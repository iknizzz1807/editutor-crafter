{"html":"<h1 id=\"blue-origin-a-foundational-cdn-for-learning-distributed-systems\">Blue Origin: A Foundational CDN for Learning Distributed Systems</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This project builds a foundational Content Delivery Network (CDN) that accelerates web content delivery by caching copies at geographically distributed &#39;edge&#39; servers. The key architectural challenge is designing a multi-tiered, consistent, and resilient caching system that dramatically reduces latency and origin load while handling real-world complexities like invalidation and request storms.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the foundational understanding and motivation for the entire CDN project. It underpins the challenges addressed by all five milestones.</p>\n</blockquote>\n<p>Delivering web content at a global scale presents a fundamental engineering challenge. When a user in Tokyo clicks a link hosted on a server in New York, the request and the data must travel across thousands of miles of network infrastructure. This journey is fraught with latency, bottlenecks, and points of failure. A <strong>Content Delivery Network (CDN)</strong> is the distributed systems solution to this problem, transforming the internet&#39;s architecture from a hub-and-spoke model into a mesh of local delivery points. Building a CDN is a classic, complex distributed systems problem because it requires elegantly balancing consistency, performance, resilience, and scale across many independent nodes. Before we delve into <em>how</em> to build one, we must deeply understand the <em>why</em>—the core problem it solves and the architectural constraints it operates within.</p>\n<h3 id=\"mental-model-the-global-library-system\">Mental Model: The Global Library System</h3>\n<p>Imagine a single, massive central library (the <strong>Origin Server</strong>) that holds every book (web resource) for a worldwide audience. A reader (the <strong>Client</strong>) in a distant city wants a popular novel. Under the naive model, the reader must request the book from the central library, wait for it to be packaged and shipped across continents, and then receive it. This is slow, expensive in shipping costs (bandwidth), and overwhelms the central library&#39;s staff (CPU) and shipping docks (network interface) whenever a book becomes popular.</p>\n<p>A CDN is analogous to building a network of local branch libraries (<strong>Edge Caches</strong>) in every major city. When the first reader in Tokyo requests the novel, the local branch fetches a copy from the central library and stores it on its own shelves. When the next reader in Tokyo requests the same book, the branch library can serve it immediately from its local stock—a <strong>Cache Hit</strong>. The experience is dramatically faster, cheaper, and relieves the central library.</p>\n<p>This simple analogy breaks down at scale, revealing the true complexity:</p>\n<ul>\n<li><strong>Shelf Space Management:</strong> Branch libraries have limited shelf space (memory/disk). They must decide which books to keep (<strong>Cache Eviction Policy</strong>) when new ones arrive.</li>\n<li><strong>Updated Editions:</strong> When the central library releases a revised edition of the novel (the origin content changes), all branch copies become outdated. The system needs a way to notify branches to discard their old copies (<strong>Cache Invalidation</strong>).</li>\n<li><strong>Rush Hours:</strong> If a famous author announces a new book at noon, thousands of readers might arrive at their local branch at the same moment before any copy is on the shelf. If every branch then simultaneously calls the central library, it will be overwhelmed (<strong>Cache Miss Storm</strong>). A smart system might have regional distribution centers (<strong>Origin Shields</strong>) that coordinate a single fetch and then supply all local branches.</li>\n<li><strong>Finding Your Nearest Branch:</strong> A reader must be directed to their closest, operational branch (<strong>Geo-Routing</strong> and <strong>Health Checking</strong>), not just the geographically nearest one that might be closed for maintenance.</li>\n</ul>\n<p>This project, Blue Origin, is about designing and building the systems and protocols that make this &quot;global library network&quot; intelligent, efficient, and robust.</p>\n<h3 id=\"the-core-delivery-problem\">The Core Delivery Problem</h3>\n<p>Serving content from a single origin server to a global user base creates three critical, interconnected problems:</p>\n<ol>\n<li><p><strong>Latency (The Speed of Light Problem):</strong> Network latency is governed by physics. A request/response round-trip between Tokyo and New York cannot be faster than the time light takes to travel that distance through fiber optics, which is roughly 100-200 milliseconds for a single trip. When a webpage requires dozens of resources (HTML, CSS, JavaScript, images), this delay compounds, leading to slow page loads. The <strong>propagation delay</strong> is fixed; the only way to reduce it is to shorten the physical distance between the user and the content.</p>\n</li>\n<li><p><strong>Origin Load &amp; Scalability (The Stampede Problem):</strong> An origin server has finite capacity—CPU, memory, network bandwidth, and I/O. A sudden surge in traffic (a &quot;flash crowd&quot; from a popular news article or a product launch) can easily exceed this capacity, causing the server to slow to a crawl or crash. This is economically inefficient; serving a static image file does not require the origin&#39;s expensive application logic, yet it consumes critical resources. The goal is to <strong>offload</strong> repetitive, simple work from the origin.</p>\n</li>\n<li><p><strong>Availability &amp; Resilience (The Single Point of Failure Problem):</strong> A single origin server (or even a single data center) represents a <strong>single point of failure</strong>. A network partition, a power outage, or a hardware failure in that location can make the service entirely unavailable to all users, everywhere. A distributed system must be designed to <strong>degrade gracefully</strong>, continuing to serve users even when components fail.</p>\n</li>\n</ol>\n<p>The CDN directly attacks these three problems:</p>\n<ul>\n<li><strong>Against Latency:</strong> By placing <strong>edge nodes</strong> in hundreds of locations (<strong>Points of Presence</strong>, or PoPs) close to users, the physical distance for most requests is reduced to tens of miles, cutting latency from hundreds of milliseconds to single-digit milliseconds.</li>\n<li><strong>Against Origin Load:</strong> By <strong>caching</strong> (storing) copies of content at the edge, repeated requests for the same resource are served locally without touching the origin. This can reduce origin traffic by 90% or more for cacheable content.</li>\n<li><strong>Against Availability Issues:</strong> With many distributed edge nodes, the failure of one node affects only a subset of users. Furthermore, cached content can often be served even if the origin is temporarily unavailable (<strong>Serve Stale</strong>), providing a buffer for origin recovery.</li>\n</ul>\n<p>The architectural challenge lies in making this distribution appear seamless, consistent, and automatic to both the end user and the content provider.</p>\n<h3 id=\"existing-approaches-amp-vocabulary\">Existing Approaches &amp; Vocabulary</h3>\n<p>To ground our design, it&#39;s essential to understand the landscape of existing solutions and establish a precise vocabulary.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Approach</th>\n<th align=\"left\">Description</th>\n<th align=\"left\">Key Characteristics</th>\n<th align=\"left\">Relation to Our Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Commercial CDNs</strong> (Cloudflare, Akamai, Fastly)</td>\n<td align=\"left\">Full-service, global networks offering caching, security, load balancing, and optimization as a service.</td>\n<td align=\"left\">Proprietary, massively scaled software and hardware. Use advanced routing (Anycast), extensive PoPs, and offer rich control APIs.</td>\n<td align=\"left\">Our inspiration and conceptual blueprint. We are building a foundational, educational version of their core caching layer.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Open-Source Caching Proxies</strong> (Varnish Cache, NGINX, Apache Traffic Server)</td>\n<td align=\"left\">Software that can be deployed on a server to act as a reverse proxy with caching capabilities.</td>\n<td align=\"left\">Single-node or manually configured clusters. Powerful configuration languages (VCL for Varnish). Often form the building blocks of DIY CDNs.</td>\n<td align=\"left\">Our edge cache component will implement logic similar to Varnish&#39;s core HTTP caching. We use their design (e.g., surrogate keys) as a specification.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Cloud Provider CDN Services</strong> (AWS CloudFront, Google Cloud CDN, Azure CDN)</td>\n<td align=\"left\">Managed CDN services integrated with the provider&#39;s other cloud services (storage, compute).</td>\n<td align=\"left\">Tightly coupled with the provider&#39;s ecosystem. Often simpler to set up but less customizable than commercial CDNs.</td>\n<td align=\"left\">Illustrates the integration of a CDN with origin services (like object storage).</td>\n</tr>\n</tbody></table>\n<p><strong>Core Vocabulary</strong>\nUnderstanding these terms is crucial for the rest of the document:</p>\n<ul>\n<li><strong>Origin / Origin Server:</strong> The ultimate source of truth for content. This is the application server (e.g., <code>api.example.com</code>) or storage bucket (e.g., <code>assets.example.com</code>) that the CDN is protecting and accelerating.</li>\n<li><strong>Edge Node / Edge Server / PoP (Point of Presence):</strong> A geographically distributed server that caches content and serves requests directly to users. It is the &quot;front line&quot; of the CDN.</li>\n<li><strong>Cache Hit:</strong> When a user&#39;s request can be served entirely from the edge node&#39;s local cache. This is the ideal outcome, providing the lowest latency and zero origin load.</li>\n<li><strong>Cache Miss:</strong> When the requested resource is not in the edge node&#39;s cache (or is stale and invalid). The edge node must fetch a fresh copy from upstream (either an origin shield or the origin itself).</li>\n<li><strong>Origin Shield / Mid-Tier Cache:</strong> An optional caching layer between the edge nodes and the origin. It acts as a &quot;super-edge&quot; or regional aggregator to further reduce requests to the origin and provide request collapsing.</li>\n<li><strong>Control Plane:</strong> The management and coordination layer of the CDN. It handles configuration distribution, analytics aggregation, and invalidation propagation. It is distinct from the <strong>Data Plane</strong> (the edge nodes) that handles user traffic.</li>\n<li><strong>TTL (Time-To-Live):</strong> The duration, in seconds, that a cached resource is considered fresh. After this time, it becomes stale and should be revalidated or refetched.</li>\n<li><strong>Invalidation / Purging:</strong> The active removal of content from the cache before its TTL expires, typically because the origin content has changed.</li>\n<li><strong>Geo-Routing:</strong> Directing a user&#39;s request to the geographically closest (or otherwise optimal) edge node, often based on the user&#39;s IP address.</li>\n</ul>\n<p>This project synthesizes principles from all these approaches. We take the robust HTTP caching semantics from Varnish and RFC 9111, the distributed architecture concepts from commercial CDNs, and build them into a cohesive, understandable system. The following sections detail the design of each component, starting with the heart of the system: the edge cache.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1 through 5)</p>\n</blockquote>\n<p>This section precisely defines the scope of the &quot;Blue Origin&quot; CDN project. For an educational project of this complexity, clear boundaries are essential to maintain focus on the core distributed systems concepts while acknowledging that a production-grade CDN encompasses many additional features. The goals are directly mapped to the five project milestones, while the non-goals explicitly exclude features that, while important in commercial CDNs, would distract from the foundational learning objectives.</p>\n<h3 id=\"goals-what-we-must-build\">Goals (What We Must Build)</h3>\n<p>These goals represent the complete set of functional requirements that the &quot;Blue Origin&quot; CDN must implement. Each goal is aligned with one of the five project milestones, ensuring progressive implementation of increasingly sophisticated CDN capabilities.</p>\n<p><strong>Milestone 1: Edge Cache Implementation</strong></p>\n<ul>\n<li><strong>HTTP Caching with RFC 9111 Compliance:</strong> Implement an edge server that acts as a compliant HTTP cache, intercepting client requests and serving cached responses when possible. The cache must respect standard HTTP caching headers (<code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>).</li>\n<li><strong>Sophisticated Cache Key Generation:</strong> Construct cache keys that uniquely identify resources by combining the request URL with the values of headers listed in the <code>Vary</code> response header (e.g., <code>Accept-Encoding</code>, <code>Accept-Language</code>). Correctly handle the special case of <code>Vary: *</code>, which indicates the resource should never be cached.</li>\n<li><strong>TTL Hierarchy and Freshness Management:</strong> Implement a multi-layered Time-To-Live (TTL) logic that prioritizes cache directives in the correct order: <code>s-maxage</code> (for shared caches like CDNs), <code>max-age</code>, and finally the <code>Expires</code> header. Maintain metadata for each cache entry indicating its freshness lifetime and current state (fresh, stale).</li>\n<li><strong>Cache Validation with Conditional Requests:</strong> Support <code>If-None-Match</code> (with <code>ETag</code>) and <code>If-Modified-Since</code> (with <code>Last-Modified</code>) conditional requests from clients. When a cached resource is stale, the edge should issue a conditional request to the upstream (shield or origin) and serve a <code>304 Not Modified</code> response if the content is unchanged, saving bandwidth.</li>\n<li><strong>Stale Content Serving Strategies:</strong> Implement <code>stale-while-revalidate</code> and <code>stale-if-error</code> behaviors, allowing the cache to serve stale content while asynchronously revalidating it with the origin or when the origin is unavailable, improving availability and perceived performance.</li>\n<li><strong>Memory Management with Eviction Policies:</strong> Implement a bounded cache storage (e.g., based on entry count or memory usage) with a configurable eviction policy—either <strong>LRU (Least Recently Used)</strong> or <strong>LFU (Least Frequently Used)</strong>—to remove the least valuable entries when capacity is exceeded.</li>\n</ul>\n<p><strong>Milestone 2: Cache Invalidation</strong></p>\n<ul>\n<li><strong>Programmatic Purge API:</strong> Expose an administrative HTTP API (e.g., <code>PURGE /path/to/resource</code>) that immediately removes a specific cached resource from the edge cache. The next request for that resource must trigger a fresh fetch from the origin.</li>\n<li><strong>Tag-Based Invalidation with Surrogate Keys:</strong> Support the <code>Surrogate-Key</code> response header, allowing the origin to assign one or more tags (keys) to a cached resource. Implement a purge-by-tag API (e.g., <code>PURGE /purge/tag/KEY</code>) that invalidates all resources tagged with that key in a single operation, enabling efficient bulk invalidation of related content (e.g., all product pages when a category changes).</li>\n<li><strong>Pattern-Based Invalidation (Bans):</strong> Implement &quot;ban&quot; functionality that invalidates cache entries matching a pattern (e.g., a URL path prefix like <code>/api/products/*</code> or a regular expression). Bans are evaluated lazily when a request matches the pattern, rather than scanning the entire cache upfront.</li>\n<li><strong>Soft Purge (Graceful Invalidation):</strong> Support a &quot;soft purge&quot; operation that marks content as stale but continues to serve it to clients while asynchronously revalidating it in the background. This provides a smoother user experience compared to a hard purge, which might cause a temporary slowdown as all clients trigger simultaneous cache misses.</li>\n<li><strong>Distributed Invalidation Propagation:</strong> Design a mechanism for propagating invalidation commands (purges, bans, tag purges) from one edge node to all other edge nodes in the CDN, ensuring eventual consistency of the cache state across the network. This propagation should complete within a configurable time window.</li>\n</ul>\n<p><strong>Milestone 3: Origin Shield &amp; Request Collapsing</strong></p>\n<ul>\n<li><strong>Mid-Tier Caching Layer:</strong> Implement an <strong>origin shield</strong> server that sits between the edge nodes and the origin server. It acts as a shared, secondary cache tier, absorbing repeated requests from multiple edge nodes for the same resource.</li>\n<li><strong>Request Collapsing (Coalescing):</strong> When the shield receives multiple concurrent requests for the same uncached resource (identical cache key), it should collapse them into a single upstream request to the origin. The resulting response is then broadcast to all waiting requestors, dramatically reducing load on the origin during &quot;cache miss storms&quot; or &quot;thundering herd&quot; scenarios.</li>\n<li><strong>Request Queuing and Timeout Management:</strong> For collapsed requests, implement a fair queuing mechanism where subsequent requests for the same key wait for the ongoing fetch to complete. This queue must have a timeout shorter than the client&#39;s timeout to prevent clients from waiting indefinitely if the upstream fetch hangs.</li>\n<li><strong>Negative Caching:</strong> Cache error responses (like <code>404 Not Found</code> or <code>5xx</code> origin errors) with a short, configurable TTL. This prevents a flood of requests to the origin for non-existent or temporarily failing resources.</li>\n<li><strong>Origin Load Protection:</strong> Implement circuit breakers or concurrency limits at the shield to prevent overwhelming the origin server with too many simultaneous requests, even during massive traffic spikes.</li>\n</ul>\n<p><strong>Milestone 4: Edge Node Distribution &amp; Routing</strong></p>\n<ul>\n<li><strong>Multi-Node Edge Network:</strong> Architect the CDN to consist of multiple, geographically distributed <strong>edge nodes</strong> (Points of Presence). Each node runs the edge caching software independently but coordinates for invalidation and analytics.</li>\n<li><strong>Geo-Aware Client Routing:</strong> Implement a routing mechanism that directs client requests to the <strong>nearest</strong> healthy edge node based on the client&#39;s IP address. This reduces latency by minimizing network distance.</li>\n<li><strong>Health Checking and Failover:</strong> Implement active health checks between a <strong>control plane</strong> (or routing layer) and edge nodes. Unhealthy nodes should be automatically removed from the routing table, and traffic should be redirected to the next-nearest healthy node, ideally within 5 seconds of failure detection.</li>\n<li><strong>Consistent Hashing for Cache Distribution:</strong> Use consistent hashing to distribute content keys across the pool of edge nodes. This ensures that requests for a given resource are generally routed to the same edge node, improving cache efficiency. More importantly, it minimizes cache reshuffling (the &quot;thundering herd&quot; effect on origin) when nodes are added or removed, as only a fraction of keys need to be remapped.</li>\n<li><strong>Control Plane for Coordination:</strong> Implement a simple control plane that edge nodes register with, report health to, and receive configuration/invalidation commands from. This decouples the data plane (serving user requests) from the management plane.</li>\n</ul>\n<p><strong>Milestone 5: CDN Analytics &amp; Performance Optimization</strong></p>\n<ul>\n<li><strong>Cache Performance Analytics:</strong> Track and expose real-time metrics for each edge node and the shield, including cache hit ratio (hits/requests), bandwidth saved, and breakdown by content type or URL pattern.</li>\n<li><strong>On-the-Fly Content Compression:</strong> Implement response body compression at the edge for text-based content (HTML, CSS, JS, JSON). Support both <code>gzip</code> (widely compatible) and <code>Brotli</code> (better compression) algorithms, selecting the best based on the client&#39;s <code>Accept-Encoding</code> header and configurable quality/CPU trade-offs.</li>\n<li><strong>HTTP Range Request Support:</strong> Fully support the <code>Range</code> and <code>If-Range</code> request headers for partial content delivery. This is critical for large files (videos, software downloads) and adaptive bitrate streaming. The cache must be able to store, serve, and revalidate partial responses.</li>\n<li><strong>Advanced Stale-While-Revalidate:</strong> Extend the Milestone 1 implementation with robust background revalidation logic, ensuring that stale content served under <code>stale-while-revalidate</code> is eventually updated without impacting client response times.</li>\n</ul>\n<h3 id=\"non-goals-what-we-explicitly-won39t-build\">Non-Goals (What We Explicitly Won&#39;t Build)</h3>\n<p>The following features are commonly found in commercial CDN offerings but are explicitly out of scope for this educational project. This focus allows us to delve deep into core caching, distribution, and invalidation patterns without being overwhelmed by peripheral concerns.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Non-Goal</th>\n<th align=\"left\">Reason for Exclusion</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Full TLS/SSL Termination &amp; Certificate Management</strong></td>\n<td align=\"left\">While HTTPS is mandatory for the modern web, implementing TLS (key exchange, certificate validation, SNI, OCSP stapling) is a complex domain in itself. We assume TLS is handled by a reverse proxy (like NGINX or Caddy) in front of our edge node. Our CDN will work with plain HTTP or behind a TLS terminator.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Distributed Denial of Service (DDoS) Protection</strong></td>\n<td align=\"left\">Mitigating large-scale attack traffic requires specialized infrastructure (scrubbing centers, anycast routing, rate limiting at line speed) and threat intelligence. It&#39;s a critical production feature but orthogonal to learning caching architecture.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Web Application Firewall (WAF)</strong></td>\n<td align=\"left\">Scanning HTTP traffic for SQL injection, XSS, and other OWASP Top 10 vulnerabilities involves complex rule engines and security expertise. It&#39;s a valuable add-on layer but not part of the core CDN data plane.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Video Transcoding &amp; Adaptive Bitrate Streaming</strong></td>\n<td align=\"left\">Transforming video formats (e.g., to HLS or DASH manifests) requires significant CPU/GPU resources and media expertise. Our CDN will <strong>deliver</strong> video files efficiently (with range request support) but not <strong>transform</strong> them.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Dynamic Content Acceleration (DSA) &amp; API Optimization</strong></td>\n<td align=\"left\">Techniques for caching personalized or non-cacheable content (e.g., via Edge Side Includes, sophisticated request/response transformation) involve complex business logic integration. We focus on static and cacheable dynamic content.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Real User Monitoring (RUM) &amp; Synthetic Monitoring</strong></td>\n<td align=\"left\">Collecting fine-grained performance data from end-user browsers and running synthetic tests from various locations is a vast analytics domain. Our analytics are server-side focused (hit ratios, bandwidth).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Object Storage Integration as Origin</strong></td>\n<td align=\"left\">While many CDNs pull from cloud storage (S3, GCS), implementing the authentication (AWS SigV4) and semantics of various storage backends adds complexity. Our origin is assumed to be a standard HTTP web server.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Multi-CDN Failover &amp; Intelligent Traffic Steering</strong></td>\n<td align=\"left\">Switching traffic between different CDN providers based on performance is a strategic layer above a single CDN&#39;s operation. We build one CDN, not an orchestrator of many.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Edge Computing (Serverless Functions at Edge)</strong></td>\n<td align=\"left\">Executing customer-provided JavaScript/Wasm code at the edge (like Cloudflare Workers) is a paradigm shift from caching. Our edge nodes are pure caching/proxy servers.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Detailed Billing &amp; Usage Reporting</strong></td>\n<td align=\"left\">Metering traffic per customer and generating invoices is a business support system, not a core distributed systems challenge.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The choice of non-goals reflects a fundamental learning strategy: depth over breadth. By implementing the data plane of a CDN—caching, distribution, invalidation, shielding—you grapple with the essential problems of state replication, consistency, and fault tolerance in distributed systems. These concepts transfer to countless other domains, whereas the non-goals listed are more specialized verticals (security, media, finance).</p>\n</blockquote>\n<h4 id=\"why-these-boundaries-matter\">Why These Boundaries Matter</h4>\n<p>Establishing clear non-goals prevents <strong>scope creep</strong>, which is the enemy of a successful educational project. For example:</p>\n<ul>\n<li><strong>TLS Termination:</strong> Adding TLS would require diving into cryptography libraries, PKI, and potentially performance optimizations like TLS session resumption. This could easily consume more time than the caching logic itself.</li>\n<li><strong>DDoS Protection:</strong> Building even basic rate limiting is valuable, but advanced DDoS mitigation involves network-level filtering and global threat intelligence feeds, which are impractical to simulate in a learning environment.</li>\n<li><strong>WAF:</strong> Writing a secure WAF rule engine is a project unto itself and requires deep security knowledge to avoid creating bypass vulnerabilities.</li>\n</ul>\n<p>By stating these exclusions upfront, we channel all effort into the <strong>core value proposition of a CDN</strong>: reducing latency and origin load through intelligent caching and geographic distribution. The architecture we design, however, remains compatible with these additional features—they could be added as layers in front of or behind our caching logic, following the Unix philosophy of composable components.</p>\n<blockquote>\n<p><strong>Milestone Checkpoint 0 - Scoping Validation:</strong> Before writing any code, verify your understanding of the project&#39;s scope. Write a brief document answering: 1) What are the five core capabilities my CDN must have? 2) For each non-goal, what is an alternative (e.g., using an existing tool) to achieve that functionality in a production deployment? This ensures you won&#39;t accidentally start implementing features that are out of scope.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical starting points for organizing your codebase and implementing the scoped features. Since Python is the primary language, guidance will focus on Pythonic patterns and libraries.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Getting Started)</th>\n<th align=\"left\">Advanced Option (For Exploration)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>HTTP Server (Edge/Shield)</strong></td>\n<td align=\"left\"><code>http.server</code> (standard library) - Simple, built-in.</td>\n<td align=\"left\"><code>aiohttp</code> (async) - High performance, supports HTTP/1.1 fully.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>HTTP Client (to upstream)</strong></td>\n<td align=\"left\"><code>urllib.request</code> (standard library) - Simple.</td>\n<td align=\"left\"><code>httpx</code> (sync or async) - Modern, supports HTTP/2, connection pooling.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Cache Storage</strong></td>\n<td align=\"left\"><code>functools.lru_cache</code> or <code>dict</code> with custom eviction - In-memory, simple.</td>\n<td align=\"left\"><code>redis</code> (via <code>redis-py</code>) - External, distributed, persistent.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Data Serialization</strong></td>\n<td align=\"left\"><code>pickle</code> for caching objects (careful with security).</td>\n<td align=\"left\"><code>msgpack</code> or <code>orjson</code> - Faster, more compact than JSON.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Concurrency Control</strong></td>\n<td align=\"left\"><code>threading.Lock</code> / <code>queue.Queue</code></td>\n<td align=\"left\"><code>asyncio</code> with locks and queues - More scalable for I/O.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Health Checks</strong></td>\n<td align=\"left\">Simple TCP/HTTP ping in a background thread.</td>\n<td align=\"left\"><code>aiohttp</code> client with timeout and retry logic.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>GeoIP Lookup</strong></td>\n<td align=\"left\"><code>geoip2</code> library with free MaxMind GeoLite2 database.</td>\n<td align=\"left\">Integration with a paid, more accurate GeoIP service API.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Metrics &amp; Analytics</strong></td>\n<td align=\"left\"><code>prometheus_client</code> - Exposes metrics for Prometheus.</td>\n<td align=\"left\">Custom time-series storage (e.g., InfluxDB) or logging to ELK stack.</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<p>Organize your project from the start to separate concerns and make milestones map to clear code modules.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin_cdn/\n├── README.md\n├── pyproject.toml (or requirements.txt)\n├── src/\n│   ├── blue_origin/\n│   │   ├── __init__.py\n│   │   ├── main.py                      # Entry point, CLI parsing\n│   │   ├── config.py                    # Configuration loading (YAML/TOML)\n│   │   ├── metrics.py                   # Prometheus metrics setup (Milestone 5)\n│   │   ├── control_plane/               # Milestone 4\n│   │   │   ├── __init__.py\n│   │   │   ├── server.py                # Control plane HTTP API\n│   │   │   ├── registry.py              # Edge node registration\n│   │   │   └── health_checker.py        # Active health checks\n│   │   ├── edge/                        # Milestone 1 &amp; 5\n│   │   │   ├── __init__.py\n│   │   │   ├── server.py                # Main HTTP request handler\n│   │   │   ├── cache/                   # Caching logic core\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── storage.py           # CacheStorage class (LRU, etc.)\n│   │   │   │   ├── key_generator.py     # Cache key creation\n│   │   │   │   ├── ttl_manager.py       # Freshness/expiry logic\n│   │   │   │   └── validator.py         # Conditional request handling (304)\n│   │   │   ├── compression.py           # Brotli/gzip middleware (Milestone 5)\n│   │   │   ├── range_handler.py         # HTTP Range support (Milestone 5)\n│   │   │   └── analytics.py             # Hit/miss tracking (Milestone 5)\n│   │   ├── invalidation/                # Milestone 2\n│   │   │   ├── __init__.py\n│   │   │   ├── api.py                   # PURGE/ban HTTP API endpoints\n│   │   │   ├── purge.py                 # Purge by URL/tag logic\n│   │   │   ├── ban.py                   # Ban pattern matching &amp; storage\n│   │   │   ├── tags.py                  # Surrogate key index management\n│   │   │   └── broadcaster.py           # Propagate invalidations (pub/sub)\n│   │   ├── shield/                      # Milestone 3\n│   │   │   ├── __init__.py\n│   │   │   ├── server.py                # Shield HTTP handler (similar to edge)\n│   │   │   ├── request_coalescer.py     # Request collapsing &amp; queuing logic\n│   │   │   ├── negative_cache.py        # Cache for error responses\n│   │   │   └── circuit_breaker.py       # Origin load protection\n│   │   ├── routing/                     # Milestone 4\n│   │   │   ├── __init__.py\n│   │   │   ├── geo_router.py            # Map client IP to nearest edge\n│   │   │   ├── consistent_hashing.py    # Consistent hashing ring\n│   │   │   └── health.py                # Health check logic (used by edge/shield)\n│   │   └── utils/\n│   │       ├── __init__.py\n│   │       ├── http_utils.py            # Header parsing, date formatting\n│   │       └── logging.py               # Structured logging setup\n└── tests/                               # Comprehensive test suite\n    ├── unit/\n    └── integration/</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here is a complete, reusable utility for parsing HTTP caching headers—a prerequisite for Milestone 1.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/utils/http_utils.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> email.utils</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Tuple, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheDirectives</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parsed Cache-Control directives relevant to a CDN.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s_maxage: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_age: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_cache: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_store: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    must_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proxy_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    public: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    private: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_while_revalidate: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_if_error: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_header</span><span style=\"color:#E1E4E8\">(cls, cache_control_header: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#9ECBFF\">'CacheDirectives'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse a Cache-Control header string into a structured object.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        directives </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> cache_control_header:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [token.strip().lower() </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> cache_control_header.split(</span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> tokens:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#9ECBFF\"> '='</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> token:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                key, value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.split(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> key.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    value_int </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(value.strip())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span><span style=\"color:#6A737D\">  # Ignore malformed integer values</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 's-maxage'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.s_maxage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value_int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'max-age'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.max_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value_int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'stale-while-revalidate'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.stale_while_revalidate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value_int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'stale-if-error'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.stale_if_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value_int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'no-cache'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.no_cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'no-store'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.no_store </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'must-revalidate'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.must_revalidate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'proxy-revalidate'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.proxy_revalidate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'public'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.public </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'private'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.private </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(date_str: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse an RFC 1123/822 date string into a Unix timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns None if the string is invalid or empty.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> date_str:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> email.utils.parsedate_to_datetime(date_str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> dt.tzinfo </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dt.replace(</span><span style=\"color:#FFAB70\">tzinfo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dt.timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_response_cacheable</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_control: CacheDirectives,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vary_header: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determine if a response can be stored in the cache per RFC 9111.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        status_code: HTTP status code.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        method: Request method (only GET and HEAD are cacheable by default).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        cache_control: Parsed Cache-Control directives.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        vary_header: Value of the Vary header.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if the response is cacheable, False otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Section 3: https://httpwg.org/specs/rfc9111.html#caching.overview</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> method </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'GET'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'HEAD'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cache_control.no_store:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cache_control.private:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">  # Private responses are not cacheable by shared caches (CDN)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> vary_header </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '*'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">  # Vary: * means never cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Generally, only successful responses are cached (200, 203, 206, 300, 301, 308, 404, 405, 410, 414, 501)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For simplicity, we'll cache 200, 206, 301, 302, 304 (304 is for validation, not stored), 404, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cacheable_statuses </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">203</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">204</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">206</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">300</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">301</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">302</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">303</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">307</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">308</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Note: 304 Not Modified is a response to a conditional request and does not contain a body to cache.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> status_code </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> cacheable_statuses:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> True</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>For the central caching logic (Milestone 1), here is a skeleton for the main request handler method on the edge node.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/edge/server.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> http.client </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HTTPResponse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .cache.storage </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheStorage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .cache.key_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_cache_key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .cache.ttl_manager </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TTLManager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .cache.validator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> validate_conditional_request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.http_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheDirectives, parse_http_date, is_response_cacheable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache_storage: CacheStorage, upstream_url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache_storage</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.upstream </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> upstream_url  </span><span style=\"color:#6A737D\"># Could be shield or origin URL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main request handling algorithm for the edge node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_headers: Dictionary of HTTP request headers.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_body: Raw request body.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (status_code, response_headers, response_body).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        method </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_headers.get(</span><span style=\"color:#9ECBFF\">':method'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'GET'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        url </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_headers.get(</span><span style=\"color:#9ECBFF\">':path'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate cache key from request URL and Vary header dimensions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Extract headers listed in any existing Vary header from the cache.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - For initial lookup, use a provisional key (just URL). After fetching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     from upstream, you'll know the full Vary headers and can store correctly.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> generate_cache_key(url, request_headers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Look up the cache key in the cache storage.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cache.get(cache_key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cache_entry:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if the cached entry is fresh using TTLManager.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - Calculate age from Date header and current time.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - Compare against s-maxage, max-age, Expires.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   - Determine if it's fresh, stale, or needs revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            freshness_state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TTLManager.check_freshness(cache_entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If fresh, serve directly from cache (cache hit).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> freshness_state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'fresh'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Apply any request collapsing for Range headers if present.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> cache_entry.status, cache_entry.headers, cache_entry.body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If stale but allowed by stale-while-revalidate, serve stale</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   and trigger asynchronous revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> freshness_state </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'stale'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> TTLManager.can_serve_stale(cache_entry):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Fire-and-forget background revalidation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">._revalidate_in_background(cache_key, cache_entry, request_headers)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> cache_entry.status, cache_entry.headers, cache_entry.body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If cache entry exists but is stale and needs validation,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   build a conditional request (If-None-Match, If-Modified-Since)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   using the cached entry's ETag and Last-Modified.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            conditional_headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> validate_conditional_request(cache_entry, request_headers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Forward to upstream with conditional headers...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Cache miss or needs revalidation: forward request to upstream.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Merge conditional headers if this is a revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Use a connection pool for efficiency.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        upstream_response </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._fetch_from_upstream(request_headers, request_body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Parse upstream response headers and check if cacheable.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_control </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CacheDirectives.from_header(upstream_response.headers.get(</span><span style=\"color:#9ECBFF\">'Cache-Control'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> is_response_cacheable(upstream_response.status, method, cache_control, upstream_response.headers.get(</span><span style=\"color:#9ECBFF\">'Vary'</span><span style=\"color:#E1E4E8\">)):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: If cacheable, compute final cache key with actual Vary header values.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            final_cache_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> generate_cache_key(url, request_headers, upstream_response.headers.get(</span><span style=\"color:#9ECBFF\">'Vary'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Store the response in cache with computed TTL.</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.cache.set(final_cache_key, upstream_response, cache_control)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 12: Return the response to the client.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> upstream_response.status, upstream_response.headers, upstream_response.body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _revalidate_in_background</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, cache_entry, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Asynchronously revalidate a stale cache entry.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement background thread or async task to revalidate.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _fetch_from_upstream</span><span style=\"color:#E1E4E8\">(self, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Forward request to upstream (shield or origin).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement HTTP client with connection pooling.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python)</strong></p>\n<ul>\n<li><strong>Concurrency:</strong> Use <code>threading.Lock</code> for simple mutexes around the cache storage. For request collapsing at the shield, <code>threading.Condition</code> is ideal for waiting/notifying threads.</li>\n<li><strong>Data Structures:</strong> Use <code>collections.OrderedDict</code> to implement an LRU cache easily. For LFU, you&#39;ll need a more complex structure (e.g., a dict plus a min-heap or <code>SortedDict</code>).</li>\n<li><strong>HTTP Dates:</strong> Always work with UTC timestamps internally. Use <code>email.utils.formatdate</code> to generate RFC 1123 dates for responses.</li>\n<li><strong>Performance:</strong> For header parsing, avoid repeated string splits. Consider caching parsed <code>CacheDirectives</code> objects alongside the cached response.</li>\n<li><strong>Testing:</strong> Use <code>unittest.mock</code> to simulate upstream origin responses and test cache behavior without a network.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint for Goals</strong></p>\n<p>After reading this section, you should be able to clearly articulate what you will and won&#39;t build. A good checkpoint is to create a simple markdown table in your project notes mapping each milestone to the 2-3 most critical deliverables. For example:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Milestone</th>\n<th align=\"left\">Critical Deliverable</th>\n<th align=\"left\">Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">Cache serves cached response for same URL</td>\n<td align=\"left\"><code>curl</code> twice, second response has <code>X-Cache: HIT</code> header</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code>PURGE /api/purge</code> removes cached item</td>\n<td align=\"left\"><code>curl</code> after purge shows <code>X-Cache: MISS</code></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">Two simultaneous requests for same uncached resource result in one origin fetch</td>\n<td align=\"left\">Logs show only one upstream request</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">Client IP from US routes to US edge node IP</td>\n<td align=\"left\"><code>dig</code> or <code>curl</code> shows different IPs for different geo-locations</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">Text response is served with <code>Content-Encoding: gzip</code></td>\n<td align=\"left\">Response headers show compression</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1 through 5)<br>This section presents the architectural blueprint for the entire CDN system. Understanding this bird&#39;s-eye view is critical before diving into individual component designs, as it establishes the relationships and responsibilities that define how the system works as a whole.</p>\n</blockquote>\n<p><img src=\"/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fsys-component.svg\" alt=\"High-Level System Component Diagram\"></p>\n<h3 id=\"component-overview-amp-responsibilities\">Component Overview &amp; Responsibilities</h3>\n<p>Think of our CDN as a <strong>global postal system</strong> with specialized facilities at different distances from the end recipient:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Postal System Analogy</th>\n<th>Technical Responsibility</th>\n<th>Key Data Held</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Client</strong></td>\n<td>Letter sender/recipient</td>\n<td>Initiates HTTP requests for web content; expects fast responses</td>\n<td>None (external to CDN)</td>\n</tr>\n<tr>\n<td><strong>Edge Node</strong></td>\n<td>Local post office</td>\n<td>Serves cached content to nearby users; first point of contact</td>\n<td>Cached responses, local hit/miss counters</td>\n</tr>\n<tr>\n<td><strong>Origin Shield</strong></td>\n<td>Regional sorting facility</td>\n<td>Aggregates requests from multiple edge nodes; provides secondary cache layer</td>\n<td>Shield-level cache, request coalescing state</td>\n</tr>\n<tr>\n<td><strong>Origin Server</strong></td>\n<td>Central mail repository</td>\n<td>Ultimate source of truth for all content; serves uncached resources</td>\n<td>Original content, database, application logic</td>\n</tr>\n<tr>\n<td><strong>Control Plane</strong></td>\n<td>Postal management HQ</td>\n<td>Coordinates the network: routing, invalidation, health monitoring, analytics</td>\n<td>Node registry, routing rules, invalidation queue</td>\n</tr>\n</tbody></table>\n<p>Each component has a clearly defined responsibility that minimizes overlap and creates clean separation of concerns. The <strong>data plane</strong> (Edge Nodes and Origin Shield) handles user traffic, while the <strong>control plane</strong> manages configuration and coordination.</p>\n<h4 id=\"detailed-component-specifications\">Detailed Component Specifications</h4>\n<p><strong>Edge Node (PoP - Point of Presence)</strong>\nThe edge node is the CDN&#39;s frontline — geographically distributed servers that intercept client requests before they travel long distances to the origin. Each edge node operates autonomously but follows centralized policies.</p>\n<blockquote>\n<p><strong>Design Principle:</strong> Edge nodes should be stateless in terms of configuration but stateful in terms of cache content. They can operate independently during network partitions, serving cached content even if the control plane is unavailable.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Details</th>\n<th>Critical Interfaces</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Request Handling</strong></td>\n<td>Accepts HTTP/HTTPS connections, parses requests, generates cache keys</td>\n<td><code>EdgeRequestHandler.handle_request()</code></td>\n</tr>\n<tr>\n<td><strong>Cache Lookup &amp; Serving</strong></td>\n<td>Checks local cache storage, serves fresh content, validates stale entries</td>\n<td>Cache storage interface</td>\n</tr>\n<tr>\n<td><strong>Cache Population</strong></td>\n<td>Fetches missing content from upstream (shield or origin), stores with metadata</td>\n<td><code>_fetch_from_upstream()</code></td>\n</tr>\n<tr>\n<td><strong>TTL Enforcement</strong></td>\n<td>Respects cache-control directives, marks entries stale when expired</td>\n<td><code>CacheDirectives</code> processing</td>\n</tr>\n<tr>\n<td><strong>Local Invalidation</strong></td>\n<td>Removes entries when purge commands arrive from control plane</td>\n<td>Purge API endpoint</td>\n</tr>\n<tr>\n<td><strong>Health Reporting</strong></td>\n<td>Periodically sends heartbeat and metrics to control plane</td>\n<td>Health check endpoint</td>\n</tr>\n</tbody></table>\n<p><strong>Origin Shield (Mid-Tier Cache)</strong>\nThe origin shield sits between edge nodes and the origin, acting as a <strong>request aggregator</strong> and <strong>secondary cache</strong>. Its primary purpose is to protect the origin from being overwhelmed by cache miss storms—when many edge nodes simultaneously request the same uncached resource.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> The shield introduces a small additional latency (typically 10-50ms) but dramatically reduces origin load. For high-traffic sites, this trade-off is almost always worthwhile.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Details</th>\n<th>Key Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Request Collapsing</strong></td>\n<td>Deduplicates concurrent identical requests from multiple edge nodes</td>\n<td>Request coalescing map with waiters</td>\n</tr>\n<tr>\n<td><strong>Secondary Caching</strong></td>\n<td>Maintains its own cache (typically larger than edge caches)</td>\n<td>Shield-level cache storage</td>\n</tr>\n<tr>\n<td><strong>Negative Caching</strong></td>\n<td>Briefly caches error responses (404, 503) to prevent origin storms</td>\n<td>Short TTL for error status codes</td>\n</tr>\n<tr>\n<td><strong>Load Shedding</strong></td>\n<td>Queues or rejects requests when origin is overloaded</td>\n<td>Adaptive queuing with circuit breakers</td>\n</tr>\n<tr>\n<td><strong>Health Monitoring</strong></td>\n<td>Probes origin health and bypasses cache when origin is unhealthy</td>\n<td>Active health checks</td>\n</tr>\n</tbody></table>\n<p><strong>Control Plane</strong>\nThe control plane is the CDN&#39;s &quot;brain&quot;—it doesn&#39;t handle user traffic but ensures the data plane operates correctly and efficiently. It maintains a global view of the network.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Details</th>\n<th>Data Structures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Geo-Routing Configuration</strong></td>\n<td>Maps client IP prefixes to optimal edge nodes</td>\n<td>GeoIP database, routing tables</td>\n</tr>\n<tr>\n<td><strong>Health Monitoring</strong></td>\n<td>Collects heartbeats from edge nodes and shield</td>\n<td>Node registry with health status</td>\n</tr>\n<tr>\n<td><strong>Invalidation Propagation</strong></td>\n<td>Distributes purge commands to all relevant nodes</td>\n<td>Message queue/pub-sub system</td>\n</tr>\n<tr>\n<td><strong>Analytics Aggregation</strong></td>\n<td>Collects metrics from all nodes for reporting</td>\n<td>Time-series database of hits/misses</td>\n</tr>\n<tr>\n<td><strong>Consistent Hashing Management</strong></td>\n<td>Maintains the distribution ring for cache sharding</td>\n<td>Consistent hashing ring state</td>\n</tr>\n</tbody></table>\n<p><strong>Origin Server</strong>\nThe origin is the authoritative source for content. While not part of the CDN proper, its behavior profoundly affects CDN design.</p>\n<table>\n<thead>\n<tr>\n<th>Characteristic</th>\n<th>Implication for CDN Design</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Cache-Control Headers</strong></td>\n<td>Determines TTLs and cacheability of responses</td>\n</tr>\n<tr>\n<td><strong>ETag/Last-Modified Headers</strong></td>\n<td>Enables conditional revalidation</td>\n</tr>\n<tr>\n<td><strong>Vary Headers</strong></td>\n<td>Indicates response varies by certain request headers</td>\n</tr>\n<tr>\n<td><strong>Surrogate-Key Headers</strong></td>\n<td>Allows tag-based invalidation (custom header)</td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<p>A well-organized codebase from the start prevents architectural drift and makes the five milestones easier to implement incrementally. Below is the recommended Python package structure, organized by component and responsibility.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin_cdn/                    # Project root\n├── pyproject.toml                  # Python project configuration\n├── README.md\n├── requirements.txt\n│\n├── src/                            # Source code (installable package)\n│   └── blue_origin/\n│       ├── __init__.py\n│       │\n│       ├── data_models/            # Core data structures (Milestone 1)\n│       │   ├── __init__.py\n│       │   ├── cache_entry.py      # CacheEntry class and related structures\n│       │   ├── cache_directives.py # CacheDirectives parsing class\n│       │   └── invalidation.py     # PurgeRequest, BanRule, SurrogateKeyIndex\n│       │\n│       ├── edge/                   # Edge node implementation (Milestones 1, 5)\n│       │   ├── __init__.py\n│       │   ├── handler.py          # EdgeRequestHandler class\n│       │   ├── cache_storage.py    # CacheStorage interface and LRU implementation\n│       │   ├── cache_key.py        # Cache key generation logic\n│       │   ├── compression.py      # Gzip/Brotli compression (Milestone 5)\n│       │   ├── range_requests.py   # HTTP Range support (Milestone 5)\n│       │   └── analytics.py        # Local hit/miss tracking\n│       │\n│       ├── shield/                 # Origin shield (Milestone 3)\n│       │   ├── __init__.py\n│       │   ├── shield_handler.py   # Shield's request handler\n│       │   ├── request_coalescing.py # Request collapsing logic\n│       │   └── negative_cache.py   # Negative response caching\n│       │\n│       ├── control_plane/          # Control plane (Milestones 2, 4)\n│       │   ├── __init__.py\n│       │   ├── node_registry.py    # Tracks edge nodes and their health\n│       │   ├── geo_routing.py      # GeoIP lookup and routing logic\n│       │   ├── invalidation_bus.py # Distributes purge commands\n│       │   └── hashing_ring.py     # Consistent hashing implementation\n│       │\n│       ├── http_utils/             # Shared HTTP utilities\n│       │   ├── __init__.py\n│       │   ├── headers.py          # Header parsing utilities\n│       │   ├── cache_validation.py # is_response_cacheable() and helpers\n│       │   └── date_parsing.py     # parse_http_date() function\n│       │\n│       ├── protocols/              # Communication protocols\n│       │   ├── __init__.py\n│       │   ├── health_check.py     # Health check protocol messages\n│       │   └── invalidation_pb.py  # Invalidation protocol (could be protobuf)\n│       │\n│       └── cli/                    # Command-line interfaces\n│           ├── __init__.py\n│           ├── edge_node.py        # Starts an edge node server\n│           ├── shield_node.py      # Starts a shield node\n│           ├── control_plane.py    # Starts the control plane\n│           └── admin.py            # Admin commands (purge, ban, stats)\n│\n├── tests/                          # Comprehensive test suite\n│   ├── __init__.py\n│   ├── test_edge/\n│   ├── test_shield/\n│   ├── test_control_plane/\n│   └── integration/\n│\n├── configs/                        # Configuration files\n│   ├── edge_config.yaml.example\n│   ├── shield_config.yaml.example\n│   └── control_plane_config.yaml.example\n│\n└── scripts/                        # Deployment and utility scripts\n    ├── deploy_edge.sh\n    ├── load_test.py\n    └── geoip_update.py</code></pre></div>\n\n<h4 id=\"module-dependencies-and-import-structure\">Module Dependencies and Import Structure</h4>\n<p>The dependency flow follows the logical data flow: edge nodes depend on shared utilities and data models; the control plane is relatively independent; and the shield sits between them.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>edge/ → http_utils/ → data_models/\nshield/ → http_utils/ → data_models/\ncontrol_plane/ → protocols/ → data_models/</code></pre></div>\n\n<blockquote>\n<p><strong>Design Decision:</strong> We place the <code>CacheDirectives</code> class in <code>data_models/</code> rather than <code>http_utils/</code> because it&#39;s a core data structure used throughout the system, not just an HTTP utility. This makes it available to all components without creating circular dependencies.</p>\n</blockquote>\n<h4 id=\"configuration-management\">Configuration Management</h4>\n<p>Each component should be configurable via YAML files and environment variables:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example configuration pattern for edge node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeConfig</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    upstream_url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # URL of shield or origin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_capacity_mb: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    listen_port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8080</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    control_plane_url: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    geoip_database_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"./data/GeoIP2-City.mmdb\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_yaml</span><span style=\"color:#E1E4E8\">(cls, path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">\"EdgeConfig\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Load and validate configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p>This structure supports all five milestones:</p>\n<ul>\n<li><strong>Milestone 1 &amp; 5:</strong> <code>edge/</code> and <code>data_models/</code> directories</li>\n<li><strong>Milestone 2:</strong> <code>control_plane/invalidation_bus.py</code> and edge invalidation handling</li>\n<li><strong>Milestone 3:</strong> <code>shield/</code> directory</li>\n<li><strong>Milestone 4:</strong> <code>control_plane/geo_routing.py</code> and <code>hashing_ring.py</code></li>\n<li>Shared utilities in <code>http_utils/</code> support all milestones</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Getting Started)</th>\n<th>Advanced Option (Production-Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP Server</strong></td>\n<td>Python&#39;s <code>http.server</code> with threading</td>\n<td><code>asyncio</code> + <code>aiohttp</code> for async I/O</td>\n</tr>\n<tr>\n<td><strong>Cache Storage</strong></td>\n<td><code>dict</code> with LRU eviction using <code>collections.OrderedDict</code></td>\n<td><code>redis</code> as external cache store</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>Python <code>dataclasses</code> with YAML loading</td>\n<td><code>pydantic</code> with validation and hot reload</td>\n</tr>\n<tr>\n<td><strong>Inter-Component Comm</strong></td>\n<td>HTTP REST endpoints</td>\n<td>gRPC with Protocol Buffers for lower latency</td>\n</tr>\n<tr>\n<td><strong>GeoIP Lookup</strong></td>\n<td>Offline MaxMind DB with <code>geoip2</code> library</td>\n<td>Commercial GeoIP service with SLA</td>\n</tr>\n<tr>\n<td><strong>Metrics Collection</strong></td>\n<td>In-memory counters exposed via <code>/metrics</code> endpoint</td>\n<td><code>prometheus</code> client library + Grafana</td>\n</tr>\n<tr>\n<td><strong>Message Propagation</strong></td>\n<td>Redis Pub/Sub for invalidation events</td>\n<td>Apache Kafka for ordered, durable events</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-complete-http-utilities-starter-code\">B. Complete HTTP Utilities Starter Code</h4>\n<p>Since HTTP header parsing is a prerequisite for all components but not the core learning goal, here&#39;s complete, working code for the foundational utilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/http_utils/date_parsing.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"RFC 1123/822 date parsing utilities for HTTP caching.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> email.utils</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(date_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse an RFC 1123/822 date string into a Unix timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        date_str: Date string like \"Tue, 15 Nov 1994 08:12:31 GMT\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Unix timestamp (seconds since epoch) or None if parsing fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> date_str:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # email.utils.parsedate_to_datetime handles RFC 1123, 850, and asctime formats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> email.utils.parsedate_to_datetime(date_str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dt.timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Log warning in production</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> format_http_date</span><span style=\"color:#E1E4E8\">(timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Format a Unix timestamp to RFC 1123 string.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        timestamp: Unix timestamp in seconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        RFC 1123 formatted date string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcfromtimestamp(timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> dt.strftime(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %b</span><span style=\"color:#9ECBFF\"> %Y %H:%M:%S GMT\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/http_utils/headers.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"HTTP header parsing and manipulation utilities.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Set</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_cache_control_header</span><span style=\"color:#E1E4E8\">(header_value: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse Cache-Control header into a dictionary of directives.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        header_value: e.g., \"public, max-age=3600, stale-while-revalidate=60\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary mapping directive names to values (or None for boolean directives)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> header_value:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Split by comma, trim whitespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> part </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> header_value.split(</span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        part </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> part.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> part:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            key, value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> part.split(</span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            directives[key.strip()] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            directives[part] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Boolean directive like \"no-cache\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_header_values</span><span style=\"color:#E1E4E8\">(headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], header_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Get all values for a header (handling comma-separated and multiple headers).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    HTTP allows both comma-separated values and multiple headers with the same name.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        headers: Dictionary of header name -> value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        header_name: Header name (case-insensitive)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        List of individual header values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    normalized_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header_name.lower()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    values </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name, value </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> headers.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name.lower() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> normalized_name:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Split by comma, but be careful of quoted strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Simple implementation for most cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            values.extend([v.strip() </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> value.split(</span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">)])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> values</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/http_utils/cache_validation.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Cache validation logic per RFC 9111.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_models.cache_directives </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheDirectives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_response_cacheable</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_control: Optional[CacheDirectives],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vary_header: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Determine if a response can be stored in the cache per RFC 9111.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        status_code: HTTP status code</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        method: HTTP method of request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        cache_control: Parsed CacheDirectives object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        vary_header: Value of Vary header (or None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if the response can be cached</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # RFC 9111 Section 3: Only successful responses to GET are cacheable by default</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> method.upper() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"GET\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Status codes that are cacheable by default (per RFC 9111)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cacheable_by_default </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">203</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">204</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">206</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">300</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">301</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">308</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">405</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">410</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">414</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">501</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check for explicit no-store directive</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cache_control </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> (cache_control.no_store </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> cache_control.private):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Vary: * means never cache (RFC 9111 Section 4.1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> vary_header </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> vary_header.strip() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"*\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check if status code is cacheable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> status_code </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> cacheable_by_default:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Some status codes are cacheable only with explicit directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> status_code </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">302</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">307</span><span style=\"color:#E1E4E8\">}:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # These are cacheable if explicit freshness info is provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cache_control </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> (cache_control.max_age </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> or</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            cache_control.s_maxage </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> or</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            cache_control.public):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<h4 id=\"c-core-data-model-skeleton\">C. Core Data Model Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/data_models/cache_directives.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Structured representation of Cache-Control directives.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..http_utils.headers </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_cache_control_header</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheDirectives</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parsed Cache-Control directives from HTTP headers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s_maxage: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # For shared caches (CDN should use this)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_age: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">   # For both shared and private caches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_cache: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">          # Must revalidate with origin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_store: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">          # Don't store in cache at all</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    must_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">   # Must revalidate when stale</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proxy_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">  # Like must-revalidate but only for shared caches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    public: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">            # Explicitly cacheable by shared caches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    private: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">           # Not cacheable by shared caches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_while_revalidate: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Can serve stale while revalidating</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_if_error: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">          # Can serve stale if origin error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_header</span><span style=\"color:#E1E4E8\">(cls, cache_control_header: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#9ECBFF\">\"CacheDirectives\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse a Cache-Control header string into a structured object.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cache_control_header: Raw Cache-Control header value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            CacheDirectives object with parsed values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Call parse_cache_control_header() to get dictionary of directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Convert string values to appropriate types (ints for numeric directives)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Set boolean fields based on presence of boolean directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Handle edge cases: multiple values, invalid formats, unknown directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Ensure s-maxage takes precedence over max-age for CDN purposes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Handle contradictory directives (e.g., both public and private)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        directives </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> cache_control_header:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement parsing logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_cache_control_header(cache_control_header)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Map parsed directives to fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Example:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # if \"s-maxage\" in parsed:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     directives.s_maxage = int(parsed[\"s-maxage\"])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_cacheable_by_cdn</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Determine if this response can be cached by a CDN (shared cache).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if CDN can cache this response</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check no_store - if True, return False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check private - if True, return False (private means no shared cache)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If public is True, return True (explicitly cacheable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If no explicit directives, default is cacheable for GET requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Consider other directives that might affect cacheability</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/data_models/cache_entry.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Core cache entry data structure.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheEntry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a cached HTTP response with metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Primary key components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                         # Generated cache key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                         # Original request URL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vary_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]    </span><span style=\"color:#6A737D\"># Values for headers in Vary header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Response data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status_code: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]         </span><span style=\"color:#6A737D\"># Original response headers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#6A737D\">                     # Response body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Cache metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fetched_at: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#6A737D\">               # Unix timestamp when fetched</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expires_at: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#6A737D\">               # Unix timestamp when entry expires</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_used_at: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#6A737D\">             # For LRU eviction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    use_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">                  # For LFU eviction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Invalidation support</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    surrogate_keys: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]       </span><span style=\"color:#6A737D\"># Tags for group invalidation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Validation support</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    etag: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_modified: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_fresh</span><span style=\"color:#E1E4E8\">(self, current_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if cache entry is still fresh.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            current_time: Unix timestamp (defaults to time.time())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if entry hasn't expired</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.expires_at</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_stale_but_revalidatable</span><span style=\"color:#E1E4E8\">(self, current_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if stale entry can be served during revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            current_time: Unix timestamp</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if stale-while-revalidate period hasn't expired</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Compare current_time to expires_at + stale_while_revalidate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Need access to CacheDirectives to know stale_while_revalidate duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if within grace period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"d-edge-request-handler-skeleton\">D. Edge Request Handler Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/edge/handler.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Main request handling logic for edge nodes.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_models.cache_directives </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_models.cache_entry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheEntry</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles HTTP requests at the edge node.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache, upstream: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize handler with cache storage and upstream URL.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cache: CacheStorage implementation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            upstream: URL of shield or origin server</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.upstream </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> upstream</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main request handling algorithm for the edge node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_headers: Dictionary of HTTP request headers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_body: Raw request body</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (status_code, response_headers, response_body)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Extract request method and URL from headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Generate cache key using URL and Vary header dimensions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Look up cache entry by key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: If cache hit and fresh: return cached response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: If cache hit but stale: handle revalidation logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: If cache miss: fetch from upstream using _fetch_from_upstream()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 7: If response is cacheable: store in cache with metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 8: Apply compression if requested and appropriate (Milestone 5)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 9: Update analytics counters (hit/miss)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 10: Return final response</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement the full algorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _fetch_from_upstream</span><span style=\"color:#E1E4E8\">(self, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Forward request to upstream (shield or origin).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            headers: Request headers (may be modified)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            body: Request body</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (status_code, response_headers, response_body)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Add CDN-specific headers (e.g., X-Forwarded-For)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Make HTTP request to upstream URL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Handle timeouts and connection errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Parse response headers and body</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Extract cache directives and validation headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Return response tuple</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _revalidate_in_background</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 cache_entry: CacheEntry,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Asynchronously revalidate a stale cache entry.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cache_key: Key of stale cache entry</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cache_entry: The stale cache entry</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_headers: Original request headers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Create conditional request with If-None-Match/If-Modified-Since</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Send request to upstream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: If 304 Not Modified: update entry's expiry time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: If 200 OK: replace entry with new response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Handle errors (keep stale entry if stale-if-error allows)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: Implement proper async/threading to not block main request</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-python-specific-implementation-hints\">E. Python-Specific Implementation Hints</h4>\n<ol>\n<li><p><strong>Concurrency Model:</strong> Use threading for simplicity (<code>concurrent.futures.ThreadPoolExecutor</code>) or asyncio for high performance. For educational purposes, threading is recommended initially.</p>\n</li>\n<li><p><strong>Cache Storage:</strong> Implement <code>CacheStorage</code> as an abstract base class with concrete implementations:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> CacheStorage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#B392F0\"> get</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[CacheEntry]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, entry: CacheEntry) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#B392F0\"> delete</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   class</span><span style=\"color:#B392F0\"> LRUCacheStorage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">CacheStorage</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_size_mb: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           self</span><span style=\"color:#E1E4E8\">.max_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_size_mb </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           self</span><span style=\"color:#E1E4E8\">.current_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">           self</span><span style=\"color:#E1E4E8\">.storage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> OrderedDict()  </span><span style=\"color:#6A737D\"># Maintains insertion order</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>HTTP Date Handling:</strong> Always use UTC for HTTP dates. Python&#39;s <code>email.utils</code> module handles the complex parsing of various date formats.</p>\n</li>\n<li><p><strong>Header Case Sensitivity:</strong> HTTP headers are case-insensitive for names but case-sensitive for values. Normalize header names to lowercase when storing but preserve original casing when forwarding to origin.</p>\n</li>\n<li><p><strong>Memory Management:</strong> For the cache, estimate entry size as <code>len(body) + sum(len(k) + len(v) for k, v in headers.items())</code>. Use <code>sys.getsizeof()</code> for rough estimates but be aware it doesn&#39;t account for referenced objects.</p>\n</li>\n<li><p><strong>Testing:</strong> Use <code>unittest.mock</code> to simulate upstream servers and <code>pytest</code> for comprehensive testing. The <code>httpx</code> library is excellent for both client and server testing.</p>\n</li>\n</ol>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Edge Cache Implementation), Milestone 2 (Cache Invalidation), Milestone 5 (CDN Analytics &amp; Performance Optimization)</p>\n</blockquote>\n<p>The data model defines the foundational structures that allow the Content Delivery Network (CDN) to store, manage, and track cached content. These structures represent the <strong>&quot;state of the world&quot;</strong> for the caching system—what content is stored, where, for how long, and how it can be invalidated or analyzed. Without a well-defined data model, the system would lack the consistency needed for reliable caching operations, efficient invalidation, and meaningful performance insights. This section details three core aspects: the cache entry itself, structures for invalidation, and structures for analytics.</p>\n<h3 id=\"core-the-cache-entry\">Core: The Cache Entry</h3>\n<p><strong>Mental Model: The Cargo Container</strong>\nThink of a <code>CacheEntry</code> as a standardized shipping container. Each container has:</p>\n<ul>\n<li><strong>A unique manifest (key)</strong> that exactly describes its contents and destination.</li>\n<li><strong>The actual goods (body)</strong> – the response data being delivered.</li>\n<li><strong>Shipping labels (headers)</strong> that specify handling instructions (like compression, encoding).</li>\n<li><strong>A customs stamp (metadata)</strong> including loading time, expiration date, and tracking of how often it&#39;s been accessed.</li>\n<li><strong>Cargo tags (surrogate keys)</strong> that group this container with others from the same shipment for batch operations.</li>\n</ul>\n<p>Just as a port&#39;s efficiency depends on how quickly it can locate and retrieve the right container using its manifest, the <strong>edge cache</strong>&#39;s performance hinges on efficiently storing and retrieving <code>CacheEntry</code> objects using their <code>key</code>.</p>\n<p>The <code>CacheEntry</code> is the central data structure stored within the <code>CacheStorage</code> of each <strong>edge node</strong> and <strong>origin shield</strong>. It encapsulates a complete HTTP response along with the metadata required for HTTP caching semantics, eviction decisions, and invalidation. Its design directly implements the caching logic specified in RFC 9111.</p>\n<p>The following table details every field in the <code>CacheEntry</code>. These fields collectively enable the four key cache behaviors: freshness validation, revalidation, efficient lookup, and lifecycle management.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>key</code></td>\n<td align=\"left\"><code>str</code></td>\n<td align=\"left\">The <strong>primary lookup key</strong> for the cache storage. This is a deterministic string generated from the request URL and the values of headers specified in the <code>Vary</code> response header (e.g., <code>Accept-Encoding</code>). It uniquely identifies a cached representation of a resource.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>url</code></td>\n<td align=\"left\"><code>str</code></td>\n<td align=\"left\">The original, normalized request URL (including scheme, host, path, and query string). Stored separately from the <code>key</code> for debugging, analytics, and potential invalidation by URL pattern.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>vary_headers</code></td>\n<td align=\"left\"><code>Dict[str, str]</code></td>\n<td align=\"left\">A dictionary mapping header names (from the <code>Vary</code> header) to their specific values from the <em>request</em> that produced this cached response. For a <code>Vary: Accept-Encoding, User-Agent</code> response, this dict would contain the <code>accept-encoding</code> and <code>user-agent</code> values from the request that resulted in this cache entry.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>status_code</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">The HTTP status code of the cached response (e.g., <code>200</code>, <code>404</code>, <code>302</code>). Non-<code>200</code> responses (like <code>301</code>, <code>404</code>, <code>503</code>) can also be cached, often with shorter TTLs (<strong>negative caching</strong>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>headers</code></td>\n<td align=\"left\"><code>Dict[str, str]</code></td>\n<td align=\"left\">The HTTP response headers as received from the upstream (<strong>origin server</strong> or <strong>origin shield</strong>). Critical headers like <code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>, <code>Content-Type</code>, and <code>Content-Encoding</code> are stored here verbatim to be sent back to clients.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>body</code></td>\n<td align=\"left\"><code>bytes</code></td>\n<td align=\"left\">The raw, uncompressed response body. Storing the uncompressed form allows the edge to re-encode on-the-fly for clients that support different compression algorithms (e.g., Brotli vs. gzip).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>fetched_at</code></td>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">The Unix timestamp (seconds since epoch) when this entry was fetched from the upstream and stored. This is the baseline for calculating freshness based on <code>max-age</code> or <code>s-maxage</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>expires_at</code></td>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">The calculated Unix timestamp after which this entry is considered <strong>stale</strong>. Derived from <code>fetched_at</code> plus the effective TTL (prioritizing <code>s-maxage</code>, then <code>max-age</code>, then <code>Expires</code> header).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>last_used_at</code></td>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">The Unix timestamp of the last time this entry was used to serve a request. This field is critical for implementing the <strong>LRU (Least Recently Used)</strong> eviction policy.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>use_count</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">A counter of how many times this entry has been used to serve a request. This field supports <strong>LFU (Least Frequently Used)</strong> eviction policies and analytics for &quot;hot&quot; content.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>surrogate_keys</code></td>\n<td align=\"left\"><code>List[str]</code></td>\n<td align=\"left\">A list of <strong>tags</strong> (often called <strong>surrogate keys</strong>) assigned to this entry via the <code>Surrogate-Key</code> response header. These allow for efficient, group-based invalidation (e.g., purging all product images when a product is updated).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>etag</code></td>\n<td align=\"left\"><code>Optional[str]</code></td>\n<td align=\"left\">The <code>ETag</code> validator from the response headers, stored for efficient conditional revalidation (<code>If-None-Match</code>). Can be a strong (<code>&quot;xyzzy&quot;</code>) or weak (<code>W/&quot;xyzzy&quot;</code>) validator.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>last_modified</code></td>\n<td align=\"left\"><code>Optional[str]</code></td>\n<td align=\"left\">The <code>Last-Modified</code> date string from the response headers, stored for conditional revalidation (<code>If-Modified-Since</code>). The string format is preserved for direct comparison in future requests.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> Separating <code>key</code> (for lookup) from <code>url</code> (for content identity) is essential. The <code>key</code> is a function of both the resource <em>and</em> the request characteristics defined by <code>Vary</code>. Two requests for the same <code>url</code> with different <code>Accept-Encoding</code> headers must generate different <code>keys</code> and thus distinct <code>CacheEntry</code> objects.</p>\n</blockquote>\n<p><strong>Lifecycle and State Transitions</strong>\nA <code>CacheEntry</code> moves through distinct states during its lifetime. Understanding these states is crucial for implementing correct cache logic, especially for <strong>stale-while-revalidate</strong> and conditional revalidation.</p>\n<p>The following state machine describes these transitions. Refer to the diagram <img src=\"/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fstate-machine-cache-entry.svg\" alt=\"State Machine: Cache Entry Lifecycle\"> for a visual representation.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Current State</th>\n<th align=\"left\">Event</th>\n<th align=\"left\">Next State</th>\n<th align=\"left\">Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>MISS</strong> (Not in cache)</td>\n<td align=\"left\">Cache lookup for a request</td>\n<td align=\"left\"><strong>FETCHING</strong></td>\n<td align=\"left\">1. Generate cache <code>key</code>. 2. <code>key</code> not found in storage. 3. Initiate upstream request. 4. Create a placeholder to collapse concurrent requests (at the shield).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FETCHING</strong></td>\n<td align=\"left\">Upstream response received</td>\n<td align=\"left\"><strong>FRESH</strong></td>\n<td align=\"left\">1. Validate response is cacheable via <code>is_response_cacheable</code>. 2. Create <code>CacheEntry</code> with <code>fetched_at</code> and calculated <code>expires_at</code>. 3. Store entry in <code>CacheStorage</code>. 4. Serve response to waiting client(s).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FRESH</strong></td>\n<td align=\"left\"><code>current_time</code> &lt; <code>expires_at</code></td>\n<td align=\"left\"><strong>FRESH</strong></td>\n<td align=\"left\">1. Serve entry directly to client. 2. Update <code>last_used_at</code> and increment <code>use_count</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>FRESH</strong></td>\n<td align=\"left\"><code>current_time</code> &gt;= <code>expires_at</code></td>\n<td align=\"left\"><strong>STALE</strong></td>\n<td align=\"left\">Entry is now past its freshness lifetime. It may still be served under certain conditions (e.g., <code>stale-while-revalidate</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>STALE</strong></td>\n<td align=\"left\">Request arrives, <code>CacheDirectives.stale_while_revalidate</code> period is active</td>\n<td align=\"left\"><strong>REVALIDATING</strong></td>\n<td align=\"left\">1. Serve the stale entry immediately to the client. 2. Asynchronously trigger <code>_revalidate_in_background</code>. 3. The entry remains <strong>STALE</strong> for subsequent requests until revalidation completes.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>STALE</strong></td>\n<td align=\"left\">Request arrives, no <code>stale-while-revalidate</code> allowed</td>\n<td align=\"left\"><strong>FETCHING</strong></td>\n<td align=\"left\">1. Do not serve the stale entry. 2. Treat as a <strong>MISS</strong> and initiate a synchronous upstream fetch.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>REVALIDATING</strong></td>\n<td align=\"left\">Background revalidation returns <code>304 Not Modified</code></td>\n<td align=\"left\"><strong>FRESH</strong></td>\n<td align=\"left\">1. Update <code>fetched_at</code> and <code>expires_at</code> (resetting the TTL clock). 2. Update <code>last_used_at</code>. 3. The entry is now fresh again.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>REVALIDATING</strong></td>\n<td align=\"left\">Background revalidation returns new <code>200 OK</code></td>\n<td align=\"left\"><strong>FRESH</strong></td>\n<td align=\"left\">1. Replace the existing <code>CacheEntry</code> with a new one built from the new response. 2. New entry is stored with updated <code>key</code> (if headers changed) or overwrites the old one.</td>\n</tr>\n<tr>\n<td align=\"left\"><em><strong>Any State</strong></em></td>\n<td align=\"left\"><strong>Purge</strong> command received (by <code>key</code> or tag)</td>\n<td align=\"left\"><strong>MISS</strong></td>\n<td align=\"left\">1. Entry is removed from <code>CacheStorage</code>. 2. Any associated index entries (tags) are cleaned up.</td>\n</tr>\n</tbody></table>\n<h3 id=\"structures-for-invalidation\">Structures for Invalidation</h3>\n<p>Invalidation is the active process of removing or marking content as stale in the cache. Efficient invalidation requires auxiliary data structures that map invalidation targets (like tags or URL patterns) to the actual <code>CacheEntry</code> objects stored in the cache.</p>\n<p><strong>Mental Model: The Library Index Card Catalog</strong>\nImagine the cache as a library. Each book is a <code>CacheEntry</code>. The primary card catalog (the <code>CacheStorage</code>) finds books by their primary ID (<code>key</code>). An <strong>invalidation index</strong> is like a secondary catalog:</p>\n<ul>\n<li><strong>Surrogate Key Index</strong>: Like a &quot;subject&quot; catalog. All books about &quot;Dinosaurs&quot; are filed under the &quot;Paleontology&quot; subject card. Purging the &quot;Paleontology&quot; tag means pulling every book linked to that card.</li>\n<li><strong>Ban List</strong>: Like a librarian&#39;s memo to remove &quot;all books published before 1950 from the Fantasy section&quot;. It&#39;s a rule that is checked when books are accessed or during a cleanup sweep.</li>\n</ul>\n<p>These structures enable powerful, granular cache management beyond simple URL purges.</p>\n<h4 id=\"surrogate-key-index\">Surrogate Key Index</h4>\n<p>To enable tag-based purges, the system must maintain an inverted index mapping each surrogate key (tag) to the set of cache keys for entries that contain that tag. This is typically stored in memory for fast lookup.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>key_to_tags</code></td>\n<td align=\"left\"><code>Dict[str, List[str]]</code></td>\n<td align=\"left\">Mapping from a cache entry&#39;s <code>key</code> to its list of <code>surrogate_keys</code>. Maintained when a new entry is stored or updated.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>tag_to_keys</code></td>\n<td align=\"left\"><code>Dict[str, Set[str]]</code></td>\n<td align=\"left\">Inverted index mapping a single surrogate key (tag) to the set of cache <code>key</code>s that are tagged with it. This is the core structure for <code>purge_by_tag</code> operations.</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm for Tag-Based Purge:</strong></p>\n<ol>\n<li>Admin sends purge command for tag <code>T</code>.</li>\n<li>Look up <code>tag_to_keys[T]</code> to get set <code>S</code> of cache keys.</li>\n<li>For each key in <code>S</code>:\na. Remove the corresponding <code>CacheEntry</code> from the primary <code>CacheStorage</code>.\nb. Remove the entry&#39;s key from <code>key_to_tags</code>.</li>\n<li>Clear the set <code>tag_to_keys[T]</code> (or remove the key <code>T</code> entirely).</li>\n</ol>\n<blockquote>\n<p><strong>Warning:</strong> This index must be kept consistent with the primary cache. If an entry is evicted due to capacity (LRU), its tags must also be removed from the <code>tag_to_keys</code> index. This requires a cleanup hook during eviction.</p>\n</blockquote>\n<h4 id=\"ban-rule\">Ban Rule</h4>\n<p>A <strong>ban</strong> is a pattern-based invalidation rule (e.g., &quot;all URLs under <code>/api/v1/products/*</code>&quot;). Unlike an immediate purge, bans are often evaluated lazily—when a cached entry is accessed, it&#39;s checked against active ban rules. This prevents unbounded memory growth from storing huge lists of purged URLs.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>pattern</code></td>\n<td align=\"left\"><code>str</code></td>\n<td align=\"left\">A pattern to match against cache entry URLs. For simplicity, we can support prefix matching (e.g., <code>/api/v1/products/</code>) or simple glob patterns.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>created_at</code></td>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">Timestamp when the ban was created. Allows for automatic expiration of ban rules after a configured TTL to prevent memory leaks.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>is_soft</code></td>\n<td align=\"left\"><code>bool</code></td>\n<td align=\"left\">If <code>True</code>, the ban is a <strong>soft purge</strong>: matching entries are marked as stale but not immediately removed. They can be served during <code>stale-while-revalidate</code>. If <code>False</code>, entries are hard-purged (deleted).</td>\n</tr>\n</tbody></table>\n<p><strong>ADR: Ban Rule Storage and Evaluation</strong></p>\n<blockquote>\n<p><strong>Decision: Lazy Evaluation of Ban Rules</strong></p>\n<ul>\n<li><strong>Context</strong>: Bans can match a very large number of cached entries. Immediately iterating through all cache entries to find matches during ban creation is an O(n) operation that can block request handling, especially in large caches.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Eager Evaluation</strong>: On ban creation, scan all <code>CacheEntry</code> objects and immediately delete/update those that match.</li>\n<li><strong>Lazy Evaluation</strong>: Store ban rules in a list. Check each rule when a cache entry is <em>accessed</em> (on a potential cache hit). If it matches, treat it as a miss (or stale) and optionally delete it.</li>\n<li><strong>Hybrid with Background Job</strong>: Store ban rules and run a periodic background job that scans and invalidates matching entries.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement <strong>Lazy Evaluation</strong> (Option 2).</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Predictable Latency</strong>: Ban creation becomes an O(1) insert operation, avoiding unpredictable delays during administrative actions.</li>\n<li><strong>Simplicity</strong>: Avoids the complexity of a background scanning thread and associated locking.</li>\n<li><strong>Effective for Common Use</strong>: Most banned content will naturally be re-requested by clients. When it is, it will be invalidated. Truly &quot;cold&quot; banned content that is never requested again will eventually be evicted by the LRU policy anyway.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>A banned item may remain in the cache until it is next requested or evicted by LRU. This is <strong>eventual invalidation</strong>.</li>\n<li>Adds a small overhead to every cache lookup (must check against all active bans). The list of active bans must be kept small and have a TTL.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Eager Evaluation</strong></td>\n<td align=\"left\">Immediate consistency. Guaranteed removal.</td>\n<td align=\"left\">O(n) scan blocks request handling. Poor performance for large caches.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Lazy Evaluation</strong></td>\n<td align=\"left\">Fast ban creation. No scanning overhead.</td>\n<td align=\"left\">Eventual consistency. Overhead per cache lookup.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Hybrid</strong></td>\n<td align=\"left\">Balances immediacy and latency.</td>\n<td align=\"left\">Adds system complexity (background jobs, coordination).</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<h3 id=\"structures-for-analytics\">Structures for Analytics</h3>\n<p>To operate and optimize a CDN, you must measure its performance. Analytics structures track metrics at various levels: per edge node, per origin shield, per content type, and over time.</p>\n<p><strong>Mental Model: The Power Plant Control Room</strong>\nThink of analytics as the gauges and dials in a power plant control room. You need:</p>\n<ul>\n<li><strong>Instantaneous meters</strong> (like <code>current_hits</code>): What&#39;s happening right now?</li>\n<li><strong>Cumulative totals</strong> (like <code>total_bytes_served</code>): How much work have we done today?</li>\n<li><strong>Rate calculations</strong> (like <code>requests_per_second</code>): Is demand increasing?</li>\n<li><strong>Breakdowns by category</strong> (like <code>hits_by_status_code</code>): Are failures concentrated in a specific area?</li>\n</ul>\n<p>These metrics allow operators to answer critical questions about cache effectiveness, origin load, and bandwidth usage.</p>\n<p>The following structures are intended to be in-memory counters that are periodically flushed to a persistent store (like the <strong>control plane</strong>) or reset for rolling time windows (e.g., last 5 minutes).</p>\n<h4 id=\"edge-node-metrics\">Edge Node Metrics</h4>\n<p>Each <strong>edge node</strong> maintains a set of counters to track its own performance.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>total_hits</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Cumulative count of requests served directly from this edge&#39;s cache (HTTP status <code>200</code> from cache, or <code>304</code> from validation).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>total_misses</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Cumulative count of requests that could not be served from cache and required an upstream fetch.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>total_bandwidth_served</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Total bytes served to clients from this edge node (includes response bodies from both hits and misses).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>total_bandwidth_upstream</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Total bytes fetched from upstream (shield or origin) to fulfill misses and revalidations.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>hits_by_status</code></td>\n<td align=\"left\"><code>Dict[int, int]</code></td>\n<td align=\"left\">Breakdown of cache hits by the HTTP status code of the cached response (e.g., <code>200</code>, <code>404</code>, <code>301</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>hits_by_content_type</code></td>\n<td align=\"left\"><code>Dict[str, int]</code></td>\n<td align=\"left\">Breakdown of cache hits by the <code>Content-Type</code> of the response (e.g., <code>image/jpeg</code>, <code>text/html</code>).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>current_cache_size</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Current number of <code>CacheEntry</code> objects stored in this node&#39;s <code>CacheStorage</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>current_cache_size_bytes</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Estimated total memory usage (in bytes) of the cache, including <code>CacheEntry</code> structures and their bodies.</td>\n</tr>\n</tbody></table>\n<h4 id=\"shield-amp-origin-metrics\">Shield &amp; Origin Metrics</h4>\n<p>The <strong>origin shield</strong> (and potentially each edge node, for its upstream) tracks metrics related to origin protection and request collapsing.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>collapsed_requests</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Count of requests that were deduplicated (collapsed) because another identical request was already in flight to the origin. This directly measures the shield&#39;s effectiveness in protecting the origin.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>origin_request_queue_size</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Current number of requests waiting in the shield&#39;s queue (for rate limiting or collapsing). A persistently high queue indicates origin overload or insufficient shield capacity.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>origin_errors</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Count of errors (5xx, network timeouts) received from the origin. A spike triggers health check failures and potential failover.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>negative_cache_hits</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Count of requests served from cached negative responses (e.g., <code>404</code>, <code>503</code>).</td>\n</tr>\n</tbody></table>\n<h4 id=\"time-windowed-metrics\">Time-Windowed Metrics</h4>\n<p>For real-time dashboards, metrics are often tracked over sliding time windows (e.g., last 1 minute, last 5 minutes). This can be implemented using a circular buffer or bucket-based approach.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field Name</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>window_start</code></td>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">Timestamp for the start of the current measurement window.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>window_duration</code></td>\n<td align=\"left\"><code>float</code></td>\n<td align=\"left\">Duration of the window in seconds (e.g., 60.0 for 1 minute).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>buckets</code></td>\n<td align=\"left\"><code>List[Dict]</code></td>\n<td align=\"left\">A list where each element is a metrics snapshot for a sub-interval within the window. For example, for a 5-minute window with 10-second granularity, there would be 30 buckets.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>current_bucket_index</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Index pointing to the bucket currently being filled.</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm for Updating Time-Windowed Metrics:</strong></p>\n<ol>\n<li>On each request completion, identify the relevant metrics (e.g., hit, miss, bytes served).</li>\n<li>Determine the current time bucket based on <code>window_start</code>, <code>window_duration</code>, and bucket size.</li>\n<li>If the current time has moved to a new bucket:\na. Increment <code>current_bucket_index</code> (wrapping around using modulo).\nb. Reset the count in the new bucket to zero.\nc. If the new bucket index has wrapped, update <code>window_start</code> to reflect the new start time of the oldest bucket.</li>\n<li>Increment the counters in the current bucket.</li>\n</ol>\n<p>This structure allows for efficient calculation of rates (e.g., hits per second over the last minute) by summing the still-relevant buckets.</p>\n<h3 id=\"common-pitfalls-in-data-modeling\">Common Pitfalls in Data Modeling</h3>\n<p>⚠️ <strong>Pitfall: Forgetting to Normalize Header Values in <code>vary_headers</code></strong></p>\n<ul>\n<li><strong>Description</strong>: When storing the <code>vary_headers</code> dictionary, using raw header values as sent by the client (e.g., <code>gzip, br</code> vs <code>gzip, br, deflate</code>) can lead to unnecessary cache fragmentation. The same semantic value may be expressed differently.</li>\n<li><strong>Why it&#39;s wrong</strong>: Two clients requesting the same resource with semantically identical <code>Accept-Encoding: gzip</code> and <code>Accept-Encoding: gzip, br</code> (where the server only supports gzip) would create two separate cache entries, wasting space.</li>\n<li><strong>Fix</strong>: Normalize header values before using them in the <code>key</code> and <code>vary_headers</code>. For <code>Accept-Encoding</code>, parse the value, intersect it with the server&#39;s supported encodings, and store a canonical form (e.g., <code>gzip</code>). Apply similar normalization for other <code>Vary</code> headers like <code>Accept-Language</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Storing Compressed Bodies in <code>CacheEntry.body</code></strong></p>\n<ul>\n<li><strong>Description</strong>: Storing the response body exactly as received from upstream (e.g., gzip-compressed).</li>\n<li><strong>Why it&#39;s wrong</strong>: If a new client requests the same resource but only supports Brotli or no compression, the edge must re-fetch from origin or decompress and recompress on-the-fly, losing performance benefits.</li>\n<li><strong>Fix</strong>: Always store the <strong>uncompressed</strong> body in <code>CacheEntry.body</code>. Store the <code>Content-Encoding</code> header from the upstream response. When serving a client, check the <code>Accept-Encoding</code> request header, and apply the appropriate compression <em>at the edge</em> before sending. This is a form of <strong>transcoding</strong> that maximizes cache efficiency.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Letting the <code>tag_to_keys</code> Index Grow Unbounded</strong></p>\n<ul>\n<li><strong>Description</strong>: Failing to clean up the inverted index when a <code>CacheEntry</code> is evicted from the primary cache (due to LRU) or when its tags change.</li>\n<li><strong>Why it&#39;s wrong</strong>: Memory leak. The index holds references to cache keys that no longer exist. A <code>purge_by_tag</code> operation would iterate over stale keys, wasting CPU and potentially causing errors.</li>\n<li><strong>Fix</strong>: Implement a <strong>cleanup hook</strong> in the <code>CacheStorage.evict()</code> method. When an entry is evicted, iterate through its <code>surrogate_keys</code> and remove its key from each corresponding set in <code>tag_to_keys</code>. If a set becomes empty, you may optionally delete the key from the dictionary.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (for Learning)</th>\n<th align=\"left\">Advanced Option (for Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Cache Storage</strong></td>\n<td align=\"left\">In-memory dictionary (<code>dict</code>) with LRU eviction using <code>collections.OrderedDict</code> or a custom linked list.</td>\n<td align=\"left\">External cache system like Redis (for distributed edges) or <code>lru-dict</code> library for efficient, bounded in-memory cache.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Metrics Storage</strong></td>\n<td align=\"left\">In-memory counters, periodically logged to stdout or a local file.</td>\n<td align=\"left\">Time-series database (Prometheus) with a push gateway, or streaming metrics to the Control Plane via a lightweight protocol.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Invalidation Index</strong></td>\n<td align=\"left\">Nested Python dictionaries (<code>Dict[str, Set[str]]</code>) in memory.</td>\n<td align=\"left\">Redis Sets and Hashes for persistence and cross-node sharing.</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin_cdn/\n├── pyproject.toml\n├── src/\n│   └── blue_origin/\n│       ├── __init__.py\n│       ├── config.py                # EdgeConfig class and loading\n│       ├── models/                  # Data models (this section)\n│       │   ├── __init__.py\n│       │   ├── cache_entry.py       # CacheEntry class &amp; CacheDirectives\n│       │   ├── invalidation.py      # SurrogateKeyIndex, BanRule\n│       │   └── analytics.py         # EdgeMetrics, ShieldMetrics\n│       ├── cache/                   # Milestone 1 &amp; 5\n│       │   ├── storage.py           # CacheStorage abstract interface &amp; LRU impl\n│       │   └── key.py               # Cache key generation utilities\n│       ├── handlers/                # HTTP request handlers\n│       │   ├── edge_handler.py      # EdgeRequestHandler\n│       │   └── shield_handler.py\n│       ├── http_utils/              # RFC 9111 helper functions\n│       │   ├── cache_control.py     # parse_cache_control_header, CacheDirectives.from_header\n│       │   └── dates.py             # parse_http_date, format_http_date\n│       ├── invalidation/            # Milestone 2\n│       │   └── manager.py           # Purge, ban, tag invalidation logic\n│       ├── analytics/               # Milestone 5\n│       │   └── collector.py         # Metrics collection and aggregation\n│       └── cli.py                   # Command-line interface for admin tasks\n└── tests/</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-cache-directives-amp-http-utilities\">C. Infrastructure Starter Code (Cache Directives &amp; HTTP Utilities)</h4>\n<p>These utilities are prerequisites for parsing and handling HTTP caching headers correctly. They are provided complete and ready to use.</p>\n<p><strong>File: <code>src/blue_origin/http_utils/cache_control.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">RFC 9111 Cache-Control header parsing utilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheDirectives</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Structured representation of Cache-Control response directives.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s_maxage: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_age: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_cache: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_store: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    must_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proxy_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    public: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    private: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_while_revalidate: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_if_error: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_header</span><span style=\"color:#E1E4E8\">(cls, cache_control_header: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#9ECBFF\">\"CacheDirectives\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse a Cache-Control header string into a structured CacheDirectives object.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handles multiple directives separated by commas.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        directives </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> cache_control_header:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Split by comma, then by '=' for key-value directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> cache_control_header.split(</span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.strip().lower()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> token:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                key, val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.split(</span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> key.strip()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> val.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    int_val </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(val)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Ignore non-integer values for known int fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    continue</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"s-maxage\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.s_maxage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> int_val</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"max-age\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.max_age </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> int_val</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"stale-while-revalidate\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.stale_while_revalidate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> int_val</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"stale-if-error\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.stale_if_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> int_val</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Boolean directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"no-cache\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.no_cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"no-store\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.no_store </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"must-revalidate\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.must_revalidate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"proxy-revalidate\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.proxy_revalidate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"public\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.public </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"private\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    directives.private </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_cache_control_header</span><span style=\"color:#E1E4E8\">(header_value: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse Cache-Control header into a dictionary of directive names to values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns a dict where keys are directive names and values are either</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    the parameter (as string) or None for boolean directives.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> header_value:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> header_value.split(</span><span style=\"color:#9ECBFF\">\",\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> token:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            key, val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token.split(</span><span style=\"color:#9ECBFF\">\"=\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[key.strip().lower()] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> val.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result[token.lower()] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<p><strong>File: <code>src/blue_origin/http_utils/dates.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">HTTP date parsing and formatting (RFC 1123 / 822).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> email.utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parsedate_to_datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(date_str: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse an RFC 1123/822 date string into a Unix timestamp (float seconds since epoch).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns None if the string cannot be parsed.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> date_str:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # parsedate_to_datetime handles most common HTTP date formats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parsedate_to_datetime(date_str)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Ensure it's timezone-aware (UTC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> dt.tzinfo </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dt.replace(</span><span style=\"color:#FFAB70\">tzinfo</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> dt.astimezone(timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dt.timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> format_http_date</span><span style=\"color:#E1E4E8\">(timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Format a Unix timestamp to RFC 1123 string.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Use UTC for HTTP dates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.fromtimestamp(timestamp, </span><span style=\"color:#FFAB70\">tz</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Format: 'Wed, 21 Oct 2015 07:28:00 GMT'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> dt.strftime(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %b</span><span style=\"color:#9ECBFF\"> %Y %H:%M:%S GMT\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code-data-model-classes\">D. Core Logic Skeleton Code (Data Model Classes)</h4>\n<p><strong>File: <code>src/blue_origin/models/cache_entry.py</code></strong></p>\n<p><img src=\"/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fdata-model-class.svg\" alt=\"Data Model: Cache Entry & Relationships\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core CacheEntry data model and associated logic.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..http_utils.cache_control </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..http_utils.dates </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_http_date</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheEntry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Field definitions as per the data model table</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    url: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vary_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status_code: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body: </span><span style=\"color:#79B8FF\">bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fetched_at: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expires_at: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_used_at: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    use_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    surrogate_keys: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    etag: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_modified: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_fresh</span><span style=\"color:#E1E4E8\">(self, current_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if cache entry is still fresh (i.e., current_time &#x3C; expires_at).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If current_time is None, use time.time()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compare current_time with self.expires_at</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if current_time &#x3C; expires_at, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_stale_but_revalidatable</span><span style=\"color:#E1E4E8\">(self, current_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if a stale entry can be served during background revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This depends on the stale-while-revalidate directive.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If current_time is None, use time.time()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if current_time >= self.expires_at (i.e., stale)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Parse Cache-Control from self.headers to get CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If directives.stale_while_revalidate exists, calculate the grace period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return True if (current_time - self.expires_at) &#x3C; grace_period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Otherwise return False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_upstream_response</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cls,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        vary_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        status_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        surrogate_keys: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> </span><span style=\"color:#9ECBFF\">\"CacheEntry\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Factory method to create a CacheEntry from an upstream HTTP response.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculates fetched_at and expires_at based on current time and Cache-Control headers.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Record current time as fetched_at</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse Cache-Control header to get CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine effective TTL (in seconds):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Prefer s_maxage if present (CDN-specific)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Then max_age</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Then fall back to parsing Expires header and subtracting fetched_at</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Default to a short TTL (e.g., 60 seconds) if none present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate expires_at = fetched_at + effective_ttl</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Extract etag and last_modified from headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create and return a new CacheEntry instance with all fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>File: <code>src/blue_origin/models/invalidation.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Data structures for cache invalidation: SurrogateKeyIndex and BanRule.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Set</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SurrogateKeyIndex</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Inverted index mapping surrogate keys (tags) to cache entry keys.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.key_to_tags: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tag_to_keys: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Set[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_entry</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, tags: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Register a cache entry and its tags with the index.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store mapping from cache_key -> tags in self.key_to_tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each tag in tags, add cache_key to the set in self.tag_to_keys[tag]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         (create the set if it doesn't exist)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> remove_entry</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Remove a cache entry from the index, cleaning up tag associations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Look up the tags for this cache_key from self.key_to_tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each tag in those tags, remove cache_key from self.tag_to_keys[tag]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If the set for a tag becomes empty, delete the tag key from the dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Remove the cache_key from self.key_to_tags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_keys_for_tag</span><span style=\"color:#E1E4E8\">(self, tag: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Set[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return all cache keys tagged with the given tag.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.tag_to_keys.get(tag, </span><span style=\"color:#79B8FF\">set</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> purge_by_tag</span><span style=\"color:#E1E4E8\">(self, tag: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Set[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Return all cache keys for a given tag and clear the index for that tag.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Called by the invalidation manager.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get the set of keys for this tag (or empty set)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each key in that set, remove it from self.key_to_tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Delete the tag entry from self.tag_to_keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the set of keys (so they can be purged from primary storage)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BanRule</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a pattern-based invalidation rule.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pattern: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # e.g., \"/api/v1/products/*\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">  # True for soft purge (mark stale), False for hard purge</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> matches</span><span style=\"color:#E1E4E8\">(self, url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if the given URL matches this ban rule.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        For simplicity, implement prefix matching first.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: For prefix matching, check if url.startswith(self.pattern)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return True if it matches, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Advanced: Implement simple glob matching (e.g., using fnmatch)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-python\">E. Language-Specific Hints (Python)</h4>\n<ul>\n<li>Use <code>@dataclass</code> from the <code>dataclasses</code> module for clean, boilerplate-free data models. It automatically generates <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code> methods.</li>\n<li>For the <code>SurrogateKeyIndex</code>, use Python&#39;s built-in <code>set</code> for <code>tag_to_keys</code> values to ensure uniqueness and fast membership tests.</li>\n<li>Use <code>time.time()</code> for timestamps. It returns a float representing seconds since the Unix epoch in UTC (system clock dependent, but sufficient for relative TTLs).</li>\n<li>When parsing dates, the <code>email.utils.parsedate_to_datetime</code> function handles the various HTTP date formats correctly and is in the standard library.</li>\n<li>For thread-safe access to shared structures like the metrics counters or invalidation indexes, use <code>threading.Lock</code> or <code>threading.RLock</code>. Consider using <code>collections.defaultdict</code> for metrics breakdowns to avoid key checks.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint-data-model\">F. Milestone Checkpoint (Data Model)</h4>\n<p>After implementing the data structures above, you should be able to run a simple test to verify their basic functionality.</p>\n<p><strong>Checkpoint Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests for the models module</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> src/blue_origin/models/</span><span style=\"color:#79B8FF\"> -xvs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Tests should pass, demonstrating:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. CacheEntry.is_fresh() returns True before TTL, False after.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. SurrogateKeyIndex correctly adds and removes entries, maintaining consistency.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. BanRule.matches() correctly identifies URLs with a given prefix.</span></span></code></pre></div>\n\n<p><strong>Manual Verification Script:</strong>\nCreate a simple script <code>test_models.py</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> blue_origin.models.cache_entry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheEntry, CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> blue_origin.models.invalidation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SurrogateKeyIndex, BanRule</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test CacheEntry freshness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CacheEntry(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    key</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test_key\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    url</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/test\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    vary_headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    status_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    body</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    fetched_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># 10 seconds ago</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    expires_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time() </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\"># expires in 50 seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> entry.is_fresh() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ CacheEntry freshness check passed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test SurrogateKeyIndex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SurrogateKeyIndex()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">index.add_entry(</span><span style=\"color:#9ECBFF\">\"key1\"</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#9ECBFF\">\"tag1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tag2\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">index.add_entry(</span><span style=\"color:#9ECBFF\">\"key2\"</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#9ECBFF\">\"tag2\"</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> index.get_keys_for_tag(</span><span style=\"color:#9ECBFF\">\"tag2\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"key1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"key2\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">index.remove_entry(</span><span style=\"color:#9ECBFF\">\"key1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> index.get_keys_for_tag(</span><span style=\"color:#9ECBFF\">\"tag2\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"key2\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ SurrogateKeyIndex consistency passed\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test BanRule prefix matching</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ban </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BanRule(</span><span style=\"color:#FFAB70\">pattern</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/api/v1/\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> ban.matches(</span><span style=\"color:#9ECBFF\">\"/api/v1/products/123\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> ban.matches(</span><span style=\"color:#9ECBFF\">\"/static/image.jpg\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ BanRule prefix matching passed\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>Run it: <code>python test_models.py</code>. All assertions should pass silently.</p>\n<h2 id=\"component-edge-cache-milestone-1-amp-5\">Component: Edge Cache (Milestone 1 &amp; 5)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Edge Cache Implementation), Milestone 5 (CDN Analytics &amp; Performance Optimization)</p>\n</blockquote>\n<p>The edge cache is the beating heart of a CDN. It&#39;s the component that directly interacts with end users, intercepting their requests and deciding whether to serve cached content instantly or fetch it from upstream. This section details the design and implementation of this critical component, combining the foundational caching logic from Milestone 1 with the performance optimizations from Milestone 5.</p>\n<h3 id=\"mental-model-the-smart-mailroom\">Mental Model: The Smart Mailroom</h3>\n<p>Imagine a large corporate office building with a central mailroom. All incoming packages (HTTP requests) arrive at this mailroom, and the mailroom clerk (edge cache) has a simple goal: deliver packages to employees (return responses to users) as quickly as possible.</p>\n<ol>\n<li><strong>Package Lookup (Cache Key)</strong>: Each package is labeled with a recipient name and department (URL and Vary headers). The clerk first checks organized shelves (the cache) for an identical package already waiting.</li>\n<li><strong>Freshness Check (TTL)</strong>: Packages have expiration dates stamped on them (Cache-Control headers). The clerk won&#39;t deliver stale milk (expired content).</li>\n<li><strong>Smart Validation (Conditional Requests)</strong>: If a package looks old, the clerk calls the sender (origin) and asks, &quot;Has this changed since last Tuesday?&quot; (If-Modified-Since). If not, they reuse the old package (304 Not Modified).</li>\n<li><strong>Efficient Storage (Eviction)</strong>: Shelves have limited space. When full, the clerk removes the least recently used packages (LRU) or packages from rarely visited departments (LFU) to make room for new arrivals.</li>\n<li><strong>Value-Added Services (Analytics &amp; Compression)</strong>: The clerk keeps a log of how many packages they handled (analytics) and can repack bulky items into smaller boxes (compression) before delivery to save bandwidth.</li>\n</ol>\n<p>This mental model captures the core responsibilities: efficient storage/retrieval, freshness management, validation, and optimization—all performed at the &quot;edge&quot; where users first connect.</p>\n<h3 id=\"interface-amp-http-flow\">Interface &amp; HTTP Flow</h3>\n<p>The <code>EdgeRequestHandler</code> is the primary interface between the outside world and the cache. It receives HTTP requests, processes them through the caching logic, and returns HTTP responses.</p>\n<p><strong>Interface Definition:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EdgeRequestHandler.handle_request</code></td>\n<td><code>request_headers: Dict[str, str]</code>, <code>request_body: bytes</code></td>\n<td><code>Tuple[int, Dict[str, str], bytes]</code> (status, headers, body)</td>\n<td>The main request processing entry point. It follows the caching algorithm defined in RFC 9111.</td>\n</tr>\n<tr>\n<td><code>EdgeRequestHandler._fetch_from_upstream</code></td>\n<td><code>headers: Dict[str, str]</code>, <code>body: bytes</code></td>\n<td><code>Tuple[int, Dict[str, str], bytes]</code></td>\n<td>Forwards a request to the upstream (shield or origin) when a cache miss occurs.</td>\n</tr>\n<tr>\n<td><code>EdgeRequestHandler._revalidate_in_background</code></td>\n<td><code>cache_key: str</code>, <code>cache_entry: CacheEntry</code>, <code>request_headers: Dict[str, str]</code></td>\n<td><code>None</code></td>\n<td>Asynchronously revalidates a stale-but-revalidatable cache entry while the current request is served stale content.</td>\n</tr>\n</tbody></table>\n<p><strong>Request Handling Algorithm:</strong></p>\n<p>The flowchart <img src=\"/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fflowchart-request-handling.svg\" alt=\"Flowchart: Edge Node Request Handling\"> illustrates the complete decision flow. Here is the step-by-step algorithm executed by <code>handle_request</code>:</p>\n<ol>\n<li><p><strong>Request Parsing &amp; Normalization</strong>: Extract the request URL, method, and relevant headers (<code>Cache-Control</code>, <code>If-None-Match</code>, <code>If-Modified-Since</code>, <code>Accept-Encoding</code>). Normalize the URL (e.g., remove default ports, ensure consistent casing for the scheme/host).</p>\n</li>\n<li><p><strong>Cacheability Pre-check</strong>: If the request method is not <code>GET</code> or <code>HEAD</code>, or if the request contains a <code>Cache-Control: no-store</code> directive, bypass the cache entirely and forward directly to <code>_fetch_from_upstream</code>.</p>\n</li>\n<li><p><strong>Cache Key Generation</strong>: Construct a unique <code>cache_key</code> by combining the normalized request URL with the values of all headers listed in the <code>Vary</code> header of the <em>cached response</em> (or if no cached entry exists yet, the current request&#39;s <code>Vary</code>-relevant headers). This ensures different representations (e.g., gzip vs. plain text) are stored separately.</p>\n</li>\n<li><p><strong>Cache Lookup</strong>: Query the <code>CacheStorage</code> with the generated <code>cache_key</code>. The result is either a <code>CacheEntry</code> (HIT) or <code>None</code> (MISS).</p>\n</li>\n<li><p><strong>On Cache HIT</strong>:\na. <strong>Freshness Determination</strong>: Calculate the current age of the entry (current time - <code>fetched_at</code>). Compare against TTL derived from <code>CacheDirectives</code> (see TTL Management below).\nb. <strong>If Fresh</strong>: Serve the cached response immediately. Update <code>last_used_at</code> and <code>use_count</code> for eviction policies. Record a cache hit in <code>EdgeMetrics</code>.\nc. <strong>If Stale but Revalidatable</strong>: Check <code>CacheDirectives.stale_while_revalidate</code>. If within this grace period, serve the stale response immediately (<code>_revalidate_in_background</code>), then asynchronously revalidate the entry with the origin and update the cache. Record a hit.\nd. <strong>If Stale and Must Revalidate</strong>: The entry cannot be served without validation. Proceed to step 6 (Conditional Request) using the cached entry&#39;s <code>etag</code> and <code>last_modified</code>.</p>\n</li>\n<li><p><strong>On Cache MISS or Need Validation</strong>:\na. <strong>Prepare Upstream Request</strong>: If a cached entry exists (for validation), add <code>If-None-Match: {etag}</code> and/or <code>If-Modified-Since: {last_modified}</code> headers to the upstream request.\nb. <strong>Fetch from Upstream</strong>: Call <code>_fetch_from_upstream</code> with the (potentially conditional) request.\nc. <strong>Handle Response</strong>:</p>\n<ul>\n<li><strong>304 Not Modified (Validation Success)</strong>: The cached entry is fresh. Update its <code>fetched_at</code> and <code>expires_at</code> timestamps based on new headers in the 304 response, then serve the cached body. Record a hit.</li>\n<li><strong>200 OK (Miss or Changed)</strong>: This is a new or updated resource. Determine if the response is cacheable using <code>is_response_cacheable</code>. If cacheable, create a new <code>CacheEntry</code> via <code>CacheEntry.from_upstream_response</code> and store it. Record a miss.</li>\n<li><strong>Any other status</strong>: Pass through to client. Cache error responses (like 404, 500) only if they have explicit caching directives (negative caching).</li>\n</ul>\n</li>\n<li><p><strong>Post-Processing</strong>: Before returning the final response:\na. <strong>Compression (Milestone 5)</strong>: If the client supports compression (<code>Accept-Encoding</code>) and the content type is compressible (e.g., text/html), and the response isn&#39;t already compressed, apply gzip or Brotli compression. Update the <code>Content-Encoding</code> and <code>Content-Length</code> headers.\nb. <strong>Add Diagnostic Headers</strong>: Append headers like <code>X-Cache: HIT</code> or <code>X-Cache: MISS</code> for debugging.\nc. <strong>Update Analytics</strong>: Increment counters in <code>EdgeMetrics</code> (hits, misses, bandwidth served).</p>\n</li>\n<li><p><strong>Return Response</strong>: Send the final status code, headers, and body to the client.</p>\n</li>\n</ol>\n<h3 id=\"cache-key-amp-ttl-management\">Cache Key &amp; TTL Management</h3>\n<p>Two of the most critical and subtle aspects of HTTP caching are correctly constructing cache keys and interpreting the hierarchy of TTL directives.</p>\n<p><strong>Cache Key Construction:</strong></p>\n<p>The cache key must uniquely identify a <em>representation</em> of a resource, not just the resource itself. The primary inputs are:</p>\n<ol>\n<li><strong>Request URL</strong>: The full URL including scheme, host, port, path, and query string.</li>\n<li><strong>Vary Header Dimensions</strong>: The values of request headers listed in the <code>Vary</code> header of the <em>cached response</em>.</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> You cannot know which request headers are relevant for variation until <em>after</em> you have received a response from the origin. Therefore, the cache key for lookup (step 4 above) must be constructed using the <em>Vary header from the previously cached entry</em>. If no entry exists, you must store the request&#39;s headers that <em>might</em> be varied on, and then after fetching the response, use its <code>Vary</code> header to construct the final storage key.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Header</th>\n<th>Role in Cache Key</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Vary: Accept-Encoding</code></td>\n<td>Cache key must include the <code>Accept-Encoding</code> value from the request.</td>\n<td>Requests for <code>image.jpg</code> with <code>Accept-Encoding: gzip</code> and <code>Accept-Encoding: identity</code> get separate cache entries.</td>\n</tr>\n<tr>\n<td><code>Vary: User-Agent</code></td>\n<td>Cache key includes the <code>User-Agent</code> string.</td>\n<td>Different cache entries for mobile vs. desktop versions of a page.</td>\n</tr>\n<tr>\n<td><code>Vary: *</code></td>\n<td>Special case: The response is <strong>never</strong> stored.</td>\n<td>Serves as a directive to never cache this response.</td>\n</tr>\n</tbody></table>\n<p><strong>TTL Management &amp; Freshness Calculation:</strong></p>\n<p>A <code>CacheEntry</code>&#39;s freshness is determined by its <code>expires_at</code> timestamp, which is calculated when the entry is created or revalidated. The hierarchy of TTL directives, from most to least authoritative for a shared cache (like our CDN), is:</p>\n<ol>\n<li><code>Cache-Control: s-maxage=&lt;seconds&gt;</code>: Explicitly for shared caches. Overrides <code>max-age</code> and <code>Expires</code>.</li>\n<li><code>Cache-Control: max-age=&lt;seconds&gt;</code>: For both private and shared caches.</li>\n<li><code>Expires: &lt;date&gt;</code>: An absolute expiration date.</li>\n<li>Heuristic Freshness: If no explicit directive exists, RFC 9111 allows using a heuristic (e.g., 10% of the time since <code>Last-Modified</code>). For simplicity, we treat such responses as non-cacheable unless explicitly configured otherwise.</li>\n</ol>\n<p>The <code>CacheDirectives.from_header</code> method parses the <code>Cache-Control</code> header string into a structured object. The algorithm for calculating <code>expires_at</code> is:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>fetched_at = current_time\nif directives.s_maxage is not None:\n    expires_at = fetched_at + directives.s_maxage\nelif directives.max_age is not None:\n    expires_at = fetched_at + directives.max_age\nelif Expires header exists and is valid:\n    expires_at = parse_http_date(Expires_header)\nelse:\n    // Not cacheable by explicit directives</code></pre></div>\n\n<p>The <code>CacheEntry.is_fresh(current_time)</code> method simply returns <code>current_time &lt; expires_at</code>.</p>\n<p><strong>Stale-While-Revalidate &amp; Stale-If-Error:</strong>\nThese directives allow graceful behavior beyond simple freshness:</p>\n<ul>\n<li><code>stale-while-revalidate</code>: After <code>expires_at</code>, for the next N seconds, the cache may serve stale data while asynchronously revalidating it.</li>\n<li><code>stale-if-error</code>: If the origin is failing, stale content may be served for N seconds past expiration.</li>\n</ul>\n<p>These are checked by <code>CacheEntry.is_stale_but_revalidatable</code>.</p>\n<h3 id=\"adr-cache-storage-amp-eviction-policy\">ADR: Cache Storage &amp; Eviction Policy</h3>\n<blockquote>\n<p><strong>Decision: In-Memory LRU Cache with Size Limit</strong></p>\n<ul>\n<li><strong>Context</strong>: We need a fast, concurrent cache storage layer for the edge node. The cache must hold thousands to millions of responses, evict entries when capacity is reached, and support fast lookups by complex string keys.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>In-memory LRU/LFU cache</strong>: Store everything in the node&#39;s RAM using a structure like a hash map + doubly linked list for LRU ordering.</li>\n<li><strong>Disk-backed cache (e.g., SQLite, RocksDB)</strong>: Use local SSD storage for larger capacity, trading some latency for persistence and size.</li>\n<li><strong>External cache service (e.g., Redis, Memcached)</strong>: Delegate storage to a dedicated in-memory data store, allowing multiple edge processes to share a cache.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement an in-memory LRU (Least Recently Used) cache as the default <code>CacheStorage</code>.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Performance</strong>: RAM access is orders of magnitude faster than disk or network. Edge caching&#39;s primary goal is low latency.</li>\n<li><strong>Simplicity</strong>: An in-memory LRU is straightforward to implement and reason about. Python&#39;s <code>functools.lru_cache</code> or a custom <code>OrderedDict</code>-based implementation works well.</li>\n<li><strong>Predictable Memory Footprint</strong>: A size limit (e.g., 1GB) ensures the cache doesn&#39;t cause the node to run out of memory.</li>\n<li><strong>Educational Value</strong>: Implementing LRU eviction teaches fundamental data structure concepts.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Volatility</strong>: Cache contents are lost on process restart. This is acceptable for a CDN edge (cache warming can repopulate).</li>\n<li><strong>Size Limitation</strong>: The cache cannot exceed available RAM. Large media files may limit the number of objects cached.</li>\n<li><strong>Single-Node Only</strong>: Cache is not shared between edge processes on different machines. This is fine for our architecture where each edge node is independent.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>In-memory LRU/LFU</td>\n<td>Extremely fast, simple to implement, predictable memory use</td>\n<td>Volatile, limited to RAM size, not shared</td>\n<td><strong>Yes</strong> (LRU for simplicity)</td>\n</tr>\n<tr>\n<td>Disk-backed cache</td>\n<td>Larger capacity, persistent across restarts</td>\n<td>Higher latency (I/O), more complex eviction (disk space), wear on SSDs</td>\n<td>No</td>\n</tr>\n<tr>\n<td>External cache service</td>\n<td>Shared cache across processes, potentially larger, persistence options</td>\n<td>Network latency added to every lookup, extra operational complexity</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p><strong>Eviction Policy Details:</strong>\nWhen the cache reaches its configured capacity (in bytes or item count), it must evict entries. LRU eviction removes the entry with the oldest <code>last_used_at</code> timestamp. This assumes recent requests are predictive of future requests, which is a common access pattern. The <code>CacheEntry.last_used_at</code> field must be updated on every cache hit.</p>\n<p>An alternative is LFU (Least Frequently Used), which evicts the entry with the smallest <code>use_count</code>. This can better retain &quot;popular but not recently accessed&quot; items but requires more overhead to track and decay frequencies. For our educational project, LRU provides a good balance.</p>\n<h3 id=\"common-pitfalls-in-edge-caching\">Common Pitfalls in Edge Caching</h3>\n<p>⚠️ <strong>Pitfall: Ignoring the Vary Header</strong>\n<strong>Description</strong>: Constructing cache keys using only the URL, ignoring the <code>Vary</code> header. This causes cache corruption where a user requesting a gzipped version might get a plain-text version cached for a different user.\n<strong>Why it&#39;s wrong</strong>: Violates HTTP semantics, serves incorrect content, and can break websites.\n<strong>Fix</strong>: Always include the normalized values of <em>all</em> headers listed in the cached response&#39;s <code>Vary</code> header in the cache key. Handle <code>Vary: *</code> by not caching at all.</p>\n<p>⚠️ <strong>Pitfall: Confusing s-maxage and max-age</strong>\n<strong>Description</strong>: Using <code>max-age</code> when <code>s-maxage</code> is present for shared cache decisions.\n<strong>Why it&#39;s wrong</strong>: <code>s-maxage</code> is specifically for shared caches (like CDNs). Using <code>max-age</code> instead may cause the CDN to cache content for shorter durations than intended for public users, increasing origin load.\n<strong>Fix</strong>: In your TTL calculation hierarchy, prioritize <code>s-maxage</code> over <code>max-age</code> for shared caches.</p>\n<p>⚠️ <strong>Pitfall: Cache Key Collisions with Normalization</strong>\n<strong>Description</strong>: Different URLs that point to the same resource (e.g., <code>http://example.com</code> vs <code>http://example.com:80</code>, or differing query parameter order) create duplicate cache entries.\n<strong>Why it&#39;s wrong</strong>: Wastes cache space, reduces hit rates.\n<strong>Fix</strong>: Normalize URLs before generating cache keys: convert scheme/host to lowercase, remove default ports, sort query parameters alphabetically (if the origin treats them as order-independent).</p>\n<p>⚠️ <strong>Pitfall: Forgetting to Cache 304 Responses</strong>\n<strong>Description</strong>: When a conditional request returns <code>304 Not Modified</code>, not updating the cached entry&#39;s freshness metadata.\n<strong>Why it&#39;s wrong</strong>: The cached entry&#39;s <code>expires_at</code> remains based on the original fetch time, causing it to become stale prematurely.\n<strong>Fix</strong>: On a 304 response, extract any new <code>Cache-Control</code>, <code>Expires</code>, or <code>ETag</code> headers from the response and update the existing <code>CacheEntry</code>&#39;s metadata accordingly, effectively &quot;refreshing&quot; the TTL.</p>\n<p>⚠️ <strong>Pitfall: Not Respecting no-store on Requests</strong>\n<strong>Description</strong>: Caching responses for requests that contained <code>Cache-Control: no-store</code>.\n<strong>Why it&#39;s wrong</strong>: The user explicitly requested that sensitive information not be stored. Violating this is a privacy/security issue.\n<strong>Fix</strong>: Check request directives at the start of the algorithm and bypass the cache entirely for <code>no-store</code> requests.</p>\n<h3 id=\"implementation-guidance-for-edge-cache\">Implementation Guidance for Edge Cache</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (for Learning)</th>\n<th>Advanced Option (for Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td>Python&#39;s <code>http.server</code> with threading</td>\n<td><code>asyncio</code> + <code>aiohttp</code> for high concurrency</td>\n</tr>\n<tr>\n<td>Cache Storage</td>\n<td>Python <code>dict</code> + <code>collections.OrderedDict</code> for LRU</td>\n<td><code>lru-dict</code> library or custom sharded hash map</td>\n</tr>\n<tr>\n<td>Compression</td>\n<td>Python&#39;s <code>gzip</code> library</td>\n<td><code>brotli</code> library for Brotli compression</td>\n</tr>\n<tr>\n<td>Header Parsing</td>\n<td>Manual string splitting using <code>parse_cache_control_header</code></td>\n<td>Use <code>cachetools</code> library for RFC-compliant parsing</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin/\n├── README.md\n├── pyproject.toml\n├── src/\n│   └── blue_origin/\n│       ├── __init__.py\n│       ├── config.py                    # EdgeConfig, config loading\n│       ├── constants.py                 # HTTP constants, defaults\n│       ├── models/                      # Data models\n│       │   ├── __init__.py\n│       │   ├── cache.py                 # CacheEntry, CacheDirectives\n│       │   ├── metrics.py               # EdgeMetrics, TimeWindowedMetrics\n│       │   └── invalidation.py          # SurrogateKeyIndex, BanRule\n│       ├── cache/                       # Core caching logic\n│       │   ├── __init__.py\n│       │   ├── storage.py               # CacheStorage interface &amp; LRU impl\n│       │   ├── key_generator.py         # Cache key generation\n│       │   ├── ttl_manager.py           # TTL calculation\n│       │   └── validator.py             # Conditional request logic\n│       ├── handlers/                    # HTTP handlers\n│       │   ├── __init__.py\n│       │   ├── edge_handler.py          # EdgeRequestHandler\n│       │   └── purge_handler.py         # Admin API for invalidation\n│       ├── middleware/                  # Response processing\n│       │   ├── __init__.py\n│       │   ├── compression.py           # gzip/Brotli compression\n│       │   └── analytics.py             # Metrics collection\n│       ├── utils/                       # Utilities\n│       │   ├── __init__.py\n│       │   ├── http_utils.py            # parse_http_date, etc.\n│       │   └── headers.py               # Header manipulation\n│       └── server.py                    # Main server entry point\n└── tests/</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (COMPLETE HTTP Utilities):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/utils/http_utils.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">HTTP utility functions for parsing and formatting dates, headers, etc.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> email.utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parsedate_to_datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> urllib.parse </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> urlparse, urlunparse</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_http_date</span><span style=\"color:#E1E4E8\">(date_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parse an RFC 1123/822 date string into a Unix timestamp.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> date_str:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parsedate_to_datetime(date_str)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> dt.timestamp()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">ValueError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> format_http_date</span><span style=\"color:#E1E4E8\">(timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Format a Unix timestamp to RFC 1123 string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> time.strftime(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">%a</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %b</span><span style=\"color:#9ECBFF\"> %Y %H:%M:%S GMT'</span><span style=\"color:#E1E4E8\">, time.gmtime(timestamp))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_cache_control_header</span><span style=\"color:#E1E4E8\">(header_value: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse Cache-Control header into dictionary of directives.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Example: \"max-age=60, public\" -> {\"max-age\": \"60\", \"public\": None}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> header_value:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> part </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> header_value.split(</span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        part </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> part.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> '='</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> part:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            key, val </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> part.split(</span><span style=\"color:#9ECBFF\">'='</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            directives[key.strip()] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> val.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            directives[part] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> directives</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_header_values</span><span style=\"color:#E1E4E8\">(headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], header_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Get all values for a header (handling comma-separated and multiple headers).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    HTTP allows multiple headers with same name and comma-separated values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Case-insensitive search</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    header_name_lower </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> header_name.lower()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matched_values </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name, value </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> headers.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name.lower() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> header_name_lower:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Split by comma, but be careful of quoted strings (simple split works for most caching headers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            matched_values.extend([v.strip() </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> v </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> value.split(</span><span style=\"color:#9ECBFF\">','</span><span style=\"color:#E1E4E8\">)])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> matched_values</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_url</span><span style=\"color:#E1E4E8\">(url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Normalize URL for cache key: lowercase scheme/host, remove default port.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Does NOT sort query parameters (application-specific).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> urlparse(url)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Lowercase scheme and host</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parsed.scheme.lower()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    netloc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parsed.hostname.lower() </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> parsed.hostname </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> ''</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add port if non-default</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> parsed.port:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> (scheme </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'http'</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> parsed.port </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 80</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> (scheme </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'https'</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> parsed.port </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 443</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            netloc </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">netloc</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">parsed.port</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Reconstruct without fragment (fragment is never sent to server)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> urlunparse((scheme, netloc, parsed.path, parsed.params, parsed.query, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/cache/key_generator.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Cache key generation combining URL and Vary header values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.http_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> normalize_url</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_cache_key</span><span style=\"color:#E1E4E8\">(url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, vary_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], vary_header_list: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate a cache key from URL and the values of headers specified in Vary.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        url: The request URL (will be normalized).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        vary_headers: Dictionary containing ALL request headers (lowercased keys).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        vary_header_list: List of header names from the cached response's Vary header.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        A string cache key.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Normalize the URL using normalize_url()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: For each header name in vary_header_list:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            a. Get its value from vary_headers (case-insensitive)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            b. If header is not present, use empty string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            c. Normalize header value (strip, lowercase for some headers?)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Sort the vary_header_list to ensure consistent key generation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            (Vary: Accept-Encoding,User-Agent should match Vary: User-Agent,Accept-Encoding)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Combine normalized URL with sorted header name-value pairs</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Example format: \"GET:{url}:{header1}={value1}:{header2}={value2}\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 5: Return the combined string (consider hashing for shorter keys if needed)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/models/cache.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Cache data structures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheDirectives</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parsed Cache-Control directives.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s_maxage: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_age: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_cache: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    no_store: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    must_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    proxy_revalidate: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    public: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    private: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_while_revalidate: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stale_if_error: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_header</span><span style=\"color:#E1E4E8\">(cls, cache_control_header: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#9ECBFF\">'CacheDirectives'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse a Cache-Control header string into a structured object.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Use parse_cache_control_header() to get dictionary of directives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Initialize a CacheDirectives instance with default values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: For each key-value in the dictionary:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                a. Handle boolean directives (no-cache, no-store, etc.): set to True if present</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                b. Handle numeric directives (s-maxage, max-age, etc.): convert string to int</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Special case: 'public' and 'private' are mutually exclusive</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                (private takes precedence if both are present per RFC 9111)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: Return the populated CacheDirectives object</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheEntry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A cached HTTP response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    key: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    url: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vary_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status_code: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body: </span><span style=\"color:#79B8FF\">bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fetched_at: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expires_at: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_used_at: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    use_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    surrogate_keys: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    etag: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_modified: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_fresh</span><span style=\"color:#E1E4E8\">(self, current_time: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if cache entry is still fresh.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True if current_time &#x3C; expires_at, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_stale_but_revalidatable</span><span style=\"color:#E1E4E8\">(self, current_time: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, directives: CacheDirectives) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if stale entry can be served during revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: If entry is fresh, return False (no need for revalidation)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Calculate staleness: current_time - expires_at</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Check if directives.stale_while_revalidate exists and staleness &#x3C;= that value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Return True if conditions met, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_upstream_response</span><span style=\"color:#E1E4E8\">(cls, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, vary_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               status_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               surrogate_keys: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#9ECBFF\">'CacheEntry'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Factory method to create a CacheEntry from an upstream HTTP response.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Parse Cache-Control header from response headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Calculate TTL and set expires_at (use current time for fetched_at)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Extract ETag and Last-Modified headers if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Create and return a CacheEntry instance with all fields populated</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/handlers/edge_handler.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Main edge request handler.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..cache.storage </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheStorage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models.cache </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheEntry, CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.http_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_http_date, get_header_values</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache: CacheStorage, upstream: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.upstream </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> upstream</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main request handling algorithm for the edge node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Extract method, URL, and relevant headers from request_headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Check if request is cacheable (method GET/HEAD, no no-store directive)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Generate preliminary cache key (use request's Vary-relevant headers)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Look up entry in cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: If cache HIT:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                a. Check freshness and revalidation rules</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                b. If fresh or stale-while-revalidate: serve from cache</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                c. If needs validation: add If-None-Match/If-Modified-Since</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 6: If cache MISS or validation needed:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                a. Forward request to upstream with conditional headers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                b. Handle response:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                   - 304: Update cached entry metadata, serve cached body</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                   - 200: Create new cache entry if cacheable</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                   - Other: Pass through</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 7: Apply compression middleware if applicable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 8: Add diagnostic headers (X-Cache: HIT/MISS)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 9: Update metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 10: Return final response</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _fetch_from_upstream</span><span style=\"color:#E1E4E8\">(self, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Forward request to upstream (shield or origin).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Add CDN-specific headers (X-Forwarded-For, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Make HTTP request to self.upstream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Return status, headers, body from upstream response</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _revalidate_in_background</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, cache_entry: CacheEntry,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Asynchronously revalidate a stale cache entry.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Create a background thread/task</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Make conditional request to upstream with cache_entry.etag/last_modified</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: If 304: Update cache_entry.fetched_at and expires_at</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: If 200: Replace cache entry with new response</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 5: If error: Log and keep stale entry (might be served via stale-if-error later)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python):</strong></p>\n<ul>\n<li>Use <code>threading.Lock</code> or <code>asyncio.Lock</code> to protect concurrent access to the cache storage.</li>\n<li>For LRU cache implementation, <code>collections.OrderedDict</code> maintains insertion order. On every cache hit, move the key to the end using <code>move_to_end(key, last=True)</code>. When evicting, pop the first item.</li>\n<li>Use <code>email.utils.parsedate_to_datetime</code> for robust HTTP date parsing (handles multiple formats).</li>\n<li>For background tasks, consider <code>concurrent.futures.ThreadPoolExecutor</code> or <code>asyncio.create_task</code> depending on your concurrency model.</li>\n<li>When applying compression, check <code>Accept-Encoding</code> header for <code>gzip</code> or <code>br</code> (Brotli). Use Python&#39;s <code>gzip.compress()</code> and the <code>brotli</code> library if installed.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint (Edge Cache):</strong>\nAfter implementing the edge cache, run the following test:</p>\n<ol>\n<li>Start your edge server: <code>python -m blue_origin.server --config config.yaml</code></li>\n<li>Use <code>curl</code> to make requests:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   curl -v http://localhost:8080/image.jpg</code></pre></div>\n<p>   First request should show <code>X-Cache: MISS</code>. Second identical request should show <code>X-Cache: HIT</code>.\n3. Test conditional requests: Add an <code>If-None-Match</code> header with a known ETag from a previous response. You should receive <code>304 Not Modified</code>.\n4. Verify TTL: Set a <code>Cache-Control: max-age=2</code> header on your origin server. Request the resource, wait 3 seconds, request again. The second request should trigger a revalidation or miss.\n5. Check compression: <code>curl -H &quot;Accept-Encoding: gzip&quot; -v http://localhost:8080/some-text.html</code> should show <code>Content-Encoding: gzip</code> in the response.</p>\n<p>Expected behavior: The edge server responds correctly to cache directives, respects freshness, and shows improved performance on repeated requests.</p>\n<h2 id=\"component-cache-invalidation-milestone-2\">Component: Cache Invalidation (Milestone 2)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Cache Invalidation)</p>\n</blockquote>\n<p>The edge cache&#39;s ability to serve content quickly becomes useless when that content changes at the origin. <strong>Cache invalidation</strong>—the active removal or marking of outdated cached content—is the mechanism that maintains consistency between the cached copies and the origin&#39;s truth. This component transforms the CDN from a static snapshotter into a dynamic, synchronized delivery system. Implementing invalidation is a classic distributed systems challenge: we must ensure that updates propagate to potentially hundreds of edge nodes, each holding independent copies, without overwhelming the system or introducing prolonged inconsistency windows.</p>\n<h3 id=\"mental-model-the-building-eviction-notice\">Mental Model: The Building Eviction Notice</h3>\n<p>Imagine the CDN&#39;s cache as a large apartment building (the cache storage). Each apartment (cache entry) is rented by a tenant (a cached response). When the building owner (the origin) decides to change the terms or reclaim an apartment, they issue different types of notices:</p>\n<ol>\n<li><p><strong>Hard Purge (Immediate Eviction):</strong> A sheriff arrives, immediately removes the tenant, and changes the locks. The apartment is now empty. This is analogous to a <strong>hard purge</strong>—the cache entry is deleted instantly. The next request for that resource will experience a cache miss and fetch a fresh copy from the origin.</p>\n</li>\n<li><p><strong>Soft Purge (Notice to Renew Lease):</strong> The owner posts a notice saying, &quot;Your current lease expires now, but you can stay while we process a renewal.&quot; The tenant remains in the apartment temporarily. This is a <strong>soft purge</strong> (or stale-while-revalidate). The cache marks the entry as stale but continues serving it to clients while asynchronously fetching a fresh version in the background. This provides graceful degradation and avoids a thundering herd of requests to the origin.</p>\n</li>\n<li><p><strong>Ban (Evicting Everyone on a Floor):</strong> The building manager declares, &quot;Everyone in apartments with numbers ending in &#39;01&#39; must leave.&quot; This is a <strong>ban</strong>—a pattern-based invalidation. Instead of specifying each apartment, you define a rule (e.g., a URL pattern like <code>/blog/*</code>). The eviction may happen immediately or, in <strong>eventual invalidation</strong>, only when someone next tries to enter that apartment (cache access). Bans are powerful for bulk operations but require careful management to avoid unbounded rule growth.</p>\n</li>\n<li><p><strong>Surrogate Key Purge (Tag-Based Eviction):</strong> Apartments are tagged with colored stickers representing features (e.g., &quot;renovated,&quot; &quot;ocean view&quot;). The owner announces, &quot;All apartments with a &#39;renovated&#39; sticker must be updated.&quot; This is <strong>tag-based invalidation</strong> using <strong>surrogate keys</strong>. Cache entries are tagged (e.g., with <code>product-12345</code>) upon storage. Invalidating by that tag removes all related entries in a single operation, which is far more efficient than listing every individual URL.</p>\n</li>\n</ol>\n<p>This mental model clarifies the trade-offs: immediacy vs. origin load, precision vs. management overhead. A production CDN uses all these &quot;notice types&quot; in different scenarios.</p>\n<h3 id=\"purge-ban-and-tag-based-invalidation\">Purge, Ban, and Tag-Based Invalidation</h3>\n<p>The invalidation component exposes administrative APIs and internal logic to execute the three core invalidation strategies. Each strategy targets a different granularity and use case.</p>\n<h4 id=\"1-purge-by-exact-url\">1. Purge by Exact URL</h4>\n<p>The most precise operation. It removes a single cached response identified by its exact cache key (URL + Vary header values).</p>\n<p><strong>Algorithm: Hard Purge by URL</strong></p>\n<ol>\n<li>An administrative request arrives (e.g., <code>PURGE /images/photo.jpg</code> with authentication).</li>\n<li>The handler validates the requestor&#39;s permissions.</li>\n<li>It constructs the exact cache key from the request URL and the relevant <code>Vary</code> header dimensions (extracted from the request or by looking up the stored entry).</li>\n<li>It synchronously deletes the corresponding <code>CacheEntry</code> from the <code>CacheStorage</code>.</li>\n<li>It removes the cache key from the <code>SurrogateKeyIndex</code> (if indexed).</li>\n<li>It returns a <code>200 OK</code> acknowledging the purge.</li>\n</ol>\n<p><strong>Algorithm: Soft Purge by URL</strong></p>\n<ol>\n<li>Steps 1-3 are identical to hard purge.</li>\n<li>Instead of deletion, it updates the <code>CacheEntry.expires_at</code> to a timestamp in the past (e.g., <code>current_time - 1</code>), immediately marking it stale.</li>\n<li>It optionally sets a flag or updates metadata to indicate the entry is under soft purge.</li>\n<li>It triggers <code>_revalidate_in_background</code> for this key, which will asynchronously fetch a new version from the origin and update the cache.</li>\n<li>Subsequent client requests for this key will be served the stale content (if <code>stale-while-revalidate</code> directives allow) while the background refresh proceeds.</li>\n<li>Returns a <code>200 OK</code> acknowledging the soft purge.</li>\n</ol>\n<p><strong>API Specification</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Path</th>\n<th>Headers</th>\n<th>Body</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PURGE</code></td>\n<td><code>/{path:.*}</code></td>\n<td><code>Authorization: Bearer &lt;token&gt;</code>, <code>Soft-Purge: 1</code> (optional)</td>\n<td>Empty</td>\n<td><code>200 OK</code> (success), <code>404 Not Found</code> (key not in cache), <code>401 Unauthorized</code></td>\n<td>Hard or soft purge of the exact URL path. The <code>Soft-Purge</code> header triggers the soft purge behavior.</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-ban-by-pattern-eventual-invalidation\">2. Ban by Pattern (Eventual Invalidation)</h4>\n<p>A ban is a rule that invalidates cache entries matching a pattern (e.g., a regex or glob applied to the URL). For performance, bans are often applied <strong>lazily</strong> (eventually) upon cache access, not by scanning the entire cache store.</p>\n<p><strong>Data Structure: <code>BanRule</code></strong>\nWe extend the provided structure to support pattern matching and TTL.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pattern</code></td>\n<td><code>str</code></td>\n<td>The URL-matching pattern (e.g., glob <code>&quot;/images/*.jpg&quot;</code> or regex <code>&quot;^/blog/2024-&quot;</code>).</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td><code>float</code></td>\n<td>Unix timestamp when the ban was created.</td>\n</tr>\n<tr>\n<td><code>is_soft</code></td>\n<td><code>bool</code></td>\n<td>If <code>True</code>, matching entries are marked stale (soft purge). If <code>False</code>, they are deleted (hard purge).</td>\n</tr>\n<tr>\n<td><code>ttl_seconds</code></td>\n<td><code>float</code></td>\n<td>Time-to-live for this ban rule. After expiry, the rule is garbage-collected. Prevents unbounded growth.</td>\n</tr>\n<tr>\n<td><code>id</code></td>\n<td><code>str</code></td>\n<td>Unique identifier for the ban rule.</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm: Adding a Ban Rule</strong></p>\n<ol>\n<li>Admin request (<code>POST /ban</code> with pattern and soft/hard flag).</li>\n<li>Validate and compile the pattern for efficient matching.</li>\n<li>Create a new <code>BanRule</code> with <code>created_at = current_time</code> and assign a unique ID.</li>\n<li>Store the rule in a <code>BanRuleList</code> (e.g., a list or priority queue sorted by <code>created_at</code>).</li>\n<li>Return the ban rule ID.</li>\n</ol>\n<p><strong>Algorithm: Applying Bans (Lazy Evaluation)</strong>\nThis logic integrates into the main <code>EdgeRequestHandler.handle_request</code> flow, just after cache key generation but before cache lookup.</p>\n<ol>\n<li>When a request arrives, generate the cache key (URL).</li>\n<li>Before checking the cache, iterate through the active <code>BanRuleList</code>.</li>\n<li>For each <code>BanRule</code> where <code>BanRule.matches(cache_key.url)</code> returns <code>True</code>:\na. If <code>is_soft</code> is <code>False</code>: Delete the cache entry for this key (if it exists) and skip to origin fetch (cache miss).\nb. If <code>is_soft</code> is <code>True</code>: Mark the existing entry as stale (set <code>expires_at</code> in the past) and allow the request to proceed. The stale entry may be served while triggering background revalidation.</li>\n<li>If no matching ban rule applies, proceed with normal cache lookup.</li>\n</ol>\n<p><strong>Garbage Collection of Ban Rules</strong>\nA background task periodically scans the <code>BanRuleList</code> and removes rules where <code>current_time &gt; created_at + ttl_seconds</code>. A typical TTL for bans might be 24-48 hours.</p>\n<p><strong>API Specification</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Path</th>\n<th>Headers</th>\n<th>Body (JSON)</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>POST</code></td>\n<td><code>/ban</code></td>\n<td><code>Authorization: Bearer &lt;token&gt;</code></td>\n<td><code>{&quot;pattern&quot;: &quot;/images/*.jpg&quot;, &quot;soft&quot;: false, &quot;ttl_seconds&quot;: 86400}</code></td>\n<td><code>201 Created</code> with <code>{&quot;ban_id&quot;: &quot;...&quot;}</code></td>\n<td>Creates a new ban rule.</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td><code>/ban/{ban_id}</code></td>\n<td><code>Authorization: Bearer &lt;token&gt;</code></td>\n<td>Empty</td>\n<td><code>200 OK</code> or <code>404 Not Found</code></td>\n<td>Removes a specific ban rule.</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-tag-based-invalidation-with-surrogate-keys\">3. Tag-Based Invalidation with Surrogate Keys</h4>\n<p>This method groups cache entries by arbitrary tags (surrogate keys) provided by the origin via the <code>Surrogate-Key</code> response header. Invalidating by a tag removes all entries associated with that tag.</p>\n<p><strong>Data Structure: <code>SurrogateKeyIndex</code></strong>\nWe utilize the provided structure, which maintains a bidirectional mapping.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>key_to_tags</code></td>\n<td><code>Dict[str, List[str]]</code></td>\n<td>Maps a cache key to a list of surrogate key tags associated with that entry.</td>\n</tr>\n<tr>\n<td><code>tag_to_keys</code></td>\n<td><code>Dict[str, Set[str]]</code></td>\n<td>Maps a tag to a set of cache keys that are tagged with it.</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm: Tagging on Cache Storage</strong></p>\n<ol>\n<li>When storing a new <code>CacheEntry</code> (on cache miss), extract the <code>Surrogate-Key</code> header from the origin response. The header value is a space-separated list of tags (e.g., <code>Surrogate-Key: product-12345 category-shoes</code>).</li>\n<li>Store the list of tags in <code>CacheEntry.surrogate_keys</code>.</li>\n<li>Call <code>SurrogateKeyIndex.add_entry(cache_key, tags)</code> to update the index.</li>\n</ol>\n<p><strong>Algorithm: Purging by Tag</strong></p>\n<ol>\n<li>Admin request (<code>PURGE /purge/tag/{tag}</code>).</li>\n<li>Call <code>SurrogateKeyIndex.purge_by_tag(tag)</code>. This returns the set of cache keys associated with the tag and clears the index for that tag.</li>\n<li>For each cache key in the returned set:\na. Perform a hard or soft purge (based on request headers) of that individual cache key.</li>\n<li>Return a summary: <code>200 OK</code> with <code>{&quot;purged_keys_count&quot;: 123}</code>.</li>\n</ol>\n<p><strong>API Specification</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Path</th>\n<th>Headers</th>\n<th>Body</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PURGE</code></td>\n<td><code>/purge/tag/{tag}</code></td>\n<td><code>Authorization: Bearer &lt;token&gt;</code>, <code>Soft-Purge: 1</code> (optional)</td>\n<td>Empty</td>\n<td><code>200 OK</code> with count of purged keys</td>\n<td>Purges all cache entries tagged with the given surrogate key.</td>\n</tr>\n</tbody></table>\n<h3 id=\"invalidation-propagation-strategy\">Invalidation Propagation Strategy</h3>\n<p>An invalidation command issued to one edge node must eventually take effect across <strong>all</strong> edge nodes in the CDN. <img src=\"/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fseq-invalidation-propagation.svg\" alt=\"Sequence: Purge Propagation via Control Plane\"> illustrates the ideal flow. The strategy defines how this propagation is achieved, balancing consistency, latency, and system complexity.</p>\n<p><strong>Core Requirements:</strong></p>\n<ul>\n<li><strong>Eventual Consistency:</strong> All nodes should reflect the invalidation within a bounded time window (e.g., &lt; 60 seconds).</li>\n<li><strong>Reliability:</strong> Invalidation messages must not be lost even if individual nodes or the network temporarily fail.</li>\n<li><strong>Scalability:</strong> The propagation mechanism should not create a bottleneck as the number of edge nodes grows (e.g., from 10 to 10,000).</li>\n<li><strong>Ordering (Sometimes):</strong> For certain operations, order matters (e.g., &quot;update item A, then purge its cache&quot;). The system should preserve this order where required.</li>\n</ul>\n<p><strong>Propagation Steps:</strong></p>\n<ol>\n<li><strong>Ingestion:</strong> An admin issues a purge command to a designated <strong>control plane</strong> API (or directly to any edge node, which forwards it).</li>\n<li><strong>Fan-out:</strong> The control plane broadcasts the invalidation message to all registered edge nodes. This can be done via:<ul>\n<li><strong>Direct HTTP calls</strong> to each node&#39;s administrative endpoint (simple but doesn&#39;t scale, no persistence).</li>\n<li>A <strong>publish-subscribe (pub/sub) message queue</strong> (e.g., Redis Pub/Sub, Kafka, NATS). Edge nodes subscribe to an invalidation channel.</li>\n<li>A <strong>gossip protocol</strong> where nodes propagate the message to their peers (decentralized, resilient, but complex).</li>\n</ul>\n</li>\n<li><strong>Acknowledgment &amp; Retry:</strong> Edge nodes acknowledge receipt. The control plane retries unacknowledged messages with exponential backoff.</li>\n<li><strong>Local Execution:</strong> Each edge node receives the message, validates it, and executes the local purge/ban logic described earlier.</li>\n<li><strong>Monitoring:</strong> The control plane logs completion and can provide a dashboard showing propagation status.</li>\n</ol>\n<h3 id=\"adr-invalidation-propagation-mechanism\">ADR: Invalidation Propagation Mechanism</h3>\n<blockquote>\n<p><strong>Decision: Use a Centralized Pub/Sub System for Invalidation Propagation</strong></p>\n<ul>\n<li><strong>Context</strong>: The CDN needs to propagate cache invalidation commands (purge, ban, tag) from an administrative source to all edge nodes. The system has a moderate number of edge nodes (10s to 100s initially), and the control plane is already a central component for configuration and analytics. We need a reliable, scalable, and simple-to-implement propagation mechanism.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Direct HTTP Broadcast from Control Plane</strong>: The control plane maintains a list of edge node admin endpoints and <code>POST</code>s the invalidation command to each sequentially or in parallel.</li>\n<li><strong>Pub/Sub Message Queue (Centralized)</strong>: Edge nodes subscribe to a channel (e.g., <code>invalidation</code>) on a centralized message broker (like Redis). The control plane publishes messages to this channel.</li>\n<li><strong>Gossip Protocol (Decentralized)</strong>: Edge nodes form a peer-to-peer mesh and propagate invalidation messages via a gossip protocol (like SWIM or epidemic broadcasting).</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: We will implement Option 2: A centralized Pub/Sub system using a simple broker. Initially, we can use an in-memory broker within the control plane for simplicity, with the ability to replace it with Redis or NATS for production scaling.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Scalability</strong>: Pub/Sub decouples the control plane from edge nodes. The control plane publishes once, and the broker handles fan-out. This scales better than the control plane managing direct connections to hundreds of nodes (Option 1).</li>\n<li><strong>Reliability</strong>: Most message brokers offer persistence and retry mechanisms. If an edge node is temporarily offline, it can reconnect and receive missed messages (depending on broker configuration). Direct HTTP (Option 1) requires the control plane to implement complex retry and state tracking.</li>\n<li><strong>Simplicity</strong>: Implementing a robust gossip protocol (Option 3) is complex and introduces its own consistency and convergence timing issues. For an educational project, Pub/Sub is a more understandable and industry-standard pattern.</li>\n<li><strong>Natural Fit</strong>: The control plane is already a central coordination point. Adding a Pub/Sub broker aligns with its role.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>The control plane and edge nodes now depend on the availability of the message broker. This introduces a new single point of failure. Mitigation: Use a clustered broker or accept that invalidation is a best-effort, non-critical path (serving stale content is often acceptable briefly).</li>\n<li>Edge nodes must maintain a persistent connection or polling mechanism to the broker, adding some network overhead.</li>\n<li>Message ordering is guaranteed per-channel in most brokers, which simplifies handling of related purge sequences.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Direct HTTP Broadcast</strong></td>\n<td>Simple, no new components, strong consistency if all calls succeed.</td>\n<td>Control plane becomes a bottleneck, hard to scale, must manage connection/retry logic, no persistence if edge node is down.</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Centralized Pub/Sub</strong></td>\n<td>Decouples components, scalable, brokers often provide persistence and retry, industry standard.</td>\n<td>Introduces a new component (broker) as a potential SPOF, requires managing broker connections.</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td><strong>Gossip Protocol</strong></td>\n<td>Highly resilient, no central broker, scales well.</td>\n<td>Complex to implement correctly, convergence time can be unpredictable, debugging is harder.</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-invalidation\">Common Pitfalls in Invalidation</h3>\n<p>⚠️ <strong>Pitfall: Unbounded Growth of the Ban List</strong></p>\n<ul>\n<li><strong>Description</strong>: Continuously adding ban rules without ever removing them. Over weeks, the list grows to thousands of rules. Every incoming request must be checked against all rules, causing linear performance degradation (<code>O(n)</code> per request).</li>\n<li><strong>Why it&#39;s wrong</strong>: It turns a performance optimization (caching) into a performance bottleneck. Eventually, request latency becomes dominated by ban rule matching.</li>\n<li><strong>How to fix</strong>: Attach a <strong>TTL to every ban rule</strong>. Implement a background garbage collection task that periodically removes expired rules. For long-term bans, consider converting them to a more permanent configuration (like a cache rule that sets a very short TTL for a path pattern).</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Race Condition During Revalidation</strong></p>\n<ul>\n<li><strong>Description</strong>: A soft purge triggers background revalidation. Simultaneously, a client request for the same resource arrives. Both the background task and the client request might independently fetch from the origin, causing a duplicate request (wasting origin capacity) or a race in updating the cache entry.</li>\n<li><strong>Why it&#39;s wrong</strong>: It undermines the request collapsing benefits of the origin shield and can lead to inconsistent cache state if the two fetches return slightly different data (e.g., due to timing).</li>\n<li><strong>How to fix</strong>: Implement a <strong>revalidation lock per cache key</strong>. Use a dictionary mapping cache keys to <code>asyncio.Lock</code> (or similar) or a promise/future. The first entity (background job or client request) that finds a stale entry acquires the lock and performs the origin fetch. Others wait on the same lock and reuse its result.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Propagation Delay</strong></p>\n<ul>\n<li><strong>Description</strong>: After issuing a global purge, the developer assumes all edge nodes are instantly updated and tests from a single location, seeing fresh content. However, users in other regions may still see stale content for seconds or minutes due to propagation lag.</li>\n<li><strong>Why it&#39;s wrong</strong>: It creates a false sense of consistency and can lead to user complaints (&quot;I cleared the cache but my friend still sees the old version&quot;).</li>\n<li><strong>How to fix</strong>: <strong>Design for eventual consistency</strong>. Document the expected propagation SLA (e.g., &lt; 30s). Provide an API or admin UI to track the propagation status of an invalidation event. For scenarios requiring stronger guarantees, consider using cache versioning in URLs (e.g., <code>/image.jpg?v=2</code>) instead of purging.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Surrogate Key Collision and Over-Invalidation</strong></p>\n<ul>\n<li><strong>Description</strong>: Using overly broad surrogate keys (e.g., tagging all blog posts with <code>&quot;blog&quot;</code>). Purging <code>&quot;blog&quot;</code> invalidates the entire blog cache, causing a massive origin load spike (a &quot;cache miss storm&quot;) when those pages are next requested.</li>\n<li><strong>Why it&#39;s wrong</strong>: Loses the granularity benefit of caching. It&#39;s equivalent to banning <code>/blog/*</code> but with less visibility.</li>\n<li><strong>How to fix</strong>: <strong>Use granular surrogate keys</strong>. Combine broad and specific tags. For example, a product page could be tagged with <code>&quot;product-12345&quot;</code>, <code>&quot;category-shoes&quot;</code>, and <code>&quot;page-type-detail&quot;</code>. This allows invalidating a single product, all shoes, or all detail pages independently. Educate content authors on key design.</li>\n</ul>\n<h3 id=\"implementation-guidance-for-invalidation\">Implementation Guidance for Invalidation</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalidation API</td>\n<td>HTTP <code>PURGE</code> method with bearer token authentication</td>\n<td>gRPC admin service with richer semantics (e.g., dry-run, scheduled purge)</td>\n</tr>\n<tr>\n<td>Propagation Broker</td>\n<td>In-memory Pub/Sub within the Control Plane process (using <code>asyncio.Queue</code> or <code>concurrent.futures</code>)</td>\n<td>External Redis Pub/Sub or Apache Kafka for persistence and scale</td>\n</tr>\n<tr>\n<td>Pattern Matching for Bans</td>\n<td>Python&#39;s <code>fnmatch</code> for glob patterns (<code>/images/*.jpg</code>)</td>\n<td>Regular expressions (<code>re</code> module) for maximum flexibility (with careful compilation caching)</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin/\n├── cdn/\n│   ├── __init__.py\n│   ├── edge/\n│   │   ├── __init__.py\n│   │   ├── server.py              # Edge HTTP server, includes request handler\n│   │   ├── cache.py               # CacheStorage, CacheEntry, SurrogateKeyIndex\n│   │   ├── handler.py             # EdgeRequestHandler (includes ban checking)\n│   │   └── invalidation.py        # Purge/Ban API handlers, local invalidation logic\n│   ├── shield/\n│   │   └── ...                    # Origin shield components\n│   ├── control/\n│   │   ├── __init__.py\n│   │   ├── plane.py               # Control plane HTTP server, pub/sub broker\n│   │   └── propagation.py         # Message formats, publisher/subscriber clients\n│   └── common/\n│       ├── __init__.py\n│       ├── http_utils.py          # parse_http_date, format_http_date, etc.\n│       ├── models.py              # Shared data models (EdgeConfig, etc.)\n│       └── auth.py                # Simple token validation utilities\n├── scripts/\n│   └── purge_cli.py               # Command-line tool for issuing purge commands\n└── tests/\n    └── test_invalidation.py       # Unit and integration tests for invalidation</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>Simple In-Memory Pub/Sub Broker (<code>control/propagation.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Set, Any, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidationMessage</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Message format for cache invalidation commands.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    command: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # \"PURGE\", \"BAN\", \"PURGE_TAG\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">   # URL, pattern, or tag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Additional parameters can be added as a dict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_json</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> json.dumps({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"message_id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"command\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.command,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"target\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.target,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"soft\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.soft,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"timestamp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.timestamp,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"parameters\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parameters </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_json</span><span style=\"color:#E1E4E8\">(cls, data: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">\"InvalidationMessage\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        d </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.loads(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> cls</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            message_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">d[</span><span style=\"color:#9ECBFF\">\"message_id\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            command</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">d[</span><span style=\"color:#9ECBFF\">\"command\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            target</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">d[</span><span style=\"color:#9ECBFF\">\"target\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            soft</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">d.get(</span><span style=\"color:#9ECBFF\">\"soft\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">d.get(</span><span style=\"color:#9ECBFF\">\"timestamp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            parameters</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">d.get(</span><span style=\"color:#9ECBFF\">\"parameters\"</span><span style=\"color:#E1E4E8\">, {})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InMemoryPubSubBroker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A simple in-memory publish-subscribe broker for invalidation messages.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._subscribers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Set[Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Lock()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> subscribe</span><span style=\"color:#E1E4E8\">(self, channel: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, callback: Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Subscribe a callback function to a channel.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> channel </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._subscribers[channel] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._subscribers[channel].add(callback)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.debug(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"New subscriber to channel '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">channel</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'. Total: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._subscribers[channel])</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> unsubscribe</span><span style=\"color:#E1E4E8\">(self, channel: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, callback: Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Unsubscribe a callback from a channel.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> channel </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._subscribers[channel].discard(callback)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers[channel]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers[channel]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> publish</span><span style=\"color:#E1E4E8\">(self, channel: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, message: InvalidationMessage):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Publish a message to all subscribers of a channel.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Publishing message </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message.message_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> to channel '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">channel</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            subscribers </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers.get(channel, </span><span style=\"color:#79B8FF\">set</span><span style=\"color:#E1E4E8\">()).copy()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Call subscribers without holding the lock to avoid deadlocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> callback </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> subscribers:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Fire and forget; consider error handling in production</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                asyncio.create_task(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._safe_callback(callback, message))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error scheduling callback for message </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message.message_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _safe_callback</span><span style=\"color:#E1E4E8\">(self, callback: Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">], message: InvalidationMessage):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Wrapper to log errors in subscriber callbacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> callback(message)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Subscriber callback failed for message </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">message.message_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global broker instance (simple singleton)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">broker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InMemoryPubSubBroker()</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>Purge API Handler (<code>edge/invalidation.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> fnmatch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Set, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .cache </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheStorage, SurrogateKeyIndex</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.auth </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> validate_token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidationHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles administrative invalidation commands (purge, ban, tag).\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache: CacheStorage, key_index: SurrogateKeyIndex, control_plane_publisher</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.key_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> key_index</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.ban_rules: List[BanRule] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []  </span><span style=\"color:#6A737D\"># In-memory list, could be persisted</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.control_plane_publisher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> control_plane_publisher  </span><span style=\"color:#6A737D\"># Optional publisher for propagation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_purge_request</span><span style=\"color:#E1E4E8\">(self, request_method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, request_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handles HTTP PURGE requests.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Expected path: /{path...} for URL purge, /purge/tag/{tag} for tag purge.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Headers: Authorization, Soft-Purge.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate the Authorization header using validate_token.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   If invalid, return 401 Unauthorized.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Determine if this is a tag purge or URL purge.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Check if request_path starts with '/purge/tag/'.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   If yes, extract the tag and proceed to tag purge logic (step 6).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For URL purge: Extract the target URL from request_path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Generate the cache key. This requires knowing the Vary headers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Hint: You may need to look up the existing CacheEntry to get its vary_headers.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for the 'Soft-Purge' header (e.g., '1' or 'true').</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Set a boolean flag `is_soft`.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Perform the local purge.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   If is_soft: call self._soft_purge_key(cache_key).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Else: call self._hard_purge_key(cache_key).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Return 200 OK with appropriate body (e.g., \"Purged\" or \"Soft purged\").</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For tag purge: Extract tag from path.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Call self._purge_by_tag(tag, is_soft).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Return 200 OK with count of purged keys.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7 (Optional - Propagation): If self.control_plane_publisher is set,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   construct an InvalidationMessage and publish it to the 'invalidation' channel.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   This allows other edge nodes to learn about this purge.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _hard_purge_key</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Immediately delete a cache entry by key.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Delete the entry from self.cache.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Remove the entry from self.key_index using key_index.remove_entry(cache_key).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _soft_purge_key</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark a cache entry as stale and trigger background revalidation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Retrieve the CacheEntry from self.cache.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If entry exists, set its expires_at to a past timestamp (e.g., time.time() - 1).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Optionally, set a flag in the entry metadata (e.g., entry.is_soft_purged = True).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Trigger background revalidation: asyncio.create_task(_revalidate_in_background(...)).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   You'll need to pass appropriate request headers (maybe default ones).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _purge_by_tag</span><span style=\"color:#E1E4E8\">(self, tag: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, is_soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Purge all cache entries associated with a surrogate key tag.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call self.key_index.purge_by_tag(tag) to get the set of cache keys.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each cache key in the set:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if is_soft: self._soft_purge_key(key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   else: self._hard_purge_key(key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return the count of purged keys.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> add_ban_rule</span><span style=\"color:#E1E4E8\">(self, pattern: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, is_soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, ttl_seconds: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a new ban rule and return its ID.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate a unique ID for the rule (e.g., using uuid or timestamp).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create a BanRule object with pattern, is_soft, ttl_seconds, and current time.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Append the rule to self.ban_rules.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Schedule a garbage collection task if not already running.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the rule ID.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_bans</span><span style=\"color:#E1E4E8\">(self, url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[BanRule]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if a URL matches any active ban rule. Returns the first matching rule.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> rule </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.ban_rules:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Skip rule if it's expired (current_time > rule.created_at + rule.ttl_seconds).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If rule.matches(url): return rule.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   For glob matching: fnmatch.fnmatch(url, rule.pattern)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            #   For regex: use a pre-compiled regex stored in the rule.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _gc_ban_rules</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background task to garbage collect expired ban rules.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(</span><span style=\"color:#79B8FF\">3600</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Run every hour</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Filter self.ban_rules, keeping only rules where current_time &#x3C;= created_at + ttl_seconds.</span></span></code></pre></div>\n\n<p><strong>Integration into EdgeRequestHandler (<code>edge/handler.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache: CacheStorage, upstream: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, invalidation_handler: InvalidationHandler):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.upstream </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> upstream</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.invalidation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> invalidation_handler</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # ... existing code to parse request ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Insert ban checking early in the flow (after generating the URL but before cache lookup).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   ban_rule = self.invalidation.check_bans(url)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   if ban_rule:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #       if not ban_rule.is_soft:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #           # Hard ban: delete cache entry if exists, then proceed as cache miss.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #           self.invalidation._hard_purge_key(cache_key)  # cache_key may need URL only variant</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #       else:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #           # Soft ban: mark existing entry stale.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #           self.invalidation._soft_purge_key(cache_key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #       # Continue; the cache lookup will now miss or find a stale entry.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # ... rest of the caching logic ...</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li>Use Python&#39;s <code>asyncio.Lock</code> or <code>asyncio.Queue</code> for coordinating background revalidation and preventing thundering herds.</li>\n<li>For pattern matching in bans, <code>fnmatch</code> is simpler and safer than regex for globs. If using regex, pre-compile them with <code>re.compile(pattern)</code> and store the compiled object in the <code>BanRule</code> to avoid compilation on every request.</li>\n<li>Use <code>asyncio.create_task</code> for fire-and-forget background operations like revalidation or garbage collection. Consider using a bounded semaphore (<code>asyncio.Semaphore</code>) to limit concurrent revalidation tasks.</li>\n<li>For the simple in-memory Pub/Sub, <code>asyncio.Queue</code> can also be used per channel, but the callback-based approach shown is more flexible.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong>\nTo verify your cache invalidation implementation:</p>\n<ol>\n<li><strong>Start the edge server</strong> with an upstream origin (e.g., a simple static file server).</li>\n<li><strong>Prime the cache:</strong> Use <code>curl http://edge:8080/image.jpg</code> to fetch and cache an image.</li>\n<li><strong>Test Hard Purge:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    curl -X PURGE -H &quot;Authorization: Bearer admin-token&quot; http://edge:8080/image.jpg</code></pre></div>\n<pre><code>Expected: `200 OK` response. Immediately request the image again. You should see a cache miss (check server logs) and the origin should receive a request.\n</code></pre>\n<ol start=\"4\">\n<li><strong>Test Soft Purge:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    curl -X PURGE -H &quot;Authorization: Bearer admin-token&quot; -H &quot;Soft-Purge: 1&quot; http://edge:8080/image.jpg</code></pre></div>\n<pre><code>Expected: `200 OK`. Immediately request the image. You should be served the *stale* (cached) version, but a background revalidation request should be logged. After a short delay, the cache should be updated.\n</code></pre>\n<ol start=\"5\">\n<li><strong>Test Tag-Based Purge:</strong> First, ensure your origin returns a <code>Surrogate-Key: test</code> header. Fetch a few URLs with that tag. Then:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    curl -X PURGE -H &quot;Authorization: Bearer admin-token&quot; http://edge:8080/purge/tag/test</code></pre></div>\n<pre><code>Expected: `200 OK` with a JSON body like `{&quot;purged_keys_count&quot;: 3}`. All tagged entries should be purged.\n</code></pre>\n<ol start=\"6\">\n<li><strong>Test Ban Rule:</strong> Add a ban rule via API, then request a matching URL. The entry should be invalidated (either hard or soft). Check that expired ban rules are removed by the GC task after their TTL.</li>\n</ol>\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong>Purge does nothing:</strong> Check cache key generation. Ensure the purge handler is using the same key logic as the cache store. Verify authentication.</li>\n<li><strong>Background revalidation causes duplicate origin requests:</strong> Implement the revalidation lock per key as described in the pitfalls.</li>\n<li><strong>Ban rules slow down requests:</strong> You are likely checking all rules linearly. Ensure you are using efficient matching (pre-compiled regex) and implement TTL-based garbage collection.</li>\n</ul>\n<h2 id=\"component-origin-shield-amp-request-collapsing-milestone-3\">Component: Origin Shield &amp; Request Collapsing (Milestone 3)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Origin Shield &amp; Request Collapsing)</p>\n</blockquote>\n<h3 id=\"mental-model-the-concert-vestibule\">Mental Model: The Concert Vestibule</h3>\n<p>Picture a massive concert hall where the main auditorium (the <strong>Origin Server</strong>) can only accommodate a limited number of people at once. Thousands of fans (client requests) arrive at the venue at the same time, all heading to the same section of seats (requesting the same resource). If everyone rushed the main doors simultaneously, they would create a dangerous stampede, overwhelming the entrance and causing a collapse (the <strong>thundering herd problem</strong>).</p>\n<p>Now, imagine a well-designed <strong>vestibule</strong> or lobby area just before the main hall doors. This is the <strong>Origin Shield</strong>. As fans arrive, the vestibule staff (the shield logic) quickly groups together everyone who has a ticket for the same seat (identical requests). Instead of letting 100 individuals each try to enter the main hall independently for the same seat, the staff selects one representative from the group (the <strong>collapsed request</strong>) to go and claim the seat. The other 99 wait patiently in the vestibule (their requests are <strong>queued</strong>). When the representative returns with confirmation and details about the seat (the HTTP response), the staff efficiently relays that information to the entire waiting group. This prevents a stampede, protects the main hall&#39;s capacity, and serves all fans efficiently.</p>\n<p>This mental model captures the core purpose of the shield: it&#39;s a <strong>deduplication and queueing layer</strong> that sits between the noisy, high-volume edge nodes and the precious, capacity-constrained origin. It transforms a potential storm of concurrent, identical <code>GET</code> requests into a single, orderly fetch, dramatically reducing load on the origin.</p>\n<h3 id=\"shield-logic-amp-request-collapsing\">Shield Logic &amp; Request Collapsing</h3>\n<p>The Origin Shield is an HTTP proxy with its own cache (often called a <strong>mid-tier</strong> or <strong>shield</strong> cache). Its primary intelligence lies in handling cache misses. The following algorithm describes its behavior when an edge node forwards a request (a cache miss) to the shield.</p>\n<ol>\n<li><strong>Request Arrival &amp; Cache Check:</strong> The shield receives an HTTP request from an edge node. It first checks its own local cache using the same <code>CacheEntry</code> data model and <code>CacheKey</code> generation logic as the edge (including <code>Vary</code> header dimensions). If a <strong>fresh</strong> entry exists, it is returned immediately—this is a <strong>shield hit</strong>.</li>\n<li><strong>Cache Miss &amp; Coalescing Map Lookup:</strong> On a cache miss, the shield checks an internal, in-memory data structure we&#39;ll call the <strong>Request Coalescing Map</strong>. This map tracks which requests are currently &quot;in flight&quot; to the origin. The key is the normalized cache key for the request (URL + <code>Vary</code> header values). The value is a list of callback functions or futures representing all the client connections (edge nodes) waiting for the result of that specific request.</li>\n<li><strong>Decision: New Origin Fetch or Join Existing Queue:</strong><ul>\n<li>If the cache key is <strong>not</strong> in the coalescing map, this is the first request for this resource since the last cached version expired. The shield creates a new entry in the map, initiates a single HTTP request to the origin server, and records the pending client connection. The request proceeds to step 4.</li>\n<li>If the cache key <strong>is</strong> already in the coalescing map, it means an identical request is already being fetched from the origin. The shield simply adds the new client&#39;s callback to the list associated with that key. This request is now <strong>collapsed</strong>—it will wait for the shared result. The algorithm jumps to step 6.</li>\n</ul>\n</li>\n<li><strong>Origin Fetch with Protection:</strong> The shield sends the request to the origin. Crucially, it implements protective measures:<ul>\n<li><strong>Connection Limits:</strong> A semaphore or rate limiter ensures the total number of concurrent connections to the origin stays below a safe threshold.</li>\n<li><strong>Timeouts &amp; Circuit Breakers:</strong> Individual requests have strict timeouts. If the origin becomes slow or fails, circuit breakers can trip to fail fast and prevent cascading failure.</li>\n</ul>\n</li>\n<li><strong>Response Processing &amp; Cache Population:</strong> Upon receiving the origin&#39;s response, the shield:<ul>\n<li>Determines if the response is cacheable using <code>is_response_cacheable</code>.</li>\n<li>If cacheable, it creates a new <code>CacheEntry</code> (using <code>CacheEntry.from_upstream_response</code>), stores it in its cache, and records its TTL.</li>\n<li><strong>Negative Caching:</strong> If the response is an error (e.g., <code>404 Not Found</code> or <code>503 Service Unavailable</code>), the shield may still create a cache entry with a very short TTL (e.g., 5-10 seconds). This prevents a storm of requests for a non-existent or temporarily failing resource from hammering the origin.</li>\n</ul>\n</li>\n<li><strong>Fan-Out to Waiting Requests:</strong> The shield retrieves the list of all waiting callbacks from the coalescing map for the given cache key. It then sends the HTTP response (either the freshly fetched one, a cached one, or a negatively cached error) to <strong>every</strong> waiting client connection.</li>\n<li><strong>Cleanup:</strong> Finally, the shield removes the entry for this cache key from the Request Coalescing Map. Any new requests for the same resource will now either be served from the shield&#39;s cache (if fresh) or trigger a new origin fetch cycle.</li>\n</ol>\n<p>The state of a request at the shield can be summarized in the following table:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">State</th>\n<th align=\"left\">Description</th>\n<th align=\"left\">Trigger for Transition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>MISS (No Coalescing)</strong></td>\n<td align=\"left\">First request for an uncached resource.</td>\n<td align=\"left\">Request arrives, cache key not in coalescing map.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>IN_FLIGHT (Coalescing Active)</strong></td>\n<td align=\"left\">An origin fetch for this key is ongoing. Other identical requests are queued.</td>\n<td align=\"left\">Subsequent identical requests arrive before the origin fetch completes.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>CACHED (FRESH/STALE)</strong></td>\n<td align=\"left\">Response is stored in the shield&#39;s local cache.</td>\n<td align=\"left\">Origin fetch completes and response is stored.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>NEGATIVE_CACHED</strong></td>\n<td align=\"left\">An error response is stored with a short TTL.</td>\n<td align=\"left\">Origin returns an error code deemed safe for negative caching.</td>\n</tr>\n</tbody></table>\n<p>The core data structure enabling this, the <code>RequestCoalescingMap</code>, has the following interface:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Method Name</th>\n<th align=\"left\">Parameters</th>\n<th align=\"left\">Returns</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>get_or_create_future</code></td>\n<td align=\"left\"><code>cache_key: str</code></td>\n<td align=\"left\"><code>Future</code></td>\n<td align=\"left\">If <code>cache_key</code> exists, returns its associated Future. If not, creates a new Future, stores it with the key, and returns it. The caller who creates the Future is responsible for fulfilling it.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>fulfill_future</code></td>\n<td align=\"left\"><code>cache_key: str</code>, <code>result: Tuple[int, Dict, bytes]</code></td>\n<td align=\"left\"><code>None</code></td>\n<td align=\"left\">Sets the result for the Future associated with <code>cache_key</code> and notifies all waiters. Removes the key from the map.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>fail_future</code></td>\n<td align=\"left\"><code>cache_key: str</code>, <code>exception: Exception</code></td>\n<td align=\"left\"><code>None</code></td>\n<td align=\"left\">Sets an exception for the Future, notifies waiters, and removes the key.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The shield&#39;s value isn&#39;t just in its cache hit ratio—it&#39;s in its <strong>miss efficiency</strong>. A single origin request satisfying hundreds of simultaneous edge requests is a massive win for origin load and stability.</p>\n</blockquote>\n<h3 id=\"adr-to-shield-or-not-to-shield\">ADR: To Shield or Not To Shield</h3>\n<blockquote>\n<p><strong>Decision: Deploy an Origin Shield as a Standard Tier for Multi-Edge CDNs</strong></p>\n</blockquote>\n<ul>\n<li><strong>Context:</strong> Our CDN architecture involves multiple geographically distributed edge nodes. Without a shield, a sudden surge in traffic for an uncached resource (a &quot;hot&quot; article, a product launch) would cause all edge nodes to independently fetch the same content from the origin simultaneously. This &quot;cache miss storm&quot; can overload the origin, increase its latency, and risk its availability. We must decide whether to introduce an intermediate caching layer (the shield) to absorb and deduplicate these requests.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>No Shield (Edge-to-Origin Direct):</strong> All edge nodes connect directly to the origin.</li>\n<li><strong>Single Global Origin Shield:</strong> Deploy one shield instance (or a cluster behind a load balancer) that all edge nodes use as their upstream.</li>\n<li><strong>Regional Shields:</strong> Deploy multiple shield instances, each serving edge nodes in a specific geographic region (e.g., North America Shield, EU Shield).</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> We will implement a <strong>Single Global Origin Shield</strong> as the primary architecture for this educational project. It provides the core learning benefits of request collapsing and origin protection with manageable complexity.</li>\n<li><strong>Rationale:</strong><ul>\n<li><strong>Simplicity vs. Benefit:</strong> A single shield provides the vast majority of the origin protection benefit (request collapsing) with a much simpler operational and implementation model compared to a regionalized shield tier. It&#39;s the most effective &quot;next step&quot; after basic edge caching.</li>\n<li><strong>Clear Learning Path:</strong> Implementing request coalescing, negative caching, and connection queuing against a single upstream is a coherent, challenging milestone. Adding regionalization introduces networking and cache consistency complexities that are better suited for a later extension.</li>\n<li><strong>Effective for Many Scenarios:</strong> For origins that are not themselves globally distributed, a single, well-provisioned shield located in the same data center or region as the origin can eliminate nearly all duplicate traffic, as network latency from the shield to the origin is minimal.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Added Latency:</strong> Edge nodes far from the shield&#39;s location will experience higher latency on cache misses compared to connecting directly to a nearby origin. This is the primary trade-off.</li>\n<li><strong>Single Point of Failure:</strong> The shield becomes a critical component. Its failure would cause all cache misses to fail. This necessitates making the shield itself highly available (e.g., via a cluster with a load balancer) and implementing robust health checks and failover logic at the edge (e.g., failover to origin if the shield is unhealthy).</li>\n<li><strong>Cache Warming:</strong> The shield&#39;s cache acts as a global warming layer. Once one edge node populates the shield cache, all other edges benefit, reducing overall origin load more effectively than isolated edge caches.</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>No Shield</strong></td>\n<td align=\"left\">Lowest latency for cache misses (direct path). Simplest architecture.</td>\n<td align=\"left\">Extremely vulnerable to thundering herd problem. High, unbounded load on origin.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Single Global Shield</strong></td>\n<td align=\"left\">Excellent request collapsing. Dramatically reduces origin load. Clear, focused implementation milestone.</td>\n<td align=\"left\">Introduces a hop of latency for distant edges. Creates a new critical component to manage.</td>\n<td align=\"left\"><strong>Yes</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Regional Shields</strong></td>\n<td align=\"left\">Good request collapsing within regions. Lower latency for cache misses than a single global shield.</td>\n<td align=\"left\">Significantly higher complexity (multiple shield caches, potential for inconsistency). Higher operational cost.</td>\n<td align=\"left\">No (Consider as a Future Extension)</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-shielding\">Common Pitfalls in Shielding</h3>\n<p>⚠️ <strong>Pitfall 1: Cache Poisoning Between Edge Variants</strong></p>\n<ul>\n<li><strong>Description:</strong> Edge nodes in different regions might request the same URL but with different <code>Accept-Encoding</code> headers (e.g., <code>gzip</code> vs. <code>br</code>). If the shield&#39;s cache key doesn&#39;t include all <code>Vary</code> header dimensions (just like the edge), it might store and serve a <code>gzip</code> response to an edge that requested <code>brotli</code>, causing corruption.</li>\n<li><strong>Why it&#39;s Wrong:</strong> The HTTP response body is incompatible with the client&#39;s expectation. The edge node might serve incorrect, unreadable content to the user.</li>\n<li><strong>Fix:</strong> The shield <strong>must</strong> use the exact same cache key generation logic as the edge, meticulously incorporating all headers listed in the origin&#39;s <code>Vary</code> response header. Reuse the <code>CacheKey</code> generation module from Milestone 1.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: Timeout Mismatch Chain Reaction</strong></p>\n<ul>\n<li><strong>Description:</strong> The edge node has a 30-second client timeout. The shield sets a 10-second timeout to the origin. If the origin is slow and takes 15 seconds to respond, the shield&#39;s request fails (timeout). However, 100 edge requests were collapsed behind that single shield request. The shield fails all 100 waiting connections simultaneously. All 100 edge nodes, now seeing a failed upstream (shield), may simultaneously decide to retry directly to the origin or to another shield, creating a new, smaller herd problem.</li>\n<li><strong>Why it&#39;s Wrong:</strong> It negates the benefit of request collapsing and can amplify failures.</li>\n<li><strong>Fix:</strong> Implement a <strong>graceful degradation</strong> strategy. Use <code>stale-if-error</code> directives. If the shield&#39;s fetch times out or fails, it should check if it has a <strong>stale</strong> cached version of the resource. If so, it can serve that stale content immediately while logging the error, rather than failing all clients. Additionally, ensure shield-to-origin timeouts are configured to be meaningfully shorter than edge-to-client timeouts.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Ignoring Shield Health in Edge Routing</strong></p>\n<ul>\n<li><strong>Description:</strong> The edge node is configured to always forward misses to the shield&#39;s hostname. If the shield instance crashes or becomes partitioned, the edge will still send it requests, which will fail or timeout, degrading performance for all users.</li>\n<li><strong>Why it&#39;s Wrong:</strong> It eliminates the fault-tolerance benefits of a multi-tier architecture. A failure in the shield tier should not cause a full outage.</li>\n<li><strong>Fix:</strong> Implement active <strong>health checking</strong> at the edge. Periodically (e.g., every 5 seconds) make a lightweight request (e.g., <code>GET /health</code>) to the shield. If consecutive health checks fail, mark the shield as unhealthy and temporarily <strong>bypass</strong> it, sending cache misses directly to the origin for a defined period. Re-introduce the shield after it passes health checks again.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Unbounded Growth of the Coalescing Map</strong></p>\n<ul>\n<li><strong>Description:</strong> The in-memory map that tracks in-flight requests (<code>RequestCoalescingMap</code>) is never cleaned up. If an origin fetch hangs forever (due to an origin bug or network issue), the entry remains, and all subsequent requests for that resource pile up in memory indefinitely, causing a memory leak.</li>\n<li><strong>Why it&#39;s Wrong:</strong> Leads to eventual out-of-memory crashes of the shield process.</li>\n<li><strong>Fix:</strong> Associate every entry in the coalescing map with a <strong>timeout</strong>. If the origin fetch does not complete within this timeout, the future is failed (e.g., with a <code>TimeoutError</code>), and the entry is removed from the map. Also, implement a periodic garbage collection task that scans for and removes stale entries.</li>\n</ul>\n<h3 id=\"implementation-guidance-for-origin-shield\">Implementation Guidance for Origin Shield</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (for Learning)</th>\n<th align=\"left\">Advanced Option (for Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">HTTP Server/Proxy</td>\n<td align=\"left\">Python&#39;s <code>asyncio</code> with <code>aiohttp</code> (easy concurrency for request collapsing)</td>\n<td align=\"left\">Go&#39;s <code>net/http</code> or Rust&#39;s <code>hyper</code> (performance, robustness)</td>\n</tr>\n<tr>\n<td align=\"left\">Request Coalescing</td>\n<td align=\"left\">In-memory <code>dict</code> with <code>asyncio.Future</code>/<code>asyncio.Event</code></td>\n<td align=\"left\">Distributed coordination (Redis, memcached) for multi-process shields</td>\n</tr>\n<tr>\n<td align=\"left\">Connection Pool/Limiting</td>\n<td align=\"left\"><code>aiohttp.TCPConnector</code> with limit</td>\n<td align=\"left\">Adaptive concurrency limiting (AIMD, gradient)</td>\n</tr>\n<tr>\n<td align=\"left\">Health Checking</td>\n<td align=\"left\">Simple periodic HTTP <code>GET</code></td>\n<td align=\"left\">Rich health checks with metrics integration (Prometheus)</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin_cdn/\n├── pyproject.toml\n├── src/\n│   └── blue_origin/\n│       ├── __init__.py\n│       ├── edge/                    # Milestone 1 &amp; 5\n│       │   ├── __init__.py\n│       │   ├── handler.py           # EdgeRequestHandler\n│       │   ├── cache.py             # CacheStorage, CacheEntry\n│       │   └── compression.py       # gzip/brotli middleware\n│       ├── shield/                  # Milestone 3\n│       │   ├── __init__.py\n│       │   ├── handler.py           # ShieldRequestHandler\n│       │   ├── coalescing.py        # RequestCoalescingMap\n│       │   ├── client.py            # ShieldHTTPClient (with queue/limit)\n│       │   └── health.py            # Health check endpoint &amp; logic\n│       ├── invalidation/            # Milestone 2\n│       │   └── ...\n│       ├── routing/                 # Milestone 4\n│       │   └── ...\n│       ├── analytics/               # Milestone 5\n│       │   └── ...\n│       └── utils/\n│           └── http.py              # parse_http_date, is_response_cacheable, etc.\n├── configs/\n│   └── shield_config.yaml\n└── scripts/\n    └── run_shield.py</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>The following is a complete, working implementation of the core <code>RequestCoalescingMap</code> using <code>asyncio</code>. This is a prerequisite component that learners can use directly.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/shield/coalescing.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple, Optional, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RequestCoalescingMap</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    A map that collapses concurrent requests for the same cache key.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Each key maps to a Future that will hold the result (status, headers, body).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._futures: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, asyncio.Future] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._timeouts: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># key -> expiration time</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._default_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> default_timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._gc_task: Optional[asyncio.Task] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> get_or_create_future</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> asyncio.Future:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get the existing Future for `cache_key`, or create a new one.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        The caller that creates the Future MUST fulfill or fail it.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cache_key </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures[cache_key]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Create a new future</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fut </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Future()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._futures[cache_key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fut</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._timeouts[cache_key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._default_timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Start GC task if not running</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._gc_task </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> or</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._gc_task.done():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._gc_task </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.create_task(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._gc_loop())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fut</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fulfill_future</span><span style=\"color:#E1E4E8\">(self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            result: Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set the result for the Future associated with `cache_key`.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fut </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._timeouts.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> fut </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> fut.done():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fut.set_result(result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fail_future</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, exception: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set an exception for the Future associated with `cache_key`.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fut </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._timeouts.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> fut </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> fut.done():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fut.set_exception(exception)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _gc_loop</span><span style=\"color:#E1E4E8\">(self, interval: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background task to clean up timed-out futures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            to_remove </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> key, exp_time </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._timeouts.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> exp_time:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        to_remove.append(key)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> to_remove:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    fut </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures.pop(key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">._timeouts.pop(key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> fut </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> fut.done():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        fut.set_exception(asyncio.TimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Request for </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">key</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> timed out\"</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Here is the skeleton for the main shield request handler. Learners must fill in the detailed logic.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/blue_origin/shield/handler.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .coalescing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RequestCoalescingMap</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..edge.cache </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheStorage, CacheEntry, generate_cache_key</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.http </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_response_cacheable,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parse_cache_control_header,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheDirectives,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    get_header_values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ShieldRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    HTTP request handler for the Origin Shield.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 cache: CacheStorage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 origin_upstream: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 coalescing_map: RequestCoalescingMap,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 max_concurrent_origin_requests: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.origin_upstream </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> origin_upstream.rstrip(</span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.coalescing_map </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> coalescing_map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Semaphore to limit concurrent origin requests</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._origin_semaphore </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Semaphore(max_concurrent_origin_requests)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main request handling algorithm for the shield.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Called by the shield's HTTP server for each incoming request (from an edge node).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract the request method, URL, and headers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - The URL is in request_headers[':path'] (or similar, depending on your HTTP lib).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - The method is in request_headers[':method'].</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate the cache key for this request.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Use the same `generate_cache_key` function as the edge node.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - It must consider the `Vary` header from the *original client request*</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     which should be forwarded by the edge. Assume it's in a header like `X-Forwarded-Vary`.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check the shield's local cache for a fresh entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Use `self.cache.get(cache_key)`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If found and `entry.is_fresh(current_time)` is True, return the cached response.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If found but stale, check `stale-while-revalidate` directive.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     If allowed, serve stale and trigger background revalidation (</span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check the Request Coalescing Map.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call `self.coalescing_map.get_or_create_future(cache_key)`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If this returns an *existing* Future, it means a request is already in flight.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Wait on that Future (`await future`).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     - Return the result it provides. This is the collapsed request path.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If we are here, we are the first/only request (we created the Future).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   Now we must fetch from the origin.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Acquire the origin semaphore: `async with self._origin_semaphore:`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Make an HTTP request to `self.origin_upstream + url` with the appropriate headers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Enforce a timeout (e.g., 10 seconds).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Process the origin's response.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If the request succeeded (status code 2xx, 3xx, 404, etc.):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     a. Determine if response is cacheable via `is_response_cacheable`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     b. If cacheable, create a `CacheEntry` and store it in `self.cache`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     c. If it's an error (4xx, 5xx), consider negative caching with a short TTL.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If the request failed (network error, timeout):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     Consider serving stale content from cache if available (graceful degradation).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Fulfill the Future in the coalescing map.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Call `self.coalescing_map.fulfill_future(cache_key, result)` where result is</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #     (status_code, headers, body).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - This will wake up all other requests waiting on this same cache key.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: (Background) If serving stale content under `stale-while-revalidate`,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   spawn a background task to revalidate the cache entry with the origin.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Use `asyncio.create_task(self._revalidate_in_background(cache_key, stale_entry, request_headers))`.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return the HTTP response (status, headers, body) to the caller.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span><span style=\"color:#6A737D\">  # Placeholder return (will be filled by learner)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 500</span><span style=\"color:#E1E4E8\">, {</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"text/plain\"</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">\"Not implemented\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _revalidate_in_background</span><span style=\"color:#E1E4E8\">(self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                       cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                       stale_entry: CacheEntry,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                       request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Asynchronously revalidate a stale cache entry with the origin.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        If successful, update the cache with the new entry.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Make a conditional request to the origin.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Include `If-None-Match: stale_entry.etag` and/or `If-Modified-Since: stale_entry.last_modified`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Use the same request headers as the original (but potentially with conditional headers).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If origin returns 304 Not Modified, update the `fetched_at` and `expires_at`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   of the stale_entry to mark it fresh again, and store it back in the cache.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If origin returns a new response (200 OK), store it as a new CacheEntry,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   replacing the old one.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If the origin request fails, log the error. The stale entry remains stale.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python)</strong></p>\n<ul>\n<li><strong>Concurrency:</strong> Use <code>asyncio</code> throughout the shield. The <code>aiohttp</code> library provides excellent asynchronous HTTP client and server capabilities. The <code>RequestCoalescingMap</code> heavily relies on <code>asyncio.Future</code> for synchronization.</li>\n<li><strong>Timeouts:</strong> Always use <code>asyncio.wait_for</code> or the <code>timeout</code> parameter in <code>aiohttp</code> client calls to prevent hung requests from consuming resources indefinitely.</li>\n<li><strong>Graceful Shutdown:</strong> Ensure your shield server has a shutdown handler that waits for in-flight origin requests to complete (or times them out) before exiting.</li>\n<li><strong>Metrics Integration:</strong> Use the <code>ShieldMetrics</code> data structure to track counts of collapsed requests, origin errors, and queue sizes. Export these via a <code>/metrics</code> endpoint for monitoring.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the <code>ShieldRequestHandler</code> and the <code>RequestCoalescingMap</code>, you can verify basic functionality with the following steps:</p>\n<ol>\n<li><strong>Start the Origin:</strong> Run a simple static file server (e.g., <code>python -m http.server 8000</code>).</li>\n<li><strong>Start the Shield:</strong> Run your shield server, configured to upstream to <code>http://localhost:8000</code>.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">    python</span><span style=\"color:#9ECBFF\"> scripts/run_shield.py</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> configs/shield_config.yaml</span></span></code></pre></div>\n<ol start=\"3\">\n<li><strong>Simulate Concurrent Edge Requests:</strong> Write a small test script that uses <code>asyncio</code> to send 10 identical <code>GET</code> requests to the shield at the same time.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> aiohttp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fetch</span><span style=\"color:#E1E4E8\">(session, url):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#E1E4E8\"> session.get(url) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> resp:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> resp.text()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        url </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"http://localhost:8080/shield/path/to/image.jpg\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#E1E4E8\"> aiohttp.ClientSession() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [fetch(session, url) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            responses </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> asyncio.gather(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">tasks)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Sent 10 concurrent requests. All received responses.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Verify all responses are identical</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            assert</span><span style=\"color:#79B8FF\"> all</span><span style=\"color:#E1E4E8\">(r </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> responses[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> responses)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    asyncio.run(main())</span></span></code></pre></div>\n<ol start=\"4\">\n<li><strong>Expected Behavior:</strong><ul>\n<li>The shield&#39;s access log should show only <strong>one</strong> request to the origin (<code>localhost:8000</code>) for <code>/path/to/image.jpg</code>.</li>\n<li>The origin server&#39;s log should also show only <strong>one</strong> request.</li>\n<li>All 10 client requests should receive the same, correct response.</li>\n<li>The shield&#39;s metrics (if exposed) should show <code>collapsed_requests: 9</code>.</li>\n</ul>\n</li>\n<li><strong>Signs of Trouble:</strong><ul>\n<li><strong>Origin sees 10 requests:</strong> The request collapsing logic is not working. Check the <code>RequestCoalescingMap</code> implementation and the logic in <code>handle_request</code> steps 4 and 5.</li>\n<li><strong>Clients receive errors or hang:</strong> The Future fulfillment logic (<code>fulfill_future</code>/<code>fail_future</code>) may be broken, or the shield&#39;s HTTP client might be failing. Check error handling and timeouts.</li>\n<li><strong>Responses differ:</strong> Cache key generation is inconsistent, possibly not handling <code>Vary</code> headers correctly. Ensure the edge node forwards the necessary headers (like <code>Accept-Encoding</code>) to the shield.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"component-edge-node-distribution-amp-routing-milestone-4\">Component: Edge Node Distribution &amp; Routing (Milestone 4)</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Edge Node Distribution &amp; Routing)</p>\n</blockquote>\n<h3 id=\"mental-model-the-air-traffic-control-map\">Mental Model: The Air Traffic Control Map</h3>\n<p>Imagine a global air traffic control system for web requests. Planes (user requests) depart from airports worldwide (user locations) and need to land at the nearest available, operational airport (edge node) for their destination. The air traffic controller (routing system) must:</p>\n<ol>\n<li><strong>Know all airports</strong>: Maintain a real-time map of all edge nodes, their geographic locations, and operational status</li>\n<li><strong>Direct to nearest</strong>: Calculate the geographically closest operational airport for each incoming flight based on its departure point (user IP)</li>\n<li><strong>Handle emergencies</strong>: When an airport closes (node fails), redirect incoming flights to the next-nearest airport within seconds</li>\n<li><strong>Balance traffic</strong>: Evenly distribute flights across airports with similar proximity to prevent congestion</li>\n</ol>\n<p>This mental model captures the essence of a multi-node CDN: we have multiple geographically distributed edge servers (airports), clients make requests from various locations (flights departing), and our routing system (air traffic control) must intelligently direct each request to the optimal edge node based on proximity and health. Just as a flight from Tokyo shouldn&#39;t be directed to an airport in London when there&#39;s one in Osaka, a user in Japan shouldn&#39;t be served from a European edge node when there&#39;s a Tokyo PoP available.</p>\n<h3 id=\"geo-routing-amp-health-checking\">Geo-Routing &amp; Health Checking</h3>\n<p>Geo-routing ensures users connect to the geographically closest edge node, minimizing network latency. Health checking ensures we don&#39;t route traffic to nodes that are malfunctioning or offline.</p>\n<h4 id=\"how-client-ips-map-to-edge-nodes\">How Client IPs Map to Edge Nodes</h4>\n<p>The mapping process follows this algorithm:</p>\n<ol>\n<li><strong>IP Geolocation</strong>: When a request arrives (or during DNS resolution), we determine the client&#39;s approximate geographic location from their IP address using a GeoIP database</li>\n<li><strong>Node Location Database</strong>: Each edge node registers its physical location (latitude/longitude or region code) with the control plane during startup</li>\n<li><strong>Distance Calculation</strong>: For each healthy edge node, calculate the geographic distance to the client using the Haversine formula (great-circle distance)</li>\n<li><strong>Selection</strong>: Select the edge node with the smallest distance that also meets capacity and health constraints</li>\n<li><strong>Fallback</strong>: If the nearest node is unhealthy, select the next nearest healthy node</li>\n</ol>\n<p>The geographic mapping can be implemented at different layers:</p>\n<table>\n<thead>\n<tr>\n<th>Mapping Layer</th>\n<th>How It Works</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DNS-Based</strong></td>\n<td>DNS server returns different A/AAAA records based on the resolver&#39;s IP location</td>\n<td>Simple, works with any client</td>\n<td>Depends on client&#39;s DNS resolver location, not end-user location</td>\n</tr>\n<tr>\n<td><strong>Anycast</strong></td>\n<td>Same IP address announced from multiple locations; BGP routes to nearest</td>\n<td>Transparent to client, fastest failover</td>\n<td>Complex BGP configuration, all nodes share same IP</td>\n</tr>\n<tr>\n<td><strong>HTTP Redirect</strong></td>\n<td>Central gateway receives all requests, responds with 302 to nearest edge</td>\n<td>Most accurate (sees real client IP), flexible</td>\n<td>Adds extra round-trip for first request</td>\n</tr>\n</tbody></table>\n<h4 id=\"health-checking-implementation\">Health Checking Implementation</h4>\n<p>Health checking is a continuous process that monitors each edge node&#39;s operational status:</p>\n<p><strong>Passive Health Checking</strong>: Monitor actual traffic patterns</p>\n<ul>\n<li>Track error rates (5xx responses) from the node</li>\n<li>Monitor request latency percentiles</li>\n<li>Observe TCP connection failures</li>\n</ul>\n<p><strong>Active Health Checking</strong>: Periodic synthetic requests</p>\n<ul>\n<li>HTTP GET to <code>/health</code> endpoint on each edge node</li>\n<li>Validate response status code (200 OK) and optionally content</li>\n<li>Check within configurable intervals (e.g., every 10 seconds)</li>\n<li>Consider network path health (latency, packet loss)</li>\n</ul>\n<p>The health state machine for an edge node follows these transitions:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HEALTHY</strong></td>\n<td>3 consecutive health checks fail</td>\n<td><strong>UNHEALTHY</strong></td>\n<td>Remove from DNS rotation, stop routing new traffic</td>\n</tr>\n<tr>\n<td><strong>UNHEALTHY</strong></td>\n<td>2 consecutive health checks succeed</td>\n<td><strong>DEGRADED</strong></td>\n<td>Add back to rotation with reduced traffic weight</td>\n</tr>\n<tr>\n<td><strong>DEGRADED</strong></td>\n<td>5 consecutive health checks succeed</td>\n<td><strong>HEALTHY</strong></td>\n<td>Restore full traffic weight</td>\n</tr>\n<tr>\n<td><strong>DEGRADED</strong></td>\n<td>1 health check fails</td>\n<td><strong>UNHEALTHY</strong></td>\n<td>Remove from rotation again</td>\n</tr>\n<tr>\n<td>Any state</td>\n<td>Manual admin command (disable)</td>\n<td><strong>MAINTENANCE</strong></td>\n<td>Gracefully drain connections, no new traffic</td>\n</tr>\n<tr>\n<td><strong>MAINTENANCE</strong></td>\n<td>Manual admin command (enable)</td>\n<td><strong>HEALTHY</strong></td>\n<td>Add to rotation, full weight</td>\n</tr>\n</tbody></table>\n<p>Health check responses include detailed metrics:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example health check response structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"status\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"healthy\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"timestamp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1678901234.567</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"metrics\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"cache_hit_ratio\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.89</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"request_rate\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1250.5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"error_rate\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.001</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"cpu_utilization\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.45</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"memory_used_mb\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2048</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"active_connections\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">347</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"version\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"1.2.3\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  \"region\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"us-west-2\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"consistent-hashing-for-cache-distribution\">Consistent Hashing for Cache Distribution</h3>\n<p>When we have multiple edge nodes, we face a critical decision: should each node cache independently (edge-local caching) or should we distribute cache entries across nodes (shared caching)? For our educational CDN, we implement <strong>consistent hashing</strong> to distribute cache load while minimizing reshuffling when nodes join or leave.</p>\n<h4 id=\"the-problem-cache-distribution-amp-reshuffling\">The Problem: Cache Distribution &amp; Reshuffling</h4>\n<p>Consider three approaches:</p>\n<ol>\n<li><strong>Independent Caches</strong>: Each edge node caches what it serves. Simple but inefficient - popular content gets cached redundantly on every node that serves it, wasting memory. Cache hit ratio lower due to divided cache space.</li>\n<li><strong>Centralized Cache</strong>: All edge nodes query a shared cache cluster. Efficient memory use but single point of failure, adds latency.</li>\n<li><strong>Distributed with Hashing</strong>: Each URL maps to a specific edge node via hashing; that node becomes the &quot;owner&quot; of that cached content. Other nodes can fetch from the owner on cache miss.</li>\n</ol>\n<p>The naive hashing approach (<code>hash(url) % num_nodes</code>) has a major problem: when nodes are added or removed, nearly all URLs remap to different nodes, causing massive cache invalidation (the &quot;reshuffling problem&quot;).</p>\n<h4 id=\"consistent-hashing-solution\">Consistent Hashing Solution</h4>\n<p>Consistent hashing solves the reshuffling problem by hashing both nodes and keys onto a virtual ring:</p>\n<p><img src=\"/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fdiagram-consistent-hashing-ring.svg\" alt=\"Consistent Hashing Ring for Edge Distribution\"></p>\n<p><strong>Algorithm</strong>:</p>\n<ol>\n<li>Create a virtual circle representing the hash space (0 to 2^m - 1, where m is typically 160 for SHA-1)</li>\n<li>For each edge node, compute multiple hash points (virtual nodes) around the circle (e.g., 100-200 replicas per physical node)</li>\n<li>For each cache key (URL + Vary headers), compute its hash and find the next hash point clockwise around the circle</li>\n<li>The node owning that hash point is responsible for caching that content</li>\n</ol>\n<p><strong>When a node joins</strong>:</p>\n<ol>\n<li>Compute virtual node positions for the new node</li>\n<li>Only keys that hash between the new node&#39;s positions and the previous node&#39;s positions get reassigned</li>\n<li>This affects only <code>1/(n+1)</code> of keys on average, not all keys</li>\n</ol>\n<p><strong>When a node fails</strong>:</p>\n<ol>\n<li>Its virtual nodes are removed from the ring</li>\n<li>Keys that mapped to those virtual nodes now map to the next node clockwise</li>\n<li>Affected keys can be re-fetched from origin or replicated in advance</li>\n</ol>\n<p><strong>Data Structures for Consistent Hashing</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Fields</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>HashRingNode</code></td>\n<td><code>node_id: str</code>, <code>physical_node: EdgeNode</code>, <code>position: int</code></td>\n<td>A virtual node on the hash ring</td>\n</tr>\n<tr>\n<td><code>EdgeNode</code></td>\n<td><code>node_id: str</code>, <code>region: str</code>, <code>address: str</code>, <code>weight: int</code>, <code>health_status: NodeHealth</code></td>\n<td>Physical edge node information</td>\n</tr>\n<tr>\n<td><code>ConsistentHashRing</code></td>\n<td><code>nodes: SortedDict[int, HashRingNode]</code>, <code>replicas_per_node: int</code>, <code>hash_function: Callable</code></td>\n<td>Main hash ring structure</td>\n</tr>\n</tbody></table>\n<p>The <code>ConsistentHashRing</code> interface:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>add_node</code></td>\n<td><code>node: EdgeNode</code></td>\n<td><code>None</code></td>\n<td>Add a physical node with virtual replicas to the ring</td>\n</tr>\n<tr>\n<td><code>remove_node</code></td>\n<td><code>node_id: str</code></td>\n<td><code>None</code></td>\n<td>Remove a node and all its virtual replicas</td>\n</tr>\n<tr>\n<td><code>get_node</code></td>\n<td><code>key: str</code></td>\n<td><code>EdgeNode</code></td>\n<td>Find the node responsible for the given key</td>\n</tr>\n<tr>\n<td><code>get_replica_nodes</code></td>\n<td><code>key: str</code>, <code>count: int</code></td>\n<td><code>List[EdgeNode]</code></td>\n<td>Get the primary node plus N-1 successor nodes for replication</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Virtual nodes (replicas) serve two purposes: 1) They provide better load distribution by preventing clustering, and 2) They allow weighting - nodes with more capacity get more virtual nodes, receiving proportionally more keys.</p>\n</blockquote>\n<h3 id=\"adr-client-routing-mechanism\">ADR: Client Routing Mechanism</h3>\n<blockquote>\n<p><strong>Decision: Hybrid DNS-Based Routing with HTTP Fallback</strong></p>\n<p><strong>Context</strong>: We need to direct clients to the nearest healthy edge node. The routing must work with unmodified web browsers (standard HTTP/HTTPS), provide fast failover (&lt;5 seconds), and handle GeoIP inaccuracy gracefully. We&#39;re building an educational CDN, not a commercial anycast network.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>Pure DNS-based geo-routing</strong>: DNS server returns different A records based on resolver IP location</li>\n<li><strong>Anycast BGP routing</strong>: Same IP advertised from all locations, BGP routes to nearest</li>\n<li><strong>HTTP redirect-based</strong>: All clients hit central endpoint, get 302 redirected to nearest edge</li>\n<li><strong>Hybrid DNS+HTTP</strong>: DNS returns multiple edges, client tries nearest, falls back via 302</li>\n</ol>\n<p><strong>Decision</strong>: Implement hybrid DNS-based routing with HTTP fallback. DNS returns 2-3 nearest edge IPs ordered by proximity. Client tries the first; if unhealthy (connection fails or receives 503), tries the next. For cache misses that need to reach a different edge (due to consistent hashing), the serving edge issues an HTTP 302 to the correct edge.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li>DNS-based routing works with all clients without special software</li>\n<li>Multiple IPs in DNS provide client-side failover when first edge is down</li>\n<li>HTTP redirects handle cases where GeoIP is wrong or cache location differs from optimal edge</li>\n<li>Avoids BGP anycast complexity (requires ISP relationships, not feasible for educational project)</li>\n<li>Provides flexibility: we can implement smart routing logic at both DNS and HTTP layers</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li>Adds one extra HTTP redirect for cache misses that hash to different edge than client&#39;s nearest</li>\n<li>DNS TTL (Time-To-Live) must be balanced: too short causes excessive DNS queries, too long delays failover</li>\n<li>Need to maintain both DNS infrastructure and HTTP redirect logic</li>\n<li>Clients with broken DNS caching may experience suboptimal routing</li>\n</ul>\n</blockquote>\n<p><strong>Comparison of Routing Options</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DNS-Based Geo-Routing</strong></td>\n<td>Simple, works everywhere, scales well</td>\n<td>GeoIP inaccuracy, DNS caching delays failover, all-or-nothing</td>\n<td>Partially - as primary</td>\n</tr>\n<tr>\n<td><strong>Anycast BGP</strong></td>\n<td>Transparent, fastest failover, optimal routing</td>\n<td>Complex setup, requires ISP partnerships, expensive</td>\n<td>No - too complex for educational</td>\n</tr>\n<tr>\n<td><strong>HTTP Redirect</strong></td>\n<td>Most accurate (sees real client IP), flexible control</td>\n<td>Extra round-trip, breaks some client assumptions</td>\n<td>Partially - as fallback</td>\n</tr>\n<tr>\n<td><strong>Hybrid DNS+HTTP</strong></td>\n<td>Best of both: DNS for speed, HTTP for accuracy</td>\n<td>Implementation complexity, two systems to maintain</td>\n<td><strong>Yes</strong> - optimal balance</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-distribution\">Common Pitfalls in Distribution</h3>\n<p>⚠️ <strong>Pitfall: GeoIP Database Inaccuracy</strong></p>\n<ul>\n<li><strong>Description</strong>: Assuming GeoIP databases are perfectly accurate. In reality, they&#39;re often wrong by hundreds of miles, especially for mobile networks and VPNs.</li>\n<li><strong>Why It&#39;s Wrong</strong>: A user in New York might be mapped to a Los Angeles edge node due to ISP routing through California, adding 100ms+ latency.</li>\n<li><strong>How to Fix</strong>: <ol>\n<li>Use multiple GeoIP databases and cross-reference</li>\n<li>Implement latency-based verification: ping potential edges from client location</li>\n<li>Allow manual override via cookie or URL parameter for testing</li>\n<li>Use HTTP redirect as correction mechanism when wrong edge is selected</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Thundering Herd on Edge Failover</strong></p>\n<ul>\n<li><strong>Description</strong>: When an edge node fails, all its traffic immediately shifts to the next-nearest node, potentially overloading it.</li>\n<li><strong>Why It&#39;s Wrong</strong>: The backup node might have 50% spare capacity, but gets 100% more traffic instantly, causing cascading failure.</li>\n<li><strong>How to Fix</strong>:<ol>\n<li>Implement gradual traffic shift: redirect 10% of users every second, not all at once</li>\n<li>Monitor backup node load and throttle redirects if approaching capacity</li>\n<li>Use multiple backup nodes with weighted distribution</li>\n<li>Implement client-side exponential backoff when connecting to overloaded nodes</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Cache Inconsistency (&quot;Cold Starts&quot;) on New Nodes</strong></p>\n<ul>\n<li><strong>Description</strong>: When a new edge node is added to the cluster, it starts with empty cache. All requests become cache misses until it warms up.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Performance degrades just when trying to add capacity, and origin gets hammered by cache fill requests.</li>\n<li><strong>How to Fix</strong>:<ol>\n<li>Implement cache warming: pre-fetch popular content before adding to rotation</li>\n<li>Use consistent hashing with replication: new node can fetch from neighboring nodes</li>\n<li>Gradual traffic ramp-up: start with 1% of traffic, increase as cache fills</li>\n<li>Share cache data between nodes for hottest content</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: DNS TTL Misconfiguration</strong></p>\n<ul>\n<li><strong>Description</strong>: Setting DNS TTL too high (hours) delays failover; setting too low (seconds) causes excessive DNS load.</li>\n<li><strong>Why It&#39;s Wrong</strong>: With 1-hour TTL, clients continue trying dead edge for up to an hour. With 5-second TTL, DNS servers get hammered.</li>\n<li><strong>How to Fix</strong>:<ol>\n<li>Use adaptive TTL: 300 seconds normally, 30 seconds when changes are pending</li>\n<li>Implement DNS-based health checks that override TTL for unhealthy nodes</li>\n<li>Use HTTP-level failover as backup when DNS fails</li>\n<li>Consider EDNS Client Subnet for more accurate GeoIP at DNS level</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Network Topology</strong></p>\n<ul>\n<li><strong>Description</strong>: Routing based solely on geographic distance, ignoring network congestion, peering arrangements, and ISP relationships.</li>\n<li><strong>Why It&#39;s Wrong</strong>: An edge 50 miles away through a congested peer might be slower than one 200 miles away through a direct fiber link.</li>\n<li><strong>How to Fix</strong>:<ol>\n<li>Augment geographic distance with latency measurements</li>\n<li>Implement network-aware routing that considers AS (Autonomous System) paths</li>\n<li>Use real-time latency data from monitoring to adjust routing weights</li>\n<li>Consider cost: some network paths might be more expensive despite being faster</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"implementation-guidance-for-distribution\">Implementation Guidance for Distribution</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GeoIP Database</td>\n<td>MaxMind GeoLite2 (free)</td>\n<td>MaxMind GeoIP2 Enterprise or IPinfo.io API</td>\n</tr>\n<tr>\n<td>DNS Server</td>\n<td>Python <code>dnslib</code> library for custom DNS</td>\n<td>PowerDNS with GeoIP backend or AWS Route 53</td>\n</tr>\n<tr>\n<td>Health Checking</td>\n<td>HTTP endpoint with simple status</td>\n<td>Complex health checks with dependency verification</td>\n</tr>\n<tr>\n<td>Consistent Hashing</td>\n<td>In-memory hash ring with virtual nodes</td>\n<td>Ring with replication, persistence, and load balancing</td>\n</tr>\n<tr>\n<td>Node Discovery</td>\n<td>Static configuration file</td>\n<td>etcd or ZooKeeper for dynamic registration</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin/\n├── edge/\n│   ├── __init__.py\n│   ├── server.py              # Edge HTTP server (from Milestone 1)\n│   ├── cache.py              # Cache storage (from Milestone 1)\n│   └── health.py             # Health check endpoint\n├── routing/\n│   ├── __init__.py\n│   ├── geo.py                # GeoIP lookup utilities\n│   ├── hash_ring.py          # Consistent hashing implementation\n│   ├── dns_server.py         # Custom DNS server for geo-routing\n│   └── node_registry.py      # Edge node registration and discovery\n├── control/\n│   ├── __init__.py\n│   ├── plane.py              # Control plane logic\n│   └── metrics_aggregator.py # Collect metrics from edges\n└── config/\n    ├── __init__.py\n    ├── edge.yaml             # Edge node configuration\n    └── routing.yaml          # Routing configuration</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete Health Check Endpoint</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># routing/health.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, asdict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NodeHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HEALTHY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"healthy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEGRADED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"degraded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNHEALTHY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unhealthy\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAINTENANCE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"maintenance\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HealthMetrics</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Metrics reported in health check response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_hit_ratio: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    request_rate: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#6A737D\">  # requests per second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_rate: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#6A737D\">    # error rate (0.0-1.0)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cpu_utilization: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#6A737D\">  # 0.0-1.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_used_mb: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_total_mb: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    active_connections: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_size_bytes: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_capacity_bytes: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> asdict(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HealthChecker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages health state and provides health check endpoint.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, node_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, region: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, version: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node_id</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.region </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> region</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.version </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> version</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.health_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeHealth.</span><span style=\"color:#79B8FF\">HEALTHY</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HealthMetrics()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._check_interval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#6A737D\">  # seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._check_task: Optional[asyncio.Task] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> start</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start background health monitoring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._check_task </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.create_task(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._monitor_loop())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> stop</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Stop health monitoring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._check_task:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._check_task.cancel()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._check_task</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> asyncio.CancelledError:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _monitor_loop</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background task to update health metrics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._update_metrics()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._evaluate_health()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Health monitor error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._check_interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _update_metrics</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Update health metrics from system monitoring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # In a real implementation, this would collect:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Cache statistics from cache storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - System metrics (CPU, memory)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Network connection counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # For now, we'll use placeholder values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics.cache_hit_ratio </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.85</span><span style=\"color:#6A737D\">  # Example</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics.request_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1250.5</span><span style=\"color:#6A737D\">   # Example</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics.error_rate </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.001</span><span style=\"color:#6A737D\">      # Example</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics.active_connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 347</span><span style=\"color:#6A737D\"> # Example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _evaluate_health</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate overall health status based on metrics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.metrics.error_rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 10% error rate</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.health_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeHealth.</span><span style=\"color:#79B8FF\">UNHEALTHY</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.metrics.error_rate </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.05</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 5% error rate</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.health_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeHealth.</span><span style=\"color:#79B8FF\">DEGRADED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.metrics.cpu_utilization </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.9</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># 90% CPU</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.health_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeHealth.</span><span style=\"color:#79B8FF\">DEGRADED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.health_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeHealth.</span><span style=\"color:#79B8FF\">HEALTHY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_health_request</span><span style=\"color:#E1E4E8\">(self) -> tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle HTTP GET /health request.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        uptime </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"status\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.health_status.value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"node_id\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.node_id,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"region\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.region,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"version\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.version,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"timestamp\"</span><span style=\"color:#E1E4E8\">: time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"uptime_seconds\"</span><span style=\"color:#E1E4E8\">: uptime,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"metrics\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.metrics.to_dict()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Content-Type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Cache-Control\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"no-cache, no-store, must-revalidate\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">, headers, json.dumps(response_data).encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_health_status</span><span style=\"color:#E1E4E8\">(self) -> NodeHealth:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current health status.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.health_status</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Consistent Hash Ring Implementation</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># routing/hash_ring.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> bisect</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a physical edge node.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    region: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    address: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # IP:port</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    weight: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#6A737D\">  # Relative capacity (100 = normal)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    health_status: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"healthy\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HashRingNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"A virtual node on the consistent hash ring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    physical_node: EdgeNode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">  # Hash position on the ring (0 to 2^m-1)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConsistentHashRing</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Consistent hashing implementation with virtual nodes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    The ring maps cache keys to edge nodes for distributed caching.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, replicas_per_node: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">, hash_bits: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 160</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize an empty hash ring.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            replicas_per_node: Number of virtual nodes per physical node</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hash_bits: Number of bits in hash space (default 160 for SHA-1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.replicas_per_node </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> replicas_per_node</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.hash_bits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hash_bits</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.hash_space </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\"> hash_bits</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.ring: Dict[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, HashRingNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># position -> virtual node</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.sorted_positions: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []  </span><span style=\"color:#6A737D\"># Sorted list of positions</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.nodes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, EdgeNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># node_id -> physical node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _hash</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Hash a string key to a position on the ring.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            key: String to hash</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Integer position in hash space</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use SHA-1 hash function (or configurable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert hash digest to integer in range [0, hash_space-1]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return the integer position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_node</span><span style=\"color:#E1E4E8\">(self, node: EdgeNode) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Add a physical node to the hash ring.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Creates multiple virtual nodes (replicas) for better distribution.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: EdgeNode to add</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if node already exists, return if it does</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate number of replicas based on node weight</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each replica i in range(num_replicas):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Create key: f\"{node.node_id}:{i}\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Hash the key to get position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Create HashRingNode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Add to self.ring and self.sorted_positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Sort self.sorted_positions for binary search</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add physical node to self.nodes dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> remove_node</span><span style=\"color:#E1E4E8\">(self, node_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[EdgeNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Remove a node from the hash ring.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node_id: ID of node to remove</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Removed EdgeNode or None if not found</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if node exists in self.nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Remove all virtual nodes for this physical node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update self.sorted_positions list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Remove from self.nodes dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the removed node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_node</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[EdgeNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get the node responsible for a given cache key.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            key: Cache key (URL + vary headers)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            EdgeNode responsible for this key, or None if ring is empty</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If ring is empty, return None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Hash the key to get position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use bisect to find first position >= hashed position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If at end of list, wrap around to first position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Get virtual node at that position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the physical node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_replica_nodes</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) -> List[EdgeNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get the primary node plus replica nodes for a key.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Used for cache replication to handle node failures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            key: Cache key</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            count: Total number of nodes to return (including primary)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of EdgeNodes, starting with primary</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get primary node with get_node(key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If ring is empty, return empty list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Find position of primary node's virtual node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Get next N-1 distinct physical nodes clockwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return list of nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> redistribute_keys</span><span style=\"color:#E1E4E8\">(self, old_node: EdgeNode, new_node: EdgeNode) -> List[Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, EdgeNode]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate which keys need to move when replacing a node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            old_node: Node being removed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            new_node: Node being added</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of (key, new_node) pairs for keys that should move</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get all virtual node positions for old_node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each virtual node position:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Find keys that hash to positions between this node and previous</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - These keys will now map to new_node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return list of affected keys and their new node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Note: In practice, we'd need to know all existing keys to do this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Simple GeoIP Lookup Utility</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># routing/geo.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> maxminddb</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GeoLocation</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Geographic location information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    country_code: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    country_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    region_code: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    region_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    city: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    latitude: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    longitude: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metro_code: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># US metro code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timezone: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GeoIPLookup</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"GeoIP lookup using MaxMind database.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, database_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize GeoIP lookup.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            database_path: Path to MaxMind GeoLite2 database file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Open MaxMind database file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify database is readable and valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Store reader instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> lookup</span><span style=\"color:#E1E4E8\">(self, ip_address: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[GeoLocation]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Look up geographic location for an IP address.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ip_address: IP address string (IPv4 or IPv6)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            GeoLocation or None if not found</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate IP address format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Query MaxMind database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Parse response into GeoLocation dataclass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle errors (invalid IP, not in database)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> distance_between</span><span style=\"color:#E1E4E8\">(self, loc1: GeoLocation, loc2: GeoLocation) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate great-circle distance between two locations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses Haversine formula.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            loc1: First location</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            loc2: Second location</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Distance in kilometers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if both locations have latitude/longitude</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert degrees to radians</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply Haversine formula</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return distance in kilometers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_nearest_node</span><span style=\"color:#E1E4E8\">(self, client_ip: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, nodes: List[EdgeNode]) -> Optional[EdgeNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Find nearest edge node for a client IP.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            client_ip: Client IP address</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            nodes: List of available edge nodes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Nearest EdgeNode or None if can't determine</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Look up client location from IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each node with known location:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Calculate distance to client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return node with minimum distance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle edge cases (no location data, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-python-specific-hints\">E. Python-Specific Hints</h4>\n<ol>\n<li><p><strong>MaxMind Database</strong>: Use <code>maxminddb</code> library: <code>pip install maxminddb</code>. The free GeoLite2 database is available from MaxMind (requires account registration).</p>\n</li>\n<li><p><strong>DNS Server</strong>: For a simple DNS server, use the <code>dnslib</code> library: <code>pip install dnslib</code>. It provides DNS protocol handling without needing bind/named.</p>\n</li>\n<li><p><strong>Consistent Hashing Performance</strong>: Use <code>bisect</code> module for O(log n) lookups in the sorted positions list. For production, consider a balanced tree structure.</p>\n</li>\n<li><p><strong>Health Checks</strong>: Use <code>asyncio</code> for non-blocking health checks. The <code>aiohttp</code> library is good for HTTP health checks to other nodes.</p>\n</li>\n<li><p><strong>Node Discovery</strong>: For a simple implementation, use HTTP registration: nodes POST to control plane on startup. For advanced, use <code>etcd3</code> or <code>kazoo</code> (ZooKeeper) libraries.</p>\n</li>\n<li><p><strong>Monitoring Metrics</strong>: Use <code>psutil</code> library to gather system metrics (CPU, memory, disk) for health reporting.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p><strong>To verify Milestone 4 implementation</strong>:</p>\n<ol>\n<li><strong>Start multiple edge nodes</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Terminal 1 (US East)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin.edge.server</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/edge_us_east.yaml</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Terminal 2 (US West)  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin.edge.server</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/edge_us_west.yaml</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Terminal 3 (Europe)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin.edge.server</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/edge_eu.yaml</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Start control plane and DNS server</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin.routing.dns_server</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/routing.yaml</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin.control.plane</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/control.yaml</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Test DNS-based geo-routing</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Simulate queries from different locations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> mycdn.example.com</span><span style=\"color:#9ECBFF\"> A</span><span style=\"color:#9ECBFF\"> +subnet=8.8.8.0/24</span><span style=\"color:#6A737D\">  # US query</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   dig</span><span style=\"color:#9ECBFF\"> @localhost</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#79B8FF\"> 5353</span><span style=\"color:#9ECBFF\"> mycdn.example.com</span><span style=\"color:#9ECBFF\"> A</span><span style=\"color:#9ECBFF\"> +subnet=194.158.0.0/16</span><span style=\"color:#6A737D\">  # EU query</span></span></code></pre></div>\n<p>   Expected: Different IPs returned based on source subnet.</p>\n<ol start=\"4\">\n<li><strong>Test health checking</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Check health endpoint</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/health</span><span style=\"color:#6A737D\">  # Should return JSON with status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Stop one edge node, verify DNS stops returning it within 15 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # (kill US West node, then query again)</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Test consistent hashing</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Python test script</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> routing.hash_ring </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ConsistentHashRing, EdgeNode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   ring </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ConsistentHashRing()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   ring.add_node(EdgeNode(</span><span style=\"color:#9ECBFF\">\"us-east-1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"us-east\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"10.0.1.1:8080\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   ring.add_node(EdgeNode(</span><span style=\"color:#9ECBFF\">\"us-west-2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"us-west\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"10.0.2.1:8080\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Same URL should always map to same node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   node1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ring.get_node(</span><span style=\"color:#9ECBFF\">\"/images/cat.jpg\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   node2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ring.get_node(</span><span style=\"color:#9ECBFF\">\"/images/cat.jpg\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   assert</span><span style=\"color:#E1E4E8\"> node1.node_id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> node2.node_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Different URLs should distribute across nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   urls </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"/page/</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   distribution </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   for</span><span style=\"color:#E1E4E8\"> url </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> urls:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       node </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ring.get_node(url)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       distribution[node.node_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> distribution.get(node.node_id, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Distribution: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">distribution</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Should be roughly 50/50</span></span></code></pre></div>\n\n<ol start=\"6\">\n<li><strong>Test failover</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Simulate node failure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   pkill</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"edge_us_west.yaml\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Wait 15 seconds for health checks to detect</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Then query DNS - should not return west IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # HTTP requests to west should get connection refused</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Requests should redirect to east or europe</span></span></code></pre></div>\n\n<p><strong>Expected Behaviors to Verify</strong>:</p>\n<ul>\n<li>DNS returns different IPs for clients from different continents</li>\n<li>Health endpoint returns 200 OK with metrics when node is healthy</li>\n<li>When a node is stopped, DNS stops returning its IP within 30 seconds</li>\n<li>Cache keys consistently map to same node (until ring changes)</li>\n<li>Adding/removing nodes affects only ~1/N of cache mappings</li>\n<li>HTTP redirects work when cache needs to be fetched from different edge</li>\n</ul>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>DNS always returns same IP regardless of source: GeoIP database not loaded</li>\n<li>Health checks fail: firewall blocking health endpoint</li>\n<li>Inconsistent node mapping: hash function or ring implementation bug</li>\n<li>Slow failover (&gt;30 seconds): DNS TTL too high or health check interval too long</li>\n</ul>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Edge Cache Implementation), Milestone 2 (Cache Invalidation), Milestone 3 (Origin Shield &amp; Request Collapsing), Milestone 4 (Edge Node Distribution &amp; Routing)</p>\n</blockquote>\n<p>Understanding the static architecture of components is only half the picture. This section animates the system by tracing the journey of real user requests and administrative commands through the complete CDN pipeline. We examine three critical scenarios: the optimal path where content is served directly from the edge, the more complex path involving a cache miss and origin shield, and the control-plane operation of globally invalidating cached content. These traces reveal how the components defined in previous sections collaborate to deliver a seamless, high-performance caching service while maintaining consistency and resilience.</p>\n<h3 id=\"data-flow-cache-hit-at-edge\">Data Flow: Cache Hit at Edge</h3>\n<p><strong>Mental Model: The Express Checkout Lane</strong>\nImagine a supermarket with a dedicated express lane for customers purchasing common, pre-packaged items. When you approach with a loaf of bread, the cashier immediately recognizes the item (cache key), retrieves it from a nearby shelf (cache storage), scans it (applies headers), and completes the transaction in seconds. No need to visit the store&#39;s warehouse (origin). This is a <strong>cache hit</strong> – the fastest possible path through the CDN, where a valid, fresh copy of the requested resource resides at the edge node closest to the user.</p>\n<p>A cache hit represents the CDN&#39;s primary value proposition: dramatically reduced latency. The following sequence describes each step, from the user&#39;s initial request to the cached response being served. Refer to the flowchart <code>![Flowchart: Edge Node Request Handling](/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fflowchart-request-handling.svg)</code> for a visual guide to the decision logic within the <code>EdgeRequestHandler</code>.</p>\n<ol>\n<li><p><strong>Client Request Initiation:</strong> An end-user&#39;s browser or application sends an HTTP GET request for a resource (e.g., <code>https://cdn.example.com/images/photo.jpg</code>). This request may include conditional headers like <code>If-None-Match</code> (with an ETag) or <code>If-Modified-Since</code> (with a timestamp).</p>\n</li>\n<li><p><strong>Geo-Routing &amp; Edge Selection:</strong> The client&#39;s DNS resolver, or a global load balancer using Anycast, directs the request to the nearest healthy edge node based on the client&#39;s IP address and geographic proximity. The selected edge node&#39;s <code>EdgeRequestHandler</code> receives the request.</p>\n</li>\n<li><p><strong>Request Parsing &amp; Cache Key Construction:</strong> The handler parses the request URL and headers. It constructs a <strong>cache key</strong> by combining the normalized request URL (including query string) and the values of any headers listed in a potential <code>Vary</code> header from a previous cached response (e.g., <code>Accept-Encoding</code>). If the request itself contains a <code>Vary: *</code> header, the handler immediately classifies this as uncacheable and proceeds to a fetch from upstream.</p>\n</li>\n<li><p><strong>Cache Lookup:</strong> The handler queries the <code>CacheStorage</code> (e.g., an in-memory LRU store) with the generated cache key. In this scenario, the lookup succeeds, returning a <code>CacheEntry</code> object.</p>\n</li>\n<li><p><strong>Freshness Validation:</strong> The handler checks if the cached entry is fresh by calling <code>CacheEntry.is_fresh(current_time)</code>. This evaluates the cached <code>CacheDirectives</code> (primarily <code>s-maxage</code> or <code>max-age</code>) against the current time and the entry&#39;s <code>expires_at</code> timestamp. If the entry is fresh, the system proceeds to step 7.</p>\n</li>\n<li><p><strong>Conditional Revalidation (If Stale):</strong> If the entry is stale but <code>stale-while-revalidate</code> is present and its period has not expired, the handler may immediately serve the stale data (proceeding to step 7) while simultaneously spawning a background task via <code>_revalidate_in_background</code> to fetch an updated version from the origin. Alternatively, if the client provided conditional headers (<code>If-None-Match</code>, <code>If-Modified-Since</code>), the handler forwards these to the origin in a conditional request. A <code>304 Not Modified</code> response from the origin would refresh the entry&#39;s TTL without transferring the body, still resulting in a cache hit from the user&#39;s perspective.</p>\n</li>\n<li><p><strong>Ban Rule Check:</strong> Before serving the cached content, the handler calls <code>InvalidationHandler.check_bans(url)</code> to verify the request URL doesn&#39;t match any active <code>BanRule</code>. In a hit scenario with no ban, this returns <code>None</code>.</p>\n</li>\n<li><p><strong>Response Preparation:</strong> The handler prepares the HTTP response. It uses the status code, headers, and body stored in the <code>CacheEntry</code>. Critical caching headers like <code>Age</code> (calculated as <code>current_time - fetched_at</code>) and <code>Cache-Control</code> are updated to reflect the current state. If the client supports compression and the cache holds a compressed variant (per the <code>Vary: Accept-Encoding</code> dimension), the appropriate <code>Content-Encoding</code> header is set.</p>\n</li>\n<li><p><strong>Analytics Update:</strong> The <code>EdgeMetrics</code> are updated: <code>total_hits</code> is incremented, <code>total_bandwidth_served</code> is increased by the size of the response body, and counters for the specific status code and content type are updated.</p>\n</li>\n<li><p><strong>Response Delivery:</strong> The fully formed HTTP response is transmitted back to the client. The transaction is complete, with the origin server entirely uninvolved.</p>\n</li>\n</ol>\n<p><strong>Key Data Structures Involved:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Structure</th>\n<th>Role in Cache Hit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CacheEntry</code></td>\n<td>The stored response object containing body, headers, and metadata.</td>\n</tr>\n<tr>\n<td><code>CacheDirectives</code></td>\n<td>Parsed directives that determine the entry&#39;s freshness and revalidation behavior.</td>\n</tr>\n<tr>\n<td><code>EdgeMetrics</code></td>\n<td>Accumulates performance data for analytics.</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-flow-cache-miss-with-origin-shield\">Data Flow: Cache Miss with Origin Shield</h3>\n<p><strong>Mental Model: The Concert Vestibule</strong>\nReturning to the concert analogy from the Origin Shield component section, consider a group of fans arriving at the venue for a popular band. They all want entry to the same section (the resource). Instead of each fan individually bothering the busy main ticket scanner (origin), a staff member in the vestibule (shield) takes one representative&#39;s request, goes to the scanner to get the ticket validated, and returns with the approval. The other waiting fans receive copies of the same approval. The <strong>shield</strong> orchestrates this <strong>request collapsing</strong>, preventing a stampede.</p>\n<p>This data flow is the most complex, involving multiple tiers and sophisticated coordination to protect the origin. The sequence diagram <code>![Sequence: Cache Miss with Origin Shielding](/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fseq-cache-miss-shield.svg)</code> illustrates the full interaction.</p>\n<ol>\n<li><p><strong>Initial Steps (1-4):</strong> The flow begins identically to a cache hit: client request, geo-routing, and cache key generation at the edge node. However, the cache lookup (step 4) fails, resulting in a <strong>miss</strong>. The <code>EdgeMetrics.total_misses</code> is incremented.</p>\n</li>\n<li><p><strong>Edge to Shield Request:</strong> The <code>EdgeRequestHandler</code> calls <code>_fetch_from_upstream</code>, which forwards the original request (potentially with added CDN-specific headers like <code>X-Forwarded-For</code>) to the configured <strong>origin shield</strong> URL, not directly to the origin.</p>\n</li>\n<li><p><strong>Shield Receives Request:</strong> The <code>ShieldRequestHandler</code> at the shield node receives the request. It first performs its own <strong>cache lookup</strong> using the same cache key logic. In this miss scenario, the shield also does not have a fresh entry.</p>\n</li>\n<li><p><strong>Request Collapsing Logic:</strong> The shield uses its <code>RequestCoalescingMap</code> to prevent a <strong>thundering herd</strong>. It calls <code>RequestCoalescingMap.get_or_create_future(cache_key)</code>.</p>\n<ul>\n<li>If this is the <strong>first concurrent request</strong> for this key, the method creates a new <code>asyncio.Future</code>, registers it in the map, and allows this request to proceed to the origin.</li>\n<li>If other <strong>identical requests are already in-flight</strong>, the method returns the existing <code>Future</code>. These duplicate requests will <code>await</code> the result of that single Future, effectively &quot;collapsing&quot; into one origin fetch.</li>\n</ul>\n</li>\n<li><p><strong>Origin Fetch with Concurrency Limit:</strong> The shield thread/proces that won the right to fetch from the origin first acquires a permit from the <code>_origin_semaphore</code>, which enforces a maximum concurrency limit to the origin. It then forwards the request to the <strong>origin server</strong>.</p>\n</li>\n<li><p><strong>Origin Response:</strong> The origin server processes the request and returns a standard HTTP response (e.g., <code>200 OK</code> with the image data). It should include proper caching headers (<code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>).</p>\n</li>\n<li><p><strong>Shield Cache Storage &amp; Future Fulfillment:</strong> The shield receives the origin response. It validates if the response is cacheable via <code>is_response_cacheable</code>. If cacheable, it creates a <code>CacheEntry</code> via <code>CacheEntry.from_upstream_response</code> and stores it in its own <code>CacheStorage</code>. The shield then calls <code>RequestCoalescingMap.fulfill_future(cache_key, result)</code> with the response. This action awakens all collapsed requests waiting on that <code>Future</code>, providing each with the same response data.</p>\n</li>\n<li><p><strong>Negative Caching:</strong> If the origin returns an error (e.g., <code>404 Not Found</code> or <code>5xx</code>), the shield may still <strong>cache this negative response</strong> for a very short TTL (e.g., 10 seconds) to prevent overwhelming the origin with repeated requests for the same non-existent or failing resource. This is a critical protection mechanism.</p>\n</li>\n<li><p><strong>Response to Edge:</strong> The shield sends the origin&#39;s response (or the cached negative response) back to the requesting edge node.</p>\n</li>\n<li><p><strong>Edge Cache Storage:</strong> The edge node receives the response from the shield. It performs its own cacheability check, creates its own <code>CacheEntry</code>, stores it locally, and updates the <code>SurrogateKeyIndex</code> if the response includes a <code>Surrogate-Key</code> header.</p>\n</li>\n<li><p><strong>Analytics Update:</strong> Both shield and edge update their metrics (<code>ShieldMetrics.collapsed_requests</code>, <code>EdgeMetrics.total_bandwidth_upstream</code>).</p>\n</li>\n<li><p><strong>Final Delivery:</strong> Finally, the edge node sends the HTTP response back to the original client. The client receives the data, unaware of the multi-tiered fetching and collapsing that occurred.</p>\n</li>\n</ol>\n<p><strong>Architecture Decision Record: Request Collapsing Timeout Strategy</strong></p>\n<blockquote>\n<p><strong>Decision: Use a Short, Configurable Timeout for Collapsed Requests</strong></p>\n<ul>\n<li><strong>Context:</strong> When requests are collapsed at the shield, duplicate clients wait for a single origin fetch. If that fetch hangs or is very slow, all waiting clients could experience unacceptable latency or timeouts.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Infinite Wait:</strong> Duplicate requests wait indefinitely for the lead request&#39;s future. Simple but risks massive client timeouts and resource exhaustion during origin slowness.</li>\n<li><strong>Client-Propagated Timeout:</strong> Use the shortest remaining client timeout among the collapsed requests. Complex to coordinate and requires intercepting/client timeout awareness.</li>\n<li><strong>Fixed, Configurable Shield Timeout:</strong> Set a shield-specific timeout (e.g., 3-5 seconds) shorter than typical client HTTP timeouts. If the lead request exceeds this, its future fails, releasing waiting requests to potentially retry or bypass collapsing.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Implement a fixed, configurable timeout in the <code>RequestCoalescingMap</code> (Option 3).</li>\n<li><strong>Rationale:</strong> This provides a straightforward safety valve. It ensures the shield doesn&#39;t become a bottleneck if the origin is severely impaired. The timeout should be configured to be shorter than the edge node&#39;s upstream timeout and typical client timeouts, ensuring the edge can fall back to a direct fetch or error before the client disconnects.</li>\n<li><strong>Consequences:</strong> Requires logic to clean up timed-out futures and potentially allows a subsequent request to become the new &quot;lead&quot; for fetching, preventing a complete deadlock. Adds a configuration parameter to tune based on origin performance SLAs.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Infinite Wait</td>\n<td>Simple implementation</td>\n<td>Causes cascading client failures on origin slowness</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Client-Propagated Timeout</td>\n<td>Fair, respects each client&#39;s tolerance</td>\n<td>Extremely complex; requires parsing timeouts from unknown client implementations</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fixed Shield Timeout</td>\n<td>Simple, predictable, provides circuit-breaker</td>\n<td>May break slow-but-valid origin responses; requires tuning</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"control-flow-global-cache-invalidation\">Control Flow: Global Cache Invalidation</h3>\n<p><strong>Mental Model: The Building Eviction Notice System</strong>\nImagine a property manager needing to remove specific items from all branch offices. For a single filing cabinet (URL purge), they call each branch to have it removed immediately. For a policy change affecting all documents of a certain category (tag purge), they send a broadcast memo listing the category code. For a rule that all documents matching a pattern (e.g., &quot;draft-*&quot;) should be discarded upon next access (ban), they update a central rulebook distributed to all branches. The <strong>control plane</strong> is the manager&#39;s office, coordinating these distributed operations.</p>\n<p>Invalidation is a control-plane operation that ensures consistency between the origin&#39;s truth and the cached copies. Its propagation must be reliable and efficient. The sequence diagram <code>![Sequence: Purge Propagation via Control Plane](/api/project/cdn-implementation/architecture-doc/asset?path=diagrams%2Fseq-invalidation-propagation.svg)</code> depicts this process.</p>\n<ol>\n<li><p><strong>Administrative Command:</strong> An administrator or an automated system (e.g., triggered by a content management system update) issues an invalidation command. This is typically done via a dedicated API endpoint (e.g., <code>PURGE /purge</code> on the control plane) or a management console. The command specifies the type (<code>purge</code>, <code>soft-purge</code>, <code>ban</code>, <code>tag</code>) and target (URL, pattern, or surrogate key).</p>\n</li>\n<li><p><strong>Control Plane Reception &amp; Validation:</strong> The control plane&#39;s API server receives the command, authenticates/authorizes the request, and validates its parameters. It constructs a standardized <code>InvalidationMessage</code> containing a unique <code>message_id</code>, <code>command</code>, <code>target</code>, <code>timestamp</code>, and other metadata.</p>\n</li>\n<li><p><strong>Message Broadcast:</strong> The control plane publishes the <code>InvalidationMessage</code> to a specific <strong>pub/sub channel</strong> (e.g., <code>invalidation:global</code>) using the <code>InMemoryPubSubBroker.publish</code> method. All edge nodes that have previously subscribed to this channel via <code>InMemoryPubSubBroker.subscribe</code> will receive the message. This decouples the sender from the receivers and allows for scalable fan-out.</p>\n</li>\n<li><p><strong>Edge Node Reception:</strong> Each edge node&#39;s <code>InvalidationHandler</code> has a registered callback that is invoked with the <code>InvalidationMessage</code>. The handler first may deduplicate messages using the <code>message_id</code> to avoid processing the same command multiple times (e.g., in case of network retries).</p>\n</li>\n<li><p><strong>Local Invalidation Execution:</strong> The handler executes the command locally on its node&#39;s cache:</p>\n<ul>\n<li><strong>For a URL Purge:</strong> It generates the cache key for the given URL (considering <code>Vary</code> headers) and calls <code>_hard_purge_key</code> or <code>_soft_purge_key</code>.</li>\n<li><strong>For a Tag Purge:</strong> It calls <code>_purge_by_tag(tag, is_soft)</code>, which uses the local <code>SurrogateKeyIndex.get_keys_for_tag</code> to find all affected cache keys and purges them.</li>\n<li><strong>For a Ban Rule:</strong> It calls <code>add_ban_rule(pattern, is_soft, ttl_seconds)</code> to add the rule to the local list of <code>BanRule</code>s. Future requests matching the pattern will be invalidated (lazily, upon access).</li>\n</ul>\n</li>\n<li><p><strong>Acknowledgment (Optional):</strong> In a more advanced implementation, edge nodes may send an acknowledgment message back to the control plane, allowing it to track propagation completeness. For our foundational design, we assume <strong>best-effort, eventually consistent</strong> propagation.</p>\n</li>\n<li><p><strong>Cleanup:</strong> For ban rules, a background garbage collection task (<code>_gc_ban_rules</code>) periodically runs on each edge node to remove expired rules, preventing memory leaks.</p>\n</li>\n</ol>\n<p><strong>Common Pitfalls in Invalidation Propagation:</strong></p>\n<p>⚠️ <strong>Pitfall: Ignoring Propagation Delay</strong></p>\n<ul>\n<li><strong>Description:</strong> Assuming that once a purge API call returns, the content is immediately invalidated worldwide.</li>\n<li><strong>Why it&#39;s Wrong:</strong> Network latency, node failures, and message queue delays mean there is a window (seconds to minutes) where some edge nodes may still serve stale content. This violates consistency expectations.</li>\n<li><strong>Fix:</strong> Design the system with <strong>eventual consistency</strong> in mind. Document this behavior. For stronger guarantees, implement synchronous purges to critical nodes or use versioned URLs (e.g., <code>/image.jpg?v=2</code>) to bypass caching entirely.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Inefficient Tag-Based Purge on Large Indexes</strong></p>\n<ul>\n<li><strong>Description:</strong> Iterating over all cache entries to find those matching a tag when the <code>SurrogateKeyIndex</code> is large can block the request thread and cause latency spikes.</li>\n<li><strong>Why it&#39;s Wrong:</strong> A tag like &quot;homepage&quot; might be associated with thousands of entries (CSS, JS, images). Linearly scanning a list or performing many individual cache deletions is slow.</li>\n<li><strong>Fix:</strong> Use the reverse index in <code>SurrogateKeyIndex</code> (<code>tag_to_keys</code>) for O(1) lookups of affected keys. Perform the actual cache evictions in a background thread to avoid blocking the purge API response.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ban Rule Explosion</strong></p>\n<ul>\n<li><strong>Description:</strong> Continuously adding new ban rules (e.g., for every user-generated content update) without a TTL or cleanup mechanism.</li>\n<li><strong>Why it&#39;s Wrong:</strong> The list of <code>BanRule</code> objects grows indefinitely, consuming memory and slowing down the <code>check_bans(url)</code> function which must evaluate every rule against every requested URL.</li>\n<li><strong>Fix:</strong> Always attach a sensible TTL to programmatically added ban rules. Implement the <code>_gc_ban_rules</code> background task to regularly purge expired rules. For high-volume patterns, consider using a more scalable data structure like a Bloom filter for certain prefix-based bans (with the understanding of its probabilistic nature).</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This guidance provides the foundational code to connect the components and realize the data flows described above. Focus is on the glue logic and critical coordination structures.</p>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (for Learning)</th>\n<th>Advanced Option (for Production-readiness)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inter-Component Messaging</td>\n<td>In-memory Pub/Sub within a single process (for simulation)</td>\n<td>Redis Pub/Sub or Apache Kafka for distributed, persistent messaging</td>\n</tr>\n<tr>\n<td>Request Collapsing</td>\n<td><code>asyncio.Future</code> and <code>asyncio.Lock</code> in Python</td>\n<td>Dedicated library with support for timeouts, circuit breaking, and metrics (e.g., <code>aiocache</code> patterns)</td>\n</tr>\n<tr>\n<td>Health Checking &amp; Discovery</td>\n<td>Periodic HTTP <code>GET /health</code> polls from control plane</td>\n<td>Gossip protocol (SWIM) for decentralized failure detection and membership</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>In-memory counters flushed periodically to logs</td>\n<td>OpenTelemetry SDK exporting to Prometheus or Grafana</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong>\nAdd the following files to manage the flow and interactions:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin_cdn/\n├── internal/\n│   ├── flow/\n│   │   ├── __init__.py\n│   │   ├── coordinator.py          # Control plane logic for message broadcasting\n│   │   └── sequences.py           # Integration tests for the data flows\n│   ├── messaging/\n│   │   ├── __init__.py\n│   │   ├── pubsub.py              # InMemoryPubSubBroker implementation\n│   │   └── message.py             # InvalidationMessage and other DTOs\n│   └── utils/\n│       └── timeouts.py            # Utility for managing timeouts in collapsing\n└── simulations/\n    ├── multi_edge_hit.py          # Script to simulate cache hit flow\n    ├── miss_with_shield.py        # Script to simulate miss/collapsing flow\n    └── global_purge.py            # Script to simulate invalidation propagation</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>1. In-Memory Pub/Sub Broker (<code>internal/messaging/pubsub.py</code>):</strong>\nThis is a complete, thread-safe implementation for simulation and testing. In a real distributed CDN, this would be replaced with Redis or Kafka.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, Set, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidationMessage</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    command: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # \"purge\", \"soft_purge\", \"ban\", \"tag_purge\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">   # URL, pattern, or tag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    soft: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InMemoryPubSubBroker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Simple in-memory publish-subscribe broker for simulation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._subscribers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Set[Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> subscribe</span><span style=\"color:#E1E4E8\">(self, channel: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, callback: Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Subscribe a callback to a channel.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> channel </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._subscribers[channel] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._subscribers[channel].add(callback)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> unsubscribe</span><span style=\"color:#E1E4E8\">(self, channel: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, callback: Callable[[InvalidationMessage], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Unsubscribe a callback from a channel.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> channel </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._subscribers[channel].discard(callback)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers[channel]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers[channel]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> publish</span><span style=\"color:#E1E4E8\">(self, channel: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, message: InvalidationMessage):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Publish a message to all subscribers of a channel.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            subscribers </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._subscribers.get(channel, </span><span style=\"color:#79B8FF\">set</span><span style=\"color:#E1E4E8\">()).copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Call each subscriber in the background (fire-and-forget)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> callback </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> subscribers:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # In a real system, you might want to handle exceptions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            asyncio.create_task(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._safe_callback(callback, message))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _safe_callback</span><span style=\"color:#E1E4E8\">(self, callback, message):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Wrapper to catch and log exceptions in subscriber callbacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> callback(message)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error in pub/sub callback: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>2. Request Coalescing Map with Timeout (<code>internal/flow/coordinator.py</code>):</strong>\nThis is a critical piece for the origin shield. It manages the futures for collapsing.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RequestCoalescingMap</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Tracks in-flight requests by cache key to enable request collapsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3.0</span><span style=\"color:#E1E4E8\">, cleanup_interval: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._futures: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, asyncio.Future] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._timeouts: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># key -> creation time</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._default_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> default_timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._gc_task: Optional[asyncio.Task] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._start_gc_loop(cleanup_interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _start_gc_loop</span><span style=\"color:#E1E4E8\">(self, interval: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start background garbage collection loop.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> gc_loop</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(interval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._gc_loop(interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._gc_task </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.create_task(gc_loop())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> get_or_create_future</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> asyncio.Future:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get existing Future for key or create a new one.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns a Future that will resolve to the (status, headers, body) tuple.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cache_key </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures[cache_key]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Create new future</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            future </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Future()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._futures[cache_key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> future</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._timeouts[cache_key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> future</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fulfill_future</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, result: </span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set result for Future associated with key and clean up.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            future </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._timeouts.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> future </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> future.done():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            future.set_result(result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fail_future</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, exception: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set exception for Future associated with key and clean up.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            future </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._timeouts.pop(cache_key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> future </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> future.done():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            future.set_exception(exception)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _gc_loop</span><span style=\"color:#E1E4E8\">(self, interval: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Background cleanup of timed-out entries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        to_remove </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> key, created_at </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._timeouts.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> created_at </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._default_timeout:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    to_remove.append(key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> key </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> to_remove:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                future </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._futures.pop(key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">._timeouts.pop(key, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> future </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> future.done():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    future.set_exception(asyncio.TimeoutError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Request coalescing timeout for </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">key</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> stop</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Stop the garbage collection loop.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._gc_task:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._gc_task.cancel()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._gc_task</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\"> asyncio.CancelledError:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>1. Shield Request Handler with Collapsing (<code>internal/shield/handler.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..cache.storage </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheStorage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..flow.coordinator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> RequestCoalescingMap</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ShieldRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles requests at the origin shield layer with request collapsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache: CacheStorage, origin_upstream: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 coalescing_map: RequestCoalescingMap, max_concurrent_requests: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.origin_upstream </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> origin_upstream</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.coalescing_map </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> coalescing_map</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._origin_semaphore </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Semaphore(max_concurrent_requests)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(self, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main request handling algorithm for the shield.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Steps:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1. Generate cache key from URL and Vary headers.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2. Check local cache; if fresh, serve and return.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        3. If stale but revalidatable, serve stale and start background revalidation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        4. On miss, use request collapsing map to deduplicate concurrent requests.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        5. Acquire semaphore to limit origin concurrency.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        6. Fetch from origin.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        7. Cache the response (including negative caching for errors).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        8. Fulfill the future in the coalescing map.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        9. Return response.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse request method, URL, and headers from request_headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate a cache key using URL and Vary header dimensions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check local cache storage for the key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If cache hit and fresh, return cached response immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If cache hit but stale, check if stale-while-revalidate applies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - If yes, serve stale and call _revalidate_in_background</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: On cache miss, call self.coalescing_map.get_or_create_future(key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If the returned future is already done (another request filled it), return its result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: If this is the first request (future not done), proceed to fetch from origin:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         a. Acquire self._origin_semaphore</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         b. Make HTTP request to self.origin_upstream</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         c. Parse response status, headers, body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         d. Determine if response is cacheable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         e. If cacheable, store in self.cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         f. Call self.coalescing_map.fulfill_future(key, (status, headers, body))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         g. Return the response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Implement proper exception handling:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - On origin timeout/error, call self.coalescing_map.fail_future</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - Consider negative caching for 404/5xx errors with short TTL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _revalidate_in_background</span><span style=\"color:#E1E4E8\">(self, cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, stale_entry, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Asynchronously revalidate a stale cache entry.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Should update the cache if the origin returns 200, or delete it if 304.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Make a conditional request to origin with If-None-Match/If-Modified-Since</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If origin returns 200 OK, replace stale_entry in cache with new response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If origin returns 304 Not Modified, update stale_entry's expires_at/metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Log errors but don't propagate (this is background)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>2. Control Plane Invalidation Endpoint (<code>internal/control/api.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> fastapi </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FastAPI, HTTPException, BackgroundTasks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..messaging.pubsub </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InMemoryPubSubBroker, InvalidationMessage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">app </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FastAPI()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">broker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InMemoryPubSubBroker()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.post</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/invalidate/purge\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> purge_url</span><span style=\"color:#E1E4E8\">(url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, background_tasks: BackgroundTasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Admin API to purge a specific URL from all edge caches.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate admin authentication/authorization (basic implementation could use API key)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create an InvalidationMessage with command=\"purge\", target=url, soft=soft</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InvalidationMessage(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        message_id</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(uuid.uuid4()),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        command</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"soft_purge\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> soft </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> \"purge\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        target</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">url,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        soft</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">soft,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        parameters</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"reason\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"manual_api_call\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Publish the message to the global invalidation channel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Use background task to avoid blocking the API response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    background_tasks.add_task(broker.publish, </span><span style=\"color:#9ECBFF\">\"invalidation:global\"</span><span style=\"color:#E1E4E8\">, message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"status\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"accepted\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"message_id\"</span><span style=\"color:#E1E4E8\">: message.message_id}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.post</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/invalidate/tag\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> purge_tag</span><span style=\"color:#E1E4E8\">(tag: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, background_tasks: BackgroundTasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Admin API to purge all resources with a given surrogate key tag.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate input (tag format)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create InvalidationMessage with command=\"tag_purge\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Publish to broker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@app.post</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/invalidate/ban\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> add_ban_rule</span><span style=\"color:#E1E4E8\">(pattern: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, ttl_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3600</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       soft: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, background_tasks: BackgroundTasks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Admin API to add a new ban rule.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate pattern (e.g., check for reasonable length, prevent injection)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create InvalidationMessage with command=\"ban\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include ttl_seconds in parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Publish to broker</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (Python)</strong></p>\n<ul>\n<li><strong>Use <code>asyncio</code> for Concurrency:</strong> The request collapsing and background revalidation are natural fits for async/await. Use <code>asyncio.create_task()</code> for fire-and-forget background operations.</li>\n<li><strong>Type Hints:</strong> Use Python type hints extensively for the data structures defined in the naming conventions. This will catch many errors early and serve as documentation.</li>\n<li><strong>Testing Async Code:</strong> Use <code>pytest-asyncio</code> for testing async components. Mock the <code>CacheStorage</code> and origin HTTP calls to simulate different flow scenarios.</li>\n<li><strong>Configuration Management:</strong> Use Pydantic models for <code>EdgeConfig</code> to get validation and type-safe access to configuration values loaded from YAML or environment variables.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint: Flow Integration</strong>\nAfter implementing the core components, test the integrated flows:</p>\n<ol>\n<li><strong>Cache Hit Flow Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start a mock origin server (serves static files)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#9ECBFF\"> tests/mock_origin.py</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#79B8FF\"> 8001</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Start an edge node pointing to the origin</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin_cdn.edge</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/edge_local.yaml</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Make a request, then make it again (should hit)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/image.jpg</span><span style=\"color:#6A737D\">  # Check Age header increases</span></span></code></pre></div>\n<p>   <strong>Expected:</strong> First request logs <code>[MISS]</code>, second logs <code>[HIT]</code>. The <code>Age</code> header in the second response should be &gt;0.</p>\n<ol start=\"2\">\n<li><strong>Cache Miss with Shield Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start shield pointing to origin</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin_cdn.shield</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/shield_local.yaml</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Start edge pointing to shield (not directly to origin)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Update edge config upstream_url to shield address</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Use Apache Bench to simulate concurrent requests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ab</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> http://localhost:8080/new_image.jpg</span></span></code></pre></div>\n<p>   <strong>Expected:</strong> Shield logs should show <code>[COLLAPSED]</code> messages. Origin server logs should show only 1 request for <code>new_image.jpg</code>, not 100.</p>\n<ol start=\"3\">\n<li><strong>Global Invalidation Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start two edge nodes and one control plane</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin_cdn.control_plane</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin_cdn.edge</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/edge_node1.yaml</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> blue_origin_cdn.edge</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> config/edge_node2.yaml</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Populate cache on both edges</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://node1:8080/image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#9ECBFF\"> http://node2:8080/image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Send purge command via control plane API</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://control-plane:9000/invalidate/purge?url=/image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Request again - should miss on both nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://node1:8080/image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://node2:8080/image.jpg</span></span></code></pre></div>\n<p>   <strong>Expected:</strong> After purge, both edges should log <code>[MISS]</code> and fetch fresh content from upstream. Check control plane logs for message broadcast.</p>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Edge Cache Implementation), Milestone 2 (Cache Invalidation), Milestone 3 (Origin Shield &amp; Request Collapsing), Milestone 4 (Edge Node Distribution &amp; Routing), Milestone 5 (CDN Analytics &amp; Performance Optimization)</p>\n</blockquote>\n<p>The true test of a CDN&#39;s architectural soundness isn&#39;t how it performs under ideal conditions, but how it degrades when components fail and how it handles the messy reality of HTTP traffic. This section systematically documents failure modes, recovery strategies, and edge case handling—transforming the CDN from a fragile prototype into a robust production-ready system.</p>\n<h3 id=\"failure-modes-amp-recovery-strategies\">Failure Modes &amp; Recovery Strategies</h3>\n<h4 id=\"mental-model-the-redundant-bridge-system\">Mental Model: The Redundant Bridge System</h4>\n<p>Imagine a network of bridges connecting islands. The primary bridge (origin) sometimes collapses, detour bridges (edge nodes) can become congested, and storms (network partitions) can isolate entire islands. A resilient transportation system has redundant routes, detour signs, and temporary shelters. Our CDN employs similar strategies: when the origin fails, we serve stale content from shelters (cache); when edges fail, we redirect traffic via detours (failover); when storms isolate nodes, they operate independently until reconnected (degraded mode).</p>\n<h4 id=\"catalog-of-failure-modes-and-recovery-strategies\">Catalog of Failure Modes and Recovery Strategies</h4>\n<p>The CDN must handle failures at multiple levels while maintaining some level of service. The following table documents each failure mode, its detection mechanism, and the corresponding recovery strategy.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Impact on Clients</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Origin Server Unavailable</strong></td>\n<td>HTTP request timeout (5s) or status code 5xx from origin</td>\n<td>Serve stale content using <code>stale-if-error</code> directive; if no stale content available, return 502 Bad Gateway</td>\n<td>Temporary degradation: clients may see older content or error pages</td>\n<td>Monitor <code>origin_errors</code> in <code>ShieldMetrics</code>; implement exponential backoff for retries</td>\n</tr>\n<tr>\n<td><strong>Edge Node Failure</strong></td>\n<td>Health checks failing (TCP connect timeout, HTTP 5xx on <code>/health</code>)</td>\n<td>Geo-routing redirects clients to next-nearest healthy edge node within failover timeout</td>\n<td>Brief interruption (&lt;5s) during failover, then normal service</td>\n<td>Update consistent hash ring to redistribute keys from failed node</td>\n</tr>\n<tr>\n<td><strong>Network Partition (Edge ↔ Origin)</strong></td>\n<td>Repeated timeouts when contacting upstream</td>\n<td>Edge nodes operate in &quot;degraded mode&quot;: serve stale content exclusively, disable cache updates</td>\n<td>Clients see potentially outdated content until partition heals</td>\n<td>Implement circuit breaker pattern for upstream connections</td>\n</tr>\n<tr>\n<td><strong>Network Partition (Edge ↔ Control Plane)</strong></td>\n<td>Heartbeat timeout with control plane</td>\n<td>Edge nodes continue serving traffic with local configuration; invalidation commands queue locally</td>\n<td>Cache may become stale (eventual consistency issues)</td>\n<td>Buffer invalidation messages in local queue for eventual sync</td>\n</tr>\n<tr>\n<td><strong>Cache Storage Exhaustion</strong></td>\n<td><code>current_cache_size_bytes</code> approaches <code>cache_capacity_bytes</code></td>\n<td>LRU/LFU eviction removes least valuable entries; log warnings; optionally compress existing entries</td>\n<td>Slight increase in cache misses for evicted content</td>\n<td>Monitor <code>current_cache_size_bytes</code> in <code>EdgeMetrics</code>; implement compression for text responses</td>\n</tr>\n<tr>\n<td><strong>Disk I/O Errors (if persistent cache)</strong></td>\n<td>Failed read/write operations with errno</td>\n<td>Fall back to in-memory cache only; log critical error; alert operator</td>\n<td>Reduced cache capacity, increased origin load</td>\n<td>Use <code>try/except</code> around all filesystem operations; implement graceful degradation</td>\n</tr>\n<tr>\n<td><strong>Memory Exhaustion</strong></td>\n<td><code>MemoryError</code> exceptions or OOM killer</td>\n<td>Reject new cache entries while serving existing ones; aggressively evict old entries</td>\n<td>Increased cache misses, potential 503 errors for new content</td>\n<td>Monitor memory usage via <code>HealthMetrics</code>; implement soft limits</td>\n</tr>\n<tr>\n<td><strong>DNS Resolution Failure</strong></td>\n<td><code>socket.gaierror</code> when resolving upstream hostnames</td>\n<td>Use cached DNS results with TTL; fall back to backup origin IPs if configured</td>\n<td>Service interruption if no cached resolution available</td>\n<td>Implement DNS caching with TTL validation; pre-resolve critical hostnames</td>\n</tr>\n<tr>\n<td><strong>SSL/TLS Handshake Failure</strong></td>\n<td><code>ssl.SSLError</code> during upstream connection</td>\n<td>Attempt plain HTTP if origin supports it (configurable); otherwise fail with 502</td>\n<td>Potential security downgrade or service interruption</td>\n<td>Implement TLS version fallback; maintain certificate cache</td>\n</tr>\n<tr>\n<td><strong>Clock Skew Between Nodes</strong></td>\n<td>Comparison of timestamps in invalidation messages</td>\n<td>Use logical clocks (Lamport timestamps) for invalidation ordering; NTP synchronization required</td>\n<td>Potential cache inconsistency if skew &gt; TTL window</td>\n<td>Include logical timestamp in <code>InvalidationMessage</code>; implement NTP client</td>\n</tr>\n</tbody></table>\n<p><strong>Design Principle:</strong> <em>Graceful degradation beats catastrophic failure.</em> The system should never completely stop serving traffic unless absolutely necessary. Each failure mode has a defined fallback that maintains some level of service.</p>\n<h4 id=\"adr-stale-content-serving-strategy\">ADR: Stale Content Serving Strategy</h4>\n<blockquote>\n<p><strong>Decision: Serve Stale Content with <code>stale-if-error</code> During Origin Failures</strong></p>\n<ul>\n<li><strong>Context</strong>: When the origin server becomes unavailable, the CDN faces a choice: return errors (502/504) or serve potentially outdated content from cache. Returning errors provides accuracy but poor user experience during origin outages.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Always return 502/504</strong>: Strict correctness but poor availability during origin failures</li>\n<li><strong>Serve stale content indefinitely</strong>: High availability but potentially serving very outdated content</li>\n<li><strong>Serve stale content with <code>stale-if-error</code> and time limits</strong>: Balanced approach with configurable staleness windows</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement <code>stale-if-error</code> semantics per RFC 9111, with configurable maximum staleness (default: 1 hour).</li>\n<li><strong>Rationale</strong>: The <code>stale-if-error</code> extension is standard HTTP semantics that clients understand. It provides availability during temporary origin issues while bounding how stale content can become. This aligns with CDN industry practices where serving slightly stale content is preferable to complete unavailability.</li>\n<li><strong>Consequences</strong>: Clients may receive outdated content during origin failures, but the system remains available. Operators must monitor staleness duration and set appropriate limits based on content volatility.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Always return 502/504</td>\n<td>Strictly correct behavior, no stale content</td>\n<td>Poor availability during origin outages</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Serve stale indefinitely</td>\n<td>Maximum availability</td>\n<td>May serve very outdated content without bound</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Serve with <code>stale-if-error</code> and limits</strong></td>\n<td><strong>Balances availability and freshness, standard-compliant</strong></td>\n<td><strong>Adds complexity to cache freshness logic</strong></td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"implementation-of-failure-recovery\">Implementation of Failure Recovery</h4>\n<p>The recovery strategies translate to concrete implementation patterns:</p>\n<ol>\n<li><p><strong>Circuit Breaker for Upstream Connections</strong>: Implement the circuit breaker pattern to prevent cascading failures when the origin is unhealthy. After a threshold of failures, the circuit opens and all requests immediately fail fast to stale cache, periodically allowing a test request to check if the origin has recovered.</p>\n</li>\n<li><p><strong>Health-Based Routing Fallback</strong>: When the primary edge node is unhealthy, the geo-routing system should redirect to the next-nearest node. This requires maintaining a sorted list of backup nodes per region and implementing fast health check propagation.</p>\n</li>\n<li><p><strong>Degraded Mode Flag</strong>: Each edge node should maintain a <code>degraded_mode</code> boolean that gets set when critical dependencies (origin, control plane) are unavailable. In degraded mode, the node:</p>\n<ul>\n<li>Serves stale content regardless of freshness</li>\n<li>Logs all cache misses (but doesn&#39;t attempt to fetch from origin)</li>\n<li>Returns custom <code>X-CDN-Degraded: true</code> header</li>\n<li>Periodically attempts to reconnect to dependencies</li>\n</ul>\n</li>\n<li><p><strong>Request Queue Management During Failover</strong>: When an edge node fails, the consistent hashing ring redistributes its keys to other nodes. These nodes may experience a &quot;cold start&quot; problem with empty caches. Implement request queuing and rate limiting to prevent thundering herd on the origin during redistribution.</p>\n</li>\n</ol>\n<h3 id=\"http-edge-cases\">HTTP Edge Cases</h3>\n<h4 id=\"mental-model-the-quirky-mailroom-clerk\">Mental Model: The Quirky Mailroom Clerk</h4>\n<p>Imagine a mailroom clerk who must handle every possible mailing scenario: packages with contradictory instructions (Vary: *), massive crates that need partial delivery (range requests), and envelopes with unreadable postmarks (malformed headers). A good clerk has procedures for each edge case—knowing when to reject, when to improvise, and when to consult the rulebook. Our CDN edge cache acts as this clerk, implementing specific logic for HTTP&#39;s corner cases.</p>\n<h4 id=\"handling-complex-http-caching-scenarios\">Handling Complex HTTP Caching Scenarios</h4>\n<table>\n<thead>\n<tr>\n<th>HTTP Edge Case</th>\n<th>Standard Behavior</th>\n<th>CDN Implementation</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong><code>Vary: *</code> Header</strong></td>\n<td>Per RFC 9111, means &quot;never cache&quot; because the response varies on all request headers</td>\n<td>Check for <code>Vary: *</code> in response; if present, do not store in cache and bypass cache for future requests</td>\n<td>Prevents cache key explosion and ensures correct content negotiation</td>\n</tr>\n<tr>\n<td><strong><code>Cache-Control: no-store</code></strong></td>\n<td>Response must not be stored in any cache</td>\n<td>Respect directive: do not store response in cache; existing entries must be invalidated</td>\n<td>Privacy/security requirement; override any other caching directives</td>\n</tr>\n<tr>\n<td><strong><code>Cache-Control: private</code></strong></td>\n<td>Response is intended for a single user and must not be stored in shared caches</td>\n<td>CDN as shared cache must not store; edge caches skip storage, but shield may still cache if configured</td>\n<td>Respects user privacy while allowing some optimization</td>\n</tr>\n<tr>\n<td><strong>Malformed <code>Cache-Control</code> Header</strong></td>\n<td>Invalid syntax (e.g., <code>max-age=not-a-number</code>)</td>\n<td>Parse leniently: ignore malformed directives, log warning, use defaults (or <code>max-age=0</code> if uncertain)</td>\n<td>Robustness over strictness; better to cache with short TTL than break</td>\n</tr>\n<tr>\n<td><strong>Conflicting Directives</strong> (e.g., <code>max-age=3600</code> and <code>no-cache</code>)</td>\n<td><code>no-cache</code> takes precedence for validation, but <code>max-age</code> still sets freshness lifetime</td>\n<td>Implement precedence hierarchy: <code>no-store</code> &gt; <code>no-cache</code> &gt; <code>private</code> &gt; <code>s-maxage</code> &gt; <code>max-age</code> &gt; default</td>\n<td>Follows RFC 9111 Section 5.2.2 directive precedence</td>\n</tr>\n<tr>\n<td><strong>Multiple <code>Cache-Control</code> Headers</strong></td>\n<td>Headers should be concatenated with commas</td>\n<td>Use <code>get_header_values()</code> to collect all values, then parse combined string</td>\n<td>Handles HTTP/1.x and HTTP/2 differences in header serialization</td>\n</tr>\n<tr>\n<td><strong><code>Expires</code> in the Past</strong></td>\n<td>Resource is already stale when received</td>\n<td>Treat as <code>max-age=0</code>, requiring immediate revalidation</td>\n<td>Prevents serving already-expired content</td>\n</tr>\n<tr>\n<td><strong><code>ETag</code> with <code>W/</code> Prefix (Weak Validator)</strong></td>\n<td>Allows semantic equivalence (e.g., reformatted HTML)</td>\n<td>Support weak validation: match weak ETags only with <code>If-None-Match</code>, not with <code>If-Match</code></td>\n<td>Enables more efficient caching when content changes insignificantly</td>\n</tr>\n<tr>\n<td><strong><code>Vary</code> with Multiple Headers</strong> (e.g., <code>Vary: Accept-Encoding, User-Agent</code>)</td>\n<td>Response varies on all listed headers</td>\n<td>Include all specified header values in cache key; store separate entry for each combination</td>\n<td>Correctly handles multi-dimensional content negotiation</td>\n</tr>\n<tr>\n<td><strong><code>Accept-Encoding</code> with <code>identity</code> or <code>*</code></strong></td>\n<td>Client accepts any encoding, including none</td>\n<td>Normalize: treat <code>*</code> as <code>identity</code>; include normalized encoding in cache key</td>\n<td>Prevents cache fragmentation from semantically equivalent headers</td>\n</tr>\n<tr>\n<td><strong>Range Requests (<code>Range: bytes=0-499</code>)</strong></td>\n<td>Request for partial content; requires <code>206 Partial Content</code> response</td>\n<td>Check cache for full response; if present, extract range and return 206; otherwise fetch range or full from origin</td>\n<td>Supports video streaming and large file downloads efficiently</td>\n</tr>\n<tr>\n<td><strong><code>If-Range</code> Conditional Range Requests</strong></td>\n<td>Continue interrupted downloads if unchanged</td>\n<td>If ETag/Last-Modified matches, serve requested range; otherwise serve full entity</td>\n<td>Optimizes recovery from interrupted downloads</td>\n</tr>\n<tr>\n<td><strong><code>POST</code> to Cacheable URL</strong></td>\n<td>POST generally invalidates cached GET to same URL</td>\n<td>Invalidate cache entry for the URL on successful POST (status 2xx/3xx)</td>\n<td>Maintains cache consistency when content is modified</td>\n</tr>\n<tr>\n<td><strong><code>PUT</code>/<code>DELETE</code> to Cached URL</strong></td>\n<td>Modifies or removes resource</td>\n<td>Invalidate cache entry for the URL</td>\n<td>Ensures cache reflects resource state changes</td>\n</tr>\n<tr>\n<td><strong>Responses Exceeding Cache Size Limit</strong></td>\n<td>Too large to store given capacity constraints</td>\n<td>Stream response to client without caching; log warning; increment <code>too_large_to_cache</code> metric</td>\n<td>Prevents single large response from evicting many small ones</td>\n</tr>\n<tr>\n<td><strong>Chunked Transfer Encoding</strong></td>\n<td>Response body delivered in chunks</td>\n<td>Reassemble complete body before caching; stream chunks to client immediately</td>\n<td>Cache stores complete entities, not transfer encoding state</td>\n</tr>\n<tr>\n<td><strong><code>304 Not Modified</code> Responses</strong></td>\n<td>Conditional request found resource unchanged</td>\n<td>Update freshness of existing cache entry without replacing body; update headers from 304 response</td>\n<td>Optimizes bandwidth by avoiding body retransmission</td>\n</tr>\n<tr>\n<td><strong><code>206 Partial Content</code> from Origin</strong></td>\n<td>Origin supports range requests natively</td>\n<td>Cache full response if possible; otherwise cache partial response marked as incomplete</td>\n<td>Future range requests may need full response for other ranges</td>\n</tr>\n</tbody></table>\n<h4 id=\"adr-handling-vary-to-cache-or-not-to-cache\">ADR: Handling Vary: * - To Cache or Not to Cache</h4>\n<blockquote>\n<p><strong>Decision: Never Cache Responses with <code>Vary: *</code></strong></p>\n<ul>\n<li><strong>Context</strong>: The <code>Vary: *</code> header indicates the response varies on all possible request headers. This creates a cache key explosion problem since every request is essentially unique.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Cache with URL-only key</strong>: Ignore the <code>Vary: *</code> and cache based only on URL (incorrect, violates spec)</li>\n<li><strong>Cache with all headers as key</strong>: Include all request headers in cache key (theoretically correct but impractical)</li>\n<li><strong>Do not cache at all</strong>: Treat <code>Vary: *</code> as &quot;never cache&quot; as suggested by RFC 9111</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement &quot;never cache&quot; behavior for <code>Vary: *</code> responses.</li>\n<li><strong>Rationale</strong>: RFC 9111 Section 4.1 suggests that <code>Vary: *</code> &quot;always fails to match&quot; subsequent requests, implying it should not be stored. Practical implementations (Varnish, NGINX) treat it as uncacheable. The alternative of including all headers would make the cache effectively useless due to key explosion.</li>\n<li><strong>Consequences</strong>: Some dynamic content that could theoretically be cached (if we ignored certain headers) won&#39;t be cached. This is an acceptable trade-off for correctness and simplicity.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache with URL-only key</td>\n<td>Would cache some dynamic content</td>\n<td>Violates HTTP spec, serves wrong content to clients with different headers</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Cache with all headers as key</td>\n<td>Theoretically correct</td>\n<td>Cache key explosion makes caching ineffective; high memory overhead</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>Do not cache at all</strong></td>\n<td><strong>Spec-compliant, simple to implement</strong></td>\n<td><strong>Misses caching opportunities for some content</strong></td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"range-request-implementation-details\">Range Request Implementation Details</h4>\n<p>Range requests present particular challenges for caching. The CDN must handle:</p>\n<ol>\n<li><p><strong>Cache Storage for Range Requests</strong>: When a range request misses the cache but the origin returns a <code>206 Partial Content</code>, we have two options:</p>\n<ul>\n<li>Store the partial response separately</li>\n<li>Fetch the entire resource and cache it, then extract the range</li>\n</ul>\n<p>The recommended approach is to attempt to fetch the full resource (using <code>Range: bytes=0-</code> or no Range header) when cache storage is desirable. If the origin only supports range requests, we can cache partial responses with metadata indicating which ranges are available.</p>\n</li>\n<li><p><strong>Range Combining</strong>: If multiple concurrent requests ask for different ranges of the same resource, the CDN should combine them into a single origin request for the full resource (or a superset range) to optimize bandwidth.</p>\n</li>\n<li><p><strong>Range Validation</strong>: When serving a cached response to a range request, validate that the requested range is within the cached entity length. If not, either fetch the needed range from origin or return <code>416 Range Not Satisfiable</code>.</p>\n</li>\n</ol>\n<p><strong>Algorithm for Handling Range Requests:</strong></p>\n<ol>\n<li>Parse <code>Range</code> header using <code>range-units</code> syntax (only <code>bytes</code> unit required)</li>\n<li>Generate cache key including range information (or use full resource key)</li>\n<li>Check cache for matching entry:<ul>\n<li>If full entity cached and fresh: extract range, return <code>206</code></li>\n<li>If partial entity cached containing requested range: serve from cache</li>\n<li>Otherwise: proceed to origin</li>\n</ul>\n</li>\n<li>Forward to origin with appropriate <code>Range</code> header</li>\n<li>On <code>206</code> response: cache full entity if possible, otherwise cache partial with range metadata</li>\n<li>On <code>200</code> response (origin doesn&#39;t support ranges): cache full entity, extract requested range for response</li>\n<li>Always set <code>Content-Range</code> and <code>Accept-Ranges: bytes</code> headers in response</li>\n</ol>\n<h4 id=\"common-pitfalls-in-error-handling\">Common Pitfalls in Error Handling</h4>\n<p>⚠️ <strong>Pitfall: Silent Degradation to Stale Content Indefinitely</strong></p>\n<ul>\n<li><strong>Description</strong>: When the origin fails, serving stale content via <code>stale-if-error</code> without time limits.</li>\n<li><strong>Why it&#39;s wrong</strong>: Users may see hours-old content without knowing, violating content freshness expectations.</li>\n<li><strong>Fix</strong>: Implement maximum staleness window (e.g., 1 hour) and add <code>X-CDN-Stale: true</code> header to responses.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Cache Poisoning via Malformed Headers</strong></p>\n<ul>\n<li><strong>Description</strong>: Accepting malformed <code>Cache-Control</code> headers without validation leads to incorrect caching decisions.</li>\n<li><strong>Why it&#39;s wrong</strong>: <code>max-age=999999999</code> (overflow) could cache content for decades; <code>no-cache=</code> (missing value) might be misinterpreted.</li>\n<li><strong>Fix</strong>: Validate directive values: clamp <code>max-age</code>/<code>s-maxage</code> to reasonable maximum (e.g., 1 year), treat malformed directives as <code>max-age=0</code>.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Range Request Cache Fragmentation</strong></p>\n<ul>\n<li><strong>Description</strong>: Storing each requested range as separate cache entry wastes memory and causes redundancy.</li>\n<li><strong>Why it&#39;s wrong</strong>: Requests for <code>bytes=0-999</code> and <code>bytes=1000-1999</code> of same file create two cache entries storing overlapping data.</li>\n<li><strong>Fix</strong>: Prefer caching full entities; for partial-only origins, implement range metadata tracking and combine overlapping ranges.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Thundering Herd on Health Check Failover</strong></p>\n<ul>\n<li><strong>Description</strong>: When an edge node fails, all clients simultaneously reconnect to the next-nearest node, overwhelming it.</li>\n<li><strong>Why it&#39;s wrong</strong>: The backup node experiences sudden load spike, potentially causing cascade failure.</li>\n<li><strong>Fix</strong>: Implement staggered failover using DNS TTLs, client-side randomization, or anycast with BGP dampening.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Clock Skew in Expiration</strong></p>\n<ul>\n<li><strong>Description</strong>: Using local system time for TTL calculations without considering time synchronization.</li>\n<li><strong>Why it&#39;s wrong</strong>: Nodes with skewed clocks expire content at different times, causing inconsistency.</li>\n<li><strong>Fix</strong>: Use NTP-synchronized clocks; for critical timing, use relative durations from receipt time rather than absolute expiry.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Circuit Breaker</td>\n<td>Manual failure counting with timeout</td>\n<td><code>aiocircuitbreaker</code> library with multiple strategies</td>\n</tr>\n<tr>\n<td>Health Checking</td>\n<td>Periodic HTTP GET to <code>/health</code> endpoint</td>\n<td>Active health checks + passive monitoring + weighted scoring</td>\n</tr>\n<tr>\n<td>Range Request Handling</td>\n<td>Simple byte range slicing of cached bodies</td>\n<td>Multipart range support with <code>boundary</code> parsing</td>\n</tr>\n<tr>\n<td>Stale Content Serving</td>\n<td>Basic <code>stale-if-error</code> with fixed window</td>\n<td>Dynamic staleness based on content type and historical patterns</td>\n</tr>\n<tr>\n<td>Error Monitoring</td>\n<td>Logging to stdout/stderr</td>\n<td>Structured logging with metrics export to Prometheus</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin_cdn/\n├── src/\n│   ├── error_handling/\n│   │   ├── __init__.py\n│   │   ├── circuit_breaker.py          # Circuit breaker implementation\n│   │   ├── degraded_mode.py            # Degraded mode flag and logic\n│   │   ├── stale_content_handler.py    # stale-if-error logic\n│   │   └── health_checker.py           # Health checking utilities\n│   ├── http_edge_cases/\n│   │   ├── __init__.py\n│   │   ├── range_request.py           # Range request handler\n│   │   ├── vary_header.py             # Vary header processor\n│   │   ├── cache_control_parser.py    # Robust Cache-Control parser\n│   │   └── etag_handler.py            # ETag weak/strong validation\n│   └── failure_recovery/\n│       ├── __init__.py\n│       ├── failover_manager.py        # Geo-routing failover logic\n│       ├── request_queuing.py         # Request queue for cold starts\n│       └── partition_handler.py       # Network partition detection\n└── tests/\n    ├── test_error_handling.py\n    ├── test_http_edge_cases.py\n    └── test_failure_recovery.py</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-circuit-breaker-implementation\">Infrastructure Starter Code: Circuit Breaker Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Circuit breaker pattern implementation for upstream connections.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Callable, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLOSED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"closed\"</span><span style=\"color:#6A737D\">      # Normal operation: requests pass through</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    OPEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"open\"</span><span style=\"color:#6A737D\">          # Circuit open: requests fail fast</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HALF_OPEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"half_open\"</span><span style=\"color:#6A737D\">  # Testing if service has recovered</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitBreakerConfig</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failure_threshold: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#6A737D\">           # Failures needed to open circuit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reset_timeout: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30.0</span><span style=\"color:#6A737D\">          # Time in seconds before attempting recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    half_open_max_requests: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">      # Max requests allowed in half-open state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    half_open_success_threshold: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\"> # Successes needed to close circuit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_failure_history: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#6A737D\">       # Max failures to track for statistics</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitBreaker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Circuit breaker for upstream service calls.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, config: Optional[CircuitBreakerConfig] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> CircuitBreakerConfig()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">CLOSED</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.last_failure_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Lock()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(self, func: Callable, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute function with circuit breaker protection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check if circuit is open</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Check if reset timeout has elapsed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.config.reset_timeout):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">HALF_OPEN</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#E1E4E8\"> CircuitOpenError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Circuit '</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' is OPEN\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Execute the function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._record_success()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._record_failure()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _record_success</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record a successful execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">HALF_OPEN</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.success_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.success_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.config.half_open_success_threshold:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">CLOSED</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # In CLOSED state, reset failure count on consecutive successes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _record_failure</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record a failed execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._lock:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.last_failure_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">HALF_OPEN</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Failure in half-open state: re-open circuit</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">OPEN</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.success_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">CLOSED</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                  self</span><span style=\"color:#E1E4E8\">.failure_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.config.failure_threshold):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Too many failures in closed state: open circuit</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">OPEN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_status</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return current circuit status for monitoring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"name\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"state\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.state.value,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"failure_count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.failure_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"success_count\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.success_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"last_failure_time\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.last_failure_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"is_open\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> CircuitState.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CircuitOpenError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when circuit breaker is open and request is rejected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-range-request-handler\">Core Logic Skeleton: Range Request Handler</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">HTTP range request handler for CDN edge cache.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Tuple, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ByteRange</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a byte range request.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    end: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># None means \"to end of resource\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">property</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> length</span><span style=\"color:#E1E4E8\">(self) -> Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate length of range if end is specified.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> within</span><span style=\"color:#E1E4E8\">(self, content_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if range is within content bounds.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> content_length:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> content_length:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RangeRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles HTTP Range and If-Range headers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Regex for bytes range specifier: bytes=start-end</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BYTES_RANGE_RE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#DBEDFF\">bytes=</span><span style=\"color:#79B8FF\">(\\d</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#79B8FF\">(\\d</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache_storage):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache_storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_range_header</span><span style=\"color:#E1E4E8\">(self, range_header: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          content_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[ByteRange]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse Range header value into list of ByteRange objects.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            range_header: Value of Range header (e.g., \"bytes=0-499\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            content_length: Total length of the resource in bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of valid ByteRange objects</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ranges </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle single range: bytes=start-end</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        match </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">BYTES_RANGE_RE</span><span style=\"color:#E1E4E8\">.match(range_header)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> match:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start_str, end_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> match.groups()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(start_str)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(end_str) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> end_str </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Validate range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> start:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Invalid range: end before start</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Adjust \"to end of resource\" syntax</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # bytes=start- means from start to end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> content_length:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    ranges.append(ByteRange(start, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # bytes=start-end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> start </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> content_length </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> end </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> content_length:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    ranges.append(ByteRange(start, end))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Support multiple ranges: bytes=0-499,1000-1499</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Support suffix ranges: bytes=-500 (last 500 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ranges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_range_request</span><span style=\"color:#E1E4E8\">(self, request_headers: </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 request_body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handle HTTP request with Range header.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_headers: Client request headers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            request_body: Client request body</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            cache_key: Cache key for this resource</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (status_code, headers, body)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        range_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_headers.get(</span><span style=\"color:#9ECBFF\">'range'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        if_range_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_headers.get(</span><span style=\"color:#9ECBFF\">'if-range'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check cache for full entity using cache_key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If full entity cached and fresh:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Parse range_header to get requested byte ranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Extract ranges from cached body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If single range: return 206 with Content-Range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If multiple ranges: return 206 with multipart/byteranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If full entity cached but stale, check If-Range header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If If-Range ETag/date matches: serve range from stale content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Otherwise: revalidate with origin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If cache miss or partial entity only:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Forward request to upstream with Range header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - On 206 response: cache if possible (prefer full entity)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - On 200 response: cache full entity, extract range for response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle edge cases:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Range not satisfiable (416)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - Malformed Range header (ignore, serve full response)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - If-Range with weak validator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Placeholder return (implementer should replace)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">, {}, </span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extract_range_from_body</span><span style=\"color:#E1E4E8\">(self, body: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               byte_range: ByteRange) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Extract byte range from full response body.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            body: Complete response body</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            byte_range: ByteRange specification</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Extracted byte range</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that body length >= byte_range.start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If byte_range.end is None, extract from start to end</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If byte_range.end specified, extract start to end (inclusive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return extracted bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"\"</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><p><strong>Python&#39;s <code>http.client</code> vs <code>aiohttp</code></strong>: For range requests, <code>aiohttp</code> automatically handles <code>Range</code> headers in responses but not in requests. Use manual <code>Range</code> header setting with <code>aiohttp.ClientSession.get(headers={&#39;Range&#39;: &#39;bytes=0-499&#39;})</code>.</p>\n</li>\n<li><p><strong>Memory Management for Large Files</strong>: When handling range requests for large files, avoid loading entire files into memory. Use Python&#39;s <code>memoryview</code> or <code>io.BytesIO</code> with slicing for efficient partial access.</p>\n</li>\n<li><p><strong>Exception Hierarchy</strong>: Create a custom exception hierarchy for CDN-specific errors:</p>\n</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">  class</span><span style=\"color:#B392F0\"> CDNError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">): </span><span style=\"color:#F97583\">pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  class</span><span style=\"color:#B392F0\"> OriginError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">CDNError</span><span style=\"color:#E1E4E8\">): </span><span style=\"color:#F97583\">pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  class</span><span style=\"color:#B392F0\"> CacheError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">CDNError</span><span style=\"color:#E1E4E8\">): </span><span style=\"color:#F97583\">pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  class</span><span style=\"color:#B392F0\"> ConfigurationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">CDNError</span><span style=\"color:#E1E4E8\">): </span><span style=\"color:#F97583\">pass</span></span></code></pre></div>\n\n<ul>\n<li><p><strong>Structured Logging</strong>: Use Python&#39;s <code>structlog</code> or <code>logging.config.dictConfig</code> to create structured logs that include request IDs, cache keys, and failure modes for easier debugging.</p>\n</li>\n<li><p><strong>Testing Network Failures</strong>: Use <code>unittest.mock.patch</code> to simulate network timeouts and failures: <code>@patch(&#39;aiohttp.ClientSession.get&#39;, side_effect=asyncio.TimeoutError())</code>.</p>\n</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Clients receive 502 errors during origin maintenance</td>\n<td>Circuit breaker stuck in OPEN state</td>\n<td>Check circuit breaker status endpoint; monitor failure count</td>\n<td>Implement manual circuit reset API; adjust failure threshold</td>\n</tr>\n<tr>\n<td>Range requests return full content instead of partial</td>\n<td>Range header parsing failure</td>\n<td>Log parsed range values; check for malformed Range headers</td>\n<td>Improve Range header parser; handle edge cases like bytes=0-</td>\n</tr>\n<tr>\n<td><code>Vary: *</code> responses are being cached</td>\n<td>Missing check for <code>Vary: *</code></td>\n<td>Add debug logging when <code>Vary</code> header is processed</td>\n<td>Implement explicit check for <code>Vary: *</code> before caching</td>\n</tr>\n<tr>\n<td>Stale content served indefinitely after origin recovery</td>\n<td><code>stale-if-error</code> logic doesn&#39;t reset on origin recovery</td>\n<td>Monitor origin health separately from circuit breaker</td>\n<td>Reset stale serving when origin returns to healthy state</td>\n</tr>\n<tr>\n<td>Different edge nodes serve different versions of same content</td>\n<td>Clock skew causing different expiration times</td>\n<td>Compare <code>fetched_at</code> and <code>expires_at</code> across nodes</td>\n<td>Implement NTP synchronization; use monotonic clocks for relative TTLs</td>\n</tr>\n<tr>\n<td>Thundering herd on new edge node</td>\n<td>Failover directs all clients simultaneously</td>\n<td>Monitor request rate spike after failover</td>\n<td>Implement staggered client redirection using DNS TTL randomization</td>\n</tr>\n<tr>\n<td>Memory exhaustion during video streaming</td>\n<td>Large range requests cached in full</td>\n<td>Monitor cache entry sizes; check for partial vs full caching</td>\n<td>Implement size-based cache admission policy; stream without caching large files</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1 through 5)</p>\n</blockquote>\n<p>Building a Content Delivery Network is a complex distributed systems undertaking. Without a rigorous testing strategy, subtle bugs in cache semantics, race conditions during invalidation, or thundering herd scenarios could undermine the entire system. This section provides a comprehensive blueprint for verifying the CDN works correctly across all five milestones. We&#39;ll establish a <strong>multi-layered testing pyramid</strong> that combines unit tests for algorithmic correctness, property-based tests for cache behavior invariants, integration tests for multi-component interactions, and load tests for performance validation. Additionally, we provide concrete <strong>milestone checkpoints</strong>—specific commands to run and expected outputs—that let you verify each milestone&#39;s acceptance criteria before moving forward.</p>\n<p>Think of testing a CDN as <strong>calibrating a network of smart thermostats</strong>. Each thermostat (edge node) must independently make correct decisions about when to heat (fetch from origin) and when to rely on stored warmth (serve from cache). However, they must also coordinate when the building manager sends a system-wide temperature change (invalidation). Our testing strategy ensures each thermostat&#39;s local logic is flawless and that their collective behavior remains consistent even during network partitions or command storms.</p>\n<h3 id=\"testing-approaches-amp-properties\">Testing Approaches &amp; Properties</h3>\n<p>A robust CDN testing strategy employs four complementary approaches, each targeting different aspects of the system:</p>\n<table>\n<thead>\n<tr>\n<th><strong>Test Type</strong></th>\n<th><strong>Primary Focus</strong></th>\n<th><strong>Key Properties Verified</strong></th>\n<th><strong>Tools/Techniques</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unit Tests</strong></td>\n<td>Individual functions and classes in isolation</td>\n<td>- Cache key generation correctness<br>- TTL calculation accuracy<br>- Header parsing edge cases<br>- Data structure operations</td>\n<td><code>pytest</code>, <code>unittest</code>, mock objects</td>\n</tr>\n<tr>\n<td><strong>Property-Based Tests</strong></td>\n<td>System invariants under random inputs</td>\n<td>- Cache never serves stale fresh content<br>- Invalidation eventually removes banned content<br>- No race conditions in request collapsing<br>- Consistent hashing distribution properties</td>\n<td><code>hypothesis</code>, randomized test generators</td>\n</tr>\n<tr>\n<td><strong>Integration Tests</strong></td>\n<td>Multi-component interactions</td>\n<td>- Edge → Shield → Origin request flow<br>- Invalidation propagation across nodes<br>- Geo-routing and failover behavior<br>- Analytics aggregation</td>\n<td>Docker containers, test HTTP clients, simulated network partitions</td>\n</tr>\n<tr>\n<td><strong>Load &amp; Performance Tests</strong></td>\n<td>System behavior under production-like load</td>\n<td>- Origin protection during cache miss storms<br>- Memory usage under cache pressure<br>- Request collapsing efficiency<br>- Latency percentiles</td>\n<td><code>locust</code>, <code>k6</code>, custom load generators, monitoring dashboards</td>\n</tr>\n</tbody></table>\n<h4 id=\"mental-model-the-four-layer-inspection-protocol\">Mental Model: The Four-Layer Inspection Protocol</h4>\n<p>Imagine inspecting a chain of grocery stores (our CDN). <strong>Unit tests</strong> are like checking each cash register&#39;s calculation logic in isolation. <strong>Property-based tests</strong> verify that no matter what combination of items a customer buys (random inputs), the store never charges tax on exempt items (invariants). <strong>Integration tests</strong> simulate the full supply chain—delivery trucks arriving from warehouses (origin) to distribution centers (shield) to stores (edge)—ensuring produce stays fresh through the entire journey. <strong>Load tests</strong> are the Black Friday simulation: we flood the stores with thousands of customers to ensure neither the cash registers nor the stockrooms collapse under pressure.</p>\n<h4 id=\"property-based-testing-for-cache-correctness\">Property-Based Testing for Cache Correctness</h4>\n<p>The most subtle bugs in caching systems involve edge cases in the HTTP caching specification. Property-based testing generates thousands of random but valid HTTP headers and verifies our implementation always respects RFC 9111 semantics. Key properties to test include:</p>\n<ol>\n<li><strong>Freshness Invariant</strong>: If a cache entry is fresh (current time &lt; <code>expires_at</code>), serving it must produce the same semantic result as fetching from origin (excluding explicit <code>no-cache</code> directives).</li>\n<li><strong>Staleness Propagation</strong>: Once a cache entry becomes stale, the next request must trigger revalidation (unless <code>stale-while-revalidate</code> is in effect).</li>\n<li><strong>Invalidation Completeness</strong>: After a hard purge of a URL, the next request must result in a cache miss.</li>\n<li><strong>Vary Header Consistency</strong>: Two requests with different <code>Vary</code> header values must never return the wrong cached variant.</li>\n<li><strong>Request Collapsing Idempotence</strong>: N identical concurrent requests must produce exactly one origin fetch.</li>\n</ol>\n<p>We express these properties as test functions that use <code>hypothesis</code> to generate random cache-control headers, status codes, and request patterns:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example property test structure (shown here for illustration, not in main body)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@given</span><span style=\"color:#E1E4E8\">(random_cache_control(), random_status_code(), random_headers())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_fresh_content_never_triggers_origin_fetch</span><span style=\"color:#E1E4E8\">(cache_control, status_code, headers):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hypothesis generates thousands of combinations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Test that when content is fresh, edge cache serves it without upstream call</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"integration-testing-strategy\">Integration Testing Strategy</h4>\n<p>Integration tests verify that the CDN&#39;s distributed components work together correctly. Since we&#39;re building an educational project, we&#39;ll use lightweight containerization (Docker Compose) to spin up a mini-CDN with 2 edge nodes, 1 shield, and 1 origin server for testing.</p>\n<p><strong>Test Scenarios to Cover:</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>Scenario</strong></th>\n<th><strong>Components Involved</strong></th>\n<th><strong>What to Verify</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache miss cascade</td>\n<td>Client → Edge → Shield → Origin</td>\n<td>- Request collapsing at shield works<br>- Response flows back correctly<br>- Cache populated at both edge and shield</td>\n</tr>\n<tr>\n<td>Geo-routing decision</td>\n<td>Client resolver → Multiple edges</td>\n<td>- Client directed to nearest healthy edge<br>- Consistent hashing distributes load</td>\n</tr>\n<tr>\n<td>Invalidation storm</td>\n<td>Admin API → Control plane → All edges</td>\n<td>- Purge commands propagate within time window<br>- No stale content served after propagation</td>\n</tr>\n<tr>\n<td>Shield failure</td>\n<td>Edge → Fallback to origin</td>\n<td>- Circuit breaker opens after threshold<br>- Requests bypass shield when unhealthy</td>\n</tr>\n<tr>\n<td>Request with <code>Range</code> header</td>\n<td>Client → Edge (with cached content)</td>\n<td>- Partial content correctly served<br>- 206 status code returned</td>\n</tr>\n</tbody></table>\n<h4 id=\"load-testing-for-origin-protection\">Load Testing for Origin Protection</h4>\n<p>The primary value of a CDN is protecting the origin during traffic spikes. Load tests verify this protection actually works. We&#39;ll simulate:</p>\n<ol>\n<li><strong>Cache Miss Storm</strong>: 1000 concurrent requests for an uncached resource with 1-second TTL.</li>\n<li><strong>Popular Content Refresh</strong>: 500 requests/second for a resource that expires simultaneously across all edges.</li>\n<li><strong>Invalidation Cascade</strong>: Purge a heavily cached resource while it&#39;s receiving 200 req/s.</li>\n</ol>\n<p>Success criteria:</p>\n<ul>\n<li>Origin request rate stays below configured limit (e.g., 10 req/s during miss storm)</li>\n<li>No client requests time out (all served within 2 seconds)</li>\n<li>Memory usage remains bounded (no leaks during cache churn)</li>\n</ul>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone has specific acceptance criteria. These checkpoints provide concrete commands to run and outputs to verify, serving as <strong>quality gates</strong> before proceeding to the next milestone.</p>\n<h4 id=\"milestone-1-edge-cache-implementation\">Milestone 1: Edge Cache Implementation</h4>\n<p><strong>Verification Goal</strong>: Ensure the edge cache correctly stores, retrieves, and validates HTTP responses according to RFC 9111.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Test</strong></th>\n<th><strong>Command to Run</strong></th>\n<th><strong>Expected Output/Behavior</strong></th>\n<th><strong>What Could Go Wrong</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic cache hit</td>\n<td><code>pytest tests/test_edge_cache.py::test_cache_hit -v</code></td>\n<td>Test passes: shows cache served response without origin fetch</td>\n<td>Cache key mismatch or TTL calculation error</td>\n</tr>\n<tr>\n<td>Cache miss with origin fetch</td>\n<td><code>pytest tests/test_edge_cache.py::test_cache_miss -v</code></td>\n<td>Test passes: shows cache fetched from origin and stored</td>\n<td>Upstream connection failure or response parsing error</td>\n</tr>\n<tr>\n<td>Cache key with Vary headers</td>\n<td><code>pytest tests/test_edge_cache.py::test_vary_header_caching -v</code></td>\n<td>Test passes: different <code>Accept-Encoding</code> values create separate cache entries</td>\n<td>Vary header parsing incomplete or cache key collision</td>\n</tr>\n<tr>\n<td>Conditional request (304)</td>\n<td><code>pytest tests/test_edge_cache.py::test_conditional_request -v</code></td>\n<td>Test passes: <code>If-None-Match</code> with valid ETag returns 304, saves bandwidth</td>\n<td>ETag comparison logic flawed or headers not passed upstream</td>\n</tr>\n<tr>\n<td>LRU eviction under pressure</td>\n<td><code>python -m tests.capacity_test --requests 1000 --capacity 100</code></td>\n<td>Memory usage stabilizes, oldest entries evicted, hit ratio reasonable</td>\n<td>Memory leak or eviction algorithm not triggered</td>\n</tr>\n<tr>\n<td>Cache-Control directive parsing</td>\n<td><code>pytest tests/test_directives.py -v</code></td>\n<td>All 15+ directives parsed correctly, precedence rules followed</td>\n<td><code>s-maxage</code> ignored in favor of <code>max-age</code>, <code>no-cache</code> misinterpreted</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Start a test origin server: <code>python tests/origin_server.py</code></li>\n<li>Start the edge cache: <code>python edge_server.py --config configs/edge_test.yaml</code></li>\n<li>Make first request: <code>curl -v http://localhost:8080/image.jpg</code><ul>\n<li>Should show <code>X-Cache: MISS</code> header</li>\n</ul>\n</li>\n<li>Make identical second request:<ul>\n<li>Should show <code>X-Cache: HIT</code> header</li>\n<li>Response identical to first</li>\n</ul>\n</li>\n<li>Request with <code>Accept-Encoding: gzip</code>:<ul>\n<li>Should create separate cache entry (check logs)</li>\n</ul>\n</li>\n<li>Wait for TTL expiration, request again:<ul>\n<li>Should trigger revalidation or fresh fetch</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"milestone-2-cache-invalidation\">Milestone 2: Cache Invalidation</h4>\n<p><strong>Verification Goal</strong>: Ensure purge, ban, and tag-based invalidation work correctly and propagate to all nodes.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Test</strong></th>\n<th><strong>Command to Run</strong></th>\n<th><strong>Expected Output/Behavior</strong></th>\n<th><strong>What Could Go Wrong</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hard purge by URL</td>\n<td><code>pytest tests/test_invalidation.py::test_hard_purge -v</code></td>\n<td>Cache entry removed, next request misses</td>\n<td>Entry not fully removed or ghost data remains</td>\n</tr>\n<tr>\n<td>Soft purge with revalidation</td>\n<td><code>pytest tests/test_invalidation.py::test_soft_purge -v</code></td>\n<td>Entry marked stale, served while background fetch updates</td>\n<td>Background thread not started or stale content not served</td>\n</tr>\n<tr>\n<td>Surrogate key purge</td>\n<td><code>pytest tests/test_invalidation.py::test_tag_purge -v</code></td>\n<td>All entries with tag removed, others remain</td>\n<td>Tag index corruption or incomplete cleanup</td>\n</tr>\n<tr>\n<td>Ban rule pattern matching</td>\n<td><code>pytest tests/test_invalidation.py::test_ban_rules -v</code></td>\n<td>URLs matching pattern invalidated on access</td>\n<td>Regex compilation errors or matching logic flawed</td>\n</tr>\n<tr>\n<td>Invalidation propagation</td>\n<td><code>python -m tests.propagation_test --nodes 3</code></td>\n<td>All nodes receive purge within 500ms</td>\n<td>Pub/sub message loss or network partition not handled</td>\n</tr>\n<tr>\n<td>Ban rule GC</td>\n<td><code>pytest tests/test_invalidation.py::test_ban_garbage_collection -v</code></td>\n<td>Expired ban rules automatically removed</td>\n<td>Memory leak from unbounded ban list</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Start 3 edge nodes in separate terminals with shared control plane</li>\n<li>Cache content on all nodes by making requests to each</li>\n<li>Execute purge via admin API:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> PURGE</span><span style=\"color:#9ECBFF\"> http://edge1:8080/image.jpg</span></span></code></pre></div>\n<ol start=\"4\">\n<li>Verify all nodes show purge in logs</li>\n<li>Request same URL on each node:<ul>\n<li>All should show <code>X-Cache: MISS</code></li>\n</ul>\n</li>\n<li>Test surrogate key purge:<ul>\n<li>Request with <code>Surrogate-Key: product-123</code></li>\n<li>Purge by tag: <code>curl -X PURGE -H &quot;Surrogate-Key: product-123&quot; http://edge1:8080/purge-by-tag</code></li>\n<li>Verify all tagged content purged across nodes</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"milestone-3-origin-shield-amp-request-collapsing\">Milestone 3: Origin Shield &amp; Request Collapsing</h4>\n<p><strong>Verification Goal</strong>: Ensure shield reduces origin load through request collapsing and protects against thundering herds.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Test</strong></th>\n<th><strong>Command to Run</strong></th>\n<th><strong>Expected Output/Behavior</strong></th>\n<th><strong>What Could Go Wrong</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Request collapsing</td>\n<td><code>pytest tests/test_shield.py::test_request_collapsing -v</code></td>\n<td>100 concurrent requests → 1 origin fetch</td>\n<td>Race condition in coalescing map or timeout too short</td>\n</tr>\n<tr>\n<td>Negative caching</td>\n<td><code>pytest tests/test_shield.py::test_negative_caching -v</code></td>\n<td>Origin 404s cached briefly, not repeatedly fetched</td>\n<td>Negative cache TTL not honored or error responses cached incorrectly</td>\n</tr>\n<tr>\n<td>Shield circuit breaker</td>\n<td><code>pytest tests/test_shield.py::test_circuit_breaker -v</code></td>\n<td>After origin failures, shield bypasses to origin</td>\n<td>Circuit state transitions incorrectly or health checks flawed</td>\n</tr>\n<tr>\n<td>Queue overflow protection</td>\n<td><code>python -m tests.shield_load_test --concurrent 1000</code></td>\n<td>Queue limits respected, excess requests get 503</td>\n<td>Unlimited queue growth causes memory exhaustion</td>\n</tr>\n<tr>\n<td>Stale-while-revalidate at shield</td>\n<td><code>pytest tests/test_shield.py::test_shield_stale_while_revalidate -v</code></td>\n<td>Shield serves stale while revalidating in background</td>\n<td>Background revalidation not triggered or stale content blocked</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Start origin, shield, and single edge node</li>\n<li>Use <code>ab</code> or <code>wrk</code> to send 100 concurrent requests for uncached resource:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   wrk</span><span style=\"color:#79B8FF\"> -t10</span><span style=\"color:#79B8FF\"> -c100</span><span style=\"color:#79B8FF\"> -d5s</span><span style=\"color:#9ECBFF\"> http://edge:8080/uncached.html</span></span></code></pre></div>\n<ol start=\"3\">\n<li>Check shield logs: should show exactly 1 origin request</li>\n<li>Check origin logs: should show 1 request, not 100</li>\n<li>Cause origin failure (kill origin server)</li>\n<li>Make several requests:<ul>\n<li>First few might fail through</li>\n<li>Circuit should open after threshold</li>\n<li>Subsequent requests should bypass shield (check headers)</li>\n</ul>\n</li>\n<li>Restart origin, verify circuit half-open then closed</li>\n</ol>\n<h4 id=\"milestone-4-edge-node-distribution-amp-routing\">Milestone 4: Edge Node Distribution &amp; Routing</h4>\n<p><strong>Verification Goal</strong>: Ensure clients route to nearest edge, consistent hashing distributes load, and failover works.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Test</strong></th>\n<th><strong>Command to Run</strong></th>\n<th><strong>Expected Output/Behavior</strong></th>\n<th><strong>What Could Go Wrong</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GeoIP routing</td>\n<td><code>pytest tests/test_routing.py::test_geoip_routing -v</code></td>\n<td>US IP routes to US edge, EU IP to EU edge</td>\n<td>GeoIP database missing or incorrect mapping</td>\n</tr>\n<tr>\n<td>Consistent hashing distribution</td>\n<td><code>python -m tests.distribution_test --keys 10000 --nodes 5</code></td>\n<td>Keys distributed evenly (within 20% variance)</td>\n<td>Hash function skew or virtual nodes not balanced</td>\n</tr>\n<tr>\n<td>Node failure and redistribution</td>\n<td><code>pytest tests/test_routing.py::test_node_failure -v</code></td>\n<td>Keys remapped minimally (&lt; 30% movement on node loss)</td>\n<td>Hash ring update incorrect or health check false positive</td>\n</tr>\n<tr>\n<td>Health check integration</td>\n<td><code>pytest tests/test_health.py -v</code></td>\n<td>Unhealthy nodes removed from rotation, marked degraded</td>\n<td>Health check too aggressive or recovery not detected</td>\n</tr>\n<tr>\n<td>Failover latency</td>\n<td><code>python -m tests.failover_test --kill-node edge-us-1</code></td>\n<td>Traffic redirects to next-nearest within 5 seconds</td>\n<td>DNS TTL too long or health propagation delayed</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Deploy 3 edge nodes in different regions (simulate with different ports)</li>\n<li>Start GeoDNS resolver or HTTP redirector</li>\n<li>From simulated US client (<code>curl -H &quot;X-Client-IP: 8.8.8.8&quot;</code>):<ul>\n<li>Should reach US edge node (check logs)</li>\n</ul>\n</li>\n<li>From simulated EU client (<code>curl -H &quot;X-Client-IP: 1.1.1.1&quot;</code>):<ul>\n<li>Should reach EU edge node</li>\n</ul>\n</li>\n<li>Kill US edge node process</li>\n<li>Health check should detect within 2 seconds</li>\n<li>Subsequent US client requests should route to next closest (EU or ASIA)</li>\n<li>Verify consistent hashing: cache specific key on node A, kill node A, bring up replacement node A&#39;, request same key - should route to different node initially, then re-cache on A&#39;</li>\n</ol>\n<h4 id=\"milestone-5-cdn-analytics-amp-performance-optimization\">Milestone 5: CDN Analytics &amp; Performance Optimization</h4>\n<p><strong>Verification Goal</strong>: Ensure analytics track performance accurately and optimizations (compression, range requests) work.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Test</strong></th>\n<th><strong>Command to Run</strong></th>\n<th><strong>Expected Output/Behavior</strong></th>\n<th><strong>What Could Go Wrong</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache hit ratio tracking</td>\n<td><code>pytest tests/test_analytics.py::test_hit_ratio -v</code></td>\n<td>After mixed hits/misses, ratio calculated correctly</td>\n<td>Race conditions in counter updates or reset logic flawed</td>\n</tr>\n<tr>\n<td>Compression negotiation</td>\n<td><code>pytest tests/test_compression.py -v</code></td>\n<td><code>Accept-Encoding: gzip</code> returns compressed, others uncompressed</td>\n<td>Compression applied to already binary content or CPU spike</td>\n</tr>\n<tr>\n<td>Range request support</td>\n<td><code>pytest tests/test_range_requests.py -v</code></td>\n<td><code>Range: bytes=0-499</code> returns 206 with correct content</td>\n<td>Byte range math errors or multi-range not handled</td>\n</tr>\n<tr>\n<td>Bandwidth accounting</td>\n<td><code>python -m tests.bandwidth_test --duration 30</code></td>\n<td>Analytics show correct bytes served, matches actual transfer</td>\n<td>Counting omitted for cached responses or compression size not considered</td>\n</tr>\n<tr>\n<td>Stale-while-revalidate behavior</td>\n<td><code>pytest tests/test_stale_optimizations.py -v</code></td>\n<td>Stale content served while async revalidation occurs</td>\n<td>Client receives stale content indefinitely if revalidation fails</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Enable analytics dashboard: <code>python analytics_dashboard.py</code></li>\n<li>Generate mixed traffic pattern:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#9ECBFF\"> tests/traffic_generator.py</span><span style=\"color:#79B8FF\"> --pattern</span><span style=\"color:#9ECBFF\"> mixed</span><span style=\"color:#79B8FF\"> --duration</span><span style=\"color:#79B8FF\"> 60</span></span></code></pre></div>\n<ol start=\"3\">\n<li>Check dashboard:<ul>\n<li>Hit ratio should converge to expected value</li>\n<li>Bandwidth should show savings from cache hits</li>\n</ul>\n</li>\n<li>Test compression:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"Accept-Encoding: gzip\"</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://edge:8080/large.json</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"Content-Encoding\"</span></span></code></pre></div>\n<ul>\n<li>Should show <code>gzip</code> and reduced size</li>\n</ul>\n<ol start=\"5\">\n<li>Test range request:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -H</span><span style=\"color:#9ECBFF\"> \"Range: bytes=1000-1999\"</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://edge:8080/large_video.mp4</span></span></code></pre></div>\n<ul>\n<li>Should return 206 Partial Content</li>\n<li>Should serve from cache if already cached</li>\n</ul>\n<ol start=\"6\">\n<li>Verify stale-while-revalidate:<ul>\n<li>Request resource, wait for it to go stale</li>\n<li>Make concurrent requests: should serve stale while one revalidates</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>Component</strong></th>\n<th><strong>Simple Option</strong></th>\n<th><strong>Advanced Option</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td><code>pytest</code> with <code>pytest-asyncio</code></td>\n<td><code>pytest</code> with custom fixtures and plugins</td>\n</tr>\n<tr>\n<td>Property Testing</td>\n<td><code>hypothesis</code> for random test generation</td>\n<td>Custom fuzzers with corpus from real traffic</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td><code>docker-compose</code> with test containers</td>\n<td>Kubernetes Kind cluster for realistic orchestration</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td><code>locust</code> for Python-based load scenarios</td>\n<td><code>k6</code> for JavaScript-based performance tests</td>\n</tr>\n<tr>\n<td>Mock HTTP Servers</td>\n<td><code>aiohttp</code> test server or <code>responses</code> library</td>\n<td>Custom TCP server simulating origin behaviors</td>\n</tr>\n</tbody></table>\n</blockquote>\n<p><strong>Recommended Test Directory Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue-origin-cdn/\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py                    # Shared pytest fixtures\n│   ├── unit/\n│   │   ├── test_edge_cache.py        # Milestone 1\n│   │   ├── test_directives.py        # Cache-Control parsing\n│   │   ├── test_invalidation.py      # Milestone 2\n│   │   ├── test_shield.py            # Milestone 3\n│   │   ├── test_routing.py           # Milestone 4\n│   │   └── test_analytics.py         # Milestone 5\n│   ├── integration/\n│   │   ├── test_multi_node.py        # Multi-edge scenarios\n│   │   ├── test_propagation.py       # Invalidation across nodes\n│   │   └── test_full_stack.py        # End-to-end flows\n│   ├── property/\n│   │   ├── test_cache_properties.py  # Hypothesis-based invariants\n│   │   └── test_hashing_properties.py\n│   ├── load/\n│   │   ├── miss_storm.py             # Cache miss load test\n│   │   └── invalidation_storm.py     # Purge load test\n│   ├── fixtures/\n│   │   ├── origin_server.py          # Test origin implementation\n│   │   └── geoip_test_db.mmdb        # Test GeoIP database\n│   └── utils/\n│       ├── test_client.py            # Async HTTP test client\n│       └── assertions.py             # Custom assertions\n├── docker-compose.test.yml           # Integration test environment\n└── loadtest/\n    ├── locustfile.py                 # Locust load test definition\n    └── k6_script.js                  # k6 load test script</code></pre></div>\n\n<p><strong>Infrastructure Starter Code: Test Origin Server</strong></p>\n<p>Here&#39;s a complete, ready-to-use test origin server that simulates various origin behaviors for testing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/fixtures/origin_server.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> aiohttp </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> web</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> gzip</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> random</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestOriginServer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Configurable test origin server for CDN testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, port: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.request_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.responses: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '/image.jpg'</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'headers'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'image/jpeg'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Cache-Control'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'public, max-age=3600'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'body'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">'fake-jpeg-content-'</span><span style=\"color:#F97583\"> +</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'x'</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'etag'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'\"abc123\"'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'delay'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '/api/data'</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'headers'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Cache-Control'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'no-cache'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'body'</span><span style=\"color:#E1E4E8\">: json.dumps({</span><span style=\"color:#9ECBFF\">'data'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'sensitive'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'version'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">}).encode(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'delay'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.05</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '/large.txt'</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'headers'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'text/plain'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Cache-Control'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'public, max-age=60, stale-while-revalidate=30'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'body'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">'Line '</span><span style=\"color:#F97583\"> +</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">.join([</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'Line </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">.encode() </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)]),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'etag'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'\"large123\"'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'delay'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # 'timeout', '500', 'slow'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#E1E4E8\">(self, request: web.Request) -> web.Response:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle incoming request with configurable behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.request_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        method </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Apply failure modes if active</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'timeout'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Longer than client timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> web.Response(</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">504</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '500'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> web.Response(</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">text</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Internal Server Error'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.failure_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'slow'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Slow but not timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check for conditional requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        if_none_match </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.headers.get(</span><span style=\"color:#9ECBFF\">'If-None-Match'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        if_modified_since </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.headers.get(</span><span style=\"color:#9ECBFF\">'If-Modified-Since'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Find response configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        resp_config </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.responses.get(path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> resp_config:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            resp_config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'headers'</span><span style=\"color:#E1E4E8\">: {</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'text/plain'</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'body'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">'Not Found'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'delay'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Apply delay if specified</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resp_config.get(</span><span style=\"color:#9ECBFF\">'delay'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(resp_config[</span><span style=\"color:#9ECBFF\">'delay'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle conditional requests for resources with ETag</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> if_none_match </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> resp_config.get(</span><span style=\"color:#9ECBFF\">'etag'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> if_none_match </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> resp_config[</span><span style=\"color:#9ECBFF\">'etag'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> web.Response(</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">304</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">resp_config[</span><span style=\"color:#9ECBFF\">'headers'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Build response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> dict</span><span style=\"color:#E1E4E8\">(resp_config[</span><span style=\"color:#9ECBFF\">'headers'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resp_config.get(</span><span style=\"color:#9ECBFF\">'etag'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            headers[</span><span style=\"color:#9ECBFF\">'ETag'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resp_config[</span><span style=\"color:#9ECBFF\">'etag'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle compression if requested</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        accept_encoding </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.headers.get(</span><span style=\"color:#9ECBFF\">'Accept-Encoding'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resp_config[</span><span style=\"color:#9ECBFF\">'body'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> 'gzip'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> accept_encoding </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> headers.get(</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">).startswith(</span><span style=\"color:#9ECBFF\">'text/'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            body </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> gzip.compress(body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            headers[</span><span style=\"color:#9ECBFF\">'Content-Encoding'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'gzip'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            headers[</span><span style=\"color:#9ECBFF\">'Vary'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Accept-Encoding'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle range requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        range_header </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request.headers.get(</span><span style=\"color:#9ECBFF\">'Range'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> range_header </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '/large.txt'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Simple byte range handling for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> range_header.startswith(</span><span style=\"color:#9ECBFF\">'bytes='</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                range_spec </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> range_header[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#9ECBFF\"> '-'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> range_spec:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    start_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> range_spec.split(</span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    start </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(start_end[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> start_end[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    end </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(start_end[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(start_end) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> start_end[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(body) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> body[start:end</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    headers[</span><span style=\"color:#9ECBFF\">'Content-Range'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">'bytes </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">start</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">end</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(body)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    return</span><span style=\"color:#E1E4E8\"> web.Response(</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">206</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">headers, </span><span style=\"color:#FFAB70\">body</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">chunk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> web.Response(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            status</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">resp_config[</span><span style=\"color:#9ECBFF\">'status'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">headers,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            body</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> start</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start the test origin server.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        app </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> web.Application()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        app.router.add_route(</span><span style=\"color:#9ECBFF\">'*'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/</span><span style=\"color:#79B8FF\">{path</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\">.*}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        runner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> web.AppRunner(app)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#E1E4E8\"> runner.setup()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        site </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> web.TCPSite(runner, </span><span style=\"color:#9ECBFF\">'localhost'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.port)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#E1E4E8\"> site.start()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Test origin server running on http://localhost:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.port</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> runner</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_failure_mode</span><span style=\"color:#E1E4E8\">(self, mode: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set failure mode for testing circuit breakers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.failure_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_request_count</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get total requests received.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.request_count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> reset_counter</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Reset request counter.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.request_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Quick test runner</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> '__main__'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TestOriginServer(</span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">9999</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#E1E4E8\"> server.start()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#E1E4E8\"> asyncio.Future()  </span><span style=\"color:#6A737D\"># Run forever</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    asyncio.run(run())</span></span></code></pre></div>\n\n<p><strong>Core Test Skeleton: Property-Based Cache Validation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/property/test_cache_properties.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> hypothesis </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> given, strategies </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> st, settings, assume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> blue_origin.cache.edge_cache </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CacheEntry, CacheDirectives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> blue_origin.cache.validation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> is_response_cacheable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Strategy for generating random cache control headers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">cache_control_strategy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> st.dictionaries(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    keys</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.sampled_from([</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'max-age'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'s-maxage'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'no-cache'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'no-store'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'must-revalidate'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'proxy-revalidate'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'public'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'private'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'stale-while-revalidate'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'stale-if-error'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    values</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.one_of(st.none(), st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">31536000</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@given</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    status_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">599</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    method</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.sampled_from([</span><span style=\"color:#9ECBFF\">'GET'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'POST'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'HEAD'</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    cache_control</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">cache_control_strategy,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    vary_header</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.one_of(st.none(), st.text(</span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@settings</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">max_examples</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">deadline</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_cacheability_property</span><span style=\"color:#E1E4E8\">(status_code, method, cache_control, vary_header):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Property: is_response_cacheable must be consistent with RFC 9111.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Only GET and HEAD responses are potentially cacheable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Status codes 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            414, 501 are cacheable by default (unless headers forbid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: no-store directive makes response uncacheable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: private directive means response cacheable but not by shared caches (CDN)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 5: Vary: * means response is uncacheable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 6: Implement the actual logic from RFC 9111 Section 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 7: Return True/False based on all conditions above</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Run with: pytest tests/property/test_cache_properties.py -v</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # This is a skeleton - hypothesis will generate 1000 random inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Your implementation should deterministically decide cacheability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_response_cacheable(status_code, method, cache_control, vary_header)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add assertions that must ALWAYS hold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> method </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'GET'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'HEAD'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Non-GET/HEAD method </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">method</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> must not be cacheable\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cache_control.get(</span><span style=\"color:#9ECBFF\">'no-store'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"no-store directive must prevent caching\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> vary_header </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '*'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        assert</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Vary: * must prevent caching\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@given</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    fetched_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.floats(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1e9</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    max_age</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.one_of(st.none(), st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">31536000</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    s_maxage</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.one_of(st.none(), st.integers(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">31536000</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    request_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">st.floats(</span><span style=\"color:#FFAB70\">min_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1e9</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_freshness_calculation_property</span><span style=\"color:#E1E4E8\">(fetched_at, max_age, s_maxage, request_time):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Property: Freshness calculation must follow Cache-Control precedence.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: s-maxage takes precedence over max-age for shared caches (CDN)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Calculate expires_at based on fetched_at + relevant TTL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Entry is fresh if request_time &#x3C; expires_at</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Handle None values correctly (no expiration)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 5: Ensure math doesn't overflow or produce negative TTLs</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Run with: pytest tests/property/test_cache_properties.py::test_freshness_calculation_property -v</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    assume(request_time </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> fetched_at)  </span><span style=\"color:#6A737D\"># Request can't be before fetch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create directives object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    directives </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CacheDirectives(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        s_maxage</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s_maxage,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        max_age</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">max_age,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        no_cache</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        no_store</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        must_revalidate</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        proxy_revalidate</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        public</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        private</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stale_while_revalidate</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        stale_if_error</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create cache entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CacheEntry(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        key</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        url</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"/test\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        vary_headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        status_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        body</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        fetched_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">fetched_at,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        expires_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Will be calculated</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        last_used_at</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">fetched_at,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        use_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        surrogate_keys</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        etag</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        last_modified</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate expires_at based on directives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Determine if entry is fresh at request_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add assertions about correctness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Placeholder assertions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#6A737D\">  # Replace with actual property checks</span></span></code></pre></div>\n\n<p><strong>Integration Test Helper: Multi-Node Test Environment</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/integration/conftest.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> aiohttp</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">scope</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"session\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> event_loop</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create event loop for async tests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loop </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.get_event_loop_policy().new_event_loop()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    yield</span><span style=\"color:#E1E4E8\"> loop</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    loop.close()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">scope</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"module\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> test_origin</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Start test origin server.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> tests.fixtures.origin_server </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TestOriginServer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    origin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TestOriginServer(</span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">8888</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runner </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> origin.start()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    yield</span><span style=\"color:#E1E4E8\"> origin</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> runner.cleanup()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">scope</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"module\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> edge_nodes</span><span style=\"color:#E1E4E8\">(test_origin):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Start multiple edge nodes for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Start 3 edge nodes on different ports</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 9000</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> os.environ.copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env[</span><span style=\"color:#9ECBFF\">'EDGE_PORT'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env[</span><span style=\"color:#9ECBFF\">'UPSTREAM_URL'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'http://localhost:8888'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env[</span><span style=\"color:#9ECBFF\">'NODE_ID'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">'edge-</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.Popen(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            [</span><span style=\"color:#9ECBFF\">'python'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-m'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'blue_origin.edge_server'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            env</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">env,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            stdout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            stderr</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">subprocess.</span><span style=\"color:#79B8FF\">PIPE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        processes.append(proc)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodes.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'http://localhost:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">port</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        time.sleep(</span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Stagger startup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Wait for nodes to be ready</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> node_url </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> nodes:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">):  </span><span style=\"color:#6A737D\"># 30 second timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#E1E4E8\"> aiohttp.ClientSession() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#E1E4E8\"> session.get(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node_url</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/health'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                time.sleep(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Edge node </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node_url</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed to start\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    yield</span><span style=\"color:#E1E4E8\"> nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> proc </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> processes:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc.terminate()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        proc.wait(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> http_client</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create HTTP client for tests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#E1E4E8\"> aiohttp.ClientSession() </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> session:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        yield</span><span style=\"color:#E1E4E8\"> session</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint Test Commands</strong></p>\n<p>Add these to your <code>Makefile</code> or test scripts:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code># Makefile test targets\ntest-milestone1:\n\tpytest tests/unit/test_edge_cache.py -v --tb=short\n\tpytest tests/unit/test_directives.py -v\n\tpython -m tests.capacity_test --requests 1000 --capacity 100\n\ntest-milestone2:\n\tpytest tests/unit/test_invalidation.py -v\n\tpython -m tests.propagation_test --nodes 3 --timeout 500\n\ntest-milestone3:\n\tpytest tests/unit/test_shield.py -v\n\tpython -m tests.shield_load_test --concurrent 100 --duration 10\n\ntest-milestone4:\n\tpytest tests/unit/test_routing.py -v\n\tpython -m tests.distribution_test --keys 10000 --nodes 5\n\tpytest tests/unit/test_health.py -v\n\ntest-milestone5:\n\tpytest tests/unit/test_analytics.py -v\n\tpytest tests/unit/test_compression.py -v\n\tpytest tests/unit/test_range_requests.py -v\n\ntest-integration:\n\tpytest tests/integration/ -v --tb=short\n\ntest-property:\n\tpytest tests/property/ -v --hypothesis-show-statistics\n\ntest-all: test-milestone1 test-milestone2 test-milestone3 test-milestone4 test-milestone5 test-integration\n\nload-test:\n\tcd loadtest &amp;&amp; locust -f locustfile.py --host=http://localhost:8080</code></pre></div>\n\n<p><strong>Language-Specific Hints for Python Testing:</strong></p>\n<ol>\n<li><p><strong>Async Testing</strong>: Use <code>pytest-asyncio</code> and mark async tests with <code>@pytest.mark.asyncio</code>. Ensure event loop fixtures are properly scoped.</p>\n</li>\n<li><p><strong>Mocking</strong>: Use <code>unittest.mock</code> to mock external dependencies. For async mocks, use <code>AsyncMock</code>:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> unittest.mock </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> AsyncMock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   upstream_fetch </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AsyncMock(</span><span style=\"color:#FFAB70\">return_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">, {}, </span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">'response'</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Timing-Dependent Tests</strong>: For tests involving timeouts or TTLs, use time mocking:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   from</span><span style=\"color:#E1E4E8\"> unittest.mock </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> patch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   with</span><span style=\"color:#E1E4E8\"> patch(</span><span style=\"color:#9ECBFF\">'time.time'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">return_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       # Test logic with fixed time</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><p><strong>Property-Based Testing with Hypothesis</strong>: Use <code>@given</code> decorators with strategies. Build custom strategies for complex data structures. Use <code>assume()</code> to filter out invalid test cases.</p>\n</li>\n<li><p><strong>Testing Concurrent Behavior</strong>: Use <code>asyncio.gather()</code> to simulate concurrent requests in tests. Add small jitter to avoid synchronized timing.</p>\n</li>\n<li><p><strong>Checking Log Output</strong>: Use <code>caplog</code> fixture to verify log messages:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> test_cache_hit_logs</span><span style=\"color:#E1E4E8\">(caplog):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       with</span><span style=\"color:#E1E4E8\"> caplog.at_level(</span><span style=\"color:#9ECBFF\">'INFO'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           make_request()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">           assert</span><span style=\"color:#9ECBFF\"> 'Cache hit'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> caplog.text</span></span></code></pre></div>\n\n<p><strong>Debugging Tips for Failed Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>Symptom</strong></th>\n<th><strong>Likely Cause</strong></th>\n<th><strong>How to Diagnose</strong></th>\n<th><strong>Fix</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test passes locally but fails in CI</td>\n<td>Timing differences or race conditions</td>\n<td>Add more logging, increase timeouts in CI environment</td>\n<td>Use <code>asyncio.wait_for</code> with reasonable timeouts, mock time in sensitive tests</td>\n</tr>\n<tr>\n<td>Property-based test finds rare failure</td>\n<td>Edge case in cache logic</td>\n<td>Hypothesis shrinks input to minimal failing case</td>\n<td>Examine shrunk input, add special handling for that case</td>\n</tr>\n<tr>\n<td>Integration test flakes randomly</td>\n<td>Network race conditions or cleanup issues</td>\n<td>Add retry logic, check for proper resource cleanup in fixtures</td>\n<td>Ensure proper async cleanup, add unique IDs to requests for tracing</td>\n</tr>\n<tr>\n<td>Load test shows memory growth</td>\n<td>Cache eviction not working or memory leak</td>\n<td>Profile memory during test, check cache size metrics</td>\n<td>Implement proper LRU eviction, close HTTP clients, use weak references</td>\n</tr>\n<tr>\n<td>Tests pass but manual verification fails</td>\n<td>Test mocks too permissive or incomplete</td>\n<td>Run test with real components, compare logs</td>\n<td>Make mocks more strict, test with actual HTTP traffic</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1 through 5)</p>\n</blockquote>\n<p>Building a distributed caching system involves numerous moving parts that can fail in subtle ways. This debugging guide provides a practical manual for diagnosing and fixing the most common issues you&#39;ll encounter while implementing the Blue Origin CDN. Think of debugging a CDN as <strong>being a traffic investigator at a complex highway interchange</strong>—you need to examine multiple layers (network routes, vehicle behavior, traffic signals) to understand why congestion or accidents occur. This guide helps you systematically trace problems through the caching layers, from client requests to origin responses and everything in between.</p>\n<h3 id=\"symptom-cause-fix-table\">Symptom → Cause → Fix Table</h3>\n<p>The following table catalogs common symptoms, their root causes, diagnostic approaches, and solutions. Each row represents a complete debugging workflow for a specific issue you might encounter.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Origin server receives duplicate identical requests</strong> (Thundering herd)</td>\n<td>Missing request collapsing at the origin shield layer, or shield bypassed</td>\n<td>1. Check shield logs for concurrent requests with same cache key<br>2. Verify <code>RequestCoalescingMap</code> is tracking in-flight requests<br>3. Monitor <code>ShieldMetrics.collapsed_requests</code> counter</td>\n<td>Implement proper request deduplication in <code>ShieldRequestHandler.handle_request()</code> using <code>RequestCoalescingMap.get_or_create_future()</code></td>\n</tr>\n<tr>\n<td><strong>Cache hit ratio remains near 0% despite repeated requests</strong></td>\n<td>Cache keys not matching, TTLs set to zero, or responses marked uncacheable</td>\n<td>1. Add debug headers (<code>X-Cache-Key</code>, <code>X-Cache-Status</code>) to responses<br>2. Check <code>is_response_cacheable()</code> logic for false negatives<br>3. Inspect <code>Cache-Control</code> headers from origin</td>\n<td>Ensure cache key generation includes all <code>Vary</code> header dimensions and respects <code>CacheDirectives.public</code> vs <code>private</code></td>\n</tr>\n<tr>\n<td><strong>Purge commands don&#39;t remove content from all edge nodes</strong></td>\n<td>Invalidation propagation delay or failed broadcast</td>\n<td>1. Check <code>InvalidationMessage</code> delivery via pub/sub broker<br>2. Verify all edge nodes subscribe to the same channel<br>3. Monitor control plane logs for delivery failures</td>\n<td>Implement acknowledgment mechanism in pub/sub or switch to more reliable propagation (e.g., control plane polling)</td>\n</tr>\n<tr>\n<td><strong>Clients receive stale content after origin update</strong></td>\n<td>Cache entries not invalidated, TTL too long, or revalidation failing</td>\n<td>1. Check <code>CacheEntry.expires_at</code> vs current time<br>2. Verify purge commands actually delete entries<br>3. Test <code>CacheEntry.is_fresh()</code> logic with edge cases</td>\n<td>Implement proper invalidation propagation and ensure <code>stale-while-revalidate</code> doesn&#39;t serve outdated data indefinitely</td>\n</tr>\n<tr>\n<td><strong>Edge node crashes under high load</strong></td>\n<td>Memory exhaustion from unbounded cache growth or ban rule accumulation</td>\n<td>1. Monitor <code>EdgeMetrics.current_cache_size_bytes</code><br>2. Check <code>BanRule</code> list length and TTLs<br>3. Profile memory usage during load tests</td>\n<td>Implement LRU eviction with strict capacity limits and add TTL-based cleanup for ban rules via <code>InvalidationHandler._gc_ban_rules()</code></td>\n</tr>\n<tr>\n<td><strong>Geo-routing directs clients to distant edge nodes</strong></td>\n<td>GeoIP database inaccuracy or health status misreporting</td>\n<td>1. Verify <code>GeoIPLookup.lookup()</code> returns correct location for test IPs<br>2. Check <code>EdgeNode.health_status</code> reporting<br>3. Test consistent hashing ring assignment</td>\n<td>Use more accurate GeoIP database, implement weighted health checks, and add fallback routing based on latency measurements</td>\n</tr>\n<tr>\n<td><strong>Range requests return incorrect byte ranges</strong></td>\n<td>Cache fragmentation or incorrect <code>Range</code> header parsing</td>\n<td>1. Test <code>RangeRequestHandler.parse_range_header()</code> with various inputs<br>2. Verify cached body length matches <code>Content-Length</code><br>3. Check for off-by-one errors in <code>ByteRange.end</code></td>\n<td>Implement proper boundary checking in <code>RangeRequestHandler.extract_range_from_body()</code> and cache full responses, not partials</td>\n</tr>\n<tr>\n<td><strong>Compression causes CPU spikes at edge</strong></td>\n<td>Compressing all content types or using high compression levels</td>\n<td>1. Profile CPU usage by content type<br>2. Check if already-compressed responses (images, videos) get recompressed<br>3. Monitor compression ratio vs CPU time trade-off</td>\n<td>Skip compression for already-compressed formats and implement configurable compression level per content type</td>\n</tr>\n<tr>\n<td><strong>Circuit breaker trips unnecessarily</strong></td>\n<td>Failure threshold too low or origin temporary blips treated as failures</td>\n<td>1. Check <code>CircuitBreakerConfig.failure_threshold</code> value<br>2. Monitor origin response times vs timeout settings<br>3. Verify health check logic isn&#39;t too sensitive</td>\n<td>Adjust circuit breaker parameters based on actual failure patterns and implement exponential backoff for <code>half_open</code> state</td>\n</tr>\n<tr>\n<td><strong>Negative caching causes 404s to persist</strong></td>\n<td>Error response TTL too long or missing invalidation on content creation</td>\n<td>1. Check TTL assigned to error responses (should be short)<br>2. Verify purge commands affect negative cache entries<br>3. Monitor <code>ShieldMetrics.negative_cache_hits</code></td>\n<td>Cache 404/5xx responses with very short TTLs (5-10 seconds) and include them in purge operations</td>\n</tr>\n<tr>\n<td><strong>Vary header handling causes cache bloat</strong></td>\n<td>Treating each unique header combination as separate entry without bounds</td>\n<td>1. Inspect cache storage for duplicate content with different <code>Vary</code> values<br>2. Check if <code>Vary: *</code> is incorrectly cached<br>3. Monitor memory growth with varied requests</td>\n<td>Implement <code>Vary</code> header normalization and limit number of variations per URL; reject <code>Vary: *</code> from cache</td>\n</tr>\n<tr>\n<td><strong>Request collapsing causes client timeouts</strong></td>\n<td>Collapsing timeout longer than client timeout or deadlock in coalescing map</td>\n<td>1. Compare <code>RequestCoalescingMap._default_timeout</code> with client timeout<br>2. Check for stuck futures never fulfilled<br>3. Monitor queue times in <code>ShieldMetrics</code></td>\n<td>Set collapsing timeout shorter than client timeout and implement timeout cleanup in <code>RequestCoalescingMap._gc_loop()</code></td>\n</tr>\n<tr>\n<td><strong>Consistent hashing causes hot spots</strong></td>\n<td>Uneven virtual node distribution or skewed request patterns</td>\n<td>1. Analyze request distribution across edge nodes<br>2. Check <code>ConsistentHashRing.replicas_per_node</code> count<br>3. Verify hash function distribution uniformity</td>\n<td>Increase virtual nodes per physical node and consider weighted consistent hashing based on node capacity</td>\n</tr>\n<tr>\n<td><strong>Stale-while-revalidate serves outdated data indefinitely</strong></td>\n<td>Background revalidation failing silently or not triggered</td>\n<td>1. Check <code>_revalidate_in_background()</code> error handling<br>2. Verify stale entries get revalidation triggered on access<br>3. Monitor background thread/task completion</td>\n<td>Implement proper error recovery in revalidation and fallback to fetch fresh content if revalidation fails repeatedly</td>\n</tr>\n<tr>\n<td><strong>Health checks cause cascading failures</strong></td>\n<td>Aggressive health checking marks nodes unhealthy during normal load</td>\n<td>1. Check health check interval vs node response time under load<br>2. Verify health metrics thresholds are realistic<br>3. Monitor <code>NodeHealth</code> transitions during traffic spikes</td>\n<td>Implement weighted health checks that consider historical performance and add grace periods before marking nodes unhealthy</td>\n</tr>\n</tbody></table>\n<h3 id=\"cdn-specific-debugging-techniques\">CDN-Specific Debugging Techniques</h3>\n<p>Beyond symptom-based diagnosis, effective CDN debugging requires specialized techniques for inspecting the complex interactions between caching layers, routing logic, and distributed state. These methods transform the CDN from a black box into a transparent, observable system where you can trace every request&#39;s journey and understand every caching decision.</p>\n<h4 id=\"adding-diagnostic-headers-to-http-responses\">Adding Diagnostic Headers to HTTP Responses</h4>\n<p>The simplest yet most powerful debugging technique is augmenting HTTP responses with custom headers that reveal the CDN&#39;s internal decision-making. These headers act as <strong>flight data recorders for each request</strong>, documenting its path through the caching infrastructure. Add the following headers to all responses from edge nodes:</p>\n<ul>\n<li><strong><code>X-Cache-Status</code></strong>: Indicates whether the response was served from cache (<code>HIT</code>), fetched from upstream (<code>MISS</code>), revalidated (<code>REVALIDATED</code>), or served stale while revalidating (<code>STALE</code>)</li>\n<li><strong><code>X-Cache-Key</code></strong>: Shows the exact cache key used for lookup, helping identify key generation issues</li>\n<li><strong><code>X-Cache-Age</code></strong>: The time in seconds since the cached response was fetched from origin</li>\n<li><strong><code>X-Edge-Node</code></strong>: Identifier of the edge node that served the request (crucial for geo-routing debugging)</li>\n<li><strong><code>X-Request-ID</code></strong>: Unique identifier propagated through all layers (edge → shield → origin) for request tracing</li>\n<li><strong><code>X-Cache-TTL</code></strong>: Remaining time-to-live in seconds for the cached response</li>\n<li><strong><code>X-Vary-Headers</code></strong>: Shows which request headers were considered in cache key generation due to <code>Vary</code></li>\n</ul>\n<p>To implement these headers, modify the <code>EdgeRequestHandler.handle_request()</code> method to append them before returning the response. In production CDNs, these headers are typically enabled via configuration and stripped for external clients, but during development they provide invaluable visibility.</p>\n<h4 id=\"inspecting-cache-state-and-metrics\">Inspecting Cache State and Metrics</h4>\n<p>When responses aren&#39;t caching as expected, you need to directly examine the cache&#39;s internal state. The CDN provides several inspection points:</p>\n<ol>\n<li><p><strong>Cache Storage Dump</strong>: Implement a debug endpoint (e.g., <code>GET /debug/cache</code>) that returns a JSON representation of all cache entries, including their keys, URLs, TTLs, and tags. This helps verify what&#39;s actually stored versus what you expect to be stored.</p>\n</li>\n<li><p><strong>Metrics Inspection Endpoint</strong>: Create <code>/debug/metrics</code> endpoint exposing <code>EdgeMetrics</code>, <code>ShieldMetrics</code>, and <code>TimeWindowedMetrics</code> in structured format. Monitor:</p>\n<ul>\n<li>Cache hit ratio trends over time</li>\n<li>Cache size and eviction rates</li>\n<li>Request collapsing effectiveness at shield</li>\n<li>Geo-routing distribution across nodes</li>\n</ul>\n</li>\n<li><p><strong>Surrogate Key Index Verification</strong>: Add a debug endpoint to inspect <code>SurrogateKeyIndex</code> mappings, showing which tags are assigned to which cache keys and vice versa. This is crucial when tag-based purges aren&#39;t working.</p>\n</li>\n<li><p><strong>Ban Rule Audit</strong>: Expose active <code>BanRule</code> patterns, their creation times, and match counts to ensure they&#39;re being applied correctly and garbage collected when expired.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Debugging Insight</strong>: Always compare cache state with actual HTTP behavior. If the cache dump shows an entry exists but requests miss, the issue is likely in cache key generation or request/response header mismatching.</p>\n</blockquote>\n<h4 id=\"simulating-geo-distribution-locally\">Simulating Geo-Distribution Locally</h4>\n<p>Testing geo-routing and multi-node behavior typically requires distributed infrastructure, but you can simulate it locally using these techniques:</p>\n<ol>\n<li><p><strong>IP Address Spoofing</strong>: Use tools like <code>curl --interface</code> or programming libraries to bind requests to different source IPs. Combine with a test <code>GeoIP</code> database that maps specific test IPs to different regions (e.g., <code>203.0.113.1</code> → &quot;US-West&quot;, <code>203.0.113.2</code> → &quot;EU-Central&quot;).</p>\n</li>\n<li><p><strong>Local Edge Node Cluster</strong>: Run multiple edge node instances on different ports, each configured with a different <code>region</code> in <code>EdgeConfig</code>. Use a simple local DNS resolver or HTTP proxy to route requests based on simulated client IPs.</p>\n</li>\n<li><p><strong>Consistent Hashing Visualization</strong>: Implement a debug visualization of the <code>ConsistentHashRing</code> showing positions of nodes and sample cache keys. This helps identify hot spots and understand key redistribution during node addition/removal.</p>\n</li>\n<li><p><strong>Network Condition Simulation</strong>: Use tools like <code>tc</code> (traffic control on Linux) or <code>comcast</code> to simulate latency, packet loss, and bandwidth constraints between nodes, reproducing real-world network partitions.</p>\n</li>\n<li><p><strong>Control Plane Mock</strong>: Create a mock control plane that coordinates multiple local edge nodes, allowing you to test invalidation propagation, health check aggregation, and configuration distribution without cloud deployment.</p>\n</li>\n</ol>\n<h4 id=\"request-tracing-and-log-correlation\">Request Tracing and Log Correlation</h4>\n<p>For complex issues involving multiple hops (client → edge → shield → origin), implement distributed tracing:</p>\n<ol>\n<li><p><strong>Generate Unique Request ID</strong>: At the first CDN entry point, generate a UUID and pass it through all layers via the <code>X-Request-ID</code> header.</p>\n</li>\n<li><p><strong>Structured Logging</strong>: Use JSON-structured logs at each component that includes the request ID, component name, cache key, decision points, and timing information.</p>\n</li>\n<li><p><strong>Log Aggregation</strong>: Collect logs from all edge nodes, shields, and control plane into a central location (even a simple file during development) where you can filter by request ID to see the complete journey.</p>\n</li>\n<li><p><strong>Timing Measurements</strong>: Log key timing events: cache lookup duration, upstream fetch time, shield queuing delay, and geo-routing decision time. This helps identify performance bottlenecks.</p>\n</li>\n</ol>\n<h4 id=\"testing-cache-invalidation-propagation\">Testing Cache Invalidation Propagation</h4>\n<p>Invalidation bugs often manifest as stale content served from some nodes but not others. Test propagation systematically:</p>\n<ol>\n<li><p><strong>Propagation Delay Test</strong>: Issue a purge command, then immediately request the same resource from multiple edge nodes while logging <code>X-Cache-Status</code> and <code>X-Edge-Node</code>. Measure time until all nodes reflect the purge.</p>\n</li>\n<li><p><strong>Network Partition Simulation</strong>: Disconnect one edge node from the pub/sub network, issue purges, then reconnect and verify it receives queued invalidation messages.</p>\n</li>\n<li><p><strong>Sequence Testing</strong>: Send rapid successive purge commands and verify they&#39;re processed in order, especially important for soft-purge-then-hard-purge scenarios.</p>\n</li>\n<li><p><strong>Tag-Based Purge Coverage</strong>: Create resources with multiple surrogate keys, then purge by one tag and verify only appropriate resources are invalidated.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Debugging Principle</strong>: When debugging distributed caching systems, <strong>assume eventual consistency by default</strong>. Many issues resolve themselves given time. The question is whether the inconsistency window matches your design expectations.</p>\n</blockquote>\n<h4 id=\"common-http-edge-case-testing\">Common HTTP Edge Case Testing</h4>\n<p>Several HTTP caching edge cases frequently cause subtle bugs. Create test cases for:</p>\n<ol>\n<li><p><strong><code>Vary: *</code></strong>: Ensure responses with this header are never cached, despite other cache directives suggesting they could be.</p>\n</li>\n<li><p><strong><code>Cache-Control: no-cache</code> vs <code>no-store</code></strong>: Verify <code>no-cache</code> allows storage but requires revalidation, while <code>no-store</code> prevents any storage.</p>\n</li>\n<li><p><strong>Multiple <code>Cache-Control</code> headers</strong>: Test handling of multiple <code>Cache-Control</code> headers (should be concatenated per RFC).</p>\n</li>\n<li><p><strong><code>Expires</code> with invalid date format</strong>: Ensure graceful fallback when <code>Expires</code> header contains malformed dates.</p>\n</li>\n<li><p><strong>Chunked encoding with cache</strong>: Verify chunked responses can be cached (must be reassembled into complete body).</p>\n</li>\n<li><p><strong><code>Content-Encoding</code> with <code>Vary: Accept-Encoding</code></strong>: Test that compressed and uncompressed versions are stored separately.</p>\n</li>\n</ol>\n<p>By combining these debugging techniques with the symptom-cause-fix table, you&#39;ll develop systematic approach to troubleshooting the CDN. Remember that caching bugs often involve <strong>timing, distribution, and state</strong>—reproduce issues under realistic load and network conditions, and always verify behavior at multiple points in the request flow.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Diagnostic Headers</td>\n<td>Custom middleware in request handler</td>\n<td>OpenTelemetry tracing with baggage propagation</td>\n</tr>\n<tr>\n<td>Cache Inspection</td>\n<td>Debug HTTP endpoints with JSON output</td>\n<td>Integrated admin UI with real-time metrics</td>\n</tr>\n<tr>\n<td>Geo Simulation</td>\n<td>Static IP-to-region mapping file</td>\n<td>Docker containers with virtual networks and IP routing</td>\n</tr>\n<tr>\n<td>Request Tracing</td>\n<td>Manual <code>X-Request-ID</code> propagation</td>\n<td>Distributed tracing (Jaeger/Zipkin) with spans</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Structured JSON to stdout</td>\n<td>Centralized log aggregation (Loki/ELK)</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue-origin-cdn/\n├── src/\n│   ├── debug/                      # Debugging utilities\n│   │   ├── __init__.py\n│   │   ├── headers.py              # Diagnostic header injection\n│   │   ├── inspector.py            # Cache state inspection\n│   │   ├── tracing.py              # Request tracing utilities\n│   │   └── simulation.py           # Geo-distribution simulation tools\n│   ├── metrics/                    # Metrics collection\n│   │   ├── __init__.py\n│   │   ├── collectors.py           # Metrics collection logic\n│   │   └── exporters.py            # Export to Prometheus/JSON\n│   └── tests/\n│       ├── __init__.py\n│       ├── test_debug_headers.py\n│       ├── test_cache_inspection.py\n│       └── simulation/             # Simulation tests\n│           ├── test_geo_routing.py\n│           └── test_invalidation_propagation.py</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here&#39;s a complete, ready-to-use diagnostic header middleware for Python:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/debug/headers.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> uuid</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiagnosticHeaders</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Middleware for adding diagnostic headers to HTTP responses.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, node_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"local\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_cache_headers</span><span style=\"color:#E1E4E8\">(self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         status: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         cache_entry: Optional[</span><span style=\"color:#9ECBFF\">'CacheEntry'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         response_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add cache-related diagnostic headers to response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response_headers.copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Always add cache status and node ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers[</span><span style=\"color:#9ECBFF\">'X-Cache-Status'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers[</span><span style=\"color:#9ECBFF\">'X-Edge-Node'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.node_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add cache key for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers[</span><span style=\"color:#9ECBFF\">'X-Cache-Key'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache_key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add cache age and TTL if we have a cache entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cache_entry:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            age </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(current_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> cache_entry.fetched_at)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttl </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(cache_entry.expires_at </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> current_time) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> cache_entry.expires_at </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            headers[</span><span style=\"color:#9ECBFF\">'X-Cache-Age'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(age)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            headers[</span><span style=\"color:#9ECBFF\">'X-Cache-TTL'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(ttl)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Add vary header info if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cache_entry.vary_headers:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                vary_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> ','</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">k</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">v</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> cache_entry.vary_headers.items())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                headers[</span><span style=\"color:#9ECBFF\">'X-Vary-Headers'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> vary_list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> headers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_request_id</span><span style=\"color:#E1E4E8\">(self, existing_id: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate or propagate request ID for tracing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> existing_id </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> existing_id.strip():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> existing_id</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"req_</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">uuid.uuid4().hex[:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_tracing_headers</span><span style=\"color:#E1E4E8\">(self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           response_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add distributed tracing headers to response.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response_headers.copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Get or generate request ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.generate_request_id(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            request_headers.get(</span><span style=\"color:#9ECBFF\">'X-Request-ID'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> request_headers.get(</span><span style=\"color:#9ECBFF\">'x-request-id'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers[</span><span style=\"color:#9ECBFF\">'X-Request-ID'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_id</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add timing information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers[</span><span style=\"color:#9ECBFF\">'X-Processed-At'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(time.time())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> headers</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Here&#39;s skeleton code for the cache inspection debug endpoint:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/debug/inspector.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CacheInspector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Debug endpoint for inspecting cache state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, cache_storage: </span><span style=\"color:#9ECBFF\">'CacheStorage'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 key_index: Optional[</span><span style=\"color:#9ECBFF\">'SurrogateKeyIndex'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 ban_rules: Optional[List[</span><span style=\"color:#9ECBFF\">'BanRule'</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache_storage</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.key_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> key_index</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.ban_rules </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ban_rules </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_debug_request</span><span style=\"color:#E1E4E8\">(self, path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            query_params: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle GET /debug/cache[/subpath] requests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse path to determine what to inspect:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - /debug/cache/entries: List all cache entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - /debug/cache/keys: List just cache keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - /debug/cache/tags: Show tag-to-key mappings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - /debug/cache/bans: Show active ban rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For /debug/cache/entries, iterate through cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   and collect entry metadata without full bodies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For /debug/cache/tags, use key_index.get_keys_for_tag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   to show all tag associations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For /debug/cache/bans, list all active ban rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   with their patterns, creation time, and TTL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Apply query filters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - ?url=pattern: Filter by URL pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - ?tag=name: Filter by surrogate key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - ?limit=N: Limit number of results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Format results as JSON with appropriate structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return HTTP 200 with application/json content-type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle errors gracefully (e.g., missing key_index)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_cache_entries_summary</span><span style=\"color:#E1E4E8\">(self, limit: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">) -> List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get summary of cache entries without full bodies.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get list of all cache keys from storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each key, retrieve cache entry metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract key information: url, fetched_at, expires_at, </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   size, surrogate_keys, hit_count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply limit and return list of summaries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_tag_mappings</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get surrogate key index mappings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if key_index is available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return tag_to_keys and key_to_tags structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include statistics: total tags, avg keys per tag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Python&#39;s <code>asyncio</code> debugging</strong>: Use <code>asyncio.create_task()</code> for background revalidation but capture exceptions with <code>task.add_done_callback()</code> to avoid silent failures.</li>\n<li><strong>Memory profiling</strong>: Use <code>tracemalloc</code> to track cache memory usage and identify leaks in cache storage implementation.</li>\n<li><strong>Timing measurements</strong>: Use <code>time.perf_counter()</code> for high-resolution timing in critical paths (cache lookups, upstream fetches).</li>\n<li><strong>GeoIP database</strong>: Use <code>maxminddb-geolite2</code> package for development GeoIP database, but remember it&#39;s not updated in real-time.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing debugging features, verify them with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start edge node with debug endpoints enabled</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/edge_server.py</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#79B8FF\"> --debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test diagnostic headers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> http://localhost:8080/image.jpg</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Look for headers:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># X-Cache-Status: MISS (first time) or HIT (subsequent)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># X-Cache-Key: /image.jpg (or with vary dimensions)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># X-Edge-Node: local</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># X-Request-ID: req_abcdef1234567890</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test cache inspection endpoint</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/cache/entries?limit=</span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: JSON array of cache entries with metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [{\"key\": \"...\", \"url\": \"...\", \"fetched_at\": 123.45, ...}]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test invalidation and verify via debug endpoint</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> PURGE</span><span style=\"color:#9ECBFF\"> http://localhost:8080/image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/cache/entries</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> image.jpg</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show no entries or stale status</span></span></code></pre></div>\n\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Diagnostic headers missing</td>\n<td>Check middleware order in request handler</td>\n<td>Ensure <code>DiagnosticHeaders</code> processes responses before sending</td>\n</tr>\n<tr>\n<td>Cache inspection endpoint slow</td>\n<td>Profile <code>_get_cache_entries_summary</code> with large cache</td>\n<td>Implement pagination and limit full scan frequency</td>\n</tr>\n<tr>\n<td>Request ID not propagating</td>\n<td>Trace headers through edge → shield → origin</td>\n<td>Ensure each component reads and forwards <code>X-Request-ID</code></td>\n</tr>\n<tr>\n<td>Simulation not reflecting real behavior</td>\n<td>Compare latency measurements with production-like conditions</td>\n<td>Add jitter, packet loss, and bandwidth constraints to simulation</td>\n</tr>\n</tbody></table>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section explores potential enhancements beyond the foundational five milestones, showing how the current architecture accommodates future growth and more advanced CDN features.</p>\n</blockquote>\n<p>The &quot;Blue Origin&quot; CDN you&#39;ve built represents a solid foundation for content delivery, but like any production system, it will naturally evolve to meet new requirements and leverage emerging technologies. This section explores several <strong>natural extensions</strong> that build upon the existing architecture without requiring fundamental redesigns. Each extension demonstrates how the modular, layered design enables incremental enhancement—a key principle of sustainable system architecture.</p>\n<h3 id=\"mental-model-the-highway-system-evolution\">Mental Model: The Highway System Evolution</h3>\n<p>Imagine the current CDN as a basic interstate highway system connecting cities (origin) to suburbs (users) with well-designed on-ramps (edge nodes), rest stops (shields), and traffic control systems (routing). The foundational system efficiently moves standard vehicles (HTTP content) between points. Future extensions are analogous to:</p>\n<ol>\n<li><strong>Express lanes for predictable commuters</strong> → <strong>Prefetching</strong> anticipates regular traffic patterns</li>\n<li><strong>Vehicle modification stations</strong> → <strong>Image optimization</strong> transforms content for different vehicles</li>\n<li><strong>Real-time convoy coordination</strong> → <strong>WebSocket proxying</strong> maintains persistent connections</li>\n<li><strong>Integration with shipping warehouses</strong> → <strong>Object storage</strong> connects to cloud-native origins</li>\n</ol>\n<p>Each extension builds upon the existing infrastructure rather than replacing it, demonstrating the power of well-defined interfaces and separation of concerns.</p>\n<h3 id=\"potential-enhancements\">Potential Enhancements</h3>\n<h4 id=\"1-predictive-prefetching-and-cache-warming\">1. Predictive Prefetching and Cache Warming</h4>\n<p><strong>What it is:</strong> Automatically fetching content before users request it, based on access patterns, link analysis, or explicit hints.</p>\n<p><strong>Why it&#39;s valuable:</strong> Dramatically improves cache hit ratios for predictable traffic patterns (daily content updates, scheduled releases, trending content). Reduces perceived latency to near-zero for prefetched resources.</p>\n<p><strong>How it integrates with current design:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Integration Point</th>\n<th>Extension Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Edge Cache Storage</td>\n<td>New <code>prefetch_queue</code> field in <code>EdgeConfig</code> to manage background fetch jobs</td>\n</tr>\n<tr>\n<td>Control Plane</td>\n<td>New prefetch scheduler analyzing access logs and content relationships</td>\n</tr>\n<tr>\n<td>Edge Node Routing</td>\n<td>Enhanced <code>EdgeRequestHandler</code> with predictive logic before cache check</td>\n</tr>\n<tr>\n<td>Analytics</td>\n<td>New <code>PrefetchMetrics</code> tracking hit rates on prefetched content</td>\n</tr>\n</tbody></table>\n<p><strong>Design considerations:</strong></p>\n<blockquote>\n<p><strong>Decision: Client-Driven vs. Server-Driven Prefetching</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to decide who initiates prefetch operations—the edge node (server-driven) or the client (via hints like Link headers).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Server-driven predictive prefetching</strong>: Edge nodes analyze access patterns and automatically fetch likely-next resources</li>\n<li><strong>Client-driven hint-based prefetching</strong>: Use HTTP <code>Link</code> headers with <code>rel=&quot;prefetch&quot;</code> or <code>rel=&quot;preload&quot;</code></li>\n<li><strong>Hybrid approach</strong>: Combine server predictions with client hints for highest accuracy</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Start with client-driven prefetching using standard HTTP headers</li>\n<li><strong>Rationale</strong>: Client hints are standardized (RFC 5988), deterministic, and don&#39;t require complex machine learning. Server-driven prefetching risks wasteful bandwidth usage if predictions are wrong.</li>\n<li><strong>Consequences</strong>: Simpler implementation, respects origin bandwidth, but misses opportunities where clients don&#39;t send hints.</li>\n</ul>\n</blockquote>\n<p><strong>Implementation approach:</strong></p>\n<ol>\n<li>Extend <code>EdgeRequestHandler.handle_request()</code> to parse <code>Link</code> headers with <code>rel=&quot;prefetch&quot;</code> or <code>rel=&quot;preload&quot;</code></li>\n<li>Add background worker pool to asynchronously fetch linked resources</li>\n<li>Store prefetched content with lower priority (evicted first under memory pressure)</li>\n<li>Add <code>X-CDN-Prefetch: hit/miss</code> diagnostic headers to track effectiveness</li>\n</ol>\n<p><strong>Challenges:</strong></p>\n<ul>\n<li><strong>Cache pollution</strong>: Prefetched content that&#39;s never used wastes storage and bandwidth</li>\n<li><strong>Origin load spikes</strong>: Aggressive prefetching could overwhelm origins</li>\n<li><strong>Priority inversion</strong>: Prefetching shouldn&#39;t block real user requests</li>\n</ul>\n<p><strong>Solution patterns:</strong></p>\n<ul>\n<li>Implement prefetch budget limiting (max concurrent prefetches per edge)</li>\n<li>Use TTL-based decay for prefetch priority (older predictions less valuable)</li>\n<li>Add <code>prefetch</code> flag to <code>CacheEntry</code> to track prefetched vs. demand-fetched content</li>\n</ul>\n<h4 id=\"2-image-optimization-at-the-edge\">2. Image Optimization at the Edge</h4>\n<p><strong>What it is:</strong> On-the-fly resizing, format conversion (WebP/AVIF), compression, and quality adjustment for images based on client device and network conditions.</p>\n<p><strong>Why it&#39;s valuable:</strong> Images typically constitute 60-80% of page weight. Optimizing them at the edge reduces bandwidth costs, improves page load times, and provides better user experience across diverse devices.</p>\n<p><strong>How it integrates with current design:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Enhancement Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Edge Cache</td>\n<td>New <code>ImageOptimizer</code> component with format detection and conversion</td>\n</tr>\n<tr>\n<td>Cache Key Generation</td>\n<td>Include image transformation parameters in cache key</td>\n</tr>\n<tr>\n<td>Content Negotiation</td>\n<td>Enhanced <code>Accept</code> header parsing for image formats</td>\n</tr>\n<tr>\n<td>Response Headers</td>\n<td>Add <code>Content-DPR</code>, <code>Content-Width</code> headers for responsive images</td>\n</tr>\n</tbody></table>\n<p><strong>Key data structures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Fields</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ImageTransformation</code></td>\n<td><code>format: str</code>, <code>width: int</code>, <code>height: int</code>, <code>quality: int</code>, <code>crop: bool</code>, <code>dpr: float</code></td>\n<td>Defines transformation parameters for an image</td>\n</tr>\n<tr>\n<td><code>DeviceProfile</code></td>\n<td><code>dpi: int</code>, <code>max_width: int</code>, <code>supported_formats: List[str]</code>, <code>network_type: str</code></td>\n<td>Client device capabilities for adaptive optimization</td>\n</tr>\n<tr>\n<td><code>OptimizedImageCacheKey</code></td>\n<td><code>original_key: str</code>, <code>transformation: ImageTransformation</code>, <code>variant_hash: str</code></td>\n<td>Composite key for transformed image variants</td>\n</tr>\n</tbody></table>\n<p><strong>Workflow:</strong></p>\n<ol>\n<li>Client request includes <code>Accept</code> header with preferred image formats and <code>DPR</code> (Device Pixel Ratio) header</li>\n<li><code>EdgeRequestHandler</code> checks for existing optimized variant in cache</li>\n<li>On miss, fetch original from upstream (or from cache if original exists)</li>\n<li>Apply transformations using <code>ImageOptimizer.transform(image_bytes, transformation)</code></li>\n<li>Store transformed variant with separate <code>CacheEntry</code> and TTL</li>\n<li>Serve optimized image with appropriate <code>Content-Type</code> and <code>Vary: Accept, DPR</code></li>\n</ol>\n<p><strong>Performance optimization strategies:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Implementation</th>\n<th>Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lazy transformation</td>\n<td>Only transform on demand, not preemptively</td>\n<td>Reduces CPU and storage waste</td>\n</tr>\n<tr>\n<td>Progressive rendering</td>\n<td>Serve low-quality placeholder first, then enhance</td>\n<td>Improves perceived performance</td>\n</tr>\n<tr>\n<td>Format fallback chain</td>\n<td>Try WebP → JPEG → PNG based on client support</td>\n<td>Maximizes compression benefits</td>\n</tr>\n<tr>\n<td>Dimension-aware caching</td>\n<td>Cache common sizes (320w, 640w, 1024w, etc.)</td>\n<td>Increases cache hit ratio across devices</td>\n</tr>\n</tbody></table>\n<p><strong>Challenges and solutions:</strong></p>\n<p>⚠️ <strong>Pitfall: CPU exhaustion at edge</strong></p>\n<ul>\n<li><strong>Problem</strong>: Image transformation is CPU-intensive; under heavy load, edge nodes could become compute-bound</li>\n<li><strong>Solution</strong>: Implement request queuing with priority (user requests &gt; optimization), and limit concurrent transformations per node</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Storage explosion</strong></p>\n<ul>\n<li><strong>Problem</strong>: Each image could have dozens of variants (formats × sizes × qualities)</li>\n<li><strong>Solution</strong>: Use LRU with lower TTL for variants, implement variant garbage collection based on access patterns</li>\n</ul>\n<h4 id=\"3-websocket-proxying-and-edge-compute\">3. WebSocket Proxying and Edge Compute</h4>\n<p><strong>What it is:</strong> Extending the CDN to proxy WebSocket connections and execute lightweight compute functions at the edge.</p>\n<p><strong>Why it&#39;s valuable:</strong> Modern applications increasingly use real-time bidirectional communication (chat, gaming, collaborative editing). Edge compute enables custom logic execution close to users (A/B testing, personalization, authentication).</p>\n<p><strong>How it integrates with current design:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current Component</th>\n<th>WebSocket Extension</th>\n<th>Edge Compute Extension</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Edge Node</td>\n<td>WebSocket handshake handling, connection pooling</td>\n<td>Python/JavaScript runtime sandbox</td>\n</tr>\n<tr>\n<td>Cache Storage</td>\n<td>Session state storage (limited TTL)</td>\n<td>Function code cache with invalidation</td>\n</tr>\n<tr>\n<td>Routing</td>\n<td>Connection-aware sticky routing</td>\n<td>Function registry and versioning</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>Connection count, message rates, uptime</td>\n<td>Execution time, memory usage, error rates</td>\n</tr>\n</tbody></table>\n<p><strong>WebSocket proxying architecture:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Client ──WS──&gt; Edge Node ──WS──&gt; Origin\n           │                     │\n           ├── Message Cache ────┘ (for pub/sub patterns)\n           └── Connection Pool ──── (reuse origin connections)</code></pre></div>\n\n<p><strong>Key considerations for WebSocket support:</strong></p>\n<ol>\n<li><strong>Connection lifecycle management</strong>: WebSocket connections are long-lived (hours/days vs HTTP&#39;s seconds)</li>\n<li><strong>Message caching</strong>: Some pub/sub patterns benefit from edge caching of broadcast messages</li>\n<li><strong>Sticky routing</strong>: Once a WebSocket connects to an edge node, subsequent HTTP requests should route to same node (for session consistency)</li>\n<li><strong>Protocol upgrade handling</strong>: Proper HTTP/1.1 Upgrade header processing with fallback</li>\n</ol>\n<p><strong>Edge compute implementation pattern:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Pseudo-structure (not Layer 1 code, but conceptual)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    version: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    code_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # For cache invalidation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runtime: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">    # \"python\", \"javascript\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_limit_mb: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout_ms: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env_vars: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EdgeFunctionRuntime</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(function: EdgeFunction, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     request: HttpRequest, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     context: ExecutionContext) -> HttpResponse:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Isolate in sandbox, enforce limits, collect metrics</span></span></code></pre></div>\n\n<p><strong>Security considerations critical for edge compute:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Concern</th>\n<th>Mitigation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Code injection</td>\n<td>Strict sandboxing (seccomp, namespaces, cgroups)</td>\n</tr>\n<tr>\n<td>Resource exhaustion</td>\n<td>Hard limits on memory, CPU time, execution duration</td>\n</tr>\n<tr>\n<td>Data leakage</td>\n<td>Encryption at rest, process isolation between tenants</td>\n</tr>\n<tr>\n<td>DoS amplification</td>\n<td>Rate limiting per function, global resource quotas</td>\n</tr>\n</tbody></table>\n<p><strong>Integration with cache invalidation:</strong> Edge functions can trigger cache purges programmatically, enabling dynamic content generation with automatic invalidation.</p>\n<h4 id=\"4-object-storage-integration-as-origin\">4. Object Storage Integration as Origin</h4>\n<p><strong>What it is:</strong> Treating cloud object storage (AWS S3, Google Cloud Storage, Azure Blob Storage) as a first-class origin, with optimized protocols and caching semantics.</p>\n<p><strong>Why it&#39;s valuable:</strong> Modern applications increasingly store static assets in object storage. Direct integration reduces latency (no intermediary web server) and leverages storage-native features (versioning, lifecycle policies).</p>\n<p><strong>How it integrates with current design:</strong></p>\n<table>\n<thead>\n<tr>\n<th>CDN Component</th>\n<th>Object Storage Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Origin Shield</td>\n<td>S3 API client with signature v4 authentication</td>\n</tr>\n<tr>\n<td>Cache Invalidation</td>\n<td>S3 event notification integration (purge on object update)</td>\n</tr>\n<tr>\n<td>Range Requests</td>\n<td>Native support for S3&#39;s multipart and range requests</td>\n</tr>\n<tr>\n<td>TTL Management</td>\n<td>Respect S3 metadata (Cache-Control headers on objects)</td>\n</tr>\n</tbody></table>\n<p><strong>Optimization opportunities specific to object storage:</strong></p>\n<ol>\n<li><strong>Parallel range fetching</strong>: For large files, fetch chunks in parallel from S3</li>\n<li><strong>Prefix-based caching</strong>: Special handling for directory-like listings</li>\n<li><strong>Version-aware caching</strong>: Cache multiple versions of same object key</li>\n<li><strong>Lifecycle synchronization</strong>: Automatically purge when S3 lifecycle policy deletes objects</li>\n</ol>\n<p><strong>Data flow for S3-backed origin:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Edge Node → Origin Shield → S3 API Endpoint\n    ↑           ↑                ↑\n    Cache     Transform      Authentication\n    Layer    HTTP to S3       (SigV4)\n              Protocol</code></pre></div>\n\n<p><strong>Implementation details:</strong></p>\n<ul>\n<li>Extend <code>_fetch_from_upstream()</code> in <code>ShieldRequestHandler</code> to handle S3-specific HTTP headers (<code>x-amz-*</code>)</li>\n<li>Implement S3 authentication (AWS Signature Version 4) for private buckets</li>\n<li>Parse S3 error responses and convert to appropriate HTTP status codes</li>\n<li>Handle S3&#39;s multipart upload references for large objects</li>\n</ul>\n<p><strong>Challenges and solutions:</strong></p>\n<p>⚠️ <strong>Pitfall: Authentication token management</strong></p>\n<ul>\n<li><strong>Problem</strong>: S3 requires frequent signature rotation; hardcoding credentials is insecure</li>\n<li><strong>Solution</strong>: Implement IAM role assumption with temporary credentials, refreshed automatically</li>\n</ul>\n<p>⚠️ <strong>Pitfall: S3 eventual consistency</strong></p>\n<ul>\n<li><strong>Problem</strong>: S3 offers eventual consistency for overwrite PUTs and DELETEs</li>\n<li><strong>Solution</strong>: Implement read-after-write consistency verification or use S3 Strong Consistency where available</li>\n</ul>\n<h4 id=\"5-additional-extension-ideas\">5. Additional Extension Ideas</h4>\n<p><strong>Real-time Analytics Pipeline:</strong> Extend the <code>EdgeMetrics</code> collection to stream to a time-series database (InfluxDB, TimescaleDB) for real-time dashboards and anomaly detection.</p>\n<p><strong>Advanced Compression:</strong> Add Zstandard (zstd) support alongside Brotli and gzip, with adaptive compression level based on content type and client capabilities.</p>\n<p><strong>Video Streaming Optimizations:</strong> </p>\n<ul>\n<li>HLS/DASH manifest manipulation at edge</li>\n<li>Per-title encoding ladder optimization</li>\n<li>Buffer management for adaptive bitrate streaming</li>\n<li>Prefetching of video segments based on playback rate</li>\n</ul>\n<p><strong>Security Enhancements:</strong></p>\n<ul>\n<li>DDoS protection with rate limiting and challenge-response</li>\n<li>WAF (Web Application Firewall) rules execution at edge</li>\n<li>Bot detection and mitigation</li>\n<li>TLS 1.3 with early data support</li>\n</ul>\n<p><strong>Multi-CDN Failover:</strong> Integrate with commercial CDNs as fallback origins, implementing health-based routing between your CDN and third-party providers.</p>\n<h3 id=\"architectural-principles-for-extensibility\">Architectural Principles for Extensibility</h3>\n<p>The current &quot;Blue Origin&quot; CDN design follows several principles that make these extensions feasible:</p>\n<ol>\n<li><strong>Interface-based design</strong>: Clear boundaries between components (cache storage, request handlers, routing) allow swapping implementations</li>\n<li><strong>Pluggable middleware</strong>: The request processing pipeline can be extended with additional handlers (compression, optimization, authentication)</li>\n<li><strong>Configuration-driven behavior</strong>: <code>EdgeConfig</code> provides hooks for enabling/disabling features without code changes</li>\n<li><strong>Observability first</strong>: Built-in metrics collection makes it easy to track the impact of new features</li>\n<li><strong>Graceful degradation</strong>: Circuit breakers and fallback mechanisms ensure new features don&#39;t break core functionality</li>\n</ol>\n<h3 id=\"prioritization-framework\">Prioritization Framework</h3>\n<p>When deciding which extensions to implement first, consider this decision matrix:</p>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>User Impact</th>\n<th>Implementation Complexity</th>\n<th>Operational Overhead</th>\n<th>Alignment with Trends</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Image Optimization</td>\n<td>High (60%+ bandwidth savings)</td>\n<td>Medium (requires image libraries)</td>\n<td>Medium (CPU intensive)</td>\n<td>High (Core Web Vitals)</td>\n</tr>\n<tr>\n<td>WebSocket Proxying</td>\n<td>Medium (real-time apps)</td>\n<td>High (stateful connections)</td>\n<td>High (connection management)</td>\n<td>Medium (growing but not universal)</td>\n</tr>\n<tr>\n<td>Object Storage Integration</td>\n<td>High (cloud-native apps)</td>\n<td>Low (protocol translation)</td>\n<td>Low (stateless)</td>\n<td>High (cloud migration)</td>\n</tr>\n<tr>\n<td>Predictive Prefetching</td>\n<td>Medium (reduced latency)</td>\n<td>High (ML/pattern analysis)</td>\n<td>Medium (extra origin load)</td>\n<td>Medium (established technique)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Start with object storage integration—it provides immediate value for modern applications with relatively low complexity. Follow with image optimization, which delivers tangible performance improvements users can feel.</p>\n</blockquote>\n<h3 id=\"testing-extended-functionality\">Testing Extended Functionality</h3>\n<p>Each extension requires specific testing strategies:</p>\n<table>\n<thead>\n<tr>\n<th>Extension</th>\n<th>Test Category</th>\n<th>Specific Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Image Optimization</td>\n<td>Visual regression</td>\n<td>Ensure transformations don&#39;t corrupt images</td>\n</tr>\n<tr>\n<td>WebSocket Proxying</td>\n<td>Load/stress testing</td>\n<td>Handle thousands of concurrent connections</td>\n</tr>\n<tr>\n<td>Object Storage</td>\n<td>Integration testing</td>\n<td>Mock S3 API with moto or localstack</td>\n</tr>\n<tr>\n<td>Edge Compute</td>\n<td>Security testing</td>\n<td>Fuzz testing for sandbox escape vulnerabilities</td>\n</tr>\n</tbody></table>\n<h3 id=\"migration-path-from-foundation-to-extended-cdn\">Migration Path from Foundation to Extended CDN</h3>\n<p>The modular design allows incremental adoption:</p>\n<p><strong>Phase 1: Foundation</strong> (Milestones 1-5) → Basic caching, routing, shielding\n<strong>Phase 2: Optimization</strong> (+Image optimization, +Advanced compression) → Better performance\n<strong>Phase 3: Modernization</strong> (+Object storage, +Prefetching) → Cloud-native compatibility<br><strong>Phase 4: Real-time</strong> (+WebSocket, +Edge compute) → Application platform</p>\n<p>Each phase delivers value independently while building toward a comprehensive edge delivery platform.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While full implementation of all extensions is beyond this foundational guide, here&#39;s how to approach the first natural extension: <strong>Object Storage Integration</strong>.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>S3 Client</td>\n<td><code>boto3</code> (Python AWS SDK)</td>\n<td>Custom HTTP client with connection pooling</td>\n</tr>\n<tr>\n<td>Authentication</td>\n<td>IAM instance profiles</td>\n<td>AssumeRole with temporary credentials</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Basic retry with exponential backoff</td>\n<td>Circuit breaker with fallback to HTTP origin</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>moto</code> library for mocking</td>\n<td>LocalStack for full S3 API simulation</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-module-structure\">B. Recommended Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>blue_origin/\n├── origins/                    # New package for origin implementations\n│   ├── __init__.py\n│   ├── base.py                # Abstract OriginClient\n│   ├── http_origin.py         # Existing HTTP origin client\n│   ├── s3_origin.py           # New S3 origin client\n│   └── multi_origin.py        # Fallback across multiple origins\n├── shield/\n│   └── handler.py             # Updated to use OriginClient interface\n└── config/\n    └── origin_config.py       # Origin-specific configuration</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># origins/base.py - Abstract interface for origin implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OriginClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract base class for origin implementations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fetch</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"GET\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body: Optional[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Fetch resource from origin.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> should_cache_response</span><span style=\"color:#E1E4E8\">(self, status_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine if response from this origin should be cached.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_cache_key_prefix</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get prefix for cache keys from this origin (for isolation).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># origins/s3_origin.py - S3 implementation starter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> urllib.parse </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> urlparse, quote</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> aiohttp</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> S3OriginClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">OriginClient</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Origin client for Amazon S3 and compatible object storage.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        endpoint: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bucket: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        region: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"us-east-1\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        access_key: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        secret_key: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        session_token: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        use_iam_role: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.endpoint </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> endpoint.rstrip(</span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.bucket </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bucket</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.region </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> region</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.access_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> access_key</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.secret_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> secret_key</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.session_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> session_token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.use_iam_role </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> use_iam_role</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Connection pool for S3 requests</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.session </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> aiohttp.ClientSession()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _sign_request</span><span style=\"color:#E1E4E8\">(self, method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate AWS Signature Version 4 for the request.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement AWS SigV4 signing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This is complex but follows a standard algorithm:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 1. Create canonical request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 2. Create string to sign</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 3. Calculate signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # 4. Add authorization header</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> fetch</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        method: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"GET\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        body: Optional[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Fetch object from S3.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> headers </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Build S3 URL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s3_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> quote(path.lstrip(</span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        url </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.endpoint</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.bucket</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">s3_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Add S3-specific headers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        s3_headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> headers.copy()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> body:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s3_headers[</span><span style=\"color:#9ECBFF\">'Content-Length'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(body))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Sign the request if using credentials</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.access_key </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.secret_key:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            s3_headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._sign_request(method, path, s3_headers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Make request to S3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.session.request(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            method</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">method,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            url</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">url,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_headers,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            data</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> response:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response.status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            response_headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> dict</span><span style=\"color:#E1E4E8\">(response.headers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            response_body </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> response.read()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Convert S3 errors to appropriate HTTP status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#F97583\"> and</span><span style=\"color:#9ECBFF\"> 'Error'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> response_headers.get(</span><span style=\"color:#9ECBFF\">'x-amz-error-code'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # S3 returns 404 for missing objects, which is correct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 403</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Permission denied - might want to log this differently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> status, response_headers, response_body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> should_cache_response</span><span style=\"color:#E1E4E8\">(self, status_code: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"S3-specific caching logic.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Cache successful GETs and 404s (negative caching)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> status_code </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 200</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> status_code </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 404</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Negative cache 404s for shorter TTL</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_cache_key_prefix</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Isolate S3 cache entries from HTTP origin entries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"s3:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.bucket</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> close</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Cleanup connection pool.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.session.close()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># config/origin_config.py - Configuration for multiple origin types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pydantic </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BaseModel</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OriginType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HTTP</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"http\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    S3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"s3\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GOOGLE_STORAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"google_storage\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AZURE_BLOB</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"azure_blob\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HttpOriginConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseModel</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    url: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    health_check_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"/health\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> S3OriginConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseModel</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    endpoint: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bucket: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    region: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"us-east-1\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    access_key: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    secret_key: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    use_iam_role: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    force_path_style: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OriginConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BaseModel</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: OriginType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config: Union[HttpOriginConfig, S3OriginConfig, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fallback_to: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # List of other origin IDs to try</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-for-shield-integration\">D. Core Logic Skeleton for Shield Integration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># shield/handler.py - Updated to support multiple origin types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> origins.base </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> OriginClient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> origins.s3_origin </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> S3OriginClient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> origins.http_origin </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HttpOriginClient</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ShieldRequestHandler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache: CacheStorage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        origin_configs: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, OriginConfig],  </span><span style=\"color:#6A737D\"># Multiple origins by ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        default_origin: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># ID of default origin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        coalescing_map: RequestCoalescingMap,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        max_concurrent_requests: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cache</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.origin_configs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> origin_configs</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.default_origin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> default_origin</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.coalescing_map </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> coalescing_map</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._origin_semaphore </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.Semaphore(max_concurrent_requests)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Initialize origin clients</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.origin_clients: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, OriginClient] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._init_origin_clients()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _init_origin_clients</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize origin clients from configuration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> origin_id, config </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.origin_configs.items():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> config.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> OriginType.</span><span style=\"color:#79B8FF\">HTTP</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.origin_clients[origin_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HttpOriginClient(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    base_url</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">config.config.url,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">config.config.timeout_seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> config.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> OriginType.S3:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                s3_config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config.config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.origin_clients[origin_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> S3OriginClient(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    endpoint</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_config.endpoint,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    bucket</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_config.bucket,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    region</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_config.region,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    access_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_config.access_key,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    secret_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_config.secret_key,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    use_iam_role</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">s3_config.use_iam_role</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add other origin types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _determine_origin</span><span style=\"color:#E1E4E8\">(self, request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine which origin to use for this request.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for X-Origin-Override header for explicit origin selection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse URL path to determine bucket/namespace for routing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check origin health status (circuit breakers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return origin ID or raise exception if no healthy origin</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.default_origin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> handle_request</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request_body: Optional[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ) -> Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # ... existing cache logic ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # On cache miss or need to revalidate:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        origin_id </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._determine_origin(request_headers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        origin_client </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.origin_clients[origin_id]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add origin-specific cache key prefix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_key </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._generate_cache_key(request_headers, origin_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Use the generic origin client interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        async</span><span style=\"color:#F97583\"> with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._origin_semaphore:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            status, headers, body </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> origin_client.fetch(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                path</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">request_path,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                method</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">request_method,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">request_headers,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                body</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">request_body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store with origin-specific TTL logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> origin_client.should_cache_response(status, headers):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cache_entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CacheEntry.from_upstream_response(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                key</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">cache_key,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                url</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">request_url,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                vary_headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">vary_dict,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                status_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">status,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">headers,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                body</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">body,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                surrogate_keys</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._extract_surrogate_keys(headers)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cache.store(cache_entry)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> status, headers, body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _revalidate_in_background</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stale_entry: CacheEntry, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        request_headers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Revalidate with appropriate origin based on cache entry metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract origin ID from cache key or entry metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get origin client for that origin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Perform conditional revalidation (If-None-Match, If-Modified-Since)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update cache if changed, respecting origin-specific caching rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-python\">E. Language-Specific Hints for Python</h4>\n<ul>\n<li>Use <code>aioboto3</code> for async S3 operations instead of synchronous <code>boto3</code></li>\n<li>Implement connection pooling with <code>aiohttp.ClientSession</code> for S3 requests</li>\n<li>Use <code>pydantic</code> for configuration validation with discriminated unions</li>\n<li>Consider <code>smart_open</code> library for streaming large files from S3 efficiently</li>\n<li>For image optimization, <code>Pillow</code> is the standard library, but consider <code>wand</code> (ImageMagick bindings) for advanced transformations</li>\n</ul>\n<h4 id=\"f-testing-extended-features\">F. Testing Extended Features</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/test_s3_origin.py - Example test with moto</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> boto3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> moto </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> mock_s3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> origins.s3_origin </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> S3OriginClient</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@mock_s3</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.mark.asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> test_s3_origin_fetch</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test fetching object from mocked S3.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Setup mock S3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s3 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> boto3.client(</span><span style=\"color:#9ECBFF\">'s3'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">region_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'us-east-1'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s3.create_bucket(</span><span style=\"color:#FFAB70\">Bucket</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'test-bucket'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s3.put_object(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        Bucket</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'test-bucket'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        Key</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'test/image.jpg'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        Body</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">b</span><span style=\"color:#9ECBFF\">'test image content'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        ContentType</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'image/jpeg'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create S3 origin client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> S3OriginClient(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        endpoint</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'http://localhost:4566'</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># LocalStack default</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        bucket</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'test-bucket'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        region</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'us-east-1'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        access_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'test'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        secret_key</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'test'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Fetch object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    status, headers, body </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> client.fetch(</span><span style=\"color:#9ECBFF\">'test/image.jpg'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 200</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> headers[</span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'image/jpeg'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> body </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'test image content'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client.close()</span></span></code></pre></div>\n\n<h4 id=\"g-migration-strategy\">G. Migration Strategy</h4>\n<ol>\n<li><strong>Phase 1</strong>: Add S3 origin support alongside existing HTTP origin</li>\n<li><strong>Phase 2</strong>: Implement origin routing based on URL prefixes (<code>/s3/*</code> → S3, <code>/*</code> → HTTP)</li>\n<li><strong>Phase 3</strong>: Add health checking and failover between origins</li>\n<li><strong>Phase 4</strong>: Implement S3 event notifications for cache invalidation</li>\n</ol>\n<p>Each phase can be tested and deployed independently, demonstrating the value of incremental extension to a well-architected foundation.</p>\n<hr>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1 through 5)</p>\n</blockquote>\n<p>This glossary provides definitions for key terms, acronyms, and domain-specific vocabulary used throughout the Blue Origin CDN design document. Understanding these terms is essential for navigating the complex distributed systems concepts involved in building a content delivery network.</p>\n<h3 id=\"term-definitions\">Term Definitions</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Anycast</strong></td>\n<td>A network addressing and routing method where the same IP address is announced from multiple locations. When a client sends a request to an anycast IP, network routers direct it to the nearest (in terms of routing hops) location announcing that IP. This is commonly used in CDNs for global load balancing without DNS.</td>\n</tr>\n<tr>\n<td><strong>Background Revalidation</strong></td>\n<td>The process of asynchronously fetching updated content from the origin server while continuing to serve stale cached content to clients. This enables <code>stale-while-revalidate</code> behavior where users get fast responses while the cache is refreshed in the background.</td>\n</tr>\n<tr>\n<td><strong>Ban</strong></td>\n<td>A pattern-based invalidation rule that matches URLs using wildcards or regular expressions. When a URL matches a ban rule, the corresponding cache entry is either immediately removed (hard ban) or marked stale (soft ban). Bans are useful for invalidating entire categories of content like <code>/api/v1/users/*</code>.</td>\n</tr>\n<tr>\n<td><strong>Ban Rule</strong></td>\n<td>A data structure representing a pattern-based invalidation rule with fields including <code>pattern</code> (string pattern to match URLs), <code>created_at</code> (timestamp), and <code>is_soft</code> (boolean indicating whether it&#39;s a soft or hard ban). Ban rules have TTLs and are garbage collected when expired.</td>\n</tr>\n<tr>\n<td><strong>Byte Range</strong></td>\n<td>A specification of start and end byte positions for partial content delivery, represented as a tuple <code>(start, end)</code> where <code>end</code> is optional. Used in HTTP Range requests to request specific portions of large files like videos.</td>\n</tr>\n<tr>\n<td><strong>Cache Entry</strong></td>\n<td>The core data structure holding a cached HTTP response, including fields like <code>key</code> (unique cache identifier), <code>url</code> (original request URL), <code>vary_headers</code> (dictionary of Vary header values), <code>status_code</code>, <code>headers</code>, <code>body</code>, <code>fetched_at</code> (timestamp when fetched), <code>expires_at</code> (timestamp when entry expires), <code>last_used_at</code> (timestamp of last access), <code>use_count</code> (access count for LFU), <code>surrogate_keys</code> (list of tags), <code>etag</code>, and <code>last_modified</code>.</td>\n</tr>\n<tr>\n<td><strong>Cache Hit</strong></td>\n<td>A request that is successfully served from the edge cache without contacting the origin server. This represents optimal performance as the response is delivered from a nearby location with minimal latency.</td>\n</tr>\n<tr>\n<td><strong>Cache Hit Ratio</strong></td>\n<td>The percentage of requests served from cache versus total requests, calculated as <code>hits / (hits + misses)</code>. A key performance metric for CDNs indicating caching efficiency. Higher ratios mean less origin load and faster responses.</td>\n</tr>\n<tr>\n<td><strong>Cache Key</strong></td>\n<td>A unique identifier for a cached response constructed from the URL and values of headers specified in the Vary header. For example, if Vary includes &quot;Accept-Encoding&quot;, then requests for <code>/image.jpg</code> with &quot;gzip&quot; and &quot;br&quot; Accept-Encoding values generate different cache keys.</td>\n</tr>\n<tr>\n<td><strong>Cache Miss</strong></td>\n<td>A request that cannot be served from cache and must be fetched from the upstream source (origin shield or origin server). This occurs when content is not cached, has expired, or has been invalidated.</td>\n</tr>\n<tr>\n<td><strong>Cache Miss Storm</strong></td>\n<td>A sudden surge of cache misses that overwhelms the origin server, often occurring when popular content expires simultaneously or after a cache invalidation. Origin shielding and request collapsing mitigate this problem.</td>\n</tr>\n<tr>\n<td><strong>Cache Poisoning</strong></td>\n<td>A security issue where malicious or incorrect content is cached and served to users. Can occur due to bugs in cache key generation, missing validation, or origin server compromise. Defensive measures include careful cache key construction and origin authentication.</td>\n</tr>\n<tr>\n<td><strong>Cache State Dump</strong></td>\n<td>A JSON representation of all cache entries for inspection and debugging purposes, typically exposed via a <code>/debug/cache</code> endpoint. Includes metadata but not response bodies to avoid exposing sensitive data.</td>\n</tr>\n<tr>\n<td><strong>Cache Storage</strong></td>\n<td>An abstract interface for cache storage implementations (in-memory, disk-based, distributed). Provides methods for storing, retrieving, and deleting cache entries. The CDN&#39;s caching logic works with this interface regardless of the underlying storage.</td>\n</tr>\n<tr>\n<td><strong>Circuit Breaker</strong></td>\n<td>A resilience pattern that prevents cascading failures by failing fast when upstream services are unhealthy. The circuit has three states: CLOSED (normal operation), OPEN (fail fast, no requests sent), and HALF_OPEN (testing if upstream has recovered). Implemented via the <code>CircuitBreaker</code> class with configurable thresholds.</td>\n</tr>\n<tr>\n<td><strong>CircuitBreakerConfig</strong></td>\n<td>Configuration parameters for a circuit breaker including <code>failure_threshold</code> (number of failures before opening), <code>reset_timeout</code> (time before attempting recovery), <code>half_open_max_requests</code> (max requests in half-open state), <code>half_open_success_threshold</code> (successes needed to close), and <code>max_failure_history</code> (how many failures to track).</td>\n</tr>\n<tr>\n<td><strong>Cold Start</strong></td>\n<td>The performance degradation that occurs when a new edge node starts with an empty cache. Until the cache warms up with frequently requested content, most requests will be cache misses, increasing latency and origin load. Mitigated by cache warming strategies and content prefetching.</td>\n</tr>\n<tr>\n<td><strong>Consistent Hashing</strong></td>\n<td>A distributed hashing technique that minimizes the number of keys that need to be remapped when nodes are added or removed from the system. Keys are mapped to a virtual ring (hash ring), and each node is assigned multiple positions on the ring. When looking up a key, you find the next node clockwise from the key&#39;s position.</td>\n</tr>\n<tr>\n<td><strong>Content Delivery Network (CDN)</strong></td>\n<td>A geographically distributed network of proxy servers (edge nodes) that caches content close to users to reduce latency, bandwidth usage, and origin server load. The CDN sits between users and origin servers, accelerating delivery of static and dynamic content.</td>\n</tr>\n<tr>\n<td><strong>Control Plane</strong></td>\n<td>The management layer of the CDN responsible for configuration distribution, analytics collection, health monitoring, and coordination between edge nodes. Handles administrative tasks like cache invalidation propagation but does not process user traffic.</td>\n</tr>\n<tr>\n<td><strong>Data Plane</strong></td>\n<td>The layer that handles actual user traffic (requests and responses) flowing through edge nodes. This is the performance-critical path where caching, compression, and routing decisions happen in real-time.</td>\n</tr>\n<tr>\n<td><strong>Device Pixel Ratio (DPR)</strong></td>\n<td>The ratio between physical pixels and CSS pixels on a device&#39;s display. High-DPR devices (like Retina displays) require higher resolution images. The CDN can use this value in image optimization to serve appropriately sized images.</td>\n</tr>\n<tr>\n<td><strong>DNS TTL</strong></td>\n<td>The Time-To-Live value in DNS records that controls how long DNS resolvers cache the response. In geo-routing, short DNS TTLs (e.g., 60 seconds) allow faster failover when edge nodes become unhealthy, at the cost of increased DNS query load.</td>\n</tr>\n<tr>\n<td><strong>Edge Compute</strong></td>\n<td>The capability to execute lightweight compute functions at edge nodes rather than at the origin. Enables personalization, A/B testing, security checks, and dynamic content generation close to users. Represented by the <code>EdgeFunction</code> and <code>EdgeFunctionRuntime</code> concepts.</td>\n</tr>\n<tr>\n<td><strong>Edge Node/Edge Server/PoP</strong></td>\n<td>A geographically distributed server in a CDN that caches and serves content to nearby users. Also called a Point of Presence (PoP). These nodes form the &quot;edge&quot; of the network closest to end users. Each edge node runs the caching logic described in Milestone 1.</td>\n</tr>\n<tr>\n<td><strong>Eventual Consistency</strong></td>\n<td>The property where updates (like cache invalidations) propagate to all nodes eventually, but not immediately. During the propagation window, some users may see stale content while others see fresh content. This trade-off is often accepted for scalability in distributed systems.</td>\n</tr>\n<tr>\n<td><strong>Eventual Invalidation</strong></td>\n<td>A lazy invalidation strategy where a banned cache entry is only removed when it is next accessed, not immediately. This reduces the immediate performance impact of sweeping invalidations but means stale content may remain in cache longer.</td>\n</tr>\n<tr>\n<td><strong>Flight Data Recorders</strong></td>\n<td>Diagnostic headers (like <code>X-Cache-Status</code>, <code>X-Cache-Key</code>, <code>X-Node-ID</code>) that document a request&#39;s path through the caching infrastructure. Analogous to aircraft black boxes, they provide visibility for debugging without impacting performance.</td>\n</tr>\n<tr>\n<td><strong>GeoIP Database</strong></td>\n<td>A database that maps IP addresses to geographic locations (country, region, city, coordinates). Used by the CDN&#39;s geo-routing system to direct clients to the nearest edge node. Requires regular updates as IP allocations change.</td>\n</tr>\n<tr>\n<td><strong>Geo-Routing</strong></td>\n<td>Directing user requests to the nearest optimal edge node based on geographic location. Uses client IP address lookup in a GeoIP database to determine approximate location, then selects the edge node with lowest network latency or geographic distance.</td>\n</tr>\n<tr>\n<td><strong>Geo Simulation</strong></td>\n<td>Techniques to simulate geographic distribution locally during development and testing, such as using IP address prefixes to represent regions or manually setting location headers. Helps test routing logic without deploying to multiple physical locations.</td>\n</tr>\n<tr>\n<td><strong>Graceful Degradation</strong></td>\n<td>A resilience strategy of serving stale content, reduced functionality, or cached error pages when upstream services are impaired. For example, serving stale content via <code>stale-if-error</code> when the origin server is down maintains availability at the cost of freshness.</td>\n</tr>\n<tr>\n<td><strong>Hard Purge</strong></td>\n<td>Immediate deletion of a cache entry from storage. The next request for that content will be a cache miss and fetch fresh content from origin. Provides strong consistency but may cause cache miss storms if popular content is purged.</td>\n</tr>\n<tr>\n<td><strong>Hash Ring</strong></td>\n<td>A virtual circle representing the hash space in consistent hashing, typically using a 32-bit or 64-bit integer range. Nodes are assigned positions on the ring via hash functions, and keys are mapped to the next node clockwise from their hash position.</td>\n</tr>\n<tr>\n<td><strong>Haversine Formula</strong></td>\n<td>An equation used in calculating great-circle distances between two points on a sphere given their longitudes and latitudes. Used in geo-routing to find the geographically closest edge node to a client&#39;s location.</td>\n</tr>\n<tr>\n<td><strong>Health Checking</strong></td>\n<td>The process of monitoring node availability and performance to ensure reliable routing. Edge nodes periodically report health metrics to the control plane, which removes unhealthy nodes from rotation. Health checks verify connectivity, latency, and resource utilization.</td>\n</tr>\n<tr>\n<td><strong>Image Optimization</strong></td>\n<td>On-the-fly resizing, format conversion (WebP, AVIF), compression, and quality adjustment of images at the edge based on device capabilities and network conditions. Reduces bandwidth usage and improves page load times. Represented by the <code>ImageTransformation</code> and <code>OptimizedImageCacheKey</code> structures.</td>\n</tr>\n<tr>\n<td><strong>Invalidation Propagation</strong></td>\n<td>The process of disseminating an invalidation command (purge, ban, tag purge) to all edge nodes in the CDN. Can use pub/sub messaging, control plane broadcasts, or gossip protocols to achieve eventual consistency across nodes.</td>\n</tr>\n<tr>\n<td><strong>Load Testing</strong></td>\n<td>Testing system behavior under production-like load to identify performance bottlenecks, capacity limits, and failure modes. For a CDN, load testing simulates many concurrent users requesting various content types to verify the system can handle peak traffic.</td>\n</tr>\n<tr>\n<td><strong>Negative Caching</strong></td>\n<td>Caching error responses (like 404 Not Found or 503 Service Unavailable) with a short TTL to protect the origin from repeated requests for non-existent or temporarily unavailable resources. Prevents &quot;cache miss storms&quot; for error conditions.</td>\n</tr>\n<tr>\n<td><strong>Node Failover</strong></td>\n<td>The process of redirecting traffic from a failed or unhealthy edge node to a backup node. When health checks detect a node failure, the routing system (DNS or anycast) updates to direct new clients to the next-nearest healthy node.</td>\n</tr>\n<tr>\n<td><strong>Object Storage Integration</strong></td>\n<td>Treating cloud object storage services (AWS S3, Google Cloud Storage, Azure Blob Storage) as first-class origins for the CDN. Requires handling authentication, bucket policies, and storage-specific APIs while maintaining caching semantics.</td>\n</tr>\n<tr>\n<td><strong>Origin Client</strong></td>\n<td>An abstract base class for fetching content from different types of origins (HTTP servers, S3 buckets, etc.). Subclasses like <code>S3OriginClient</code> implement origin-specific authentication and request handling while presenting a unified interface to the caching layer.</td>\n</tr>\n<tr>\n<td><strong>Origin Routing</strong></td>\n<td>Directing requests to different origins based on rules like path prefixes, hostnames, or geographic location. Enables multi-origin setups where different content comes from different backend systems while appearing as a unified CDN.</td>\n</tr>\n<tr>\n<td><strong>Origin Server</strong></td>\n<td>The ultimate source of truth for web content, also called the &quot;backend&quot; or &quot;source&quot; server. The CDN fetches content from origin servers when cache misses occur and serves cached copies to users. Origins should implement proper cache control headers.</td>\n</tr>\n<tr>\n<td><strong>Origin Shield/Mid-Tier Cache</strong></td>\n<td>An intermediate caching layer between edge nodes and the origin server that reduces origin load by acting as a shared cache for multiple edge nodes. The shield collapses duplicate requests and queues others, preventing thundering herd problems at the origin.</td>\n</tr>\n<tr>\n<td><strong>Predictive Prefetching</strong></td>\n<td>Automatically fetching content before users request it based on access patterns, link analysis, or machine learning predictions. For example, prefetching linked CSS and JavaScript files when a user requests an HTML page.</td>\n</tr>\n<tr>\n<td><strong>Propagation Delay</strong></td>\n<td>The time it takes for invalidation commands to reach all edge nodes in a distributed CDN. During this window, some users may receive stale content from nodes that haven&#39;t yet received the invalidation notice. Systems aim to minimize this delay.</td>\n</tr>\n<tr>\n<td><strong>Property-Based Testing</strong></td>\n<td>A testing methodology that verifies properties hold for all possible inputs rather than specific examples. For caching, properties might include &quot;cache hit should always return same response as original fetch&quot; or &quot;purge should always remove the entry&quot;.</td>\n</tr>\n<tr>\n<td><strong>Pub/Sub Broker</strong></td>\n<td>A message broker that implements the publish-subscribe pattern, allowing components to broadcast messages to multiple subscribers. The <code>InMemoryPubSubBroker</code> handles invalidation propagation within a single process, while production systems use distributed brokers like Redis or Kafka.</td>\n</tr>\n<tr>\n<td><strong>Pub/Sub Channel</strong></td>\n<td>A named message bus topic for publish-subscribe messaging. In the CDN, channels like <code>invalidation</code> or <code>health</code> allow edge nodes to subscribe to relevant updates without knowing about other subscribers.</td>\n</tr>\n<tr>\n<td><strong>Race Condition</strong></td>\n<td>When system behavior depends on the sequence or timing of uncontrollable events. In caching, race conditions can occur when multiple threads simultaneously check cache, miss, and fetch from origin, causing duplicate origin requests or cache corruption.</td>\n</tr>\n<tr>\n<td><strong>Range Request</strong></td>\n<td>An HTTP request for partial content using the Range header (e.g., <code>Range: bytes=0-999</code>). Used for video streaming, large file downloads, and resumable transfers. The CDN must handle range requests efficiently without fetching entire files.</td>\n</tr>\n<tr>\n<td><strong>Request Coalescing Map</strong></td>\n<td>An in-memory data structure that tracks in-flight requests for deduplication. When multiple clients request the same uncached resource concurrently, the map ensures only one origin fetch occurs, and all clients wait for that single result.</td>\n</tr>\n<tr>\n<td><strong>Request Collapsing</strong></td>\n<td>Deduplicating concurrent identical requests to the origin. When multiple edge nodes or clients request the same uncached content simultaneously, the shield collapses them into a single origin fetch and shares the response with all requesters.</td>\n</tr>\n<tr>\n<td><strong>Request Tracing</strong></td>\n<td>Tracking a request through all CDN layers using unique IDs (like <code>X-Request-ID</code>) that are propagated across service boundaries. Enables distributed debugging by correlating logs and timing information across edge nodes, shields, and origins.</td>\n</tr>\n<tr>\n<td><strong>Soft Purge</strong></td>\n<td>Marking a cache entry as stale while continuing to serve it to clients, then triggering background revalidation from the origin. Provides better user experience than hard purge (no cache miss penalty) but may serve stale content briefly.</td>\n</tr>\n<tr>\n<td><strong>Stale-if-error</strong></td>\n<td>A Cache-Control directive that allows serving stale content when the origin server returns an error (5xx status). This provides graceful degradation during origin outages, maintaining availability at the cost of freshness.</td>\n</tr>\n<tr>\n<td><strong>Stale-while-revalidate</strong></td>\n<td>A Cache-Control directive that allows serving stale content while asynchronously revalidating it in the background. Users get fast responses from cache while the system ensures content freshness for subsequent requests.</td>\n</tr>\n<tr>\n<td><strong>Surrogate Key</strong></td>\n<td>A tag (string identifier) assigned to cache entries for group-based invalidation. Multiple resources (like all images in a product catalog) can share a surrogate key, allowing invalidation of all related content with a single purge command.</td>\n</tr>\n<tr>\n<td><strong>Test Fixture</strong></td>\n<td>Reusable setup and teardown code for tests that creates a known state before tests run and cleans up afterward. For CDN testing, fixtures might start a test origin server, create cache entries, or simulate network conditions.</td>\n</tr>\n<tr>\n<td><strong>Thundering Herd Problem</strong></td>\n<td>A stampede of concurrent requests overwhelming a resource, typically occurring when cached content expires simultaneously or after a cache invalidation. The sudden spike of cache misses can overload origin servers. Mitigated by request collapsing, staggered TTLs, and cache warming.</td>\n</tr>\n<tr>\n<td><strong>Time-to-Live (TTL)</strong></td>\n<td>The duration a cached item is considered fresh before it needs revalidation. Determined by cache control headers with hierarchy: <code>s-maxage</code> (for shared caches) &gt; <code>max-age</code> &gt; <code>Expires</code>. The CDN calculates <code>expires_at = fetched_at + TTL</code> for each cache entry.</td>\n</tr>\n<tr>\n<td><strong>TTL Hierarchy</strong></td>\n<td>The precedence order for TTL determination: <code>s-maxage</code> (for shared caches like CDNs) takes precedence over <code>max-age</code>, which takes precedence over <code>Expires</code> header. The CDN uses <code>s-maxage</code> when present since it&#39;s specifically for intermediary caches.</td>\n</tr>\n<tr>\n<td><strong>Vary Header</strong></td>\n<td>An HTTP response header that indicates which request headers the response varies on. For example, <code>Vary: Accept-Encoding</code> means responses differ based on the client&#39;s Accept-Encoding header value, requiring separate cache entries for gzip, br, and identity encodings.</td>\n</tr>\n<tr>\n<td>**Vary: ***</td>\n<td>A special value of the Vary header indicating the response varies on all request headers. According to RFC 9111, this means the response should never be stored in a shared cache, as it&#39;s essentially uncacheable for different clients.</td>\n</tr>\n<tr>\n<td><strong>Virtual Node</strong></td>\n<td>Multiple hash positions on a consistent hash ring representing a single physical node. Using multiple virtual nodes per physical node (e.g., 100-200) provides better load distribution and minimizes hotspotting when nodes are added or removed.</td>\n</tr>\n<tr>\n<td><strong>WebSocket Proxying</strong></td>\n<td>Extending the CDN to proxy WebSocket connections between clients and origins, maintaining the bidirectional communication channel while providing caching for initial handshake and potential message inspection/transformation.</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"Blue Origin: A Foundational CDN for Learning Distributed Systems","id":"blue-origin-a-foundational-cdn-for-learning-distributed-systems"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Global Library System","id":"mental-model-the-global-library-system"},{"level":3,"text":"The Core Delivery Problem","id":"the-core-delivery-problem"},{"level":3,"text":"Existing Approaches &amp; Vocabulary","id":"existing-approaches-amp-vocabulary"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Goals (What We Must Build)","id":"goals-what-we-must-build"},{"level":3,"text":"Non-Goals (What We Explicitly Won&#39;t Build)","id":"non-goals-what-we-explicitly-won39t-build"},{"level":4,"text":"Why These Boundaries Matter","id":"why-these-boundaries-matter"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview &amp; Responsibilities","id":"component-overview-amp-responsibilities"},{"level":4,"text":"Detailed Component Specifications","id":"detailed-component-specifications"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Module Dependencies and Import Structure","id":"module-dependencies-and-import-structure"},{"level":4,"text":"Configuration Management","id":"configuration-management"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Complete HTTP Utilities Starter Code","id":"b-complete-http-utilities-starter-code"},{"level":4,"text":"C. Core Data Model Skeleton","id":"c-core-data-model-skeleton"},{"level":4,"text":"D. Edge Request Handler Skeleton","id":"d-edge-request-handler-skeleton"},{"level":4,"text":"E. Python-Specific Implementation Hints","id":"e-python-specific-implementation-hints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Core: The Cache Entry","id":"core-the-cache-entry"},{"level":3,"text":"Structures for Invalidation","id":"structures-for-invalidation"},{"level":4,"text":"Surrogate Key Index","id":"surrogate-key-index"},{"level":4,"text":"Ban Rule","id":"ban-rule"},{"level":3,"text":"Structures for Analytics","id":"structures-for-analytics"},{"level":4,"text":"Edge Node Metrics","id":"edge-node-metrics"},{"level":4,"text":"Shield &amp; Origin Metrics","id":"shield-amp-origin-metrics"},{"level":4,"text":"Time-Windowed Metrics","id":"time-windowed-metrics"},{"level":3,"text":"Common Pitfalls in Data Modeling","id":"common-pitfalls-in-data-modeling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code (Cache Directives &amp; HTTP Utilities)","id":"c-infrastructure-starter-code-cache-directives-amp-http-utilities"},{"level":4,"text":"D. Core Logic Skeleton Code (Data Model Classes)","id":"d-core-logic-skeleton-code-data-model-classes"},{"level":4,"text":"E. Language-Specific Hints (Python)","id":"e-language-specific-hints-python"},{"level":4,"text":"F. Milestone Checkpoint (Data Model)","id":"f-milestone-checkpoint-data-model"},{"level":2,"text":"Component: Edge Cache (Milestone 1 &amp; 5)","id":"component-edge-cache-milestone-1-amp-5"},{"level":3,"text":"Mental Model: The Smart Mailroom","id":"mental-model-the-smart-mailroom"},{"level":3,"text":"Interface &amp; HTTP Flow","id":"interface-amp-http-flow"},{"level":3,"text":"Cache Key &amp; TTL Management","id":"cache-key-amp-ttl-management"},{"level":3,"text":"ADR: Cache Storage &amp; Eviction Policy","id":"adr-cache-storage-amp-eviction-policy"},{"level":3,"text":"Common Pitfalls in Edge Caching","id":"common-pitfalls-in-edge-caching"},{"level":3,"text":"Implementation Guidance for Edge Cache","id":"implementation-guidance-for-edge-cache"},{"level":2,"text":"Component: Cache Invalidation (Milestone 2)","id":"component-cache-invalidation-milestone-2"},{"level":3,"text":"Mental Model: The Building Eviction Notice","id":"mental-model-the-building-eviction-notice"},{"level":3,"text":"Purge, Ban, and Tag-Based Invalidation","id":"purge-ban-and-tag-based-invalidation"},{"level":4,"text":"1. Purge by Exact URL","id":"1-purge-by-exact-url"},{"level":4,"text":"2. Ban by Pattern (Eventual Invalidation)","id":"2-ban-by-pattern-eventual-invalidation"},{"level":4,"text":"3. Tag-Based Invalidation with Surrogate Keys","id":"3-tag-based-invalidation-with-surrogate-keys"},{"level":3,"text":"Invalidation Propagation Strategy","id":"invalidation-propagation-strategy"},{"level":3,"text":"ADR: Invalidation Propagation Mechanism","id":"adr-invalidation-propagation-mechanism"},{"level":3,"text":"Common Pitfalls in Invalidation","id":"common-pitfalls-in-invalidation"},{"level":3,"text":"Implementation Guidance for Invalidation","id":"implementation-guidance-for-invalidation"},{"level":2,"text":"Component: Origin Shield &amp; Request Collapsing (Milestone 3)","id":"component-origin-shield-amp-request-collapsing-milestone-3"},{"level":3,"text":"Mental Model: The Concert Vestibule","id":"mental-model-the-concert-vestibule"},{"level":3,"text":"Shield Logic &amp; Request Collapsing","id":"shield-logic-amp-request-collapsing"},{"level":3,"text":"ADR: To Shield or Not To Shield","id":"adr-to-shield-or-not-to-shield"},{"level":3,"text":"Common Pitfalls in Shielding","id":"common-pitfalls-in-shielding"},{"level":3,"text":"Implementation Guidance for Origin Shield","id":"implementation-guidance-for-origin-shield"},{"level":2,"text":"Component: Edge Node Distribution &amp; Routing (Milestone 4)","id":"component-edge-node-distribution-amp-routing-milestone-4"},{"level":3,"text":"Mental Model: The Air Traffic Control Map","id":"mental-model-the-air-traffic-control-map"},{"level":3,"text":"Geo-Routing &amp; Health Checking","id":"geo-routing-amp-health-checking"},{"level":4,"text":"How Client IPs Map to Edge Nodes","id":"how-client-ips-map-to-edge-nodes"},{"level":4,"text":"Health Checking Implementation","id":"health-checking-implementation"},{"level":3,"text":"Consistent Hashing for Cache Distribution","id":"consistent-hashing-for-cache-distribution"},{"level":4,"text":"The Problem: Cache Distribution &amp; Reshuffling","id":"the-problem-cache-distribution-amp-reshuffling"},{"level":4,"text":"Consistent Hashing Solution","id":"consistent-hashing-solution"},{"level":3,"text":"ADR: Client Routing Mechanism","id":"adr-client-routing-mechanism"},{"level":3,"text":"Common Pitfalls in Distribution","id":"common-pitfalls-in-distribution"},{"level":3,"text":"Implementation Guidance for Distribution","id":"implementation-guidance-for-distribution"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Python-Specific Hints","id":"e-python-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Data Flow: Cache Hit at Edge","id":"data-flow-cache-hit-at-edge"},{"level":3,"text":"Data Flow: Cache Miss with Origin Shield","id":"data-flow-cache-miss-with-origin-shield"},{"level":3,"text":"Control Flow: Global Cache Invalidation","id":"control-flow-global-cache-invalidation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Failure Modes &amp; Recovery Strategies","id":"failure-modes-amp-recovery-strategies"},{"level":4,"text":"Mental Model: The Redundant Bridge System","id":"mental-model-the-redundant-bridge-system"},{"level":4,"text":"Catalog of Failure Modes and Recovery Strategies","id":"catalog-of-failure-modes-and-recovery-strategies"},{"level":4,"text":"ADR: Stale Content Serving Strategy","id":"adr-stale-content-serving-strategy"},{"level":4,"text":"Implementation of Failure Recovery","id":"implementation-of-failure-recovery"},{"level":3,"text":"HTTP Edge Cases","id":"http-edge-cases"},{"level":4,"text":"Mental Model: The Quirky Mailroom Clerk","id":"mental-model-the-quirky-mailroom-clerk"},{"level":4,"text":"Handling Complex HTTP Caching Scenarios","id":"handling-complex-http-caching-scenarios"},{"level":4,"text":"ADR: Handling Vary: * - To Cache or Not to Cache","id":"adr-handling-vary-to-cache-or-not-to-cache"},{"level":4,"text":"Range Request Implementation Details","id":"range-request-implementation-details"},{"level":4,"text":"Common Pitfalls in Error Handling","id":"common-pitfalls-in-error-handling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Circuit Breaker Implementation","id":"infrastructure-starter-code-circuit-breaker-implementation"},{"level":4,"text":"Core Logic Skeleton: Range Request Handler","id":"core-logic-skeleton-range-request-handler"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Testing Approaches &amp; Properties","id":"testing-approaches-amp-properties"},{"level":4,"text":"Mental Model: The Four-Layer Inspection Protocol","id":"mental-model-the-four-layer-inspection-protocol"},{"level":4,"text":"Property-Based Testing for Cache Correctness","id":"property-based-testing-for-cache-correctness"},{"level":4,"text":"Integration Testing Strategy","id":"integration-testing-strategy"},{"level":4,"text":"Load Testing for Origin Protection","id":"load-testing-for-origin-protection"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1: Edge Cache Implementation","id":"milestone-1-edge-cache-implementation"},{"level":4,"text":"Milestone 2: Cache Invalidation","id":"milestone-2-cache-invalidation"},{"level":4,"text":"Milestone 3: Origin Shield &amp; Request Collapsing","id":"milestone-3-origin-shield-amp-request-collapsing"},{"level":4,"text":"Milestone 4: Edge Node Distribution &amp; Routing","id":"milestone-4-edge-node-distribution-amp-routing"},{"level":4,"text":"Milestone 5: CDN Analytics &amp; Performance Optimization","id":"milestone-5-cdn-analytics-amp-performance-optimization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Symptom → Cause → Fix Table","id":"symptom-cause-fix-table"},{"level":3,"text":"CDN-Specific Debugging Techniques","id":"cdn-specific-debugging-techniques"},{"level":4,"text":"Adding Diagnostic Headers to HTTP Responses","id":"adding-diagnostic-headers-to-http-responses"},{"level":4,"text":"Inspecting Cache State and Metrics","id":"inspecting-cache-state-and-metrics"},{"level":4,"text":"Simulating Geo-Distribution Locally","id":"simulating-geo-distribution-locally"},{"level":4,"text":"Request Tracing and Log Correlation","id":"request-tracing-and-log-correlation"},{"level":4,"text":"Testing Cache Invalidation Propagation","id":"testing-cache-invalidation-propagation"},{"level":4,"text":"Common HTTP Edge Case Testing","id":"common-http-edge-case-testing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: The Highway System Evolution","id":"mental-model-the-highway-system-evolution"},{"level":3,"text":"Potential Enhancements","id":"potential-enhancements"},{"level":4,"text":"1. Predictive Prefetching and Cache Warming","id":"1-predictive-prefetching-and-cache-warming"},{"level":4,"text":"2. Image Optimization at the Edge","id":"2-image-optimization-at-the-edge"},{"level":4,"text":"3. WebSocket Proxying and Edge Compute","id":"3-websocket-proxying-and-edge-compute"},{"level":4,"text":"4. Object Storage Integration as Origin","id":"4-object-storage-integration-as-origin"},{"level":4,"text":"5. Additional Extension Ideas","id":"5-additional-extension-ideas"},{"level":3,"text":"Architectural Principles for Extensibility","id":"architectural-principles-for-extensibility"},{"level":3,"text":"Prioritization Framework","id":"prioritization-framework"},{"level":3,"text":"Testing Extended Functionality","id":"testing-extended-functionality"},{"level":3,"text":"Migration Path from Foundation to Extended CDN","id":"migration-path-from-foundation-to-extended-cdn"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended Module Structure","id":"b-recommended-module-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton for Shield Integration","id":"d-core-logic-skeleton-for-shield-integration"},{"level":4,"text":"E. Language-Specific Hints for Python","id":"e-language-specific-hints-for-python"},{"level":4,"text":"F. Testing Extended Features","id":"f-testing-extended-features"},{"level":4,"text":"G. Migration Strategy","id":"g-migration-strategy"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Term Definitions","id":"term-definitions"}],"title":"Blue Origin: A Foundational CDN for Learning Distributed Systems","markdown":"# Blue Origin: A Foundational CDN for Learning Distributed Systems\n\n\n## Overview\n\nThis project builds a foundational Content Delivery Network (CDN) that accelerates web content delivery by caching copies at geographically distributed 'edge' servers. The key architectural challenge is designing a multi-tiered, consistent, and resilient caching system that dramatically reduces latency and origin load while handling real-world complexities like invalidation and request storms.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides the foundational understanding and motivation for the entire CDN project. It underpins the challenges addressed by all five milestones.\n\nDelivering web content at a global scale presents a fundamental engineering challenge. When a user in Tokyo clicks a link hosted on a server in New York, the request and the data must travel across thousands of miles of network infrastructure. This journey is fraught with latency, bottlenecks, and points of failure. A **Content Delivery Network (CDN)** is the distributed systems solution to this problem, transforming the internet's architecture from a hub-and-spoke model into a mesh of local delivery points. Building a CDN is a classic, complex distributed systems problem because it requires elegantly balancing consistency, performance, resilience, and scale across many independent nodes. Before we delve into *how* to build one, we must deeply understand the *why*—the core problem it solves and the architectural constraints it operates within.\n\n### Mental Model: The Global Library System\n\nImagine a single, massive central library (the **Origin Server**) that holds every book (web resource) for a worldwide audience. A reader (the **Client**) in a distant city wants a popular novel. Under the naive model, the reader must request the book from the central library, wait for it to be packaged and shipped across continents, and then receive it. This is slow, expensive in shipping costs (bandwidth), and overwhelms the central library's staff (CPU) and shipping docks (network interface) whenever a book becomes popular.\n\nA CDN is analogous to building a network of local branch libraries (**Edge Caches**) in every major city. When the first reader in Tokyo requests the novel, the local branch fetches a copy from the central library and stores it on its own shelves. When the next reader in Tokyo requests the same book, the branch library can serve it immediately from its local stock—a **Cache Hit**. The experience is dramatically faster, cheaper, and relieves the central library.\n\nThis simple analogy breaks down at scale, revealing the true complexity:\n*   **Shelf Space Management:** Branch libraries have limited shelf space (memory/disk). They must decide which books to keep (**Cache Eviction Policy**) when new ones arrive.\n*   **Updated Editions:** When the central library releases a revised edition of the novel (the origin content changes), all branch copies become outdated. The system needs a way to notify branches to discard their old copies (**Cache Invalidation**).\n*   **Rush Hours:** If a famous author announces a new book at noon, thousands of readers might arrive at their local branch at the same moment before any copy is on the shelf. If every branch then simultaneously calls the central library, it will be overwhelmed (**Cache Miss Storm**). A smart system might have regional distribution centers (**Origin Shields**) that coordinate a single fetch and then supply all local branches.\n*   **Finding Your Nearest Branch:** A reader must be directed to their closest, operational branch (**Geo-Routing** and **Health Checking**), not just the geographically nearest one that might be closed for maintenance.\n\nThis project, Blue Origin, is about designing and building the systems and protocols that make this \"global library network\" intelligent, efficient, and robust.\n\n### The Core Delivery Problem\n\nServing content from a single origin server to a global user base creates three critical, interconnected problems:\n\n1.  **Latency (The Speed of Light Problem):** Network latency is governed by physics. A request/response round-trip between Tokyo and New York cannot be faster than the time light takes to travel that distance through fiber optics, which is roughly 100-200 milliseconds for a single trip. When a webpage requires dozens of resources (HTML, CSS, JavaScript, images), this delay compounds, leading to slow page loads. The **propagation delay** is fixed; the only way to reduce it is to shorten the physical distance between the user and the content.\n\n2.  **Origin Load & Scalability (The Stampede Problem):** An origin server has finite capacity—CPU, memory, network bandwidth, and I/O. A sudden surge in traffic (a \"flash crowd\" from a popular news article or a product launch) can easily exceed this capacity, causing the server to slow to a crawl or crash. This is economically inefficient; serving a static image file does not require the origin's expensive application logic, yet it consumes critical resources. The goal is to **offload** repetitive, simple work from the origin.\n\n3.  **Availability & Resilience (The Single Point of Failure Problem):** A single origin server (or even a single data center) represents a **single point of failure**. A network partition, a power outage, or a hardware failure in that location can make the service entirely unavailable to all users, everywhere. A distributed system must be designed to **degrade gracefully**, continuing to serve users even when components fail.\n\nThe CDN directly attacks these three problems:\n*   **Against Latency:** By placing **edge nodes** in hundreds of locations (**Points of Presence**, or PoPs) close to users, the physical distance for most requests is reduced to tens of miles, cutting latency from hundreds of milliseconds to single-digit milliseconds.\n*   **Against Origin Load:** By **caching** (storing) copies of content at the edge, repeated requests for the same resource are served locally without touching the origin. This can reduce origin traffic by 90% or more for cacheable content.\n*   **Against Availability Issues:** With many distributed edge nodes, the failure of one node affects only a subset of users. Furthermore, cached content can often be served even if the origin is temporarily unavailable (**Serve Stale**), providing a buffer for origin recovery.\n\nThe architectural challenge lies in making this distribution appear seamless, consistent, and automatic to both the end user and the content provider.\n\n### Existing Approaches & Vocabulary\n\nTo ground our design, it's essential to understand the landscape of existing solutions and establish a precise vocabulary.\n\n| Approach | Description | Key Characteristics | Relation to Our Project |\n| :--- | :--- | :--- | :--- |\n| **Commercial CDNs** (Cloudflare, Akamai, Fastly) | Full-service, global networks offering caching, security, load balancing, and optimization as a service. | Proprietary, massively scaled software and hardware. Use advanced routing (Anycast), extensive PoPs, and offer rich control APIs. | Our inspiration and conceptual blueprint. We are building a foundational, educational version of their core caching layer. |\n| **Open-Source Caching Proxies** (Varnish Cache, NGINX, Apache Traffic Server) | Software that can be deployed on a server to act as a reverse proxy with caching capabilities. | Single-node or manually configured clusters. Powerful configuration languages (VCL for Varnish). Often form the building blocks of DIY CDNs. | Our edge cache component will implement logic similar to Varnish's core HTTP caching. We use their design (e.g., surrogate keys) as a specification. |\n| **Cloud Provider CDN Services** (AWS CloudFront, Google Cloud CDN, Azure CDN) | Managed CDN services integrated with the provider's other cloud services (storage, compute). | Tightly coupled with the provider's ecosystem. Often simpler to set up but less customizable than commercial CDNs. | Illustrates the integration of a CDN with origin services (like object storage). |\n\n**Core Vocabulary**\nUnderstanding these terms is crucial for the rest of the document:\n\n*   **Origin / Origin Server:** The ultimate source of truth for content. This is the application server (e.g., `api.example.com`) or storage bucket (e.g., `assets.example.com`) that the CDN is protecting and accelerating.\n*   **Edge Node / Edge Server / PoP (Point of Presence):** A geographically distributed server that caches content and serves requests directly to users. It is the \"front line\" of the CDN.\n*   **Cache Hit:** When a user's request can be served entirely from the edge node's local cache. This is the ideal outcome, providing the lowest latency and zero origin load.\n*   **Cache Miss:** When the requested resource is not in the edge node's cache (or is stale and invalid). The edge node must fetch a fresh copy from upstream (either an origin shield or the origin itself).\n*   **Origin Shield / Mid-Tier Cache:** An optional caching layer between the edge nodes and the origin. It acts as a \"super-edge\" or regional aggregator to further reduce requests to the origin and provide request collapsing.\n*   **Control Plane:** The management and coordination layer of the CDN. It handles configuration distribution, analytics aggregation, and invalidation propagation. It is distinct from the **Data Plane** (the edge nodes) that handles user traffic.\n*   **TTL (Time-To-Live):** The duration, in seconds, that a cached resource is considered fresh. After this time, it becomes stale and should be revalidated or refetched.\n*   **Invalidation / Purging:** The active removal of content from the cache before its TTL expires, typically because the origin content has changed.\n*   **Geo-Routing:** Directing a user's request to the geographically closest (or otherwise optimal) edge node, often based on the user's IP address.\n\nThis project synthesizes principles from all these approaches. We take the robust HTTP caching semantics from Varnish and RFC 9111, the distributed architecture concepts from commercial CDNs, and build them into a cohesive, understandable system. The following sections detail the design of each component, starting with the heart of the system: the edge cache.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** All milestones (1 through 5)\n\nThis section precisely defines the scope of the \"Blue Origin\" CDN project. For an educational project of this complexity, clear boundaries are essential to maintain focus on the core distributed systems concepts while acknowledging that a production-grade CDN encompasses many additional features. The goals are directly mapped to the five project milestones, while the non-goals explicitly exclude features that, while important in commercial CDNs, would distract from the foundational learning objectives.\n\n### Goals (What We Must Build)\n\nThese goals represent the complete set of functional requirements that the \"Blue Origin\" CDN must implement. Each goal is aligned with one of the five project milestones, ensuring progressive implementation of increasingly sophisticated CDN capabilities.\n\n**Milestone 1: Edge Cache Implementation**\n- **HTTP Caching with RFC 9111 Compliance:** Implement an edge server that acts as a compliant HTTP cache, intercepting client requests and serving cached responses when possible. The cache must respect standard HTTP caching headers (`Cache-Control`, `Expires`, `ETag`, `Last-Modified`).\n- **Sophisticated Cache Key Generation:** Construct cache keys that uniquely identify resources by combining the request URL with the values of headers listed in the `Vary` response header (e.g., `Accept-Encoding`, `Accept-Language`). Correctly handle the special case of `Vary: *`, which indicates the resource should never be cached.\n- **TTL Hierarchy and Freshness Management:** Implement a multi-layered Time-To-Live (TTL) logic that prioritizes cache directives in the correct order: `s-maxage` (for shared caches like CDNs), `max-age`, and finally the `Expires` header. Maintain metadata for each cache entry indicating its freshness lifetime and current state (fresh, stale).\n- **Cache Validation with Conditional Requests:** Support `If-None-Match` (with `ETag`) and `If-Modified-Since` (with `Last-Modified`) conditional requests from clients. When a cached resource is stale, the edge should issue a conditional request to the upstream (shield or origin) and serve a `304 Not Modified` response if the content is unchanged, saving bandwidth.\n- **Stale Content Serving Strategies:** Implement `stale-while-revalidate` and `stale-if-error` behaviors, allowing the cache to serve stale content while asynchronously revalidating it with the origin or when the origin is unavailable, improving availability and perceived performance.\n- **Memory Management with Eviction Policies:** Implement a bounded cache storage (e.g., based on entry count or memory usage) with a configurable eviction policy—either **LRU (Least Recently Used)** or **LFU (Least Frequently Used)**—to remove the least valuable entries when capacity is exceeded.\n\n**Milestone 2: Cache Invalidation**\n- **Programmatic Purge API:** Expose an administrative HTTP API (e.g., `PURGE /path/to/resource`) that immediately removes a specific cached resource from the edge cache. The next request for that resource must trigger a fresh fetch from the origin.\n- **Tag-Based Invalidation with Surrogate Keys:** Support the `Surrogate-Key` response header, allowing the origin to assign one or more tags (keys) to a cached resource. Implement a purge-by-tag API (e.g., `PURGE /purge/tag/KEY`) that invalidates all resources tagged with that key in a single operation, enabling efficient bulk invalidation of related content (e.g., all product pages when a category changes).\n- **Pattern-Based Invalidation (Bans):** Implement \"ban\" functionality that invalidates cache entries matching a pattern (e.g., a URL path prefix like `/api/products/*` or a regular expression). Bans are evaluated lazily when a request matches the pattern, rather than scanning the entire cache upfront.\n- **Soft Purge (Graceful Invalidation):** Support a \"soft purge\" operation that marks content as stale but continues to serve it to clients while asynchronously revalidating it in the background. This provides a smoother user experience compared to a hard purge, which might cause a temporary slowdown as all clients trigger simultaneous cache misses.\n- **Distributed Invalidation Propagation:** Design a mechanism for propagating invalidation commands (purges, bans, tag purges) from one edge node to all other edge nodes in the CDN, ensuring eventual consistency of the cache state across the network. This propagation should complete within a configurable time window.\n\n**Milestone 3: Origin Shield & Request Collapsing**\n- **Mid-Tier Caching Layer:** Implement an **origin shield** server that sits between the edge nodes and the origin server. It acts as a shared, secondary cache tier, absorbing repeated requests from multiple edge nodes for the same resource.\n- **Request Collapsing (Coalescing):** When the shield receives multiple concurrent requests for the same uncached resource (identical cache key), it should collapse them into a single upstream request to the origin. The resulting response is then broadcast to all waiting requestors, dramatically reducing load on the origin during \"cache miss storms\" or \"thundering herd\" scenarios.\n- **Request Queuing and Timeout Management:** For collapsed requests, implement a fair queuing mechanism where subsequent requests for the same key wait for the ongoing fetch to complete. This queue must have a timeout shorter than the client's timeout to prevent clients from waiting indefinitely if the upstream fetch hangs.\n- **Negative Caching:** Cache error responses (like `404 Not Found` or `5xx` origin errors) with a short, configurable TTL. This prevents a flood of requests to the origin for non-existent or temporarily failing resources.\n- **Origin Load Protection:** Implement circuit breakers or concurrency limits at the shield to prevent overwhelming the origin server with too many simultaneous requests, even during massive traffic spikes.\n\n**Milestone 4: Edge Node Distribution & Routing**\n- **Multi-Node Edge Network:** Architect the CDN to consist of multiple, geographically distributed **edge nodes** (Points of Presence). Each node runs the edge caching software independently but coordinates for invalidation and analytics.\n- **Geo-Aware Client Routing:** Implement a routing mechanism that directs client requests to the **nearest** healthy edge node based on the client's IP address. This reduces latency by minimizing network distance.\n- **Health Checking and Failover:** Implement active health checks between a **control plane** (or routing layer) and edge nodes. Unhealthy nodes should be automatically removed from the routing table, and traffic should be redirected to the next-nearest healthy node, ideally within 5 seconds of failure detection.\n- **Consistent Hashing for Cache Distribution:** Use consistent hashing to distribute content keys across the pool of edge nodes. This ensures that requests for a given resource are generally routed to the same edge node, improving cache efficiency. More importantly, it minimizes cache reshuffling (the \"thundering herd\" effect on origin) when nodes are added or removed, as only a fraction of keys need to be remapped.\n- **Control Plane for Coordination:** Implement a simple control plane that edge nodes register with, report health to, and receive configuration/invalidation commands from. This decouples the data plane (serving user requests) from the management plane.\n\n**Milestone 5: CDN Analytics & Performance Optimization**\n- **Cache Performance Analytics:** Track and expose real-time metrics for each edge node and the shield, including cache hit ratio (hits/requests), bandwidth saved, and breakdown by content type or URL pattern.\n- **On-the-Fly Content Compression:** Implement response body compression at the edge for text-based content (HTML, CSS, JS, JSON). Support both `gzip` (widely compatible) and `Brotli` (better compression) algorithms, selecting the best based on the client's `Accept-Encoding` header and configurable quality/CPU trade-offs.\n- **HTTP Range Request Support:** Fully support the `Range` and `If-Range` request headers for partial content delivery. This is critical for large files (videos, software downloads) and adaptive bitrate streaming. The cache must be able to store, serve, and revalidate partial responses.\n- **Advanced Stale-While-Revalidate:** Extend the Milestone 1 implementation with robust background revalidation logic, ensuring that stale content served under `stale-while-revalidate` is eventually updated without impacting client response times.\n\n### Non-Goals (What We Explicitly Won't Build)\n\nThe following features are commonly found in commercial CDN offerings but are explicitly out of scope for this educational project. This focus allows us to delve deep into core caching, distribution, and invalidation patterns without being overwhelmed by peripheral concerns.\n\n| Non-Goal | Reason for Exclusion |\n| :--- | :--- |\n| **Full TLS/SSL Termination & Certificate Management** | While HTTPS is mandatory for the modern web, implementing TLS (key exchange, certificate validation, SNI, OCSP stapling) is a complex domain in itself. We assume TLS is handled by a reverse proxy (like NGINX or Caddy) in front of our edge node. Our CDN will work with plain HTTP or behind a TLS terminator. |\n| **Distributed Denial of Service (DDoS) Protection** | Mitigating large-scale attack traffic requires specialized infrastructure (scrubbing centers, anycast routing, rate limiting at line speed) and threat intelligence. It's a critical production feature but orthogonal to learning caching architecture. |\n| **Web Application Firewall (WAF)** | Scanning HTTP traffic for SQL injection, XSS, and other OWASP Top 10 vulnerabilities involves complex rule engines and security expertise. It's a valuable add-on layer but not part of the core CDN data plane. |\n| **Video Transcoding & Adaptive Bitrate Streaming** | Transforming video formats (e.g., to HLS or DASH manifests) requires significant CPU/GPU resources and media expertise. Our CDN will **deliver** video files efficiently (with range request support) but not **transform** them. |\n| **Dynamic Content Acceleration (DSA) & API Optimization** | Techniques for caching personalized or non-cacheable content (e.g., via Edge Side Includes, sophisticated request/response transformation) involve complex business logic integration. We focus on static and cacheable dynamic content. |\n| **Real User Monitoring (RUM) & Synthetic Monitoring** | Collecting fine-grained performance data from end-user browsers and running synthetic tests from various locations is a vast analytics domain. Our analytics are server-side focused (hit ratios, bandwidth). |\n| **Object Storage Integration as Origin** | While many CDNs pull from cloud storage (S3, GCS), implementing the authentication (AWS SigV4) and semantics of various storage backends adds complexity. Our origin is assumed to be a standard HTTP web server. |\n| **Multi-CDN Failover & Intelligent Traffic Steering** | Switching traffic between different CDN providers based on performance is a strategic layer above a single CDN's operation. We build one CDN, not an orchestrator of many. |\n| **Edge Computing (Serverless Functions at Edge)** | Executing customer-provided JavaScript/Wasm code at the edge (like Cloudflare Workers) is a paradigm shift from caching. Our edge nodes are pure caching/proxy servers. |\n| **Detailed Billing & Usage Reporting** | Metering traffic per customer and generating invoices is a business support system, not a core distributed systems challenge. |\n\n> **Design Insight:** The choice of non-goals reflects a fundamental learning strategy: depth over breadth. By implementing the data plane of a CDN—caching, distribution, invalidation, shielding—you grapple with the essential problems of state replication, consistency, and fault tolerance in distributed systems. These concepts transfer to countless other domains, whereas the non-goals listed are more specialized verticals (security, media, finance).\n\n#### Why These Boundaries Matter\n\nEstablishing clear non-goals prevents **scope creep**, which is the enemy of a successful educational project. For example:\n\n- **TLS Termination:** Adding TLS would require diving into cryptography libraries, PKI, and potentially performance optimizations like TLS session resumption. This could easily consume more time than the caching logic itself.\n- **DDoS Protection:** Building even basic rate limiting is valuable, but advanced DDoS mitigation involves network-level filtering and global threat intelligence feeds, which are impractical to simulate in a learning environment.\n- **WAF:** Writing a secure WAF rule engine is a project unto itself and requires deep security knowledge to avoid creating bypass vulnerabilities.\n\nBy stating these exclusions upfront, we channel all effort into the **core value proposition of a CDN**: reducing latency and origin load through intelligent caching and geographic distribution. The architecture we design, however, remains compatible with these additional features—they could be added as layers in front of or behind our caching logic, following the Unix philosophy of composable components.\n\n> **Milestone Checkpoint 0 - Scoping Validation:** Before writing any code, verify your understanding of the project's scope. Write a brief document answering: 1) What are the five core capabilities my CDN must have? 2) For each non-goal, what is an alternative (e.g., using an existing tool) to achieve that functionality in a production deployment? This ensures you won't accidentally start implementing features that are out of scope.\n\n### Implementation Guidance\n\nThis section provides practical starting points for organizing your codebase and implementing the scoped features. Since Python is the primary language, guidance will focus on Pythonic patterns and libraries.\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (Getting Started) | Advanced Option (For Exploration) |\n| :--- | :--- | :--- |\n| **HTTP Server (Edge/Shield)** | `http.server` (standard library) - Simple, built-in. | `aiohttp` (async) - High performance, supports HTTP/1.1 fully. |\n| **HTTP Client (to upstream)** | `urllib.request` (standard library) - Simple. | `httpx` (sync or async) - Modern, supports HTTP/2, connection pooling. |\n| **Cache Storage** | `functools.lru_cache` or `dict` with custom eviction - In-memory, simple. | `redis` (via `redis-py`) - External, distributed, persistent. |\n| **Data Serialization** | `pickle` for caching objects (careful with security). | `msgpack` or `orjson` - Faster, more compact than JSON. |\n| **Concurrency Control** | `threading.Lock` / `queue.Queue` | `asyncio` with locks and queues - More scalable for I/O. |\n| **Health Checks** | Simple TCP/HTTP ping in a background thread. | `aiohttp` client with timeout and retry logic. |\n| **GeoIP Lookup** | `geoip2` library with free MaxMind GeoLite2 database. | Integration with a paid, more accurate GeoIP service API. |\n| **Metrics & Analytics** | `prometheus_client` - Exposes metrics for Prometheus. | Custom time-series storage (e.g., InfluxDB) or logging to ELK stack. |\n\n**B. Recommended File/Module Structure**\n\nOrganize your project from the start to separate concerns and make milestones map to clear code modules.\n\n```\nblue_origin_cdn/\n├── README.md\n├── pyproject.toml (or requirements.txt)\n├── src/\n│   ├── blue_origin/\n│   │   ├── __init__.py\n│   │   ├── main.py                      # Entry point, CLI parsing\n│   │   ├── config.py                    # Configuration loading (YAML/TOML)\n│   │   ├── metrics.py                   # Prometheus metrics setup (Milestone 5)\n│   │   ├── control_plane/               # Milestone 4\n│   │   │   ├── __init__.py\n│   │   │   ├── server.py                # Control plane HTTP API\n│   │   │   ├── registry.py              # Edge node registration\n│   │   │   └── health_checker.py        # Active health checks\n│   │   ├── edge/                        # Milestone 1 & 5\n│   │   │   ├── __init__.py\n│   │   │   ├── server.py                # Main HTTP request handler\n│   │   │   ├── cache/                   # Caching logic core\n│   │   │   │   ├── __init__.py\n│   │   │   │   ├── storage.py           # CacheStorage class (LRU, etc.)\n│   │   │   │   ├── key_generator.py     # Cache key creation\n│   │   │   │   ├── ttl_manager.py       # Freshness/expiry logic\n│   │   │   │   └── validator.py         # Conditional request handling (304)\n│   │   │   ├── compression.py           # Brotli/gzip middleware (Milestone 5)\n│   │   │   ├── range_handler.py         # HTTP Range support (Milestone 5)\n│   │   │   └── analytics.py             # Hit/miss tracking (Milestone 5)\n│   │   ├── invalidation/                # Milestone 2\n│   │   │   ├── __init__.py\n│   │   │   ├── api.py                   # PURGE/ban HTTP API endpoints\n│   │   │   ├── purge.py                 # Purge by URL/tag logic\n│   │   │   ├── ban.py                   # Ban pattern matching & storage\n│   │   │   ├── tags.py                  # Surrogate key index management\n│   │   │   └── broadcaster.py           # Propagate invalidations (pub/sub)\n│   │   ├── shield/                      # Milestone 3\n│   │   │   ├── __init__.py\n│   │   │   ├── server.py                # Shield HTTP handler (similar to edge)\n│   │   │   ├── request_coalescer.py     # Request collapsing & queuing logic\n│   │   │   ├── negative_cache.py        # Cache for error responses\n│   │   │   └── circuit_breaker.py       # Origin load protection\n│   │   ├── routing/                     # Milestone 4\n│   │   │   ├── __init__.py\n│   │   │   ├── geo_router.py            # Map client IP to nearest edge\n│   │   │   ├── consistent_hashing.py    # Consistent hashing ring\n│   │   │   └── health.py                # Health check logic (used by edge/shield)\n│   │   └── utils/\n│   │       ├── __init__.py\n│   │       ├── http_utils.py            # Header parsing, date formatting\n│   │       └── logging.py               # Structured logging setup\n└── tests/                               # Comprehensive test suite\n    ├── unit/\n    └── integration/\n```\n\n**C. Infrastructure Starter Code**\n\nHere is a complete, reusable utility for parsing HTTP caching headers—a prerequisite for Milestone 1.\n\n```python\n# src/blue_origin/utils/http_utils.py\nimport time\nimport email.utils\nfrom datetime import datetime, timezone\nfrom typing import Optional, Dict, Tuple, List\nfrom dataclasses import dataclass\n\n@dataclass\nclass CacheDirectives:\n    \"\"\"Parsed Cache-Control directives relevant to a CDN.\"\"\"\n    s_maxage: Optional[int] = None\n    max_age: Optional[int] = None\n    no_cache: bool = False\n    no_store: bool = False\n    must_revalidate: bool = False\n    proxy_revalidate: bool = False\n    public: bool = False\n    private: bool = False\n    stale_while_revalidate: Optional[int] = None\n    stale_if_error: Optional[int] = None\n\n    @classmethod\n    def from_header(cls, cache_control_header: Optional[str]) -> 'CacheDirectives':\n        \"\"\"Parse a Cache-Control header string into a structured object.\"\"\"\n        directives = cls()\n        if not cache_control_header:\n            return directives\n\n        tokens = [token.strip().lower() for token in cache_control_header.split(',')]\n        for token in tokens:\n            if '=' in token:\n                key, value = token.split('=', 1)\n                key = key.strip()\n                try:\n                    value_int = int(value.strip())\n                except ValueError:\n                    continue  # Ignore malformed integer values\n\n                if key == 's-maxage':\n                    directives.s_maxage = value_int\n                elif key == 'max-age':\n                    directives.max_age = value_int\n                elif key == 'stale-while-revalidate':\n                    directives.stale_while_revalidate = value_int\n                elif key == 'stale-if-error':\n                    directives.stale_if_error = value_int\n            else:\n                if token == 'no-cache':\n                    directives.no_cache = True\n                elif token == 'no-store':\n                    directives.no_store = True\n                elif token == 'must-revalidate':\n                    directives.must_revalidate = True\n                elif token == 'proxy-revalidate':\n                    directives.proxy_revalidate = True\n                elif token == 'public':\n                    directives.public = True\n                elif token == 'private':\n                    directives.private = True\n        return directives\n\ndef parse_http_date(date_str: Optional[str]) -> Optional[float]:\n    \"\"\"Parse an RFC 1123/822 date string into a Unix timestamp.\n    Returns None if the string is invalid or empty.\n    \"\"\"\n    if not date_str:\n        return None\n    try:\n        dt = email.utils.parsedate_to_datetime(date_str)\n        if dt.tzinfo is None:\n            dt = dt.replace(tzinfo=timezone.utc)\n        return dt.timestamp()\n    except (TypeError, ValueError):\n        return None\n\ndef is_response_cacheable(\n    status_code: int,\n    method: str,\n    cache_control: CacheDirectives,\n    vary_header: Optional[str]\n) -> bool:\n    \"\"\"Determine if a response can be stored in the cache per RFC 9111.\n    \n    Args:\n        status_code: HTTP status code.\n        method: Request method (only GET and HEAD are cacheable by default).\n        cache_control: Parsed Cache-Control directives.\n        vary_header: Value of the Vary header.\n    \n    Returns:\n        True if the response is cacheable, False otherwise.\n    \"\"\"\n    # Section 3: https://httpwg.org/specs/rfc9111.html#caching.overview\n    if method not in ('GET', 'HEAD'):\n        return False\n    if cache_control.no_store:\n        return False\n    if cache_control.private:\n        return False  # Private responses are not cacheable by shared caches (CDN)\n    if vary_header == '*':\n        return False  # Vary: * means never cache\n    # Generally, only successful responses are cached (200, 203, 206, 300, 301, 308, 404, 405, 410, 414, 501)\n    # For simplicity, we'll cache 200, 206, 301, 302, 304 (304 is for validation, not stored), 404, etc.\n    cacheable_statuses = {200, 203, 204, 206, 300, 301, 302, 303, 307, 308}\n    # Note: 304 Not Modified is a response to a conditional request and does not contain a body to cache.\n    if status_code not in cacheable_statuses:\n        return False\n    return True\n```\n\n**D. Core Logic Skeleton Code**\n\nFor the central caching logic (Milestone 1), here is a skeleton for the main request handler method on the edge node.\n\n```python\n# src/blue_origin/edge/server.py\nfrom typing import Dict, Optional, Tuple\nfrom http.client import HTTPResponse\nfrom .cache.storage import CacheStorage\nfrom .cache.key_generator import generate_cache_key\nfrom .cache.ttl_manager import TTLManager\nfrom .cache.validator import validate_conditional_request\nfrom ..utils.http_utils import CacheDirectives, parse_http_date, is_response_cacheable\n\nclass EdgeRequestHandler:\n    def __init__(self, cache_storage: CacheStorage, upstream_url: str):\n        self.cache = cache_storage\n        self.upstream = upstream_url  # Could be shield or origin URL\n    \n    def handle_request(self, request_headers: Dict[str, str], request_body: bytes = b\"\") -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Main request handling algorithm for the edge node.\n        \n        Args:\n            request_headers: Dictionary of HTTP request headers.\n            request_body: Raw request body.\n        \n        Returns:\n            Tuple of (status_code, response_headers, response_body).\n        \"\"\"\n        method = request_headers.get(':method', 'GET')\n        url = request_headers.get(':path', '/')\n        \n        # TODO 1: Generate cache key from request URL and Vary header dimensions.\n        #   - Extract headers listed in any existing Vary header from the cache.\n        #   - For initial lookup, use a provisional key (just URL). After fetching\n        #     from upstream, you'll know the full Vary headers and can store correctly.\n        cache_key = generate_cache_key(url, request_headers)\n        \n        # TODO 2: Look up the cache key in the cache storage.\n        cache_entry = self.cache.get(cache_key)\n        \n        if cache_entry:\n            # TODO 3: Check if the cached entry is fresh using TTLManager.\n            #   - Calculate age from Date header and current time.\n            #   - Compare against s-maxage, max-age, Expires.\n            #   - Determine if it's fresh, stale, or needs revalidation.\n            freshness_state = TTLManager.check_freshness(cache_entry)\n            \n            # TODO 4: If fresh, serve directly from cache (cache hit).\n            if freshness_state == 'fresh':\n                # TODO 5: Apply any request collapsing for Range headers if present.\n                return cache_entry.status, cache_entry.headers, cache_entry.body\n            \n            # TODO 6: If stale but allowed by stale-while-revalidate, serve stale\n            #   and trigger asynchronous revalidation.\n            if freshness_state == 'stale':\n                if TTLManager.can_serve_stale(cache_entry):\n                    # Fire-and-forget background revalidation\n                    self._revalidate_in_background(cache_key, cache_entry, request_headers)\n                    return cache_entry.status, cache_entry.headers, cache_entry.body\n            \n            # TODO 7: If cache entry exists but is stale and needs validation,\n            #   build a conditional request (If-None-Match, If-Modified-Since)\n            #   using the cached entry's ETag and Last-Modified.\n            conditional_headers = validate_conditional_request(cache_entry, request_headers)\n            # Forward to upstream with conditional headers...\n        \n        # TODO 8: Cache miss or needs revalidation: forward request to upstream.\n        #   - Merge conditional headers if this is a revalidation.\n        #   - Use a connection pool for efficiency.\n        upstream_response = self._fetch_from_upstream(request_headers, request_body)\n        \n        # TODO 9: Parse upstream response headers and check if cacheable.\n        cache_control = CacheDirectives.from_header(upstream_response.headers.get('Cache-Control'))\n        if is_response_cacheable(upstream_response.status, method, cache_control, upstream_response.headers.get('Vary')):\n            # TODO 10: If cacheable, compute final cache key with actual Vary header values.\n            final_cache_key = generate_cache_key(url, request_headers, upstream_response.headers.get('Vary'))\n            # TODO 11: Store the response in cache with computed TTL.\n            self.cache.set(final_cache_key, upstream_response, cache_control)\n        \n        # TODO 12: Return the response to the client.\n        return upstream_response.status, upstream_response.headers, upstream_response.body\n    \n    def _revalidate_in_background(self, cache_key: str, cache_entry, request_headers: Dict[str, str]):\n        \"\"\"Asynchronously revalidate a stale cache entry.\"\"\"\n        # TODO: Implement background thread or async task to revalidate.\n        pass\n    \n    def _fetch_from_upstream(self, headers: Dict[str, str], body: bytes):\n        \"\"\"Forward request to upstream (shield or origin).\"\"\"\n        # TODO: Implement HTTP client with connection pooling.\n        pass\n```\n\n**E. Language-Specific Hints (Python)**\n\n- **Concurrency:** Use `threading.Lock` for simple mutexes around the cache storage. For request collapsing at the shield, `threading.Condition` is ideal for waiting/notifying threads.\n- **Data Structures:** Use `collections.OrderedDict` to implement an LRU cache easily. For LFU, you'll need a more complex structure (e.g., a dict plus a min-heap or `SortedDict`).\n- **HTTP Dates:** Always work with UTC timestamps internally. Use `email.utils.formatdate` to generate RFC 1123 dates for responses.\n- **Performance:** For header parsing, avoid repeated string splits. Consider caching parsed `CacheDirectives` objects alongside the cached response.\n- **Testing:** Use `unittest.mock` to simulate upstream origin responses and test cache behavior without a network.\n\n**F. Milestone Checkpoint for Goals**\n\nAfter reading this section, you should be able to clearly articulate what you will and won't build. A good checkpoint is to create a simple markdown table in your project notes mapping each milestone to the 2-3 most critical deliverables. For example:\n\n| Milestone | Critical Deliverable | Verification Method |\n| :--- | :--- | :--- |\n| 1 | Cache serves cached response for same URL | `curl` twice, second response has `X-Cache: HIT` header |\n| 2 | `PURGE /api/purge` removes cached item | `curl` after purge shows `X-Cache: MISS` |\n| 3 | Two simultaneous requests for same uncached resource result in one origin fetch | Logs show only one upstream request |\n| 4 | Client IP from US routes to US edge node IP | `dig` or `curl` shows different IPs for different geo-locations |\n| 5 | Text response is served with `Content-Encoding: gzip` | Response headers show compression |\n\n---\n\n\n## High-Level Architecture\n\n> **Milestone(s):** All milestones (1 through 5)  \n> This section presents the architectural blueprint for the entire CDN system. Understanding this bird's-eye view is critical before diving into individual component designs, as it establishes the relationships and responsibilities that define how the system works as a whole.\n\n![High-Level System Component Diagram](./diagrams/sys-component.svg)\n\n### Component Overview & Responsibilities\n\nThink of our CDN as a **global postal system** with specialized facilities at different distances from the end recipient:\n\n| Component | Postal System Analogy | Technical Responsibility | Key Data Held |\n|-----------|-----------------------|--------------------------|---------------|\n| **Client** | Letter sender/recipient | Initiates HTTP requests for web content; expects fast responses | None (external to CDN) |\n| **Edge Node** | Local post office | Serves cached content to nearby users; first point of contact | Cached responses, local hit/miss counters |\n| **Origin Shield** | Regional sorting facility | Aggregates requests from multiple edge nodes; provides secondary cache layer | Shield-level cache, request coalescing state |\n| **Origin Server** | Central mail repository | Ultimate source of truth for all content; serves uncached resources | Original content, database, application logic |\n| **Control Plane** | Postal management HQ | Coordinates the network: routing, invalidation, health monitoring, analytics | Node registry, routing rules, invalidation queue |\n\nEach component has a clearly defined responsibility that minimizes overlap and creates clean separation of concerns. The **data plane** (Edge Nodes and Origin Shield) handles user traffic, while the **control plane** manages configuration and coordination.\n\n#### Detailed Component Specifications\n\n**Edge Node (PoP - Point of Presence)**\nThe edge node is the CDN's frontline — geographically distributed servers that intercept client requests before they travel long distances to the origin. Each edge node operates autonomously but follows centralized policies.\n\n> **Design Principle:** Edge nodes should be stateless in terms of configuration but stateful in terms of cache content. They can operate independently during network partitions, serving cached content even if the control plane is unavailable.\n\n| Responsibility | Details | Critical Interfaces |\n|----------------|---------|---------------------|\n| **Request Handling** | Accepts HTTP/HTTPS connections, parses requests, generates cache keys | `EdgeRequestHandler.handle_request()` |\n| **Cache Lookup & Serving** | Checks local cache storage, serves fresh content, validates stale entries | Cache storage interface |\n| **Cache Population** | Fetches missing content from upstream (shield or origin), stores with metadata | `_fetch_from_upstream()` |\n| **TTL Enforcement** | Respects cache-control directives, marks entries stale when expired | `CacheDirectives` processing |\n| **Local Invalidation** | Removes entries when purge commands arrive from control plane | Purge API endpoint |\n| **Health Reporting** | Periodically sends heartbeat and metrics to control plane | Health check endpoint |\n\n**Origin Shield (Mid-Tier Cache)**\nThe origin shield sits between edge nodes and the origin, acting as a **request aggregator** and **secondary cache**. Its primary purpose is to protect the origin from being overwhelmed by cache miss storms—when many edge nodes simultaneously request the same uncached resource.\n\n> **Key Insight:** The shield introduces a small additional latency (typically 10-50ms) but dramatically reduces origin load. For high-traffic sites, this trade-off is almost always worthwhile.\n\n| Responsibility | Details | Key Mechanism |\n|----------------|---------|---------------|\n| **Request Collapsing** | Deduplicates concurrent identical requests from multiple edge nodes | Request coalescing map with waiters |\n| **Secondary Caching** | Maintains its own cache (typically larger than edge caches) | Shield-level cache storage |\n| **Negative Caching** | Briefly caches error responses (404, 503) to prevent origin storms | Short TTL for error status codes |\n| **Load Shedding** | Queues or rejects requests when origin is overloaded | Adaptive queuing with circuit breakers |\n| **Health Monitoring** | Probes origin health and bypasses cache when origin is unhealthy | Active health checks |\n\n**Control Plane**\nThe control plane is the CDN's \"brain\"—it doesn't handle user traffic but ensures the data plane operates correctly and efficiently. It maintains a global view of the network.\n\n| Responsibility | Details | Data Structures |\n|----------------|---------|-----------------|\n| **Geo-Routing Configuration** | Maps client IP prefixes to optimal edge nodes | GeoIP database, routing tables |\n| **Health Monitoring** | Collects heartbeats from edge nodes and shield | Node registry with health status |\n| **Invalidation Propagation** | Distributes purge commands to all relevant nodes | Message queue/pub-sub system |\n| **Analytics Aggregation** | Collects metrics from all nodes for reporting | Time-series database of hits/misses |\n| **Consistent Hashing Management** | Maintains the distribution ring for cache sharding | Consistent hashing ring state |\n\n**Origin Server**\nThe origin is the authoritative source for content. While not part of the CDN proper, its behavior profoundly affects CDN design.\n\n| Characteristic | Implication for CDN Design |\n|----------------|----------------------------|\n| **Cache-Control Headers** | Determines TTLs and cacheability of responses | Edge must parse and respect these headers |\n| **ETag/Last-Modified Headers** | Enables conditional revalidation | Edge must support `If-None-Match` and `If-Modified-Since` |\n| **Vary Headers** | Indicates response varies by certain request headers | Cache key must include these dimensions |\n| **Surrogate-Key Headers** | Allows tag-based invalidation (custom header) | Edge must extract and index by these tags |\n\n### Recommended File/Module Structure\n\nA well-organized codebase from the start prevents architectural drift and makes the five milestones easier to implement incrementally. Below is the recommended Python package structure, organized by component and responsibility.\n\n```\nblue_origin_cdn/                    # Project root\n├── pyproject.toml                  # Python project configuration\n├── README.md\n├── requirements.txt\n│\n├── src/                            # Source code (installable package)\n│   └── blue_origin/\n│       ├── __init__.py\n│       │\n│       ├── data_models/            # Core data structures (Milestone 1)\n│       │   ├── __init__.py\n│       │   ├── cache_entry.py      # CacheEntry class and related structures\n│       │   ├── cache_directives.py # CacheDirectives parsing class\n│       │   └── invalidation.py     # PurgeRequest, BanRule, SurrogateKeyIndex\n│       │\n│       ├── edge/                   # Edge node implementation (Milestones 1, 5)\n│       │   ├── __init__.py\n│       │   ├── handler.py          # EdgeRequestHandler class\n│       │   ├── cache_storage.py    # CacheStorage interface and LRU implementation\n│       │   ├── cache_key.py        # Cache key generation logic\n│       │   ├── compression.py      # Gzip/Brotli compression (Milestone 5)\n│       │   ├── range_requests.py   # HTTP Range support (Milestone 5)\n│       │   └── analytics.py        # Local hit/miss tracking\n│       │\n│       ├── shield/                 # Origin shield (Milestone 3)\n│       │   ├── __init__.py\n│       │   ├── shield_handler.py   # Shield's request handler\n│       │   ├── request_coalescing.py # Request collapsing logic\n│       │   └── negative_cache.py   # Negative response caching\n│       │\n│       ├── control_plane/          # Control plane (Milestones 2, 4)\n│       │   ├── __init__.py\n│       │   ├── node_registry.py    # Tracks edge nodes and their health\n│       │   ├── geo_routing.py      # GeoIP lookup and routing logic\n│       │   ├── invalidation_bus.py # Distributes purge commands\n│       │   └── hashing_ring.py     # Consistent hashing implementation\n│       │\n│       ├── http_utils/             # Shared HTTP utilities\n│       │   ├── __init__.py\n│       │   ├── headers.py          # Header parsing utilities\n│       │   ├── cache_validation.py # is_response_cacheable() and helpers\n│       │   └── date_parsing.py     # parse_http_date() function\n│       │\n│       ├── protocols/              # Communication protocols\n│       │   ├── __init__.py\n│       │   ├── health_check.py     # Health check protocol messages\n│       │   └── invalidation_pb.py  # Invalidation protocol (could be protobuf)\n│       │\n│       └── cli/                    # Command-line interfaces\n│           ├── __init__.py\n│           ├── edge_node.py        # Starts an edge node server\n│           ├── shield_node.py      # Starts a shield node\n│           ├── control_plane.py    # Starts the control plane\n│           └── admin.py            # Admin commands (purge, ban, stats)\n│\n├── tests/                          # Comprehensive test suite\n│   ├── __init__.py\n│   ├── test_edge/\n│   ├── test_shield/\n│   ├── test_control_plane/\n│   └── integration/\n│\n├── configs/                        # Configuration files\n│   ├── edge_config.yaml.example\n│   ├── shield_config.yaml.example\n│   └── control_plane_config.yaml.example\n│\n└── scripts/                        # Deployment and utility scripts\n    ├── deploy_edge.sh\n    ├── load_test.py\n    └── geoip_update.py\n```\n\n#### Module Dependencies and Import Structure\n\nThe dependency flow follows the logical data flow: edge nodes depend on shared utilities and data models; the control plane is relatively independent; and the shield sits between them.\n\n```\nedge/ → http_utils/ → data_models/\nshield/ → http_utils/ → data_models/\ncontrol_plane/ → protocols/ → data_models/\n```\n\n> **Design Decision:** We place the `CacheDirectives` class in `data_models/` rather than `http_utils/` because it's a core data structure used throughout the system, not just an HTTP utility. This makes it available to all components without creating circular dependencies.\n\n#### Configuration Management\n\nEach component should be configurable via YAML files and environment variables:\n\n```python\n# Example configuration pattern for edge node\n@dataclass\nclass EdgeConfig:\n    upstream_url: str  # URL of shield or origin\n    cache_capacity_mb: int = 1024\n    listen_port: int = 8080\n    control_plane_url: Optional[str] = None\n    geoip_database_path: str = \"./data/GeoIP2-City.mmdb\"\n    \n    @classmethod\n    def from_yaml(cls, path: str) -> \"EdgeConfig\":\n        # Load and validate configuration\n        pass\n```\n\nThis structure supports all five milestones:\n- **Milestone 1 & 5:** `edge/` and `data_models/` directories\n- **Milestone 2:** `control_plane/invalidation_bus.py` and edge invalidation handling\n- **Milestone 3:** `shield/` directory\n- **Milestone 4:** `control_plane/geo_routing.py` and `hashing_ring.py`\n- Shared utilities in `http_utils/` support all milestones\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Getting Started) | Advanced Option (Production-Ready) |\n|-----------|---------------------------------|------------------------------------|\n| **HTTP Server** | Python's `http.server` with threading | `asyncio` + `aiohttp` for async I/O |\n| **Cache Storage** | `dict` with LRU eviction using `collections.OrderedDict` | `redis` as external cache store |\n| **Configuration** | Python `dataclasses` with YAML loading | `pydantic` with validation and hot reload |\n| **Inter-Component Comm** | HTTP REST endpoints | gRPC with Protocol Buffers for lower latency |\n| **GeoIP Lookup** | Offline MaxMind DB with `geoip2` library | Commercial GeoIP service with SLA |\n| **Metrics Collection** | In-memory counters exposed via `/metrics` endpoint | `prometheus` client library + Grafana |\n| **Message Propagation** | Redis Pub/Sub for invalidation events | Apache Kafka for ordered, durable events |\n\n#### B. Complete HTTP Utilities Starter Code\n\nSince HTTP header parsing is a prerequisite for all components but not the core learning goal, here's complete, working code for the foundational utilities:\n\n```python\n# src/blue_origin/http_utils/date_parsing.py\n\"\"\"RFC 1123/822 date parsing utilities for HTTP caching.\"\"\"\n\nimport email.utils\nfrom datetime import datetime\nfrom typing import Optional\n\ndef parse_http_date(date_str: str) -> Optional[float]:\n    \"\"\"\n    Parse an RFC 1123/822 date string into a Unix timestamp.\n    \n    Args:\n        date_str: Date string like \"Tue, 15 Nov 1994 08:12:31 GMT\"\n    \n    Returns:\n        Unix timestamp (seconds since epoch) or None if parsing fails\n    \"\"\"\n    if not date_str:\n        return None\n    \n    try:\n        # email.utils.parsedate_to_datetime handles RFC 1123, 850, and asctime formats\n        dt = email.utils.parsedate_to_datetime(date_str)\n        return dt.timestamp()\n    except (ValueError, TypeError):\n        # Log warning in production\n        return None\n\ndef format_http_date(timestamp: float) -> str:\n    \"\"\"\n    Format a Unix timestamp to RFC 1123 string.\n    \n    Args:\n        timestamp: Unix timestamp in seconds\n    \n    Returns:\n        RFC 1123 formatted date string\n    \"\"\"\n    dt = datetime.utcfromtimestamp(timestamp)\n    return dt.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n\n# src/blue_origin/http_utils/headers.py\n\"\"\"HTTP header parsing and manipulation utilities.\"\"\"\n\nimport re\nfrom typing import Dict, List, Optional, Set\n\ndef parse_cache_control_header(header_value: str) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Parse Cache-Control header into a dictionary of directives.\n    \n    Args:\n        header_value: e.g., \"public, max-age=3600, stale-while-revalidate=60\"\n    \n    Returns:\n        Dictionary mapping directive names to values (or None for boolean directives)\n    \"\"\"\n    directives = {}\n    if not header_value:\n        return directives\n    \n    # Split by comma, trim whitespace\n    for part in header_value.split(\",\"):\n        part = part.strip()\n        if \"=\" in part:\n            key, value = part.split(\"=\", 1)\n            directives[key.strip()] = value.strip()\n        else:\n            directives[part] = None  # Boolean directive like \"no-cache\"\n    \n    return directives\n\ndef get_header_values(headers: Dict[str, str], header_name: str) -> List[str]:\n    \"\"\"\n    Get all values for a header (handling comma-separated and multiple headers).\n    \n    HTTP allows both comma-separated values and multiple headers with the same name.\n    \n    Args:\n        headers: Dictionary of header name -> value\n        header_name: Header name (case-insensitive)\n    \n    Returns:\n        List of individual header values\n    \"\"\"\n    normalized_name = header_name.lower()\n    values = []\n    \n    for name, value in headers.items():\n        if name.lower() == normalized_name:\n            # Split by comma, but be careful of quoted strings\n            # Simple implementation for most cases\n            values.extend([v.strip() for v in value.split(\",\")])\n    \n    return values\n\n# src/blue_origin/http_utils/cache_validation.py\n\"\"\"Cache validation logic per RFC 9111.\"\"\"\n\nfrom typing import Dict, Optional\nfrom ..data_models.cache_directives import CacheDirectives\n\ndef is_response_cacheable(\n    status_code: int,\n    method: str,\n    cache_control: Optional[CacheDirectives],\n    vary_header: Optional[str]\n) -> bool:\n    \"\"\"\n    Determine if a response can be stored in the cache per RFC 9111.\n    \n    Args:\n        status_code: HTTP status code\n        method: HTTP method of request\n        cache_control: Parsed CacheDirectives object\n        vary_header: Value of Vary header (or None)\n    \n    Returns:\n        True if the response can be cached\n    \"\"\"\n    # RFC 9111 Section 3: Only successful responses to GET are cacheable by default\n    if method.upper() != \"GET\":\n        return False\n    \n    # Status codes that are cacheable by default (per RFC 9111)\n    cacheable_by_default = {200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501}\n    \n    # Check for explicit no-store directive\n    if cache_control and (cache_control.no_store or cache_control.private):\n        return False\n    \n    # Vary: * means never cache (RFC 9111 Section 4.1)\n    if vary_header and vary_header.strip() == \"*\":\n        return False\n    \n    # Check if status code is cacheable\n    if status_code in cacheable_by_default:\n        return True\n    \n    # Some status codes are cacheable only with explicit directives\n    if status_code in {302, 307}:\n        # These are cacheable if explicit freshness info is provided\n        if cache_control and (cache_control.max_age is not None or \n                            cache_control.s_maxage is not None or\n                            cache_control.public):\n            return True\n    \n    return False\n```\n\n#### C. Core Data Model Skeleton\n\n```python\n# src/blue_origin/data_models/cache_directives.py\n\"\"\"Structured representation of Cache-Control directives.\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom ..http_utils.headers import parse_cache_control_header\n\n@dataclass\nclass CacheDirectives:\n    \"\"\"Parsed Cache-Control directives from HTTP headers.\"\"\"\n    s_maxage: Optional[int] = None  # For shared caches (CDN should use this)\n    max_age: Optional[int] = None   # For both shared and private caches\n    no_cache: bool = False          # Must revalidate with origin\n    no_store: bool = False          # Don't store in cache at all\n    must_revalidate: bool = False   # Must revalidate when stale\n    proxy_revalidate: bool = False  # Like must-revalidate but only for shared caches\n    public: bool = False            # Explicitly cacheable by shared caches\n    private: bool = False           # Not cacheable by shared caches\n    stale_while_revalidate: Optional[int] = None  # Can serve stale while revalidating\n    stale_if_error: Optional[int] = None          # Can serve stale if origin error\n    \n    @classmethod\n    def from_header(cls, cache_control_header: Optional[str]) -> \"CacheDirectives\":\n        \"\"\"\n        Parse a Cache-Control header string into a structured object.\n        \n        Args:\n            cache_control_header: Raw Cache-Control header value\n        \n        Returns:\n            CacheDirectives object with parsed values\n        \n        TODO 1: Call parse_cache_control_header() to get dictionary of directives\n        TODO 2: Convert string values to appropriate types (ints for numeric directives)\n        TODO 3: Set boolean fields based on presence of boolean directives\n        TODO 4: Handle edge cases: multiple values, invalid formats, unknown directives\n        TODO 5: Ensure s-maxage takes precedence over max-age for CDN purposes\n        TODO 6: Handle contradictory directives (e.g., both public and private)\n        \"\"\"\n        directives = cls()\n        \n        if not cache_control_header:\n            return directives\n        \n        # TODO: Implement parsing logic\n        parsed = parse_cache_control_header(cache_control_header)\n        \n        # TODO: Map parsed directives to fields\n        # Example:\n        # if \"s-maxage\" in parsed:\n        #     directives.s_maxage = int(parsed[\"s-maxage\"])\n        \n        return directives\n    \n    def is_cacheable_by_cdn(self) -> bool:\n        \"\"\"\n        Determine if this response can be cached by a CDN (shared cache).\n        \n        Returns:\n            True if CDN can cache this response\n        \"\"\"\n        # TODO 1: Check no_store - if True, return False\n        # TODO 2: Check private - if True, return False (private means no shared cache)\n        # TODO 3: If public is True, return True (explicitly cacheable)\n        # TODO 4: If no explicit directives, default is cacheable for GET requests\n        # TODO 5: Consider other directives that might affect cacheability\n        pass\n\n# src/blue_origin/data_models/cache_entry.py\n\"\"\"Core cache entry data structure.\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport time\n\n@dataclass\nclass CacheEntry:\n    \"\"\"Represents a cached HTTP response with metadata.\"\"\"\n    # Primary key components\n    key: str                         # Generated cache key\n    url: str                         # Original request URL\n    vary_headers: Dict[str, str]    # Values for headers in Vary header\n    \n    # Response data\n    status_code: int\n    headers: Dict[str, str]         # Original response headers\n    body: bytes                     # Response body\n    \n    # Cache metadata\n    fetched_at: float               # Unix timestamp when fetched\n    expires_at: float               # Unix timestamp when entry expires\n    last_used_at: float             # For LRU eviction\n    use_count: int                  # For LFU eviction\n    \n    # Invalidation support\n    surrogate_keys: List[str]       # Tags for group invalidation\n    \n    # Validation support\n    etag: Optional[str] = None\n    last_modified: Optional[str] = None\n    \n    def is_fresh(self, current_time: Optional[float] = None) -> bool:\n        \"\"\"\n        Check if cache entry is still fresh.\n        \n        Args:\n            current_time: Unix timestamp (defaults to time.time())\n        \n        Returns:\n            True if entry hasn't expired\n        \"\"\"\n        if current_time is None:\n            current_time = time.time()\n        return current_time < self.expires_at\n    \n    def is_stale_but_revalidatable(self, current_time: Optional[float] = None) -> bool:\n        \"\"\"\n        Check if stale entry can be served during revalidation.\n        \n        Args:\n            current_time: Unix timestamp\n        \n        Returns:\n            True if stale-while-revalidate period hasn't expired\n        \"\"\"\n        # TODO 1: Compare current_time to expires_at + stale_while_revalidate\n        # TODO 2: Need access to CacheDirectives to know stale_while_revalidate duration\n        # TODO 3: Return True if within grace period\n        pass\n```\n\n#### D. Edge Request Handler Skeleton\n\n```python\n# src/blue_origin/edge/handler.py\n\"\"\"Main request handling logic for edge nodes.\"\"\"\n\nimport time\nfrom typing import Dict, Tuple, Optional\nfrom ..data_models.cache_directives import CacheDirectives\nfrom ..data_models.cache_entry import CacheEntry\n\nclass EdgeRequestHandler:\n    \"\"\"Handles HTTP requests at the edge node.\"\"\"\n    \n    def __init__(self, cache, upstream: str):\n        \"\"\"\n        Initialize handler with cache storage and upstream URL.\n        \n        Args:\n            cache: CacheStorage implementation\n            upstream: URL of shield or origin server\n        \"\"\"\n        self.cache = cache\n        self.upstream = upstream\n    \n    def handle_request(self, request_headers: Dict[str, str], \n                      request_body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Main request handling algorithm for the edge node.\n        \n        Args:\n            request_headers: Dictionary of HTTP request headers\n            request_body: Raw request body\n        \n        Returns:\n            Tuple of (status_code, response_headers, response_body)\n        \n        TODO 1: Extract request method and URL from headers\n        TODO 2: Generate cache key using URL and Vary header dimensions\n        TODO 3: Look up cache entry by key\n        TODO 4: If cache hit and fresh: return cached response\n        TODO 5: If cache hit but stale: handle revalidation logic\n        TODO 6: If cache miss: fetch from upstream using _fetch_from_upstream()\n        TODO 7: If response is cacheable: store in cache with metadata\n        TODO 8: Apply compression if requested and appropriate (Milestone 5)\n        TODO 9: Update analytics counters (hit/miss)\n        TODO 10: Return final response\n        \"\"\"\n        # TODO: Implement the full algorithm\n        pass\n    \n    def _fetch_from_upstream(self, headers: Dict[str, str], \n                            body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Forward request to upstream (shield or origin).\n        \n        Args:\n            headers: Request headers (may be modified)\n            body: Request body\n        \n        Returns:\n            Tuple of (status_code, response_headers, response_body)\n        \n        TODO 1: Add CDN-specific headers (e.g., X-Forwarded-For)\n        TODO 2: Make HTTP request to upstream URL\n        TODO 3: Handle timeouts and connection errors\n        TODO 4: Parse response headers and body\n        TODO 5: Extract cache directives and validation headers\n        TODO 6: Return response tuple\n        \"\"\"\n        pass\n    \n    def _revalidate_in_background(self, cache_key: str, \n                                 cache_entry: CacheEntry,\n                                 request_headers: Dict[str, str]):\n        \"\"\"\n        Asynchronously revalidate a stale cache entry.\n        \n        Args:\n            cache_key: Key of stale cache entry\n            cache_entry: The stale cache entry\n            request_headers: Original request headers\n        \n        TODO 1: Create conditional request with If-None-Match/If-Modified-Since\n        TODO 2: Send request to upstream\n        TODO 3: If 304 Not Modified: update entry's expiry time\n        TODO 4: If 200 OK: replace entry with new response\n        TODO 5: Handle errors (keep stale entry if stale-if-error allows)\n        TODO 6: Implement proper async/threading to not block main request\n        \"\"\"\n        pass\n```\n\n#### E. Python-Specific Implementation Hints\n\n1. **Concurrency Model:** Use threading for simplicity (`concurrent.futures.ThreadPoolExecutor`) or asyncio for high performance. For educational purposes, threading is recommended initially.\n\n2. **Cache Storage:** Implement `CacheStorage` as an abstract base class with concrete implementations:\n   ```python\n   from abc import ABC, abstractmethod\n   from typing import Optional\n   \n   class CacheStorage(ABC):\n       @abstractmethod\n       def get(self, key: str) -> Optional[CacheEntry]:\n           pass\n       \n       @abstractmethod\n       def set(self, key: str, entry: CacheEntry) -> None:\n           pass\n       \n       @abstractmethod\n       def delete(self, key: str) -> bool:\n           pass\n   \n   class LRUCacheStorage(CacheStorage):\n       def __init__(self, max_size_mb: int):\n           self.max_size = max_size_mb * 1024 * 1024\n           self.current_size = 0\n           self.storage = OrderedDict()  # Maintains insertion order\n   ```\n\n3. **HTTP Date Handling:** Always use UTC for HTTP dates. Python's `email.utils` module handles the complex parsing of various date formats.\n\n4. **Header Case Sensitivity:** HTTP headers are case-insensitive for names but case-sensitive for values. Normalize header names to lowercase when storing but preserve original casing when forwarding to origin.\n\n5. **Memory Management:** For the cache, estimate entry size as `len(body) + sum(len(k) + len(v) for k, v in headers.items())`. Use `sys.getsizeof()` for rough estimates but be aware it doesn't account for referenced objects.\n\n6. **Testing:** Use `unittest.mock` to simulate upstream servers and `pytest` for comprehensive testing. The `httpx` library is excellent for both client and server testing.\n\n\n## Data Model\n\n> **Milestone(s):** Milestone 1 (Edge Cache Implementation), Milestone 2 (Cache Invalidation), Milestone 5 (CDN Analytics & Performance Optimization)\n\nThe data model defines the foundational structures that allow the Content Delivery Network (CDN) to store, manage, and track cached content. These structures represent the **\"state of the world\"** for the caching system—what content is stored, where, for how long, and how it can be invalidated or analyzed. Without a well-defined data model, the system would lack the consistency needed for reliable caching operations, efficient invalidation, and meaningful performance insights. This section details three core aspects: the cache entry itself, structures for invalidation, and structures for analytics.\n\n### Core: The Cache Entry\n\n**Mental Model: The Cargo Container**\nThink of a `CacheEntry` as a standardized shipping container. Each container has:\n- **A unique manifest (key)** that exactly describes its contents and destination.\n- **The actual goods (body)** – the response data being delivered.\n- **Shipping labels (headers)** that specify handling instructions (like compression, encoding).\n- **A customs stamp (metadata)** including loading time, expiration date, and tracking of how often it's been accessed.\n- **Cargo tags (surrogate keys)** that group this container with others from the same shipment for batch operations.\n\nJust as a port's efficiency depends on how quickly it can locate and retrieve the right container using its manifest, the **edge cache**'s performance hinges on efficiently storing and retrieving `CacheEntry` objects using their `key`.\n\nThe `CacheEntry` is the central data structure stored within the `CacheStorage` of each **edge node** and **origin shield**. It encapsulates a complete HTTP response along with the metadata required for HTTP caching semantics, eviction decisions, and invalidation. Its design directly implements the caching logic specified in RFC 9111.\n\nThe following table details every field in the `CacheEntry`. These fields collectively enable the four key cache behaviors: freshness validation, revalidation, efficient lookup, and lifecycle management.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `key` | `str` | The **primary lookup key** for the cache storage. This is a deterministic string generated from the request URL and the values of headers specified in the `Vary` response header (e.g., `Accept-Encoding`). It uniquely identifies a cached representation of a resource. |\n| `url` | `str` | The original, normalized request URL (including scheme, host, path, and query string). Stored separately from the `key` for debugging, analytics, and potential invalidation by URL pattern. |\n| `vary_headers` | `Dict[str, str]` | A dictionary mapping header names (from the `Vary` header) to their specific values from the *request* that produced this cached response. For a `Vary: Accept-Encoding, User-Agent` response, this dict would contain the `accept-encoding` and `user-agent` values from the request that resulted in this cache entry. |\n| `status_code` | `int` | The HTTP status code of the cached response (e.g., `200`, `404`, `302`). Non-`200` responses (like `301`, `404`, `503`) can also be cached, often with shorter TTLs (**negative caching**). |\n| `headers` | `Dict[str, str]` | The HTTP response headers as received from the upstream (**origin server** or **origin shield**). Critical headers like `Cache-Control`, `ETag`, `Last-Modified`, `Content-Type`, and `Content-Encoding` are stored here verbatim to be sent back to clients. |\n| `body` | `bytes` | The raw, uncompressed response body. Storing the uncompressed form allows the edge to re-encode on-the-fly for clients that support different compression algorithms (e.g., Brotli vs. gzip). |\n| `fetched_at` | `float` | The Unix timestamp (seconds since epoch) when this entry was fetched from the upstream and stored. This is the baseline for calculating freshness based on `max-age` or `s-maxage`. |\n| `expires_at` | `float` | The calculated Unix timestamp after which this entry is considered **stale**. Derived from `fetched_at` plus the effective TTL (prioritizing `s-maxage`, then `max-age`, then `Expires` header). |\n| `last_used_at` | `float` | The Unix timestamp of the last time this entry was used to serve a request. This field is critical for implementing the **LRU (Least Recently Used)** eviction policy. |\n| `use_count` | `int` | A counter of how many times this entry has been used to serve a request. This field supports **LFU (Least Frequently Used)** eviction policies and analytics for \"hot\" content. |\n| `surrogate_keys` | `List[str]` | A list of **tags** (often called **surrogate keys**) assigned to this entry via the `Surrogate-Key` response header. These allow for efficient, group-based invalidation (e.g., purging all product images when a product is updated). |\n| `etag` | `Optional[str]` | The `ETag` validator from the response headers, stored for efficient conditional revalidation (`If-None-Match`). Can be a strong (`\"xyzzy\"`) or weak (`W/\"xyzzy\"`) validator. |\n| `last_modified` | `Optional[str]` | The `Last-Modified` date string from the response headers, stored for conditional revalidation (`If-Modified-Since`). The string format is preserved for direct comparison in future requests. |\n\n> **Key Insight:** Separating `key` (for lookup) from `url` (for content identity) is essential. The `key` is a function of both the resource *and* the request characteristics defined by `Vary`. Two requests for the same `url` with different `Accept-Encoding` headers must generate different `keys` and thus distinct `CacheEntry` objects.\n\n**Lifecycle and State Transitions**\nA `CacheEntry` moves through distinct states during its lifetime. Understanding these states is crucial for implementing correct cache logic, especially for **stale-while-revalidate** and conditional revalidation.\n\nThe following state machine describes these transitions. Refer to the diagram ![State Machine: Cache Entry Lifecycle](./diagrams/state-machine-cache-entry.svg) for a visual representation.\n\n| Current State | Event | Next State | Actions Taken |\n| :--- | :--- | :--- | :--- |\n| **MISS** (Not in cache) | Cache lookup for a request | **FETCHING** | 1. Generate cache `key`. 2. `key` not found in storage. 3. Initiate upstream request. 4. Create a placeholder to collapse concurrent requests (at the shield). |\n| **FETCHING** | Upstream response received | **FRESH** | 1. Validate response is cacheable via `is_response_cacheable`. 2. Create `CacheEntry` with `fetched_at` and calculated `expires_at`. 3. Store entry in `CacheStorage`. 4. Serve response to waiting client(s). |\n| **FRESH** | `current_time` < `expires_at` | **FRESH** | 1. Serve entry directly to client. 2. Update `last_used_at` and increment `use_count`. |\n| **FRESH** | `current_time` >= `expires_at` | **STALE** | Entry is now past its freshness lifetime. It may still be served under certain conditions (e.g., `stale-while-revalidate`). |\n| **STALE** | Request arrives, `CacheDirectives.stale_while_revalidate` period is active | **REVALIDATING** | 1. Serve the stale entry immediately to the client. 2. Asynchronously trigger `_revalidate_in_background`. 3. The entry remains **STALE** for subsequent requests until revalidation completes. |\n| **STALE** | Request arrives, no `stale-while-revalidate` allowed | **FETCHING** | 1. Do not serve the stale entry. 2. Treat as a **MISS** and initiate a synchronous upstream fetch. |\n| **REVALIDATING** | Background revalidation returns `304 Not Modified` | **FRESH** | 1. Update `fetched_at` and `expires_at` (resetting the TTL clock). 2. Update `last_used_at`. 3. The entry is now fresh again. |\n| **REVALIDATING** | Background revalidation returns new `200 OK` | **FRESH** | 1. Replace the existing `CacheEntry` with a new one built from the new response. 2. New entry is stored with updated `key` (if headers changed) or overwrites the old one. |\n| ***Any State*** | **Purge** command received (by `key` or tag) | **MISS** | 1. Entry is removed from `CacheStorage`. 2. Any associated index entries (tags) are cleaned up. |\n\n### Structures for Invalidation\n\nInvalidation is the active process of removing or marking content as stale in the cache. Efficient invalidation requires auxiliary data structures that map invalidation targets (like tags or URL patterns) to the actual `CacheEntry` objects stored in the cache.\n\n**Mental Model: The Library Index Card Catalog**\nImagine the cache as a library. Each book is a `CacheEntry`. The primary card catalog (the `CacheStorage`) finds books by their primary ID (`key`). An **invalidation index** is like a secondary catalog:\n- **Surrogate Key Index**: Like a \"subject\" catalog. All books about \"Dinosaurs\" are filed under the \"Paleontology\" subject card. Purging the \"Paleontology\" tag means pulling every book linked to that card.\n- **Ban List**: Like a librarian's memo to remove \"all books published before 1950 from the Fantasy section\". It's a rule that is checked when books are accessed or during a cleanup sweep.\n\nThese structures enable powerful, granular cache management beyond simple URL purges.\n\n#### Surrogate Key Index\nTo enable tag-based purges, the system must maintain an inverted index mapping each surrogate key (tag) to the set of cache keys for entries that contain that tag. This is typically stored in memory for fast lookup.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `key_to_tags` | `Dict[str, List[str]]` | Mapping from a cache entry's `key` to its list of `surrogate_keys`. Maintained when a new entry is stored or updated. |\n| `tag_to_keys` | `Dict[str, Set[str]]` | Inverted index mapping a single surrogate key (tag) to the set of cache `key`s that are tagged with it. This is the core structure for `purge_by_tag` operations. |\n\n**Algorithm for Tag-Based Purge:**\n1.  Admin sends purge command for tag `T`.\n2.  Look up `tag_to_keys[T]` to get set `S` of cache keys.\n3.  For each key in `S`:\n    a. Remove the corresponding `CacheEntry` from the primary `CacheStorage`.\n    b. Remove the entry's key from `key_to_tags`.\n4.  Clear the set `tag_to_keys[T]` (or remove the key `T` entirely).\n\n> **Warning:** This index must be kept consistent with the primary cache. If an entry is evicted due to capacity (LRU), its tags must also be removed from the `tag_to_keys` index. This requires a cleanup hook during eviction.\n\n#### Ban Rule\nA **ban** is a pattern-based invalidation rule (e.g., \"all URLs under `/api/v1/products/*`\"). Unlike an immediate purge, bans are often evaluated lazily—when a cached entry is accessed, it's checked against active ban rules. This prevents unbounded memory growth from storing huge lists of purged URLs.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `pattern` | `str` | A pattern to match against cache entry URLs. For simplicity, we can support prefix matching (e.g., `/api/v1/products/`) or simple glob patterns. |\n| `created_at` | `float` | Timestamp when the ban was created. Allows for automatic expiration of ban rules after a configured TTL to prevent memory leaks. |\n| `is_soft` | `bool` | If `True`, the ban is a **soft purge**: matching entries are marked as stale but not immediately removed. They can be served during `stale-while-revalidate`. If `False`, entries are hard-purged (deleted). |\n\n**ADR: Ban Rule Storage and Evaluation**\n\n> **Decision: Lazy Evaluation of Ban Rules**\n> - **Context**: Bans can match a very large number of cached entries. Immediately iterating through all cache entries to find matches during ban creation is an O(n) operation that can block request handling, especially in large caches.\n> - **Options Considered**:\n>     1.  **Eager Evaluation**: On ban creation, scan all `CacheEntry` objects and immediately delete/update those that match.\n>     2.  **Lazy Evaluation**: Store ban rules in a list. Check each rule when a cache entry is *accessed* (on a potential cache hit). If it matches, treat it as a miss (or stale) and optionally delete it.\n>     3.  **Hybrid with Background Job**: Store ban rules and run a periodic background job that scans and invalidates matching entries.\n> - **Decision**: Implement **Lazy Evaluation** (Option 2).\n> - **Rationale**:\n>     - **Predictable Latency**: Ban creation becomes an O(1) insert operation, avoiding unpredictable delays during administrative actions.\n>     - **Simplicity**: Avoids the complexity of a background scanning thread and associated locking.\n>     - **Effective for Common Use**: Most banned content will naturally be re-requested by clients. When it is, it will be invalidated. Truly \"cold\" banned content that is never requested again will eventually be evicted by the LRU policy anyway.\n> - **Consequences**:\n>     - A banned item may remain in the cache until it is next requested or evicted by LRU. This is **eventual invalidation**.\n>     - Adds a small overhead to every cache lookup (must check against all active bans). The list of active bans must be kept small and have a TTL.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **Eager Evaluation** | Immediate consistency. Guaranteed removal. | O(n) scan blocks request handling. Poor performance for large caches. | No |\n| **Lazy Evaluation** | Fast ban creation. No scanning overhead. | Eventual consistency. Overhead per cache lookup. | **Yes** |\n| **Hybrid** | Balances immediacy and latency. | Adds system complexity (background jobs, coordination). | No |\n\n### Structures for Analytics\n\nTo operate and optimize a CDN, you must measure its performance. Analytics structures track metrics at various levels: per edge node, per origin shield, per content type, and over time.\n\n**Mental Model: The Power Plant Control Room**\nThink of analytics as the gauges and dials in a power plant control room. You need:\n- **Instantaneous meters** (like `current_hits`): What's happening right now?\n- **Cumulative totals** (like `total_bytes_served`): How much work have we done today?\n- **Rate calculations** (like `requests_per_second`): Is demand increasing?\n- **Breakdowns by category** (like `hits_by_status_code`): Are failures concentrated in a specific area?\n\nThese metrics allow operators to answer critical questions about cache effectiveness, origin load, and bandwidth usage.\n\nThe following structures are intended to be in-memory counters that are periodically flushed to a persistent store (like the **control plane**) or reset for rolling time windows (e.g., last 5 minutes).\n\n#### Edge Node Metrics\nEach **edge node** maintains a set of counters to track its own performance.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `total_hits` | `int` | Cumulative count of requests served directly from this edge's cache (HTTP status `200` from cache, or `304` from validation). |\n| `total_misses` | `int` | Cumulative count of requests that could not be served from cache and required an upstream fetch. |\n| `total_bandwidth_served` | `int` | Total bytes served to clients from this edge node (includes response bodies from both hits and misses). |\n| `total_bandwidth_upstream` | `int` | Total bytes fetched from upstream (shield or origin) to fulfill misses and revalidations. |\n| `hits_by_status` | `Dict[int, int]` | Breakdown of cache hits by the HTTP status code of the cached response (e.g., `200`, `404`, `301`). |\n| `hits_by_content_type` | `Dict[str, int]` | Breakdown of cache hits by the `Content-Type` of the response (e.g., `image/jpeg`, `text/html`). |\n| `current_cache_size` | `int` | Current number of `CacheEntry` objects stored in this node's `CacheStorage`. |\n| `current_cache_size_bytes` | `int` | Estimated total memory usage (in bytes) of the cache, including `CacheEntry` structures and their bodies. |\n\n#### Shield & Origin Metrics\nThe **origin shield** (and potentially each edge node, for its upstream) tracks metrics related to origin protection and request collapsing.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `collapsed_requests` | `int` | Count of requests that were deduplicated (collapsed) because another identical request was already in flight to the origin. This directly measures the shield's effectiveness in protecting the origin. |\n| `origin_request_queue_size` | `int` | Current number of requests waiting in the shield's queue (for rate limiting or collapsing). A persistently high queue indicates origin overload or insufficient shield capacity. |\n| `origin_errors` | `int` | Count of errors (5xx, network timeouts) received from the origin. A spike triggers health check failures and potential failover. |\n| `negative_cache_hits` | `int` | Count of requests served from cached negative responses (e.g., `404`, `503`). |\n\n#### Time-Windowed Metrics\nFor real-time dashboards, metrics are often tracked over sliding time windows (e.g., last 1 minute, last 5 minutes). This can be implemented using a circular buffer or bucket-based approach.\n\n| Field Name | Type | Description |\n| :--- | :--- | :--- |\n| `window_start` | `float` | Timestamp for the start of the current measurement window. |\n| `window_duration` | `float` | Duration of the window in seconds (e.g., 60.0 for 1 minute). |\n| `buckets` | `List[Dict]` | A list where each element is a metrics snapshot for a sub-interval within the window. For example, for a 5-minute window with 10-second granularity, there would be 30 buckets. |\n| `current_bucket_index` | `int` | Index pointing to the bucket currently being filled. |\n\n**Algorithm for Updating Time-Windowed Metrics:**\n1.  On each request completion, identify the relevant metrics (e.g., hit, miss, bytes served).\n2.  Determine the current time bucket based on `window_start`, `window_duration`, and bucket size.\n3.  If the current time has moved to a new bucket:\n    a. Increment `current_bucket_index` (wrapping around using modulo).\n    b. Reset the count in the new bucket to zero.\n    c. If the new bucket index has wrapped, update `window_start` to reflect the new start time of the oldest bucket.\n4.  Increment the counters in the current bucket.\n\nThis structure allows for efficient calculation of rates (e.g., hits per second over the last minute) by summing the still-relevant buckets.\n\n### Common Pitfalls in Data Modeling\n\n⚠️ **Pitfall: Forgetting to Normalize Header Values in `vary_headers`**\n- **Description**: When storing the `vary_headers` dictionary, using raw header values as sent by the client (e.g., `gzip, br` vs `gzip, br, deflate`) can lead to unnecessary cache fragmentation. The same semantic value may be expressed differently.\n- **Why it's wrong**: Two clients requesting the same resource with semantically identical `Accept-Encoding: gzip` and `Accept-Encoding: gzip, br` (where the server only supports gzip) would create two separate cache entries, wasting space.\n- **Fix**: Normalize header values before using them in the `key` and `vary_headers`. For `Accept-Encoding`, parse the value, intersect it with the server's supported encodings, and store a canonical form (e.g., `gzip`). Apply similar normalization for other `Vary` headers like `Accept-Language`.\n\n⚠️ **Pitfall: Storing Compressed Bodies in `CacheEntry.body`**\n- **Description**: Storing the response body exactly as received from upstream (e.g., gzip-compressed).\n- **Why it's wrong**: If a new client requests the same resource but only supports Brotli or no compression, the edge must re-fetch from origin or decompress and recompress on-the-fly, losing performance benefits.\n- **Fix**: Always store the **uncompressed** body in `CacheEntry.body`. Store the `Content-Encoding` header from the upstream response. When serving a client, check the `Accept-Encoding` request header, and apply the appropriate compression *at the edge* before sending. This is a form of **transcoding** that maximizes cache efficiency.\n\n⚠️ **Pitfall: Letting the `tag_to_keys` Index Grow Unbounded**\n- **Description**: Failing to clean up the inverted index when a `CacheEntry` is evicted from the primary cache (due to LRU) or when its tags change.\n- **Why it's wrong**: Memory leak. The index holds references to cache keys that no longer exist. A `purge_by_tag` operation would iterate over stale keys, wasting CPU and potentially causing errors.\n- **Fix**: Implement a **cleanup hook** in the `CacheStorage.evict()` method. When an entry is evicted, iterate through its `surrogate_keys` and remove its key from each corresponding set in `tag_to_keys`. If a set becomes empty, you may optionally delete the key from the dictionary.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n| Component | Simple Option (for Learning) | Advanced Option (for Production) |\n| :--- | :--- | :--- |\n| **Cache Storage** | In-memory dictionary (`dict`) with LRU eviction using `collections.OrderedDict` or a custom linked list. | External cache system like Redis (for distributed edges) or `lru-dict` library for efficient, bounded in-memory cache. |\n| **Metrics Storage** | In-memory counters, periodically logged to stdout or a local file. | Time-series database (Prometheus) with a push gateway, or streaming metrics to the Control Plane via a lightweight protocol. |\n| **Invalidation Index** | Nested Python dictionaries (`Dict[str, Set[str]]`) in memory. | Redis Sets and Hashes for persistence and cross-node sharing. |\n\n#### B. Recommended File/Module Structure\n```\nblue_origin_cdn/\n├── pyproject.toml\n├── src/\n│   └── blue_origin/\n│       ├── __init__.py\n│       ├── config.py                # EdgeConfig class and loading\n│       ├── models/                  # Data models (this section)\n│       │   ├── __init__.py\n│       │   ├── cache_entry.py       # CacheEntry class & CacheDirectives\n│       │   ├── invalidation.py      # SurrogateKeyIndex, BanRule\n│       │   └── analytics.py         # EdgeMetrics, ShieldMetrics\n│       ├── cache/                   # Milestone 1 & 5\n│       │   ├── storage.py           # CacheStorage abstract interface & LRU impl\n│       │   └── key.py               # Cache key generation utilities\n│       ├── handlers/                # HTTP request handlers\n│       │   ├── edge_handler.py      # EdgeRequestHandler\n│       │   └── shield_handler.py\n│       ├── http_utils/              # RFC 9111 helper functions\n│       │   ├── cache_control.py     # parse_cache_control_header, CacheDirectives.from_header\n│       │   └── dates.py             # parse_http_date, format_http_date\n│       ├── invalidation/            # Milestone 2\n│       │   └── manager.py           # Purge, ban, tag invalidation logic\n│       ├── analytics/               # Milestone 5\n│       │   └── collector.py         # Metrics collection and aggregation\n│       └── cli.py                   # Command-line interface for admin tasks\n└── tests/\n```\n\n#### C. Infrastructure Starter Code (Cache Directives & HTTP Utilities)\nThese utilities are prerequisites for parsing and handling HTTP caching headers correctly. They are provided complete and ready to use.\n\n**File: `src/blue_origin/http_utils/cache_control.py`**\n```python\n\"\"\"\nRFC 9111 Cache-Control header parsing utilities.\n\"\"\"\nfrom typing import Dict, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass CacheDirectives:\n    \"\"\"Structured representation of Cache-Control response directives.\"\"\"\n    s_maxage: Optional[int] = None\n    max_age: Optional[int] = None\n    no_cache: bool = False\n    no_store: bool = False\n    must_revalidate: bool = False\n    proxy_revalidate: bool = False\n    public: bool = False\n    private: bool = False\n    stale_while_revalidate: Optional[int] = None\n    stale_if_error: Optional[int] = None\n\n    @classmethod\n    def from_header(cls, cache_control_header: Optional[str]) -> \"CacheDirectives\":\n        \"\"\"\n        Parse a Cache-Control header string into a structured CacheDirectives object.\n        Handles multiple directives separated by commas.\n        \"\"\"\n        directives = cls()\n        if not cache_control_header:\n            return directives\n\n        # Split by comma, then by '=' for key-value directives\n        for token in cache_control_header.split(\",\"):\n            token = token.strip().lower()\n            if \"=\" in token:\n                key, val = token.split(\"=\", 1)\n                key = key.strip()\n                val = val.strip()\n                try:\n                    int_val = int(val)\n                except ValueError:\n                    # Ignore non-integer values for known int fields\n                    continue\n\n                if key == \"s-maxage\":\n                    directives.s_maxage = int_val\n                elif key == \"max-age\":\n                    directives.max_age = int_val\n                elif key == \"stale-while-revalidate\":\n                    directives.stale_while_revalidate = int_val\n                elif key == \"stale-if-error\":\n                    directives.stale_if_error = int_val\n            else:\n                # Boolean directives\n                if token == \"no-cache\":\n                    directives.no_cache = True\n                elif token == \"no-store\":\n                    directives.no_store = True\n                elif token == \"must-revalidate\":\n                    directives.must_revalidate = True\n                elif token == \"proxy-revalidate\":\n                    directives.proxy_revalidate = True\n                elif token == \"public\":\n                    directives.public = True\n                elif token == \"private\":\n                    directives.private = True\n        return directives\n\ndef parse_cache_control_header(header_value: Optional[str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Parse Cache-Control header into a dictionary of directive names to values.\n    Returns a dict where keys are directive names and values are either\n    the parameter (as string) or None for boolean directives.\n    \"\"\"\n    result = {}\n    if not header_value:\n        return result\n    for token in header_value.split(\",\"):\n        token = token.strip()\n        if \"=\" in token:\n            key, val = token.split(\"=\", 1)\n            result[key.strip().lower()] = val.strip()\n        else:\n            result[token.lower()] = None\n    return result\n```\n\n**File: `src/blue_origin/http_utils/dates.py`**\n```python\n\"\"\"\nHTTP date parsing and formatting (RFC 1123 / 822).\n\"\"\"\nimport time\nfrom email.utils import parsedate_to_datetime\nfrom datetime import datetime, timezone\nfrom typing import Optional\n\ndef parse_http_date(date_str: Optional[str]) -> Optional[float]:\n    \"\"\"\n    Parse an RFC 1123/822 date string into a Unix timestamp (float seconds since epoch).\n    Returns None if the string cannot be parsed.\n    \"\"\"\n    if not date_str:\n        return None\n    try:\n        # parsedate_to_datetime handles most common HTTP date formats\n        dt = parsedate_to_datetime(date_str)\n        # Ensure it's timezone-aware (UTC)\n        if dt.tzinfo is None:\n            dt = dt.replace(tzinfo=timezone.utc)\n        else:\n            dt = dt.astimezone(timezone.utc)\n        return dt.timestamp()\n    except (ValueError, TypeError):\n        return None\n\ndef format_http_date(timestamp: float) -> str:\n    \"\"\"\n    Format a Unix timestamp to RFC 1123 string.\n    \"\"\"\n    # Use UTC for HTTP dates\n    dt = datetime.fromtimestamp(timestamp, tz=timezone.utc)\n    # Format: 'Wed, 21 Oct 2015 07:28:00 GMT'\n    return dt.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n```\n\n#### D. Core Logic Skeleton Code (Data Model Classes)\n\n**File: `src/blue_origin/models/cache_entry.py`**\n\n![Data Model: Cache Entry & Relationships](./diagrams/data-model-class.svg)\n\n```python\n\"\"\"\nCore CacheEntry data model and associated logic.\n\"\"\"\nimport time\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, field\n\nfrom ..http_utils.cache_control import CacheDirectives\nfrom ..http_utils.dates import parse_http_date\n\n@dataclass\nclass CacheEntry:\n    # Field definitions as per the data model table\n    key: str\n    url: str\n    vary_headers: Dict[str, str]\n    status_code: int\n    headers: Dict[str, str]\n    body: bytes\n    fetched_at: float\n    expires_at: float\n    last_used_at: float = field(default_factory=time.time)\n    use_count: int = 0\n    surrogate_keys: List[str] = field(default_factory=list)\n    etag: Optional[str] = None\n    last_modified: Optional[str] = None\n\n    def is_fresh(self, current_time: Optional[float] = None) -> bool:\n        \"\"\"\n        Check if cache entry is still fresh (i.e., current_time < expires_at).\n        \"\"\"\n        # TODO 1: If current_time is None, use time.time()\n        # TODO 2: Compare current_time with self.expires_at\n        # TODO 3: Return True if current_time < expires_at, False otherwise\n        pass\n\n    def is_stale_but_revalidatable(self, current_time: Optional[float] = None) -> bool:\n        \"\"\"\n        Check if a stale entry can be served during background revalidation.\n        This depends on the stale-while-revalidate directive.\n        \"\"\"\n        # TODO 1: If current_time is None, use time.time()\n        # TODO 2: Check if current_time >= self.expires_at (i.e., stale)\n        # TODO 3: Parse Cache-Control from self.headers to get CacheDirectives\n        # TODO 4: If directives.stale_while_revalidate exists, calculate the grace period\n        # TODO 5: Return True if (current_time - self.expires_at) < grace_period\n        # TODO 6: Otherwise return False\n        pass\n\n    @classmethod\n    def from_upstream_response(\n        cls,\n        key: str,\n        url: str,\n        vary_headers: Dict[str, str],\n        status_code: int,\n        headers: Dict[str, str],\n        body: bytes,\n        surrogate_keys: List[str],\n    ) -> \"CacheEntry\":\n        \"\"\"\n        Factory method to create a CacheEntry from an upstream HTTP response.\n        Calculates fetched_at and expires_at based on current time and Cache-Control headers.\n        \"\"\"\n        # TODO 1: Record current time as fetched_at\n        # TODO 2: Parse Cache-Control header to get CacheDirectives\n        # TODO 3: Determine effective TTL (in seconds):\n        #   - Prefer s_maxage if present (CDN-specific)\n        #   - Then max_age\n        #   - Then fall back to parsing Expires header and subtracting fetched_at\n        #   - Default to a short TTL (e.g., 60 seconds) if none present\n        # TODO 4: Calculate expires_at = fetched_at + effective_ttl\n        # TODO 5: Extract etag and last_modified from headers\n        # TODO 6: Create and return a new CacheEntry instance with all fields\n        pass\n```\n\n**File: `src/blue_origin/models/invalidation.py`**\n```python\n\"\"\"\nData structures for cache invalidation: SurrogateKeyIndex and BanRule.\n\"\"\"\nimport time\nfrom typing import Dict, List, Set\n\nclass SurrogateKeyIndex:\n    \"\"\"\n    Inverted index mapping surrogate keys (tags) to cache entry keys.\n    \"\"\"\n    def __init__(self) -> None:\n        self.key_to_tags: Dict[str, List[str]] = {}\n        self.tag_to_keys: Dict[str, Set[str]] = {}\n\n    def add_entry(self, cache_key: str, tags: List[str]) -> None:\n        \"\"\"\n        Register a cache entry and its tags with the index.\n        \"\"\"\n        # TODO 1: Store mapping from cache_key -> tags in self.key_to_tags\n        # TODO 2: For each tag in tags, add cache_key to the set in self.tag_to_keys[tag]\n        #         (create the set if it doesn't exist)\n        pass\n\n    def remove_entry(self, cache_key: str) -> None:\n        \"\"\"\n        Remove a cache entry from the index, cleaning up tag associations.\n        \"\"\"\n        # TODO 1: Look up the tags for this cache_key from self.key_to_tags\n        # TODO 2: For each tag in those tags, remove cache_key from self.tag_to_keys[tag]\n        # TODO 3: If the set for a tag becomes empty, delete the tag key from the dictionary\n        # TODO 4: Remove the cache_key from self.key_to_tags\n        pass\n\n    def get_keys_for_tag(self, tag: str) -> Set[str]:\n        \"\"\"Return all cache keys tagged with the given tag.\"\"\"\n        return self.tag_to_keys.get(tag, set())\n\n    def purge_by_tag(self, tag: str) -> Set[str]:\n        \"\"\"\n        Return all cache keys for a given tag and clear the index for that tag.\n        Called by the invalidation manager.\n        \"\"\"\n        # TODO 1: Get the set of keys for this tag (or empty set)\n        # TODO 2: For each key in that set, remove it from self.key_to_tags\n        # TODO 3: Delete the tag entry from self.tag_to_keys\n        # TODO 4: Return the set of keys (so they can be purged from primary storage)\n        pass\n\n@dataclass\nclass BanRule:\n    \"\"\"Represents a pattern-based invalidation rule.\"\"\"\n    pattern: str  # e.g., \"/api/v1/products/*\"\n    created_at: float = time.time()\n    is_soft: bool = False  # True for soft purge (mark stale), False for hard purge\n\n    def matches(self, url: str) -> bool:\n        \"\"\"\n        Check if the given URL matches this ban rule.\n        For simplicity, implement prefix matching first.\n        \"\"\"\n        # TODO 1: For prefix matching, check if url.startswith(self.pattern)\n        # TODO 2: Return True if it matches, False otherwise\n        # Advanced: Implement simple glob matching (e.g., using fnmatch)\n        pass\n```\n\n#### E. Language-Specific Hints (Python)\n- Use `@dataclass` from the `dataclasses` module for clean, boilerplate-free data models. It automatically generates `__init__`, `__repr__`, and `__eq__` methods.\n- For the `SurrogateKeyIndex`, use Python's built-in `set` for `tag_to_keys` values to ensure uniqueness and fast membership tests.\n- Use `time.time()` for timestamps. It returns a float representing seconds since the Unix epoch in UTC (system clock dependent, but sufficient for relative TTLs).\n- When parsing dates, the `email.utils.parsedate_to_datetime` function handles the various HTTP date formats correctly and is in the standard library.\n- For thread-safe access to shared structures like the metrics counters or invalidation indexes, use `threading.Lock` or `threading.RLock`. Consider using `collections.defaultdict` for metrics breakdowns to avoid key checks.\n\n#### F. Milestone Checkpoint (Data Model)\nAfter implementing the data structures above, you should be able to run a simple test to verify their basic functionality.\n\n**Checkpoint Commands:**\n```bash\n# Run unit tests for the models module\npython -m pytest src/blue_origin/models/ -xvs\n\n# Expected: Tests should pass, demonstrating:\n# 1. CacheEntry.is_fresh() returns True before TTL, False after.\n# 2. SurrogateKeyIndex correctly adds and removes entries, maintaining consistency.\n# 3. BanRule.matches() correctly identifies URLs with a given prefix.\n```\n\n**Manual Verification Script:**\nCreate a simple script `test_models.py`:\n```python\nfrom blue_origin.models.cache_entry import CacheEntry, CacheDirectives\nfrom blue_origin.models.invalidation import SurrogateKeyIndex, BanRule\nimport time\n\n# Test CacheEntry freshness\nentry = CacheEntry(\n    key=\"test_key\",\n    url=\"/test\",\n    vary_headers={},\n    status_code=200,\n    headers={},\n    body=b\"\",\n    fetched_at=time.time() - 10,  # 10 seconds ago\n    expires_at=time.time() + 50,   # expires in 50 seconds\n)\nassert entry.is_fresh() == True\nprint(\"✓ CacheEntry freshness check passed\")\n\n# Test SurrogateKeyIndex\nindex = SurrogateKeyIndex()\nindex.add_entry(\"key1\", [\"tag1\", \"tag2\"])\nindex.add_entry(\"key2\", [\"tag2\"])\nassert index.get_keys_for_tag(\"tag2\") == {\"key1\", \"key2\"}\nindex.remove_entry(\"key1\")\nassert index.get_keys_for_tag(\"tag2\") == {\"key2\"}\nprint(\"✓ SurrogateKeyIndex consistency passed\")\n\n# Test BanRule prefix matching\nban = BanRule(pattern=\"/api/v1/\")\nassert ban.matches(\"/api/v1/products/123\") == True\nassert ban.matches(\"/static/image.jpg\") == False\nprint(\"✓ BanRule prefix matching passed\")\n```\n\nRun it: `python test_models.py`. All assertions should pass silently.\n\n\n## Component: Edge Cache (Milestone 1 & 5)\n\n> **Milestone(s):** Milestone 1 (Edge Cache Implementation), Milestone 5 (CDN Analytics & Performance Optimization)\n\nThe edge cache is the beating heart of a CDN. It's the component that directly interacts with end users, intercepting their requests and deciding whether to serve cached content instantly or fetch it from upstream. This section details the design and implementation of this critical component, combining the foundational caching logic from Milestone 1 with the performance optimizations from Milestone 5.\n\n### Mental Model: The Smart Mailroom\n\nImagine a large corporate office building with a central mailroom. All incoming packages (HTTP requests) arrive at this mailroom, and the mailroom clerk (edge cache) has a simple goal: deliver packages to employees (return responses to users) as quickly as possible.\n\n1. **Package Lookup (Cache Key)**: Each package is labeled with a recipient name and department (URL and Vary headers). The clerk first checks organized shelves (the cache) for an identical package already waiting.\n2. **Freshness Check (TTL)**: Packages have expiration dates stamped on them (Cache-Control headers). The clerk won't deliver stale milk (expired content).\n3. **Smart Validation (Conditional Requests)**: If a package looks old, the clerk calls the sender (origin) and asks, \"Has this changed since last Tuesday?\" (If-Modified-Since). If not, they reuse the old package (304 Not Modified).\n4. **Efficient Storage (Eviction)**: Shelves have limited space. When full, the clerk removes the least recently used packages (LRU) or packages from rarely visited departments (LFU) to make room for new arrivals.\n5. **Value-Added Services (Analytics & Compression)**: The clerk keeps a log of how many packages they handled (analytics) and can repack bulky items into smaller boxes (compression) before delivery to save bandwidth.\n\nThis mental model captures the core responsibilities: efficient storage/retrieval, freshness management, validation, and optimization—all performed at the \"edge\" where users first connect.\n\n### Interface & HTTP Flow\n\nThe `EdgeRequestHandler` is the primary interface between the outside world and the cache. It receives HTTP requests, processes them through the caching logic, and returns HTTP responses.\n\n**Interface Definition:**\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `EdgeRequestHandler.handle_request` | `request_headers: Dict[str, str]`, `request_body: bytes` | `Tuple[int, Dict[str, str], bytes]` (status, headers, body) | The main request processing entry point. It follows the caching algorithm defined in RFC 9111. |\n| `EdgeRequestHandler._fetch_from_upstream` | `headers: Dict[str, str]`, `body: bytes` | `Tuple[int, Dict[str, str], bytes]` | Forwards a request to the upstream (shield or origin) when a cache miss occurs. |\n| `EdgeRequestHandler._revalidate_in_background` | `cache_key: str`, `cache_entry: CacheEntry`, `request_headers: Dict[str, str]` | `None` | Asynchronously revalidates a stale-but-revalidatable cache entry while the current request is served stale content. |\n\n**Request Handling Algorithm:**\n\nThe flowchart ![Flowchart: Edge Node Request Handling](./diagrams/flowchart-request-handling.svg) illustrates the complete decision flow. Here is the step-by-step algorithm executed by `handle_request`:\n\n1. **Request Parsing & Normalization**: Extract the request URL, method, and relevant headers (`Cache-Control`, `If-None-Match`, `If-Modified-Since`, `Accept-Encoding`). Normalize the URL (e.g., remove default ports, ensure consistent casing for the scheme/host).\n\n2. **Cacheability Pre-check**: If the request method is not `GET` or `HEAD`, or if the request contains a `Cache-Control: no-store` directive, bypass the cache entirely and forward directly to `_fetch_from_upstream`.\n\n3. **Cache Key Generation**: Construct a unique `cache_key` by combining the normalized request URL with the values of all headers listed in the `Vary` header of the *cached response* (or if no cached entry exists yet, the current request's `Vary`-relevant headers). This ensures different representations (e.g., gzip vs. plain text) are stored separately.\n\n4. **Cache Lookup**: Query the `CacheStorage` with the generated `cache_key`. The result is either a `CacheEntry` (HIT) or `None` (MISS).\n\n5. **On Cache HIT**:\n   a. **Freshness Determination**: Calculate the current age of the entry (current time - `fetched_at`). Compare against TTL derived from `CacheDirectives` (see TTL Management below).\n   b. **If Fresh**: Serve the cached response immediately. Update `last_used_at` and `use_count` for eviction policies. Record a cache hit in `EdgeMetrics`.\n   c. **If Stale but Revalidatable**: Check `CacheDirectives.stale_while_revalidate`. If within this grace period, serve the stale response immediately (`_revalidate_in_background`), then asynchronously revalidate the entry with the origin and update the cache. Record a hit.\n   d. **If Stale and Must Revalidate**: The entry cannot be served without validation. Proceed to step 6 (Conditional Request) using the cached entry's `etag` and `last_modified`.\n\n6. **On Cache MISS or Need Validation**:\n   a. **Prepare Upstream Request**: If a cached entry exists (for validation), add `If-None-Match: {etag}` and/or `If-Modified-Since: {last_modified}` headers to the upstream request.\n   b. **Fetch from Upstream**: Call `_fetch_from_upstream` with the (potentially conditional) request.\n   c. **Handle Response**:\n      - **304 Not Modified (Validation Success)**: The cached entry is fresh. Update its `fetched_at` and `expires_at` timestamps based on new headers in the 304 response, then serve the cached body. Record a hit.\n      - **200 OK (Miss or Changed)**: This is a new or updated resource. Determine if the response is cacheable using `is_response_cacheable`. If cacheable, create a new `CacheEntry` via `CacheEntry.from_upstream_response` and store it. Record a miss.\n      - **Any other status**: Pass through to client. Cache error responses (like 404, 500) only if they have explicit caching directives (negative caching).\n\n7. **Post-Processing**: Before returning the final response:\n   a. **Compression (Milestone 5)**: If the client supports compression (`Accept-Encoding`) and the content type is compressible (e.g., text/html), and the response isn't already compressed, apply gzip or Brotli compression. Update the `Content-Encoding` and `Content-Length` headers.\n   b. **Add Diagnostic Headers**: Append headers like `X-Cache: HIT` or `X-Cache: MISS` for debugging.\n   c. **Update Analytics**: Increment counters in `EdgeMetrics` (hits, misses, bandwidth served).\n\n8. **Return Response**: Send the final status code, headers, and body to the client.\n\n### Cache Key & TTL Management\n\nTwo of the most critical and subtle aspects of HTTP caching are correctly constructing cache keys and interpreting the hierarchy of TTL directives.\n\n**Cache Key Construction:**\n\nThe cache key must uniquely identify a *representation* of a resource, not just the resource itself. The primary inputs are:\n1. **Request URL**: The full URL including scheme, host, port, path, and query string.\n2. **Vary Header Dimensions**: The values of request headers listed in the `Vary` header of the *cached response*.\n\n> **Key Insight:** You cannot know which request headers are relevant for variation until *after* you have received a response from the origin. Therefore, the cache key for lookup (step 4 above) must be constructed using the *Vary header from the previously cached entry*. If no entry exists, you must store the request's headers that *might* be varied on, and then after fetching the response, use its `Vary` header to construct the final storage key.\n\n| Header | Role in Cache Key | Example |\n|--------|-------------------|---------|\n| `Vary: Accept-Encoding` | Cache key must include the `Accept-Encoding` value from the request. | Requests for `image.jpg` with `Accept-Encoding: gzip` and `Accept-Encoding: identity` get separate cache entries. |\n| `Vary: User-Agent` | Cache key includes the `User-Agent` string. | Different cache entries for mobile vs. desktop versions of a page. |\n| `Vary: *` | Special case: The response is **never** stored. | Serves as a directive to never cache this response. |\n\n**TTL Management & Freshness Calculation:**\n\nA `CacheEntry`'s freshness is determined by its `expires_at` timestamp, which is calculated when the entry is created or revalidated. The hierarchy of TTL directives, from most to least authoritative for a shared cache (like our CDN), is:\n\n1. `Cache-Control: s-maxage=<seconds>`: Explicitly for shared caches. Overrides `max-age` and `Expires`.\n2. `Cache-Control: max-age=<seconds>`: For both private and shared caches.\n3. `Expires: <date>`: An absolute expiration date.\n4. Heuristic Freshness: If no explicit directive exists, RFC 9111 allows using a heuristic (e.g., 10% of the time since `Last-Modified`). For simplicity, we treat such responses as non-cacheable unless explicitly configured otherwise.\n\nThe `CacheDirectives.from_header` method parses the `Cache-Control` header string into a structured object. The algorithm for calculating `expires_at` is:\n\n```\nfetched_at = current_time\nif directives.s_maxage is not None:\n    expires_at = fetched_at + directives.s_maxage\nelif directives.max_age is not None:\n    expires_at = fetched_at + directives.max_age\nelif Expires header exists and is valid:\n    expires_at = parse_http_date(Expires_header)\nelse:\n    // Not cacheable by explicit directives\n```\n\nThe `CacheEntry.is_fresh(current_time)` method simply returns `current_time < expires_at`.\n\n**Stale-While-Revalidate & Stale-If-Error:**\nThese directives allow graceful behavior beyond simple freshness:\n- `stale-while-revalidate`: After `expires_at`, for the next N seconds, the cache may serve stale data while asynchronously revalidating it.\n- `stale-if-error`: If the origin is failing, stale content may be served for N seconds past expiration.\n\nThese are checked by `CacheEntry.is_stale_but_revalidatable`.\n\n### ADR: Cache Storage & Eviction Policy\n\n> **Decision: In-Memory LRU Cache with Size Limit**\n> - **Context**: We need a fast, concurrent cache storage layer for the edge node. The cache must hold thousands to millions of responses, evict entries when capacity is reached, and support fast lookups by complex string keys.\n> - **Options Considered**:\n>   1. **In-memory LRU/LFU cache**: Store everything in the node's RAM using a structure like a hash map + doubly linked list for LRU ordering.\n>   2. **Disk-backed cache (e.g., SQLite, RocksDB)**: Use local SSD storage for larger capacity, trading some latency for persistence and size.\n>   3. **External cache service (e.g., Redis, Memcached)**: Delegate storage to a dedicated in-memory data store, allowing multiple edge processes to share a cache.\n> - **Decision**: Implement an in-memory LRU (Least Recently Used) cache as the default `CacheStorage`.\n> - **Rationale**:\n>   - **Performance**: RAM access is orders of magnitude faster than disk or network. Edge caching's primary goal is low latency.\n>   - **Simplicity**: An in-memory LRU is straightforward to implement and reason about. Python's `functools.lru_cache` or a custom `OrderedDict`-based implementation works well.\n>   - **Predictable Memory Footprint**: A size limit (e.g., 1GB) ensures the cache doesn't cause the node to run out of memory.\n>   - **Educational Value**: Implementing LRU eviction teaches fundamental data structure concepts.\n> - **Consequences**:\n>   - **Volatility**: Cache contents are lost on process restart. This is acceptable for a CDN edge (cache warming can repopulate).\n>   - **Size Limitation**: The cache cannot exceed available RAM. Large media files may limit the number of objects cached.\n>   - **Single-Node Only**: Cache is not shared between edge processes on different machines. This is fine for our architecture where each edge node is independent.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| In-memory LRU/LFU | Extremely fast, simple to implement, predictable memory use | Volatile, limited to RAM size, not shared | **Yes** (LRU for simplicity) |\n| Disk-backed cache | Larger capacity, persistent across restarts | Higher latency (I/O), more complex eviction (disk space), wear on SSDs | No |\n| External cache service | Shared cache across processes, potentially larger, persistence options | Network latency added to every lookup, extra operational complexity | No |\n\n**Eviction Policy Details:**\nWhen the cache reaches its configured capacity (in bytes or item count), it must evict entries. LRU eviction removes the entry with the oldest `last_used_at` timestamp. This assumes recent requests are predictive of future requests, which is a common access pattern. The `CacheEntry.last_used_at` field must be updated on every cache hit.\n\nAn alternative is LFU (Least Frequently Used), which evicts the entry with the smallest `use_count`. This can better retain \"popular but not recently accessed\" items but requires more overhead to track and decay frequencies. For our educational project, LRU provides a good balance.\n\n### Common Pitfalls in Edge Caching\n\n⚠️ **Pitfall: Ignoring the Vary Header**\n**Description**: Constructing cache keys using only the URL, ignoring the `Vary` header. This causes cache corruption where a user requesting a gzipped version might get a plain-text version cached for a different user.\n**Why it's wrong**: Violates HTTP semantics, serves incorrect content, and can break websites.\n**Fix**: Always include the normalized values of *all* headers listed in the cached response's `Vary` header in the cache key. Handle `Vary: *` by not caching at all.\n\n⚠️ **Pitfall: Confusing s-maxage and max-age**\n**Description**: Using `max-age` when `s-maxage` is present for shared cache decisions.\n**Why it's wrong**: `s-maxage` is specifically for shared caches (like CDNs). Using `max-age` instead may cause the CDN to cache content for shorter durations than intended for public users, increasing origin load.\n**Fix**: In your TTL calculation hierarchy, prioritize `s-maxage` over `max-age` for shared caches.\n\n⚠️ **Pitfall: Cache Key Collisions with Normalization**\n**Description**: Different URLs that point to the same resource (e.g., `http://example.com` vs `http://example.com:80`, or differing query parameter order) create duplicate cache entries.\n**Why it's wrong**: Wastes cache space, reduces hit rates.\n**Fix**: Normalize URLs before generating cache keys: convert scheme/host to lowercase, remove default ports, sort query parameters alphabetically (if the origin treats them as order-independent).\n\n⚠️ **Pitfall: Forgetting to Cache 304 Responses**\n**Description**: When a conditional request returns `304 Not Modified`, not updating the cached entry's freshness metadata.\n**Why it's wrong**: The cached entry's `expires_at` remains based on the original fetch time, causing it to become stale prematurely.\n**Fix**: On a 304 response, extract any new `Cache-Control`, `Expires`, or `ETag` headers from the response and update the existing `CacheEntry`'s metadata accordingly, effectively \"refreshing\" the TTL.\n\n⚠️ **Pitfall: Not Respecting no-store on Requests**\n**Description**: Caching responses for requests that contained `Cache-Control: no-store`.\n**Why it's wrong**: The user explicitly requested that sensitive information not be stored. Violating this is a privacy/security issue.\n**Fix**: Check request directives at the start of the algorithm and bypass the cache entirely for `no-store` requests.\n\n### Implementation Guidance for Edge Cache\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option (for Learning) | Advanced Option (for Production) |\n|-----------|------------------------------|----------------------------------|\n| HTTP Server | Python's `http.server` with threading | `asyncio` + `aiohttp` for high concurrency |\n| Cache Storage | Python `dict` + `collections.OrderedDict` for LRU | `lru-dict` library or custom sharded hash map |\n| Compression | Python's `gzip` library | `brotli` library for Brotli compression |\n| Header Parsing | Manual string splitting using `parse_cache_control_header` | Use `cachetools` library for RFC-compliant parsing |\n\n**B. Recommended File/Module Structure:**\n\n```\nblue_origin/\n├── README.md\n├── pyproject.toml\n├── src/\n│   └── blue_origin/\n│       ├── __init__.py\n│       ├── config.py                    # EdgeConfig, config loading\n│       ├── constants.py                 # HTTP constants, defaults\n│       ├── models/                      # Data models\n│       │   ├── __init__.py\n│       │   ├── cache.py                 # CacheEntry, CacheDirectives\n│       │   ├── metrics.py               # EdgeMetrics, TimeWindowedMetrics\n│       │   └── invalidation.py          # SurrogateKeyIndex, BanRule\n│       ├── cache/                       # Core caching logic\n│       │   ├── __init__.py\n│       │   ├── storage.py               # CacheStorage interface & LRU impl\n│       │   ├── key_generator.py         # Cache key generation\n│       │   ├── ttl_manager.py           # TTL calculation\n│       │   └── validator.py             # Conditional request logic\n│       ├── handlers/                    # HTTP handlers\n│       │   ├── __init__.py\n│       │   ├── edge_handler.py          # EdgeRequestHandler\n│       │   └── purge_handler.py         # Admin API for invalidation\n│       ├── middleware/                  # Response processing\n│       │   ├── __init__.py\n│       │   ├── compression.py           # gzip/Brotli compression\n│       │   └── analytics.py             # Metrics collection\n│       ├── utils/                       # Utilities\n│       │   ├── __init__.py\n│       │   ├── http_utils.py            # parse_http_date, etc.\n│       │   └── headers.py               # Header manipulation\n│       └── server.py                    # Main server entry point\n└── tests/\n```\n\n**C. Infrastructure Starter Code (COMPLETE HTTP Utilities):**\n\n```python\n# src/blue_origin/utils/http_utils.py\n\"\"\"\nHTTP utility functions for parsing and formatting dates, headers, etc.\n\"\"\"\nimport time\nfrom email.utils import parsedate_to_datetime\nfrom typing import Dict, List, Optional\nfrom urllib.parse import urlparse, urlunparse\n\ndef parse_http_date(date_str: str) -> Optional[float]:\n    \"\"\"Parse an RFC 1123/822 date string into a Unix timestamp.\"\"\"\n    if not date_str:\n        return None\n    try:\n        dt = parsedate_to_datetime(date_str)\n        return dt.timestamp()\n    except (ValueError, TypeError):\n        return None\n\ndef format_http_date(timestamp: float) -> str:\n    \"\"\"Format a Unix timestamp to RFC 1123 string.\"\"\"\n    return time.strftime('%a, %d %b %Y %H:%M:%S GMT', time.gmtime(timestamp))\n\ndef parse_cache_control_header(header_value: Optional[str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Parse Cache-Control header into dictionary of directives.\n    Example: \"max-age=60, public\" -> {\"max-age\": \"60\", \"public\": None}\n    \"\"\"\n    directives = {}\n    if not header_value:\n        return directives\n    for part in header_value.split(','):\n        part = part.strip()\n        if '=' in part:\n            key, val = part.split('=', 1)\n            directives[key.strip()] = val.strip()\n        else:\n            directives[part] = None\n    return directives\n\ndef get_header_values(headers: Dict[str, str], header_name: str) -> List[str]:\n    \"\"\"\n    Get all values for a header (handling comma-separated and multiple headers).\n    HTTP allows multiple headers with same name and comma-separated values.\n    \"\"\"\n    # Case-insensitive search\n    header_name_lower = header_name.lower()\n    matched_values = []\n    for name, value in headers.items():\n        if name.lower() == header_name_lower:\n            # Split by comma, but be careful of quoted strings (simple split works for most caching headers)\n            matched_values.extend([v.strip() for v in value.split(',')])\n    return matched_values\n\ndef normalize_url(url: str) -> str:\n    \"\"\"\n    Normalize URL for cache key: lowercase scheme/host, remove default port.\n    Does NOT sort query parameters (application-specific).\n    \"\"\"\n    parsed = urlparse(url)\n    # Lowercase scheme and host\n    scheme = parsed.scheme.lower()\n    netloc = parsed.hostname.lower() if parsed.hostname else ''\n    # Add port if non-default\n    if parsed.port:\n        if not (scheme == 'http' and parsed.port == 80) and not (scheme == 'https' and parsed.port == 443):\n            netloc = f'{netloc}:{parsed.port}'\n    # Reconstruct without fragment (fragment is never sent to server)\n    return urlunparse((scheme, netloc, parsed.path, parsed.params, parsed.query, ''))\n```\n\n**D. Core Logic Skeleton Code:**\n\n```python\n# src/blue_origin/cache/key_generator.py\n\"\"\"\nCache key generation combining URL and Vary header values.\n\"\"\"\nfrom typing import Dict, List\nfrom ..utils.http_utils import normalize_url\n\ndef generate_cache_key(url: str, vary_headers: Dict[str, str], vary_header_list: List[str]) -> str:\n    \"\"\"\n    Generate a cache key from URL and the values of headers specified in Vary.\n    \n    Args:\n        url: The request URL (will be normalized).\n        vary_headers: Dictionary containing ALL request headers (lowercased keys).\n        vary_header_list: List of header names from the cached response's Vary header.\n    \n    Returns:\n        A string cache key.\n    \n    TODO 1: Normalize the URL using normalize_url()\n    TODO 2: For each header name in vary_header_list:\n            a. Get its value from vary_headers (case-insensitive)\n            b. If header is not present, use empty string\n            c. Normalize header value (strip, lowercase for some headers?)\n    TODO 3: Sort the vary_header_list to ensure consistent key generation\n            (Vary: Accept-Encoding,User-Agent should match Vary: User-Agent,Accept-Encoding)\n    TODO 4: Combine normalized URL with sorted header name-value pairs\n            Example format: \"GET:{url}:{header1}={value1}:{header2}={value2}\"\n    TODO 5: Return the combined string (consider hashing for shorter keys if needed)\n    \"\"\"\n    pass\n\n# src/blue_origin/models/cache.py\n\"\"\"\nCache data structures.\n\"\"\"\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport time\n\n@dataclass\nclass CacheDirectives:\n    \"\"\"Parsed Cache-Control directives.\"\"\"\n    s_maxage: Optional[int] = None\n    max_age: Optional[int] = None\n    no_cache: bool = False\n    no_store: bool = False\n    must_revalidate: bool = False\n    proxy_revalidate: bool = False\n    public: bool = False\n    private: bool = False\n    stale_while_revalidate: Optional[int] = None\n    stale_if_error: Optional[int] = None\n    \n    @classmethod\n    def from_header(cls, cache_control_header: Optional[str]) -> 'CacheDirectives':\n        \"\"\"\n        Parse a Cache-Control header string into a structured object.\n        \n        TODO 1: Use parse_cache_control_header() to get dictionary of directives\n        TODO 2: Initialize a CacheDirectives instance with default values\n        TODO 3: For each key-value in the dictionary:\n                a. Handle boolean directives (no-cache, no-store, etc.): set to True if present\n                b. Handle numeric directives (s-maxage, max-age, etc.): convert string to int\n        TODO 4: Special case: 'public' and 'private' are mutually exclusive\n                (private takes precedence if both are present per RFC 9111)\n        TODO 5: Return the populated CacheDirectives object\n        \"\"\"\n        pass\n\n@dataclass\nclass CacheEntry:\n    \"\"\"A cached HTTP response.\"\"\"\n    key: str\n    url: str\n    vary_headers: Dict[str, str]\n    status_code: int\n    headers: Dict[str, str]\n    body: bytes\n    fetched_at: float\n    expires_at: float\n    last_used_at: float = field(default_factory=time.time)\n    use_count: int = 1\n    surrogate_keys: List[str] = field(default_factory=list)\n    etag: Optional[str] = None\n    last_modified: Optional[str] = None\n    \n    def is_fresh(self, current_time: float) -> bool:\n        \"\"\"Check if cache entry is still fresh.\"\"\"\n        # TODO: Return True if current_time < expires_at, False otherwise\n        pass\n    \n    def is_stale_but_revalidatable(self, current_time: float, directives: CacheDirectives) -> bool:\n        \"\"\"\n        Check if stale entry can be served during revalidation.\n        \n        TODO 1: If entry is fresh, return False (no need for revalidation)\n        TODO 2: Calculate staleness: current_time - expires_at\n        TODO 3: Check if directives.stale_while_revalidate exists and staleness <= that value\n        TODO 4: Return True if conditions met, False otherwise\n        \"\"\"\n        pass\n    \n    @classmethod\n    def from_upstream_response(cls, key: str, url: str, vary_headers: Dict[str, str],\n                               status_code: int, headers: Dict[str, str], body: bytes,\n                               surrogate_keys: List[str]) -> 'CacheEntry':\n        \"\"\"\n        Factory method to create a CacheEntry from an upstream HTTP response.\n        \n        TODO 1: Parse Cache-Control header from response headers\n        TODO 2: Calculate TTL and set expires_at (use current time for fetched_at)\n        TODO 3: Extract ETag and Last-Modified headers if present\n        TODO 4: Create and return a CacheEntry instance with all fields populated\n        \"\"\"\n        pass\n\n# src/blue_origin/handlers/edge_handler.py\n\"\"\"\nMain edge request handler.\n\"\"\"\nimport time\nfrom typing import Dict, Tuple\nfrom ..cache.storage import CacheStorage\nfrom ..models.cache import CacheEntry, CacheDirectives\nfrom ..utils.http_utils import parse_http_date, get_header_values\n\nclass EdgeRequestHandler:\n    def __init__(self, cache: CacheStorage, upstream: str):\n        self.cache = cache\n        self.upstream = upstream\n    \n    def handle_request(self, request_headers: Dict[str, str], \n                       request_body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Main request handling algorithm for the edge node.\n        \n        TODO 1: Extract method, URL, and relevant headers from request_headers\n        TODO 2: Check if request is cacheable (method GET/HEAD, no no-store directive)\n        TODO 3: Generate preliminary cache key (use request's Vary-relevant headers)\n        TODO 4: Look up entry in cache\n        TODO 5: If cache HIT:\n                a. Check freshness and revalidation rules\n                b. If fresh or stale-while-revalidate: serve from cache\n                c. If needs validation: add If-None-Match/If-Modified-Since\n        TODO 6: If cache MISS or validation needed:\n                a. Forward request to upstream with conditional headers\n                b. Handle response:\n                   - 304: Update cached entry metadata, serve cached body\n                   - 200: Create new cache entry if cacheable\n                   - Other: Pass through\n        TODO 7: Apply compression middleware if applicable\n        TODO 8: Add diagnostic headers (X-Cache: HIT/MISS)\n        TODO 9: Update metrics\n        TODO 10: Return final response\n        \"\"\"\n        pass\n    \n    def _fetch_from_upstream(self, headers: Dict[str, str], \n                             body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Forward request to upstream (shield or origin).\n        \n        TODO 1: Add CDN-specific headers (X-Forwarded-For, etc.)\n        TODO 2: Make HTTP request to self.upstream\n        TODO 3: Return status, headers, body from upstream response\n        \"\"\"\n        pass\n    \n    def _revalidate_in_background(self, cache_key: str, cache_entry: CacheEntry,\n                                  request_headers: Dict[str, str]) -> None:\n        \"\"\"\n        Asynchronously revalidate a stale cache entry.\n        \n        TODO 1: Create a background thread/task\n        TODO 2: Make conditional request to upstream with cache_entry.etag/last_modified\n        TODO 3: If 304: Update cache_entry.fetched_at and expires_at\n        TODO 4: If 200: Replace cache entry with new response\n        TODO 5: If error: Log and keep stale entry (might be served via stale-if-error later)\n        \"\"\"\n        pass\n```\n\n**E. Language-Specific Hints (Python):**\n- Use `threading.Lock` or `asyncio.Lock` to protect concurrent access to the cache storage.\n- For LRU cache implementation, `collections.OrderedDict` maintains insertion order. On every cache hit, move the key to the end using `move_to_end(key, last=True)`. When evicting, pop the first item.\n- Use `email.utils.parsedate_to_datetime` for robust HTTP date parsing (handles multiple formats).\n- For background tasks, consider `concurrent.futures.ThreadPoolExecutor` or `asyncio.create_task` depending on your concurrency model.\n- When applying compression, check `Accept-Encoding` header for `gzip` or `br` (Brotli). Use Python's `gzip.compress()` and the `brotli` library if installed.\n\n**F. Milestone Checkpoint (Edge Cache):**\nAfter implementing the edge cache, run the following test:\n1. Start your edge server: `python -m blue_origin.server --config config.yaml`\n2. Use `curl` to make requests:\n   ```\n   curl -v http://localhost:8080/image.jpg\n   ```\n   First request should show `X-Cache: MISS`. Second identical request should show `X-Cache: HIT`.\n3. Test conditional requests: Add an `If-None-Match` header with a known ETag from a previous response. You should receive `304 Not Modified`.\n4. Verify TTL: Set a `Cache-Control: max-age=2` header on your origin server. Request the resource, wait 3 seconds, request again. The second request should trigger a revalidation or miss.\n5. Check compression: `curl -H \"Accept-Encoding: gzip\" -v http://localhost:8080/some-text.html` should show `Content-Encoding: gzip` in the response.\n\nExpected behavior: The edge server responds correctly to cache directives, respects freshness, and shows improved performance on repeated requests.\n\n\n## Component: Cache Invalidation (Milestone 2)\n\n> **Milestone(s):** Milestone 2 (Cache Invalidation)\n\nThe edge cache's ability to serve content quickly becomes useless when that content changes at the origin. **Cache invalidation**—the active removal or marking of outdated cached content—is the mechanism that maintains consistency between the cached copies and the origin's truth. This component transforms the CDN from a static snapshotter into a dynamic, synchronized delivery system. Implementing invalidation is a classic distributed systems challenge: we must ensure that updates propagate to potentially hundreds of edge nodes, each holding independent copies, without overwhelming the system or introducing prolonged inconsistency windows.\n\n### Mental Model: The Building Eviction Notice\n\nImagine the CDN's cache as a large apartment building (the cache storage). Each apartment (cache entry) is rented by a tenant (a cached response). When the building owner (the origin) decides to change the terms or reclaim an apartment, they issue different types of notices:\n\n1.  **Hard Purge (Immediate Eviction):** A sheriff arrives, immediately removes the tenant, and changes the locks. The apartment is now empty. This is analogous to a **hard purge**—the cache entry is deleted instantly. The next request for that resource will experience a cache miss and fetch a fresh copy from the origin.\n\n2.  **Soft Purge (Notice to Renew Lease):** The owner posts a notice saying, \"Your current lease expires now, but you can stay while we process a renewal.\" The tenant remains in the apartment temporarily. This is a **soft purge** (or stale-while-revalidate). The cache marks the entry as stale but continues serving it to clients while asynchronously fetching a fresh version in the background. This provides graceful degradation and avoids a thundering herd of requests to the origin.\n\n3.  **Ban (Evicting Everyone on a Floor):** The building manager declares, \"Everyone in apartments with numbers ending in '01' must leave.\" This is a **ban**—a pattern-based invalidation. Instead of specifying each apartment, you define a rule (e.g., a URL pattern like `/blog/*`). The eviction may happen immediately or, in **eventual invalidation**, only when someone next tries to enter that apartment (cache access). Bans are powerful for bulk operations but require careful management to avoid unbounded rule growth.\n\n4.  **Surrogate Key Purge (Tag-Based Eviction):** Apartments are tagged with colored stickers representing features (e.g., \"renovated,\" \"ocean view\"). The owner announces, \"All apartments with a 'renovated' sticker must be updated.\" This is **tag-based invalidation** using **surrogate keys**. Cache entries are tagged (e.g., with `product-12345`) upon storage. Invalidating by that tag removes all related entries in a single operation, which is far more efficient than listing every individual URL.\n\nThis mental model clarifies the trade-offs: immediacy vs. origin load, precision vs. management overhead. A production CDN uses all these \"notice types\" in different scenarios.\n\n### Purge, Ban, and Tag-Based Invalidation\n\nThe invalidation component exposes administrative APIs and internal logic to execute the three core invalidation strategies. Each strategy targets a different granularity and use case.\n\n#### 1. Purge by Exact URL\n\nThe most precise operation. It removes a single cached response identified by its exact cache key (URL + Vary header values).\n\n**Algorithm: Hard Purge by URL**\n1.  An administrative request arrives (e.g., `PURGE /images/photo.jpg` with authentication).\n2.  The handler validates the requestor's permissions.\n3.  It constructs the exact cache key from the request URL and the relevant `Vary` header dimensions (extracted from the request or by looking up the stored entry).\n4.  It synchronously deletes the corresponding `CacheEntry` from the `CacheStorage`.\n5.  It removes the cache key from the `SurrogateKeyIndex` (if indexed).\n6.  It returns a `200 OK` acknowledging the purge.\n\n**Algorithm: Soft Purge by URL**\n1.  Steps 1-3 are identical to hard purge.\n2.  Instead of deletion, it updates the `CacheEntry.expires_at` to a timestamp in the past (e.g., `current_time - 1`), immediately marking it stale.\n3.  It optionally sets a flag or updates metadata to indicate the entry is under soft purge.\n4.  It triggers `_revalidate_in_background` for this key, which will asynchronously fetch a new version from the origin and update the cache.\n5.  Subsequent client requests for this key will be served the stale content (if `stale-while-revalidate` directives allow) while the background refresh proceeds.\n6.  Returns a `200 OK` acknowledging the soft purge.\n\n**API Specification**\n| Method | Path | Headers | Body | Returns | Description |\n|--------|------|---------|------|---------|-------------|\n| `PURGE` | `/{path:.*}` | `Authorization: Bearer <token>`, `Soft-Purge: 1` (optional) | Empty | `200 OK` (success), `404 Not Found` (key not in cache), `401 Unauthorized` | Hard or soft purge of the exact URL path. The `Soft-Purge` header triggers the soft purge behavior. |\n\n#### 2. Ban by Pattern (Eventual Invalidation)\n\nA ban is a rule that invalidates cache entries matching a pattern (e.g., a regex or glob applied to the URL). For performance, bans are often applied **lazily** (eventually) upon cache access, not by scanning the entire cache store.\n\n**Data Structure: `BanRule`**\nWe extend the provided structure to support pattern matching and TTL.\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `pattern` | `str` | The URL-matching pattern (e.g., glob `\"/images/*.jpg\"` or regex `\"^/blog/2024-\"`). |\n| `created_at` | `float` | Unix timestamp when the ban was created. |\n| `is_soft` | `bool` | If `True`, matching entries are marked stale (soft purge). If `False`, they are deleted (hard purge). |\n| `ttl_seconds` | `float` | Time-to-live for this ban rule. After expiry, the rule is garbage-collected. Prevents unbounded growth. |\n| `id` | `str` | Unique identifier for the ban rule. |\n\n**Algorithm: Adding a Ban Rule**\n1.  Admin request (`POST /ban` with pattern and soft/hard flag).\n2.  Validate and compile the pattern for efficient matching.\n3.  Create a new `BanRule` with `created_at = current_time` and assign a unique ID.\n4.  Store the rule in a `BanRuleList` (e.g., a list or priority queue sorted by `created_at`).\n5.  Return the ban rule ID.\n\n**Algorithm: Applying Bans (Lazy Evaluation)**\nThis logic integrates into the main `EdgeRequestHandler.handle_request` flow, just after cache key generation but before cache lookup.\n1.  When a request arrives, generate the cache key (URL).\n2.  Before checking the cache, iterate through the active `BanRuleList`.\n3.  For each `BanRule` where `BanRule.matches(cache_key.url)` returns `True`:\n    a. If `is_soft` is `False`: Delete the cache entry for this key (if it exists) and skip to origin fetch (cache miss).\n    b. If `is_soft` is `True`: Mark the existing entry as stale (set `expires_at` in the past) and allow the request to proceed. The stale entry may be served while triggering background revalidation.\n4.  If no matching ban rule applies, proceed with normal cache lookup.\n\n**Garbage Collection of Ban Rules**\nA background task periodically scans the `BanRuleList` and removes rules where `current_time > created_at + ttl_seconds`. A typical TTL for bans might be 24-48 hours.\n\n**API Specification**\n| Method | Path | Headers | Body (JSON) | Returns | Description |\n|--------|------|---------|-------------|---------|-------------|\n| `POST` | `/ban` | `Authorization: Bearer <token>` | `{\"pattern\": \"/images/*.jpg\", \"soft\": false, \"ttl_seconds\": 86400}` | `201 Created` with `{\"ban_id\": \"...\"}` | Creates a new ban rule. |\n| `DELETE` | `/ban/{ban_id}` | `Authorization: Bearer <token>` | Empty | `200 OK` or `404 Not Found` | Removes a specific ban rule. |\n\n#### 3. Tag-Based Invalidation with Surrogate Keys\n\nThis method groups cache entries by arbitrary tags (surrogate keys) provided by the origin via the `Surrogate-Key` response header. Invalidating by a tag removes all entries associated with that tag.\n\n**Data Structure: `SurrogateKeyIndex`**\nWe utilize the provided structure, which maintains a bidirectional mapping.\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `key_to_tags` | `Dict[str, List[str]]` | Maps a cache key to a list of surrogate key tags associated with that entry. |\n| `tag_to_keys` | `Dict[str, Set[str]]` | Maps a tag to a set of cache keys that are tagged with it. |\n\n**Algorithm: Tagging on Cache Storage**\n1.  When storing a new `CacheEntry` (on cache miss), extract the `Surrogate-Key` header from the origin response. The header value is a space-separated list of tags (e.g., `Surrogate-Key: product-12345 category-shoes`).\n2.  Store the list of tags in `CacheEntry.surrogate_keys`.\n3.  Call `SurrogateKeyIndex.add_entry(cache_key, tags)` to update the index.\n\n**Algorithm: Purging by Tag**\n1.  Admin request (`PURGE /purge/tag/{tag}`).\n2.  Call `SurrogateKeyIndex.purge_by_tag(tag)`. This returns the set of cache keys associated with the tag and clears the index for that tag.\n3.  For each cache key in the returned set:\n    a. Perform a hard or soft purge (based on request headers) of that individual cache key.\n4.  Return a summary: `200 OK` with `{\"purged_keys_count\": 123}`.\n\n**API Specification**\n| Method | Path | Headers | Body | Returns | Description |\n|--------|------|---------|------|---------|-------------|\n| `PURGE` | `/purge/tag/{tag}` | `Authorization: Bearer <token>`, `Soft-Purge: 1` (optional) | Empty | `200 OK` with count of purged keys | Purges all cache entries tagged with the given surrogate key. |\n\n### Invalidation Propagation Strategy\n\nAn invalidation command issued to one edge node must eventually take effect across **all** edge nodes in the CDN. ![Sequence: Purge Propagation via Control Plane](./diagrams/seq-invalidation-propagation.svg) illustrates the ideal flow. The strategy defines how this propagation is achieved, balancing consistency, latency, and system complexity.\n\n**Core Requirements:**\n*   **Eventual Consistency:** All nodes should reflect the invalidation within a bounded time window (e.g., < 60 seconds).\n*   **Reliability:** Invalidation messages must not be lost even if individual nodes or the network temporarily fail.\n*   **Scalability:** The propagation mechanism should not create a bottleneck as the number of edge nodes grows (e.g., from 10 to 10,000).\n*   **Ordering (Sometimes):** For certain operations, order matters (e.g., \"update item A, then purge its cache\"). The system should preserve this order where required.\n\n**Propagation Steps:**\n1.  **Ingestion:** An admin issues a purge command to a designated **control plane** API (or directly to any edge node, which forwards it).\n2.  **Fan-out:** The control plane broadcasts the invalidation message to all registered edge nodes. This can be done via:\n    *   **Direct HTTP calls** to each node's administrative endpoint (simple but doesn't scale, no persistence).\n    *   A **publish-subscribe (pub/sub) message queue** (e.g., Redis Pub/Sub, Kafka, NATS). Edge nodes subscribe to an invalidation channel.\n    *   A **gossip protocol** where nodes propagate the message to their peers (decentralized, resilient, but complex).\n3.  **Acknowledgment & Retry:** Edge nodes acknowledge receipt. The control plane retries unacknowledged messages with exponential backoff.\n4.  **Local Execution:** Each edge node receives the message, validates it, and executes the local purge/ban logic described earlier.\n5.  **Monitoring:** The control plane logs completion and can provide a dashboard showing propagation status.\n\n### ADR: Invalidation Propagation Mechanism\n\n> **Decision: Use a Centralized Pub/Sub System for Invalidation Propagation**\n>\n> - **Context**: The CDN needs to propagate cache invalidation commands (purge, ban, tag) from an administrative source to all edge nodes. The system has a moderate number of edge nodes (10s to 100s initially), and the control plane is already a central component for configuration and analytics. We need a reliable, scalable, and simple-to-implement propagation mechanism.\n> - **Options Considered**:\n>     1.  **Direct HTTP Broadcast from Control Plane**: The control plane maintains a list of edge node admin endpoints and `POST`s the invalidation command to each sequentially or in parallel.\n>     2.  **Pub/Sub Message Queue (Centralized)**: Edge nodes subscribe to a channel (e.g., `invalidation`) on a centralized message broker (like Redis). The control plane publishes messages to this channel.\n>     3.  **Gossip Protocol (Decentralized)**: Edge nodes form a peer-to-peer mesh and propagate invalidation messages via a gossip protocol (like SWIM or epidemic broadcasting).\n> - **Decision**: We will implement Option 2: A centralized Pub/Sub system using a simple broker. Initially, we can use an in-memory broker within the control plane for simplicity, with the ability to replace it with Redis or NATS for production scaling.\n> - **Rationale**:\n>     *   **Scalability**: Pub/Sub decouples the control plane from edge nodes. The control plane publishes once, and the broker handles fan-out. This scales better than the control plane managing direct connections to hundreds of nodes (Option 1).\n>     *   **Reliability**: Most message brokers offer persistence and retry mechanisms. If an edge node is temporarily offline, it can reconnect and receive missed messages (depending on broker configuration). Direct HTTP (Option 1) requires the control plane to implement complex retry and state tracking.\n>     *   **Simplicity**: Implementing a robust gossip protocol (Option 3) is complex and introduces its own consistency and convergence timing issues. For an educational project, Pub/Sub is a more understandable and industry-standard pattern.\n>     *   **Natural Fit**: The control plane is already a central coordination point. Adding a Pub/Sub broker aligns with its role.\n> - **Consequences**:\n>     *   The control plane and edge nodes now depend on the availability of the message broker. This introduces a new single point of failure. Mitigation: Use a clustered broker or accept that invalidation is a best-effort, non-critical path (serving stale content is often acceptable briefly).\n>     *   Edge nodes must maintain a persistent connection or polling mechanism to the broker, adding some network overhead.\n>     *   Message ordering is guaranteed per-channel in most brokers, which simplifies handling of related purge sequences.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Direct HTTP Broadcast** | Simple, no new components, strong consistency if all calls succeed. | Control plane becomes a bottleneck, hard to scale, must manage connection/retry logic, no persistence if edge node is down. | No |\n| **Centralized Pub/Sub** | Decouples components, scalable, brokers often provide persistence and retry, industry standard. | Introduces a new component (broker) as a potential SPOF, requires managing broker connections. | **Yes** |\n| **Gossip Protocol** | Highly resilient, no central broker, scales well. | Complex to implement correctly, convergence time can be unpredictable, debugging is harder. | No |\n\n### Common Pitfalls in Invalidation\n\n⚠️ **Pitfall: Unbounded Growth of the Ban List**\n*   **Description**: Continuously adding ban rules without ever removing them. Over weeks, the list grows to thousands of rules. Every incoming request must be checked against all rules, causing linear performance degradation (`O(n)` per request).\n*   **Why it's wrong**: It turns a performance optimization (caching) into a performance bottleneck. Eventually, request latency becomes dominated by ban rule matching.\n*   **How to fix**: Attach a **TTL to every ban rule**. Implement a background garbage collection task that periodically removes expired rules. For long-term bans, consider converting them to a more permanent configuration (like a cache rule that sets a very short TTL for a path pattern).\n\n⚠️ **Pitfall: Race Condition During Revalidation**\n*   **Description**: A soft purge triggers background revalidation. Simultaneously, a client request for the same resource arrives. Both the background task and the client request might independently fetch from the origin, causing a duplicate request (wasting origin capacity) or a race in updating the cache entry.\n*   **Why it's wrong**: It undermines the request collapsing benefits of the origin shield and can lead to inconsistent cache state if the two fetches return slightly different data (e.g., due to timing).\n*   **How to fix**: Implement a **revalidation lock per cache key**. Use a dictionary mapping cache keys to `asyncio.Lock` (or similar) or a promise/future. The first entity (background job or client request) that finds a stale entry acquires the lock and performs the origin fetch. Others wait on the same lock and reuse its result.\n\n⚠️ **Pitfall: Ignoring Propagation Delay**\n*   **Description**: After issuing a global purge, the developer assumes all edge nodes are instantly updated and tests from a single location, seeing fresh content. However, users in other regions may still see stale content for seconds or minutes due to propagation lag.\n*   **Why it's wrong**: It creates a false sense of consistency and can lead to user complaints (\"I cleared the cache but my friend still sees the old version\").\n*   **How to fix**: **Design for eventual consistency**. Document the expected propagation SLA (e.g., < 30s). Provide an API or admin UI to track the propagation status of an invalidation event. For scenarios requiring stronger guarantees, consider using cache versioning in URLs (e.g., `/image.jpg?v=2`) instead of purging.\n\n⚠️ **Pitfall: Surrogate Key Collision and Over-Invalidation**\n*   **Description**: Using overly broad surrogate keys (e.g., tagging all blog posts with `\"blog\"`). Purging `\"blog\"` invalidates the entire blog cache, causing a massive origin load spike (a \"cache miss storm\") when those pages are next requested.\n*   **Why it's wrong**: Loses the granularity benefit of caching. It's equivalent to banning `/blog/*` but with less visibility.\n*   **How to fix**: **Use granular surrogate keys**. Combine broad and specific tags. For example, a product page could be tagged with `\"product-12345\"`, `\"category-shoes\"`, and `\"page-type-detail\"`. This allows invalidating a single product, all shoes, or all detail pages independently. Educate content authors on key design.\n\n### Implementation Guidance for Invalidation\n\n**A. Technology Recommendations Table**\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Invalidation API | HTTP `PURGE` method with bearer token authentication | gRPC admin service with richer semantics (e.g., dry-run, scheduled purge) |\n| Propagation Broker | In-memory Pub/Sub within the Control Plane process (using `asyncio.Queue` or `concurrent.futures`) | External Redis Pub/Sub or Apache Kafka for persistence and scale |\n| Pattern Matching for Bans | Python's `fnmatch` for glob patterns (`/images/*.jpg`) | Regular expressions (`re` module) for maximum flexibility (with careful compilation caching) |\n\n**B. Recommended File/Module Structure**\n```\nblue_origin/\n├── cdn/\n│   ├── __init__.py\n│   ├── edge/\n│   │   ├── __init__.py\n│   │   ├── server.py              # Edge HTTP server, includes request handler\n│   │   ├── cache.py               # CacheStorage, CacheEntry, SurrogateKeyIndex\n│   │   ├── handler.py             # EdgeRequestHandler (includes ban checking)\n│   │   └── invalidation.py        # Purge/Ban API handlers, local invalidation logic\n│   ├── shield/\n│   │   └── ...                    # Origin shield components\n│   ├── control/\n│   │   ├── __init__.py\n│   │   ├── plane.py               # Control plane HTTP server, pub/sub broker\n│   │   └── propagation.py         # Message formats, publisher/subscriber clients\n│   └── common/\n│       ├── __init__.py\n│       ├── http_utils.py          # parse_http_date, format_http_date, etc.\n│       ├── models.py              # Shared data models (EdgeConfig, etc.)\n│       └── auth.py                # Simple token validation utilities\n├── scripts/\n│   └── purge_cli.py               # Command-line tool for issuing purge commands\n└── tests/\n    └── test_invalidation.py       # Unit and integration tests for invalidation\n```\n\n**C. Infrastructure Starter Code**\n\n**Simple In-Memory Pub/Sub Broker (`control/propagation.py`):**\n```python\nimport asyncio\nimport logging\nfrom typing import Dict, Set, Any, Callable\nfrom dataclasses import dataclass\nimport json\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass InvalidationMessage:\n    \"\"\"Message format for cache invalidation commands.\"\"\"\n    message_id: str\n    command: str  # \"PURGE\", \"BAN\", \"PURGE_TAG\"\n    target: str   # URL, pattern, or tag\n    soft: bool = False\n    timestamp: float = 0.0\n    # Additional parameters can be added as a dict\n    parameters: Dict[str, Any] = None\n\n    def to_json(self) -> str:\n        return json.dumps({\n            \"message_id\": self.message_id,\n            \"command\": self.command,\n            \"target\": self.target,\n            \"soft\": self.soft,\n            \"timestamp\": self.timestamp,\n            \"parameters\": self.parameters or {}\n        })\n\n    @classmethod\n    def from_json(cls, data: str) -> \"InvalidationMessage\":\n        d = json.loads(data)\n        return cls(\n            message_id=d[\"message_id\"],\n            command=d[\"command\"],\n            target=d[\"target\"],\n            soft=d.get(\"soft\", False),\n            timestamp=d.get(\"timestamp\", 0.0),\n            parameters=d.get(\"parameters\", {})\n        )\n\nclass InMemoryPubSubBroker:\n    \"\"\"A simple in-memory publish-subscribe broker for invalidation messages.\"\"\"\n    def __init__(self):\n        self._subscribers: Dict[str, Set[Callable[[InvalidationMessage], None]]] = {}\n        self._lock = asyncio.Lock()\n\n    async def subscribe(self, channel: str, callback: Callable[[InvalidationMessage], None]):\n        \"\"\"Subscribe a callback function to a channel.\"\"\"\n        async with self._lock:\n            if channel not in self._subscribers:\n                self._subscribers[channel] = set()\n            self._subscribers[channel].add(callback)\n            logger.debug(f\"New subscriber to channel '{channel}'. Total: {len(self._subscribers[channel])}\")\n\n    async def unsubscribe(self, channel: str, callback: Callable[[InvalidationMessage], None]):\n        \"\"\"Unsubscribe a callback from a channel.\"\"\"\n        async with self._lock:\n            if channel in self._subscribers:\n                self._subscribers[channel].discard(callback)\n                if not self._subscribers[channel]:\n                    del self._subscribers[channel]\n\n    async def publish(self, channel: str, message: InvalidationMessage):\n        \"\"\"Publish a message to all subscribers of a channel.\"\"\"\n        logger.info(f\"Publishing message {message.message_id} to channel '{channel}'\")\n        async with self._lock:\n            subscribers = self._subscribers.get(channel, set()).copy()\n        # Call subscribers without holding the lock to avoid deadlocks\n        for callback in subscribers:\n            try:\n                # Fire and forget; consider error handling in production\n                asyncio.create_task(self._safe_callback(callback, message))\n            except Exception as e:\n                logger.error(f\"Error scheduling callback for message {message.message_id}: {e}\")\n\n    async def _safe_callback(self, callback: Callable[[InvalidationMessage], None], message: InvalidationMessage):\n        \"\"\"Wrapper to log errors in subscriber callbacks.\"\"\"\n        try:\n            await callback(message)\n        except Exception as e:\n            logger.error(f\"Subscriber callback failed for message {message.message_id}: {e}\")\n\n# Global broker instance (simple singleton)\nbroker = InMemoryPubSubBroker()\n```\n\n**D. Core Logic Skeleton Code**\n\n**Purge API Handler (`edge/invalidation.py`):**\n```python\nimport fnmatch\nimport re\nimport time\nfrom typing import Set, Optional\nfrom .cache import CacheStorage, SurrogateKeyIndex\nfrom ..common.auth import validate_token\n\nclass InvalidationHandler:\n    \"\"\"Handles administrative invalidation commands (purge, ban, tag).\"\"\"\n\n    def __init__(self, cache: CacheStorage, key_index: SurrogateKeyIndex, control_plane_publisher=None):\n        self.cache = cache\n        self.key_index = key_index\n        self.ban_rules: List[BanRule] = []  # In-memory list, could be persisted\n        self.control_plane_publisher = control_plane_publisher  # Optional publisher for propagation\n\n    async def handle_purge_request(self, request_method: str, request_path: str,\n                                   request_headers: Dict[str, str]) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Handles HTTP PURGE requests.\n        Expected path: /{path...} for URL purge, /purge/tag/{tag} for tag purge.\n        Headers: Authorization, Soft-Purge.\n        \"\"\"\n        # TODO 1: Validate the Authorization header using validate_token.\n        #   If invalid, return 401 Unauthorized.\n\n        # TODO 2: Determine if this is a tag purge or URL purge.\n        #   Check if request_path starts with '/purge/tag/'.\n        #   If yes, extract the tag and proceed to tag purge logic (step 6).\n\n        # TODO 3: For URL purge: Extract the target URL from request_path.\n        #   Generate the cache key. This requires knowing the Vary headers.\n        #   Hint: You may need to look up the existing CacheEntry to get its vary_headers.\n\n        # TODO 4: Check for the 'Soft-Purge' header (e.g., '1' or 'true').\n        #   Set a boolean flag `is_soft`.\n\n        # TODO 5: Perform the local purge.\n        #   If is_soft: call self._soft_purge_key(cache_key).\n        #   Else: call self._hard_purge_key(cache_key).\n        #   Return 200 OK with appropriate body (e.g., \"Purged\" or \"Soft purged\").\n\n        # TODO 6: For tag purge: Extract tag from path.\n        #   Call self._purge_by_tag(tag, is_soft).\n        #   Return 200 OK with count of purged keys.\n\n        # TODO 7 (Optional - Propagation): If self.control_plane_publisher is set,\n        #   construct an InvalidationMessage and publish it to the 'invalidation' channel.\n        #   This allows other edge nodes to learn about this purge.\n\n        pass\n\n    def _hard_purge_key(self, cache_key: str):\n        \"\"\"Immediately delete a cache entry by key.\"\"\"\n        # TODO 1: Delete the entry from self.cache.\n        # TODO 2: Remove the entry from self.key_index using key_index.remove_entry(cache_key).\n\n    def _soft_purge_key(self, cache_key: str):\n        \"\"\"Mark a cache entry as stale and trigger background revalidation.\"\"\"\n        # TODO 1: Retrieve the CacheEntry from self.cache.\n        # TODO 2: If entry exists, set its expires_at to a past timestamp (e.g., time.time() - 1).\n        # TODO 3: Optionally, set a flag in the entry metadata (e.g., entry.is_soft_purged = True).\n        # TODO 4: Trigger background revalidation: asyncio.create_task(_revalidate_in_background(...)).\n        #   You'll need to pass appropriate request headers (maybe default ones).\n\n    async def _purge_by_tag(self, tag: str, is_soft: bool):\n        \"\"\"Purge all cache entries associated with a surrogate key tag.\"\"\"\n        # TODO 1: Call self.key_index.purge_by_tag(tag) to get the set of cache keys.\n        # TODO 2: For each cache key in the set:\n        #   if is_soft: self._soft_purge_key(key)\n        #   else: self._hard_purge_key(key)\n        # TODO 3: Return the count of purged keys.\n\n    async def add_ban_rule(self, pattern: str, is_soft: bool, ttl_seconds: float) -> str:\n        \"\"\"Add a new ban rule and return its ID.\"\"\"\n        # TODO 1: Generate a unique ID for the rule (e.g., using uuid or timestamp).\n        # TODO 2: Create a BanRule object with pattern, is_soft, ttl_seconds, and current time.\n        # TODO 3: Append the rule to self.ban_rules.\n        # TODO 4: Schedule a garbage collection task if not already running.\n        # TODO 5: Return the rule ID.\n\n    def check_bans(self, url: str) -> Optional[BanRule]:\n        \"\"\"Check if a URL matches any active ban rule. Returns the first matching rule.\"\"\"\n        current_time = time.time()\n        for rule in self.ban_rules:\n            # TODO 1: Skip rule if it's expired (current_time > rule.created_at + rule.ttl_seconds).\n            # TODO 2: If rule.matches(url): return rule.\n            #   For glob matching: fnmatch.fnmatch(url, rule.pattern)\n            #   For regex: use a pre-compiled regex stored in the rule.\n        return None\n\n    async def _gc_ban_rules(self):\n        \"\"\"Background task to garbage collect expired ban rules.\"\"\"\n        while True:\n            await asyncio.sleep(3600)  # Run every hour\n            current_time = time.time()\n            # TODO: Filter self.ban_rules, keeping only rules where current_time <= created_at + ttl_seconds.\n```\n\n**Integration into EdgeRequestHandler (`edge/handler.py`):**\n```python\nclass EdgeRequestHandler:\n    def __init__(self, cache: CacheStorage, upstream: str, invalidation_handler: InvalidationHandler):\n        self.cache = cache\n        self.upstream = upstream\n        self.invalidation = invalidation_handler\n\n    async def handle_request(self, request_headers: Dict[str, str], request_body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        # ... existing code to parse request ...\n\n        # TODO: Insert ban checking early in the flow (after generating the URL but before cache lookup).\n        #   ban_rule = self.invalidation.check_bans(url)\n        #   if ban_rule:\n        #       if not ban_rule.is_soft:\n        #           # Hard ban: delete cache entry if exists, then proceed as cache miss.\n        #           self.invalidation._hard_purge_key(cache_key)  # cache_key may need URL only variant\n        #       else:\n        #           # Soft ban: mark existing entry stale.\n        #           self.invalidation._soft_purge_key(cache_key)\n        #       # Continue; the cache lookup will now miss or find a stale entry.\n\n        # ... rest of the caching logic ...\n```\n\n**E. Language-Specific Hints**\n*   Use Python's `asyncio.Lock` or `asyncio.Queue` for coordinating background revalidation and preventing thundering herds.\n*   For pattern matching in bans, `fnmatch` is simpler and safer than regex for globs. If using regex, pre-compile them with `re.compile(pattern)` and store the compiled object in the `BanRule` to avoid compilation on every request.\n*   Use `asyncio.create_task` for fire-and-forget background operations like revalidation or garbage collection. Consider using a bounded semaphore (`asyncio.Semaphore`) to limit concurrent revalidation tasks.\n*   For the simple in-memory Pub/Sub, `asyncio.Queue` can also be used per channel, but the callback-based approach shown is more flexible.\n\n**F. Milestone Checkpoint**\nTo verify your cache invalidation implementation:\n\n1.  **Start the edge server** with an upstream origin (e.g., a simple static file server).\n2.  **Prime the cache:** Use `curl http://edge:8080/image.jpg` to fetch and cache an image.\n3.  **Test Hard Purge:**\n    ```\n    curl -X PURGE -H \"Authorization: Bearer admin-token\" http://edge:8080/image.jpg\n    ```\n    Expected: `200 OK` response. Immediately request the image again. You should see a cache miss (check server logs) and the origin should receive a request.\n4.  **Test Soft Purge:**\n    ```\n    curl -X PURGE -H \"Authorization: Bearer admin-token\" -H \"Soft-Purge: 1\" http://edge:8080/image.jpg\n    ```\n    Expected: `200 OK`. Immediately request the image. You should be served the *stale* (cached) version, but a background revalidation request should be logged. After a short delay, the cache should be updated.\n5.  **Test Tag-Based Purge:** First, ensure your origin returns a `Surrogate-Key: test` header. Fetch a few URLs with that tag. Then:\n    ```\n    curl -X PURGE -H \"Authorization: Bearer admin-token\" http://edge:8080/purge/tag/test\n    ```\n    Expected: `200 OK` with a JSON body like `{\"purged_keys_count\": 3}`. All tagged entries should be purged.\n6.  **Test Ban Rule:** Add a ban rule via API, then request a matching URL. The entry should be invalidated (either hard or soft). Check that expired ban rules are removed by the GC task after their TTL.\n\n**Signs of Trouble:**\n*   **Purge does nothing:** Check cache key generation. Ensure the purge handler is using the same key logic as the cache store. Verify authentication.\n*   **Background revalidation causes duplicate origin requests:** Implement the revalidation lock per key as described in the pitfalls.\n*   **Ban rules slow down requests:** You are likely checking all rules linearly. Ensure you are using efficient matching (pre-compiled regex) and implement TTL-based garbage collection.\n\n\n## Component: Origin Shield & Request Collapsing (Milestone 3)\n\n> **Milestone(s):** Milestone 3 (Origin Shield & Request Collapsing)\n\n### Mental Model: The Concert Vestibule\n\nPicture a massive concert hall where the main auditorium (the **Origin Server**) can only accommodate a limited number of people at once. Thousands of fans (client requests) arrive at the venue at the same time, all heading to the same section of seats (requesting the same resource). If everyone rushed the main doors simultaneously, they would create a dangerous stampede, overwhelming the entrance and causing a collapse (the **thundering herd problem**).\n\nNow, imagine a well-designed **vestibule** or lobby area just before the main hall doors. This is the **Origin Shield**. As fans arrive, the vestibule staff (the shield logic) quickly groups together everyone who has a ticket for the same seat (identical requests). Instead of letting 100 individuals each try to enter the main hall independently for the same seat, the staff selects one representative from the group (the **collapsed request**) to go and claim the seat. The other 99 wait patiently in the vestibule (their requests are **queued**). When the representative returns with confirmation and details about the seat (the HTTP response), the staff efficiently relays that information to the entire waiting group. This prevents a stampede, protects the main hall's capacity, and serves all fans efficiently.\n\nThis mental model captures the core purpose of the shield: it's a **deduplication and queueing layer** that sits between the noisy, high-volume edge nodes and the precious, capacity-constrained origin. It transforms a potential storm of concurrent, identical `GET` requests into a single, orderly fetch, dramatically reducing load on the origin.\n\n### Shield Logic & Request Collapsing\n\nThe Origin Shield is an HTTP proxy with its own cache (often called a **mid-tier** or **shield** cache). Its primary intelligence lies in handling cache misses. The following algorithm describes its behavior when an edge node forwards a request (a cache miss) to the shield.\n\n1.  **Request Arrival & Cache Check:** The shield receives an HTTP request from an edge node. It first checks its own local cache using the same `CacheEntry` data model and `CacheKey` generation logic as the edge (including `Vary` header dimensions). If a **fresh** entry exists, it is returned immediately—this is a **shield hit**.\n2.  **Cache Miss & Coalescing Map Lookup:** On a cache miss, the shield checks an internal, in-memory data structure we'll call the **Request Coalescing Map**. This map tracks which requests are currently \"in flight\" to the origin. The key is the normalized cache key for the request (URL + `Vary` header values). The value is a list of callback functions or futures representing all the client connections (edge nodes) waiting for the result of that specific request.\n3.  **Decision: New Origin Fetch or Join Existing Queue:**\n    *   If the cache key is **not** in the coalescing map, this is the first request for this resource since the last cached version expired. The shield creates a new entry in the map, initiates a single HTTP request to the origin server, and records the pending client connection. The request proceeds to step 4.\n    *   If the cache key **is** already in the coalescing map, it means an identical request is already being fetched from the origin. The shield simply adds the new client's callback to the list associated with that key. This request is now **collapsed**—it will wait for the shared result. The algorithm jumps to step 6.\n4.  **Origin Fetch with Protection:** The shield sends the request to the origin. Crucially, it implements protective measures:\n    *   **Connection Limits:** A semaphore or rate limiter ensures the total number of concurrent connections to the origin stays below a safe threshold.\n    *   **Timeouts & Circuit Breakers:** Individual requests have strict timeouts. If the origin becomes slow or fails, circuit breakers can trip to fail fast and prevent cascading failure.\n5.  **Response Processing & Cache Population:** Upon receiving the origin's response, the shield:\n    *   Determines if the response is cacheable using `is_response_cacheable`.\n    *   If cacheable, it creates a new `CacheEntry` (using `CacheEntry.from_upstream_response`), stores it in its cache, and records its TTL.\n    *   **Negative Caching:** If the response is an error (e.g., `404 Not Found` or `503 Service Unavailable`), the shield may still create a cache entry with a very short TTL (e.g., 5-10 seconds). This prevents a storm of requests for a non-existent or temporarily failing resource from hammering the origin.\n6.  **Fan-Out to Waiting Requests:** The shield retrieves the list of all waiting callbacks from the coalescing map for the given cache key. It then sends the HTTP response (either the freshly fetched one, a cached one, or a negatively cached error) to **every** waiting client connection.\n7.  **Cleanup:** Finally, the shield removes the entry for this cache key from the Request Coalescing Map. Any new requests for the same resource will now either be served from the shield's cache (if fresh) or trigger a new origin fetch cycle.\n\nThe state of a request at the shield can be summarized in the following table:\n\n| State | Description | Trigger for Transition |\n| :--- | :--- | :--- |\n| **MISS (No Coalescing)** | First request for an uncached resource. | Request arrives, cache key not in coalescing map. |\n| **IN_FLIGHT (Coalescing Active)** | An origin fetch for this key is ongoing. Other identical requests are queued. | Subsequent identical requests arrive before the origin fetch completes. |\n| **CACHED (FRESH/STALE)** | Response is stored in the shield's local cache. | Origin fetch completes and response is stored. |\n| **NEGATIVE_CACHED** | An error response is stored with a short TTL. | Origin returns an error code deemed safe for negative caching. |\n\nThe core data structure enabling this, the `RequestCoalescingMap`, has the following interface:\n\n| Method Name | Parameters | Returns | Description |\n| :--- | :--- | :--- | :--- |\n| `get_or_create_future` | `cache_key: str` | `Future` | If `cache_key` exists, returns its associated Future. If not, creates a new Future, stores it with the key, and returns it. The caller who creates the Future is responsible for fulfilling it. |\n| `fulfill_future` | `cache_key: str`, `result: Tuple[int, Dict, bytes]` | `None` | Sets the result for the Future associated with `cache_key` and notifies all waiters. Removes the key from the map. |\n| `fail_future` | `cache_key: str`, `exception: Exception` | `None` | Sets an exception for the Future, notifies waiters, and removes the key. |\n\n> **Key Insight:** The shield's value isn't just in its cache hit ratio—it's in its **miss efficiency**. A single origin request satisfying hundreds of simultaneous edge requests is a massive win for origin load and stability.\n\n### ADR: To Shield or Not To Shield\n\n> **Decision: Deploy an Origin Shield as a Standard Tier for Multi-Edge CDNs**\n\n*   **Context:** Our CDN architecture involves multiple geographically distributed edge nodes. Without a shield, a sudden surge in traffic for an uncached resource (a \"hot\" article, a product launch) would cause all edge nodes to independently fetch the same content from the origin simultaneously. This \"cache miss storm\" can overload the origin, increase its latency, and risk its availability. We must decide whether to introduce an intermediate caching layer (the shield) to absorb and deduplicate these requests.\n*   **Options Considered:**\n    1.  **No Shield (Edge-to-Origin Direct):** All edge nodes connect directly to the origin.\n    2.  **Single Global Origin Shield:** Deploy one shield instance (or a cluster behind a load balancer) that all edge nodes use as their upstream.\n    3.  **Regional Shields:** Deploy multiple shield instances, each serving edge nodes in a specific geographic region (e.g., North America Shield, EU Shield).\n*   **Decision:** We will implement a **Single Global Origin Shield** as the primary architecture for this educational project. It provides the core learning benefits of request collapsing and origin protection with manageable complexity.\n*   **Rationale:**\n    *   **Simplicity vs. Benefit:** A single shield provides the vast majority of the origin protection benefit (request collapsing) with a much simpler operational and implementation model compared to a regionalized shield tier. It's the most effective \"next step\" after basic edge caching.\n    *   **Clear Learning Path:** Implementing request coalescing, negative caching, and connection queuing against a single upstream is a coherent, challenging milestone. Adding regionalization introduces networking and cache consistency complexities that are better suited for a later extension.\n    *   **Effective for Many Scenarios:** For origins that are not themselves globally distributed, a single, well-provisioned shield located in the same data center or region as the origin can eliminate nearly all duplicate traffic, as network latency from the shield to the origin is minimal.\n*   **Consequences:**\n    *   **Added Latency:** Edge nodes far from the shield's location will experience higher latency on cache misses compared to connecting directly to a nearby origin. This is the primary trade-off.\n    *   **Single Point of Failure:** The shield becomes a critical component. Its failure would cause all cache misses to fail. This necessitates making the shield itself highly available (e.g., via a cluster with a load balancer) and implementing robust health checks and failover logic at the edge (e.g., failover to origin if the shield is unhealthy).\n    *   **Cache Warming:** The shield's cache acts as a global warming layer. Once one edge node populates the shield cache, all other edges benefit, reducing overall origin load more effectively than isolated edge caches.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **No Shield** | Lowest latency for cache misses (direct path). Simplest architecture. | Extremely vulnerable to thundering herd problem. High, unbounded load on origin. | No |\n| **Single Global Shield** | Excellent request collapsing. Dramatically reduces origin load. Clear, focused implementation milestone. | Introduces a hop of latency for distant edges. Creates a new critical component to manage. | **Yes** |\n| **Regional Shields** | Good request collapsing within regions. Lower latency for cache misses than a single global shield. | Significantly higher complexity (multiple shield caches, potential for inconsistency). Higher operational cost. | No (Consider as a Future Extension) |\n\n### Common Pitfalls in Shielding\n\n⚠️ **Pitfall 1: Cache Poisoning Between Edge Variants**\n*   **Description:** Edge nodes in different regions might request the same URL but with different `Accept-Encoding` headers (e.g., `gzip` vs. `br`). If the shield's cache key doesn't include all `Vary` header dimensions (just like the edge), it might store and serve a `gzip` response to an edge that requested `brotli`, causing corruption.\n*   **Why it's Wrong:** The HTTP response body is incompatible with the client's expectation. The edge node might serve incorrect, unreadable content to the user.\n*   **Fix:** The shield **must** use the exact same cache key generation logic as the edge, meticulously incorporating all headers listed in the origin's `Vary` response header. Reuse the `CacheKey` generation module from Milestone 1.\n\n⚠️ **Pitfall 2: Timeout Mismatch Chain Reaction**\n*   **Description:** The edge node has a 30-second client timeout. The shield sets a 10-second timeout to the origin. If the origin is slow and takes 15 seconds to respond, the shield's request fails (timeout). However, 100 edge requests were collapsed behind that single shield request. The shield fails all 100 waiting connections simultaneously. All 100 edge nodes, now seeing a failed upstream (shield), may simultaneously decide to retry directly to the origin or to another shield, creating a new, smaller herd problem.\n*   **Why it's Wrong:** It negates the benefit of request collapsing and can amplify failures.\n*   **Fix:** Implement a **graceful degradation** strategy. Use `stale-if-error` directives. If the shield's fetch times out or fails, it should check if it has a **stale** cached version of the resource. If so, it can serve that stale content immediately while logging the error, rather than failing all clients. Additionally, ensure shield-to-origin timeouts are configured to be meaningfully shorter than edge-to-client timeouts.\n\n⚠️ **Pitfall 3: Ignoring Shield Health in Edge Routing**\n*   **Description:** The edge node is configured to always forward misses to the shield's hostname. If the shield instance crashes or becomes partitioned, the edge will still send it requests, which will fail or timeout, degrading performance for all users.\n*   **Why it's Wrong:** It eliminates the fault-tolerance benefits of a multi-tier architecture. A failure in the shield tier should not cause a full outage.\n*   **Fix:** Implement active **health checking** at the edge. Periodically (e.g., every 5 seconds) make a lightweight request (e.g., `GET /health`) to the shield. If consecutive health checks fail, mark the shield as unhealthy and temporarily **bypass** it, sending cache misses directly to the origin for a defined period. Re-introduce the shield after it passes health checks again.\n\n⚠️ **Pitfall 4: Unbounded Growth of the Coalescing Map**\n*   **Description:** The in-memory map that tracks in-flight requests (`RequestCoalescingMap`) is never cleaned up. If an origin fetch hangs forever (due to an origin bug or network issue), the entry remains, and all subsequent requests for that resource pile up in memory indefinitely, causing a memory leak.\n*   **Why it's Wrong:** Leads to eventual out-of-memory crashes of the shield process.\n*   **Fix:** Associate every entry in the coalescing map with a **timeout**. If the origin fetch does not complete within this timeout, the future is failed (e.g., with a `TimeoutError`), and the entry is removed from the map. Also, implement a periodic garbage collection task that scans for and removes stale entries.\n\n### Implementation Guidance for Origin Shield\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (for Learning) | Advanced Option (for Production) |\n| :--- | :--- | :--- |\n| HTTP Server/Proxy | Python's `asyncio` with `aiohttp` (easy concurrency for request collapsing) | Go's `net/http` or Rust's `hyper` (performance, robustness) |\n| Request Coalescing | In-memory `dict` with `asyncio.Future`/`asyncio.Event` | Distributed coordination (Redis, memcached) for multi-process shields |\n| Connection Pool/Limiting | `aiohttp.TCPConnector` with limit | Adaptive concurrency limiting (AIMD, gradient) |\n| Health Checking | Simple periodic HTTP `GET` | Rich health checks with metrics integration (Prometheus) |\n\n**B. Recommended File/Module Structure**\n\n```\nblue_origin_cdn/\n├── pyproject.toml\n├── src/\n│   └── blue_origin/\n│       ├── __init__.py\n│       ├── edge/                    # Milestone 1 & 5\n│       │   ├── __init__.py\n│       │   ├── handler.py           # EdgeRequestHandler\n│       │   ├── cache.py             # CacheStorage, CacheEntry\n│       │   └── compression.py       # gzip/brotli middleware\n│       ├── shield/                  # Milestone 3\n│       │   ├── __init__.py\n│       │   ├── handler.py           # ShieldRequestHandler\n│       │   ├── coalescing.py        # RequestCoalescingMap\n│       │   ├── client.py            # ShieldHTTPClient (with queue/limit)\n│       │   └── health.py            # Health check endpoint & logic\n│       ├── invalidation/            # Milestone 2\n│       │   └── ...\n│       ├── routing/                 # Milestone 4\n│       │   └── ...\n│       ├── analytics/               # Milestone 5\n│       │   └── ...\n│       └── utils/\n│           └── http.py              # parse_http_date, is_response_cacheable, etc.\n├── configs/\n│   └── shield_config.yaml\n└── scripts/\n    └── run_shield.py\n```\n\n**C. Infrastructure Starter Code**\n\nThe following is a complete, working implementation of the core `RequestCoalescingMap` using `asyncio`. This is a prerequisite component that learners can use directly.\n\n```python\n# src/blue_origin/shield/coalescing.py\nimport asyncio\nfrom typing import Dict, Tuple, Optional, Any\nimport time\n\nclass RequestCoalescingMap:\n    \"\"\"\n    A map that collapses concurrent requests for the same cache key.\n    Each key maps to a Future that will hold the result (status, headers, body).\n    \"\"\"\n    def __init__(self, default_timeout: float = 30.0):\n        self._futures: Dict[str, asyncio.Future] = {}\n        self._timeouts: Dict[str, float] = {}  # key -> expiration time\n        self._default_timeout = default_timeout\n        self._lock = asyncio.Lock()\n        self._gc_task: Optional[asyncio.Task] = None\n\n    async def get_or_create_future(self, cache_key: str) -> asyncio.Future:\n        \"\"\"\n        Get the existing Future for `cache_key`, or create a new one.\n        The caller that creates the Future MUST fulfill or fail it.\n        \"\"\"\n        async with self._lock:\n            if cache_key in self._futures:\n                return self._futures[cache_key]\n            # Create a new future\n            fut = asyncio.Future()\n            self._futures[cache_key] = fut\n            self._timeouts[cache_key] = time.time() + self._default_timeout\n            # Start GC task if not running\n            if self._gc_task is None or self._gc_task.done():\n                self._gc_task = asyncio.create_task(self._gc_loop())\n            return fut\n\n    async def fulfill_future(self,\n                            cache_key: str,\n                            result: Tuple[int, Dict[str, str], bytes]) -> None:\n        \"\"\"Set the result for the Future associated with `cache_key`.\"\"\"\n        async with self._lock:\n            fut = self._futures.pop(cache_key, None)\n            self._timeouts.pop(cache_key, None)\n        if fut and not fut.done():\n            fut.set_result(result)\n\n    async def fail_future(self, cache_key: str, exception: Exception) -> None:\n        \"\"\"Set an exception for the Future associated with `cache_key`.\"\"\"\n        async with self._lock:\n            fut = self._futures.pop(cache_key, None)\n            self._timeouts.pop(cache_key, None)\n        if fut and not fut.done():\n            fut.set_exception(exception)\n\n    async def _gc_loop(self, interval: float = 5.0) -> None:\n        \"\"\"Background task to clean up timed-out futures.\"\"\"\n        while True:\n            await asyncio.sleep(interval)\n            now = time.time()\n            to_remove = []\n            async with self._lock:\n                for key, exp_time in self._timeouts.items():\n                    if now > exp_time:\n                        to_remove.append(key)\n                for key in to_remove:\n                    fut = self._futures.pop(key, None)\n                    self._timeouts.pop(key, None)\n                    if fut and not fut.done():\n                        fut.set_exception(asyncio.TimeoutError(f\"Request for {key} timed out\"))\n```\n\n**D. Core Logic Skeleton Code**\n\nHere is the skeleton for the main shield request handler. Learners must fill in the detailed logic.\n\n```python\n# src/blue_origin/shield/handler.py\nimport asyncio\nfrom typing import Dict, Tuple, Optional\nfrom .coalescing import RequestCoalescingMap\nfrom ..edge.cache import CacheStorage, CacheEntry, generate_cache_key\nfrom ..utils.http import (\n    is_response_cacheable,\n    parse_cache_control_header,\n    CacheDirectives,\n    get_header_values\n)\n\nclass ShieldRequestHandler:\n    \"\"\"\n    HTTP request handler for the Origin Shield.\n    \"\"\"\n    def __init__(self,\n                 cache: CacheStorage,\n                 origin_upstream: str,\n                 coalescing_map: RequestCoalescingMap,\n                 max_concurrent_origin_requests: int = 100):\n        self.cache = cache\n        self.origin_upstream = origin_upstream.rstrip('/')\n        self.coalescing_map = coalescing_map\n        # Semaphore to limit concurrent origin requests\n        self._origin_semaphore = asyncio.Semaphore(max_concurrent_origin_requests)\n\n    async def handle_request(self,\n                            request_headers: Dict[str, str],\n                            request_body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Main request handling algorithm for the shield.\n        Called by the shield's HTTP server for each incoming request (from an edge node).\n        \"\"\"\n        # TODO 1: Extract the request method, URL, and headers.\n        #   - The URL is in request_headers[':path'] (or similar, depending on your HTTP lib).\n        #   - The method is in request_headers[':method'].\n\n        # TODO 2: Generate the cache key for this request.\n        #   - Use the same `generate_cache_key` function as the edge node.\n        #   - It must consider the `Vary` header from the *original client request*\n        #     which should be forwarded by the edge. Assume it's in a header like `X-Forwarded-Vary`.\n\n        # TODO 3: Check the shield's local cache for a fresh entry.\n        #   - Use `self.cache.get(cache_key)`.\n        #   - If found and `entry.is_fresh(current_time)` is True, return the cached response.\n        #   - If found but stale, check `stale-while-revalidate` directive.\n        #     If allowed, serve stale and trigger background revalidation (TODO 8).\n\n        # TODO 4: Check the Request Coalescing Map.\n        #   - Call `self.coalescing_map.get_or_create_future(cache_key)`.\n        #   - If this returns an *existing* Future, it means a request is already in flight.\n        #     - Wait on that Future (`await future`).\n        #     - Return the result it provides. This is the collapsed request path.\n\n        # TODO 5: If we are here, we are the first/only request (we created the Future).\n        #   Now we must fetch from the origin.\n        #   - Acquire the origin semaphore: `async with self._origin_semaphore:`.\n        #   - Make an HTTP request to `self.origin_upstream + url` with the appropriate headers.\n        #   - Enforce a timeout (e.g., 10 seconds).\n\n        # TODO 6: Process the origin's response.\n        #   - If the request succeeded (status code 2xx, 3xx, 404, etc.):\n        #     a. Determine if response is cacheable via `is_response_cacheable`.\n        #     b. If cacheable, create a `CacheEntry` and store it in `self.cache`.\n        #     c. If it's an error (4xx, 5xx), consider negative caching with a short TTL.\n        #   - If the request failed (network error, timeout):\n        #     Consider serving stale content from cache if available (graceful degradation).\n\n        # TODO 7: Fulfill the Future in the coalescing map.\n        #   - Call `self.coalescing_map.fulfill_future(cache_key, result)` where result is\n        #     (status_code, headers, body).\n        #   - This will wake up all other requests waiting on this same cache key.\n\n        # TODO 8: (Background) If serving stale content under `stale-while-revalidate`,\n        #   spawn a background task to revalidate the cache entry with the origin.\n        #   - Use `asyncio.create_task(self._revalidate_in_background(cache_key, stale_entry, request_headers))`.\n\n        # TODO 9: Return the HTTP response (status, headers, body) to the caller.\n        pass  # Placeholder return (will be filled by learner)\n        return 500, {\"Content-Type\": \"text/plain\"}, b\"Not implemented\"\n\n    async def _revalidate_in_background(self,\n                                       cache_key: str,\n                                       stale_entry: CacheEntry,\n                                       request_headers: Dict[str, str]) -> None:\n        \"\"\"\n        Asynchronously revalidate a stale cache entry with the origin.\n        If successful, update the cache with the new entry.\n        \"\"\"\n        # TODO 1: Make a conditional request to the origin.\n        #   - Include `If-None-Match: stale_entry.etag` and/or `If-Modified-Since: stale_entry.last_modified`.\n        #   - Use the same request headers as the original (but potentially with conditional headers).\n\n        # TODO 2: If origin returns 304 Not Modified, update the `fetched_at` and `expires_at`\n        #   of the stale_entry to mark it fresh again, and store it back in the cache.\n\n        # TODO 3: If origin returns a new response (200 OK), store it as a new CacheEntry,\n        #   replacing the old one.\n\n        # TODO 4: If the origin request fails, log the error. The stale entry remains stale.\n        pass\n```\n\n**E. Language-Specific Hints (Python)**\n\n*   **Concurrency:** Use `asyncio` throughout the shield. The `aiohttp` library provides excellent asynchronous HTTP client and server capabilities. The `RequestCoalescingMap` heavily relies on `asyncio.Future` for synchronization.\n*   **Timeouts:** Always use `asyncio.wait_for` or the `timeout` parameter in `aiohttp` client calls to prevent hung requests from consuming resources indefinitely.\n*   **Graceful Shutdown:** Ensure your shield server has a shutdown handler that waits for in-flight origin requests to complete (or times them out) before exiting.\n*   **Metrics Integration:** Use the `ShieldMetrics` data structure to track counts of collapsed requests, origin errors, and queue sizes. Export these via a `/metrics` endpoint for monitoring.\n\n**F. Milestone Checkpoint**\n\nAfter implementing the `ShieldRequestHandler` and the `RequestCoalescingMap`, you can verify basic functionality with the following steps:\n\n1.  **Start the Origin:** Run a simple static file server (e.g., `python -m http.server 8000`).\n2.  **Start the Shield:** Run your shield server, configured to upstream to `http://localhost:8000`.\n    ```bash\n    python scripts/run_shield.py --config configs/shield_config.yaml\n    ```\n3.  **Simulate Concurrent Edge Requests:** Write a small test script that uses `asyncio` to send 10 identical `GET` requests to the shield at the same time.\n    ```python\n    import aiohttp\n    import asyncio\n\n    async def fetch(session, url):\n        async with session.get(url) as resp:\n            return await resp.text()\n\n    async def main():\n        url = \"http://localhost:8080/shield/path/to/image.jpg\"\n        async with aiohttp.ClientSession() as session:\n            tasks = [fetch(session, url) for _ in range(10)]\n            responses = await asyncio.gather(*tasks)\n            print(f\"Sent 10 concurrent requests. All received responses.\")\n            # Verify all responses are identical\n            assert all(r == responses[0] for r in responses)\n\n    asyncio.run(main())\n    ```\n4.  **Expected Behavior:**\n    *   The shield's access log should show only **one** request to the origin (`localhost:8000`) for `/path/to/image.jpg`.\n    *   The origin server's log should also show only **one** request.\n    *   All 10 client requests should receive the same, correct response.\n    *   The shield's metrics (if exposed) should show `collapsed_requests: 9`.\n5.  **Signs of Trouble:**\n    *   **Origin sees 10 requests:** The request collapsing logic is not working. Check the `RequestCoalescingMap` implementation and the logic in `handle_request` steps 4 and 5.\n    *   **Clients receive errors or hang:** The Future fulfillment logic (`fulfill_future`/`fail_future`) may be broken, or the shield's HTTP client might be failing. Check error handling and timeouts.\n    *   **Responses differ:** Cache key generation is inconsistent, possibly not handling `Vary` headers correctly. Ensure the edge node forwards the necessary headers (like `Accept-Encoding`) to the shield.\n\n---\n\n\n## Component: Edge Node Distribution & Routing (Milestone 4)\n\n> **Milestone(s):** Milestone 4 (Edge Node Distribution & Routing)\n\n### Mental Model: The Air Traffic Control Map\n\nImagine a global air traffic control system for web requests. Planes (user requests) depart from airports worldwide (user locations) and need to land at the nearest available, operational airport (edge node) for their destination. The air traffic controller (routing system) must:\n\n1. **Know all airports**: Maintain a real-time map of all edge nodes, their geographic locations, and operational status\n2. **Direct to nearest**: Calculate the geographically closest operational airport for each incoming flight based on its departure point (user IP)\n3. **Handle emergencies**: When an airport closes (node fails), redirect incoming flights to the next-nearest airport within seconds\n4. **Balance traffic**: Evenly distribute flights across airports with similar proximity to prevent congestion\n\nThis mental model captures the essence of a multi-node CDN: we have multiple geographically distributed edge servers (airports), clients make requests from various locations (flights departing), and our routing system (air traffic control) must intelligently direct each request to the optimal edge node based on proximity and health. Just as a flight from Tokyo shouldn't be directed to an airport in London when there's one in Osaka, a user in Japan shouldn't be served from a European edge node when there's a Tokyo PoP available.\n\n### Geo-Routing & Health Checking\n\nGeo-routing ensures users connect to the geographically closest edge node, minimizing network latency. Health checking ensures we don't route traffic to nodes that are malfunctioning or offline.\n\n#### How Client IPs Map to Edge Nodes\n\nThe mapping process follows this algorithm:\n\n1. **IP Geolocation**: When a request arrives (or during DNS resolution), we determine the client's approximate geographic location from their IP address using a GeoIP database\n2. **Node Location Database**: Each edge node registers its physical location (latitude/longitude or region code) with the control plane during startup\n3. **Distance Calculation**: For each healthy edge node, calculate the geographic distance to the client using the Haversine formula (great-circle distance)\n4. **Selection**: Select the edge node with the smallest distance that also meets capacity and health constraints\n5. **Fallback**: If the nearest node is unhealthy, select the next nearest healthy node\n\nThe geographic mapping can be implemented at different layers:\n\n| Mapping Layer | How It Works | Pros | Cons |\n|--------------|--------------|------|------|\n| **DNS-Based** | DNS server returns different A/AAAA records based on the resolver's IP location | Simple, works with any client | Depends on client's DNS resolver location, not end-user location |\n| **Anycast** | Same IP address announced from multiple locations; BGP routes to nearest | Transparent to client, fastest failover | Complex BGP configuration, all nodes share same IP |\n| **HTTP Redirect** | Central gateway receives all requests, responds with 302 to nearest edge | Most accurate (sees real client IP), flexible | Adds extra round-trip for first request |\n\n#### Health Checking Implementation\n\nHealth checking is a continuous process that monitors each edge node's operational status:\n\n**Passive Health Checking**: Monitor actual traffic patterns\n- Track error rates (5xx responses) from the node\n- Monitor request latency percentiles\n- Observe TCP connection failures\n\n**Active Health Checking**: Periodic synthetic requests\n- HTTP GET to `/health` endpoint on each edge node\n- Validate response status code (200 OK) and optionally content\n- Check within configurable intervals (e.g., every 10 seconds)\n- Consider network path health (latency, packet loss)\n\nThe health state machine for an edge node follows these transitions:\n\n| Current State | Event | Next State | Action Taken |\n|---------------|-------|------------|--------------|\n| **HEALTHY** | 3 consecutive health checks fail | **UNHEALTHY** | Remove from DNS rotation, stop routing new traffic |\n| **UNHEALTHY** | 2 consecutive health checks succeed | **DEGRADED** | Add back to rotation with reduced traffic weight |\n| **DEGRADED** | 5 consecutive health checks succeed | **HEALTHY** | Restore full traffic weight |\n| **DEGRADED** | 1 health check fails | **UNHEALTHY** | Remove from rotation again |\n| Any state | Manual admin command (disable) | **MAINTENANCE** | Gracefully drain connections, no new traffic |\n| **MAINTENANCE** | Manual admin command (enable) | **HEALTHY** | Add to rotation, full weight |\n\nHealth check responses include detailed metrics:\n\n```python\n# Example health check response structure\n{\n  \"status\": \"healthy\",\n  \"timestamp\": 1678901234.567,\n  \"metrics\": {\n    \"cache_hit_ratio\": 0.89,\n    \"request_rate\": 1250.5,\n    \"error_rate\": 0.001,\n    \"cpu_utilization\": 0.45,\n    \"memory_used_mb\": 2048,\n    \"active_connections\": 347\n  },\n  \"version\": \"1.2.3\",\n  \"region\": \"us-west-2\"\n}\n```\n\n### Consistent Hashing for Cache Distribution\n\nWhen we have multiple edge nodes, we face a critical decision: should each node cache independently (edge-local caching) or should we distribute cache entries across nodes (shared caching)? For our educational CDN, we implement **consistent hashing** to distribute cache load while minimizing reshuffling when nodes join or leave.\n\n#### The Problem: Cache Distribution & Reshuffling\n\nConsider three approaches:\n\n1. **Independent Caches**: Each edge node caches what it serves. Simple but inefficient - popular content gets cached redundantly on every node that serves it, wasting memory. Cache hit ratio lower due to divided cache space.\n2. **Centralized Cache**: All edge nodes query a shared cache cluster. Efficient memory use but single point of failure, adds latency.\n3. **Distributed with Hashing**: Each URL maps to a specific edge node via hashing; that node becomes the \"owner\" of that cached content. Other nodes can fetch from the owner on cache miss.\n\nThe naive hashing approach (`hash(url) % num_nodes`) has a major problem: when nodes are added or removed, nearly all URLs remap to different nodes, causing massive cache invalidation (the \"reshuffling problem\").\n\n#### Consistent Hashing Solution\n\nConsistent hashing solves the reshuffling problem by hashing both nodes and keys onto a virtual ring:\n\n![Consistent Hashing Ring for Edge Distribution](./diagrams/diagram-consistent-hashing-ring.svg)\n\n**Algorithm**:\n1. Create a virtual circle representing the hash space (0 to 2^m - 1, where m is typically 160 for SHA-1)\n2. For each edge node, compute multiple hash points (virtual nodes) around the circle (e.g., 100-200 replicas per physical node)\n3. For each cache key (URL + Vary headers), compute its hash and find the next hash point clockwise around the circle\n4. The node owning that hash point is responsible for caching that content\n\n**When a node joins**:\n1. Compute virtual node positions for the new node\n2. Only keys that hash between the new node's positions and the previous node's positions get reassigned\n3. This affects only `1/(n+1)` of keys on average, not all keys\n\n**When a node fails**:\n1. Its virtual nodes are removed from the ring\n2. Keys that mapped to those virtual nodes now map to the next node clockwise\n3. Affected keys can be re-fetched from origin or replicated in advance\n\n**Data Structures for Consistent Hashing**:\n\n| Structure Name | Fields | Description |\n|----------------|--------|-------------|\n| `HashRingNode` | `node_id: str`, `physical_node: EdgeNode`, `position: int` | A virtual node on the hash ring |\n| `EdgeNode` | `node_id: str`, `region: str`, `address: str`, `weight: int`, `health_status: NodeHealth` | Physical edge node information |\n| `ConsistentHashRing` | `nodes: SortedDict[int, HashRingNode]`, `replicas_per_node: int`, `hash_function: Callable` | Main hash ring structure |\n\nThe `ConsistentHashRing` interface:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `add_node` | `node: EdgeNode` | `None` | Add a physical node with virtual replicas to the ring |\n| `remove_node` | `node_id: str` | `None` | Remove a node and all its virtual replicas |\n| `get_node` | `key: str` | `EdgeNode` | Find the node responsible for the given key |\n| `get_replica_nodes` | `key: str`, `count: int` | `List[EdgeNode]` | Get the primary node plus N-1 successor nodes for replication |\n\n> **Key Insight**: Virtual nodes (replicas) serve two purposes: 1) They provide better load distribution by preventing clustering, and 2) They allow weighting - nodes with more capacity get more virtual nodes, receiving proportionally more keys.\n\n### ADR: Client Routing Mechanism\n\n> **Decision: Hybrid DNS-Based Routing with HTTP Fallback**\n> \n> **Context**: We need to direct clients to the nearest healthy edge node. The routing must work with unmodified web browsers (standard HTTP/HTTPS), provide fast failover (<5 seconds), and handle GeoIP inaccuracy gracefully. We're building an educational CDN, not a commercial anycast network.\n> \n> **Options Considered**:\n> 1. **Pure DNS-based geo-routing**: DNS server returns different A records based on resolver IP location\n> 2. **Anycast BGP routing**: Same IP advertised from all locations, BGP routes to nearest\n> 3. **HTTP redirect-based**: All clients hit central endpoint, get 302 redirected to nearest edge\n> 4. **Hybrid DNS+HTTP**: DNS returns multiple edges, client tries nearest, falls back via 302\n> \n> **Decision**: Implement hybrid DNS-based routing with HTTP fallback. DNS returns 2-3 nearest edge IPs ordered by proximity. Client tries the first; if unhealthy (connection fails or receives 503), tries the next. For cache misses that need to reach a different edge (due to consistent hashing), the serving edge issues an HTTP 302 to the correct edge.\n> \n> **Rationale**:\n> - DNS-based routing works with all clients without special software\n> - Multiple IPs in DNS provide client-side failover when first edge is down\n> - HTTP redirects handle cases where GeoIP is wrong or cache location differs from optimal edge\n> - Avoids BGP anycast complexity (requires ISP relationships, not feasible for educational project)\n> - Provides flexibility: we can implement smart routing logic at both DNS and HTTP layers\n> \n> **Consequences**:\n> - Adds one extra HTTP redirect for cache misses that hash to different edge than client's nearest\n> - DNS TTL (Time-To-Live) must be balanced: too short causes excessive DNS queries, too long delays failover\n> - Need to maintain both DNS infrastructure and HTTP redirect logic\n> - Clients with broken DNS caching may experience suboptimal routing\n\n**Comparison of Routing Options**:\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **DNS-Based Geo-Routing** | Simple, works everywhere, scales well | GeoIP inaccuracy, DNS caching delays failover, all-or-nothing | Partially - as primary |\n| **Anycast BGP** | Transparent, fastest failover, optimal routing | Complex setup, requires ISP partnerships, expensive | No - too complex for educational |\n| **HTTP Redirect** | Most accurate (sees real client IP), flexible control | Extra round-trip, breaks some client assumptions | Partially - as fallback |\n| **Hybrid DNS+HTTP** | Best of both: DNS for speed, HTTP for accuracy | Implementation complexity, two systems to maintain | **Yes** - optimal balance |\n\n### Common Pitfalls in Distribution\n\n⚠️ **Pitfall: GeoIP Database Inaccuracy**\n- **Description**: Assuming GeoIP databases are perfectly accurate. In reality, they're often wrong by hundreds of miles, especially for mobile networks and VPNs.\n- **Why It's Wrong**: A user in New York might be mapped to a Los Angeles edge node due to ISP routing through California, adding 100ms+ latency.\n- **How to Fix**: \n  1. Use multiple GeoIP databases and cross-reference\n  2. Implement latency-based verification: ping potential edges from client location\n  3. Allow manual override via cookie or URL parameter for testing\n  4. Use HTTP redirect as correction mechanism when wrong edge is selected\n\n⚠️ **Pitfall: Thundering Herd on Edge Failover**\n- **Description**: When an edge node fails, all its traffic immediately shifts to the next-nearest node, potentially overloading it.\n- **Why It's Wrong**: The backup node might have 50% spare capacity, but gets 100% more traffic instantly, causing cascading failure.\n- **How to Fix**:\n  1. Implement gradual traffic shift: redirect 10% of users every second, not all at once\n  2. Monitor backup node load and throttle redirects if approaching capacity\n  3. Use multiple backup nodes with weighted distribution\n  4. Implement client-side exponential backoff when connecting to overloaded nodes\n\n⚠️ **Pitfall: Cache Inconsistency (\"Cold Starts\") on New Nodes**\n- **Description**: When a new edge node is added to the cluster, it starts with empty cache. All requests become cache misses until it warms up.\n- **Why It's Wrong**: Performance degrades just when trying to add capacity, and origin gets hammered by cache fill requests.\n- **How to Fix**:\n  1. Implement cache warming: pre-fetch popular content before adding to rotation\n  2. Use consistent hashing with replication: new node can fetch from neighboring nodes\n  3. Gradual traffic ramp-up: start with 1% of traffic, increase as cache fills\n  4. Share cache data between nodes for hottest content\n\n⚠️ **Pitfall: DNS TTL Misconfiguration**\n- **Description**: Setting DNS TTL too high (hours) delays failover; setting too low (seconds) causes excessive DNS load.\n- **Why It's Wrong**: With 1-hour TTL, clients continue trying dead edge for up to an hour. With 5-second TTL, DNS servers get hammered.\n- **How to Fix**:\n  1. Use adaptive TTL: 300 seconds normally, 30 seconds when changes are pending\n  2. Implement DNS-based health checks that override TTL for unhealthy nodes\n  3. Use HTTP-level failover as backup when DNS fails\n  4. Consider EDNS Client Subnet for more accurate GeoIP at DNS level\n\n⚠️ **Pitfall: Ignoring Network Topology**\n- **Description**: Routing based solely on geographic distance, ignoring network congestion, peering arrangements, and ISP relationships.\n- **Why It's Wrong**: An edge 50 miles away through a congested peer might be slower than one 200 miles away through a direct fiber link.\n- **How to Fix**:\n  1. Augment geographic distance with latency measurements\n  2. Implement network-aware routing that considers AS (Autonomous System) paths\n  3. Use real-time latency data from monitoring to adjust routing weights\n  4. Consider cost: some network paths might be more expensive despite being faster\n\n### Implementation Guidance for Distribution\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| GeoIP Database | MaxMind GeoLite2 (free) | MaxMind GeoIP2 Enterprise or IPinfo.io API |\n| DNS Server | Python `dnslib` library for custom DNS | PowerDNS with GeoIP backend or AWS Route 53 |\n| Health Checking | HTTP endpoint with simple status | Complex health checks with dependency verification |\n| Consistent Hashing | In-memory hash ring with virtual nodes | Ring with replication, persistence, and load balancing |\n| Node Discovery | Static configuration file | etcd or ZooKeeper for dynamic registration |\n\n#### B. Recommended File/Module Structure\n\n```\nblue_origin/\n├── edge/\n│   ├── __init__.py\n│   ├── server.py              # Edge HTTP server (from Milestone 1)\n│   ├── cache.py              # Cache storage (from Milestone 1)\n│   └── health.py             # Health check endpoint\n├── routing/\n│   ├── __init__.py\n│   ├── geo.py                # GeoIP lookup utilities\n│   ├── hash_ring.py          # Consistent hashing implementation\n│   ├── dns_server.py         # Custom DNS server for geo-routing\n│   └── node_registry.py      # Edge node registration and discovery\n├── control/\n│   ├── __init__.py\n│   ├── plane.py              # Control plane logic\n│   └── metrics_aggregator.py # Collect metrics from edges\n└── config/\n    ├── __init__.py\n    ├── edge.yaml             # Edge node configuration\n    └── routing.yaml          # Routing configuration\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete Health Check Endpoint**:\n\n```python\n# routing/health.py\nimport time\nimport json\nimport asyncio\nfrom dataclasses import dataclass, asdict\nfrom typing import Dict, Any, Optional\nfrom enum import Enum\n\nclass NodeHealth(Enum):\n    HEALTHY = \"healthy\"\n    DEGRADED = \"degraded\"\n    UNHEALTHY = \"unhealthy\"\n    MAINTENANCE = \"maintenance\"\n\n@dataclass\nclass HealthMetrics:\n    \"\"\"Metrics reported in health check response.\"\"\"\n    cache_hit_ratio: float = 0.0\n    request_rate: float = 0.0  # requests per second\n    error_rate: float = 0.0    # error rate (0.0-1.0)\n    cpu_utilization: float = 0.0  # 0.0-1.0\n    memory_used_mb: int = 0\n    memory_total_mb: int = 0\n    active_connections: int = 0\n    cache_size_bytes: int = 0\n    cache_capacity_bytes: int = 0\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return asdict(self)\n\nclass HealthChecker:\n    \"\"\"Manages health state and provides health check endpoint.\"\"\"\n    \n    def __init__(self, node_id: str, region: str, version: str):\n        self.node_id = node_id\n        self.region = region\n        self.version = version\n        self.health_status = NodeHealth.HEALTHY\n        self.metrics = HealthMetrics()\n        self.start_time = time.time()\n        self._check_interval = 10  # seconds\n        self._check_task: Optional[asyncio.Task] = None\n        \n    async def start(self):\n        \"\"\"Start background health monitoring.\"\"\"\n        self._check_task = asyncio.create_task(self._monitor_loop())\n        \n    async def stop(self):\n        \"\"\"Stop health monitoring.\"\"\"\n        if self._check_task:\n            self._check_task.cancel()\n            try:\n                await self._check_task\n            except asyncio.CancelledError:\n                pass\n                \n    async def _monitor_loop(self):\n        \"\"\"Background task to update health metrics.\"\"\"\n        while True:\n            try:\n                await self._update_metrics()\n                await self._evaluate_health()\n            except Exception as e:\n                print(f\"Health monitor error: {e}\")\n            await asyncio.sleep(self._check_interval)\n    \n    async def _update_metrics(self):\n        \"\"\"Update health metrics from system monitoring.\"\"\"\n        # In a real implementation, this would collect:\n        # - Cache statistics from cache storage\n        # - System metrics (CPU, memory)\n        # - Network connection counts\n        # For now, we'll use placeholder values\n        self.metrics.cache_hit_ratio = 0.85  # Example\n        self.metrics.request_rate = 1250.5   # Example\n        self.metrics.error_rate = 0.001      # Example\n        self.metrics.active_connections = 347 # Example\n        \n    async def _evaluate_health(self):\n        \"\"\"Evaluate overall health status based on metrics.\"\"\"\n        if self.metrics.error_rate > 0.1:  # 10% error rate\n            self.health_status = NodeHealth.UNHEALTHY\n        elif self.metrics.error_rate > 0.05:  # 5% error rate\n            self.health_status = NodeHealth.DEGRADED\n        elif self.metrics.cpu_utilization > 0.9:  # 90% CPU\n            self.health_status = NodeHealth.DEGRADED\n        else:\n            self.health_status = NodeHealth.HEALTHY\n    \n    async def handle_health_request(self) -> tuple[int, Dict[str, str], bytes]:\n        \"\"\"Handle HTTP GET /health request.\"\"\"\n        uptime = time.time() - self.start_time\n        \n        response_data = {\n            \"status\": self.health_status.value,\n            \"node_id\": self.node_id,\n            \"region\": self.region,\n            \"version\": self.version,\n            \"timestamp\": time.time(),\n            \"uptime_seconds\": uptime,\n            \"metrics\": self.metrics.to_dict()\n        }\n        \n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Cache-Control\": \"no-cache, no-store, must-revalidate\"\n        }\n        \n        return 200, headers, json.dumps(response_data).encode('utf-8')\n    \n    def get_health_status(self) -> NodeHealth:\n        \"\"\"Get current health status.\"\"\"\n        return self.health_status\n```\n\n#### D. Core Logic Skeleton Code\n\n**Consistent Hash Ring Implementation**:\n\n```python\n# routing/hash_ring.py\nimport bisect\nimport hashlib\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass EdgeNode:\n    \"\"\"Represents a physical edge node.\"\"\"\n    node_id: str\n    region: str\n    address: str  # IP:port\n    weight: int = 100  # Relative capacity (100 = normal)\n    health_status: str = \"healthy\"\n\n@dataclass  \nclass HashRingNode:\n    \"\"\"A virtual node on the consistent hash ring.\"\"\"\n    node_id: str\n    physical_node: EdgeNode\n    position: int  # Hash position on the ring (0 to 2^m-1)\n\nclass ConsistentHashRing:\n    \"\"\"\n    Consistent hashing implementation with virtual nodes.\n    \n    The ring maps cache keys to edge nodes for distributed caching.\n    \"\"\"\n    \n    def __init__(self, replicas_per_node: int = 100, hash_bits: int = 160):\n        \"\"\"\n        Initialize an empty hash ring.\n        \n        Args:\n            replicas_per_node: Number of virtual nodes per physical node\n            hash_bits: Number of bits in hash space (default 160 for SHA-1)\n        \"\"\"\n        self.replicas_per_node = replicas_per_node\n        self.hash_bits = hash_bits\n        self.hash_space = 2 ** hash_bits\n        self.ring: Dict[int, HashRingNode] = {}  # position -> virtual node\n        self.sorted_positions: List[int] = []  # Sorted list of positions\n        self.nodes: Dict[str, EdgeNode] = {}  # node_id -> physical node\n        \n    def _hash(self, key: str) -> int:\n        \"\"\"\n        Hash a string key to a position on the ring.\n        \n        Args:\n            key: String to hash\n            \n        Returns:\n            Integer position in hash space\n        \"\"\"\n        # TODO 1: Use SHA-1 hash function (or configurable)\n        # TODO 2: Convert hash digest to integer in range [0, hash_space-1]\n        # TODO 3: Return the integer position\n        pass\n    \n    def add_node(self, node: EdgeNode) -> None:\n        \"\"\"\n        Add a physical node to the hash ring.\n        \n        Creates multiple virtual nodes (replicas) for better distribution.\n        \n        Args:\n            node: EdgeNode to add\n        \"\"\"\n        # TODO 1: Check if node already exists, return if it does\n        # TODO 2: Calculate number of replicas based on node weight\n        # TODO 3: For each replica i in range(num_replicas):\n        #   - Create key: f\"{node.node_id}:{i}\"\n        #   - Hash the key to get position\n        #   - Create HashRingNode\n        #   - Add to self.ring and self.sorted_positions\n        # TODO 4: Sort self.sorted_positions for binary search\n        # TODO 5: Add physical node to self.nodes dict\n        pass\n    \n    def remove_node(self, node_id: str) -> Optional[EdgeNode]:\n        \"\"\"\n        Remove a node from the hash ring.\n        \n        Args:\n            node_id: ID of node to remove\n            \n        Returns:\n            Removed EdgeNode or None if not found\n        \"\"\"\n        # TODO 1: Check if node exists in self.nodes\n        # TODO 2: Remove all virtual nodes for this physical node\n        # TODO 3: Update self.sorted_positions list\n        # TODO 4: Remove from self.nodes dict\n        # TODO 5: Return the removed node\n        pass\n    \n    def get_node(self, key: str) -> Optional[EdgeNode]:\n        \"\"\"\n        Get the node responsible for a given cache key.\n        \n        Args:\n            key: Cache key (URL + vary headers)\n            \n        Returns:\n            EdgeNode responsible for this key, or None if ring is empty\n        \"\"\"\n        # TODO 1: If ring is empty, return None\n        # TODO 2: Hash the key to get position\n        # TODO 3: Use bisect to find first position >= hashed position\n        # TODO 4: If at end of list, wrap around to first position\n        # TODO 5: Get virtual node at that position\n        # TODO 6: Return the physical node\n        pass\n    \n    def get_replica_nodes(self, key: str, count: int = 3) -> List[EdgeNode]:\n        \"\"\"\n        Get the primary node plus replica nodes for a key.\n        \n        Used for cache replication to handle node failures.\n        \n        Args:\n            key: Cache key\n            count: Total number of nodes to return (including primary)\n            \n        Returns:\n            List of EdgeNodes, starting with primary\n        \"\"\"\n        # TODO 1: Get primary node with get_node(key)\n        # TODO 2: If ring is empty, return empty list\n        # TODO 3: Find position of primary node's virtual node\n        # TODO 4: Get next N-1 distinct physical nodes clockwise\n        # TODO 5: Return list of nodes\n        pass\n    \n    def redistribute_keys(self, old_node: EdgeNode, new_node: EdgeNode) -> List[Tuple[str, EdgeNode]]:\n        \"\"\"\n        Calculate which keys need to move when replacing a node.\n        \n        Args:\n            old_node: Node being removed\n            new_node: Node being added\n            \n        Returns:\n            List of (key, new_node) pairs for keys that should move\n        \"\"\"\n        # TODO 1: Get all virtual node positions for old_node\n        # TODO 2: For each virtual node position:\n        #   - Find keys that hash to positions between this node and previous\n        #   - These keys will now map to new_node\n        # TODO 3: Return list of affected keys and their new node\n        # Note: In practice, we'd need to know all existing keys to do this\n        pass\n```\n\n**Simple GeoIP Lookup Utility**:\n\n```python\n# routing/geo.py\nimport maxminddb\nfrom dataclasses import dataclass\nfrom typing import Optional, Tuple\n\n@dataclass\nclass GeoLocation:\n    \"\"\"Geographic location information.\"\"\"\n    country_code: Optional[str]\n    country_name: Optional[str]\n    region_code: Optional[str]\n    region_name: Optional[str]\n    city: Optional[str]\n    latitude: Optional[float]\n    longitude: Optional[float]\n    metro_code: Optional[int]  # US metro code\n    timezone: Optional[str]\n\nclass GeoIPLookup:\n    \"\"\"GeoIP lookup using MaxMind database.\"\"\"\n    \n    def __init__(self, database_path: str):\n        \"\"\"\n        Initialize GeoIP lookup.\n        \n        Args:\n            database_path: Path to MaxMind GeoLite2 database file\n        \"\"\"\n        # TODO 1: Open MaxMind database file\n        # TODO 2: Verify database is readable and valid\n        # TODO 3: Store reader instance\n        pass\n    \n    def lookup(self, ip_address: str) -> Optional[GeoLocation]:\n        \"\"\"\n        Look up geographic location for an IP address.\n        \n        Args:\n            ip_address: IP address string (IPv4 or IPv6)\n            \n        Returns:\n            GeoLocation or None if not found\n        \"\"\"\n        # TODO 1: Validate IP address format\n        # TODO 2: Query MaxMind database\n        # TODO 3: Parse response into GeoLocation dataclass\n        # TODO 4: Handle errors (invalid IP, not in database)\n        pass\n    \n    def distance_between(self, loc1: GeoLocation, loc2: GeoLocation) -> float:\n        \"\"\"\n        Calculate great-circle distance between two locations.\n        \n        Uses Haversine formula.\n        \n        Args:\n            loc1: First location\n            loc2: Second location\n            \n        Returns:\n            Distance in kilometers\n        \"\"\"\n        # TODO 1: Check if both locations have latitude/longitude\n        # TODO 2: Convert degrees to radians\n        # TODO 3: Apply Haversine formula\n        # TODO 4: Return distance in kilometers\n        pass\n    \n    def find_nearest_node(self, client_ip: str, nodes: List[EdgeNode]) -> Optional[EdgeNode]:\n        \"\"\"\n        Find nearest edge node for a client IP.\n        \n        Args:\n            client_ip: Client IP address\n            nodes: List of available edge nodes\n            \n        Returns:\n            Nearest EdgeNode or None if can't determine\n        \"\"\"\n        # TODO 1: Look up client location from IP\n        # TODO 2: For each node with known location:\n        #   - Calculate distance to client\n        # TODO 3: Return node with minimum distance\n        # TODO 4: Handle edge cases (no location data, etc.)\n        pass\n```\n\n#### E. Python-Specific Hints\n\n1. **MaxMind Database**: Use `maxminddb` library: `pip install maxminddb`. The free GeoLite2 database is available from MaxMind (requires account registration).\n\n2. **DNS Server**: For a simple DNS server, use the `dnslib` library: `pip install dnslib`. It provides DNS protocol handling without needing bind/named.\n\n3. **Consistent Hashing Performance**: Use `bisect` module for O(log n) lookups in the sorted positions list. For production, consider a balanced tree structure.\n\n4. **Health Checks**: Use `asyncio` for non-blocking health checks. The `aiohttp` library is good for HTTP health checks to other nodes.\n\n5. **Node Discovery**: For a simple implementation, use HTTP registration: nodes POST to control plane on startup. For advanced, use `etcd3` or `kazoo` (ZooKeeper) libraries.\n\n6. **Monitoring Metrics**: Use `psutil` library to gather system metrics (CPU, memory, disk) for health reporting.\n\n#### F. Milestone Checkpoint\n\n**To verify Milestone 4 implementation**:\n\n1. **Start multiple edge nodes**:\n   ```bash\n   # Terminal 1 (US East)\n   python -m blue_origin.edge.server --config config/edge_us_east.yaml\n   \n   # Terminal 2 (US West)  \n   python -m blue_origin.edge.server --config config/edge_us_west.yaml\n   \n   # Terminal 3 (Europe)\n   python -m blue_origin.edge.server --config config/edge_eu.yaml\n   ```\n\n2. **Start control plane and DNS server**:\n   ```bash\n   python -m blue_origin.routing.dns_server --config config/routing.yaml\n   python -m blue_origin.control.plane --config config/control.yaml\n   ```\n\n3. **Test DNS-based geo-routing**:\n   ```bash\n   # Simulate queries from different locations\n   dig @localhost -p 5353 mycdn.example.com A +subnet=8.8.8.0/24  # US query\n   dig @localhost -p 5353 mycdn.example.com A +subnet=194.158.0.0/16  # EU query\n   ```\n   Expected: Different IPs returned based on source subnet.\n\n4. **Test health checking**:\n   ```bash\n   # Check health endpoint\n   curl http://localhost:8080/health  # Should return JSON with status\n   \n   # Stop one edge node, verify DNS stops returning it within 15 seconds\n   # (kill US West node, then query again)\n   ```\n\n5. **Test consistent hashing**:\n   ```python\n   # Python test script\n   from routing.hash_ring import ConsistentHashRing, EdgeNode\n   \n   ring = ConsistentHashRing()\n   ring.add_node(EdgeNode(\"us-east-1\", \"us-east\", \"10.0.1.1:8080\"))\n   ring.add_node(EdgeNode(\"us-west-2\", \"us-west\", \"10.0.2.1:8080\"))\n   \n   # Same URL should always map to same node\n   node1 = ring.get_node(\"/images/cat.jpg\")\n   node2 = ring.get_node(\"/images/cat.jpg\")\n   assert node1.node_id == node2.node_id\n   \n   # Different URLs should distribute across nodes\n   urls = [f\"/page/{i}\" for i in range(1000)]\n   distribution = {}\n   for url in urls:\n       node = ring.get_node(url)\n       distribution[node.node_id] = distribution.get(node.node_id, 0) + 1\n   print(f\"Distribution: {distribution}\")  # Should be roughly 50/50\n   ```\n\n6. **Test failover**:\n   ```bash\n   # Simulate node failure\n   pkill -f \"edge_us_west.yaml\"\n   \n   # Wait 15 seconds for health checks to detect\n   # Then query DNS - should not return west IP\n   # HTTP requests to west should get connection refused\n   # Requests should redirect to east or europe\n   ```\n\n**Expected Behaviors to Verify**:\n- DNS returns different IPs for clients from different continents\n- Health endpoint returns 200 OK with metrics when node is healthy\n- When a node is stopped, DNS stops returning its IP within 30 seconds\n- Cache keys consistently map to same node (until ring changes)\n- Adding/removing nodes affects only ~1/N of cache mappings\n- HTTP redirects work when cache needs to be fetched from different edge\n\n**Signs of Problems**:\n- DNS always returns same IP regardless of source: GeoIP database not loaded\n- Health checks fail: firewall blocking health endpoint\n- Inconsistent node mapping: hash function or ring implementation bug\n- Slow failover (>30 seconds): DNS TTL too high or health check interval too long\n\n\n## Interactions and Data Flow\n> **Milestone(s):** Milestone 1 (Edge Cache Implementation), Milestone 2 (Cache Invalidation), Milestone 3 (Origin Shield & Request Collapsing), Milestone 4 (Edge Node Distribution & Routing)\n\nUnderstanding the static architecture of components is only half the picture. This section animates the system by tracing the journey of real user requests and administrative commands through the complete CDN pipeline. We examine three critical scenarios: the optimal path where content is served directly from the edge, the more complex path involving a cache miss and origin shield, and the control-plane operation of globally invalidating cached content. These traces reveal how the components defined in previous sections collaborate to deliver a seamless, high-performance caching service while maintaining consistency and resilience.\n\n### Data Flow: Cache Hit at Edge\n\n**Mental Model: The Express Checkout Lane**\nImagine a supermarket with a dedicated express lane for customers purchasing common, pre-packaged items. When you approach with a loaf of bread, the cashier immediately recognizes the item (cache key), retrieves it from a nearby shelf (cache storage), scans it (applies headers), and completes the transaction in seconds. No need to visit the store's warehouse (origin). This is a **cache hit** – the fastest possible path through the CDN, where a valid, fresh copy of the requested resource resides at the edge node closest to the user.\n\nA cache hit represents the CDN's primary value proposition: dramatically reduced latency. The following sequence describes each step, from the user's initial request to the cached response being served. Refer to the flowchart `![Flowchart: Edge Node Request Handling](./diagrams/flowchart-request-handling.svg)` for a visual guide to the decision logic within the `EdgeRequestHandler`.\n\n1.  **Client Request Initiation:** An end-user's browser or application sends an HTTP GET request for a resource (e.g., `https://cdn.example.com/images/photo.jpg`). This request may include conditional headers like `If-None-Match` (with an ETag) or `If-Modified-Since` (with a timestamp).\n\n2.  **Geo-Routing & Edge Selection:** The client's DNS resolver, or a global load balancer using Anycast, directs the request to the nearest healthy edge node based on the client's IP address and geographic proximity. The selected edge node's `EdgeRequestHandler` receives the request.\n\n3.  **Request Parsing & Cache Key Construction:** The handler parses the request URL and headers. It constructs a **cache key** by combining the normalized request URL (including query string) and the values of any headers listed in a potential `Vary` header from a previous cached response (e.g., `Accept-Encoding`). If the request itself contains a `Vary: *` header, the handler immediately classifies this as uncacheable and proceeds to a fetch from upstream.\n\n4.  **Cache Lookup:** The handler queries the `CacheStorage` (e.g., an in-memory LRU store) with the generated cache key. In this scenario, the lookup succeeds, returning a `CacheEntry` object.\n\n5.  **Freshness Validation:** The handler checks if the cached entry is fresh by calling `CacheEntry.is_fresh(current_time)`. This evaluates the cached `CacheDirectives` (primarily `s-maxage` or `max-age`) against the current time and the entry's `expires_at` timestamp. If the entry is fresh, the system proceeds to step 7.\n\n6.  **Conditional Revalidation (If Stale):** If the entry is stale but `stale-while-revalidate` is present and its period has not expired, the handler may immediately serve the stale data (proceeding to step 7) while simultaneously spawning a background task via `_revalidate_in_background` to fetch an updated version from the origin. Alternatively, if the client provided conditional headers (`If-None-Match`, `If-Modified-Since`), the handler forwards these to the origin in a conditional request. A `304 Not Modified` response from the origin would refresh the entry's TTL without transferring the body, still resulting in a cache hit from the user's perspective.\n\n7.  **Ban Rule Check:** Before serving the cached content, the handler calls `InvalidationHandler.check_bans(url)` to verify the request URL doesn't match any active `BanRule`. In a hit scenario with no ban, this returns `None`.\n\n8.  **Response Preparation:** The handler prepares the HTTP response. It uses the status code, headers, and body stored in the `CacheEntry`. Critical caching headers like `Age` (calculated as `current_time - fetched_at`) and `Cache-Control` are updated to reflect the current state. If the client supports compression and the cache holds a compressed variant (per the `Vary: Accept-Encoding` dimension), the appropriate `Content-Encoding` header is set.\n\n9.  **Analytics Update:** The `EdgeMetrics` are updated: `total_hits` is incremented, `total_bandwidth_served` is increased by the size of the response body, and counters for the specific status code and content type are updated.\n\n10. **Response Delivery:** The fully formed HTTP response is transmitted back to the client. The transaction is complete, with the origin server entirely uninvolved.\n\n**Key Data Structures Involved:**\n| Structure | Role in Cache Hit |\n|-----------|-------------------|\n| `CacheEntry` | The stored response object containing body, headers, and metadata. |\n| `CacheDirectives` | Parsed directives that determine the entry's freshness and revalidation behavior. |\n| `EdgeMetrics` | Accumulates performance data for analytics. |\n\n### Data Flow: Cache Miss with Origin Shield\n\n**Mental Model: The Concert Vestibule**\nReturning to the concert analogy from the Origin Shield component section, consider a group of fans arriving at the venue for a popular band. They all want entry to the same section (the resource). Instead of each fan individually bothering the busy main ticket scanner (origin), a staff member in the vestibule (shield) takes one representative's request, goes to the scanner to get the ticket validated, and returns with the approval. The other waiting fans receive copies of the same approval. The **shield** orchestrates this **request collapsing**, preventing a stampede.\n\nThis data flow is the most complex, involving multiple tiers and sophisticated coordination to protect the origin. The sequence diagram `![Sequence: Cache Miss with Origin Shielding](./diagrams/seq-cache-miss-shield.svg)` illustrates the full interaction.\n\n1.  **Initial Steps (1-4):** The flow begins identically to a cache hit: client request, geo-routing, and cache key generation at the edge node. However, the cache lookup (step 4) fails, resulting in a **miss**. The `EdgeMetrics.total_misses` is incremented.\n\n2.  **Edge to Shield Request:** The `EdgeRequestHandler` calls `_fetch_from_upstream`, which forwards the original request (potentially with added CDN-specific headers like `X-Forwarded-For`) to the configured **origin shield** URL, not directly to the origin.\n\n3.  **Shield Receives Request:** The `ShieldRequestHandler` at the shield node receives the request. It first performs its own **cache lookup** using the same cache key logic. In this miss scenario, the shield also does not have a fresh entry.\n\n4.  **Request Collapsing Logic:** The shield uses its `RequestCoalescingMap` to prevent a **thundering herd**. It calls `RequestCoalescingMap.get_or_create_future(cache_key)`.\n    *   If this is the **first concurrent request** for this key, the method creates a new `asyncio.Future`, registers it in the map, and allows this request to proceed to the origin.\n    *   If other **identical requests are already in-flight**, the method returns the existing `Future`. These duplicate requests will `await` the result of that single Future, effectively \"collapsing\" into one origin fetch.\n\n5.  **Origin Fetch with Concurrency Limit:** The shield thread/proces that won the right to fetch from the origin first acquires a permit from the `_origin_semaphore`, which enforces a maximum concurrency limit to the origin. It then forwards the request to the **origin server**.\n\n6.  **Origin Response:** The origin server processes the request and returns a standard HTTP response (e.g., `200 OK` with the image data). It should include proper caching headers (`Cache-Control`, `ETag`, `Last-Modified`).\n\n7.  **Shield Cache Storage & Future Fulfillment:** The shield receives the origin response. It validates if the response is cacheable via `is_response_cacheable`. If cacheable, it creates a `CacheEntry` via `CacheEntry.from_upstream_response` and stores it in its own `CacheStorage`. The shield then calls `RequestCoalescingMap.fulfill_future(cache_key, result)` with the response. This action awakens all collapsed requests waiting on that `Future`, providing each with the same response data.\n\n8.  **Negative Caching:** If the origin returns an error (e.g., `404 Not Found` or `5xx`), the shield may still **cache this negative response** for a very short TTL (e.g., 10 seconds) to prevent overwhelming the origin with repeated requests for the same non-existent or failing resource. This is a critical protection mechanism.\n\n9.  **Response to Edge:** The shield sends the origin's response (or the cached negative response) back to the requesting edge node.\n\n10. **Edge Cache Storage:** The edge node receives the response from the shield. It performs its own cacheability check, creates its own `CacheEntry`, stores it locally, and updates the `SurrogateKeyIndex` if the response includes a `Surrogate-Key` header.\n\n11. **Analytics Update:** Both shield and edge update their metrics (`ShieldMetrics.collapsed_requests`, `EdgeMetrics.total_bandwidth_upstream`).\n\n12. **Final Delivery:** Finally, the edge node sends the HTTP response back to the original client. The client receives the data, unaware of the multi-tiered fetching and collapsing that occurred.\n\n**Architecture Decision Record: Request Collapsing Timeout Strategy**\n> **Decision: Use a Short, Configurable Timeout for Collapsed Requests**\n> - **Context:** When requests are collapsed at the shield, duplicate clients wait for a single origin fetch. If that fetch hangs or is very slow, all waiting clients could experience unacceptable latency or timeouts.\n> - **Options Considered:**\n>     1.  **Infinite Wait:** Duplicate requests wait indefinitely for the lead request's future. Simple but risks massive client timeouts and resource exhaustion during origin slowness.\n>     2.  **Client-Propagated Timeout:** Use the shortest remaining client timeout among the collapsed requests. Complex to coordinate and requires intercepting/client timeout awareness.\n>     3.  **Fixed, Configurable Shield Timeout:** Set a shield-specific timeout (e.g., 3-5 seconds) shorter than typical client HTTP timeouts. If the lead request exceeds this, its future fails, releasing waiting requests to potentially retry or bypass collapsing.\n> - **Decision:** Implement a fixed, configurable timeout in the `RequestCoalescingMap` (Option 3).\n> - **Rationale:** This provides a straightforward safety valve. It ensures the shield doesn't become a bottleneck if the origin is severely impaired. The timeout should be configured to be shorter than the edge node's upstream timeout and typical client timeouts, ensuring the edge can fall back to a direct fetch or error before the client disconnects.\n> - **Consequences:** Requires logic to clean up timed-out futures and potentially allows a subsequent request to become the new \"lead\" for fetching, preventing a complete deadlock. Adds a configuration parameter to tune based on origin performance SLAs.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Infinite Wait | Simple implementation | Causes cascading client failures on origin slowness | No |\n| Client-Propagated Timeout | Fair, respects each client's tolerance | Extremely complex; requires parsing timeouts from unknown client implementations | No |\n| Fixed Shield Timeout | Simple, predictable, provides circuit-breaker | May break slow-but-valid origin responses; requires tuning | **Yes** |\n\n### Control Flow: Global Cache Invalidation\n\n**Mental Model: The Building Eviction Notice System**\nImagine a property manager needing to remove specific items from all branch offices. For a single filing cabinet (URL purge), they call each branch to have it removed immediately. For a policy change affecting all documents of a certain category (tag purge), they send a broadcast memo listing the category code. For a rule that all documents matching a pattern (e.g., \"draft-*\") should be discarded upon next access (ban), they update a central rulebook distributed to all branches. The **control plane** is the manager's office, coordinating these distributed operations.\n\nInvalidation is a control-plane operation that ensures consistency between the origin's truth and the cached copies. Its propagation must be reliable and efficient. The sequence diagram `![Sequence: Purge Propagation via Control Plane](./diagrams/seq-invalidation-propagation.svg)` depicts this process.\n\n1.  **Administrative Command:** An administrator or an automated system (e.g., triggered by a content management system update) issues an invalidation command. This is typically done via a dedicated API endpoint (e.g., `PURGE /purge` on the control plane) or a management console. The command specifies the type (`purge`, `soft-purge`, `ban`, `tag`) and target (URL, pattern, or surrogate key).\n\n2.  **Control Plane Reception & Validation:** The control plane's API server receives the command, authenticates/authorizes the request, and validates its parameters. It constructs a standardized `InvalidationMessage` containing a unique `message_id`, `command`, `target`, `timestamp`, and other metadata.\n\n3.  **Message Broadcast:** The control plane publishes the `InvalidationMessage` to a specific **pub/sub channel** (e.g., `invalidation:global`) using the `InMemoryPubSubBroker.publish` method. All edge nodes that have previously subscribed to this channel via `InMemoryPubSubBroker.subscribe` will receive the message. This decouples the sender from the receivers and allows for scalable fan-out.\n\n4.  **Edge Node Reception:** Each edge node's `InvalidationHandler` has a registered callback that is invoked with the `InvalidationMessage`. The handler first may deduplicate messages using the `message_id` to avoid processing the same command multiple times (e.g., in case of network retries).\n\n5.  **Local Invalidation Execution:** The handler executes the command locally on its node's cache:\n    *   **For a URL Purge:** It generates the cache key for the given URL (considering `Vary` headers) and calls `_hard_purge_key` or `_soft_purge_key`.\n    *   **For a Tag Purge:** It calls `_purge_by_tag(tag, is_soft)`, which uses the local `SurrogateKeyIndex.get_keys_for_tag` to find all affected cache keys and purges them.\n    *   **For a Ban Rule:** It calls `add_ban_rule(pattern, is_soft, ttl_seconds)` to add the rule to the local list of `BanRule`s. Future requests matching the pattern will be invalidated (lazily, upon access).\n\n6.  **Acknowledgment (Optional):** In a more advanced implementation, edge nodes may send an acknowledgment message back to the control plane, allowing it to track propagation completeness. For our foundational design, we assume **best-effort, eventually consistent** propagation.\n\n7.  **Cleanup:** For ban rules, a background garbage collection task (`_gc_ban_rules`) periodically runs on each edge node to remove expired rules, preventing memory leaks.\n\n**Common Pitfalls in Invalidation Propagation:**\n\n⚠️ **Pitfall: Ignoring Propagation Delay**\n*   **Description:** Assuming that once a purge API call returns, the content is immediately invalidated worldwide.\n*   **Why it's Wrong:** Network latency, node failures, and message queue delays mean there is a window (seconds to minutes) where some edge nodes may still serve stale content. This violates consistency expectations.\n*   **Fix:** Design the system with **eventual consistency** in mind. Document this behavior. For stronger guarantees, implement synchronous purges to critical nodes or use versioned URLs (e.g., `/image.jpg?v=2`) to bypass caching entirely.\n\n⚠️ **Pitfall: Inefficient Tag-Based Purge on Large Indexes**\n*   **Description:** Iterating over all cache entries to find those matching a tag when the `SurrogateKeyIndex` is large can block the request thread and cause latency spikes.\n*   **Why it's Wrong:** A tag like \"homepage\" might be associated with thousands of entries (CSS, JS, images). Linearly scanning a list or performing many individual cache deletions is slow.\n*   **Fix:** Use the reverse index in `SurrogateKeyIndex` (`tag_to_keys`) for O(1) lookups of affected keys. Perform the actual cache evictions in a background thread to avoid blocking the purge API response.\n\n⚠️ **Pitfall: Ban Rule Explosion**\n*   **Description:** Continuously adding new ban rules (e.g., for every user-generated content update) without a TTL or cleanup mechanism.\n*   **Why it's Wrong:** The list of `BanRule` objects grows indefinitely, consuming memory and slowing down the `check_bans(url)` function which must evaluate every rule against every requested URL.\n*   **Fix:** Always attach a sensible TTL to programmatically added ban rules. Implement the `_gc_ban_rules` background task to regularly purge expired rules. For high-volume patterns, consider using a more scalable data structure like a Bloom filter for certain prefix-based bans (with the understanding of its probabilistic nature).\n\n### Implementation Guidance\n\nThis guidance provides the foundational code to connect the components and realize the data flows described above. Focus is on the glue logic and critical coordination structures.\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option (for Learning) | Advanced Option (for Production-readiness) |\n|-----------|-----------------------------|--------------------------------------------|\n| Inter-Component Messaging | In-memory Pub/Sub within a single process (for simulation) | Redis Pub/Sub or Apache Kafka for distributed, persistent messaging |\n| Request Collapsing | `asyncio.Future` and `asyncio.Lock` in Python | Dedicated library with support for timeouts, circuit breaking, and metrics (e.g., `aiocache` patterns) |\n| Health Checking & Discovery | Periodic HTTP `GET /health` polls from control plane | Gossip protocol (SWIM) for decentralized failure detection and membership |\n| Metrics Collection | In-memory counters flushed periodically to logs | OpenTelemetry SDK exporting to Prometheus or Grafana |\n\n**B. Recommended File/Module Structure**\nAdd the following files to manage the flow and interactions:\n```\nblue_origin_cdn/\n├── internal/\n│   ├── flow/\n│   │   ├── __init__.py\n│   │   ├── coordinator.py          # Control plane logic for message broadcasting\n│   │   └── sequences.py           # Integration tests for the data flows\n│   ├── messaging/\n│   │   ├── __init__.py\n│   │   ├── pubsub.py              # InMemoryPubSubBroker implementation\n│   │   └── message.py             # InvalidationMessage and other DTOs\n│   └── utils/\n│       └── timeouts.py            # Utility for managing timeouts in collapsing\n└── simulations/\n    ├── multi_edge_hit.py          # Script to simulate cache hit flow\n    ├── miss_with_shield.py        # Script to simulate miss/collapsing flow\n    └── global_purge.py            # Script to simulate invalidation propagation\n```\n\n**C. Infrastructure Starter Code**\n\n**1. In-Memory Pub/Sub Broker (`internal/messaging/pubsub.py`):**\nThis is a complete, thread-safe implementation for simulation and testing. In a real distributed CDN, this would be replaced with Redis or Kafka.\n```python\nimport asyncio\nfrom typing import Callable, Set, Dict, Any\nfrom dataclasses import dataclass\nimport time\nimport json\n\n@dataclass\nclass InvalidationMessage:\n    message_id: str\n    command: str  # \"purge\", \"soft_purge\", \"ban\", \"tag_purge\"\n    target: str   # URL, pattern, or tag\n    soft: bool\n    timestamp: float\n    parameters: Dict[str, Any]\n\nclass InMemoryPubSubBroker:\n    \"\"\"Simple in-memory publish-subscribe broker for simulation.\"\"\"\n    \n    def __init__(self):\n        self._subscribers: Dict[str, Set[Callable[[InvalidationMessage], None]]] = {}\n        self._lock = asyncio.Lock()\n    \n    async def subscribe(self, channel: str, callback: Callable[[InvalidationMessage], None]):\n        \"\"\"Subscribe a callback to a channel.\"\"\"\n        async with self._lock:\n            if channel not in self._subscribers:\n                self._subscribers[channel] = set()\n            self._subscribers[channel].add(callback)\n    \n    async def unsubscribe(self, channel: str, callback: Callable[[InvalidationMessage], None]):\n        \"\"\"Unsubscribe a callback from a channel.\"\"\"\n        async with self._lock:\n            if channel in self._subscribers:\n                self._subscribers[channel].discard(callback)\n                if not self._subscribers[channel]:\n                    del self._subscribers[channel]\n    \n    async def publish(self, channel: str, message: InvalidationMessage):\n        \"\"\"Publish a message to all subscribers of a channel.\"\"\"\n        async with self._lock:\n            subscribers = self._subscribers.get(channel, set()).copy()\n        \n        # Call each subscriber in the background (fire-and-forget)\n        for callback in subscribers:\n            # In a real system, you might want to handle exceptions\n            asyncio.create_task(self._safe_callback(callback, message))\n    \n    async def _safe_callback(self, callback, message):\n        \"\"\"Wrapper to catch and log exceptions in subscriber callbacks.\"\"\"\n        try:\n            await callback(message)\n        except Exception as e:\n            print(f\"Error in pub/sub callback: {e}\")\n```\n\n**2. Request Coalescing Map with Timeout (`internal/flow/coordinator.py`):**\nThis is a critical piece for the origin shield. It manages the futures for collapsing.\n```python\nimport asyncio\nfrom typing import Dict, Optional\nimport time\n\nclass RequestCoalescingMap:\n    \"\"\"\n    Tracks in-flight requests by cache key to enable request collapsing.\n    \"\"\"\n    \n    def __init__(self, default_timeout: float = 3.0, cleanup_interval: float = 30.0):\n        self._futures: Dict[str, asyncio.Future] = {}\n        self._timeouts: Dict[str, float] = {}  # key -> creation time\n        self._default_timeout = default_timeout\n        self._lock = asyncio.Lock()\n        self._gc_task: Optional[asyncio.Task] = None\n        self._start_gc_loop(cleanup_interval)\n    \n    def _start_gc_loop(self, interval: float):\n        \"\"\"Start background garbage collection loop.\"\"\"\n        async def gc_loop():\n            while True:\n                await asyncio.sleep(interval)\n                await self._gc_loop(interval)\n        \n        self._gc_task = asyncio.create_task(gc_loop())\n    \n    async def get_or_create_future(self, cache_key: str) -> asyncio.Future:\n        \"\"\"\n        Get existing Future for key or create a new one.\n        Returns a Future that will resolve to the (status, headers, body) tuple.\n        \"\"\"\n        async with self._lock:\n            if cache_key in self._futures:\n                return self._futures[cache_key]\n            \n            # Create new future\n            future = asyncio.Future()\n            self._futures[cache_key] = future\n            self._timeouts[cache_key] = time.time()\n            return future\n    \n    async def fulfill_future(self, cache_key: str, result: tuple):\n        \"\"\"Set result for Future associated with key and clean up.\"\"\"\n        async with self._lock:\n            future = self._futures.pop(cache_key, None)\n            self._timeouts.pop(cache_key, None)\n        \n        if future and not future.done():\n            future.set_result(result)\n    \n    async def fail_future(self, cache_key: str, exception: Exception):\n        \"\"\"Set exception for Future associated with key and clean up.\"\"\"\n        async with self._lock:\n            future = self._futures.pop(cache_key, None)\n            self._timeouts.pop(cache_key, None)\n        \n        if future and not future.done():\n            future.set_exception(exception)\n    \n    async def _gc_loop(self, interval: float):\n        \"\"\"Background cleanup of timed-out entries.\"\"\"\n        now = time.time()\n        to_remove = []\n        \n        async with self._lock:\n            for key, created_at in self._timeouts.items():\n                if now - created_at > self._default_timeout:\n                    to_remove.append(key)\n            \n            for key in to_remove:\n                future = self._futures.pop(key, None)\n                self._timeouts.pop(key, None)\n                if future and not future.done():\n                    future.set_exception(asyncio.TimeoutError(f\"Request coalescing timeout for {key}\"))\n    \n    async def stop(self):\n        \"\"\"Stop the garbage collection loop.\"\"\"\n        if self._gc_task:\n            self._gc_task.cancel()\n            try:\n                await self._gc_task\n            except asyncio.CancelledError:\n                pass\n```\n\n**D. Core Logic Skeleton Code**\n\n**1. Shield Request Handler with Collapsing (`internal/shield/handler.py`):**\n```python\nimport asyncio\nfrom typing import Tuple, Dict\nfrom ..cache.storage import CacheStorage\nfrom ..flow.coordinator import RequestCoalescingMap\n\nclass ShieldRequestHandler:\n    \"\"\"\n    Handles requests at the origin shield layer with request collapsing.\n    \"\"\"\n    \n    def __init__(self, cache: CacheStorage, origin_upstream: str, \n                 coalescing_map: RequestCoalescingMap, max_concurrent_requests: int = 10):\n        self.cache = cache\n        self.origin_upstream = origin_upstream\n        self.coalescing_map = coalescing_map\n        self._origin_semaphore = asyncio.Semaphore(max_concurrent_requests)\n    \n    async def handle_request(self, request_headers: Dict[str, str], \n                           request_body: bytes) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"\n        Main request handling algorithm for the shield.\n        Steps:\n        1. Generate cache key from URL and Vary headers.\n        2. Check local cache; if fresh, serve and return.\n        3. If stale but revalidatable, serve stale and start background revalidation.\n        4. On miss, use request collapsing map to deduplicate concurrent requests.\n        5. Acquire semaphore to limit origin concurrency.\n        6. Fetch from origin.\n        7. Cache the response (including negative caching for errors).\n        8. Fulfill the future in the coalescing map.\n        9. Return response.\n        \"\"\"\n        # TODO 1: Parse request method, URL, and headers from request_headers\n        # TODO 2: Generate a cache key using URL and Vary header dimensions\n        # TODO 3: Check local cache storage for the key\n        # TODO 4: If cache hit and fresh, return cached response immediately\n        # TODO 5: If cache hit but stale, check if stale-while-revalidate applies\n        #         - If yes, serve stale and call _revalidate_in_background\n        # TODO 6: On cache miss, call self.coalescing_map.get_or_create_future(key)\n        # TODO 7: If the returned future is already done (another request filled it), return its result\n        # TODO 8: If this is the first request (future not done), proceed to fetch from origin:\n        #         a. Acquire self._origin_semaphore\n        #         b. Make HTTP request to self.origin_upstream\n        #         c. Parse response status, headers, body\n        #         d. Determine if response is cacheable\n        #         e. If cacheable, store in self.cache\n        #         f. Call self.coalescing_map.fulfill_future(key, (status, headers, body))\n        #         g. Return the response\n        # TODO 9: Implement proper exception handling:\n        #         - On origin timeout/error, call self.coalescing_map.fail_future\n        #         - Consider negative caching for 404/5xx errors with short TTL\n        pass\n    \n    async def _revalidate_in_background(self, cache_key: str, stale_entry, request_headers: Dict[str, str]):\n        \"\"\"\n        Asynchronously revalidate a stale cache entry.\n        Should update the cache if the origin returns 200, or delete it if 304.\n        \"\"\"\n        # TODO 1: Make a conditional request to origin with If-None-Match/If-Modified-Since\n        # TODO 2: If origin returns 200 OK, replace stale_entry in cache with new response\n        # TODO 3: If origin returns 304 Not Modified, update stale_entry's expires_at/metadata\n        # TODO 4: Log errors but don't propagate (this is background)\n        pass\n```\n\n**2. Control Plane Invalidation Endpoint (`internal/control/api.py`):**\n```python\nfrom fastapi import FastAPI, HTTPException, BackgroundTasks\nfrom ..messaging.pubsub import InMemoryPubSubBroker, InvalidationMessage\nimport uuid\nimport time\n\napp = FastAPI()\nbroker = InMemoryPubSubBroker()\n\n@app.post(\"/invalidate/purge\")\nasync def purge_url(url: str, soft: bool = False, background_tasks: BackgroundTasks = None):\n    \"\"\"\n    Admin API to purge a specific URL from all edge caches.\n    \"\"\"\n    # TODO 1: Validate admin authentication/authorization (basic implementation could use API key)\n    # TODO 2: Create an InvalidationMessage with command=\"purge\", target=url, soft=soft\n    message = InvalidationMessage(\n        message_id=str(uuid.uuid4()),\n        command=\"soft_purge\" if soft else \"purge\",\n        target=url,\n        soft=soft,\n        timestamp=time.time(),\n        parameters={\"reason\": \"manual_api_call\"}\n    )\n    \n    # TODO 3: Publish the message to the global invalidation channel\n    # Use background task to avoid blocking the API response\n    background_tasks.add_task(broker.publish, \"invalidation:global\", message)\n    \n    return {\"status\": \"accepted\", \"message_id\": message.message_id}\n\n@app.post(\"/invalidate/tag\")\nasync def purge_tag(tag: str, soft: bool = False, background_tasks: BackgroundTasks = None):\n    \"\"\"\n    Admin API to purge all resources with a given surrogate key tag.\n    \"\"\"\n    # TODO 1: Validate input (tag format)\n    # TODO 2: Create InvalidationMessage with command=\"tag_purge\"\n    # TODO 3: Publish to broker\n    pass\n\n@app.post(\"/invalidate/ban\")\nasync def add_ban_rule(pattern: str, ttl_seconds: int = 3600, \n                       soft: bool = False, background_tasks: BackgroundTasks = None):\n    \"\"\"\n    Admin API to add a new ban rule.\n    \"\"\"\n    # TODO 1: Validate pattern (e.g., check for reasonable length, prevent injection)\n    # TODO 2: Create InvalidationMessage with command=\"ban\"\n    # TODO 3: Include ttl_seconds in parameters\n    # TODO 4: Publish to broker\n    pass\n```\n\n**E. Language-Specific Hints (Python)**\n- **Use `asyncio` for Concurrency:** The request collapsing and background revalidation are natural fits for async/await. Use `asyncio.create_task()` for fire-and-forget background operations.\n- **Type Hints:** Use Python type hints extensively for the data structures defined in the naming conventions. This will catch many errors early and serve as documentation.\n- **Testing Async Code:** Use `pytest-asyncio` for testing async components. Mock the `CacheStorage` and origin HTTP calls to simulate different flow scenarios.\n- **Configuration Management:** Use Pydantic models for `EdgeConfig` to get validation and type-safe access to configuration values loaded from YAML or environment variables.\n\n**F. Milestone Checkpoint: Flow Integration**\nAfter implementing the core components, test the integrated flows:\n\n1. **Cache Hit Flow Test:**\n   ```bash\n   # Start a mock origin server (serves static files)\n   python tests/mock_origin.py --port 8001\n   \n   # Start an edge node pointing to the origin\n   python -m blue_origin_cdn.edge --config config/edge_local.yaml\n   \n   # Make a request, then make it again (should hit)\n   curl -v http://localhost:8080/image.jpg\n   curl -v http://localhost:8080/image.jpg  # Check Age header increases\n   ```\n   **Expected:** First request logs `[MISS]`, second logs `[HIT]`. The `Age` header in the second response should be >0.\n\n2. **Cache Miss with Shield Test:**\n   ```bash\n   # Start shield pointing to origin\n   python -m blue_origin_cdn.shield --config config/shield_local.yaml\n   \n   # Start edge pointing to shield (not directly to origin)\n   # Update edge config upstream_url to shield address\n   \n   # Use Apache Bench to simulate concurrent requests\n   ab -n 100 -c 10 http://localhost:8080/new_image.jpg\n   ```\n   **Expected:** Shield logs should show `[COLLAPSED]` messages. Origin server logs should show only 1 request for `new_image.jpg`, not 100.\n\n3. **Global Invalidation Test:**\n   ```bash\n   # Start two edge nodes and one control plane\n   python -m blue_origin_cdn.control_plane &\n   python -m blue_origin_cdn.edge --config config/edge_node1.yaml &\n   python -m blue_origin_cdn.edge --config config/edge_node2.yaml &\n   \n   # Populate cache on both edges\n   curl http://node1:8080/image.jpg\n   curl http://node2:8080/image.jpg\n   \n   # Send purge command via control plane API\n   curl -X POST http://control-plane:9000/invalidate/purge?url=/image.jpg\n   \n   # Request again - should miss on both nodes\n   curl -v http://node1:8080/image.jpg\n   curl -v http://node2:8080/image.jpg\n   ```\n   **Expected:** After purge, both edges should log `[MISS]` and fetch fresh content from upstream. Check control plane logs for message broadcast.\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** Milestone 1 (Edge Cache Implementation), Milestone 2 (Cache Invalidation), Milestone 3 (Origin Shield & Request Collapsing), Milestone 4 (Edge Node Distribution & Routing), Milestone 5 (CDN Analytics & Performance Optimization)\n\nThe true test of a CDN's architectural soundness isn't how it performs under ideal conditions, but how it degrades when components fail and how it handles the messy reality of HTTP traffic. This section systematically documents failure modes, recovery strategies, and edge case handling—transforming the CDN from a fragile prototype into a robust production-ready system.\n\n### Failure Modes & Recovery Strategies\n\n#### Mental Model: The Redundant Bridge System\n\nImagine a network of bridges connecting islands. The primary bridge (origin) sometimes collapses, detour bridges (edge nodes) can become congested, and storms (network partitions) can isolate entire islands. A resilient transportation system has redundant routes, detour signs, and temporary shelters. Our CDN employs similar strategies: when the origin fails, we serve stale content from shelters (cache); when edges fail, we redirect traffic via detours (failover); when storms isolate nodes, they operate independently until reconnected (degraded mode).\n\n#### Catalog of Failure Modes and Recovery Strategies\n\nThe CDN must handle failures at multiple levels while maintaining some level of service. The following table documents each failure mode, its detection mechanism, and the corresponding recovery strategy.\n\n| Failure Mode | Detection Method | Recovery Strategy | Impact on Clients | Implementation Notes |\n|--------------|------------------|-------------------|-------------------|----------------------|\n| **Origin Server Unavailable** | HTTP request timeout (5s) or status code 5xx from origin | Serve stale content using `stale-if-error` directive; if no stale content available, return 502 Bad Gateway | Temporary degradation: clients may see older content or error pages | Monitor `origin_errors` in `ShieldMetrics`; implement exponential backoff for retries |\n| **Edge Node Failure** | Health checks failing (TCP connect timeout, HTTP 5xx on `/health`) | Geo-routing redirects clients to next-nearest healthy edge node within failover timeout | Brief interruption (<5s) during failover, then normal service | Update consistent hash ring to redistribute keys from failed node |\n| **Network Partition (Edge ↔ Origin)** | Repeated timeouts when contacting upstream | Edge nodes operate in \"degraded mode\": serve stale content exclusively, disable cache updates | Clients see potentially outdated content until partition heals | Implement circuit breaker pattern for upstream connections |\n| **Network Partition (Edge ↔ Control Plane)** | Heartbeat timeout with control plane | Edge nodes continue serving traffic with local configuration; invalidation commands queue locally | Cache may become stale (eventual consistency issues) | Buffer invalidation messages in local queue for eventual sync |\n| **Cache Storage Exhaustion** | `current_cache_size_bytes` approaches `cache_capacity_bytes` | LRU/LFU eviction removes least valuable entries; log warnings; optionally compress existing entries | Slight increase in cache misses for evicted content | Monitor `current_cache_size_bytes` in `EdgeMetrics`; implement compression for text responses |\n| **Disk I/O Errors (if persistent cache)** | Failed read/write operations with errno | Fall back to in-memory cache only; log critical error; alert operator | Reduced cache capacity, increased origin load | Use `try/except` around all filesystem operations; implement graceful degradation |\n| **Memory Exhaustion** | `MemoryError` exceptions or OOM killer | Reject new cache entries while serving existing ones; aggressively evict old entries | Increased cache misses, potential 503 errors for new content | Monitor memory usage via `HealthMetrics`; implement soft limits |\n| **DNS Resolution Failure** | `socket.gaierror` when resolving upstream hostnames | Use cached DNS results with TTL; fall back to backup origin IPs if configured | Service interruption if no cached resolution available | Implement DNS caching with TTL validation; pre-resolve critical hostnames |\n| **SSL/TLS Handshake Failure** | `ssl.SSLError` during upstream connection | Attempt plain HTTP if origin supports it (configurable); otherwise fail with 502 | Potential security downgrade or service interruption | Implement TLS version fallback; maintain certificate cache |\n| **Clock Skew Between Nodes** | Comparison of timestamps in invalidation messages | Use logical clocks (Lamport timestamps) for invalidation ordering; NTP synchronization required | Potential cache inconsistency if skew > TTL window | Include logical timestamp in `InvalidationMessage`; implement NTP client |\n\n**Design Principle:** *Graceful degradation beats catastrophic failure.* The system should never completely stop serving traffic unless absolutely necessary. Each failure mode has a defined fallback that maintains some level of service.\n\n#### ADR: Stale Content Serving Strategy\n\n> **Decision: Serve Stale Content with `stale-if-error` During Origin Failures**\n> - **Context**: When the origin server becomes unavailable, the CDN faces a choice: return errors (502/504) or serve potentially outdated content from cache. Returning errors provides accuracy but poor user experience during origin outages.\n> - **Options Considered**:\n>   1. **Always return 502/504**: Strict correctness but poor availability during origin failures\n>   2. **Serve stale content indefinitely**: High availability but potentially serving very outdated content\n>   3. **Serve stale content with `stale-if-error` and time limits**: Balanced approach with configurable staleness windows\n> - **Decision**: Implement `stale-if-error` semantics per RFC 9111, with configurable maximum staleness (default: 1 hour).\n> - **Rationale**: The `stale-if-error` extension is standard HTTP semantics that clients understand. It provides availability during temporary origin issues while bounding how stale content can become. This aligns with CDN industry practices where serving slightly stale content is preferable to complete unavailability.\n> - **Consequences**: Clients may receive outdated content during origin failures, but the system remains available. Operators must monitor staleness duration and set appropriate limits based on content volatility.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Always return 502/504 | Strictly correct behavior, no stale content | Poor availability during origin outages | No |\n| Serve stale indefinitely | Maximum availability | May serve very outdated content without bound | No |\n| **Serve with `stale-if-error` and limits** | **Balances availability and freshness, standard-compliant** | **Adds complexity to cache freshness logic** | **Yes** |\n\n#### Implementation of Failure Recovery\n\nThe recovery strategies translate to concrete implementation patterns:\n\n1. **Circuit Breaker for Upstream Connections**: Implement the circuit breaker pattern to prevent cascading failures when the origin is unhealthy. After a threshold of failures, the circuit opens and all requests immediately fail fast to stale cache, periodically allowing a test request to check if the origin has recovered.\n\n2. **Health-Based Routing Fallback**: When the primary edge node is unhealthy, the geo-routing system should redirect to the next-nearest node. This requires maintaining a sorted list of backup nodes per region and implementing fast health check propagation.\n\n3. **Degraded Mode Flag**: Each edge node should maintain a `degraded_mode` boolean that gets set when critical dependencies (origin, control plane) are unavailable. In degraded mode, the node:\n   - Serves stale content regardless of freshness\n   - Logs all cache misses (but doesn't attempt to fetch from origin)\n   - Returns custom `X-CDN-Degraded: true` header\n   - Periodically attempts to reconnect to dependencies\n\n4. **Request Queue Management During Failover**: When an edge node fails, the consistent hashing ring redistributes its keys to other nodes. These nodes may experience a \"cold start\" problem with empty caches. Implement request queuing and rate limiting to prevent thundering herd on the origin during redistribution.\n\n### HTTP Edge Cases\n\n#### Mental Model: The Quirky Mailroom Clerk\n\nImagine a mailroom clerk who must handle every possible mailing scenario: packages with contradictory instructions (Vary: *), massive crates that need partial delivery (range requests), and envelopes with unreadable postmarks (malformed headers). A good clerk has procedures for each edge case—knowing when to reject, when to improvise, and when to consult the rulebook. Our CDN edge cache acts as this clerk, implementing specific logic for HTTP's corner cases.\n\n#### Handling Complex HTTP Caching Scenarios\n\n| HTTP Edge Case | Standard Behavior | CDN Implementation | Rationale |\n|----------------|-------------------|-------------------|-----------|\n| **`Vary: *` Header** | Per RFC 9111, means \"never cache\" because the response varies on all request headers | Check for `Vary: *` in response; if present, do not store in cache and bypass cache for future requests | Prevents cache key explosion and ensures correct content negotiation |\n| **`Cache-Control: no-store`** | Response must not be stored in any cache | Respect directive: do not store response in cache; existing entries must be invalidated | Privacy/security requirement; override any other caching directives |\n| **`Cache-Control: private`** | Response is intended for a single user and must not be stored in shared caches | CDN as shared cache must not store; edge caches skip storage, but shield may still cache if configured | Respects user privacy while allowing some optimization |\n| **Malformed `Cache-Control` Header** | Invalid syntax (e.g., `max-age=not-a-number`) | Parse leniently: ignore malformed directives, log warning, use defaults (or `max-age=0` if uncertain) | Robustness over strictness; better to cache with short TTL than break |\n| **Conflicting Directives** (e.g., `max-age=3600` and `no-cache`) | `no-cache` takes precedence for validation, but `max-age` still sets freshness lifetime | Implement precedence hierarchy: `no-store` > `no-cache` > `private` > `s-maxage` > `max-age` > default | Follows RFC 9111 Section 5.2.2 directive precedence |\n| **Multiple `Cache-Control` Headers** | Headers should be concatenated with commas | Use `get_header_values()` to collect all values, then parse combined string | Handles HTTP/1.x and HTTP/2 differences in header serialization |\n| **`Expires` in the Past** | Resource is already stale when received | Treat as `max-age=0`, requiring immediate revalidation | Prevents serving already-expired content |\n| **`ETag` with `W/` Prefix (Weak Validator)** | Allows semantic equivalence (e.g., reformatted HTML) | Support weak validation: match weak ETags only with `If-None-Match`, not with `If-Match` | Enables more efficient caching when content changes insignificantly |\n| **`Vary` with Multiple Headers** (e.g., `Vary: Accept-Encoding, User-Agent`) | Response varies on all listed headers | Include all specified header values in cache key; store separate entry for each combination | Correctly handles multi-dimensional content negotiation |\n| **`Accept-Encoding` with `identity` or `*`** | Client accepts any encoding, including none | Normalize: treat `*` as `identity`; include normalized encoding in cache key | Prevents cache fragmentation from semantically equivalent headers |\n| **Range Requests (`Range: bytes=0-499`)** | Request for partial content; requires `206 Partial Content` response | Check cache for full response; if present, extract range and return 206; otherwise fetch range or full from origin | Supports video streaming and large file downloads efficiently |\n| **`If-Range` Conditional Range Requests** | Continue interrupted downloads if unchanged | If ETag/Last-Modified matches, serve requested range; otherwise serve full entity | Optimizes recovery from interrupted downloads |\n| **`POST` to Cacheable URL** | POST generally invalidates cached GET to same URL | Invalidate cache entry for the URL on successful POST (status 2xx/3xx) | Maintains cache consistency when content is modified |\n| **`PUT`/`DELETE` to Cached URL** | Modifies or removes resource | Invalidate cache entry for the URL | Ensures cache reflects resource state changes |\n| **Responses Exceeding Cache Size Limit** | Too large to store given capacity constraints | Stream response to client without caching; log warning; increment `too_large_to_cache` metric | Prevents single large response from evicting many small ones |\n| **Chunked Transfer Encoding** | Response body delivered in chunks | Reassemble complete body before caching; stream chunks to client immediately | Cache stores complete entities, not transfer encoding state |\n| **`304 Not Modified` Responses** | Conditional request found resource unchanged | Update freshness of existing cache entry without replacing body; update headers from 304 response | Optimizes bandwidth by avoiding body retransmission |\n| **`206 Partial Content` from Origin** | Origin supports range requests natively | Cache full response if possible; otherwise cache partial response marked as incomplete | Future range requests may need full response for other ranges |\n\n#### ADR: Handling Vary: * - To Cache or Not to Cache\n\n> **Decision: Never Cache Responses with `Vary: *`**\n> - **Context**: The `Vary: *` header indicates the response varies on all possible request headers. This creates a cache key explosion problem since every request is essentially unique.\n> - **Options Considered**:\n>   1. **Cache with URL-only key**: Ignore the `Vary: *` and cache based only on URL (incorrect, violates spec)\n>   2. **Cache with all headers as key**: Include all request headers in cache key (theoretically correct but impractical)\n>   3. **Do not cache at all**: Treat `Vary: *` as \"never cache\" as suggested by RFC 9111\n> - **Decision**: Implement \"never cache\" behavior for `Vary: *` responses.\n> - **Rationale**: RFC 9111 Section 4.1 suggests that `Vary: *` \"always fails to match\" subsequent requests, implying it should not be stored. Practical implementations (Varnish, NGINX) treat it as uncacheable. The alternative of including all headers would make the cache effectively useless due to key explosion.\n> - **Consequences**: Some dynamic content that could theoretically be cached (if we ignored certain headers) won't be cached. This is an acceptable trade-off for correctness and simplicity.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Cache with URL-only key | Would cache some dynamic content | Violates HTTP spec, serves wrong content to clients with different headers | No |\n| Cache with all headers as key | Theoretically correct | Cache key explosion makes caching ineffective; high memory overhead | No |\n| **Do not cache at all** | **Spec-compliant, simple to implement** | **Misses caching opportunities for some content** | **Yes** |\n\n#### Range Request Implementation Details\n\nRange requests present particular challenges for caching. The CDN must handle:\n\n1. **Cache Storage for Range Requests**: When a range request misses the cache but the origin returns a `206 Partial Content`, we have two options:\n   - Store the partial response separately\n   - Fetch the entire resource and cache it, then extract the range\n\n   The recommended approach is to attempt to fetch the full resource (using `Range: bytes=0-` or no Range header) when cache storage is desirable. If the origin only supports range requests, we can cache partial responses with metadata indicating which ranges are available.\n\n2. **Range Combining**: If multiple concurrent requests ask for different ranges of the same resource, the CDN should combine them into a single origin request for the full resource (or a superset range) to optimize bandwidth.\n\n3. **Range Validation**: When serving a cached response to a range request, validate that the requested range is within the cached entity length. If not, either fetch the needed range from origin or return `416 Range Not Satisfiable`.\n\n**Algorithm for Handling Range Requests:**\n1. Parse `Range` header using `range-units` syntax (only `bytes` unit required)\n2. Generate cache key including range information (or use full resource key)\n3. Check cache for matching entry:\n   - If full entity cached and fresh: extract range, return `206`\n   - If partial entity cached containing requested range: serve from cache\n   - Otherwise: proceed to origin\n4. Forward to origin with appropriate `Range` header\n5. On `206` response: cache full entity if possible, otherwise cache partial with range metadata\n6. On `200` response (origin doesn't support ranges): cache full entity, extract requested range for response\n7. Always set `Content-Range` and `Accept-Ranges: bytes` headers in response\n\n#### Common Pitfalls in Error Handling\n\n⚠️ **Pitfall: Silent Degradation to Stale Content Indefinitely**\n- **Description**: When the origin fails, serving stale content via `stale-if-error` without time limits.\n- **Why it's wrong**: Users may see hours-old content without knowing, violating content freshness expectations.\n- **Fix**: Implement maximum staleness window (e.g., 1 hour) and add `X-CDN-Stale: true` header to responses.\n\n⚠️ **Pitfall: Cache Poisoning via Malformed Headers**\n- **Description**: Accepting malformed `Cache-Control` headers without validation leads to incorrect caching decisions.\n- **Why it's wrong**: `max-age=999999999` (overflow) could cache content for decades; `no-cache=` (missing value) might be misinterpreted.\n- **Fix**: Validate directive values: clamp `max-age`/`s-maxage` to reasonable maximum (e.g., 1 year), treat malformed directives as `max-age=0`.\n\n⚠️ **Pitfall: Range Request Cache Fragmentation**\n- **Description**: Storing each requested range as separate cache entry wastes memory and causes redundancy.\n- **Why it's wrong**: Requests for `bytes=0-999` and `bytes=1000-1999` of same file create two cache entries storing overlapping data.\n- **Fix**: Prefer caching full entities; for partial-only origins, implement range metadata tracking and combine overlapping ranges.\n\n⚠️ **Pitfall: Thundering Herd on Health Check Failover**\n- **Description**: When an edge node fails, all clients simultaneously reconnect to the next-nearest node, overwhelming it.\n- **Why it's wrong**: The backup node experiences sudden load spike, potentially causing cascade failure.\n- **Fix**: Implement staggered failover using DNS TTLs, client-side randomization, or anycast with BGP dampening.\n\n⚠️ **Pitfall: Ignoring Clock Skew in Expiration**\n- **Description**: Using local system time for TTL calculations without considering time synchronization.\n- **Why it's wrong**: Nodes with skewed clocks expire content at different times, causing inconsistency.\n- **Fix**: Use NTP-synchronized clocks; for critical timing, use relative durations from receipt time rather than absolute expiry.\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Circuit Breaker | Manual failure counting with timeout | `aiocircuitbreaker` library with multiple strategies |\n| Health Checking | Periodic HTTP GET to `/health` endpoint | Active health checks + passive monitoring + weighted scoring |\n| Range Request Handling | Simple byte range slicing of cached bodies | Multipart range support with `boundary` parsing |\n| Stale Content Serving | Basic `stale-if-error` with fixed window | Dynamic staleness based on content type and historical patterns |\n| Error Monitoring | Logging to stdout/stderr | Structured logging with metrics export to Prometheus |\n\n#### Recommended File/Module Structure\n\n```\nblue_origin_cdn/\n├── src/\n│   ├── error_handling/\n│   │   ├── __init__.py\n│   │   ├── circuit_breaker.py          # Circuit breaker implementation\n│   │   ├── degraded_mode.py            # Degraded mode flag and logic\n│   │   ├── stale_content_handler.py    # stale-if-error logic\n│   │   └── health_checker.py           # Health checking utilities\n│   ├── http_edge_cases/\n│   │   ├── __init__.py\n│   │   ├── range_request.py           # Range request handler\n│   │   ├── vary_header.py             # Vary header processor\n│   │   ├── cache_control_parser.py    # Robust Cache-Control parser\n│   │   └── etag_handler.py            # ETag weak/strong validation\n│   └── failure_recovery/\n│       ├── __init__.py\n│       ├── failover_manager.py        # Geo-routing failover logic\n│       ├── request_queuing.py         # Request queue for cold starts\n│       └── partition_handler.py       # Network partition detection\n└── tests/\n    ├── test_error_handling.py\n    ├── test_http_edge_cases.py\n    └── test_failure_recovery.py\n```\n\n#### Infrastructure Starter Code: Circuit Breaker Implementation\n\n```python\n\"\"\"\nCircuit breaker pattern implementation for upstream connections.\n\"\"\"\n\nimport time\nimport asyncio\nfrom enum import Enum\nfrom typing import Optional, Callable, Any\nfrom dataclasses import dataclass\n\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"      # Normal operation: requests pass through\n    OPEN = \"open\"          # Circuit open: requests fail fast\n    HALF_OPEN = \"half_open\"  # Testing if service has recovered\n\n\n@dataclass\nclass CircuitBreakerConfig:\n    failure_threshold: int = 5           # Failures needed to open circuit\n    reset_timeout: float = 30.0          # Time in seconds before attempting recovery\n    half_open_max_requests: int = 3      # Max requests allowed in half-open state\n    half_open_success_threshold: int = 2 # Successes needed to close circuit\n    max_failure_history: int = 100       # Max failures to track for statistics\n\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for upstream service calls.\"\"\"\n    \n    def __init__(self, name: str, config: Optional[CircuitBreakerConfig] = None):\n        self.name = name\n        self.config = config or CircuitBreakerConfig()\n        self.state = CircuitState.CLOSED\n        self.failure_count = 0\n        self.success_count = 0\n        self.last_failure_time: Optional[float] = None\n        self._lock = asyncio.Lock()\n        \n    async def execute(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"Execute function with circuit breaker protection.\"\"\"\n        \n        # Check if circuit is open\n        if self.state == CircuitState.OPEN:\n            # Check if reset timeout has elapsed\n            if (self.last_failure_time and \n                time.time() - self.last_failure_time > self.config.reset_timeout):\n                async with self._lock:\n                    self.state = CircuitState.HALF_OPEN\n                    self.success_count = 0\n            else:\n                raise CircuitOpenError(f\"Circuit '{self.name}' is OPEN\")\n        \n        # Execute the function\n        try:\n            result = await func(*args, **kwargs)\n            await self._record_success()\n            return result\n        except Exception as e:\n            await self._record_failure()\n            raise\n    \n    async def _record_success(self) -> None:\n        \"\"\"Record a successful execution.\"\"\"\n        async with self._lock:\n            if self.state == CircuitState.HALF_OPEN:\n                self.success_count += 1\n                if self.success_count >= self.config.half_open_success_threshold:\n                    self.state = CircuitState.CLOSED\n                    self.failure_count = 0\n            else:\n                # In CLOSED state, reset failure count on consecutive successes\n                self.failure_count = max(0, self.failure_count - 1)\n    \n    async def _record_failure(self) -> None:\n        \"\"\"Record a failed execution.\"\"\"\n        async with self._lock:\n            self.failure_count += 1\n            self.last_failure_time = time.time()\n            \n            if self.state == CircuitState.HALF_OPEN:\n                # Failure in half-open state: re-open circuit\n                self.state = CircuitState.OPEN\n                self.success_count = 0\n            elif (self.state == CircuitState.CLOSED and \n                  self.failure_count >= self.config.failure_threshold):\n                # Too many failures in closed state: open circuit\n                self.state = CircuitState.OPEN\n    \n    def get_status(self) -> dict:\n        \"\"\"Return current circuit status for monitoring.\"\"\"\n        return {\n            \"name\": self.name,\n            \"state\": self.state.value,\n            \"failure_count\": self.failure_count,\n            \"success_count\": self.success_count,\n            \"last_failure_time\": self.last_failure_time,\n            \"is_open\": self.state == CircuitState.OPEN,\n        }\n\n\nclass CircuitOpenError(Exception):\n    \"\"\"Raised when circuit breaker is open and request is rejected.\"\"\"\n    pass\n```\n\n#### Core Logic Skeleton: Range Request Handler\n\n```python\n\"\"\"\nHTTP range request handler for CDN edge cache.\n\"\"\"\n\nimport re\nfrom typing import Optional, Tuple, List\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass ByteRange:\n    \"\"\"Represents a byte range request.\"\"\"\n    start: int\n    end: Optional[int]  # None means \"to end of resource\"\n    \n    @property\n    def length(self) -> Optional[int]:\n        \"\"\"Calculate length of range if end is specified.\"\"\"\n        if self.end is None:\n            return None\n        return self.end - self.start + 1\n    \n    def within(self, content_length: int) -> bool:\n        \"\"\"Check if range is within content bounds.\"\"\"\n        if self.start >= content_length:\n            return False\n        if self.end is not None and self.end >= content_length:\n            return False\n        return True\n\n\nclass RangeRequestHandler:\n    \"\"\"Handles HTTP Range and If-Range headers.\"\"\"\n    \n    # Regex for bytes range specifier: bytes=start-end\n    BYTES_RANGE_RE = re.compile(r'bytes=(\\d+)-(\\d*)')\n    \n    def __init__(self, cache_storage):\n        self.cache = cache_storage\n    \n    def parse_range_header(self, range_header: str, \n                          content_length: int) -> List[ByteRange]:\n        \"\"\"\n        Parse Range header value into list of ByteRange objects.\n        \n        Args:\n            range_header: Value of Range header (e.g., \"bytes=0-499\")\n            content_length: Total length of the resource in bytes\n            \n        Returns:\n            List of valid ByteRange objects\n        \"\"\"\n        ranges = []\n        \n        # Handle single range: bytes=start-end\n        match = self.BYTES_RANGE_RE.match(range_header)\n        if match:\n            start_str, end_str = match.groups()\n            start = int(start_str)\n            end = int(end_str) if end_str else None\n            \n            # Validate range\n            if end is not None and end < start:\n                # Invalid range: end before start\n                return []\n            \n            # Adjust \"to end of resource\" syntax\n            if end is None:\n                # bytes=start- means from start to end\n                if start < content_length:\n                    ranges.append(ByteRange(start, None))\n            else:\n                # bytes=start-end\n                if start < content_length and end < content_length:\n                    ranges.append(ByteRange(start, end))\n        \n        # TODO: Support multiple ranges: bytes=0-499,1000-1499\n        # TODO: Support suffix ranges: bytes=-500 (last 500 bytes)\n        \n        return ranges\n    \n    async def handle_range_request(self, request_headers: dict, \n                                 request_body: bytes,\n                                 cache_key: str) -> Tuple[int, dict, bytes]:\n        \"\"\"\n        Handle HTTP request with Range header.\n        \n        Args:\n            request_headers: Client request headers\n            request_body: Client request body\n            cache_key: Cache key for this resource\n            \n        Returns:\n            Tuple of (status_code, headers, body)\n        \"\"\"\n        range_header = request_headers.get('range')\n        if_range_header = request_headers.get('if-range')\n        \n        # TODO 1: Check cache for full entity using cache_key\n        # TODO 2: If full entity cached and fresh:\n        #   - Parse range_header to get requested byte ranges\n        #   - Extract ranges from cached body\n        #   - If single range: return 206 with Content-Range\n        #   - If multiple ranges: return 206 with multipart/byteranges\n        # TODO 3: If full entity cached but stale, check If-Range header\n        #   - If If-Range ETag/date matches: serve range from stale content\n        #   - Otherwise: revalidate with origin\n        # TODO 4: If cache miss or partial entity only:\n        #   - Forward request to upstream with Range header\n        #   - On 206 response: cache if possible (prefer full entity)\n        #   - On 200 response: cache full entity, extract range for response\n        # TODO 5: Handle edge cases:\n        #   - Range not satisfiable (416)\n        #   - Malformed Range header (ignore, serve full response)\n        #   - If-Range with weak validator\n        \n        # Placeholder return (implementer should replace)\n        return 200, {}, b\"\"\n    \n    def extract_range_from_body(self, body: bytes, \n                               byte_range: ByteRange) -> bytes:\n        \"\"\"\n        Extract byte range from full response body.\n        \n        Args:\n            body: Complete response body\n            byte_range: ByteRange specification\n            \n        Returns:\n            Extracted byte range\n        \"\"\"\n        # TODO 1: Validate that body length >= byte_range.start\n        # TODO 2: If byte_range.end is None, extract from start to end\n        # TODO 3: If byte_range.end specified, extract start to end (inclusive)\n        # TODO 4: Return extracted bytes\n        \n        return b\"\"\n```\n\n#### Language-Specific Hints\n\n- **Python's `http.client` vs `aiohttp`**: For range requests, `aiohttp` automatically handles `Range` headers in responses but not in requests. Use manual `Range` header setting with `aiohttp.ClientSession.get(headers={'Range': 'bytes=0-499'})`.\n\n- **Memory Management for Large Files**: When handling range requests for large files, avoid loading entire files into memory. Use Python's `memoryview` or `io.BytesIO` with slicing for efficient partial access.\n\n- **Exception Hierarchy**: Create a custom exception hierarchy for CDN-specific errors:\n  ```python\n  class CDNError(Exception): pass\n  class OriginError(CDNError): pass\n  class CacheError(CDNError): pass\n  class ConfigurationError(CDNError): pass\n  ```\n\n- **Structured Logging**: Use Python's `structlog` or `logging.config.dictConfig` to create structured logs that include request IDs, cache keys, and failure modes for easier debugging.\n\n- **Testing Network Failures**: Use `unittest.mock.patch` to simulate network timeouts and failures: `@patch('aiohttp.ClientSession.get', side_effect=asyncio.TimeoutError())`.\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Clients receive 502 errors during origin maintenance | Circuit breaker stuck in OPEN state | Check circuit breaker status endpoint; monitor failure count | Implement manual circuit reset API; adjust failure threshold |\n| Range requests return full content instead of partial | Range header parsing failure | Log parsed range values; check for malformed Range headers | Improve Range header parser; handle edge cases like bytes=0- |\n| `Vary: *` responses are being cached | Missing check for `Vary: *` | Add debug logging when `Vary` header is processed | Implement explicit check for `Vary: *` before caching |\n| Stale content served indefinitely after origin recovery | `stale-if-error` logic doesn't reset on origin recovery | Monitor origin health separately from circuit breaker | Reset stale serving when origin returns to healthy state |\n| Different edge nodes serve different versions of same content | Clock skew causing different expiration times | Compare `fetched_at` and `expires_at` across nodes | Implement NTP synchronization; use monotonic clocks for relative TTLs |\n| Thundering herd on new edge node | Failover directs all clients simultaneously | Monitor request rate spike after failover | Implement staggered client redirection using DNS TTL randomization |\n| Memory exhaustion during video streaming | Large range requests cached in full | Monitor cache entry sizes; check for partial vs full caching | Implement size-based cache admission policy; stream without caching large files |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (1 through 5)\n\nBuilding a Content Delivery Network is a complex distributed systems undertaking. Without a rigorous testing strategy, subtle bugs in cache semantics, race conditions during invalidation, or thundering herd scenarios could undermine the entire system. This section provides a comprehensive blueprint for verifying the CDN works correctly across all five milestones. We'll establish a **multi-layered testing pyramid** that combines unit tests for algorithmic correctness, property-based tests for cache behavior invariants, integration tests for multi-component interactions, and load tests for performance validation. Additionally, we provide concrete **milestone checkpoints**—specific commands to run and expected outputs—that let you verify each milestone's acceptance criteria before moving forward.\n\nThink of testing a CDN as **calibrating a network of smart thermostats**. Each thermostat (edge node) must independently make correct decisions about when to heat (fetch from origin) and when to rely on stored warmth (serve from cache). However, they must also coordinate when the building manager sends a system-wide temperature change (invalidation). Our testing strategy ensures each thermostat's local logic is flawless and that their collective behavior remains consistent even during network partitions or command storms.\n\n### Testing Approaches & Properties\n\nA robust CDN testing strategy employs four complementary approaches, each targeting different aspects of the system:\n\n| **Test Type** | **Primary Focus** | **Key Properties Verified** | **Tools/Techniques** |\n|---------------|-------------------|-----------------------------|----------------------|\n| **Unit Tests** | Individual functions and classes in isolation | - Cache key generation correctness<br>- TTL calculation accuracy<br>- Header parsing edge cases<br>- Data structure operations | `pytest`, `unittest`, mock objects |\n| **Property-Based Tests** | System invariants under random inputs | - Cache never serves stale fresh content<br>- Invalidation eventually removes banned content<br>- No race conditions in request collapsing<br>- Consistent hashing distribution properties | `hypothesis`, randomized test generators |\n| **Integration Tests** | Multi-component interactions | - Edge → Shield → Origin request flow<br>- Invalidation propagation across nodes<br>- Geo-routing and failover behavior<br>- Analytics aggregation | Docker containers, test HTTP clients, simulated network partitions |\n| **Load & Performance Tests** | System behavior under production-like load | - Origin protection during cache miss storms<br>- Memory usage under cache pressure<br>- Request collapsing efficiency<br>- Latency percentiles | `locust`, `k6`, custom load generators, monitoring dashboards |\n\n#### Mental Model: The Four-Layer Inspection Protocol\n\nImagine inspecting a chain of grocery stores (our CDN). **Unit tests** are like checking each cash register's calculation logic in isolation. **Property-based tests** verify that no matter what combination of items a customer buys (random inputs), the store never charges tax on exempt items (invariants). **Integration tests** simulate the full supply chain—delivery trucks arriving from warehouses (origin) to distribution centers (shield) to stores (edge)—ensuring produce stays fresh through the entire journey. **Load tests** are the Black Friday simulation: we flood the stores with thousands of customers to ensure neither the cash registers nor the stockrooms collapse under pressure.\n\n#### Property-Based Testing for Cache Correctness\n\nThe most subtle bugs in caching systems involve edge cases in the HTTP caching specification. Property-based testing generates thousands of random but valid HTTP headers and verifies our implementation always respects RFC 9111 semantics. Key properties to test include:\n\n1. **Freshness Invariant**: If a cache entry is fresh (current time < `expires_at`), serving it must produce the same semantic result as fetching from origin (excluding explicit `no-cache` directives).\n2. **Staleness Propagation**: Once a cache entry becomes stale, the next request must trigger revalidation (unless `stale-while-revalidate` is in effect).\n3. **Invalidation Completeness**: After a hard purge of a URL, the next request must result in a cache miss.\n4. **Vary Header Consistency**: Two requests with different `Vary` header values must never return the wrong cached variant.\n5. **Request Collapsing Idempotence**: N identical concurrent requests must produce exactly one origin fetch.\n\nWe express these properties as test functions that use `hypothesis` to generate random cache-control headers, status codes, and request patterns:\n\n```python\n# Example property test structure (shown here for illustration, not in main body)\n@given(random_cache_control(), random_status_code(), random_headers())\ndef test_fresh_content_never_triggers_origin_fetch(cache_control, status_code, headers):\n    # Hypothesis generates thousands of combinations\n    # Test that when content is fresh, edge cache serves it without upstream call\n    pass\n```\n\n#### Integration Testing Strategy\n\nIntegration tests verify that the CDN's distributed components work together correctly. Since we're building an educational project, we'll use lightweight containerization (Docker Compose) to spin up a mini-CDN with 2 edge nodes, 1 shield, and 1 origin server for testing.\n\n**Test Scenarios to Cover:**\n\n| **Scenario** | **Components Involved** | **What to Verify** |\n|--------------|-------------------------|---------------------|\n| Cache miss cascade | Client → Edge → Shield → Origin | - Request collapsing at shield works<br>- Response flows back correctly<br>- Cache populated at both edge and shield |\n| Geo-routing decision | Client resolver → Multiple edges | - Client directed to nearest healthy edge<br>- Consistent hashing distributes load |\n| Invalidation storm | Admin API → Control plane → All edges | - Purge commands propagate within time window<br>- No stale content served after propagation |\n| Shield failure | Edge → Fallback to origin | - Circuit breaker opens after threshold<br>- Requests bypass shield when unhealthy |\n| Request with `Range` header | Client → Edge (with cached content) | - Partial content correctly served<br>- 206 status code returned |\n\n#### Load Testing for Origin Protection\n\nThe primary value of a CDN is protecting the origin during traffic spikes. Load tests verify this protection actually works. We'll simulate:\n\n1. **Cache Miss Storm**: 1000 concurrent requests for an uncached resource with 1-second TTL.\n2. **Popular Content Refresh**: 500 requests/second for a resource that expires simultaneously across all edges.\n3. **Invalidation Cascade**: Purge a heavily cached resource while it's receiving 200 req/s.\n\nSuccess criteria:\n- Origin request rate stays below configured limit (e.g., 10 req/s during miss storm)\n- No client requests time out (all served within 2 seconds)\n- Memory usage remains bounded (no leaks during cache churn)\n\n### Milestone Checkpoints\n\nEach milestone has specific acceptance criteria. These checkpoints provide concrete commands to run and outputs to verify, serving as **quality gates** before proceeding to the next milestone.\n\n#### Milestone 1: Edge Cache Implementation\n\n**Verification Goal**: Ensure the edge cache correctly stores, retrieves, and validates HTTP responses according to RFC 9111.\n\n| **Test** | **Command to Run** | **Expected Output/Behavior** | **What Could Go Wrong** |\n|----------|-------------------|------------------------------|-------------------------|\n| Basic cache hit | `pytest tests/test_edge_cache.py::test_cache_hit -v` | Test passes: shows cache served response without origin fetch | Cache key mismatch or TTL calculation error |\n| Cache miss with origin fetch | `pytest tests/test_edge_cache.py::test_cache_miss -v` | Test passes: shows cache fetched from origin and stored | Upstream connection failure or response parsing error |\n| Cache key with Vary headers | `pytest tests/test_edge_cache.py::test_vary_header_caching -v` | Test passes: different `Accept-Encoding` values create separate cache entries | Vary header parsing incomplete or cache key collision |\n| Conditional request (304) | `pytest tests/test_edge_cache.py::test_conditional_request -v` | Test passes: `If-None-Match` with valid ETag returns 304, saves bandwidth | ETag comparison logic flawed or headers not passed upstream |\n| LRU eviction under pressure | `python -m tests.capacity_test --requests 1000 --capacity 100` | Memory usage stabilizes, oldest entries evicted, hit ratio reasonable | Memory leak or eviction algorithm not triggered |\n| Cache-Control directive parsing | `pytest tests/test_directives.py -v` | All 15+ directives parsed correctly, precedence rules followed | `s-maxage` ignored in favor of `max-age`, `no-cache` misinterpreted |\n\n**Manual Verification Steps:**\n1. Start a test origin server: `python tests/origin_server.py`\n2. Start the edge cache: `python edge_server.py --config configs/edge_test.yaml`\n3. Make first request: `curl -v http://localhost:8080/image.jpg`\n   - Should show `X-Cache: MISS` header\n4. Make identical second request:\n   - Should show `X-Cache: HIT` header\n   - Response identical to first\n5. Request with `Accept-Encoding: gzip`:\n   - Should create separate cache entry (check logs)\n6. Wait for TTL expiration, request again:\n   - Should trigger revalidation or fresh fetch\n\n#### Milestone 2: Cache Invalidation\n\n**Verification Goal**: Ensure purge, ban, and tag-based invalidation work correctly and propagate to all nodes.\n\n| **Test** | **Command to Run** | **Expected Output/Behavior** | **What Could Go Wrong** |\n|----------|-------------------|------------------------------|-------------------------|\n| Hard purge by URL | `pytest tests/test_invalidation.py::test_hard_purge -v` | Cache entry removed, next request misses | Entry not fully removed or ghost data remains |\n| Soft purge with revalidation | `pytest tests/test_invalidation.py::test_soft_purge -v` | Entry marked stale, served while background fetch updates | Background thread not started or stale content not served |\n| Surrogate key purge | `pytest tests/test_invalidation.py::test_tag_purge -v` | All entries with tag removed, others remain | Tag index corruption or incomplete cleanup |\n| Ban rule pattern matching | `pytest tests/test_invalidation.py::test_ban_rules -v` | URLs matching pattern invalidated on access | Regex compilation errors or matching logic flawed |\n| Invalidation propagation | `python -m tests.propagation_test --nodes 3` | All nodes receive purge within 500ms | Pub/sub message loss or network partition not handled |\n| Ban rule GC | `pytest tests/test_invalidation.py::test_ban_garbage_collection -v` | Expired ban rules automatically removed | Memory leak from unbounded ban list |\n\n**Manual Verification Steps:**\n1. Start 3 edge nodes in separate terminals with shared control plane\n2. Cache content on all nodes by making requests to each\n3. Execute purge via admin API:\n   ```bash\n   curl -X PURGE http://edge1:8080/image.jpg\n   ```\n4. Verify all nodes show purge in logs\n5. Request same URL on each node:\n   - All should show `X-Cache: MISS`\n6. Test surrogate key purge:\n   - Request with `Surrogate-Key: product-123`\n   - Purge by tag: `curl -X PURGE -H \"Surrogate-Key: product-123\" http://edge1:8080/purge-by-tag`\n   - Verify all tagged content purged across nodes\n\n#### Milestone 3: Origin Shield & Request Collapsing\n\n**Verification Goal**: Ensure shield reduces origin load through request collapsing and protects against thundering herds.\n\n| **Test** | **Command to Run** | **Expected Output/Behavior** | **What Could Go Wrong** |\n|----------|-------------------|------------------------------|-------------------------|\n| Request collapsing | `pytest tests/test_shield.py::test_request_collapsing -v` | 100 concurrent requests → 1 origin fetch | Race condition in coalescing map or timeout too short |\n| Negative caching | `pytest tests/test_shield.py::test_negative_caching -v` | Origin 404s cached briefly, not repeatedly fetched | Negative cache TTL not honored or error responses cached incorrectly |\n| Shield circuit breaker | `pytest tests/test_shield.py::test_circuit_breaker -v` | After origin failures, shield bypasses to origin | Circuit state transitions incorrectly or health checks flawed |\n| Queue overflow protection | `python -m tests.shield_load_test --concurrent 1000` | Queue limits respected, excess requests get 503 | Unlimited queue growth causes memory exhaustion |\n| Stale-while-revalidate at shield | `pytest tests/test_shield.py::test_shield_stale_while_revalidate -v` | Shield serves stale while revalidating in background | Background revalidation not triggered or stale content blocked |\n\n**Manual Verification Steps:**\n1. Start origin, shield, and single edge node\n2. Use `ab` or `wrk` to send 100 concurrent requests for uncached resource:\n   ```bash\n   wrk -t10 -c100 -d5s http://edge:8080/uncached.html\n   ```\n3. Check shield logs: should show exactly 1 origin request\n4. Check origin logs: should show 1 request, not 100\n5. Cause origin failure (kill origin server)\n6. Make several requests:\n   - First few might fail through\n   - Circuit should open after threshold\n   - Subsequent requests should bypass shield (check headers)\n7. Restart origin, verify circuit half-open then closed\n\n#### Milestone 4: Edge Node Distribution & Routing\n\n**Verification Goal**: Ensure clients route to nearest edge, consistent hashing distributes load, and failover works.\n\n| **Test** | **Command to Run** | **Expected Output/Behavior** | **What Could Go Wrong** |\n|----------|-------------------|------------------------------|-------------------------|\n| GeoIP routing | `pytest tests/test_routing.py::test_geoip_routing -v` | US IP routes to US edge, EU IP to EU edge | GeoIP database missing or incorrect mapping |\n| Consistent hashing distribution | `python -m tests.distribution_test --keys 10000 --nodes 5` | Keys distributed evenly (within 20% variance) | Hash function skew or virtual nodes not balanced |\n| Node failure and redistribution | `pytest tests/test_routing.py::test_node_failure -v` | Keys remapped minimally (< 30% movement on node loss) | Hash ring update incorrect or health check false positive |\n| Health check integration | `pytest tests/test_health.py -v` | Unhealthy nodes removed from rotation, marked degraded | Health check too aggressive or recovery not detected |\n| Failover latency | `python -m tests.failover_test --kill-node edge-us-1` | Traffic redirects to next-nearest within 5 seconds | DNS TTL too long or health propagation delayed |\n\n**Manual Verification Steps:**\n1. Deploy 3 edge nodes in different regions (simulate with different ports)\n2. Start GeoDNS resolver or HTTP redirector\n3. From simulated US client (`curl -H \"X-Client-IP: 8.8.8.8\"`):\n   - Should reach US edge node (check logs)\n4. From simulated EU client (`curl -H \"X-Client-IP: 1.1.1.1\"`):\n   - Should reach EU edge node\n5. Kill US edge node process\n6. Health check should detect within 2 seconds\n7. Subsequent US client requests should route to next closest (EU or ASIA)\n8. Verify consistent hashing: cache specific key on node A, kill node A, bring up replacement node A', request same key - should route to different node initially, then re-cache on A'\n\n#### Milestone 5: CDN Analytics & Performance Optimization\n\n**Verification Goal**: Ensure analytics track performance accurately and optimizations (compression, range requests) work.\n\n| **Test** | **Command to Run** | **Expected Output/Behavior** | **What Could Go Wrong** |\n|----------|-------------------|------------------------------|-------------------------|\n| Cache hit ratio tracking | `pytest tests/test_analytics.py::test_hit_ratio -v` | After mixed hits/misses, ratio calculated correctly | Race conditions in counter updates or reset logic flawed |\n| Compression negotiation | `pytest tests/test_compression.py -v` | `Accept-Encoding: gzip` returns compressed, others uncompressed | Compression applied to already binary content or CPU spike |\n| Range request support | `pytest tests/test_range_requests.py -v` | `Range: bytes=0-499` returns 206 with correct content | Byte range math errors or multi-range not handled |\n| Bandwidth accounting | `python -m tests.bandwidth_test --duration 30` | Analytics show correct bytes served, matches actual transfer | Counting omitted for cached responses or compression size not considered |\n| Stale-while-revalidate behavior | `pytest tests/test_stale_optimizations.py -v` | Stale content served while async revalidation occurs | Client receives stale content indefinitely if revalidation fails |\n\n**Manual Verification Steps:**\n1. Enable analytics dashboard: `python analytics_dashboard.py`\n2. Generate mixed traffic pattern:\n   ```bash\n   python tests/traffic_generator.py --pattern mixed --duration 60\n   ```\n3. Check dashboard:\n   - Hit ratio should converge to expected value\n   - Bandwidth should show savings from cache hits\n4. Test compression:\n   ```bash\n   curl -H \"Accept-Encoding: gzip\" -v http://edge:8080/large.json 2>&1 | grep \"Content-Encoding\"\n   ```\n   - Should show `gzip` and reduced size\n5. Test range request:\n   ```bash\n   curl -H \"Range: bytes=1000-1999\" -v http://edge:8080/large_video.mp4\n   ```\n   - Should return 206 Partial Content\n   - Should serve from cache if already cached\n6. Verify stale-while-revalidate:\n   - Request resource, wait for it to go stale\n   - Make concurrent requests: should serve stale while one revalidates\n\n### Implementation Guidance\n\n> **Technology Recommendations:**\n> | **Component** | **Simple Option** | **Advanced Option** |\n> |---------------|-------------------|---------------------|\n> | Test Framework | `pytest` with `pytest-asyncio` | `pytest` with custom fixtures and plugins |\n> | Property Testing | `hypothesis` for random test generation | Custom fuzzers with corpus from real traffic |\n> | Integration Testing | `docker-compose` with test containers | Kubernetes Kind cluster for realistic orchestration |\n> | Load Testing | `locust` for Python-based load scenarios | `k6` for JavaScript-based performance tests |\n> | Mock HTTP Servers | `aiohttp` test server or `responses` library | Custom TCP server simulating origin behaviors |\n\n**Recommended Test Directory Structure:**\n```\nblue-origin-cdn/\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py                    # Shared pytest fixtures\n│   ├── unit/\n│   │   ├── test_edge_cache.py        # Milestone 1\n│   │   ├── test_directives.py        # Cache-Control parsing\n│   │   ├── test_invalidation.py      # Milestone 2\n│   │   ├── test_shield.py            # Milestone 3\n│   │   ├── test_routing.py           # Milestone 4\n│   │   └── test_analytics.py         # Milestone 5\n│   ├── integration/\n│   │   ├── test_multi_node.py        # Multi-edge scenarios\n│   │   ├── test_propagation.py       # Invalidation across nodes\n│   │   └── test_full_stack.py        # End-to-end flows\n│   ├── property/\n│   │   ├── test_cache_properties.py  # Hypothesis-based invariants\n│   │   └── test_hashing_properties.py\n│   ├── load/\n│   │   ├── miss_storm.py             # Cache miss load test\n│   │   └── invalidation_storm.py     # Purge load test\n│   ├── fixtures/\n│   │   ├── origin_server.py          # Test origin implementation\n│   │   └── geoip_test_db.mmdb        # Test GeoIP database\n│   └── utils/\n│       ├── test_client.py            # Async HTTP test client\n│       └── assertions.py             # Custom assertions\n├── docker-compose.test.yml           # Integration test environment\n└── loadtest/\n    ├── locustfile.py                 # Locust load test definition\n    └── k6_script.js                  # k6 load test script\n```\n\n**Infrastructure Starter Code: Test Origin Server**\n\nHere's a complete, ready-to-use test origin server that simulates various origin behaviors for testing:\n\n```python\n# tests/fixtures/origin_server.py\nimport asyncio\nimport time\nfrom typing import Dict, List, Optional, Tuple\nfrom aiohttp import web\nimport gzip\nimport json\nimport random\n\nclass TestOriginServer:\n    \"\"\"Configurable test origin server for CDN testing.\"\"\"\n    \n    def __init__(self, port: int = 8000):\n        self.port = port\n        self.request_count = 0\n        self.responses: Dict[str, Dict] = {\n            '/image.jpg': {\n                'status': 200,\n                'headers': {'Content-Type': 'image/jpeg', 'Cache-Control': 'public, max-age=3600'},\n                'body': b'fake-jpeg-content-' + b'x' * 1000,\n                'etag': '\"abc123\"',\n                'delay': 0.1\n            },\n            '/api/data': {\n                'status': 200,\n                'headers': {'Content-Type': 'application/json', 'Cache-Control': 'no-cache'},\n                'body': json.dumps({'data': 'sensitive', 'version': 1}).encode(),\n                'delay': 0.05\n            },\n            '/large.txt': {\n                'status': 200,\n                'headers': {'Content-Type': 'text/plain', 'Cache-Control': 'public, max-age=60, stale-while-revalidate=30'},\n                'body': b'Line ' + b'\\n'.join([f'Line {i}'.encode() for i in range(10000)]),\n                'etag': '\"large123\"',\n                'delay': 0.2\n            }\n        }\n        self.failure_mode = None  # 'timeout', '500', 'slow'\n        \n    async def handler(self, request: web.Request) -> web.Response:\n        \"\"\"Handle incoming request with configurable behavior.\"\"\"\n        self.request_count += 1\n        path = request.path\n        method = request.method\n        \n        # Apply failure modes if active\n        if self.failure_mode == 'timeout':\n            await asyncio.sleep(10)  # Longer than client timeout\n            return web.Response(status=504)\n        elif self.failure_mode == '500':\n            return web.Response(status=500, text='Internal Server Error')\n        elif self.failure_mode == 'slow':\n            await asyncio.sleep(2)  # Slow but not timeout\n            \n        # Check for conditional requests\n        if_none_match = request.headers.get('If-None-Match')\n        if_modified_since = request.headers.get('If-Modified-Since')\n        \n        # Find response configuration\n        resp_config = self.responses.get(path)\n        if not resp_config:\n            resp_config = {\n                'status': 404,\n                'headers': {'Content-Type': 'text/plain'},\n                'body': b'Not Found',\n                'delay': 0\n            }\n            \n        # Apply delay if specified\n        if resp_config.get('delay', 0) > 0:\n            await asyncio.sleep(resp_config['delay'])\n            \n        # Handle conditional requests for resources with ETag\n        if if_none_match and resp_config.get('etag'):\n            if if_none_match == resp_config['etag']:\n                return web.Response(status=304, headers=resp_config['headers'])\n                \n        # Build response\n        headers = dict(resp_config['headers'])\n        if resp_config.get('etag'):\n            headers['ETag'] = resp_config['etag']\n            \n        # Handle compression if requested\n        accept_encoding = request.headers.get('Accept-Encoding', '')\n        body = resp_config['body']\n        if 'gzip' in accept_encoding and headers.get('Content-Type', '').startswith('text/'):\n            body = gzip.compress(body)\n            headers['Content-Encoding'] = 'gzip'\n            headers['Vary'] = 'Accept-Encoding'\n            \n        # Handle range requests\n        range_header = request.headers.get('Range')\n        if range_header and path == '/large.txt':\n            # Simple byte range handling for testing\n            if range_header.startswith('bytes='):\n                range_spec = range_header[6:]\n                if '-' in range_spec:\n                    start_end = range_spec.split('-')\n                    start = int(start_end[0]) if start_end[0] else 0\n                    end = int(start_end[1]) if len(start_end) > 1 and start_end[1] else len(body) - 1\n                    chunk = body[start:end+1]\n                    headers['Content-Range'] = f'bytes {start}-{end}/{len(body)}'\n                    return web.Response(status=206, headers=headers, body=chunk)\n                    \n        return web.Response(\n            status=resp_config['status'],\n            headers=headers,\n            body=body\n        )\n        \n    async def start(self):\n        \"\"\"Start the test origin server.\"\"\"\n        app = web.Application()\n        app.router.add_route('*', '/{path:.*}', self.handler)\n        runner = web.AppRunner(app)\n        await runner.setup()\n        site = web.TCPSite(runner, 'localhost', self.port)\n        await site.start()\n        print(f\"Test origin server running on http://localhost:{self.port}\")\n        return runner\n        \n    def set_failure_mode(self, mode: Optional[str]):\n        \"\"\"Set failure mode for testing circuit breakers.\"\"\"\n        self.failure_mode = mode\n        \n    def get_request_count(self) -> int:\n        \"\"\"Get total requests received.\"\"\"\n        return self.request_count\n        \n    def reset_counter(self):\n        \"\"\"Reset request counter.\"\"\"\n        self.request_count = 0\n\n# Quick test runner\nif __name__ == '__main__':\n    server = TestOriginServer(port=9999)\n    async def run():\n        await server.start()\n        await asyncio.Future()  # Run forever\n    asyncio.run(run())\n```\n\n**Core Test Skeleton: Property-Based Cache Validation**\n\n```python\n# tests/property/test_cache_properties.py\nimport pytest\nfrom hypothesis import given, strategies as st, settings, assume\nfrom datetime import datetime, timedelta\nimport time\n\nfrom blue_origin.cache.edge_cache import CacheEntry, CacheDirectives\nfrom blue_origin.cache.validation import is_response_cacheable\n\n# Strategy for generating random cache control headers\ncache_control_strategy = st.dictionaries(\n    keys=st.sampled_from([\n        'max-age', 's-maxage', 'no-cache', 'no-store', 'must-revalidate',\n        'proxy-revalidate', 'public', 'private', 'stale-while-revalidate',\n        'stale-if-error'\n    ]),\n    values=st.one_of(st.none(), st.integers(min_value=0, max_value=31536000)),\n    max_size=5\n)\n\n@given(\n    status_code=st.integers(min_value=200, max_value=599),\n    method=st.sampled_from(['GET', 'POST', 'HEAD']),\n    cache_control=cache_control_strategy,\n    vary_header=st.one_of(st.none(), st.text(max_size=20))\n)\n@settings(max_examples=1000, deadline=2000)\ndef test_cacheability_property(status_code, method, cache_control, vary_header):\n    \"\"\"\n    Property: is_response_cacheable must be consistent with RFC 9111.\n    \n    TODO 1: Only GET and HEAD responses are potentially cacheable\n    TODO 2: Status codes 200, 203, 204, 206, 300, 301, 308, 404, 405, 410, \n            414, 501 are cacheable by default (unless headers forbid)\n    TODO 3: no-store directive makes response uncacheable\n    TODO 4: private directive means response cacheable but not by shared caches (CDN)\n    TODO 5: Vary: * means response is uncacheable\n    TODO 6: Implement the actual logic from RFC 9111 Section 3\n    TODO 7: Return True/False based on all conditions above\n    \n    Run with: pytest tests/property/test_cache_properties.py -v\n    \"\"\"\n    # This is a skeleton - hypothesis will generate 1000 random inputs\n    # Your implementation should deterministically decide cacheability\n    result = is_response_cacheable(status_code, method, cache_control, vary_header)\n    \n    # Add assertions that must ALWAYS hold\n    if method not in ['GET', 'HEAD']:\n        assert result is False, f\"Non-GET/HEAD method {method} must not be cacheable\"\n    \n    if cache_control.get('no-store') is not None:\n        assert result is False, \"no-store directive must prevent caching\"\n    \n    if vary_header == '*':\n        assert result is False, \"Vary: * must prevent caching\"\n\n@given(\n    fetched_at=st.floats(min_value=0, max_value=1e9),\n    max_age=st.one_of(st.none(), st.integers(min_value=0, max_value=31536000)),\n    s_maxage=st.one_of(st.none(), st.integers(min_value=0, max_value=31536000)),\n    request_time=st.floats(min_value=0, max_value=1e9)\n)\ndef test_freshness_calculation_property(fetched_at, max_age, s_maxage, request_time):\n    \"\"\"\n    Property: Freshness calculation must follow Cache-Control precedence.\n    \n    TODO 1: s-maxage takes precedence over max-age for shared caches (CDN)\n    TODO 2: Calculate expires_at based on fetched_at + relevant TTL\n    TODO 3: Entry is fresh if request_time < expires_at\n    TODO 4: Handle None values correctly (no expiration)\n    TODO 5: Ensure math doesn't overflow or produce negative TTLs\n    \n    Run with: pytest tests/property/test_cache_properties.py::test_freshness_calculation_property -v\n    \"\"\"\n    assume(request_time >= fetched_at)  # Request can't be before fetch\n    \n    # Create directives object\n    directives = CacheDirectives(\n        s_maxage=s_maxage,\n        max_age=max_age,\n        no_cache=False,\n        no_store=False,\n        must_revalidate=False,\n        proxy_revalidate=False,\n        public=True,\n        private=False,\n        stale_while_revalidate=None,\n        stale_if_error=None\n    )\n    \n    # Create cache entry\n    entry = CacheEntry(\n        key=\"test\",\n        url=\"/test\",\n        vary_headers={},\n        status_code=200,\n        headers={},\n        body=b\"test\",\n        fetched_at=fetched_at,\n        expires_at=0,  # Will be calculated\n        last_used_at=fetched_at,\n        use_count=1,\n        surrogate_keys=[],\n        etag=None,\n        last_modified=None\n    )\n    \n    # TODO: Calculate expires_at based on directives\n    # TODO: Determine if entry is fresh at request_time\n    # TODO: Add assertions about correctness\n    \n    # Placeholder assertions\n    assert True  # Replace with actual property checks\n```\n\n**Integration Test Helper: Multi-Node Test Environment**\n\n```python\n# tests/integration/conftest.py\nimport pytest\nimport asyncio\nimport aiohttp\nfrom typing import Dict, List\nimport subprocess\nimport time\nimport os\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture(scope=\"module\")\nasync def test_origin():\n    \"\"\"Start test origin server.\"\"\"\n    from tests.fixtures.origin_server import TestOriginServer\n    origin = TestOriginServer(port=8888)\n    runner = await origin.start()\n    yield origin\n    await runner.cleanup()\n\n@pytest.fixture(scope=\"module\")\nasync def edge_nodes(test_origin):\n    \"\"\"Start multiple edge nodes for testing.\"\"\"\n    nodes = []\n    processes = []\n    \n    # Start 3 edge nodes on different ports\n    for i in range(3):\n        port = 9000 + i\n        env = os.environ.copy()\n        env['EDGE_PORT'] = str(port)\n        env['UPSTREAM_URL'] = 'http://localhost:8888'\n        env['NODE_ID'] = f'edge-{i}'\n        \n        proc = subprocess.Popen(\n            ['python', '-m', 'blue_origin.edge_server'],\n            env=env,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE\n        )\n        processes.append(proc)\n        nodes.append(f'http://localhost:{port}')\n        time.sleep(0.5)  # Stagger startup\n        \n    # Wait for nodes to be ready\n    for node_url in nodes:\n        for _ in range(30):  # 30 second timeout\n            try:\n                async with aiohttp.ClientSession() as session:\n                    async with session.get(f'{node_url}/health'):\n                        break\n            except:\n                time.sleep(1)\n        else:\n            raise RuntimeError(f\"Edge node {node_url} failed to start\")\n    \n    yield nodes\n    \n    # Cleanup\n    for proc in processes:\n        proc.terminate()\n        proc.wait(timeout=5)\n\n@pytest.fixture\nasync def http_client():\n    \"\"\"Create HTTP client for tests.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        yield session\n```\n\n**Milestone Checkpoint Test Commands**\n\nAdd these to your `Makefile` or test scripts:\n\n```makefile\n# Makefile test targets\ntest-milestone1:\n\tpytest tests/unit/test_edge_cache.py -v --tb=short\n\tpytest tests/unit/test_directives.py -v\n\tpython -m tests.capacity_test --requests 1000 --capacity 100\n\ntest-milestone2:\n\tpytest tests/unit/test_invalidation.py -v\n\tpython -m tests.propagation_test --nodes 3 --timeout 500\n\ntest-milestone3:\n\tpytest tests/unit/test_shield.py -v\n\tpython -m tests.shield_load_test --concurrent 100 --duration 10\n\ntest-milestone4:\n\tpytest tests/unit/test_routing.py -v\n\tpython -m tests.distribution_test --keys 10000 --nodes 5\n\tpytest tests/unit/test_health.py -v\n\ntest-milestone5:\n\tpytest tests/unit/test_analytics.py -v\n\tpytest tests/unit/test_compression.py -v\n\tpytest tests/unit/test_range_requests.py -v\n\ntest-integration:\n\tpytest tests/integration/ -v --tb=short\n\ntest-property:\n\tpytest tests/property/ -v --hypothesis-show-statistics\n\ntest-all: test-milestone1 test-milestone2 test-milestone3 test-milestone4 test-milestone5 test-integration\n\nload-test:\n\tcd loadtest && locust -f locustfile.py --host=http://localhost:8080\n```\n\n**Language-Specific Hints for Python Testing:**\n\n1. **Async Testing**: Use `pytest-asyncio` and mark async tests with `@pytest.mark.asyncio`. Ensure event loop fixtures are properly scoped.\n\n2. **Mocking**: Use `unittest.mock` to mock external dependencies. For async mocks, use `AsyncMock`:\n   ```python\n   from unittest.mock import AsyncMock\n   upstream_fetch = AsyncMock(return_value=(200, {}, b'response'))\n   ```\n\n3. **Timing-Dependent Tests**: For tests involving timeouts or TTLs, use time mocking:\n   ```python\n   from unittest.mock import patch\n   with patch('time.time', return_value=1000):\n       # Test logic with fixed time\n   ```\n\n4. **Property-Based Testing with Hypothesis**: Use `@given` decorators with strategies. Build custom strategies for complex data structures. Use `assume()` to filter out invalid test cases.\n\n5. **Testing Concurrent Behavior**: Use `asyncio.gather()` to simulate concurrent requests in tests. Add small jitter to avoid synchronized timing.\n\n6. **Checking Log Output**: Use `caplog` fixture to verify log messages:\n   ```python\n   def test_cache_hit_logs(caplog):\n       with caplog.at_level('INFO'):\n           make_request()\n           assert 'Cache hit' in caplog.text\n   ```\n\n**Debugging Tips for Failed Tests:**\n\n| **Symptom** | **Likely Cause** | **How to Diagnose** | **Fix** |\n|-------------|------------------|----------------------|---------|\n| Test passes locally but fails in CI | Timing differences or race conditions | Add more logging, increase timeouts in CI environment | Use `asyncio.wait_for` with reasonable timeouts, mock time in sensitive tests |\n| Property-based test finds rare failure | Edge case in cache logic | Hypothesis shrinks input to minimal failing case | Examine shrunk input, add special handling for that case |\n| Integration test flakes randomly | Network race conditions or cleanup issues | Add retry logic, check for proper resource cleanup in fixtures | Ensure proper async cleanup, add unique IDs to requests for tracing |\n| Load test shows memory growth | Cache eviction not working or memory leak | Profile memory during test, check cache size metrics | Implement proper LRU eviction, close HTTP clients, use weak references |\n| Tests pass but manual verification fails | Test mocks too permissive or incomplete | Run test with real components, compare logs | Make mocks more strict, test with actual HTTP traffic |\n\n---\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (1 through 5)\n\nBuilding a distributed caching system involves numerous moving parts that can fail in subtle ways. This debugging guide provides a practical manual for diagnosing and fixing the most common issues you'll encounter while implementing the Blue Origin CDN. Think of debugging a CDN as **being a traffic investigator at a complex highway interchange**—you need to examine multiple layers (network routes, vehicle behavior, traffic signals) to understand why congestion or accidents occur. This guide helps you systematically trace problems through the caching layers, from client requests to origin responses and everything in between.\n\n### Symptom → Cause → Fix Table\n\nThe following table catalogs common symptoms, their root causes, diagnostic approaches, and solutions. Each row represents a complete debugging workflow for a specific issue you might encounter.\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Origin server receives duplicate identical requests** (Thundering herd) | Missing request collapsing at the origin shield layer, or shield bypassed | 1. Check shield logs for concurrent requests with same cache key<br>2. Verify `RequestCoalescingMap` is tracking in-flight requests<br>3. Monitor `ShieldMetrics.collapsed_requests` counter | Implement proper request deduplication in `ShieldRequestHandler.handle_request()` using `RequestCoalescingMap.get_or_create_future()` |\n| **Cache hit ratio remains near 0% despite repeated requests** | Cache keys not matching, TTLs set to zero, or responses marked uncacheable | 1. Add debug headers (`X-Cache-Key`, `X-Cache-Status`) to responses<br>2. Check `is_response_cacheable()` logic for false negatives<br>3. Inspect `Cache-Control` headers from origin | Ensure cache key generation includes all `Vary` header dimensions and respects `CacheDirectives.public` vs `private` |\n| **Purge commands don't remove content from all edge nodes** | Invalidation propagation delay or failed broadcast | 1. Check `InvalidationMessage` delivery via pub/sub broker<br>2. Verify all edge nodes subscribe to the same channel<br>3. Monitor control plane logs for delivery failures | Implement acknowledgment mechanism in pub/sub or switch to more reliable propagation (e.g., control plane polling) |\n| **Clients receive stale content after origin update** | Cache entries not invalidated, TTL too long, or revalidation failing | 1. Check `CacheEntry.expires_at` vs current time<br>2. Verify purge commands actually delete entries<br>3. Test `CacheEntry.is_fresh()` logic with edge cases | Implement proper invalidation propagation and ensure `stale-while-revalidate` doesn't serve outdated data indefinitely |\n| **Edge node crashes under high load** | Memory exhaustion from unbounded cache growth or ban rule accumulation | 1. Monitor `EdgeMetrics.current_cache_size_bytes`<br>2. Check `BanRule` list length and TTLs<br>3. Profile memory usage during load tests | Implement LRU eviction with strict capacity limits and add TTL-based cleanup for ban rules via `InvalidationHandler._gc_ban_rules()` |\n| **Geo-routing directs clients to distant edge nodes** | GeoIP database inaccuracy or health status misreporting | 1. Verify `GeoIPLookup.lookup()` returns correct location for test IPs<br>2. Check `EdgeNode.health_status` reporting<br>3. Test consistent hashing ring assignment | Use more accurate GeoIP database, implement weighted health checks, and add fallback routing based on latency measurements |\n| **Range requests return incorrect byte ranges** | Cache fragmentation or incorrect `Range` header parsing | 1. Test `RangeRequestHandler.parse_range_header()` with various inputs<br>2. Verify cached body length matches `Content-Length`<br>3. Check for off-by-one errors in `ByteRange.end` | Implement proper boundary checking in `RangeRequestHandler.extract_range_from_body()` and cache full responses, not partials |\n| **Compression causes CPU spikes at edge** | Compressing all content types or using high compression levels | 1. Profile CPU usage by content type<br>2. Check if already-compressed responses (images, videos) get recompressed<br>3. Monitor compression ratio vs CPU time trade-off | Skip compression for already-compressed formats and implement configurable compression level per content type |\n| **Circuit breaker trips unnecessarily** | Failure threshold too low or origin temporary blips treated as failures | 1. Check `CircuitBreakerConfig.failure_threshold` value<br>2. Monitor origin response times vs timeout settings<br>3. Verify health check logic isn't too sensitive | Adjust circuit breaker parameters based on actual failure patterns and implement exponential backoff for `half_open` state |\n| **Negative caching causes 404s to persist** | Error response TTL too long or missing invalidation on content creation | 1. Check TTL assigned to error responses (should be short)<br>2. Verify purge commands affect negative cache entries<br>3. Monitor `ShieldMetrics.negative_cache_hits` | Cache 404/5xx responses with very short TTLs (5-10 seconds) and include them in purge operations |\n| **Vary header handling causes cache bloat** | Treating each unique header combination as separate entry without bounds | 1. Inspect cache storage for duplicate content with different `Vary` values<br>2. Check if `Vary: *` is incorrectly cached<br>3. Monitor memory growth with varied requests | Implement `Vary` header normalization and limit number of variations per URL; reject `Vary: *` from cache |\n| **Request collapsing causes client timeouts** | Collapsing timeout longer than client timeout or deadlock in coalescing map | 1. Compare `RequestCoalescingMap._default_timeout` with client timeout<br>2. Check for stuck futures never fulfilled<br>3. Monitor queue times in `ShieldMetrics` | Set collapsing timeout shorter than client timeout and implement timeout cleanup in `RequestCoalescingMap._gc_loop()` |\n| **Consistent hashing causes hot spots** | Uneven virtual node distribution or skewed request patterns | 1. Analyze request distribution across edge nodes<br>2. Check `ConsistentHashRing.replicas_per_node` count<br>3. Verify hash function distribution uniformity | Increase virtual nodes per physical node and consider weighted consistent hashing based on node capacity |\n| **Stale-while-revalidate serves outdated data indefinitely** | Background revalidation failing silently or not triggered | 1. Check `_revalidate_in_background()` error handling<br>2. Verify stale entries get revalidation triggered on access<br>3. Monitor background thread/task completion | Implement proper error recovery in revalidation and fallback to fetch fresh content if revalidation fails repeatedly |\n| **Health checks cause cascading failures** | Aggressive health checking marks nodes unhealthy during normal load | 1. Check health check interval vs node response time under load<br>2. Verify health metrics thresholds are realistic<br>3. Monitor `NodeHealth` transitions during traffic spikes | Implement weighted health checks that consider historical performance and add grace periods before marking nodes unhealthy |\n\n### CDN-Specific Debugging Techniques\n\nBeyond symptom-based diagnosis, effective CDN debugging requires specialized techniques for inspecting the complex interactions between caching layers, routing logic, and distributed state. These methods transform the CDN from a black box into a transparent, observable system where you can trace every request's journey and understand every caching decision.\n\n#### Adding Diagnostic Headers to HTTP Responses\n\nThe simplest yet most powerful debugging technique is augmenting HTTP responses with custom headers that reveal the CDN's internal decision-making. These headers act as **flight data recorders for each request**, documenting its path through the caching infrastructure. Add the following headers to all responses from edge nodes:\n\n- **`X-Cache-Status`**: Indicates whether the response was served from cache (`HIT`), fetched from upstream (`MISS`), revalidated (`REVALIDATED`), or served stale while revalidating (`STALE`)\n- **`X-Cache-Key`**: Shows the exact cache key used for lookup, helping identify key generation issues\n- **`X-Cache-Age`**: The time in seconds since the cached response was fetched from origin\n- **`X-Edge-Node`**: Identifier of the edge node that served the request (crucial for geo-routing debugging)\n- **`X-Request-ID`**: Unique identifier propagated through all layers (edge → shield → origin) for request tracing\n- **`X-Cache-TTL`**: Remaining time-to-live in seconds for the cached response\n- **`X-Vary-Headers`**: Shows which request headers were considered in cache key generation due to `Vary`\n\nTo implement these headers, modify the `EdgeRequestHandler.handle_request()` method to append them before returning the response. In production CDNs, these headers are typically enabled via configuration and stripped for external clients, but during development they provide invaluable visibility.\n\n#### Inspecting Cache State and Metrics\n\nWhen responses aren't caching as expected, you need to directly examine the cache's internal state. The CDN provides several inspection points:\n\n1. **Cache Storage Dump**: Implement a debug endpoint (e.g., `GET /debug/cache`) that returns a JSON representation of all cache entries, including their keys, URLs, TTLs, and tags. This helps verify what's actually stored versus what you expect to be stored.\n\n2. **Metrics Inspection Endpoint**: Create `/debug/metrics` endpoint exposing `EdgeMetrics`, `ShieldMetrics`, and `TimeWindowedMetrics` in structured format. Monitor:\n   - Cache hit ratio trends over time\n   - Cache size and eviction rates\n   - Request collapsing effectiveness at shield\n   - Geo-routing distribution across nodes\n\n3. **Surrogate Key Index Verification**: Add a debug endpoint to inspect `SurrogateKeyIndex` mappings, showing which tags are assigned to which cache keys and vice versa. This is crucial when tag-based purges aren't working.\n\n4. **Ban Rule Audit**: Expose active `BanRule` patterns, their creation times, and match counts to ensure they're being applied correctly and garbage collected when expired.\n\n> **Debugging Insight**: Always compare cache state with actual HTTP behavior. If the cache dump shows an entry exists but requests miss, the issue is likely in cache key generation or request/response header mismatching.\n\n#### Simulating Geo-Distribution Locally\n\nTesting geo-routing and multi-node behavior typically requires distributed infrastructure, but you can simulate it locally using these techniques:\n\n1. **IP Address Spoofing**: Use tools like `curl --interface` or programming libraries to bind requests to different source IPs. Combine with a test `GeoIP` database that maps specific test IPs to different regions (e.g., `203.0.113.1` → \"US-West\", `203.0.113.2` → \"EU-Central\").\n\n2. **Local Edge Node Cluster**: Run multiple edge node instances on different ports, each configured with a different `region` in `EdgeConfig`. Use a simple local DNS resolver or HTTP proxy to route requests based on simulated client IPs.\n\n3. **Consistent Hashing Visualization**: Implement a debug visualization of the `ConsistentHashRing` showing positions of nodes and sample cache keys. This helps identify hot spots and understand key redistribution during node addition/removal.\n\n4. **Network Condition Simulation**: Use tools like `tc` (traffic control on Linux) or `comcast` to simulate latency, packet loss, and bandwidth constraints between nodes, reproducing real-world network partitions.\n\n5. **Control Plane Mock**: Create a mock control plane that coordinates multiple local edge nodes, allowing you to test invalidation propagation, health check aggregation, and configuration distribution without cloud deployment.\n\n#### Request Tracing and Log Correlation\n\nFor complex issues involving multiple hops (client → edge → shield → origin), implement distributed tracing:\n\n1. **Generate Unique Request ID**: At the first CDN entry point, generate a UUID and pass it through all layers via the `X-Request-ID` header.\n\n2. **Structured Logging**: Use JSON-structured logs at each component that includes the request ID, component name, cache key, decision points, and timing information.\n\n3. **Log Aggregation**: Collect logs from all edge nodes, shields, and control plane into a central location (even a simple file during development) where you can filter by request ID to see the complete journey.\n\n4. **Timing Measurements**: Log key timing events: cache lookup duration, upstream fetch time, shield queuing delay, and geo-routing decision time. This helps identify performance bottlenecks.\n\n#### Testing Cache Invalidation Propagation\n\nInvalidation bugs often manifest as stale content served from some nodes but not others. Test propagation systematically:\n\n1. **Propagation Delay Test**: Issue a purge command, then immediately request the same resource from multiple edge nodes while logging `X-Cache-Status` and `X-Edge-Node`. Measure time until all nodes reflect the purge.\n\n2. **Network Partition Simulation**: Disconnect one edge node from the pub/sub network, issue purges, then reconnect and verify it receives queued invalidation messages.\n\n3. **Sequence Testing**: Send rapid successive purge commands and verify they're processed in order, especially important for soft-purge-then-hard-purge scenarios.\n\n4. **Tag-Based Purge Coverage**: Create resources with multiple surrogate keys, then purge by one tag and verify only appropriate resources are invalidated.\n\n> **Critical Debugging Principle**: When debugging distributed caching systems, **assume eventual consistency by default**. Many issues resolve themselves given time. The question is whether the inconsistency window matches your design expectations.\n\n#### Common HTTP Edge Case Testing\n\nSeveral HTTP caching edge cases frequently cause subtle bugs. Create test cases for:\n\n1. **`Vary: *`**: Ensure responses with this header are never cached, despite other cache directives suggesting they could be.\n\n2. **`Cache-Control: no-cache` vs `no-store`**: Verify `no-cache` allows storage but requires revalidation, while `no-store` prevents any storage.\n\n3. **Multiple `Cache-Control` headers**: Test handling of multiple `Cache-Control` headers (should be concatenated per RFC).\n\n4. **`Expires` with invalid date format**: Ensure graceful fallback when `Expires` header contains malformed dates.\n\n5. **Chunked encoding with cache**: Verify chunked responses can be cached (must be reassembled into complete body).\n\n6. **`Content-Encoding` with `Vary: Accept-Encoding`**: Test that compressed and uncompressed versions are stored separately.\n\nBy combining these debugging techniques with the symptom-cause-fix table, you'll develop systematic approach to troubleshooting the CDN. Remember that caching bugs often involve **timing, distribution, and state**—reproduce issues under realistic load and network conditions, and always verify behavior at multiple points in the request flow.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Diagnostic Headers | Custom middleware in request handler | OpenTelemetry tracing with baggage propagation |\n| Cache Inspection | Debug HTTP endpoints with JSON output | Integrated admin UI with real-time metrics |\n| Geo Simulation | Static IP-to-region mapping file | Docker containers with virtual networks and IP routing |\n| Request Tracing | Manual `X-Request-ID` propagation | Distributed tracing (Jaeger/Zipkin) with spans |\n| Logging | Structured JSON to stdout | Centralized log aggregation (Loki/ELK) |\n\n**B. Recommended File/Module Structure**\n\n```\nblue-origin-cdn/\n├── src/\n│   ├── debug/                      # Debugging utilities\n│   │   ├── __init__.py\n│   │   ├── headers.py              # Diagnostic header injection\n│   │   ├── inspector.py            # Cache state inspection\n│   │   ├── tracing.py              # Request tracing utilities\n│   │   └── simulation.py           # Geo-distribution simulation tools\n│   ├── metrics/                    # Metrics collection\n│   │   ├── __init__.py\n│   │   ├── collectors.py           # Metrics collection logic\n│   │   └── exporters.py            # Export to Prometheus/JSON\n│   └── tests/\n│       ├── __init__.py\n│       ├── test_debug_headers.py\n│       ├── test_cache_inspection.py\n│       └── simulation/             # Simulation tests\n│           ├── test_geo_routing.py\n│           └── test_invalidation_propagation.py\n```\n\n**C. Infrastructure Starter Code**\n\nHere's a complete, ready-to-use diagnostic header middleware for Python:\n\n```python\n# src/debug/headers.py\nimport time\nimport uuid\nfrom typing import Dict, Tuple, Optional\n\nclass DiagnosticHeaders:\n    \"\"\"Middleware for adding diagnostic headers to HTTP responses.\"\"\"\n    \n    def __init__(self, node_id: str = \"local\"):\n        self.node_id = node_id\n        \n    def add_cache_headers(self,\n                         status: str,\n                         cache_key: str,\n                         cache_entry: Optional['CacheEntry'],\n                         response_headers: Dict[str, str]) -> Dict[str, str]:\n        \"\"\"Add cache-related diagnostic headers to response.\"\"\"\n        headers = response_headers.copy()\n        \n        # Always add cache status and node ID\n        headers['X-Cache-Status'] = status\n        headers['X-Edge-Node'] = self.node_id\n        \n        # Add cache key for debugging\n        headers['X-Cache-Key'] = cache_key\n        \n        # Add cache age and TTL if we have a cache entry\n        if cache_entry:\n            current_time = time.time()\n            age = int(current_time - cache_entry.fetched_at)\n            ttl = int(cache_entry.expires_at - current_time) if cache_entry.expires_at > current_time else 0\n            \n            headers['X-Cache-Age'] = str(age)\n            headers['X-Cache-TTL'] = str(ttl)\n            \n            # Add vary header info if present\n            if cache_entry.vary_headers:\n                vary_list = ','.join(f\"{k}:{v}\" for k, v in cache_entry.vary_headers.items())\n                headers['X-Vary-Headers'] = vary_list\n        \n        return headers\n    \n    def generate_request_id(self, existing_id: Optional[str] = None) -> str:\n        \"\"\"Generate or propagate request ID for tracing.\"\"\"\n        if existing_id and existing_id.strip():\n            return existing_id\n        return f\"req_{uuid.uuid4().hex[:16]}\"\n    \n    def add_tracing_headers(self,\n                           request_headers: Dict[str, str],\n                           response_headers: Dict[str, str]) -> Dict[str, str]:\n        \"\"\"Add distributed tracing headers to response.\"\"\"\n        headers = response_headers.copy()\n        \n        # Get or generate request ID\n        request_id = self.generate_request_id(\n            request_headers.get('X-Request-ID') or request_headers.get('x-request-id')\n        )\n        headers['X-Request-ID'] = request_id\n        \n        # Add timing information\n        headers['X-Processed-At'] = str(time.time())\n        \n        return headers\n```\n\n**D. Core Logic Skeleton Code**\n\nHere's skeleton code for the cache inspection debug endpoint:\n\n```python\n# src/debug/inspector.py\nfrom typing import Dict, Any, List\nimport json\nimport time\n\nclass CacheInspector:\n    \"\"\"Debug endpoint for inspecting cache state.\"\"\"\n    \n    def __init__(self, cache_storage: 'CacheStorage', \n                 key_index: Optional['SurrogateKeyIndex'] = None,\n                 ban_rules: Optional[List['BanRule']] = None):\n        self.cache = cache_storage\n        self.key_index = key_index\n        self.ban_rules = ban_rules or []\n    \n    def handle_debug_request(self, path: str, \n                            query_params: Dict[str, str]) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"Handle GET /debug/cache[/subpath] requests.\"\"\"\n        # TODO 1: Parse path to determine what to inspect:\n        #   - /debug/cache/entries: List all cache entries\n        #   - /debug/cache/keys: List just cache keys\n        #   - /debug/cache/tags: Show tag-to-key mappings\n        #   - /debug/cache/bans: Show active ban rules\n        \n        # TODO 2: For /debug/cache/entries, iterate through cache\n        #   and collect entry metadata without full bodies\n        \n        # TODO 3: For /debug/cache/tags, use key_index.get_keys_for_tag\n        #   to show all tag associations\n        \n        # TODO 4: For /debug/cache/bans, list all active ban rules\n        #   with their patterns, creation time, and TTL\n        \n        # TODO 5: Apply query filters:\n        #   - ?url=pattern: Filter by URL pattern\n        #   - ?tag=name: Filter by surrogate key\n        #   - ?limit=N: Limit number of results\n        \n        # TODO 6: Format results as JSON with appropriate structure\n        \n        # TODO 7: Return HTTP 200 with application/json content-type\n        \n        # TODO 8: Handle errors gracefully (e.g., missing key_index)\n        \n        pass\n    \n    def _get_cache_entries_summary(self, limit: int = 100) -> List[Dict[str, Any]]:\n        \"\"\"Get summary of cache entries without full bodies.\"\"\"\n        # TODO 1: Get list of all cache keys from storage\n        \n        # TODO 2: For each key, retrieve cache entry metadata\n        \n        # TODO 3: Extract key information: url, fetched_at, expires_at, \n        #   size, surrogate_keys, hit_count\n        \n        # TODO 4: Apply limit and return list of summaries\n        \n        pass\n    \n    def _get_tag_mappings(self) -> Dict[str, Any]:\n        \"\"\"Get surrogate key index mappings.\"\"\"\n        # TODO 1: Check if key_index is available\n        \n        # TODO 2: Return tag_to_keys and key_to_tags structures\n        \n        # TODO 3: Include statistics: total tags, avg keys per tag\n        \n        pass\n```\n\n**E. Language-Specific Hints**\n\n- **Python's `asyncio` debugging**: Use `asyncio.create_task()` for background revalidation but capture exceptions with `task.add_done_callback()` to avoid silent failures.\n- **Memory profiling**: Use `tracemalloc` to track cache memory usage and identify leaks in cache storage implementation.\n- **Timing measurements**: Use `time.perf_counter()` for high-resolution timing in critical paths (cache lookups, upstream fetches).\n- **GeoIP database**: Use `maxminddb-geolite2` package for development GeoIP database, but remember it's not updated in real-time.\n\n**F. Milestone Checkpoint**\n\nAfter implementing debugging features, verify them with:\n\n```bash\n# Start edge node with debug endpoints enabled\npython src/edge_server.py --port 8080 --debug\n\n# Test diagnostic headers\ncurl -v http://localhost:8080/image.jpg\n\n# Look for headers:\n# X-Cache-Status: MISS (first time) or HIT (subsequent)\n# X-Cache-Key: /image.jpg (or with vary dimensions)\n# X-Edge-Node: local\n# X-Request-ID: req_abcdef1234567890\n\n# Test cache inspection endpoint\ncurl http://localhost:8080/debug/cache/entries?limit=5\n\n# Expected: JSON array of cache entries with metadata\n# [{\"key\": \"...\", \"url\": \"...\", \"fetched_at\": 123.45, ...}]\n\n# Test invalidation and verify via debug endpoint\ncurl -X PURGE http://localhost:8080/image.jpg\ncurl http://localhost:8080/debug/cache/entries | grep image.jpg\n# Should show no entries or stale status\n```\n\n**G. Debugging Tips**\n\n| Symptom | How to Diagnose | Fix |\n|---------|-----------------|-----|\n| Diagnostic headers missing | Check middleware order in request handler | Ensure `DiagnosticHeaders` processes responses before sending |\n| Cache inspection endpoint slow | Profile `_get_cache_entries_summary` with large cache | Implement pagination and limit full scan frequency |\n| Request ID not propagating | Trace headers through edge → shield → origin | Ensure each component reads and forwards `X-Request-ID` |\n| Simulation not reflecting real behavior | Compare latency measurements with production-like conditions | Add jitter, packet loss, and bandwidth constraints to simulation |\n\n\n## Future Extensions\n\n> **Milestone(s):** This section explores potential enhancements beyond the foundational five milestones, showing how the current architecture accommodates future growth and more advanced CDN features.\n\nThe \"Blue Origin\" CDN you've built represents a solid foundation for content delivery, but like any production system, it will naturally evolve to meet new requirements and leverage emerging technologies. This section explores several **natural extensions** that build upon the existing architecture without requiring fundamental redesigns. Each extension demonstrates how the modular, layered design enables incremental enhancement—a key principle of sustainable system architecture.\n\n### Mental Model: The Highway System Evolution\n\nImagine the current CDN as a basic interstate highway system connecting cities (origin) to suburbs (users) with well-designed on-ramps (edge nodes), rest stops (shields), and traffic control systems (routing). The foundational system efficiently moves standard vehicles (HTTP content) between points. Future extensions are analogous to:\n\n1. **Express lanes for predictable commuters** → **Prefetching** anticipates regular traffic patterns\n2. **Vehicle modification stations** → **Image optimization** transforms content for different vehicles\n3. **Real-time convoy coordination** → **WebSocket proxying** maintains persistent connections\n4. **Integration with shipping warehouses** → **Object storage** connects to cloud-native origins\n\nEach extension builds upon the existing infrastructure rather than replacing it, demonstrating the power of well-defined interfaces and separation of concerns.\n\n### Potential Enhancements\n\n#### 1. Predictive Prefetching and Cache Warming\n\n**What it is:** Automatically fetching content before users request it, based on access patterns, link analysis, or explicit hints.\n\n**Why it's valuable:** Dramatically improves cache hit ratios for predictable traffic patterns (daily content updates, scheduled releases, trending content). Reduces perceived latency to near-zero for prefetched resources.\n\n**How it integrates with current design:**\n\n| Integration Point | Extension Required |\n|-------------------|-------------------|\n| Edge Cache Storage | New `prefetch_queue` field in `EdgeConfig` to manage background fetch jobs |\n| Control Plane | New prefetch scheduler analyzing access logs and content relationships |\n| Edge Node Routing | Enhanced `EdgeRequestHandler` with predictive logic before cache check |\n| Analytics | New `PrefetchMetrics` tracking hit rates on prefetched content |\n\n**Design considerations:**\n\n> **Decision: Client-Driven vs. Server-Driven Prefetching**\n> - **Context**: We need to decide who initiates prefetch operations—the edge node (server-driven) or the client (via hints like Link headers).\n> - **Options Considered**:\n>   1. **Server-driven predictive prefetching**: Edge nodes analyze access patterns and automatically fetch likely-next resources\n>   2. **Client-driven hint-based prefetching**: Use HTTP `Link` headers with `rel=\"prefetch\"` or `rel=\"preload\"`\n>   3. **Hybrid approach**: Combine server predictions with client hints for highest accuracy\n> - **Decision**: Start with client-driven prefetching using standard HTTP headers\n> - **Rationale**: Client hints are standardized (RFC 5988), deterministic, and don't require complex machine learning. Server-driven prefetching risks wasteful bandwidth usage if predictions are wrong.\n> - **Consequences**: Simpler implementation, respects origin bandwidth, but misses opportunities where clients don't send hints.\n\n**Implementation approach:**\n1. Extend `EdgeRequestHandler.handle_request()` to parse `Link` headers with `rel=\"prefetch\"` or `rel=\"preload\"`\n2. Add background worker pool to asynchronously fetch linked resources\n3. Store prefetched content with lower priority (evicted first under memory pressure)\n4. Add `X-CDN-Prefetch: hit/miss` diagnostic headers to track effectiveness\n\n**Challenges:**\n- **Cache pollution**: Prefetched content that's never used wastes storage and bandwidth\n- **Origin load spikes**: Aggressive prefetching could overwhelm origins\n- **Priority inversion**: Prefetching shouldn't block real user requests\n\n**Solution patterns:**\n- Implement prefetch budget limiting (max concurrent prefetches per edge)\n- Use TTL-based decay for prefetch priority (older predictions less valuable)\n- Add `prefetch` flag to `CacheEntry` to track prefetched vs. demand-fetched content\n\n#### 2. Image Optimization at the Edge\n\n**What it is:** On-the-fly resizing, format conversion (WebP/AVIF), compression, and quality adjustment for images based on client device and network conditions.\n\n**Why it's valuable:** Images typically constitute 60-80% of page weight. Optimizing them at the edge reduces bandwidth costs, improves page load times, and provides better user experience across diverse devices.\n\n**How it integrates with current design:**\n\n| Component | Enhancement Required |\n|-----------|----------------------|\n| Edge Cache | New `ImageOptimizer` component with format detection and conversion |\n| Cache Key Generation | Include image transformation parameters in cache key |\n| Content Negotiation | Enhanced `Accept` header parsing for image formats |\n| Response Headers | Add `Content-DPR`, `Content-Width` headers for responsive images |\n\n**Key data structures:**\n\n| Structure Name | Fields | Purpose |\n|----------------|--------|---------|\n| `ImageTransformation` | `format: str`, `width: int`, `height: int`, `quality: int`, `crop: bool`, `dpr: float` | Defines transformation parameters for an image |\n| `DeviceProfile` | `dpi: int`, `max_width: int`, `supported_formats: List[str]`, `network_type: str` | Client device capabilities for adaptive optimization |\n| `OptimizedImageCacheKey` | `original_key: str`, `transformation: ImageTransformation`, `variant_hash: str` | Composite key for transformed image variants |\n\n**Workflow:**\n1. Client request includes `Accept` header with preferred image formats and `DPR` (Device Pixel Ratio) header\n2. `EdgeRequestHandler` checks for existing optimized variant in cache\n3. On miss, fetch original from upstream (or from cache if original exists)\n4. Apply transformations using `ImageOptimizer.transform(image_bytes, transformation)`\n5. Store transformed variant with separate `CacheEntry` and TTL\n6. Serve optimized image with appropriate `Content-Type` and `Vary: Accept, DPR`\n\n**Performance optimization strategies:**\n\n| Strategy | Implementation | Benefit |\n|----------|----------------|---------|\n| Lazy transformation | Only transform on demand, not preemptively | Reduces CPU and storage waste |\n| Progressive rendering | Serve low-quality placeholder first, then enhance | Improves perceived performance |\n| Format fallback chain | Try WebP → JPEG → PNG based on client support | Maximizes compression benefits |\n| Dimension-aware caching | Cache common sizes (320w, 640w, 1024w, etc.) | Increases cache hit ratio across devices |\n\n**Challenges and solutions:**\n\n⚠️ **Pitfall: CPU exhaustion at edge**\n- **Problem**: Image transformation is CPU-intensive; under heavy load, edge nodes could become compute-bound\n- **Solution**: Implement request queuing with priority (user requests > optimization), and limit concurrent transformations per node\n\n⚠️ **Pitfall: Storage explosion**\n- **Problem**: Each image could have dozens of variants (formats × sizes × qualities)\n- **Solution**: Use LRU with lower TTL for variants, implement variant garbage collection based on access patterns\n\n#### 3. WebSocket Proxying and Edge Compute\n\n**What it is:** Extending the CDN to proxy WebSocket connections and execute lightweight compute functions at the edge.\n\n**Why it's valuable:** Modern applications increasingly use real-time bidirectional communication (chat, gaming, collaborative editing). Edge compute enables custom logic execution close to users (A/B testing, personalization, authentication).\n\n**How it integrates with current design:**\n\n| Current Component | WebSocket Extension | Edge Compute Extension |\n|-------------------|---------------------|------------------------|\n| Edge Node | WebSocket handshake handling, connection pooling | Python/JavaScript runtime sandbox |\n| Cache Storage | Session state storage (limited TTL) | Function code cache with invalidation |\n| Routing | Connection-aware sticky routing | Function registry and versioning |\n| Metrics | Connection count, message rates, uptime | Execution time, memory usage, error rates |\n\n**WebSocket proxying architecture:**\n\n```\nClient ──WS──> Edge Node ──WS──> Origin\n           │                     │\n           ├── Message Cache ────┘ (for pub/sub patterns)\n           └── Connection Pool ──── (reuse origin connections)\n```\n\n**Key considerations for WebSocket support:**\n\n1. **Connection lifecycle management**: WebSocket connections are long-lived (hours/days vs HTTP's seconds)\n2. **Message caching**: Some pub/sub patterns benefit from edge caching of broadcast messages\n3. **Sticky routing**: Once a WebSocket connects to an edge node, subsequent HTTP requests should route to same node (for session consistency)\n4. **Protocol upgrade handling**: Proper HTTP/1.1 Upgrade header processing with fallback\n\n**Edge compute implementation pattern:**\n\n```python\n# Pseudo-structure (not Layer 1 code, but conceptual)\nclass EdgeFunction:\n    name: str\n    version: str\n    code_hash: str  # For cache invalidation\n    runtime: str    # \"python\", \"javascript\"\n    memory_limit_mb: int\n    timeout_ms: int\n    env_vars: Dict[str, str]\n    \nclass EdgeFunctionRuntime:\n    async def execute(function: EdgeFunction, \n                     request: HttpRequest, \n                     context: ExecutionContext) -> HttpResponse:\n        # Isolate in sandbox, enforce limits, collect metrics\n```\n\n**Security considerations critical for edge compute:**\n\n| Concern | Mitigation Strategy |\n|---------|---------------------|\n| Code injection | Strict sandboxing (seccomp, namespaces, cgroups) |\n| Resource exhaustion | Hard limits on memory, CPU time, execution duration |\n| Data leakage | Encryption at rest, process isolation between tenants |\n| DoS amplification | Rate limiting per function, global resource quotas |\n\n**Integration with cache invalidation:** Edge functions can trigger cache purges programmatically, enabling dynamic content generation with automatic invalidation.\n\n#### 4. Object Storage Integration as Origin\n\n**What it is:** Treating cloud object storage (AWS S3, Google Cloud Storage, Azure Blob Storage) as a first-class origin, with optimized protocols and caching semantics.\n\n**Why it's valuable:** Modern applications increasingly store static assets in object storage. Direct integration reduces latency (no intermediary web server) and leverages storage-native features (versioning, lifecycle policies).\n\n**How it integrates with current design:**\n\n| CDN Component | Object Storage Integration |\n|---------------|----------------------------|\n| Origin Shield | S3 API client with signature v4 authentication |\n| Cache Invalidation | S3 event notification integration (purge on object update) |\n| Range Requests | Native support for S3's multipart and range requests |\n| TTL Management | Respect S3 metadata (Cache-Control headers on objects) |\n\n**Optimization opportunities specific to object storage:**\n\n1. **Parallel range fetching**: For large files, fetch chunks in parallel from S3\n2. **Prefix-based caching**: Special handling for directory-like listings\n3. **Version-aware caching**: Cache multiple versions of same object key\n4. **Lifecycle synchronization**: Automatically purge when S3 lifecycle policy deletes objects\n\n**Data flow for S3-backed origin:**\n\n```\nEdge Node → Origin Shield → S3 API Endpoint\n    ↑           ↑                ↑\n    Cache     Transform      Authentication\n    Layer    HTTP to S3       (SigV4)\n              Protocol\n```\n\n**Implementation details:**\n\n- Extend `_fetch_from_upstream()` in `ShieldRequestHandler` to handle S3-specific HTTP headers (`x-amz-*`)\n- Implement S3 authentication (AWS Signature Version 4) for private buckets\n- Parse S3 error responses and convert to appropriate HTTP status codes\n- Handle S3's multipart upload references for large objects\n\n**Challenges and solutions:**\n\n⚠️ **Pitfall: Authentication token management**\n- **Problem**: S3 requires frequent signature rotation; hardcoding credentials is insecure\n- **Solution**: Implement IAM role assumption with temporary credentials, refreshed automatically\n\n⚠️ **Pitfall: S3 eventual consistency**\n- **Problem**: S3 offers eventual consistency for overwrite PUTs and DELETEs\n- **Solution**: Implement read-after-write consistency verification or use S3 Strong Consistency where available\n\n#### 5. Additional Extension Ideas\n\n**Real-time Analytics Pipeline:** Extend the `EdgeMetrics` collection to stream to a time-series database (InfluxDB, TimescaleDB) for real-time dashboards and anomaly detection.\n\n**Advanced Compression:** Add Zstandard (zstd) support alongside Brotli and gzip, with adaptive compression level based on content type and client capabilities.\n\n**Video Streaming Optimizations:** \n- HLS/DASH manifest manipulation at edge\n- Per-title encoding ladder optimization\n- Buffer management for adaptive bitrate streaming\n- Prefetching of video segments based on playback rate\n\n**Security Enhancements:**\n- DDoS protection with rate limiting and challenge-response\n- WAF (Web Application Firewall) rules execution at edge\n- Bot detection and mitigation\n- TLS 1.3 with early data support\n\n**Multi-CDN Failover:** Integrate with commercial CDNs as fallback origins, implementing health-based routing between your CDN and third-party providers.\n\n### Architectural Principles for Extensibility\n\nThe current \"Blue Origin\" CDN design follows several principles that make these extensions feasible:\n\n1. **Interface-based design**: Clear boundaries between components (cache storage, request handlers, routing) allow swapping implementations\n2. **Pluggable middleware**: The request processing pipeline can be extended with additional handlers (compression, optimization, authentication)\n3. **Configuration-driven behavior**: `EdgeConfig` provides hooks for enabling/disabling features without code changes\n4. **Observability first**: Built-in metrics collection makes it easy to track the impact of new features\n5. **Graceful degradation**: Circuit breakers and fallback mechanisms ensure new features don't break core functionality\n\n### Prioritization Framework\n\nWhen deciding which extensions to implement first, consider this decision matrix:\n\n| Extension | User Impact | Implementation Complexity | Operational Overhead | Alignment with Trends |\n|-----------|-------------|---------------------------|----------------------|----------------------|\n| Image Optimization | High (60%+ bandwidth savings) | Medium (requires image libraries) | Medium (CPU intensive) | High (Core Web Vitals) |\n| WebSocket Proxying | Medium (real-time apps) | High (stateful connections) | High (connection management) | Medium (growing but not universal) |\n| Object Storage Integration | High (cloud-native apps) | Low (protocol translation) | Low (stateless) | High (cloud migration) |\n| Predictive Prefetching | Medium (reduced latency) | High (ML/pattern analysis) | Medium (extra origin load) | Medium (established technique) |\n\n> **Design Insight**: Start with object storage integration—it provides immediate value for modern applications with relatively low complexity. Follow with image optimization, which delivers tangible performance improvements users can feel.\n\n### Testing Extended Functionality\n\nEach extension requires specific testing strategies:\n\n| Extension | Test Category | Specific Considerations |\n|-----------|---------------|-------------------------|\n| Image Optimization | Visual regression | Ensure transformations don't corrupt images |\n| WebSocket Proxying | Load/stress testing | Handle thousands of concurrent connections |\n| Object Storage | Integration testing | Mock S3 API with moto or localstack |\n| Edge Compute | Security testing | Fuzz testing for sandbox escape vulnerabilities |\n\n### Migration Path from Foundation to Extended CDN\n\nThe modular design allows incremental adoption:\n\n**Phase 1: Foundation** (Milestones 1-5) → Basic caching, routing, shielding\n**Phase 2: Optimization** (+Image optimization, +Advanced compression) → Better performance\n**Phase 3: Modernization** (+Object storage, +Prefetching) → Cloud-native compatibility  \n**Phase 4: Real-time** (+WebSocket, +Edge compute) → Application platform\n\nEach phase delivers value independently while building toward a comprehensive edge delivery platform.\n\n### Implementation Guidance\n\nWhile full implementation of all extensions is beyond this foundational guide, here's how to approach the first natural extension: **Object Storage Integration**.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| S3 Client | `boto3` (Python AWS SDK) | Custom HTTP client with connection pooling |\n| Authentication | IAM instance profiles | AssumeRole with temporary credentials |\n| Error Handling | Basic retry with exponential backoff | Circuit breaker with fallback to HTTP origin |\n| Testing | `moto` library for mocking | LocalStack for full S3 API simulation |\n\n#### B. Recommended Module Structure\n\n```\nblue_origin/\n├── origins/                    # New package for origin implementations\n│   ├── __init__.py\n│   ├── base.py                # Abstract OriginClient\n│   ├── http_origin.py         # Existing HTTP origin client\n│   ├── s3_origin.py           # New S3 origin client\n│   └── multi_origin.py        # Fallback across multiple origins\n├── shield/\n│   └── handler.py             # Updated to use OriginClient interface\n└── config/\n    └── origin_config.py       # Origin-specific configuration\n```\n\n#### C. Infrastructure Starter Code\n\n```python\n# origins/base.py - Abstract interface for origin implementations\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Tuple, Optional\nimport asyncio\n\nclass OriginClient(ABC):\n    \"\"\"Abstract base class for origin implementations.\"\"\"\n    \n    @abstractmethod\n    async def fetch(\n        self,\n        path: str,\n        method: str = \"GET\",\n        headers: Optional[Dict[str, str]] = None,\n        body: Optional[bytes] = None\n    ) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"Fetch resource from origin.\"\"\"\n        pass\n    \n    @abstractmethod\n    def should_cache_response(self, status_code: int, headers: Dict[str, str]) -> bool:\n        \"\"\"Determine if response from this origin should be cached.\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_cache_key_prefix(self) -> str:\n        \"\"\"Get prefix for cache keys from this origin (for isolation).\"\"\"\n        pass\n\n# origins/s3_origin.py - S3 implementation starter\nimport hashlib\nimport hmac\nfrom datetime import datetime\nfrom urllib.parse import urlparse, quote\nfrom typing import Dict, Tuple, Optional\nimport aiohttp\n\nclass S3OriginClient(OriginClient):\n    \"\"\"Origin client for Amazon S3 and compatible object storage.\"\"\"\n    \n    def __init__(\n        self,\n        endpoint: str,\n        bucket: str,\n        region: str = \"us-east-1\",\n        access_key: Optional[str] = None,\n        secret_key: Optional[str] = None,\n        session_token: Optional[str] = None,\n        use_iam_role: bool = False\n    ):\n        self.endpoint = endpoint.rstrip('/')\n        self.bucket = bucket\n        self.region = region\n        self.access_key = access_key\n        self.secret_key = secret_key\n        self.session_token = session_token\n        self.use_iam_role = use_iam_role\n        \n        # Connection pool for S3 requests\n        self.session = aiohttp.ClientSession()\n        \n    def _sign_request(self, method: str, path: str, headers: Dict[str, str]) -> Dict[str, str]:\n        \"\"\"Generate AWS Signature Version 4 for the request.\"\"\"\n        # TODO: Implement AWS SigV4 signing\n        # This is complex but follows a standard algorithm:\n        # 1. Create canonical request\n        # 2. Create string to sign\n        # 3. Calculate signature\n        # 4. Add authorization header\n        pass\n    \n    async def fetch(\n        self,\n        path: str,\n        method: str = \"GET\",\n        headers: Optional[Dict[str, str]] = None,\n        body: Optional[bytes] = None\n    ) -> Tuple[int, Dict[str, str], bytes]:\n        \"\"\"Fetch object from S3.\"\"\"\n        if headers is None:\n            headers = {}\n            \n        # Build S3 URL\n        s3_path = quote(path.lstrip('/'))\n        url = f\"{self.endpoint}/{self.bucket}/{s3_path}\"\n        \n        # Add S3-specific headers\n        s3_headers = headers.copy()\n        if body:\n            s3_headers['Content-Length'] = str(len(body))\n        \n        # Sign the request if using credentials\n        if self.access_key and self.secret_key:\n            s3_headers = self._sign_request(method, path, s3_headers)\n        \n        # Make request to S3\n        async with self.session.request(\n            method=method,\n            url=url,\n            headers=s3_headers,\n            data=body\n        ) as response:\n            status = response.status\n            response_headers = dict(response.headers)\n            response_body = await response.read()\n            \n            # Convert S3 errors to appropriate HTTP status\n            if status == 404 and 'Error' in response_headers.get('x-amz-error-code', ''):\n                # S3 returns 404 for missing objects, which is correct\n                pass\n            elif status == 403:\n                # Permission denied - might want to log this differently\n                pass\n                \n            return status, response_headers, response_body\n    \n    def should_cache_response(self, status_code: int, headers: Dict[str, str]) -> bool:\n        \"\"\"S3-specific caching logic.\"\"\"\n        # Cache successful GETs and 404s (negative caching)\n        if status_code == 200:\n            return True\n        elif status_code == 404:\n            # Negative cache 404s for shorter TTL\n            return True\n        return False\n    \n    def get_cache_key_prefix(self) -> str:\n        \"\"\"Isolate S3 cache entries from HTTP origin entries.\"\"\"\n        return f\"s3:{self.bucket}:\"\n    \n    async def close(self):\n        \"\"\"Cleanup connection pool.\"\"\"\n        await self.session.close()\n\n# config/origin_config.py - Configuration for multiple origin types\nfrom enum import Enum\nfrom typing import Union, Dict, Any\nfrom pydantic import BaseModel\n\nclass OriginType(str, Enum):\n    HTTP = \"http\"\n    S3 = \"s3\"\n    GOOGLE_STORAGE = \"google_storage\"\n    AZURE_BLOB = \"azure_blob\"\n\nclass HttpOriginConfig(BaseModel):\n    url: str\n    health_check_path: str = \"/health\"\n    timeout_seconds: int = 30\n\nclass S3OriginConfig(BaseModel):\n    endpoint: str\n    bucket: str\n    region: str = \"us-east-1\"\n    access_key: Optional[str] = None\n    secret_key: Optional[str] = None\n    use_iam_role: bool = False\n    force_path_style: bool = False\n\nclass OriginConfig(BaseModel):\n    type: OriginType\n    config: Union[HttpOriginConfig, S3OriginConfig, Dict[str, Any]]\n    fallback_to: Optional[List[str]] = None  # List of other origin IDs to try\n```\n\n#### D. Core Logic Skeleton for Shield Integration\n\n```python\n# shield/handler.py - Updated to support multiple origin types\nimport asyncio\nfrom typing import Dict, Optional, Tuple\nfrom origins.base import OriginClient\nfrom origins.s3_origin import S3OriginClient\nfrom origins.http_origin import HttpOriginClient\n\nclass ShieldRequestHandler:\n    def __init__(\n        self,\n        cache: CacheStorage,\n        origin_configs: Dict[str, OriginConfig],  # Multiple origins by ID\n        default_origin: str,  # ID of default origin\n        coalescing_map: RequestCoalescingMap,\n        max_concurrent_requests: int = 100\n    ):\n        self.cache = cache\n        self.origin_configs = origin_configs\n        self.default_origin = default_origin\n        self.coalescing_map = coalescing_map\n        self._origin_semaphore = asyncio.Semaphore(max_concurrent_requests)\n        \n        # Initialize origin clients\n        self.origin_clients: Dict[str, OriginClient] = {}\n        self._init_origin_clients()\n    \n    def _init_origin_clients(self):\n        \"\"\"Initialize origin clients from configuration.\"\"\"\n        for origin_id, config in self.origin_configs.items():\n            if config.type == OriginType.HTTP:\n                self.origin_clients[origin_id] = HttpOriginClient(\n                    base_url=config.config.url,\n                    timeout=config.config.timeout_seconds\n                )\n            elif config.type == OriginType.S3:\n                s3_config = config.config\n                self.origin_clients[origin_id] = S3OriginClient(\n                    endpoint=s3_config.endpoint,\n                    bucket=s3_config.bucket,\n                    region=s3_config.region,\n                    access_key=s3_config.access_key,\n                    secret_key=s3_config.secret_key,\n                    use_iam_role=s3_config.use_iam_role\n                )\n            # TODO: Add other origin types\n    \n    def _determine_origin(self, request_headers: Dict[str, str]) -> str:\n        \"\"\"Determine which origin to use for this request.\"\"\"\n        # TODO 1: Check for X-Origin-Override header for explicit origin selection\n        # TODO 2: Parse URL path to determine bucket/namespace for routing\n        # TODO 3: Check origin health status (circuit breakers)\n        # TODO 4: Return origin ID or raise exception if no healthy origin\n        return self.default_origin\n    \n    async def handle_request(\n        self, \n        request_headers: Dict[str, str], \n        request_body: Optional[bytes]\n    ) -> Tuple[int, Dict[str, str], bytes]:\n        # ... existing cache logic ...\n        \n        # On cache miss or need to revalidate:\n        origin_id = self._determine_origin(request_headers)\n        origin_client = self.origin_clients[origin_id]\n        \n        # TODO: Add origin-specific cache key prefix\n        cache_key = self._generate_cache_key(request_headers, origin_id)\n        \n        # Use the generic origin client interface\n        async with self._origin_semaphore:\n            status, headers, body = await origin_client.fetch(\n                path=request_path,\n                method=request_method,\n                headers=request_headers,\n                body=request_body\n            )\n        \n        # TODO: Store with origin-specific TTL logic\n        if origin_client.should_cache_response(status, headers):\n            cache_entry = CacheEntry.from_upstream_response(\n                key=cache_key,\n                url=request_url,\n                vary_headers=vary_dict,\n                status_code=status,\n                headers=headers,\n                body=body,\n                surrogate_keys=self._extract_surrogate_keys(headers)\n            )\n            await self.cache.store(cache_entry)\n        \n        return status, headers, body\n    \n    async def _revalidate_in_background(\n        self, \n        cache_key: str, \n        stale_entry: CacheEntry, \n        request_headers: Dict[str, str]\n    ):\n        \"\"\"Revalidate with appropriate origin based on cache entry metadata.\"\"\"\n        # TODO 1: Extract origin ID from cache key or entry metadata\n        # TODO 2: Get origin client for that origin\n        # TODO 3: Perform conditional revalidation (If-None-Match, If-Modified-Since)\n        # TODO 4: Update cache if changed, respecting origin-specific caching rules\n        pass\n```\n\n#### E. Language-Specific Hints for Python\n\n- Use `aioboto3` for async S3 operations instead of synchronous `boto3`\n- Implement connection pooling with `aiohttp.ClientSession` for S3 requests\n- Use `pydantic` for configuration validation with discriminated unions\n- Consider `smart_open` library for streaming large files from S3 efficiently\n- For image optimization, `Pillow` is the standard library, but consider `wand` (ImageMagick bindings) for advanced transformations\n\n#### F. Testing Extended Features\n\n```python\n# tests/test_s3_origin.py - Example test with moto\nimport pytest\nimport boto3\nfrom moto import mock_s3\nfrom origins.s3_origin import S3OriginClient\n\n@mock_s3\n@pytest.mark.asyncio\nasync def test_s3_origin_fetch():\n    \"\"\"Test fetching object from mocked S3.\"\"\"\n    # Setup mock S3\n    s3 = boto3.client('s3', region_name='us-east-1')\n    s3.create_bucket(Bucket='test-bucket')\n    s3.put_object(\n        Bucket='test-bucket',\n        Key='test/image.jpg',\n        Body=b'test image content',\n        ContentType='image/jpeg'\n    )\n    \n    # Create S3 origin client\n    client = S3OriginClient(\n        endpoint='http://localhost:4566',  # LocalStack default\n        bucket='test-bucket',\n        region='us-east-1',\n        access_key='test',\n        secret_key='test'\n    )\n    \n    # Fetch object\n    status, headers, body = await client.fetch('test/image.jpg')\n    \n    assert status == 200\n    assert headers['Content-Type'] == 'image/jpeg'\n    assert body == b'test image content'\n    \n    await client.close()\n```\n\n#### G. Migration Strategy\n\n1. **Phase 1**: Add S3 origin support alongside existing HTTP origin\n2. **Phase 2**: Implement origin routing based on URL prefixes (`/s3/*` → S3, `/*` → HTTP)\n3. **Phase 3**: Add health checking and failover between origins\n4. **Phase 4**: Implement S3 event notifications for cache invalidation\n\nEach phase can be tested and deployed independently, demonstrating the value of incremental extension to a well-architected foundation.\n\n---\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (1 through 5)\n\nThis glossary provides definitions for key terms, acronyms, and domain-specific vocabulary used throughout the Blue Origin CDN design document. Understanding these terms is essential for navigating the complex distributed systems concepts involved in building a content delivery network.\n\n### Term Definitions\n\n| Term | Definition |\n|------|------------|\n| **Anycast** | A network addressing and routing method where the same IP address is announced from multiple locations. When a client sends a request to an anycast IP, network routers direct it to the nearest (in terms of routing hops) location announcing that IP. This is commonly used in CDNs for global load balancing without DNS. |\n| **Background Revalidation** | The process of asynchronously fetching updated content from the origin server while continuing to serve stale cached content to clients. This enables `stale-while-revalidate` behavior where users get fast responses while the cache is refreshed in the background. |\n| **Ban** | A pattern-based invalidation rule that matches URLs using wildcards or regular expressions. When a URL matches a ban rule, the corresponding cache entry is either immediately removed (hard ban) or marked stale (soft ban). Bans are useful for invalidating entire categories of content like `/api/v1/users/*`. |\n| **Ban Rule** | A data structure representing a pattern-based invalidation rule with fields including `pattern` (string pattern to match URLs), `created_at` (timestamp), and `is_soft` (boolean indicating whether it's a soft or hard ban). Ban rules have TTLs and are garbage collected when expired. |\n| **Byte Range** | A specification of start and end byte positions for partial content delivery, represented as a tuple `(start, end)` where `end` is optional. Used in HTTP Range requests to request specific portions of large files like videos. |\n| **Cache Entry** | The core data structure holding a cached HTTP response, including fields like `key` (unique cache identifier), `url` (original request URL), `vary_headers` (dictionary of Vary header values), `status_code`, `headers`, `body`, `fetched_at` (timestamp when fetched), `expires_at` (timestamp when entry expires), `last_used_at` (timestamp of last access), `use_count` (access count for LFU), `surrogate_keys` (list of tags), `etag`, and `last_modified`. |\n| **Cache Hit** | A request that is successfully served from the edge cache without contacting the origin server. This represents optimal performance as the response is delivered from a nearby location with minimal latency. |\n| **Cache Hit Ratio** | The percentage of requests served from cache versus total requests, calculated as `hits / (hits + misses)`. A key performance metric for CDNs indicating caching efficiency. Higher ratios mean less origin load and faster responses. |\n| **Cache Key** | A unique identifier for a cached response constructed from the URL and values of headers specified in the Vary header. For example, if Vary includes \"Accept-Encoding\", then requests for `/image.jpg` with \"gzip\" and \"br\" Accept-Encoding values generate different cache keys. |\n| **Cache Miss** | A request that cannot be served from cache and must be fetched from the upstream source (origin shield or origin server). This occurs when content is not cached, has expired, or has been invalidated. |\n| **Cache Miss Storm** | A sudden surge of cache misses that overwhelms the origin server, often occurring when popular content expires simultaneously or after a cache invalidation. Origin shielding and request collapsing mitigate this problem. |\n| **Cache Poisoning** | A security issue where malicious or incorrect content is cached and served to users. Can occur due to bugs in cache key generation, missing validation, or origin server compromise. Defensive measures include careful cache key construction and origin authentication. |\n| **Cache State Dump** | A JSON representation of all cache entries for inspection and debugging purposes, typically exposed via a `/debug/cache` endpoint. Includes metadata but not response bodies to avoid exposing sensitive data. |\n| **Cache Storage** | An abstract interface for cache storage implementations (in-memory, disk-based, distributed). Provides methods for storing, retrieving, and deleting cache entries. The CDN's caching logic works with this interface regardless of the underlying storage. |\n| **Circuit Breaker** | A resilience pattern that prevents cascading failures by failing fast when upstream services are unhealthy. The circuit has three states: CLOSED (normal operation), OPEN (fail fast, no requests sent), and HALF_OPEN (testing if upstream has recovered). Implemented via the `CircuitBreaker` class with configurable thresholds. |\n| **CircuitBreakerConfig** | Configuration parameters for a circuit breaker including `failure_threshold` (number of failures before opening), `reset_timeout` (time before attempting recovery), `half_open_max_requests` (max requests in half-open state), `half_open_success_threshold` (successes needed to close), and `max_failure_history` (how many failures to track). |\n| **Cold Start** | The performance degradation that occurs when a new edge node starts with an empty cache. Until the cache warms up with frequently requested content, most requests will be cache misses, increasing latency and origin load. Mitigated by cache warming strategies and content prefetching. |\n| **Consistent Hashing** | A distributed hashing technique that minimizes the number of keys that need to be remapped when nodes are added or removed from the system. Keys are mapped to a virtual ring (hash ring), and each node is assigned multiple positions on the ring. When looking up a key, you find the next node clockwise from the key's position. |\n| **Content Delivery Network (CDN)** | A geographically distributed network of proxy servers (edge nodes) that caches content close to users to reduce latency, bandwidth usage, and origin server load. The CDN sits between users and origin servers, accelerating delivery of static and dynamic content. |\n| **Control Plane** | The management layer of the CDN responsible for configuration distribution, analytics collection, health monitoring, and coordination between edge nodes. Handles administrative tasks like cache invalidation propagation but does not process user traffic. |\n| **Data Plane** | The layer that handles actual user traffic (requests and responses) flowing through edge nodes. This is the performance-critical path where caching, compression, and routing decisions happen in real-time. |\n| **Device Pixel Ratio (DPR)** | The ratio between physical pixels and CSS pixels on a device's display. High-DPR devices (like Retina displays) require higher resolution images. The CDN can use this value in image optimization to serve appropriately sized images. |\n| **DNS TTL** | The Time-To-Live value in DNS records that controls how long DNS resolvers cache the response. In geo-routing, short DNS TTLs (e.g., 60 seconds) allow faster failover when edge nodes become unhealthy, at the cost of increased DNS query load. |\n| **Edge Compute** | The capability to execute lightweight compute functions at edge nodes rather than at the origin. Enables personalization, A/B testing, security checks, and dynamic content generation close to users. Represented by the `EdgeFunction` and `EdgeFunctionRuntime` concepts. |\n| **Edge Node/Edge Server/PoP** | A geographically distributed server in a CDN that caches and serves content to nearby users. Also called a Point of Presence (PoP). These nodes form the \"edge\" of the network closest to end users. Each edge node runs the caching logic described in Milestone 1. |\n| **Eventual Consistency** | The property where updates (like cache invalidations) propagate to all nodes eventually, but not immediately. During the propagation window, some users may see stale content while others see fresh content. This trade-off is often accepted for scalability in distributed systems. |\n| **Eventual Invalidation** | A lazy invalidation strategy where a banned cache entry is only removed when it is next accessed, not immediately. This reduces the immediate performance impact of sweeping invalidations but means stale content may remain in cache longer. |\n| **Flight Data Recorders** | Diagnostic headers (like `X-Cache-Status`, `X-Cache-Key`, `X-Node-ID`) that document a request's path through the caching infrastructure. Analogous to aircraft black boxes, they provide visibility for debugging without impacting performance. |\n| **GeoIP Database** | A database that maps IP addresses to geographic locations (country, region, city, coordinates). Used by the CDN's geo-routing system to direct clients to the nearest edge node. Requires regular updates as IP allocations change. |\n| **Geo-Routing** | Directing user requests to the nearest optimal edge node based on geographic location. Uses client IP address lookup in a GeoIP database to determine approximate location, then selects the edge node with lowest network latency or geographic distance. |\n| **Geo Simulation** | Techniques to simulate geographic distribution locally during development and testing, such as using IP address prefixes to represent regions or manually setting location headers. Helps test routing logic without deploying to multiple physical locations. |\n| **Graceful Degradation** | A resilience strategy of serving stale content, reduced functionality, or cached error pages when upstream services are impaired. For example, serving stale content via `stale-if-error` when the origin server is down maintains availability at the cost of freshness. |\n| **Hard Purge** | Immediate deletion of a cache entry from storage. The next request for that content will be a cache miss and fetch fresh content from origin. Provides strong consistency but may cause cache miss storms if popular content is purged. |\n| **Hash Ring** | A virtual circle representing the hash space in consistent hashing, typically using a 32-bit or 64-bit integer range. Nodes are assigned positions on the ring via hash functions, and keys are mapped to the next node clockwise from their hash position. |\n| **Haversine Formula** | An equation used in calculating great-circle distances between two points on a sphere given their longitudes and latitudes. Used in geo-routing to find the geographically closest edge node to a client's location. |\n| **Health Checking** | The process of monitoring node availability and performance to ensure reliable routing. Edge nodes periodically report health metrics to the control plane, which removes unhealthy nodes from rotation. Health checks verify connectivity, latency, and resource utilization. |\n| **Image Optimization** | On-the-fly resizing, format conversion (WebP, AVIF), compression, and quality adjustment of images at the edge based on device capabilities and network conditions. Reduces bandwidth usage and improves page load times. Represented by the `ImageTransformation` and `OptimizedImageCacheKey` structures. |\n| **Invalidation Propagation** | The process of disseminating an invalidation command (purge, ban, tag purge) to all edge nodes in the CDN. Can use pub/sub messaging, control plane broadcasts, or gossip protocols to achieve eventual consistency across nodes. |\n| **Load Testing** | Testing system behavior under production-like load to identify performance bottlenecks, capacity limits, and failure modes. For a CDN, load testing simulates many concurrent users requesting various content types to verify the system can handle peak traffic. |\n| **Negative Caching** | Caching error responses (like 404 Not Found or 503 Service Unavailable) with a short TTL to protect the origin from repeated requests for non-existent or temporarily unavailable resources. Prevents \"cache miss storms\" for error conditions. |\n| **Node Failover** | The process of redirecting traffic from a failed or unhealthy edge node to a backup node. When health checks detect a node failure, the routing system (DNS or anycast) updates to direct new clients to the next-nearest healthy node. |\n| **Object Storage Integration** | Treating cloud object storage services (AWS S3, Google Cloud Storage, Azure Blob Storage) as first-class origins for the CDN. Requires handling authentication, bucket policies, and storage-specific APIs while maintaining caching semantics. |\n| **Origin Client** | An abstract base class for fetching content from different types of origins (HTTP servers, S3 buckets, etc.). Subclasses like `S3OriginClient` implement origin-specific authentication and request handling while presenting a unified interface to the caching layer. |\n| **Origin Routing** | Directing requests to different origins based on rules like path prefixes, hostnames, or geographic location. Enables multi-origin setups where different content comes from different backend systems while appearing as a unified CDN. |\n| **Origin Server** | The ultimate source of truth for web content, also called the \"backend\" or \"source\" server. The CDN fetches content from origin servers when cache misses occur and serves cached copies to users. Origins should implement proper cache control headers. |\n| **Origin Shield/Mid-Tier Cache** | An intermediate caching layer between edge nodes and the origin server that reduces origin load by acting as a shared cache for multiple edge nodes. The shield collapses duplicate requests and queues others, preventing thundering herd problems at the origin. |\n| **Predictive Prefetching** | Automatically fetching content before users request it based on access patterns, link analysis, or machine learning predictions. For example, prefetching linked CSS and JavaScript files when a user requests an HTML page. |\n| **Propagation Delay** | The time it takes for invalidation commands to reach all edge nodes in a distributed CDN. During this window, some users may receive stale content from nodes that haven't yet received the invalidation notice. Systems aim to minimize this delay. |\n| **Property-Based Testing** | A testing methodology that verifies properties hold for all possible inputs rather than specific examples. For caching, properties might include \"cache hit should always return same response as original fetch\" or \"purge should always remove the entry\". |\n| **Pub/Sub Broker** | A message broker that implements the publish-subscribe pattern, allowing components to broadcast messages to multiple subscribers. The `InMemoryPubSubBroker` handles invalidation propagation within a single process, while production systems use distributed brokers like Redis or Kafka. |\n| **Pub/Sub Channel** | A named message bus topic for publish-subscribe messaging. In the CDN, channels like `invalidation` or `health` allow edge nodes to subscribe to relevant updates without knowing about other subscribers. |\n| **Race Condition** | When system behavior depends on the sequence or timing of uncontrollable events. In caching, race conditions can occur when multiple threads simultaneously check cache, miss, and fetch from origin, causing duplicate origin requests or cache corruption. |\n| **Range Request** | An HTTP request for partial content using the Range header (e.g., `Range: bytes=0-999`). Used for video streaming, large file downloads, and resumable transfers. The CDN must handle range requests efficiently without fetching entire files. |\n| **Request Coalescing Map** | An in-memory data structure that tracks in-flight requests for deduplication. When multiple clients request the same uncached resource concurrently, the map ensures only one origin fetch occurs, and all clients wait for that single result. |\n| **Request Collapsing** | Deduplicating concurrent identical requests to the origin. When multiple edge nodes or clients request the same uncached content simultaneously, the shield collapses them into a single origin fetch and shares the response with all requesters. |\n| **Request Tracing** | Tracking a request through all CDN layers using unique IDs (like `X-Request-ID`) that are propagated across service boundaries. Enables distributed debugging by correlating logs and timing information across edge nodes, shields, and origins. |\n| **Soft Purge** | Marking a cache entry as stale while continuing to serve it to clients, then triggering background revalidation from the origin. Provides better user experience than hard purge (no cache miss penalty) but may serve stale content briefly. |\n| **Stale-if-error** | A Cache-Control directive that allows serving stale content when the origin server returns an error (5xx status). This provides graceful degradation during origin outages, maintaining availability at the cost of freshness. |\n| **Stale-while-revalidate** | A Cache-Control directive that allows serving stale content while asynchronously revalidating it in the background. Users get fast responses from cache while the system ensures content freshness for subsequent requests. |\n| **Surrogate Key** | A tag (string identifier) assigned to cache entries for group-based invalidation. Multiple resources (like all images in a product catalog) can share a surrogate key, allowing invalidation of all related content with a single purge command. |\n| **Test Fixture** | Reusable setup and teardown code for tests that creates a known state before tests run and cleans up afterward. For CDN testing, fixtures might start a test origin server, create cache entries, or simulate network conditions. |\n| **Thundering Herd Problem** | A stampede of concurrent requests overwhelming a resource, typically occurring when cached content expires simultaneously or after a cache invalidation. The sudden spike of cache misses can overload origin servers. Mitigated by request collapsing, staggered TTLs, and cache warming. |\n| **Time-to-Live (TTL)** | The duration a cached item is considered fresh before it needs revalidation. Determined by cache control headers with hierarchy: `s-maxage` (for shared caches) > `max-age` > `Expires`. The CDN calculates `expires_at = fetched_at + TTL` for each cache entry. |\n| **TTL Hierarchy** | The precedence order for TTL determination: `s-maxage` (for shared caches like CDNs) takes precedence over `max-age`, which takes precedence over `Expires` header. The CDN uses `s-maxage` when present since it's specifically for intermediary caches. |\n| **Vary Header** | An HTTP response header that indicates which request headers the response varies on. For example, `Vary: Accept-Encoding` means responses differ based on the client's Accept-Encoding header value, requiring separate cache entries for gzip, br, and identity encodings. |\n| **Vary: *** | A special value of the Vary header indicating the response varies on all request headers. According to RFC 9111, this means the response should never be stored in a shared cache, as it's essentially uncacheable for different clients. |\n| **Virtual Node** | Multiple hash positions on a consistent hash ring representing a single physical node. Using multiple virtual nodes per physical node (e.g., 100-200) provides better load distribution and minimizes hotspotting when nodes are added or removed. |\n| **WebSocket Proxying** | Extending the CDN to proxy WebSocket connections between clients and origins, maintaining the bidirectional communication channel while providing caching for initial handshake and potential message inspection/transformation. |\n"}