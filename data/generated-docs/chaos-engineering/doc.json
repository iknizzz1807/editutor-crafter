{"html":"<h1 id=\"chaos-engineering-platform-design-document\">Chaos Engineering Platform: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document describes the design of a Chaos Engineering platform that injects controlled failures into distributed systems to proactively test resilience. The key architectural challenge is building a safe, controlled, and observable failure injection system that can model real-world faults without causing unintended outages.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational requirements)</p>\n</blockquote>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<p>This section defines the mandatory capabilities and explicit boundaries for the Chaos Engineering Platform. Establishing clear goals and non-goals is critical for maintaining architectural focus and preventing scope creep during implementation. The platform&#39;s primary purpose is to provide a <strong>safe, controlled, and observable</strong> system for proactively testing resilience through controlled failure injection.</p>\n<p>Think of building this platform as creating a <strong>surgical robot for system operations</strong>. A surgical robot must:</p>\n<ol>\n<li><strong>Execute precise, predefined interventions</strong> (specific fault types)</li>\n<li><strong>Maintain constant monitoring of vital signs</strong> (steady-state metrics)</li>\n<li><strong>Include emergency stop mechanisms</strong> (safety abort conditions)</li>\n<li><strong>Operate only on consenting patients</strong> (explicit targeting)</li>\n<li><strong>Leave no permanent damage</strong> (full reversibility)</li>\n</ol>\n<p>This mental model emphasizes the delicate balance between deliberate disruption and absolute safety that defines professional chaos engineering.</p>\n<h3 id=\"must-have-goals\">Must-Have Goals</h3>\n<p>The platform must satisfy the following core requirements, categorized by functional and non-functional dimensions.</p>\n<h4 id=\"functional-goals\">Functional Goals</h4>\n<p>These define what the system must be able to do operationally.</p>\n<table>\n<thead>\n<tr>\n<th>Goal Category</th>\n<th>Specific Requirement</th>\n<th>Description</th>\n<th>Corresponding Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fault Injection</strong></td>\n<td>Network fault primitives</td>\n<td>Inject configurable network latency, packet loss, and bandwidth throttling between services using <code>tc netem</code> and <code>iptables</code>.</td>\n<td>Milestone 1, 5</td>\n</tr>\n<tr>\n<td></td>\n<td>Process and resource faults</td>\n<td>Terminate specified processes and exhaust CPU/memory resources to configurable levels using <code>cgroups</code> and stress utilities.</td>\n<td>Milestone 1, 5</td>\n</tr>\n<tr>\n<td></td>\n<td>Infrastructure fault simulation</td>\n<td>Simulate disk full conditions, DNS failures (NXDOMAIN, timeout), and network partitions between service pairs.</td>\n<td>Milestone 5</td>\n</tr>\n<tr>\n<td></td>\n<td>Reversible fault application</td>\n<td>All faults must be fully reversible with automatic cleanup mechanisms that restore original system state.</td>\n<td>Milestone 1</td>\n</tr>\n<tr>\n<td><strong>Experiment Management</strong></td>\n<td>Hypothesis-driven experiments</td>\n<td>Define experiments with explicit steady-state hypotheses using metric thresholds (e.g., latency &lt; 200ms, error rate &lt; 1%).</td>\n<td>Milestone 2, 4</td>\n</tr>\n<tr>\n<td></td>\n<td>Automated execution lifecycle</td>\n<td>Orchestrate experiment state transitions: baseline validation → fault injection → monitoring → rollback → analysis.</td>\n<td>Milestone 2</td>\n</tr>\n<tr>\n<td></td>\n<td>Safety controls and auto-rollback</td>\n<td>Automatically abort experiments and roll back faults when safety thresholds are breached (error rate &gt; 5%, latency &gt; 1s).</td>\n<td>Milestone 2, 4</td>\n</tr>\n<tr>\n<td></td>\n<td>Blast radius control</td>\n<td>Limit experiment scope to specific percentages of traffic, specific services, or specific infrastructure components.</td>\n<td>Milestone 4</td>\n</tr>\n<tr>\n<td><strong>Observability &amp; Analysis</strong></td>\n<td>Metrics collection and validation</td>\n<td>Collect system metrics before, during, and after experiments; validate against hypothesis thresholds with statistical tests.</td>\n<td>Milestone 4</td>\n</tr>\n<tr>\n<td></td>\n<td>Comprehensive result reporting</td>\n<td>Generate detailed experiment reports showing hypothesis validation, metric trends, and pass/fail outcomes.</td>\n<td>Milestone 2</td>\n</tr>\n<tr>\n<td></td>\n<td>Observability correlation</td>\n<td>Correlate experiment execution timestamps with application logs, metrics, and traces for root cause analysis.</td>\n<td>Milestone 2</td>\n</tr>\n<tr>\n<td><strong>Scenario Orchestration</strong></td>\n<td>Multi-experiment GameDays</td>\n<td>Execute sequences of experiments with pauses, manual approval gates, and integrated runbooks.</td>\n<td>Milestone 3</td>\n</tr>\n<tr>\n<td></td>\n<td>Automated health checks</td>\n<td>Continuously monitor system health throughout scenario execution with configurable check intervals.</td>\n<td>Milestone 3</td>\n</tr>\n<tr>\n<td></td>\n<td>Incident simulation</td>\n<td>Replicate realistic failure scenarios (e.g., dependency failure, regional outage) in controlled environments.</td>\n<td>Milestone 3</td>\n</tr>\n</tbody></table>\n<h4 id=\"non-functional-goals\">Non-Functional Goals</h4>\n<p>These define the quality attributes the system must exhibit.</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Requirement</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Safety</strong></td>\n<td>Fail-safe design by default</td>\n<td>The platform must never leave systems in a permanently degraded state. Faults must have time limits and automatic rollback.</td>\n</tr>\n<tr>\n<td><strong>Observability</strong></td>\n<td>Comprehensive logging and metrics</td>\n<td>Operators must understand exactly what the platform is doing and its impact on systems. All actions must be logged, and platform health must be monitorable.</td>\n</tr>\n<tr>\n<td><strong>Controllability</strong></td>\n<td>Precise blast radius limitation</td>\n<td>Operators must control which systems are affected and to what degree, preventing uncontrolled cascading failures.</td>\n</tr>\n<tr>\n<td><strong>Operational Simplicity</strong></td>\n<td>Clear operational model and APIs</td>\n<td>The platform should be easy to operate, with intuitive interfaces and clear documentation of its effects and limitations.</td>\n</tr>\n<tr>\n<td><strong>Reliability</strong></td>\n<td>Platform resilience to its own faults</td>\n<td>The chaos platform must not be vulnerable to the faults it injects (e.g., network chaos shouldn&#39;t break the platform&#39;s control plane).</td>\n</tr>\n<tr>\n<td><strong>Performance</strong></td>\n<td>Minimal overhead during non-experiment periods</td>\n<td>When not actively injecting faults, the platform should impose negligible resource overhead on target systems.</td>\n</tr>\n<tr>\n<td><strong>Security</strong></td>\n<td>Principle of least privilege</td>\n<td>The platform requires elevated privileges (CAP_NET_ADMIN, root) for fault injection but must operate with minimal necessary permissions and include access controls.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Principle: Safety First</strong>\nThe most critical non-functional requirement is safety. Every architectural decision must prioritize preventing unintended production outages. This includes automatic rollback mechanisms, comprehensive pre-flight checks, and explicit confirmation for production experiments.</p>\n</blockquote>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Clearly stating what the platform will <strong>not</strong> do prevents misunderstanding and sets realistic expectations. These boundaries help focus development efforts on core value.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal</th>\n<th>Rationale</th>\n<th>Alternative/Workaround</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Production testing by default</strong></td>\n<td>The platform is designed for resilience testing, but production experiments require explicit opt-in, additional safeguards, and organizational readiness.</td>\n<td>Default targeting to pre-production/staging environments; require explicit environment flags and manual approval for production.</td>\n</tr>\n<tr>\n<td><strong>Replacing traditional testing</strong></td>\n<td>Chaos engineering complements but does not replace unit, integration, or load testing. It focuses on emergent properties in complex systems.</td>\n<td>Continue existing testing practices; use chaos experiments for resilience validation beyond functional correctness.</td>\n</tr>\n<tr>\n<td><strong>Automated fault discovery</strong></td>\n<td>The platform executes predefined experiments rather than randomly exploring failure modes. Random fault injection (like Chaos Monkey) is a different approach.</td>\n<td>Manual experiment design based on failure mode analysis; consider future extension for automated scenario generation.</td>\n</tr>\n<tr>\n<td><strong>Performance/load testing</strong></td>\n<td>While resource exhaustion faults stress systems, the platform is not optimized for sustained load generation or performance benchmarking.</td>\n<td>Use dedicated load testing tools (e.g., Locust, Gatling) for performance testing; chaos experiments can complement by testing under failure conditions.</td>\n</tr>\n<tr>\n<td><strong>Permanent infrastructure changes</strong></td>\n<td>All faults must be reversible. The platform will not make permanent configuration changes to infrastructure.</td>\n<td>For testing permanent failure scenarios, use isolated environments that can be rebuilt, not modified in-place.</td>\n</tr>\n<tr>\n<td><strong>Cross-cloud/on-premises deployment</strong></td>\n<td>Initial version focuses on single Kubernetes cluster or standalone host deployment patterns.</td>\n<td>Future versions could extend to multi-cloud, but initial complexity is limited to manageable scope.</td>\n</tr>\n<tr>\n<td><strong>Real-time attack simulation</strong></td>\n<td>The platform tests resilience, not security. It will not simulate security breaches or penetration testing scenarios.</td>\n<td>Use dedicated security testing tools for attack simulation; chaos engineering focuses on reliability failures.</td>\n</tr>\n<tr>\n<td><strong>Complete autonomy (no human oversight)</strong></td>\n<td>While automated, the platform requires human oversight for experiment design, approval of production experiments, and analysis of results.</td>\n<td>Maintain manual approval gates for critical experiments; humans interpret results and refine hypotheses.</td>\n</tr>\n<tr>\n<td><strong>Stateful application data corruption</strong></td>\n<td>The platform will not intentionally corrupt application data or databases. Faults are at infrastructure/network level.</td>\n<td>Test data resilience through other means (backup/restore tests); chaos experiments focus on availability, not data integrity.</td>\n</tr>\n<tr>\n<td><strong>Legacy system support</strong></td>\n<td>Initial focus is on containerized and cloud-native workloads with modern observability.</td>\n<td>Older systems may require custom fault injectors or be tested through dependency failure scenarios.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architectural Decision: Development Phasing</strong>\nThe non-goals represent deliberate choices to limit initial scope. By focusing on reversible, infrastructure-level faults in controlled environments, we build a foundation that can safely expand to more ambitious use cases once core safety mechanisms are proven reliable.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>While this section primarily defines requirements, the following implementation considerations emerge from these goals and non-goals.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Initial Implementation)</th>\n<th>Advanced Option (Future Consideration)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fault Injection</strong></td>\n<td>Direct execution of <code>tc</code>, <code>iptables</code>, <code>cgroups</code> commands via Go&#39;s <code>os/exec</code></td>\n<td>eBPF-based fault injection for finer-grained control without external commands</td>\n</tr>\n<tr>\n<td><strong>Experiment Orchestration</strong></td>\n<td>In-memory state machine with file-based persistence</td>\n<td>Distributed state management using etcd or Redis for high availability</td>\n</tr>\n<tr>\n<td><strong>Metrics Collection</strong></td>\n<td>Prometheus queries via HTTP API</td>\n<td>Multiple backend support (Prometheus, Datadog, Cloud Monitoring) with adapter pattern</td>\n</tr>\n<tr>\n<td><strong>Safety Monitoring</strong></td>\n<td>Periodic polling of metrics during experiments</td>\n<td>Streaming metrics analysis with real-time alerting</td>\n</tr>\n<tr>\n<td><strong>API Layer</strong></td>\n<td>RESTful HTTP with JSON serialization</td>\n<td>gRPC with Protocol Buffers for better performance and bidirectional streaming</td>\n</tr>\n<tr>\n<td><strong>Storage</strong></td>\n<td>Local filesystem for experiment definitions and results</td>\n<td>Database backend (PostgreSQL) for history, search, and analytics</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-initial-file-structure\">Recommended Initial File Structure</h4>\n<p>Given the Go-centric implementation, organize code to reflect the separation of concerns aligned with our goals:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── chaos-controller/          # Main experiment orchestration daemon\n│   │   └── main.go\n│   └── chaos-agent/               # Fault injection agent (runs on target nodes)\n│       └── main.go\n├── internal/\n│   ├── experiment/                # Experiment lifecycle management\n│   │   ├── orchestrator.go        # State machine implementation\n│   │   ├── hypothesis.go          # Steady-state validation logic\n│   │   └── scheduler.go           # Experiment timing control\n│   ├── fault/                     # Fault injection primitives\n│   │   ├── injector.go            # Interface for all fault types\n│   │   ├── network/               # Network faults (latency, packet loss)\n│   │   │   ├── latency.go\n│   │   │   └── packetloss.go\n│   │   ├── resource/              # Resource exhaustion faults\n│   │   │   ├── cpu.go\n│   │   │   └── memory.go\n│   │   └── process/               # Process faults\n│   │       └── kill.go\n│   ├── safety/                    # Safety monitoring and auto-rollback\n│   │   ├── monitor.go             # Metric threshold checking\n│   │   └── circuitbreaker.go      # Abort condition evaluation\n│   ├── metrics/                   # Metrics collection and analysis\n│   │   ├── collector.go           # Query Prometheus/other backends\n│   │   └── validator.go           # Statistical validation against hypotheses\n│   ├── gameday/                   # GameDay scenario orchestration\n│   │   ├── scenario.go            # Multi-experiment sequence execution\n│   │   └── runbook.go             # Manual step integration\n│   └── api/                       # REST/GRPC API definitions\n│       ├── server.go\n│       └── types.go               # Request/response structs\n├── pkg/\n│   └── types/                     # Public data types shared across components\n│       ├── experiment.go          # Experiment, Hypothesis, Fault definitions\n│       └── result.go              # ExperimentResult, MetricSnapshot\n├── configs/                       # Configuration files and examples\n│   ├── experiment-example.yaml\n│   └── gameday-scenario.yaml\n└── scripts/                       # Utility scripts for setup and verification\n    ├── install-dependencies.sh    # Install tc, iptables, stress-ng\n    └── verify-fault-cleanup.sh    # Post-experiment cleanup verification</code></pre></div>\n\n<h4 id=\"core-data-types-skeleton\">Core Data Types Skeleton</h4>\n<p>These types form the foundation of the platform&#39;s data model, reflecting the goals around experiment definition and safety.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/types/experiment.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Experiment defines a chaos experiment with hypothesis, faults, and safety controls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Experiment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"id\"`</span><span style=\"color:#6A737D\">            // Unique identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"name\"`</span><span style=\"color:#6A737D\">          // Human-readable name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"description\"`</span><span style=\"color:#6A737D\">   // Purpose of experiment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Hypothesis   </span><span style=\"color:#B392F0\">Hypothesis</span><span style=\"color:#9ECBFF\">    `json:\"hypothesis\"`</span><span style=\"color:#6A737D\">    // Steady-state hypothesis to validate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Faults       []</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#9ECBFF\">       `json:\"faults\"`</span><span style=\"color:#6A737D\">       // Faults to inject (can be multiple)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Schedule     </span><span style=\"color:#B392F0\">Schedule</span><span style=\"color:#9ECBFF\">      `json:\"schedule\"`</span><span style=\"color:#6A737D\">      // When to run (immediate or cron)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"duration\"`</span><span style=\"color:#6A737D\">      // How long faults remain active</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BlastRadius  </span><span style=\"color:#B392F0\">BlastRadius</span><span style=\"color:#9ECBFF\">   `json:\"blast_radius\"`</span><span style=\"color:#6A737D\">  // Scope limitation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SafetyRules  []</span><span style=\"color:#B392F0\">SafetyRule</span><span style=\"color:#9ECBFF\">  `json:\"safety_rules\"`</span><span style=\"color:#6A737D\">  // Conditions for auto-abort</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status       </span><span style=\"color:#B392F0\">ExperimentStatus</span><span style=\"color:#9ECBFF\"> `json:\"status\"`</span><span style=\"color:#6A737D\">     // Current state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"started_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletedAt  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"completed_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Hypothesis defines the expected steady-state behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Hypothesis</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">           `json:\"description\"`</span><span style=\"color:#6A737D\"> // Textual hypothesis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metrics     []</span><span style=\"color:#B392F0\">MetricThreshold</span><span style=\"color:#9ECBFF\"> `json:\"metrics\"`</span><span style=\"color:#6A737D\">    // Quantifiable thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add validation method to check all required metrics are available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricThreshold defines a metric to monitor and its acceptable range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricThreshold</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"name\"`</span><span style=\"color:#6A737D\">      // Metric name (e.g., \"http_request_duration_seconds\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Query     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"query\"`</span><span style=\"color:#6A737D\">     // Prometheus query to fetch metric</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Min       </span><span style=\"color:#F97583\">*float64</span><span style=\"color:#9ECBFF\">  `json:\"min,omitempty\"`</span><span style=\"color:#6A737D\">       // Minimum acceptable value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Max       </span><span style=\"color:#F97583\">*float64</span><span style=\"color:#9ECBFF\">  `json:\"max,omitempty\"`</span><span style=\"color:#6A737D\">       // Maximum acceptable value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"duration\"`</span><span style=\"color:#6A737D\">  // Time window for evaluation (e.g., \"5m\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add statistical comparison method (e.g., compared to baseline)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fault defines a single failure to inject</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Fault</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#B392F0\">FaultType</span><span style=\"color:#9ECBFF\">     `json:\"type\"`</span><span style=\"color:#6A737D\">        // LATENCY, PACKET_LOSS, CPU_STRESS, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Target      </span><span style=\"color:#B392F0\">Target</span><span style=\"color:#9ECBFF\">        `json:\"target\"`</span><span style=\"color:#6A737D\">      // What to affect</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Parameters  </span><span style=\"color:#B392F0\">FaultParams</span><span style=\"color:#9ECBFF\">   `json:\"parameters\"`</span><span style=\"color:#6A737D\">  // Type-specific parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add validation method to ensure parameters match fault type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BlastRadius limits the scope of an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BlastRadius</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Percentage  </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"percentage\"`</span><span style=\"color:#6A737D\">  // Percentage of traffic/services affected (0-100)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Services    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"services\"`</span><span style=\"color:#6A737D\">   // Specific service names to target</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Namespaces  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"namespaces\"`</span><span style=\"color:#6A737D\"> // Kubernetes namespaces to target</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add method to check if a specific request/service falls within blast radius</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SafetyRule defines conditions that trigger experiment abortion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SafetyRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metric      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"metric\"`</span><span style=\"color:#6A737D\">      // Metric to monitor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Condition   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"condition\"`</span><span style=\"color:#6A737D\">   // Condition expression (e.g., \"> 5\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"duration\"`</span><span style=\"color:#6A737D\">    // How long condition must hold before abort</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add evaluation method to check condition against metric values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"safety-infrastructure-starter-code\">Safety Infrastructure Starter Code</h4>\n<p>Safety is the foremost non-functional goal. This complete helper ensures fault cleanup even if the orchestrator crashes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/safety/cleanup_ensurer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> safety</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupEnsurer guarantees fault cleanup by persisting active faults to disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupEnsurer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeFaults </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#6A737D\"> // faultID -> record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultRecord represents a fault that needs cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExperimentID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"experiment_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"fault_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Target       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"target\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultType    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"fault_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InjectTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"inject_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CleanupCmd   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"cleanup_cmd\"`</span><span style=\"color:#6A737D\"> // Command to reverse the fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCleanupEnsurer creates a new ensurer with persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCleanupEnsurer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dataDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dataDir, </span><span style=\"color:#9ECBFF\">\"active_faults.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ensurer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filePath: filePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeFaults: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load existing active faults on startup (for crash recovery)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ensurer.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Immediately attempt cleanup of any orphaned faults from previous run</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#E1E4E8\"> ensurer.</span><span style=\"color:#B392F0\">cleanupOrphanedFaults</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ensurer, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterFault records a fault that will need cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#B392F0\"> FaultRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.activeFaults[record.FaultID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompleteFault removes a fault from the cleanup registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CompleteFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(c.activeFaults, faultID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanupOrphanedFaults cleans up any faults that were active during a crash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">cleanupOrphanedFaults</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    records </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(c.activeFaults))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> c.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        records </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(records, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, record </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> records {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Execute the cleanup command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Execute record.CleanupCmd via exec.Command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Log successful cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.</span><span style=\"color:#B392F0\">CompleteFault</span><span style=\"color:#E1E4E8\">(record.FaultID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// save persists active faults to disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(c.activeFaults, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tmpPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.filePath </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(tmpPath, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Rename</span><span style=\"color:#E1E4E8\">(tmpPath, c.filePath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// load reads active faults from disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(c.filePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">c.activeFaults)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-orchestration-skeleton\">Core Orchestration Skeleton</h4>\n<p>This skeleton implements the experiment state machine central to the platform&#39;s operation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/experiment/orchestrator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> experiment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Orchestrator manages the lifecycle of chaos experiments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Orchestrator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    experiments </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExperimentInstance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metricsCollector </span><span style=\"color:#B392F0\">metrics</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Collector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    safetyMonitor    </span><span style=\"color:#B392F0\">safety</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Monitor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faultInjector    </span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Injector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentInstance represents a running experiment with its state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentInstance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Experiment </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State      </span><span style=\"color:#B392F0\">ExperimentState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CancelFunc </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MetricsBaseline </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResultsChan </span><span style=\"color:#F97583\">chan&#x3C;-</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentResult</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentState represents the current state in the lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentState</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateDraft</span><span style=\"color:#B392F0\">           ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DRAFT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateBaselineValidation</span><span style=\"color:#B392F0\"> ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"BASELINE_VALIDATION\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateInjecting</span><span style=\"color:#B392F0\">       ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"INJECTING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateMonitoring</span><span style=\"color:#B392F0\">      ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"MONITORING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateRollback</span><span style=\"color:#B392F0\">        ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ROLLBACK\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateAnalysis</span><span style=\"color:#B392F0\">        ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ANALYSIS\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCompleted</span><span style=\"color:#B392F0\">       ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"COMPLETED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateAborted</span><span style=\"color:#B392F0\">         ExperimentState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ABORTED\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartExperiment begins execution of a defined experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">exp</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">resultsChan</span><span style=\"color:#F97583\"> chan&#x3C;-</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentResult</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate experiment definition (hypothesis, faults, schedule)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create ExperimentInstance with initial state StateDraft</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if target systems are within allowed blast radius (safety check)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Transition to StateBaselineValidation and begin baseline metrics collection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start background goroutine to execute state machine transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return experiment ID for tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeStateMachine runs the experiment through its lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeStateMachine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance.CancelFunc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cancel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            switch</span><span style=\"color:#E1E4E8\"> instance.State {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateDraft:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Transition to StateBaselineValidation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateBaselineValidation:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 1: Collect metrics for baseline period (e.g., 5 minutes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 2: Validate baseline meets hypothesis criteria</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 3: If validation fails, transition to StateAborted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 4: If validation succeeds, transition to StateInjecting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateInjecting:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 1: For each fault in experiment, call faultInjector.Inject()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 2: Register each fault with CleanupEnsurer for safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 3: Transition to StateMonitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateMonitoring:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 1: Start safety monitor to watch for threshold breaches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 2: Start metrics collection for hypothesis validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 3: Wait for experiment duration or abort signal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 4: On completion or abort, transition to StateRollback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateRollback:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 1: For each active fault, call faultInjector.Cleanup()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 2: Verify cleanup succeeded for each fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 3: Transition to StateAnalysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateAnalysis:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 1: Collect post-experiment metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 2: Compare baseline, experiment, and post-experiment metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 3: Determine if hypothesis was validated (pass/fail)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 4: Generate comprehensive ExperimentResult</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 5: Send result to resultsChan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO 6: Transition to StateCompleted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#E1E4E8\"> StateCompleted, StateAborted:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // TODO: Clean up resources, remove from active experiments map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AbortExperiment forcefully stops an experiment and rolls back faults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AbortExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">experimentID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up experiment instance by ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If in StateMonitoring, cancel context to stop monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Immediately transition to StateRollback regardless of current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Record abort reason in experiment results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Ensure all faults are cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-1-checkpoint\">Milestone 1 Checkpoint</h4>\n<p>After implementing the fault injection framework (Milestone 1), you should be able to:</p>\n<p><strong>Command to test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run a test that injects network latency</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/fault/network/...</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestLatencyInjection</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong></p>\n<ol>\n<li>Test should apply 200ms latency to loopback interface using <code>tc netem</code></li>\n<li>Should measure actual latency increase via ping or HTTP request timing</li>\n<li>Should automatically clean up latency rule after test completes</li>\n<li>Should verify no residual <code>tc</code> rules remain after cleanup</li>\n</ol>\n<p><strong>Manual verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Before/during test execution, check tc rules</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> tc</span><span style=\"color:#9ECBFF\"> qdisc</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> dev</span><span style=\"color:#9ECBFF\"> lo</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After test completes, verify cleanup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> tc</span><span style=\"color:#9ECBFF\"> qdisc</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> dev</span><span style=\"color:#9ECBFF\"> lo</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -q</span><span style=\"color:#9ECBFF\"> \"netem\"</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"FAIL: Rules not cleaned up\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"PASS: Cleanup successful\"</span></span></code></pre></div>\n\n<p><strong>Common early failures:</strong></p>\n<ul>\n<li><p><strong>Symptom</strong>: &quot;Permission denied&quot; when running <code>tc</code> commands</p>\n<ul>\n<li><strong>Cause</strong>: Insufficient privileges (need CAP_NET_ADMIN or root)</li>\n<li><strong>Fix</strong>: Run agent with appropriate capabilities or use sudo with controlled command execution</li>\n</ul>\n</li>\n<li><p><strong>Symptom</strong>: Fault affects the chaos platform itself</p>\n<ul>\n<li><strong>Cause</strong>: Network fault applied to interface used by control plane</li>\n<li><strong>Fix</strong>: Exclude localhost/control interfaces from fault targeting or run control plane on separate network namespace</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational architecture for entire platform)</p>\n</blockquote>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<h3 id=\"mental-model-the-chaos-control-room\">Mental Model: The Chaos Control Room</h3>\n<p>Imagine a <strong>space mission control center</strong> coordinating multiple systems during a rocket launch. The mission control (our platform) doesn&#39;t physically interact with the rocket—instead, it sends precise commands to various systems (fault injectors), monitors telemetry data (metrics), and has emergency abort procedures (safety monitors). This separation of concerns ensures that a failure in one system (like a faulty monitor) doesn&#39;t cascade into uncontrolled chaos.</p>\n<p>Similarly, our Chaos Engineering Platform follows a <strong>command-and-control architecture</strong> where:</p>\n<ul>\n<li>A central <strong>Experiment Controller</strong> orchestrates the mission plan (experiment)</li>\n<li>Remote <strong>Fault Injectors</strong> execute specific sabotage operations on target systems</li>\n<li>Independent <strong>Safety Monitors</strong> watch critical telemetry streams and can trigger abort sequences</li>\n<li><strong>Metrics Collectors</strong> gather observational data before, during, and after the experiment</li>\n<li><strong>Result Analyzers</strong> compile mission reports to determine success or failure</li>\n</ul>\n<p>This architectural separation provides three critical benefits: <strong>safety</strong> (faults can be rolled back even if the controller fails), <strong>scalability</strong> (multiple fault injectors can operate simultaneously), and <strong>observability</strong> (independent monitoring prevents single-point failures in the chaos system itself).</p>\n<h3 id=\"component-diagram-and-interactions\">Component Diagram and Interactions</h3>\n<p>The platform consists of five core subsystems that work together to safely execute chaos experiments. Each component has a distinct responsibility and communicates through well-defined interfaces.</p>\n<p><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-system.svg\" alt=\"Chaos Platform System Overview\"></p>\n<h4 id=\"core-components\">Core Components</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Key Data Owned</th>\n<th>Interface Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Experiment Controller</strong></td>\n<td>Orchestrates experiment lifecycle, manages state transitions, coordinates other components</td>\n<td><code>Experiment</code> definitions, experiment state, execution history</td>\n<td>REST API (external), gRPC (internal), state machine</td>\n</tr>\n<tr>\n<td><strong>Fault Injector</strong></td>\n<td>Executes specific fault operations on target systems, ensures fault cleanup</td>\n<td>Active fault registry, cleanup commands, fault status</td>\n<td>gRPC service with <code>InjectFault()</code>, <code>Cleanup()</code> methods</td>\n</tr>\n<tr>\n<td><strong>Safety Monitor</strong></td>\n<td>Continuously evaluates safety rules, triggers automatic rollback when thresholds breached</td>\n<td>Safety rule configurations, current metric evaluations</td>\n<td>Event stream consumer, publishes abort events</td>\n</tr>\n<tr>\n<td><strong>Metrics Collector</strong></td>\n<td>Gathers and aggregates system metrics from observability sources</td>\n<td>Metric time-series data, baseline calculations</td>\n<td>Pull-based collection (Prometheus) and push-based (custom metrics)</td>\n</tr>\n<tr>\n<td><strong>Result Analyzer</strong></td>\n<td>Compares pre-experiment, during-experiment, and post-experiment metrics, generates reports</td>\n<td>Experiment results, statistical comparisons, pass/fail determinations</td>\n<td>Batch processor with report generation</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-interactions\">Component Interactions</h4>\n<p>The components communicate through two primary patterns:</p>\n<ol>\n<li><strong>Command/Response (Synchronous)</strong>: For control operations where immediate acknowledgment is required</li>\n<li><strong>Event Stream (Asynchronous)</strong>: For monitoring and safety operations where latency tolerance is higher</li>\n</ol>\n<p><strong>Key Interaction Flows:</strong></p>\n<p><strong>Experiment Execution Flow:</strong></p>\n<ol>\n<li>User submits an <code>Experiment</code> definition to the Experiment Controller via REST API</li>\n<li>Controller validates the experiment and transitions it to <code>StateBaselineValidation</code></li>\n<li>Controller queries Metrics Collector for baseline metrics to verify steady state</li>\n<li>If baseline passes, Controller calls Fault Injector&#39;s <code>InjectFault()</code> method for each fault</li>\n<li>Fault Injector executes the fault (e.g., runs <code>tc netem</code> commands) and registers cleanup</li>\n<li>Controller transitions experiment to <code>StateMonitoring</code> and begins safety monitoring</li>\n<li>Safety Monitor continuously evaluates metrics against safety rules</li>\n<li>If safety breach detected, Safety Monitor publishes abort event to Controller</li>\n<li>Controller calls Fault Injector&#39;s <code>Cleanup()</code> method and transitions to <code>StateRollback</code></li>\n<li>After fault cleanup, Controller transitions to <code>StateAnalysis</code></li>\n<li>Result Analyzer compares metrics and generates final report</li>\n<li>Controller transitions to <code>StateCompleted</code> or <code>StateAborted</code> with detailed results</li>\n</ol>\n<p><strong>Safety Monitoring Flow:</strong></p>\n<ol>\n<li>Metrics Collector continuously scrapes system metrics from various sources</li>\n<li>Safety Monitor subscribes to relevant metric streams (error rates, latency, CPU usage)</li>\n<li>For each active experiment, Safety Monitor evaluates configured <code>SafetyRule</code> conditions</li>\n<li>If condition breaches for specified duration, Safety Monitor publishes abort event</li>\n<li>Experiment Controller receives abort event and initiates rollback sequence</li>\n<li>Cleanup is executed regardless of Controller state (via <code>CleanupEnsurer</code> persistence)</li>\n</ol>\n<h4 id=\"component-interface-details\">Component Interface Details</h4>\n<p><strong>Experiment Controller API:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateExperiment</code></td>\n<td><code>Experiment</code> definition</td>\n<td><code>ExperimentID</code>, error</td>\n<td>Validates and stores new experiment</td>\n</tr>\n<tr>\n<td><code>StartExperiment</code></td>\n<td><code>experimentID string</code></td>\n<td>error</td>\n<td>Begins execution of approved experiment</td>\n</tr>\n<tr>\n<td><code>GetExperimentStatus</code></td>\n<td><code>experimentID string</code></td>\n<td><code>ExperimentStatus</code>, error</td>\n<td>Returns current state and progress</td>\n</tr>\n<tr>\n<td><code>AbortExperiment</code></td>\n<td><code>experimentID string</code>, <code>reason string</code></td>\n<td>error</td>\n<td>Manually aborts running experiment</td>\n</tr>\n<tr>\n<td><code>ListExperiments</code></td>\n<td><code>filter ExperimentFilter</code></td>\n<td><code>[]Experiment</code>, error</td>\n<td>Returns experiments matching criteria</td>\n</tr>\n</tbody></table>\n<p><strong>Fault Injector Service (gRPC):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>InjectFault</code></td>\n<td><code>Fault</code>, <code>ExperimentID string</code></td>\n<td><code>FaultID string</code>, error</td>\n<td>Applies specified fault to target system</td>\n</tr>\n<tr>\n<td><code>CleanupFault</code></td>\n<td><code>FaultID string</code></td>\n<td>error</td>\n<td>Removes previously injected fault</td>\n</tr>\n<tr>\n<td><code>GetFaultStatus</code></td>\n<td><code>FaultID string</code></td>\n<td><code>FaultStatus</code>, error</td>\n<td>Returns current state of fault</td>\n</tr>\n<tr>\n<td><code>ListActiveFaults</code></td>\n<td><code>ExperimentID string</code></td>\n<td><code>[]FaultStatus</code>, error</td>\n<td>Returns all active faults for experiment</td>\n</tr>\n</tbody></table>\n<p><strong>Safety Monitor Event Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Fields</th>\n<th>Published When</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SafetyBreach</code></td>\n<td><code>ExperimentID string</code>, <code>Rule SafetyRule</code>, <code>MetricValue float64</code>, <code>Timestamp time.Time</code></td>\n<td>Safety rule condition breaches for configured duration</td>\n</tr>\n<tr>\n<td><code>SafetyCleared</code></td>\n<td><code>ExperimentID string</code>, <code>Rule SafetyRule</code>, <code>Timestamp time.Time</code></td>\n<td>Previously breached safety condition returns to normal</td>\n</tr>\n</tbody></table>\n<p><strong>Metrics Collector Query Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GetMetric</code></td>\n<td><code>query string</code>, <code>start time.Time</code>, <code>end time.Time</code>, <code>step time.Duration</code></td>\n<td><code>[]MetricPoint</code>, error</td>\n<td>Returns time-series metric data</td>\n</tr>\n<tr>\n<td><code>GetCurrentValue</code></td>\n<td><code>query string</code></td>\n<td><code>float64</code>, error</td>\n<td>Returns most recent value for metric</td>\n</tr>\n<tr>\n<td><code>ValidateThreshold</code></td>\n<td><code>threshold MetricThreshold</code>, <code>duration string</code></td>\n<td><code>bool</code>, error</td>\n<td>Checks if metric meets threshold for duration</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-deployment-architecture\">Component Deployment Architecture</h4>\n<p>The platform supports two deployment modes:</p>\n<ol>\n<li><strong>Centralized Deployment</strong>: All components run as a single service (for development/testing)</li>\n<li><strong>Distributed Deployment</strong>: Components deploy independently with the following topology:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                          +----------------------+\n                          |   Load Balancer      |\n                          |   (Optional)         |\n                          +----------+-----------+\n                                     | HTTP/REST\n                          +----------v-----------+\n                          |  Experiment Controller|\n                          |  (Stateless)          |\n                          +----------+-----------+\n                                     | gRPC\n            +------------------------+------------------------+\n            |                         |                       |\n+-----------v-----------+   +---------v----------+   +--------v----------+\n|   Fault Injector      |   |   Safety Monitor   |   |  Metrics Collector|\n|   (Per-node agent)    |   |   (Stateful)       |   |  (Stateless)      |\n+-----------------------+   +--------------------+   +-------------------+</code></pre></div>\n\n<blockquote>\n<p><strong>Design Insight</strong>: The Fault Injector must run with elevated privileges (CAP_NET_ADMIN, root access) on target nodes. To minimize attack surface, we deploy it as a separate, tightly-scoped daemon rather than bundling it with the Controller. This follows the principle of least privilege—the Controller itself doesn&#39;t need root access.</p>\n</blockquote>\n<h4 id=\"data-flow-between-components\">Data Flow Between Components</h4>\n<p><strong>Experiment Definition Flow:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>User → [REST/HTTP] → Experiment Controller → [Validate] → [Store in DB]</code></pre></div>\n\n<p><strong>Fault Execution Flow:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Experiment Controller → [gRPC] → Fault Injector → [Execute Command] → Target System\n                      ↑                                  ↓\n                [Acknowledge]                    [Register Cleanup]</code></pre></div>\n\n<p><strong>Safety Monitoring Flow:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Metrics Collector → [Stream] → Safety Monitor → [Evaluate Rules] → [Publish Event]\n                                                     ↓\n                                            [Threshold Breach?] → [Abort Event]</code></pre></div>\n\n<p><strong>Result Compilation Flow:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Experiment Controller → [Query] → Metrics Collector → [Time-series Data]\n         ↓\n[Generate Report] ← [Analyze] ← Result Analyzer</code></pre></div>\n\n<h4 id=\"adr-centralized-vs-distributed-control-plane\">ADR: Centralized vs. Distributed Control Plane</h4>\n<blockquote>\n<p><strong>Decision: Hybrid Control Plane Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: The platform needs to coordinate across multiple nodes (for network faults) but maintain safety guarantees even if the control plane experiences partial failures.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fully centralized: Single controller managing all nodes</li>\n<li>Fully decentralized: Each node autonomous with consensus</li>\n<li>Hybrid: Central coordinator with persistent fault registries</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid architecture with persistent <code>CleanupEnsurer</code> on each node</li>\n<li><strong>Rationale</strong>: Central coordination simplifies experiment management and state tracking, while persistent local cleanup registries guarantee fault reversal even if the controller crashes or network partitions occur. This provides the safety of decentralization with the simplicity of central control.</li>\n<li><strong>Consequences</strong>: Requires synchronization between controller and nodes, but local persistence ensures no &quot;orphaned faults&quot; remain after controller failure.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fully Centralized</td>\n<td>Simple to implement, consistent state</td>\n<td>Single point of failure, network latency to nodes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fully Decentralized</td>\n<td>Highly available, fault-tolerant</td>\n<td>Complex coordination, eventual consistency issues</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hybrid (Central + Local Persistence)</td>\n<td>Safety guarantees, simpler than full decentralization</td>\n<td>Requires sync mechanism, slightly more complex</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls-in-architecture-design\">Common Pitfalls in Architecture Design</h4>\n<p>⚡ <strong>Pitfall: Tight Coupling Between Controller and Fault Injection</strong></p>\n<ul>\n<li><strong>Description</strong>: Implementing fault injection logic directly in the Experiment Controller</li>\n<li><strong>Why it&#39;s wrong</strong>: Controller needs elevated privileges, becomes single point of failure, hard to scale</li>\n<li><strong>How to fix</strong>: Strict separation: Controller only orchestrates, Fault Injector executes with proper isolation</li>\n</ul>\n<p>⚡ <strong>Pitfall: Missing Idempotency in Fault Operations</strong></p>\n<ul>\n<li><strong>Description</strong>: Fault injection commands that fail if retried (e.g., adding duplicate <code>tc</code> rules)</li>\n<li><strong>Why it&#39;s wrong</strong>: Network flakes or retries can leave system in inconsistent state</li>\n<li><strong>How to fix</strong>: Design all fault operations as idempotent: &quot;ensure this fault is active&quot; not &quot;add this fault&quot;</li>\n</ul>\n<p>⚡ <strong>Pitfall: Synchronous Safety Monitoring</strong></p>\n<ul>\n<li><strong>Description</strong>: Controller polls safety status in main experiment loop</li>\n<li><strong>Why it&#39;s wrong</strong>: Adds latency to abort decisions, blocks experiment progression</li>\n<li><strong>How to fix</strong>: Event-driven safety monitoring with publish/subscribe pattern</li>\n</ul>\n<p>⚡ <strong>Pitfall: No Cleanup Guarantees</strong></p>\n<ul>\n<li><strong>Description</strong>: Assuming controller will always be available to clean up faults</li>\n<li><strong>Why it&#39;s wrong</strong>: Controller crashes leave systems permanently impaired</li>\n<li><strong>How to fix</strong>: Persistent <code>CleanupEnsurer</code> that records faults before applying them</li>\n</ul>\n<h3 id=\"recommended-file-and-module-structure\">Recommended File and Module Structure</h3>\n<blockquote>\n<p><strong>Principle</strong>: Organize by domain responsibility, not by technical layer. Each package should have a single, clear purpose and minimal dependencies on other packages.</p>\n</blockquote>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/                          # Entry points for executables\n│   ├── controller/               # Experiment Controller main\n│   │   ├── main.go               # CLI parsing, config loading\n│   │   └── Dockerfile            # Container build file\n│   ├── injector-agent/           # Fault Injector daemon\n│   │   ├── main.go               # Agent startup, gRPC server\n│   │   └── Dockerfile            # Privileged container\n│   ├── safety-monitor/           # Safety Monitor service\n│   │   ├── main.go               # Metric consumer, event publisher\n│   │   └── Dockerfile\n│   └── metrics-collector/        # Optional: custom metrics collector\n│       ├── main.go\n│       └── Dockerfile\n├── internal/                     # Private application code\n│   ├── api/                      # External API definitions\n│   │   ├── v1/                   # API versioning\n│   │   │   ├── types.go          # Request/response structs\n│   │   │   ├── handlers.go       # HTTP handlers\n│   │   │   └── router.go         # Route definitions\n│   │   └── middleware/           # Auth, logging, validation\n│   ├── controller/               # Experiment orchestration logic\n│   │   ├── orchestrator.go       # `Orchestrator` struct and methods\n│   │   ├── state_machine.go      # `executeStateMachine` implementation\n│   │   ├── scheduler.go          # Experiment scheduling\n│   │   └── cleanup.go            # Cleanup coordination logic\n│   ├── fault/                    # Fault injection domain\n│   │   ├── injector.go           # `Injector` interface implementation\n│   │   ├── registry.go           # Fault type registry\n│   │   ├── types.go              # `Fault`, `FaultParams`, etc.\n│   │   ├── network/              # Network fault implementations\n│   │   │   ├── latency.go        # Network latency injection\n│   │   │   ├── packet_loss.go    # Packet loss simulation\n│   │   │   └── partition.go      # Network partition\n│   │   ├── resource/             # Resource fault implementations\n│   │   │   ├── cpu_stress.go     # CPU exhaustion\n│   │   │   ├── memory_pressure.go # Memory pressure\n│   │   │   └── disk_fill.go      # Disk space exhaustion\n│   │   └── process/              # Process faults\n│   │       ├── kill.go           # Process termination\n│   │       └── restart.go        # Process restart simulation\n│   ├── safety/                   # Safety monitoring domain\n│   │   ├── monitor.go            # `Monitor` implementation\n│   │   ├── evaluator.go          # Safety rule evaluation\n│   │   ├── events.go             # Event publishing\n│   │   └── rules.go              # `SafetyRule` validation\n│   ├── metrics/                  # Metrics collection domain\n│   │   ├── collector.go          # `Collector` interface\n│   │   ├── prometheus.go         # Prometheus implementation\n│   │   ├── aggregator.go         # Metric aggregation\n│   │   └── baseline.go           # Baseline calculation\n│   ├── analysis/                 # Result analysis domain\n│   │   ├── analyzer.go           # `Analyzer` implementation\n│   │   ├── reporter.go           # Report generation\n│   │   └── statistical.go        # Statistical comparisons\n│   ├── persistence/              # Data persistence layer\n│   │   ├── experiment_store.go   # Experiment CRUD\n│   │   ├── cleanup_store.go      # `CleanupEnsurer` implementation\n│   │   └── metrics_store.go      # Metric data storage\n│   ├── gameday/                  # GameDay automation (Milestone 3)\n│   │   ├── scenario.go           # Scenario execution\n│   │   ├── runbook.go            # Runbook automation\n│   │   └── sequencer.go          # Multi-experiment sequencing\n│   └── types/                    # Shared type definitions\n│       ├── experiment.go         # `Experiment`, `Hypothesis`, etc.\n│       ├── fault.go              # `Fault`, `FaultType`, etc.\n│       ├── metrics.go            # `MetricThreshold`, etc.\n│       └── common.go             # Enums, constants\n├── pkg/                          # Public libraries (if any)\n│   └── chaosclient/              # Go client library for API\n├── api/                          # Protocol definitions\n│   ├── protos/                   # gRPC protocol buffers\n│   │   ├── fault_injector.proto  # Fault injector service\n│   │   └── safety_monitor.proto  # Safety monitoring events\n│   └── openapi/                  # OpenAPI/Swagger specs\n│       └── v1.yaml               # REST API specification\n├── configs/                      # Configuration files\n│   ├── controller.yaml           # Controller configuration\n│   ├── injector.yaml             # Injector agent configuration\n│   └── safety.yaml               # Safety monitor configuration\n├── deployments/                  # Deployment manifests\n│   ├── kubernetes/               # K8s manifests for all components\n│   │   ├── controller.yaml\n│   │   ├── injector-daemonset.yaml\n│   │   └── safety-monitor.yaml\n│   └── docker-compose/           # Local development setup\n│       └── docker-compose.yaml\n├── scripts/                      # Utility scripts\n│   ├── install-dependencies.sh   # System dependency setup\n│   ├── generate-protos.sh        # Protocol buffer generation\n│   └── preflight-check.sh        # System validation before experiments\n├── tests/                        # Integration and e2e tests\n│   ├── integration/              # Component integration tests\n│   └── e2e/                      # End-to-end scenario tests\n├── examples/                     # Example configurations\n│   ├── experiments/              # Example experiment definitions\n│   └── scenarios/                # Example GameDay scenarios\n├── go.mod                        # Go module definition\n├── go.sum                        # Go dependencies checksum\n├── Makefile                      # Build, test, deploy commands\n└── README.md                     # Project documentation</code></pre></div>\n\n<h4 id=\"package-dependency-graph\">Package Dependency Graph</h4>\n<p>To maintain clean architecture, follow these dependency rules:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>cmd/* (entry points)\n  ↓\ninternal/api (depends on internal/types)\n  ↓\ninternal/controller (depends on internal/types, internal/fault, internal/safety, internal/metrics)\n  ↓\ninternal/fault (depends on internal/types)\n  ↓\ninternal/safety (depends on internal/types, internal/metrics)\n  ↓\ninternal/metrics (depends on internal/types)\n  ↓\ninternal/analysis (depends on internal/types, internal/metrics)\n  ↓\ninternal/persistence (depends on internal/types)\n  ↓\ninternal/types (no dependencies)</code></pre></div>\n\n<blockquote>\n<p><strong>Key Principle</strong>: Dependencies flow inward toward domain types. The <code>internal/types</code> package has zero dependencies and contains only data structures. This enables easy testing and prevents circular dependencies.</p>\n</blockquote>\n<h4 id=\"module-design-rationale\">Module Design Rationale</h4>\n<p><strong>Why separate <code>internal/fault</code> from <code>internal/controller</code>?</strong></p>\n<ul>\n<li>Fault injection requires system-level operations (root access, <code>tc</code> commands)</li>\n<li>Controller should remain unprivileged for security</li>\n<li>Enables independent testing of fault logic</li>\n<li>Allows replacement of fault implementations (e.g., different network manipulation tools)</li>\n</ul>\n<p><strong>Why <code>internal/types</code> as a separate package?</strong></p>\n<ul>\n<li>Shared by all other packages without import cycles</li>\n<li>Serialization/deserialization logic centralized</li>\n<li>Versioning of data structures managed in one place</li>\n<li>Generated code (protobuf, OpenAPI) can reference these types</li>\n</ul>\n<p><strong>Why <code>cmd/</code> structure with multiple binaries?</strong></p>\n<ul>\n<li>Each component has different deployment requirements</li>\n<li>Fault Injector needs privileged containers, others don&#39;t</li>\n<li>Independent scaling of components</li>\n<li>Separate configuration and dependency management</li>\n</ul>\n<h4 id=\"build-and-deployment-configuration\">Build and Deployment Configuration</h4>\n<p><strong>Multi-stage Docker builds</strong> for each component:</p>\n<ul>\n<li><strong>Controller</strong>: Lightweight Go binary on distroless base</li>\n<li><strong>Injector</strong>: Privileged container with <code>iproute2</code>, <code>stress-ng</code>, <code>iptables</code> tools</li>\n<li><strong>Safety Monitor</strong>: Event-driven service with metric client libraries</li>\n</ul>\n<p><strong>Kubernetes Deployment Strategy:</strong></p>\n<ul>\n<li>Controller: Deployment with 3 replicas for high availability</li>\n<li>Injector: DaemonSet (one per node) with <code>hostNetwork: true</code> and privileged security context</li>\n<li>Safety Monitor: StatefulSet with persistent storage for rule evaluations</li>\n<li>Metrics Collector: Optional sidecar or separate deployment depending on metrics volume</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Getting Started)</th>\n<th>Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>API Transport</strong></td>\n<td>HTTP REST with JSON (Go&#39;s <code>net/http</code>)</td>\n<td>gRPC with Protocol Buffers + HTTP/JSON gateway</td>\n</tr>\n<tr>\n<td><strong>Metrics Collection</strong></td>\n<td>Prometheus client library + direct queries</td>\n<td>Multiple adapters (Prometheus, Datadog, Cloud Monitoring)</td>\n</tr>\n<tr>\n<td><strong>Persistence</strong></td>\n<td>SQLite (embedded) + file-based cleanup registry</td>\n<td>PostgreSQL + Redis for caching</td>\n</tr>\n<tr>\n<td><strong>Event System</strong></td>\n<td>Go channels + in-memory pub/sub</td>\n<td>Apache Kafka or NATS for distributed events</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>YAML files + environment variables</td>\n<td>Config management with HashiCorp Consul</td>\n</tr>\n<tr>\n<td><strong>Container Runtime</strong></td>\n<td>Docker Compose for local development</td>\n<td>Kubernetes with Helm charts for production</td>\n</tr>\n</tbody></table>\n<h4 id=\"starter-code-for-project-structure\">Starter Code for Project Structure</h4>\n<p><strong>File: <code>internal/types/experiment.go</code></strong> (Complete foundational code)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentStatus represents the current state of an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateDraft</span><span style=\"color:#B392F0\">              ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DRAFT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateBaselineValidation</span><span style=\"color:#B392F0\"> ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"BASELINE_VALIDATION\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateInjecting</span><span style=\"color:#B392F0\">          ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"INJECTING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateMonitoring</span><span style=\"color:#B392F0\">         ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"MONITORING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateRollback</span><span style=\"color:#B392F0\">           ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ROLLBACK\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateAnalysis</span><span style=\"color:#B392F0\">           ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ANALYSIS\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateCompleted</span><span style=\"color:#B392F0\">          ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"COMPLETED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateAborted</span><span style=\"color:#B392F0\">            ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ABORTED\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Experiment defines a chaos experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Experiment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"id\" yaml:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"name\" yaml:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDescription  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"description\" yaml:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tHypothesis   </span><span style=\"color:#B392F0\">Hypothesis</span><span style=\"color:#9ECBFF\">    `json:\"hypothesis\" yaml:\"hypothesis\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tFaults       []</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#9ECBFF\">       `json:\"faults\" yaml:\"faults\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSchedule     </span><span style=\"color:#B392F0\">Schedule</span><span style=\"color:#9ECBFF\">      `json:\"schedule\" yaml:\"schedule\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"duration\" yaml:\"duration\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tBlastRadius  </span><span style=\"color:#B392F0\">BlastRadius</span><span style=\"color:#9ECBFF\">   `json:\"blastRadius\" yaml:\"blastRadius\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSafetyRules  []</span><span style=\"color:#B392F0\">SafetyRule</span><span style=\"color:#9ECBFF\">  `json:\"safetyRules\" yaml:\"safetyRules\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStatus       </span><span style=\"color:#B392F0\">ExperimentStatus</span><span style=\"color:#9ECBFF\"> `json:\"status\" yaml:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"createdAt\" yaml:\"createdAt\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStartedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"startedAt,omitempty\" yaml:\"startedAt,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCompletedAt  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"completedAt,omitempty\" yaml:\"completedAt,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Hypothesis defines the steady-state hypothesis for an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Hypothesis</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDescription </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"description\" yaml:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetrics     []</span><span style=\"color:#B392F0\">MetricThreshold</span><span style=\"color:#9ECBFF\"> `json:\"metrics\" yaml:\"metrics\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricThreshold defines acceptable bounds for a metric</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricThreshold</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"name\" yaml:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tQuery    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"query\" yaml:\"query\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMin      </span><span style=\"color:#F97583\">*float64</span><span style=\"color:#9ECBFF\"> `json:\"min,omitempty\" yaml:\"min,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMax      </span><span style=\"color:#F97583\">*float64</span><span style=\"color:#9ECBFF\"> `json:\"max,omitempty\" yaml:\"max,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"duration\" yaml:\"duration\"`</span><span style=\"color:#6A737D\"> // e.g., \"5m\", \"30s\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fault defines a single fault to inject</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Fault</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType       </span><span style=\"color:#B392F0\">FaultType</span><span style=\"color:#9ECBFF\">   `json:\"type\" yaml:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTarget     </span><span style=\"color:#B392F0\">Target</span><span style=\"color:#9ECBFF\">      `json:\"target\" yaml:\"target\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tParameters </span><span style=\"color:#B392F0\">FaultParams</span><span style=\"color:#9ECBFF\"> `json:\"parameters\" yaml:\"parameters\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BlastRadius limits the scope of an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BlastRadius</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPercentage  </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">  `json:\"percentage\" yaml:\"percentage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tServices    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"services,omitempty\" yaml:\"services,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tNamespaces  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"namespaces,omitempty\" yaml:\"namespaces,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SafetyRule defines conditions for automatic experiment abort</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SafetyRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetric    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"metric\" yaml:\"metric\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCondition </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"condition\" yaml:\"condition\"`</span><span style=\"color:#6A737D\"> // e.g., \"> 5%\", \"&#x3C; 200ms\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"duration\" yaml:\"duration\"`</span><span style=\"color:#6A737D\">   // How long condition must hold before abort</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>cmd/controller/main.go</code></strong> (Entry point skeleton)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">os/signal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/controller</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/persistence</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Additional imports as needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Load configuration from file and environment variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Initialize persistence layer (experiment store, cleanup registry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Initialize components: metrics collector, safety monitor, fault injector client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Create Orchestrator instance with all dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Set up HTTP server with API routes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Start background goroutines for experiment scheduling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Implement graceful shutdown on SIGTERM/SIGINT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Run HTTP server with health checks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tlog.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Chaos Platform Controller starting...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Example structure:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tdefer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Setup graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsigChan </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Signal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsignal.</span><span style=\"color:#B392F0\">Notify</span><span style=\"color:#E1E4E8\">(sigChan, syscall.SIGINT, syscall.SIGTERM)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tgo</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tsig </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">sigChan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tlog.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Received signal: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, initiating shutdown...\"</span><span style=\"color:#E1E4E8\">, sig)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">\t\tcancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t\t// Give services time to clean up</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\ttime.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tos.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO: Start server and block</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tserver </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tAddr:    </span><span style=\"color:#9ECBFF\">\":8080\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tHandler: </span><span style=\"color:#B392F0\">setupRouter</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#6A737D\">// Implement this</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\tif</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.ErrServerClosed {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t\tlog.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"HTTP server error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> setupRouter</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO: Create router, add middleware, register API routes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Use internal/api/v1 handlers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>File: <code>internal/controller/orchestrator.go</code></strong> (Core logic skeleton)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controller</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\t</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/metrics</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/safety</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">chaos-platform/internal/fault</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Orchestrator manages the lifecycle of chaos experiments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Orchestrator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmu              </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\texperiments     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExperimentInstance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tmetricsCollector </span><span style=\"color:#B392F0\">metrics</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Collector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tsafetyMonitor   </span><span style=\"color:#B392F0\">safety</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Monitor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tfaultInjector   </span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Injector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Additional fields as needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentInstance tracks runtime state of an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentInstance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tExperiment     </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tState          </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCancelFunc     </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetricsBaseline </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tResultsChan    </span><span style=\"color:#F97583\">chan&#x3C;-</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentResult</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Additional runtime fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartExperiment begins execution of a defined experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">exp</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">resultsChan</span><span style=\"color:#F97583\"> chan&#x3C;-</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentResult</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Validate experiment is in DRAFT state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Create ExperimentInstance with initial state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Store instance in orchestrator's map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Create context with cancellation for experiment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Launch executeStateMachine in a goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Return immediately (experiment runs asynchronously)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeStateMachine runs the experiment through its lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeStateMachine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Transition to BASELINE_VALIDATION</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: Collect baseline metrics using metricsCollector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Validate hypothesis against baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: If validation fails, transition to ABORTED and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Transition to INJECTING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: For each fault in experiment, call faultInjector.InjectFault()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 7: Register each fault with cleanup ensurer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 8: Transition to MONITORING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 9: Start safety monitoring for experiment duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 10: If safety breach detected, transition to ROLLBACK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 11: If duration elapsed, transition to ROLLBACK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 12: Clean up all faults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 13: Transition to ANALYSIS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 14: Collect post-experiment metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 15: Analyze results compared to baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 16: Generate experiment result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 17: Send result to resultsChan</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 18: Transition to COMPLETED or ABORTED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AbortExperiment forcefully stops an experiment and rolls back faults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AbortExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">experimentID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 1: Look up experiment instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 2: If experiment is in injectable state (INJECTING, MONITORING), cancel context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 3: Transition to ROLLBACK state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 4: Clean up all faults for this experiment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 5: Transition to ABORTED state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// TODO 6: Record abort reason</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>Go-Specific Patterns:</strong></p>\n<ul>\n<li>Use <code>context.Context</code> for cancellation across all goroutines</li>\n<li>Implement interfaces for testability: <code>type Injector interface { InjectFault(...) }</code></li>\n<li>Use <code>sync.Map</code> for concurrent access to experiment registry if high contention expected</li>\n<li>Leverage <code>time.Ticker</code> for periodic safety checks rather than <code>time.Sleep</code></li>\n<li>Use <code>os/exec</code> for running system commands (like <code>tc</code>) with proper timeout handling</li>\n</ul>\n<p><strong>Error Handling Strategy:</strong></p>\n<ul>\n<li>Use sentinel errors for expected failure cases: <code>var ErrExperimentNotFound = errors.New(&quot;experiment not found&quot;)</code></li>\n<li>Wrap system command errors with context: <code>fmt.Errorf(&quot;tc command failed: %w&quot;, err)</code></li>\n<li>Implement retry with exponential backoff for transient failures (network calls to metrics)</li>\n</ul>\n<p><strong>Concurrency Patterns:</strong></p>\n<ul>\n<li>One goroutine per experiment (managed by orchestrator)</li>\n<li>Worker pool for fault injection (limits concurrent system operations)</li>\n<li>Channel-based communication between components (non-blocking where possible)</li>\n</ul>\n<h4 id=\"milestone-checkpoint-architecture-validation\">Milestone Checkpoint: Architecture Validation</h4>\n<p>After setting up the basic structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build all components to verify dependencies</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/controller/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/injector-agent/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/safety-monitor/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests for core types</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/types/...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify the project structure compiles</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output: No errors, all binaries created in current directory</span></span></code></pre></div>\n\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Check that <code>internal/types</code> has no dependencies on other packages</li>\n<li>Verify each <code>cmd/</code> directory has a proper <code>main.go</code> with package <code>main</code></li>\n<li>Ensure <code>go.mod</code> declares correct module path</li>\n<li>Test that controller can be imported without circular dependency errors</li>\n</ol>\n<p><strong>Common Build Issues:</strong></p>\n<ul>\n<li><strong>Symptom</strong>: <code>import cycle not allowed</code><ul>\n<li><strong>Cause</strong>: Two-way dependency between packages</li>\n<li><strong>Fix</strong>: Refactor to move shared types to <code>internal/types</code>, use interfaces</li>\n</ul>\n</li>\n<li><strong>Symptom</strong>: <code>undefined: types.Experiment</code><ul>\n<li><strong>Cause</strong>: Incorrect import path or package name mismatch</li>\n<li><strong>Fix</strong>: Check <code>go.mod</code> module name matches import paths</li>\n</ul>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational data structures for entire platform)</p>\n</blockquote>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Mental Model: The Scientific Experiment Blueprint</strong>\nThink of the chaos engineering platform as a sophisticated laboratory that runs controlled experiments on complex systems. Just like a scientific experiment needs a <strong>protocol</strong> (defining the hypothesis, materials, methods, and analysis plan), our platform needs structured data models to represent every aspect of chaos experiments. The data model serves as the standardized blueprint that ensures experiments are well-defined, repeatable, analyzable, and—most importantly—safe.</p>\n</blockquote>\n<p>This section defines the core data structures that capture the complete lifecycle of chaos engineering: from experiment design and fault specification to hypothesis validation and result analysis. These structures form the backbone of the entire platform, ensuring consistency across components and enabling the safe, controlled injection of failures.</p>\n<p><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-datamodel.svg\" alt=\"Core Data Model Relationships\"></p>\n<h3 id=\"experiment-and-fault-definitions\">Experiment and Fault Definitions</h3>\n<blockquote>\n<p><strong>Mental Model: The Recipe for Controlled Chaos</strong>\nAn experiment definition is like a <strong>recipe for controlled chaos</strong>. It specifies exactly what ingredients (faults) to use, what system to test, what outcome to expect, and what safety precautions to take. Just as a recipe needs precise measurements and steps to ensure consistent results, our experiment definitions need structured fields to guarantee reproducible, safe experiments.</p>\n</blockquote>\n<p>The experiment data model captures everything needed to define, execute, and analyze a chaos experiment. At its core, an <code>Experiment</code> combines a <strong>steady-state hypothesis</strong> (what we expect to remain true) with a set of <strong>faults</strong> (what we&#39;re going to break) and <strong>safety controls</strong> (how we&#39;ll prevent catastrophe).</p>\n<h4 id=\"experiment-definition\">Experiment Definition</h4>\n<p>The <code>Experiment</code> struct represents a complete chaos experiment definition, from hypothesis through execution to results:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for the experiment, typically a UUID. Used to reference the experiment across all system components and for idempotent operations.</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Human-readable name for the experiment (e.g., &quot;Payment Service Latency Test&quot;). Used for display and organization purposes.</td>\n</tr>\n<tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Detailed description of the experiment&#39;s purpose, what it tests, and any important context. Helps future maintainers understand why the experiment exists.</td>\n</tr>\n<tr>\n<td><code>Hypothesis</code></td>\n<td><code>Hypothesis</code></td>\n<td>The steady-state hypothesis being tested. Defines the expected system behavior as a set of metric thresholds that should remain true during the experiment.</td>\n</tr>\n<tr>\n<td><code>Faults</code></td>\n<td><code>[]Fault</code></td>\n<td>Ordered list of faults to inject during the experiment. Multiple faults can be specified to simulate complex failure scenarios. The order matters—some faults may need to be applied sequentially.</td>\n</tr>\n<tr>\n<td><code>Schedule</code></td>\n<td><code>Schedule</code></td>\n<td>When and how often to run the experiment. Can be immediate, one-time future execution, or recurring (e.g., &quot;every Monday at 2 AM&quot;).</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>time.Duration</code></td>\n<td>How long to keep faults active once injected. After this duration, the system should automatically roll back faults even if no safety breach is detected.</td>\n</tr>\n<tr>\n<td><code>BlastRadius</code></td>\n<td><code>BlastRadius</code></td>\n<td>Scope limitation for the experiment. Defines what percentage of traffic or which specific services/namespaces are affected, ensuring experiments don&#39;t impact the entire system.</td>\n</tr>\n<tr>\n<td><code>SafetyRules</code></td>\n<td><code>[]SafetyRule</code></td>\n<td>Automatic abort conditions. If any of these rules evaluate to true during the experiment, the system immediately rolls back all faults and marks the experiment as aborted.</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>ExperimentStatus</code></td>\n<td>Current execution state of the experiment. Tracks progress through the experiment lifecycle (DRAFT → BASELINE_VALIDATION → INJECTING → etc.).</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp when the experiment was first defined. Used for auditing and to determine experiment age.</td>\n</tr>\n<tr>\n<td><code>StartedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Timestamp when experiment execution began (nil if not started). Used to calculate experiment duration and for timing analysis.</td>\n</tr>\n<tr>\n<td><code>CompletedAt</code></td>\n<td><code>*time.Time</code></td>\n<td>Timestamp when experiment reached final state (COMPLETED or ABORTED; nil if still in progress). Used to determine when cleanup can occur.</td>\n</tr>\n</tbody></table>\n<h4 id=\"hypothesis-definition\">Hypothesis Definition</h4>\n<p>The <code>Hypothesis</code> struct formalizes the expected system behavior that should remain true despite the injected faults:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Natural language description of what should remain true (e.g., &quot;User checkout flow completes within 2 seconds with &lt; 0.5% error rate&quot;).</td>\n</tr>\n<tr>\n<td><code>Metrics</code></td>\n<td><code>[]MetricThreshold</code></td>\n<td>Quantitative definitions of steady state. Each metric threshold specifies what &quot;normal&quot; looks like for a specific system metric.</td>\n</tr>\n</tbody></table>\n<h4 id=\"metric-threshold-definition\">Metric Threshold Definition</h4>\n<p>The <code>MetricThreshold</code> struct provides a precise, query-based definition of acceptable system behavior:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Descriptive name for this metric threshold (e.g., &quot;API Latency p95&quot;). Used in reports and UI displays.</td>\n</tr>\n<tr>\n<td><code>Query</code></td>\n<td><code>string</code></td>\n<td>Metric query expression that fetches the relevant time-series data. Format depends on the metrics backend (e.g., PromQL, SQL, or custom).</td>\n</tr>\n<tr>\n<td><code>Min</code></td>\n<td><code>*float64</code></td>\n<td>Minimum acceptable value (inclusive). If nil, no lower bound is enforced. Use for metrics like &quot;requests per second&quot; where you need at least some throughput.</td>\n</tr>\n<tr>\n<td><code>Max</code></td>\n<td><code>*float64</code></td>\n<td>Maximum acceptable value (inclusive). If nil, no upper bound is enforced. Use for metrics like &quot;latency&quot; or &quot;error rate&quot; where values should not exceed thresholds.</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>string</code></td>\n<td>Time window over which the metric must stay within bounds (e.g., &quot;30s&quot;, &quot;2m&quot;). This prevents transient spikes from triggering false aborts and ensures sustained violations are detected.</td>\n</tr>\n</tbody></table>\n<h4 id=\"fault-definition\">Fault Definition</h4>\n<p>The <code>Fault</code> struct defines a specific failure to inject into the system:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>FaultType</code></td>\n<td>Category of fault being injected. Determines which fault injection implementation to use. Common types: LATENCY, PACKET_LOSS, PROCESS_KILL, CPU_STRESS, MEMORY_STRESS, NETWORK_PARTITION.</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td><code>Target</code></td>\n<td>What system component to affect. Specifies the service, pod, container, or network path where the fault should be applied.</td>\n</tr>\n<tr>\n<td><code>Parameters</code></td>\n<td><code>FaultParams</code></td>\n<td>Configuration specific to this fault type. For latency: delay amount; for packet loss: percentage; for process kill: signal type; etc.</td>\n</tr>\n</tbody></table>\n<h4 id=\"blast-radius-definition\">Blast Radius Definition</h4>\n<p>The <code>BlastRadius</code> struct limits the scope of an experiment to prevent uncontrolled outages:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Percentage</code></td>\n<td><code>float64</code></td>\n<td>Percentage of traffic or instances to affect (0.0 to 100.0). For example, 10.0 means only 10% of requests or 10% of service instances experience the fault.</td>\n</tr>\n<tr>\n<td><code>Services</code></td>\n<td><code>[]string</code></td>\n<td>Specific service names to target (empty means all services). Provides precise targeting for experiments focused on particular microservices.</td>\n</tr>\n<tr>\n<td><code>Namespaces</code></td>\n<td><code>[]string</code></td>\n<td>Kubernetes namespaces to target (empty means all namespaces). Enables environment-specific testing (e.g., only staging namespaces).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight: The Importance of Blast Radius</strong>\nBlast radius is the most critical safety mechanism in chaos engineering. Without it, a single experiment could take down your entire production system. By default, new experiments should have a very small blast radius (e.g., 1% of traffic) that gradually increases as confidence grows.</p>\n</blockquote>\n<h4 id=\"safety-rule-definition\">Safety Rule Definition</h4>\n<p>The <code>SafetyRule</code> struct defines automatic abort conditions that protect the system:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Metric</code></td>\n<td><code>string</code></td>\n<td>Name of the metric to monitor (must match a <code>MetricThreshold.Name</code> from the hypothesis).</td>\n</tr>\n<tr>\n<td><code>Condition</code></td>\n<td><code>string</code></td>\n<td>Boolean expression that triggers abort when true (e.g., &quot;value &gt; 0.05&quot; for error rate &gt; 5%). The expression can reference the metric&#39;s current value as <code>value</code>.</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>string</code></td>\n<td>How long the condition must remain true before triggering abort (e.g., &quot;30s&quot;). Prevents transient spikes from unnecessarily aborting experiments.</td>\n</tr>\n</tbody></table>\n<h4 id=\"schedule-definition\">Schedule Definition</h4>\n<p>While not explicitly defined in the naming conventions, the <code>Schedule</code> type (referenced in <code>Experiment</code>) typically follows this structure:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>string</code></td>\n<td>Schedule type: &quot;immediate&quot;, &quot;one_time&quot;, or &quot;cron&quot;.</td>\n</tr>\n<tr>\n<td><code>When</code></td>\n<td><code>*time.Time</code></td>\n<td>For &quot;one_time&quot; schedules: when to run the experiment. For &quot;immediate&quot;: nil.</td>\n</tr>\n<tr>\n<td><code>CronExpression</code></td>\n<td><code>string</code></td>\n<td>For &quot;cron&quot; schedules: cron expression defining recurrence (e.g., &quot;0 2 * * 1&quot; for weekly Monday at 2 AM).</td>\n</tr>\n<tr>\n<td><code>TimeZone</code></td>\n<td><code>string</code></td>\n<td>Timezone for cron schedules (e.g., &quot;America/New_York&quot;).</td>\n</tr>\n</tbody></table>\n<h4 id=\"target-definition\">Target Definition</h4>\n<p>The <code>Target</code> struct (referenced in <code>Fault</code>) specifies where to apply a fault:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>string</code></td>\n<td>Target type: &quot;service&quot;, &quot;pod&quot;, &quot;node&quot;, &quot;network_path&quot;, or &quot;process&quot;.</td>\n</tr>\n<tr>\n<td><code>Selector</code></td>\n<td><code>map[string]string</code></td>\n<td>Key-value pairs for selecting the target. For services: {&quot;service&quot;: &quot;payment-service&quot;}. For pods: {&quot;namespace&quot;: &quot;production&quot;, &quot;label&quot;: &quot;app=payment&quot;}.</td>\n</tr>\n<tr>\n<td><code>Count</code></td>\n<td><code>int</code></td>\n<td>Number of instances to target (if applicable). For percentage-based selection, use blast radius percentage instead.</td>\n</tr>\n</tbody></table>\n<h4 id=\"fault-parameters-definition\">Fault Parameters Definition</h4>\n<p>The <code>FaultParams</code> type (referenced in <code>Fault</code>) is a flexible structure that varies by fault type. We represent it as a map with type-specific fields:</p>\n<table>\n<thead>\n<tr>\n<th>Fault Type</th>\n<th>Example Parameters</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LATENCY</code></td>\n<td><code>{&quot;delay_ms&quot;: &quot;200&quot;, &quot;jitter_ms&quot;: &quot;50&quot;, &quot;correlation&quot;: &quot;0.5&quot;}</code></td>\n<td>Adds network delay with optional jitter and correlation between packets.</td>\n</tr>\n<tr>\n<td><code>PACKET_LOSS</code></td>\n<td><code>{&quot;percentage&quot;: &quot;10&quot;, &quot;correlation&quot;: &quot;0.3&quot;}</code></td>\n<td>Drops a percentage of network packets with optional correlation.</td>\n</tr>\n<tr>\n<td><code>PROCESS_KILL</code></td>\n<td><code>{&quot;signal&quot;: &quot;SIGKILL&quot;, &quot;process_name&quot;: &quot;payment-processor&quot;}</code></td>\n<td>Kills a specific process with the given signal.</td>\n</tr>\n<tr>\n<td><code>CPU_STRESS</code></td>\n<td><code>{&quot;utilization_percent&quot;: &quot;90&quot;, &quot;duration&quot;: &quot;2m&quot;}</code></td>\n<td>Stresses CPU to target utilization percentage for given duration.</td>\n</tr>\n<tr>\n<td><code>MEMORY_STRESS</code></td>\n<td><code>{&quot;bytes&quot;: &quot;1073741824&quot;, &quot;duration&quot;: &quot;1m&quot;}</code></td>\n<td>Allocates specified bytes of memory for given duration.</td>\n</tr>\n<tr>\n<td><code>NETWORK_PARTITION</code></td>\n<td><code>{&quot;direction&quot;: &quot;both&quot;, &quot;from_selector&quot;: &quot;...&quot;, &quot;to_selector&quot;: &quot;...&quot;}</code></td>\n<td>Partitions network between two sets of pods/services.</td>\n</tr>\n</tbody></table>\n<h3 id=\"metrics-and-results\">Metrics and Results</h3>\n<blockquote>\n<p><strong>Mental Model: The Laboratory Notebook</strong>\nJust as a scientist meticulously records observations, measurements, and conclusions in a laboratory notebook, our platform captures detailed metrics and results for every experiment. This &quot;notebook&quot; serves multiple purposes: verifying the hypothesis, understanding system behavior under stress, identifying weaknesses, and providing evidence for improvements.</p>\n</blockquote>\n<p>The results data model captures what actually happened during an experiment—both the quantitative metrics and qualitative observations. This enables evidence-based decisions about system resilience.</p>\n<h4 id=\"experiment-result-definition\">Experiment Result Definition</h4>\n<p>The <code>ExperimentResult</code> struct captures the complete outcome of an experiment:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ExperimentID</code></td>\n<td><code>string</code></td>\n<td>References the original experiment definition. Links results back to the hypothesis and configuration.</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>ResultStatus</code></td>\n<td>Overall outcome: &quot;PASS&quot; (hypothesis confirmed), &quot;FAIL&quot; (hypothesis rejected), &quot;ABORTED&quot; (safety triggered), or &quot;ERROR&quot; (platform failure).</td>\n</tr>\n<tr>\n<td><code>StartTime</code></td>\n<td><code>time.Time</code></td>\n<td>When experiment execution began (copied from <code>Experiment.StartedAt</code>).</td>\n</tr>\n<tr>\n<td><code>EndTime</code></td>\n<td><code>time.Time</code></td>\n<td>When experiment reached final state (copied from <code>Experiment.CompletedAt</code>).</td>\n</tr>\n<tr>\n<td><code>HypothesisValidation</code></td>\n<td><code>HypothesisValidation</code></td>\n<td>Detailed validation results for each metric in the hypothesis, showing before/during/after comparisons.</td>\n</tr>\n<tr>\n<td><code>SafetyEvents</code></td>\n<td><code>[]SafetyEvent</code></td>\n<td>List of safety rule evaluations and any abort triggers that occurred.</td>\n</tr>\n<tr>\n<td><code>Observations</code></td>\n<td><code>[]Observation</code></td>\n<td>Human observations recorded during the experiment (by automated checks or human observers).</td>\n</tr>\n<tr>\n<td><code>FaultInjections</code></td>\n<td><code>[]FaultInjectionRecord</code></td>\n<td>Records of each fault that was injected, including timing and any errors.</td>\n</tr>\n<tr>\n<td><code>Error</code></td>\n<td><code>*string</code></td>\n<td>If the experiment ended in ERROR state, this captures what went wrong (e.g., &quot;failed to inject fault: permission denied&quot;).</td>\n</tr>\n</tbody></table>\n<h4 id=\"hypothesis-validation-definition\">Hypothesis Validation Definition</h4>\n<p>The <code>HypothesisValidation</code> struct provides detailed statistical validation of the hypothesis:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MetricResults</code></td>\n<td><code>[]MetricValidationResult</code></td>\n<td>Validation results for each metric threshold in the hypothesis.</td>\n</tr>\n<tr>\n<td><code>Overall</code></td>\n<td><code>bool</code></td>\n<td>Whether ALL metric thresholds were satisfied (true = hypothesis confirmed).</td>\n</tr>\n</tbody></table>\n<h4 id=\"metric-validation-result-definition\">Metric Validation Result Definition</h4>\n<p>The <code>MetricValidationResult</code> struct shows how a specific metric performed:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MetricName</code></td>\n<td><code>string</code></td>\n<td>Name of the metric being validated (from <code>MetricThreshold.Name</code>).</td>\n</tr>\n<tr>\n<td><code>Threshold</code></td>\n<td><code>MetricThreshold</code></td>\n<td>The threshold definition that was tested.</td>\n</tr>\n<tr>\n<td><code>Before</code></td>\n<td><code>MetricSample</code></td>\n<td>Metric values during the baseline period (before fault injection).</td>\n</tr>\n<tr>\n<td><code>During</code></td>\n<td><code>MetricSample</code></td>\n<td>Metric values during fault injection.</td>\n</tr>\n<tr>\n<td><code>After</code></td>\n<td><code>MetricSample</code></td>\n<td>Metric values during recovery period (after fault cleanup).</td>\n</tr>\n<tr>\n<td><code>Passed</code></td>\n<td><code>bool</code></td>\n<td>Whether the metric stayed within thresholds during the experiment.</td>\n</tr>\n<tr>\n<td><code>ViolationPeriods</code></td>\n<td><code>[]TimeRange</code></td>\n<td>Time ranges when the metric was outside acceptable thresholds (empty if passed).</td>\n</tr>\n</tbody></table>\n<h4 id=\"metric-sample-definition\">Metric Sample Definition</h4>\n<p>The <code>MetricSample</code> struct captures statistical summaries of metric values:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Min</code></td>\n<td><code>float64</code></td>\n<td>Minimum observed value during the period.</td>\n</tr>\n<tr>\n<td><code>Max</code></td>\n<td><code>float64</code></td>\n<td>Maximum observed value during the period.</td>\n</tr>\n<tr>\n<td><code>Mean</code></td>\n<td><code>float64</code></td>\n<td>Average value during the period.</td>\n</tr>\n<tr>\n<td><code>P95</code></td>\n<td><code>float64</code></td>\n<td>95th percentile value (useful for latency metrics).</td>\n</tr>\n<tr>\n<td><code>DataPoints</code></td>\n<td><code>int</code></td>\n<td>Number of data points collected.</td>\n</tr>\n<tr>\n<td><code>Duration</code></td>\n<td><code>time.Duration</code></td>\n<td>Time period covered by this sample.</td>\n</tr>\n</tbody></table>\n<h4 id=\"safety-event-definition\">Safety Event Definition</h4>\n<p>The <code>SafetyEvent</code> struct records safety rule evaluations:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Rule</code></td>\n<td><code>SafetyRule</code></td>\n<td>The safety rule that was evaluated.</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>time.Time</code></td>\n<td>When the evaluation occurred.</td>\n</tr>\n<tr>\n<td><code>Value</code></td>\n<td><code>float64</code></td>\n<td>Metric value at evaluation time.</td>\n</tr>\n<tr>\n<td><code>Triggered</code></td>\n<td><code>bool</code></td>\n<td>Whether the rule condition was met (true = should abort).</td>\n</tr>\n<tr>\n<td><code>DurationMet</code></td>\n<td><code>bool</code></td>\n<td>Whether the condition held for the required duration.</td>\n</tr>\n<tr>\n<td><code>ActionTaken</code></td>\n<td><code>string</code></td>\n<td>What action was taken if triggered (e.g., &quot;abort_initiated&quot;, &quot;logged_only&quot;).</td>\n</tr>\n</tbody></table>\n<h4 id=\"observation-definition\">Observation Definition</h4>\n<p>The <code>Observation</code> struct captures human or automated observations:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Time</code></td>\n<td><code>time.Time</code></td>\n<td>When the observation was recorded.</td>\n</tr>\n<tr>\n<td><code>Source</code></td>\n<td><code>string</code></td>\n<td>Who/what recorded it: &quot;automated_check&quot;, &quot;human_observer:alice&quot;, &quot;system_log&quot;.</td>\n</tr>\n<tr>\n<td><code>Message</code></td>\n<td><code>string</code></td>\n<td>The observation text (e.g., &quot;User interface became unresponsive at 14:32&quot;).</td>\n</tr>\n<tr>\n<td><code>Severity</code></td>\n<td><code>string</code></td>\n<td>Severity level: &quot;info&quot;, &quot;warning&quot;, &quot;error&quot;, &quot;critical&quot;.</td>\n</tr>\n</tbody></table>\n<h4 id=\"fault-injection-record-definition\">Fault Injection Record Definition</h4>\n<p>The <code>FaultInjectionRecord</code> tracks the execution of a specific fault:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FaultID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for this fault instance.</td>\n</tr>\n<tr>\n<td><code>FaultType</code></td>\n<td><code>FaultType</code></td>\n<td>Type of fault injected.</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td><code>string</code></td>\n<td>What was targeted (human-readable description).</td>\n</tr>\n<tr>\n<td><code>Parameters</code></td>\n<td><code>map[string]string</code></td>\n<td>Fault parameters used.</td>\n</tr>\n<tr>\n<td><code>InjectTime</code></td>\n<td><code>time.Time</code></td>\n<td>When the fault was successfully injected.</td>\n</tr>\n<tr>\n<td><code>CleanupTime</code></td>\n<td><code>*time.Time</code></td>\n<td>When the fault was cleaned up (nil if not yet cleaned).</td>\n</tr>\n<tr>\n<td><code>Status</code></td>\n<td><code>string</code></td>\n<td>Injection status: &quot;pending&quot;, &quot;injected&quot;, &quot;cleanup_failed&quot;, &quot;cleaned_up&quot;.</td>\n</tr>\n<tr>\n<td><code>Error</code></td>\n<td><code>*string</code></td>\n<td>Any error that occurred during injection or cleanup.</td>\n</tr>\n</tbody></table>\n<h4 id=\"cleanup-ensurer-and-fault-record\">Cleanup Ensurer and Fault Record</h4>\n<p>The <code>CleanupEnsurer</code> and <code>FaultRecord</code> types provide crash-safe fault cleanup:</p>\n<p><strong>CleanupEnsurer:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>mu</code></td>\n<td><code>sync.RWMutex</code></td>\n<td>Mutex for thread-safe access to the active faults map.</td>\n</tr>\n<tr>\n<td><code>filePath</code></td>\n<td><code>string</code></td>\n<td>Path to the persistence file where active faults are saved.</td>\n</tr>\n<tr>\n<td><code>activeFaults</code></td>\n<td><code>map[string]FaultRecord</code></td>\n<td>Map of fault ID to fault record for all currently active faults.</td>\n</tr>\n</tbody></table>\n<p><strong>FaultRecord:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ExperimentID</code></td>\n<td><code>string</code></td>\n<td>Which experiment this fault belongs to.</td>\n</tr>\n<tr>\n<td><code>FaultID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for this fault instance.</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td><code>string</code></td>\n<td>Target system component (for display and cleanup).</td>\n</tr>\n<tr>\n<td><code>FaultType</code></td>\n<td><code>string</code></td>\n<td>Type of fault (for determining cleanup method).</td>\n</tr>\n<tr>\n<td><code>InjectTime</code></td>\n<td><code>time.Time</code></td>\n<td>When the fault was injected.</td>\n</tr>\n<tr>\n<td><code>CleanupCmd</code></td>\n<td><code>string</code></td>\n<td>Command or method to clean up this fault (e.g., &quot;tc qdisc del dev eth0 root&quot;).</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>ADR: Structured vs. Flexible Fault Parameters</strong></p>\n<ul>\n<li><strong>Context</strong>: Faults have widely varying configuration needs. Latency needs delay amounts, packet loss needs percentages, process kill needs signal types.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Strictly typed structs</strong>: Each fault type has its own Go struct with validated fields.</li>\n<li><strong>Flexible map</strong>: All faults use <code>map[string]string</code> for parameters.</li>\n<li><strong>Protocol Buffers oneof</strong>: Use Protobuf&#39;s oneof to represent different parameter types.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use flexible <code>map[string]string</code> for parameters in the core data model.</li>\n<li><strong>Rationale</strong>: This provides maximum flexibility for new fault types without requiring schema changes. Validation happens in the fault injector implementation, not the data model. The map is easy to serialize/deserialize and pass between components.</li>\n<li><strong>Consequences</strong>: Parameters are not type-checked at compile time, requiring runtime validation. Documentation becomes crucial for knowing what parameters each fault type expects.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Strictly typed structs</td>\n<td>Compile-time type safety, IDE autocompletion</td>\n<td>Requires code changes for new fault types, harder to serialize</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Flexible map</td>\n<td>Extensible without code changes, easy serialization</td>\n<td>No compile-time checking, requires documentation</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Protocol Buffers oneof</td>\n<td>Type-safe extensibility, good serialization</td>\n<td>Complex setup, still requires proto changes for new types</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"experiment-status-constants\">Experiment Status Constants</h4>\n<p>The <code>ExperimentStatus</code> type uses these string constants to track experiment lifecycle:</p>\n<table>\n<thead>\n<tr>\n<th>Constant</th>\n<th>Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StateDraft</code></td>\n<td>&quot;DRAFT&quot;</td>\n<td>Experiment is defined but not yet scheduled or approved.</td>\n</tr>\n<tr>\n<td><code>StateBaselineValidation</code></td>\n<td>&quot;BASELINE_VALIDATION&quot;</td>\n<td>System is being checked to ensure it&#39;s in a steady state before fault injection.</td>\n</tr>\n<tr>\n<td><code>StateInjecting</code></td>\n<td>&quot;INJECTING&quot;</td>\n<td>Faults are being applied to the target system.</td>\n</tr>\n<tr>\n<td><code>StateMonitoring</code></td>\n<td>&quot;MONITORING&quot;</td>\n<td>Faults are active and system behavior is being observed.</td>\n</tr>\n<tr>\n<td><code>StateRollback</code></td>\n<td>&quot;ROLLBACK&quot;</td>\n<td>Faults are being cleaned up (either due to completion or abort).</td>\n</tr>\n<tr>\n<td><code>StateAnalysis</code></td>\n<td>&quot;ANALYSIS&quot;</td>\n<td>Results are being compiled and hypothesis is being evaluated.</td>\n</tr>\n<tr>\n<td><code>StateCompleted</code></td>\n<td>&quot;COMPLETED&quot;</td>\n<td>Experiment finished successfully (hypothesis confirmed or rejected).</td>\n</tr>\n<tr>\n<td><code>StateAborted</code></td>\n<td>&quot;ABORTED&quot;</td>\n<td>Experiment was aborted due to safety breach or manual intervention.</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data Serialization</td>\n<td>JSON (encoding/json) with Go struct tags</td>\n<td>Protocol Buffers with gRPC</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Direct Prometheus queries (prometheus/client_golang)</td>\n<td>Multi-backend abstraction (Prometheus, Datadog, Cloud Monitoring)</td>\n</tr>\n<tr>\n<td>Result Storage</td>\n<td>Local filesystem (JSON files)</td>\n<td>PostgreSQL with TimescaleDB extension</td>\n</tr>\n<tr>\n<td>Fault Parameter Validation</td>\n<td>Manual validation in each fault injector</td>\n<td>JSON Schema validation with shared definitions</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── chaos-controller/           # Main experiment orchestrator\n│   │   └── main.go\n│   └── chaos-agent/                # Fault injection agent\n│       └── main.go\n├── internal/\n│   ├── types/                      # Core data model definitions\n│   │   ├── experiment.go           # Experiment, Hypothesis, MetricThreshold\n│   │   ├── fault.go                # Fault, Target, FaultParams\n│   │   ├── results.go              # ExperimentResult, HypothesisValidation, etc.\n│   │   ├── safety.go               # SafetyRule, SafetyEvent\n│   │   └── schedule.go             # Schedule definitions\n│   ├── persistence/                # Data storage layer\n│   │   ├── experiment_store.go     # Experiment CRUD operations\n│   │   ├── result_store.go         # Result storage and retrieval\n│   │   └── cleanup_store.go        # CleanupEnsurer implementation\n│   └── validation/                 # Validation utilities\n│       ├── experiment_validator.go # Validates experiment definitions\n│       └── metric_validator.go     # Validates metric thresholds\n└── pkg/\n    ├── api/                        # REST API definitions\n    ├── metrics/                    # Metrics collection abstraction\n    └── fault/                      # Fault injection implementations</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Here&#39;s a complete, ready-to-use implementation of the core data types:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/types/experiment.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentStatus represents the lifecycle state of an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateDraft</span><span style=\"color:#B392F0\">              ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DRAFT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateBaselineValidation</span><span style=\"color:#B392F0\"> ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"BASELINE_VALIDATION\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateInjecting</span><span style=\"color:#B392F0\">          ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"INJECTING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateMonitoring</span><span style=\"color:#B392F0\">         ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"MONITORING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateRollback</span><span style=\"color:#B392F0\">           ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ROLLBACK\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateAnalysis</span><span style=\"color:#B392F0\">           ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ANALYSIS\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateCompleted</span><span style=\"color:#B392F0\">          ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"COMPLETED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tStateAborted</span><span style=\"color:#B392F0\">            ExperimentStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ABORTED\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Experiment defines a complete chaos experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Experiment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDescription  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tHypothesis   </span><span style=\"color:#B392F0\">Hypothesis</span><span style=\"color:#9ECBFF\">    `json:\"hypothesis\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tFaults       []</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#9ECBFF\">       `json:\"faults\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSchedule     </span><span style=\"color:#B392F0\">Schedule</span><span style=\"color:#9ECBFF\">      `json:\"schedule\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"duration\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tBlastRadius  </span><span style=\"color:#B392F0\">BlastRadius</span><span style=\"color:#9ECBFF\">   `json:\"blastRadius\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSafetyRules  []</span><span style=\"color:#B392F0\">SafetyRule</span><span style=\"color:#9ECBFF\">  `json:\"safetyRules\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStatus       </span><span style=\"color:#B392F0\">ExperimentStatus</span><span style=\"color:#9ECBFF\"> `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"createdAt\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStartedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"startedAt,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCompletedAt  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"completedAt,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Hypothesis defines the steady-state hypothesis being tested</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Hypothesis</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDescription </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetrics     []</span><span style=\"color:#B392F0\">MetricThreshold</span><span style=\"color:#9ECBFF\"> `json:\"metrics\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricThreshold defines acceptable bounds for a system metric</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricThreshold</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tName     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tQuery    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"query\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMin      </span><span style=\"color:#F97583\">*float64</span><span style=\"color:#9ECBFF\"> `json:\"min,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMax      </span><span style=\"color:#F97583\">*float64</span><span style=\"color:#9ECBFF\"> `json:\"max,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"duration\"`</span><span style=\"color:#6A737D\"> // e.g., \"30s\", \"2m\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BlastRadius limits the scope of an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BlastRadius</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tPercentage  </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">  `json:\"percentage\"`</span><span style=\"color:#6A737D\">  // 0.0 to 100.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tServices    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"services\"`</span><span style=\"color:#6A737D\">    // empty means all services</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tNamespaces  []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"namespaces\"`</span><span style=\"color:#6A737D\">  // empty means all namespaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SafetyRule defines an automatic abort condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SafetyRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tMetric    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"metric\"`</span><span style=\"color:#6A737D\">    // matches MetricThreshold.Name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCondition </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"condition\"`</span><span style=\"color:#6A737D\"> // e.g., \"value > 0.05\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tDuration  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"duration\"`</span><span style=\"color:#6A737D\">  // e.g., \"30s\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// internal/types/fault.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultType represents the category of fault to inject</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFaultTypeLatency</span><span style=\"color:#B392F0\">          FaultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LATENCY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFaultTypePacketLoss</span><span style=\"color:#B392F0\">       FaultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PACKET_LOSS\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFaultTypeProcessKill</span><span style=\"color:#B392F0\">      FaultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PROCESS_KILL\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFaultTypeCPUStress</span><span style=\"color:#B392F0\">        FaultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"CPU_STRESS\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFaultTypeMemoryStress</span><span style=\"color:#B392F0\">     FaultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"MEMORY_STRESS\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tFaultTypeNetworkPartition</span><span style=\"color:#B392F0\"> FaultType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"NETWORK_PARTITION\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Fault defines a specific failure to inject</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Fault</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType       </span><span style=\"color:#B392F0\">FaultType</span><span style=\"color:#9ECBFF\">           `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTarget     </span><span style=\"color:#B392F0\">Target</span><span style=\"color:#9ECBFF\">              `json:\"target\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tParameters </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"parameters\"`</span><span style=\"color:#6A737D\"> // fault-specific config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Target specifies where to apply a fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Target</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"type\"`</span><span style=\"color:#6A737D\">     // \"service\", \"pod\", \"node\", etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tSelector </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"selector\"`</span><span style=\"color:#6A737D\"> // key-value selectors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCount    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">               `json:\"count,omitempty\"`</span><span style=\"color:#6A737D\"> // number of instances</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// internal/types/schedule.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ScheduleType defines when an experiment should run</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ScheduleType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tScheduleImmediate</span><span style=\"color:#B392F0\"> ScheduleType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"IMMEDIATE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tScheduleOneTime</span><span style=\"color:#B392F0\">   ScheduleType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ONE_TIME\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">\tScheduleCron</span><span style=\"color:#B392F0\">      ScheduleType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"CRON\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Schedule defines when and how often to run an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Schedule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tType           </span><span style=\"color:#B392F0\">ScheduleType</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tWhen           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"when,omitempty\"`</span><span style=\"color:#6A737D\">           // for ONE_TIME</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCronExpression </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"cronExpression,omitempty\"`</span><span style=\"color:#6A737D\"> // for CRON</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tTimeZone       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"timeZone,omitempty\"`</span><span style=\"color:#6A737D\">       // for CRON</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>Here&#39;s skeleton code for the result validation logic that learners should implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/validation/metric_validator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> validation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateHypothesis checks if the system satisfies the hypothesis metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 1: Collect baseline metrics for each threshold in the hypothesis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 2: Apply statistical smoothing if duration is specified (e.g., moving average)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 3: Check each metric against its min/max bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 4: Return detailed results showing which metrics passed/failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 5: Include confidence intervals if sufficient data points are available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateHypothesis</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\thypothesis</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Hypothesis</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\tstartTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\tendTime</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">\tmetricsCollector</span><span style=\"color:#B392F0\"> MetricsCollector</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HypothesisValidation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">\t// Implementation goes here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">\treturn</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// internal/persistence/experiment_store.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> persistence</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\t\"</span><span style=\"color:#B392F0\">github.com/chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentFilter allows querying experiments by various criteria</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentFilter</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tStatus     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedAfter  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tCreatedBefore </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tNamePrefix </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tLimit       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">\tOffset      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 1: Implement CreateExperiment with validation and ID generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 2: Implement GetExperiment with proper error handling for not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 3: Implement ListExperiments with filtering and pagination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 4: Implement UpdateExperimentStatus for state transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO 5: Implement DeleteExperiment with cleanup of related resources</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Use <code>json</code> struct tags</strong>: All data model structs should include JSON struct tags for serialization/deserialization. Use <code>omitempty</code> for optional pointer fields.</p>\n</li>\n<li><p><strong>Time handling</strong>: Use <code>time.Time</code> for timestamps and <code>time.Duration</code> for durations. For JSON serialization of durations, you may want to implement custom marshaling/unmarshaling if you want human-readable strings like &quot;30s&quot; instead of nanoseconds.</p>\n</li>\n<li><p><strong>Thread safety</strong>: The <code>CleanupEnsurer</code> needs proper synchronization using <code>sync.RWMutex</code> since it will be accessed from multiple goroutines.</p>\n</li>\n<li><p><strong>Validation</strong>: Use the <code>validator</code> package (go-playground/validator) for struct validation, or implement custom validation logic for complex constraints like blast radius percentages.</p>\n</li>\n<li><p><strong>Error handling</strong>: Return descriptive error messages that help debug data model issues, especially for validation failures.</p>\n</li>\n</ol>\n<h4 id=\"common-pitfalls\">Common Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Missing field validation in data model</strong></p>\n<ul>\n<li><strong>Description</strong>: Not validating that blast radius percentage is between 0 and 100, or that schedule times are in the future.</li>\n<li><strong>Why it&#39;s wrong</strong>: Invalid experiments can be created that either do nothing (0% blast radius) or are impossible to schedule (past times).</li>\n<li><strong>How to fix</strong>: Implement comprehensive validation in the <code>CreateExperiment</code> method and reject invalid experiments with clear error messages.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not handling time zones in schedules</strong></p>\n<ul>\n<li><strong>Description</strong>: Storing cron schedule times without timezone information.</li>\n<li><strong>Why it&#39;s wrong</strong>: An experiment scheduled for &quot;2 AM&quot; will run at different times in different data centers, causing confusion and potential production issues.</li>\n<li><strong>How to fix</strong>: Always store timezone with schedules and convert to UTC for internal processing.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Using floating-point equality for metric thresholds</strong></p>\n<ul>\n<li><strong>Description</strong>: Checking <code>if value == 0.05</code> instead of <code>if value &gt; 0.05 - epsilon</code>.</li>\n<li><strong>Why it&#39;s wrong</strong>: Floating-point rounding errors can cause valid values to fail threshold checks.</li>\n<li><strong>How to fix</strong>: Use a small epsilon value (e.g., 1e-9) when comparing floating-point numbers, or use decimal types for precise calculations.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not persisting intermediate experiment state</strong></p>\n<ul>\n<li><strong>Description</strong>: Only storing experiment state when it reaches a final state (COMPLETED/ABORTED).</li>\n<li><strong>Why it&#39;s wrong</strong>: If the chaos controller crashes during an experiment, you lose all information about what was happening and can&#39;t resume or properly clean up.</li>\n<li><strong>How to fix</strong>: Persist state after every transition, and implement recovery logic that reads persisted state on startup.</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Fault Injection Framework) &amp; Milestone 5 (Network Chaos &amp; Infrastructure Faults)</p>\n</blockquote>\n<h2 id=\"component-design-fault-injection-framework\">Component Design: Fault Injection Framework</h2>\n<h3 id=\"mental-model-the-saboteur-in-the-factory\">Mental Model: The Saboteur in the Factory</h3>\n<p>Think of the fault injection framework as a <strong>controlled saboteur working on a factory assembly line</strong>. In a well-run factory, you have a complex system of machines (services), conveyor belts (network traffic), and power supplies (resources) all working together to produce goods. To test the factory&#39;s resilience, you hire a professional saboteur who can introduce specific, controlled defects exactly when and where you tell them to. This saboteur can:</p>\n<ol>\n<li><strong>Slow down a conveyor belt</strong> (network latency) to simulate transportation delays</li>\n<li><strong>Randomly drop packages</strong> (packet loss) to simulate damaged goods in transit</li>\n<li><strong>Turn off a specific machine</strong> (process kill) to test redundancy</li>\n<li><strong>Overload the power grid</strong> (resource exhaustion) to test backup generators</li>\n<li><strong>Build a temporary wall between two workstations</strong> (network partition) to test communication failures</li>\n</ol>\n<p>The key characteristics of this saboteur are:</p>\n<ul>\n<li><strong>Controlled</strong>: They only act on specific, authorized instructions</li>\n<li><strong>Reversible</strong>: Every defect they create can be completely undone</li>\n<li><strong>Observable</strong>: They report exactly what they did and when</li>\n<li><strong>Isolated</strong>: They never sabotage their own control systems or tools</li>\n</ul>\n<p>This mental model helps us understand the core responsibilities of the fault injection framework: to apply specific, reversible defects to a running system in a controlled manner, while ensuring the chaos platform itself remains operational.</p>\n<h3 id=\"interface-definition\">Interface Definition</h3>\n<p>The fault injection framework exposes a clean interface that other components (particularly the experiment orchestrator) use to inject and manage faults. This interface abstracts away the complexity of different fault types and execution environments.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>InjectFault</code></td>\n<td><code>fault Fault</code>, <code>experimentID string</code></td>\n<td><code>faultID string</code>, <code>error</code></td>\n<td>Applies the specified fault to the target system. Returns a unique fault identifier that can be used for subsequent operations. The fault is associated with the given experiment ID for tracking and cleanup.</td>\n</tr>\n<tr>\n<td><code>CleanupFault</code></td>\n<td><code>faultID string</code></td>\n<td><code>error</code></td>\n<td>Removes a previously injected fault, restoring normal operation. This must be idempotent - calling it multiple times on the same fault should not cause errors.</td>\n</tr>\n<tr>\n<td><code>GetFaultStatus</code></td>\n<td><code>faultID string</code></td>\n<td><code>FaultStatus</code>, <code>error</code></td>\n<td>Returns the current state of a fault, including whether it&#39;s active, what commands were executed, and any errors encountered.</td>\n</tr>\n<tr>\n<td><code>ListActiveFaults</code></td>\n<td><code>experimentID string</code></td>\n<td><code>[]FaultStatus</code>, <code>error</code></td>\n<td>Returns all active faults for a given experiment, useful for bulk cleanup or status monitoring.</td>\n</tr>\n<tr>\n<td><code>ValidateFault</code></td>\n<td><code>fault Fault</code></td>\n<td><code>[]ValidationError</code>, <code>error</code></td>\n<td>Validates that a fault definition is syntactically and semantically correct before attempting injection. Checks for things like required parameters, valid target selectors, and supported fault types.</td>\n</tr>\n</tbody></table>\n<p>The <code>Fault</code> parameter follows the data model defined earlier, but let&#39;s examine its structure in detail for this component&#39;s context:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>FaultType</code></td>\n<td>The type of fault to inject (e.g., <code>LATENCY</code>, <code>PACKET_LOSS</code>, <code>PROCESS_KILL</code>). Determines which injection mechanism to use.</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td><code>Target</code></td>\n<td>Specifies where to apply the fault. Contains a selector (like Kubernetes pod labels) and a count of how many instances to affect.</td>\n</tr>\n<tr>\n<td><code>Parameters</code></td>\n<td><code>FaultParams</code></td>\n<td>A key-value map of fault-specific parameters. For latency: <code>{&quot;delay&quot;: &quot;200ms&quot;, &quot;jitter&quot;: &quot;50ms&quot;}</code>. For packet loss: <code>{&quot;percentage&quot;: &quot;10%&quot;}</code>.</td>\n</tr>\n</tbody></table>\n<p>The returned <code>FaultStatus</code> structure provides visibility into fault execution:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FaultID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for this fault instance</td>\n</tr>\n<tr>\n<td><code>ExperimentID</code></td>\n<td><code>string</code></td>\n<td>Experiment this fault belongs to</td>\n</tr>\n<tr>\n<td><code>Type</code></td>\n<td><code>FaultType</code></td>\n<td>Type of fault</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td><code>string</code></td>\n<td>Human-readable description of what was targeted</td>\n</tr>\n<tr>\n<td><code>State</code></td>\n<td><code>FaultState</code></td>\n<td>Current state: <code>PENDING</code>, <code>INJECTING</code>, <code>ACTIVE</code>, <code>CLEANING</code>, <code>DONE</code>, <code>FAILED</code></td>\n</tr>\n<tr>\n<td><code>InjectTime</code></td>\n<td><code>*time.Time</code></td>\n<td>When the fault was successfully injected</td>\n</tr>\n<tr>\n<td><code>CleanupTime</code></td>\n<td><code>*time.Time</code></td>\n<td>When the fault was cleaned up</td>\n</tr>\n<tr>\n<td><code>Commands</code></td>\n<td><code>[]ExecutedCommand</code></td>\n<td>The actual OS commands or API calls made to inject/cleanup</td>\n</tr>\n<tr>\n<td><code>Error</code></td>\n<td><code>*string</code></td>\n<td>Any error that occurred during injection or cleanup</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior-and-state-machine\">Internal Behavior and State Machine</h3>\n<p>When the fault injector receives an <code>InjectFault</code> call, it follows a precise, stateful procedure to ensure reliable fault application. The algorithm proceeds through these steps:</p>\n<ol>\n<li><p><strong>Validation Phase</strong>: The fault definition is validated for correctness. This includes checking that all required parameters are present and valid (e.g., latency values are positive durations, packet loss percentages are between 0-100), verifying that the target selector matches at least one entity, and confirming the fault type is supported in the current environment.</p>\n</li>\n<li><p><strong>Target Resolution</strong>: The abstract <code>Target</code> selector is resolved to concrete instances. For example, if the target is <code>{&quot;app&quot;: &quot;payment-service&quot;}</code>, the injector queries the container runtime or Kubernetes API to find all pods matching those labels, then selects the specified number of instances (or all if no count specified).</p>\n</li>\n<li><p><strong>Privilege Check</strong>: The injector verifies it has the necessary permissions to apply the fault. Network faults require <code>CAP_NET_ADMIN</code> or root privileges, while process faults require appropriate process signal permissions. If running in a containerized environment, it checks for the necessary capabilities.</p>\n</li>\n<li><p><strong>Pre-flight Health Check</strong>: Before applying any destructive changes, the injector performs a quick health check on the target to ensure it&#39;s in a normal state. This prevents exacerbating existing problems.</p>\n</li>\n<li><p><strong>Fault Application</strong>: The specific fault implementation is executed. This involves:</p>\n<ul>\n<li>For network latency: Running <code>tc qdisc add</code> commands with <code>netem</code> parameters</li>\n<li>For packet loss: Configuring <code>iptables</code> rules with random drop probability</li>\n<li>For process kill: Sending <code>SIGTERM</code> or <code>SIGKILL</code> to the target PID</li>\n<li>For resource exhaustion: Starting stress-ng processes or configuring cgroup limits</li>\n<li>For network partition: Setting up <code>iptables</code> DROP rules between specific IP ranges</li>\n</ul>\n</li>\n<li><p><strong>Verification</strong>: After applying the fault, the injector verifies it was actually applied. For network faults, it runs <code>tc qdisc show</code> to confirm the rules exist. For process faults, it checks that the target process is no longer running (or has been restarted if that&#39;s the expected behavior).</p>\n</li>\n<li><p><strong>Registration</strong>: The fault is registered with the cleanup ensurer, which persists the fault details to disk. This ensures the fault can be cleaned up even if the orchestrator crashes.</p>\n</li>\n<li><p><strong>Monitoring</strong>: While active, the fault injector periodically verifies the fault is still in place (some faults, like process kills, are one-time events, while others like network rules need to persist).</p>\n</li>\n</ol>\n<p>The fault lifecycle follows a well-defined state machine:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PENDING</code></td>\n<td><code>INJECT_REQUESTED</code></td>\n<td><code>INJECTING</code></td>\n<td>Begin validation and target resolution</td>\n</tr>\n<tr>\n<td><code>INJECTING</code></td>\n<td><code>INJECTION_SUCCESS</code></td>\n<td><code>ACTIVE</code></td>\n<td>Register fault with cleanup ensurer, start monitoring timer</td>\n</tr>\n<tr>\n<td><code>INJECTING</code></td>\n<td><code>INJECTION_FAILED</code></td>\n<td><code>FAILED</code></td>\n<td>Log error, notify orchestrator</td>\n</tr>\n<tr>\n<td><code>ACTIVE</code></td>\n<td><code>CLEANUP_REQUESTED</code></td>\n<td><code>CLEANING</code></td>\n<td>Begin cleanup procedure</td>\n</tr>\n<tr>\n<td><code>ACTIVE</code></td>\n<td><code>MONITOR_TIMEOUT</code></td>\n<td><code>ACTIVE</code></td>\n<td>Verify fault still applied, reapply if necessary</td>\n</tr>\n<tr>\n<td><code>CLEANING</code></td>\n<td><code>CLEANUP_SUCCESS</code></td>\n<td><code>DONE</code></td>\n<td>Deregister from cleanup ensurer, release resources</td>\n</tr>\n<tr>\n<td><code>CLEANING</code></td>\n<td><code>CLEANUP_FAILED</code></td>\n<td><code>FAILED</code></td>\n<td>Log error, schedule retry, notify orchestrator</td>\n</tr>\n<tr>\n<td><code>FAILED</code></td>\n<td><code>RETRY_REQUESTED</code></td>\n<td><code>INJECTING</code> or <code>CLEANING</code></td>\n<td>Attempt operation again (with backoff)</td>\n</tr>\n<tr>\n<td>Any state</td>\n<td><code>FORCE_ABORT</code></td>\n<td><code>DONE</code></td>\n<td>Emergency cleanup, skip normal validation</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The state machine ensures that every fault has a clear lifecycle and that cleanup can always be attempted, even from failure states. The <code>FAILED</code> state is not terminal - retries can move the fault back to an operational state.</p>\n</blockquote>\n<p><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-seq-fault.svg\" alt=\"Sequence Diagram: Injecting a Network Latency Fault\"></p>\n<h3 id=\"adr-fault-injection-method-proxy-vs-sidecar\">ADR: Fault Injection Method (Proxy vs. Sidecar)</h3>\n<blockquote>\n<p><strong>Decision: Sidecar Agent Model for Fault Injection</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to inject faults into potentially containerized, distributed systems with minimal performance overhead and maximum compatibility. The system must work across different runtime environments (bare metal, VMs, containers) and support various fault types (network, process, resource).</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Proxy-based interception</strong>: All traffic flows through a chaos proxy that can inject latency, errors, or packet loss</li>\n<li><strong>Sidecar agent model</strong>: A lightweight agent runs alongside each service and modifies the host/container environment</li>\n<li><strong>Centralized daemon</strong>: A single powerful agent runs on each node and manages faults for all services on that node</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use a <strong>sidecar agent model</strong> for most faults, with selective use of proxy-based approaches for HTTP/gRPC-specific faults.</li>\n<li><strong>Rationale</strong>: <ul>\n<li><strong>Isolation</strong>: Sidecars can be isolated from their own faults (a network fault sidecar shouldn&#39;t lose its own control traffic)</li>\n<li><strong>Flexibility</strong>: Sidecars can inject process, resource, and network faults without requiring all traffic to flow through a proxy</li>\n<li><strong>Modern infrastructure alignment</strong>: Sidecars align with service mesh architectures (like Istio) which already use this pattern</li>\n<li><strong>Gradual adoption</strong>: Services can opt-in by deploying the sidecar, rather than requiring a wholesale infrastructure change</li>\n<li><strong>Performance</strong>: Avoids the single bottleneck and latency addition of a proxy for all traffic</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Can inject faults at multiple layers (network, process, resource), not just network traffic</li>\n<li><strong>Positive</strong>: Better isolation - if a fault crashes the sidecar, the service may continue (though fault cleanup might be affected)</li>\n<li><strong>Negative</strong>: More deployment complexity - each service needs the sidecar container</li>\n<li><strong>Negative</strong>: Resource overhead from running many sidecar instances</li>\n<li><strong>Mitigation</strong>: Use DaemonSets in Kubernetes for node-level agents where appropriate, and keep sidecars extremely lightweight</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Proxy-based</strong></td>\n<td>- Simple centralized control<br>- Can inspect/modify application-layer protocols<br>- Easy to implement for HTTP/gRPC</td>\n<td>- Single point of failure/bottleneck<br>- Requires routing all traffic through proxy<br>- Cannot inject process/resource faults<br>- Adds latency to all traffic</td>\n<td><strong>No</strong> for general faults, but useful for app-layer chaos</td>\n</tr>\n<tr>\n<td><strong>Sidecar Agent</strong></td>\n<td>- Fault isolation (agent not affected by its own faults)<br>- Can inject all fault types<br>- Aligns with service mesh patterns<br>- Gradual adoption possible</td>\n<td>- Deployment complexity<br>- Resource overhead<br>- Coordination needed across many agents</td>\n<td><strong>Yes</strong>, primary model</td>\n</tr>\n<tr>\n<td><strong>Centralized Daemon</strong></td>\n<td>- Less resource overhead than many sidecars<br>- Easy to manage/upgrade<br>- Can see whole node context</td>\n<td>- Single point of failure on node<br>- Less isolation (daemon crashes affect all faults)<br>- Security concerns (high privilege needed)</td>\n<td><strong>No</strong>, but useful for node-level faults</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Forgetting Root Privileges for Network Faults</strong></p>\n<ul>\n<li><strong>Description</strong>: Attempting to run <code>tc</code> or <code>iptables</code> commands without <code>CAP_NET_ADMIN</code> capability or root access</li>\n<li><strong>Why it&#39;s wrong</strong>: These commands fail silently or with permission errors, leaving the system in an inconsistent state where the orchestrator thinks a fault is active but it isn&#39;t</li>\n<li><strong>How to fix</strong>: <ol>\n<li>Always check privileges during the validation phase</li>\n<li>Run the fault injector with appropriate capabilities: <code>docker run --cap-add=NET_ADMIN</code></li>\n<li>For Kubernetes, use a privileged container or specific capabilities in the pod security context</li>\n<li>Provide clear error messages indicating the missing permissions</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Fault Injection Affecting the Chaos Tool Itself</strong></p>\n<ul>\n<li><strong>Description</strong>: Applying network partition or packet loss that isolates the fault injector from the orchestrator, creating a &quot;split-brain&quot; scenario</li>\n<li><strong>Why it&#39;s wrong</strong>: The orchestrator loses ability to monitor or clean up the fault, potentially leaving destructive changes permanently applied</li>\n<li><strong>How to fix</strong>:<ol>\n<li>Use <strong>control plane isolation</strong>: Ensure fault injector control traffic uses a separate network interface or VLAN</li>\n<li>Implement <strong>heartbeat monitoring</strong>: If the orchestrator loses contact with an injector, trigger automatic cleanup</li>\n<li>Use <strong>out-of-band management</strong>: For critical systems, have a separate management network for chaos control traffic</li>\n<li>Design faults to <strong>exclude control IPs</strong>: Automatically exclude orchestrator and injector IPs from network fault rules</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Non-idempotent Cleanup Operations</strong></p>\n<ul>\n<li><strong>Description</strong>: Cleanup commands that fail or behave incorrectly when run multiple times (e.g., trying to delete a <code>tc</code> rule that doesn&#39;t exist)</li>\n<li><strong>Why it&#39;s wrong</strong>: During retries or crash recovery, cleanup might be attempted multiple times, causing errors that prevent proper restoration</li>\n<li><strong>How to fix</strong>:<ol>\n<li>Design all cleanup operations to be <strong>idempotent</strong></li>\n<li>Use &quot;delete if exists&quot; patterns: <code>tc qdisc del dev eth0 root 2&gt;/dev/null || true</code></li>\n<li>Check current state before attempting modification</li>\n<li>Log but ignore &quot;already cleaned up&quot; errors during retry</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Resource Exhaustion Crashing the Injector</strong></p>\n<ul>\n<li><strong>Description</strong>: Running a CPU stress test that consumes all CPU on the node, starving the fault injector process itself</li>\n<li><strong>Why it&#39;s wrong</strong>: The injector becomes unresponsive and cannot monitor or clean up the fault</li>\n<li><strong>How to fix</strong>:<ol>\n<li>Use <strong>cgroups to isolate</strong> the stress process from the injector</li>\n<li>Set <strong>CPU affinity</strong> to restrict stress processes to specific cores</li>\n<li>Implement <strong>watchdog timers</strong> - if the injector doesn&#39;t check in, a separate monitor process triggers cleanup</li>\n<li>For memory exhaustion, use <strong>swap or memory limits</strong> to prevent complete node failure</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Assuming Process Kill Means Service Down</strong></p>\n<ul>\n<li><strong>Description</strong>: Killing a process without considering that it might be managed by a supervisor (systemd, Kubernetes, supervisord) that automatically restarts it</li>\n<li><strong>Why it&#39;s wrong</strong>: The &quot;fault&quot; has no observable effect - the service restarts so quickly that resilience appears perfect when it might not be</li>\n<li><strong>How to fix</strong>:<ol>\n<li><strong>Monitor actual availability</strong> during the fault, not just process existence</li>\n<li>For containerized environments, consider <strong>pod kill</strong> instead of process kill</li>\n<li>Optionally <strong>disable auto-restart</strong> during the experiment (but remember to re-enable it!)</li>\n<li>Measure <strong>recovery time</strong> rather than binary &quot;up/down&quot; status</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Network Faults</strong></td>\n<td><code>tc</code> (traffic control) with <code>netem</code> for latency/loss, <code>iptables</code> for packet manipulation</td>\n<td>eBPF programs for fine-grained, low-overhead network fault injection</td>\n</tr>\n<tr>\n<td><strong>Process Faults</strong></td>\n<td><code>kill</code> system calls via <code>os</code> package</td>\n<td><code>ptrace</code> or process namespace manipulation for more controlled faults</td>\n</tr>\n<tr>\n<td><strong>Resource Exhaustion</strong></td>\n<td><code>stress-ng</code> binary execution</td>\n<td>Direct cgroup manipulation via <code>github.com/containerd/cgroups</code></td>\n</tr>\n<tr>\n<td><strong>Command Execution</strong></td>\n<td><code>os/exec</code> package</td>\n<td>Agent model with gRPC for remote execution</td>\n</tr>\n<tr>\n<td><strong>Fault Persistence</strong></td>\n<td>JSON file on disk</td>\n<td>Embedded database (SQLite) or distributed store (etcd)</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── chaos-controller/          # Central orchestrator\n│   └── chaos-agent/               # Sidecar fault injector\n├── pkg/\n│   ├── fault/                     # Fault injection framework\n│   │   ├── injector.go            # Main interface and registry\n│   │   ├── types.go               # Fault types and constants\n│   │   ├── network/               # Network fault implementations\n│   │   │   ├── latency.go\n│   │   │   ├── packet_loss.go\n│   │   │   ├── partition.go\n│   │   │   └── network_utils.go   # tc/iptables helpers\n│   │   ├── process/               # Process fault implementations\n│   │   │   ├── kill.go\n│   │   │   └── restart.go\n│   │   ├── resource/              # Resource exhaustion implementations\n│   │   │   ├── cpu_stress.go\n│   │   │   ├── memory_stress.go\n│   │   │   └── disk_fill.go\n│   │   ├── registry.go            # Fault type registry\n│   │   └── cleanup/               # Cleanup ensurer implementation\n│   │       ├── ensurer.go\n│   │       └── persistence.go\n│   ├── orchestrator/              # Experiment orchestration\n│   └── metrics/                   # Metrics collection\n└── internal/\n    └── util/                      # Shared utilities</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-cleanup-ensurer\">Infrastructure Starter Code: Cleanup Ensurer</h4>\n<p>The cleanup ensurer is critical infrastructure that ensures faults are rolled back even if the orchestrator crashes. It persists fault records to disk and provides recovery on startup.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/fault/cleanup/ensurer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cleanup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultRecord represents a fault that needs cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExperimentID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"experiment_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"fault_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Target       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"target\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultType    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"fault_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InjectTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"inject_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CleanupCmd   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"cleanup_cmd\"`</span><span style=\"color:#6A737D\"> // Command to execute for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupEnsurer ensures faults are cleaned up even after crashes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupEnsurer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeFaults </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCleanupEnsurer creates a new cleanup ensurer with persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCleanupEnsurer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dataDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dataDir, </span><span style=\"color:#9ECBFF\">\"active_faults.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ensurer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filePath:     filePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeFaults: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load existing faults from disk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ensurer.</span><span style=\"color:#B392F0\">loadFromDisk</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to load fault records: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ensurer, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterFault records a fault that will need cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#B392F0\"> FaultRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.activeFaults[record.FaultID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">saveToDisk</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompleteFault removes a fault from cleanup registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CompleteFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.activeFaults[faultID]; </span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fault </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, faultID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(c.activeFaults, faultID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">saveToDisk</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetActiveFaults returns all faults needing cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetActiveFaults</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faults </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(c.activeFaults))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> c.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(faults, fault)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> faults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoverAndCleanup is called on startup to clean up any orphaned faults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecoverAndCleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cleanupFunc</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> cleanupErrors []</span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> id, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> c.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> cleanupFunc</span><span style=\"color:#E1E4E8\">(fault); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cleanupErrors </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cleanupErrors, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to cleanup fault </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, id, err))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Continue trying to clean up other faults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        delete</span><span style=\"color:#E1E4E8\">(c.activeFaults, id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">saveToDisk</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cleanupErrors </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cleanupErrors, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to save cleanup state: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cleanupErrors) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"recovery had errors: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, cleanupErrors)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// loadFromDisk loads active faults from the persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">loadFromDisk</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(c.filePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> faults []</span><span style=\"color:#B392F0\">FaultRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">faults); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to unmarshal fault records: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.activeFaults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> faults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.activeFaults[fault.FaultID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// saveToDisk saves active faults to the persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">saveToDisk</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faults </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(c.activeFaults))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> c.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(faults, fault)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(faults, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to marshal fault records: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write to temp file first, then rename for atomicity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tempPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.filePath </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(tempPath, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write temp file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Rename</span><span style=\"color:#E1E4E8\">(tempPath, c.filePath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-fault-injector\">Core Logic Skeleton: Fault Injector</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/fault/injector.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> fault</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Injector is the main interface for fault injection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Injector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu            </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    registry      </span><span style=\"color:#B392F0\">FaultRegistry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanupEnsurer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cleanup</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CleanupEnsurer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeFaults  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInstance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultInstance represents an active fault instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultInstance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExperimentID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Fault        </span><span style=\"color:#B392F0\">Fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State        </span><span style=\"color:#B392F0\">FaultState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status       </span><span style=\"color:#B392F0\">FaultStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CancelFunc   </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewInjector creates a new fault injector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewInjector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dataDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanupEnsurer, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cleanup.</span><span style=\"color:#B392F0\">NewCleanupEnsurer</span><span style=\"color:#E1E4E8\">(dataDir)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create cleanup ensurer: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        registry:      </span><span style=\"color:#B392F0\">NewFaultRegistry</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cleanupEnsurer: cleanupEnsurer,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeFaults:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInstance</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InjectFault applies the specified fault to the target system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InjectFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fault</span><span style=\"color:#B392F0\"> Fault</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">experimentID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate a unique fault ID using UUID or similar</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate the fault definition (check required parameters, valid target, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create a FaultInstance with initial state PENDING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if we have the required permissions for this fault type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Resolve the target selector to concrete instances (pods, containers, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Execute pre-flight health check on targets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Execute fault-specific injection logic (delegate to registered fault handler)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: If successful, update state to ACTIVE and register with cleanup ensurer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Start monitoring goroutine to periodically verify fault is still applied</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return fault ID and nil error on success</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupFault removes a previously injected fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    i.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> i.activeFaults[faultID]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    i.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fault </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, faultID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Update fault state to CLEANING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Cancel any monitoring goroutine for this fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute fault-specific cleanup logic (delegate to registered fault handler)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure cleanup is idempotent (safe to retry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If successful, update state to DONE and remove from activeFaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Notify cleanup ensurer that fault is complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Log cleanup completion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetFaultStatus returns the current state of a fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetFaultStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">FaultStatus</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    i.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> i.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> i.activeFaults[faultID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> FaultStatus</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fault </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, faultID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> instance.Status, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ListActiveFaults returns all active faults for an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ListActiveFaults</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">experimentID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">FaultStatus</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    i.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> i.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> faults []</span><span style=\"color:#B392F0\">FaultStatus</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, instance </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> i.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> instance.ExperimentID </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> experimentID {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(faults, instance.Status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> faults, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoverOrphanedFaults cleans up any faults that were active during a crash</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">i </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Injector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecoverOrphanedFaults</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get all active faults from cleanup ensurer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each fault, check if it's already in activeFaults (resumed session)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For faults not in activeFaults, attempt cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log recovery results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-network-latency-fault-implementation\">Core Logic Skeleton: Network Latency Fault Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/fault/network/latency.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> network</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LatencyFault implements network latency injection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LatencyFault</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Inject applies network latency to the target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">f </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LatencyFault</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Inject</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> Target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">params</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse parameters: delay (required), jitter (optional), correlation (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate parameters: delay must be positive duration (e.g., \"200ms\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Resolve target to specific network interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Build tc command: `tc qdisc add dev &#x3C;interface> root netem delay &#x3C;delay>`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add jitter if specified: `delay &#x3C;delay> &#x3C;jitter>`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Add correlation if specified: `delay &#x3C;delay> &#x3C;jitter> &#x3C;correlation>%`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Execute command with appropriate privileges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify command succeeded by checking `tc qdisc show dev &#x3C;interface>`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Return cleanup command for this fault</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup removes network latency from the target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">f </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LatencyFault</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> Target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cleanupCmd</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse cleanup command (contains interface name and original state)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute `tc qdisc del dev &#x3C;interface> root` to remove netem rule</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If deletion fails with \"No such file or directory\", log and return nil (idempotent)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify cleanup by checking `tc qdisc show dev &#x3C;interface>` doesn't show netem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// verifyTcRule checks if a tc rule is applied to an interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> verifyTcRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">interfaceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cmd </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> exec.</span><span style=\"color:#B392F0\">Command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"qdisc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"show\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"dev\"</span><span style=\"color:#E1E4E8\">, interfaceName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cmd.</span><span style=\"color:#B392F0\">Output</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to check tc rules: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if output contains \"netem\" (indicating latency rule)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(output), </span><span style=\"color:#9ECBFF\">\"netem\"</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><strong>Privilege Escalation</strong>: Use <code>exec.Command</code> with <code>sudo</code> or ensure the Go binary has <code>CAP_NET_ADMIN</code> capability set via <code>setcap cap_net_admin+ep /path/to/binary</code></li>\n<li><strong>Command Execution</strong>: Always use <code>exec.CommandContext</code> with timeout to prevent hanging if a command freezes</li>\n<li><strong>Error Handling</strong>: For OS commands, check both the error return and the exit code: <code>if err != nil || !cmd.ProcessState.Success()</code></li>\n<li><strong>Concurrency</strong>: Use <code>sync.RWMutex</code> for protecting the active faults map - multiple readers, single writer</li>\n<li><strong>ID Generation</strong>: Use <code>github.com/google/uuid</code> for generating unique fault IDs: <code>uuid.New().String()</code></li>\n<li><strong>Duration Parsing</strong>: Use <code>time.ParseDuration</code> for parsing strings like &quot;200ms&quot;, &quot;2s&quot;, &quot;1m30s&quot;</li>\n<li><strong>JSON Persistence</strong>: Use <code>encoding/json</code> with <code>MarshalIndent</code> for human-readable persistence files</li>\n<li><strong>Context Propagation</strong>: Use <code>context.WithCancel</code> for fault monitoring goroutines that need to be stopped during cleanup</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p><strong>Verification Command for Milestone 1:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run the chaos agent</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/chaos-agent</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./chaos-agent</span><span style=\"color:#79B8FF\"> --data-dir=/tmp/chaos</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In another terminal, test fault injection via API</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/faults/inject</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"type\": \"LATENCY\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"target\": {\"type\": \"pod\", \"selector\": {\"app\": \"demo-service\"}},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"parameters\": {\"delay\": \"200ms\", \"jitter\": \"50ms\"}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }'</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ol>\n<li>The agent should start and log &quot;Cleanup ensurer initialized&quot;</li>\n<li>The API call should return a JSON response with a <code>faultID</code></li>\n<li>The agent logs should show:<ul>\n<li>&quot;Injecting LATENCY fault on pod demo-service-xxx&quot;</li>\n<li>&quot;Executing: tc qdisc add dev eth0 root netem delay 200ms 50ms&quot;</li>\n<li>&quot;Fault injection successful, faultID: abc-123&quot;</li>\n</ul>\n</li>\n<li>Running <code>tc qdisc show dev eth0</code> on the target pod should show the netem rule</li>\n<li>Subsequent API call to list active faults should show the fault as ACTIVE</li>\n</ol>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>&quot;Permission denied&quot; errors: Agent needs <code>CAP_NET_ADMIN</code> or sudo</li>\n<li>&quot;No such file or directory&quot; for <code>tc</code>: Ensure <code>iproute2</code> package is installed</li>\n<li>Fault disappears immediately: Check if a network manager is overwriting tc rules</li>\n<li>Agent crashes on cleanup: Check idempotency of cleanup commands</li>\n</ul>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Experiment Orchestration) &amp; Milestone 4 (Steady-State Hypothesis &amp; Metrics Validation)</p>\n</blockquote>\n<h2 id=\"component-design-experiment-orchestration-engine\">Component Design: Experiment Orchestration Engine</h2>\n<p>The <strong>Experiment Orchestration Engine</strong> is the central nervous system of the chaos engineering platform. It transforms abstract experiment definitions into concrete, safe, and observable fault injection campaigns while rigorously testing hypotheses about system resilience. If the fault injection framework is the saboteur introducing controlled defects, the orchestrator is the scientist designing, monitoring, and analyzing the experiment.</p>\n<h3 id=\"mental-model-the-scientific-experiment-lab\">Mental Model: The Scientific Experiment Lab</h3>\n<p>Imagine a <strong>high-precision scientific laboratory</strong> studying material resilience. The lab doesn&#39;t randomly stress materials—it follows a rigorous experimental protocol: first, it establishes a baseline measurement of the material&#39;s normal properties. Then it formulates a hypothesis: &quot;This alloy will maintain structural integrity under 500°C for 5 minutes.&quot; Next, it applies controlled thermal stress while continuously monitoring deformation. If sensors detect catastrophic deformation approaching, it immediately removes heat (auto-rollback). Finally, it compares post-stress measurements to the baseline, determining if the hypothesis was validated or rejected.</p>\n<p>Similarly, the orchestrator treats each chaos experiment as a scientific study of system resilience:</p>\n<ul>\n<li><strong>Hypothesis</strong> = Steady-state prediction expressed as metric thresholds (error rate &lt; 1%, latency &lt; 200ms)</li>\n<li><strong>Baseline</strong> = System metrics collected during normal operation</li>\n<li><strong>Controlled stimulus</strong> = Precisely injected faults (latency, errors, resource exhaustion)</li>\n<li><strong>Continuous monitoring</strong> = Real-time metric collection during fault injection</li>\n<li><strong>Safety protocols</strong> = Automatic abort conditions preventing catastrophic failure</li>\n<li><strong>Results analysis</strong> = Statistical comparison of pre-fault, during-fault, and post-fault states</li>\n</ul>\n<p>This scientific approach transforms chaos engineering from random breaking to hypothesis-driven resilience validation.</p>\n<h3 id=\"interface-definition\">Interface Definition</h3>\n<p>The orchestrator exposes both a management API for experiment lifecycle operations and internal interfaces for coordinating with other components. The primary interface is the <code>Orchestrator</code> struct, which manages the complete lifecycle of experiment instances.</p>\n<h4 id=\"management-api-methods\">Management API Methods</h4>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateExperiment</code></td>\n<td><code>exp Experiment</code></td>\n<td><code>ExperimentID, error</code></td>\n<td>Validates experiment definition, stores it, assigns unique ID. Performs pre-flight validation of faults, targets, and metric queries.</td>\n</tr>\n<tr>\n<td><code>StartExperiment</code></td>\n<td><code>experimentID string, resultsChan chan&lt;- ExperimentResult</code></td>\n<td><code>error</code></td>\n<td>Begins execution of approved experiment. Creates experiment instance, starts state machine in goroutine, returns immediately. Results are streamed to the provided channel.</td>\n</tr>\n<tr>\n<td><code>AbortExperiment</code></td>\n<td><code>experimentID string, reason string</code></td>\n<td><code>error</code></td>\n<td>Forcefully stops running experiment. Triggers immediate fault cleanup, transitions to <code>ABORTED</code> state, records abort reason.</td>\n</tr>\n<tr>\n<td><code>GetExperimentStatus</code></td>\n<td><code>experimentID string</code></td>\n<td><code>ExperimentStatus, error</code></td>\n<td>Returns current status (DRAFT, RUNNING, COMPLETED, ABORTED) and progress percentage.</td>\n</tr>\n<tr>\n<td><code>ListExperiments</code></td>\n<td><code>filter ExperimentFilter</code></td>\n<td><code>[]Experiment, error</code></td>\n<td>Returns experiments matching criteria (status, time range, name prefix) with pagination support via <code>Limit</code> and <code>Offset</code>.</td>\n</tr>\n<tr>\n<td><code>GetExperimentResult</code></td>\n<td><code>experimentID string</code></td>\n<td><code>*ExperimentResult, error</code></td>\n<td>Retrieves detailed results including hypothesis validation, safety events, and fault injection records.</td>\n</tr>\n</tbody></table>\n<h4 id=\"internal-coordination-methods\">Internal Coordination Methods</h4>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>executeStateMachine</code></td>\n<td><code>instance *ExperimentInstance</code></td>\n<td>(none)</td>\n<td>Internal state machine driver. Runs in dedicated goroutine per experiment, transitions through states, coordinates component interactions.</td>\n</tr>\n<tr>\n<td><code>validateHypothesis</code></td>\n<td><code>hypothesis Hypothesis, baseline map[string]float64, duringMetrics map[string][]MetricPoint</code></td>\n<td><code>*HypothesisValidation, error</code></td>\n<td>Validates steady-state hypothesis against collected metrics. Compares baseline (pre-fault) metrics with during-fault metrics using statistical tests.</td>\n</tr>\n<tr>\n<td><code>checkSafetyRules</code></td>\n<td><code>rules []SafetyRule, metricsCollector metrics.Collector</code></td>\n<td><code>[]SafetyEvent, bool, error</code></td>\n<td>Continuously monitors safety rules during fault injection. Returns safety events and boolean indicating if any rule triggered abort condition.</td>\n</tr>\n<tr>\n<td><code>injectAllFaults</code></td>\n<td><code>faults []Fault, experimentID string</code></td>\n<td><code>[]FaultInjectionRecord, error</code></td>\n<td>Coordinates injection of all faults defined in experiment. Creates fault instances, calls fault injector, records injection metadata.</td>\n</tr>\n<tr>\n<td><code>cleanupAllFaults</code></td>\n<td><code>faults []FaultInstance</code></td>\n<td><code>[]FaultInjectionRecord, error</code></td>\n<td>Ensures all injected faults are cleaned up, even if some fail. Retries failed cleanups with exponential backoff.</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior-and-state-machine\">Internal Behavior and State Machine</h3>\n<p>The orchestrator implements a deterministic state machine that guides each experiment through its lifecycle. This state machine ensures proper sequencing (baseline collection before fault injection) and provides well-defined recovery points for failures.</p>\n<h4 id=\"experiment-state-machine\">Experiment State Machine</h4>\n<p><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-state-experiment.svg\" alt=\"Experiment Orchestration State Machine\"></p>\n<p>The state machine contains seven primary states with specific entry actions and exit conditions:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DRAFT</code></td>\n<td><code>StartExperiment()</code></td>\n<td><code>BASELINE_VALIDATION</code></td>\n<td>Validate experiment definition. Create <code>ExperimentInstance</code>. Initialize metrics baseline collection.</td>\n</tr>\n<tr>\n<td><code>BASELINE_VALIDATION</code></td>\n<td><code>Baseline metrics collected</code></td>\n<td><code>INJECTING</code></td>\n<td>Collect steady-state metrics for duration specified in hypothesis. Validate baseline meets hypothesis thresholds. If validation fails, transition to <code>ABORTED</code>.</td>\n</tr>\n<tr>\n<td><code>INJECTING</code></td>\n<td><code>All faults injected</code></td>\n<td><code>MONITORING</code></td>\n<td>Sequentially inject each fault via fault injector. Record injection timestamps and commands. Handle partial injection failures (cleanup injected faults, abort experiment).</td>\n</tr>\n<tr>\n<td><code>MONITORING</code></td>\n<td><code>Safety rule breach detected</code></td>\n<td><code>ROLLBACK</code></td>\n<td>Immediate transition regardless of duration. Record safety event. Cancel monitoring goroutines.</td>\n</tr>\n<tr>\n<td><code>MONITORING</code></td>\n<td><code>Experiment duration elapsed</code></td>\n<td><code>ROLLBACK</code></td>\n<td>Normal completion. Stop monitoring goroutines.</td>\n</tr>\n<tr>\n<td><code>ROLLBACK</code></td>\n<td><code>All faults cleaned up</code></td>\n<td><code>ANALYSIS</code></td>\n<td>Clean up all injected faults. Retry failed cleanups up to 3 times. Record cleanup timestamps.</td>\n</tr>\n<tr>\n<td><code>ANALYSIS</code></td>\n<td><code>Hypothesis validation complete</code></td>\n<td><code>COMPLETED</code></td>\n<td>Collect post-fault metrics. Validate hypothesis against baseline and during-fault metrics. Generate comprehensive result.</td>\n</tr>\n<tr>\n<td><code>ANALYSIS</code></td>\n<td><code>Validation error</code></td>\n<td><code>ABORTED</code></td>\n<td>If hypothesis validation fails due to system error (not hypothesis failure). Record error.</td>\n</tr>\n<tr>\n<td><em>Any state</em></td>\n<td><code>AbortExperiment()</code></td>\n<td><code>ABORTED</code></td>\n<td>Immediate fault cleanup. Cancel all goroutines. Record abort reason.</td>\n</tr>\n</tbody></table>\n<h4 id=\"detailed-algorithm-experiment-execution\">Detailed Algorithm: Experiment Execution</h4>\n<p>When <code>StartExperiment</code> is called, the orchestrator spawns a dedicated goroutine running the <code>executeStateMachine</code> function:</p>\n<ol>\n<li><p><strong>State: BASELINE_VALIDATION</strong></p>\n<ul>\n<li>Start metrics collection for all metrics referenced in hypothesis <code>MetricThresholds</code></li>\n<li>Wait for collection duration specified in each threshold&#39;s <code>Duration</code> field</li>\n<li>Calculate baseline statistics (mean, p95, min, max) for each metric</li>\n<li>Validate each baseline metric meets its threshold</li>\n<li><strong>If any baseline violates threshold:</strong> Transition to <code>ABORTED</code> with error &quot;System not in steady state before experiment&quot;</li>\n<li><strong>If all baselines valid:</strong> Transition to <code>INJECTING</code></li>\n</ul>\n</li>\n<li><p><strong>State: INJECTING</strong></p>\n<ul>\n<li>For each fault in experiment&#39;s <code>Faults</code> array:<ul>\n<li>Call fault injector&#39;s <code>ValidateFault()</code> for pre-flight validation</li>\n<li>Call <code>InjectFault()</code> with fault parameters and experiment ID</li>\n<li>Record <code>FaultInjectionRecord</code> with injection time and status</li>\n<li><strong>If injection fails:</strong> Attempt to clean up previously injected faults, then transition to <code>ABORTED</code></li>\n</ul>\n</li>\n<li>Start safety monitoring goroutine that continuously evaluates <code>SafetyRules</code></li>\n<li>Start metrics collection for hypothesis validation metrics</li>\n<li>Transition to <code>MONITORING</code></li>\n</ul>\n</li>\n<li><p><strong>State: MONITORING</strong></p>\n<ul>\n<li>Start timer for experiment <code>Duration</code></li>\n<li>Concurrently:<ul>\n<li>Monitor safety rules via <code>checkSafetyRules()</code> (runs every 5 seconds)</li>\n<li>Collect metrics for hypothesis validation</li>\n</ul>\n</li>\n<li><strong>If safety rule triggers:</strong> Transition to <code>ROLLBACK</code> immediately</li>\n<li><strong>If duration timer expires:</strong> Transition to <code>ROLLBACK</code> normally</li>\n</ul>\n</li>\n<li><p><strong>State: ROLLBACK</strong></p>\n<ul>\n<li>Stop safety monitoring and metrics collection goroutines</li>\n<li>For each active fault (in reverse injection order for dependency reasons):<ul>\n<li>Call <code>CleanupFault()</code> on fault injector</li>\n<li>Update <code>FaultInjectionRecord</code> with cleanup time and status</li>\n<li><strong>If cleanup fails:</strong> Retry with exponential backoff (max 3 attempts)</li>\n</ul>\n</li>\n<li><strong>If any fault cannot be cleaned after retries:</strong> Log critical error but continue (manual intervention required)</li>\n<li>Transition to <code>ANALYSIS</code></li>\n</ul>\n</li>\n<li><p><strong>State: ANALYSIS</strong></p>\n<ul>\n<li>Collect post-fault metrics (same duration as baseline collection)</li>\n<li>Call <code>validateHypothesis()</code> with:<ul>\n<li>Baseline metrics (pre-fault)</li>\n<li>During-fault metrics (collected during MONITORING state)</li>\n<li>Post-fault metrics (collected after rollback)</li>\n</ul>\n</li>\n<li>Generate <code>HypothesisValidation</code> result with statistical comparison</li>\n<li>Compile complete <code>ExperimentResult</code> including all safety events and fault injection records</li>\n<li>Send result to <code>resultsChan</code></li>\n<li>Transition to <code>COMPLETED</code></li>\n</ul>\n</li>\n<li><p><strong>State: COMPLETED/ABORTED</strong></p>\n<ul>\n<li>Clean up experiment instance resources</li>\n<li>Persist final result to storage</li>\n<li>Notify any registered listeners of experiment conclusion</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"safety-monitoring-algorithm\">Safety Monitoring Algorithm</h4>\n<p>The safety monitoring runs in a separate goroutine during the <code>MONITORING</code> state:</p>\n<ol>\n<li>For each <code>SafetyRule</code> in experiment&#39;s <code>SafetyRules</code>:<ul>\n<li>Parse <code>Condition</code> (e.g., &quot;error_rate &gt; 0.05&quot; for 5% error rate)</li>\n<li>Parse <code>Duration</code> (e.g., &quot;2m&quot; means condition must hold for 2 minutes)</li>\n</ul>\n</li>\n<li>Every 5 seconds (configurable sampling interval):<ul>\n<li>Query current value for each rule&#39;s metric via <code>GetCurrentValue()</code></li>\n<li>Evaluate condition against current value</li>\n<li>If condition is true:<ul>\n<li>Start/update timer for that rule</li>\n<li>If timer exceeds rule&#39;s <code>Duration</code>:<ul>\n<li>Record <code>SafetyEvent</code> with <code>Triggered: true</code>, <code>DurationMet: true</code></li>\n<li>Return trigger signal to state machine</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Else (condition false):<ul>\n<li>Reset timer for that rule</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Continue until state machine exits <code>MONITORING</code> state</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight:</strong> Safety rules use a <strong>duration threshold</strong> to prevent false positives from transient spikes. A 5% error rate for 30 seconds might be acceptable, but the same rate for 2 minutes indicates real degradation requiring auto-rollback.</p>\n</blockquote>\n<h3 id=\"adr-rollback-strategy-time-based-vs-condition-based\">ADR: Rollback Strategy (Time-based vs. Condition-based)</h3>\n<blockquote>\n<p><strong>Decision: Hybrid Rollback with Condition-based Safety Rules and Time-based Fallback</strong></p>\n<p><strong>Context:</strong> Chaos experiments must balance between gathering sufficient data during faults and preventing catastrophic system damage. The orchestrator needs a deterministic strategy for when to terminate fault injection and restore normal operation.</p>\n<p><strong>Options Considered:</strong></p>\n<ol>\n<li><strong>Pure Time-based:</strong> Experiments run for fixed duration specified in <code>Experiment.Duration</code>, then automatically rollback.</li>\n<li><strong>Pure Condition-based:</strong> Experiments run indefinitely until safety rules trigger auto-rollback.</li>\n<li><strong>Hybrid Approach:</strong> Experiments run until EITHER safety rules trigger OR maximum duration elapses, whichever comes first.</li>\n</ol>\n<p><strong>Decision:</strong> Implement hybrid approach (Option 3) as the default strategy.</p>\n<p><strong>Rationale:</strong> </p>\n<ul>\n<li><strong>Time-based alone</strong> risks excessive damage if faults cause degradation before duration elapses</li>\n<li><strong>Condition-based alone</strong> risks experiments running indefinitely if safety thresholds are improperly configured or metrics collection fails</li>\n<li><strong>Hybrid approach</strong> provides safety guarantee (rollback on degradation) while maintaining experiment determinism (maximum bound on runtime)</li>\n<li>This matches production chaos engineering practices at Netflix and Amazon, where GameDays have both safety monitors and strict timeboxes</li>\n</ul>\n<p><strong>Consequences:</strong></p>\n<ul>\n<li>Requires implementing both safety rule evaluation and duration timers</li>\n<li>Experiments may end earlier than planned if safety triggers, reducing fault exposure time</li>\n<li>Provides defense against &quot;runaway experiments&quot; where safety monitoring fails</li>\n<li>Simplifies experiment scheduling (known maximum runtime)</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure Time-based</td>\n<td>Simple to implement, predictable runtime</td>\n<td>No protection against rapid degradation before timeout</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Pure Condition-based</td>\n<td>Maximally safe, adapts to system response</td>\n<td>Risk of infinite run if rules never trigger, harder to schedule</td>\n<td>❌</td>\n</tr>\n<tr>\n<td><strong>Hybrid Approach</strong></td>\n<td>Safety protection + time bounding, matches industry practice</td>\n<td>Slightly more complex implementation</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<h4 id=\"-pitfall-skipping-steady-state-verification\">⚠️ <strong>Pitfall: Skipping Steady-State Verification</strong></h4>\n<p><strong>Description:</strong> Injecting faults before verifying the system is in a healthy, steady state. For example, starting a CPU stress experiment when the system already has 90% CPU utilization.\n<strong>Why it&#39;s wrong:</strong> You can&#39;t measure the impact of chaos if you don&#39;t have a valid baseline. The experiment results become meaningless (&quot;system was already broken&quot;). More dangerously, you might push an already degraded system over the edge into failure.\n<strong>How to fix:</strong> Always implement the <code>BASELINE_VALIDATION</code> state. Collect metrics for the duration specified in the hypothesis thresholds, and abort the experiment if any baseline metric violates its threshold. Log the violation clearly: &quot;Aborted experiment: baseline error rate 2.1% exceeds threshold 1.0%.&quot;</p>\n<h4 id=\"-pitfall-not-handling-orphaned-faults\">⚠️ <strong>Pitfall: Not Handling Orphaned Faults</strong></h4>\n<p><strong>Description:</strong> The orchestrator crashes during fault injection, leaving faults active with no cleanup mechanism.\n<strong>Why it&#39;s wrong:</strong> Chaos becomes uncontrolled—injected latency, packet loss, or resource exhaustion persists indefinitely, causing ongoing production issues.\n<strong>How to fix:</strong> Implement a <strong>cleanup ensurer</strong> pattern. Before injecting any fault, record it in a persistent registry (e.g., JSON file on disk) with enough information to clean it up. On orchestrator startup, scan for orphaned faults and clean them up. The <code>CleanupEnsurer</code> struct provides this capability.</p>\n<h4 id=\"-pitfall-ignoring-metric-collection-lag\">⚠️ <strong>Pitfall: Ignoring Metric Collection Lag</strong></h4>\n<p><strong>Description:</strong> Assuming metrics are real-time when they actually have 30-60 second aggregation windows in systems like Prometheus.\n<strong>Why it&#39;s wrong:</strong> Safety rules may trigger too late because they&#39;re evaluating stale data. By the time the metrics show 10% error rate, the actual system might already be at 40%.\n<strong>How to fix:</strong> Use a combination of metrics: fast local metrics (application logs, local health checks) for immediate safety triggers, and aggregated metrics for hypothesis validation. Document the expected lag for each metric source in your platform documentation.</p>\n<h4 id=\"-pitfall-single-safety-monitor-failure-point\">⚠️ <strong>Pitfall: Single Safety Monitor Failure Point</strong></h4>\n<p><strong>Description:</strong> Running safety monitoring in the same process as the orchestrator without redundancy.\n<strong>Why it&#39;s wrong:</strong> If the orchestrator process crashes, safety monitoring stops, but injected faults continue.\n<strong>How to fix:</strong> Implement a <strong>distributed safety monitor</strong> pattern where multiple independent monitors watch the same metrics. Alternatively, configure external monitoring systems (like Prometheus alerts) as backup abort triggers. At minimum, ensure the cleanup ensurer runs as a separate watchdog process.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Machine</td>\n<td>Explicit switch-case in <code>executeStateMachine</code></td>\n<td>State pattern with <code>State</code> interface and concrete implementations</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Direct Prometheus HTTP API queries</td>\n<td>Abstract <code>MetricsCollector</code> interface with adapters for Prometheus, Datadog, CloudWatch</td>\n</tr>\n<tr>\n<td>Safety Rule Evaluation</td>\n<td>Simple expression parser (e.g., <code>govaluate</code>)</td>\n<td>Custom DSL compiler with optimized evaluation engine</td>\n</tr>\n<tr>\n<td>Persistence</td>\n<td>JSON files on local disk</td>\n<td>PostgreSQL with GORM/ent for rich querying</td>\n</tr>\n<tr>\n<td>Concurrency</td>\n<td>Goroutines with channels for coordination</td>\n<td>Actor model using <code>proto.Actor</code> or <code>errgroup</code> with context cancellation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   └── orchestrator/\n│       └── main.go                 # Orchestrator service entry point\n├── internal/\n│   ├── orchestrator/\n│   │   ├── orchestrator.go         # Main Orchestrator struct and public API\n│   │   ├── state_machine.go        # executeStateMachine and state transitions\n│   │   ├── hypothesis_validator.go # validateHypothesis implementation\n│   │   ├── safety_monitor.go       # checkSafetyRules implementation\n│   │   ├── cleanup_ensurer.go      # CleanupEnsurer for fault persistence\n│   │   └── orchestrator_test.go    # Comprehensive tests\n│   ├── metrics/\n│   │   ├── collector.go            # MetricsCollector interface\n│   │   └── prometheus.go           # Prometheus implementation\n│   ├── types/\n│   │   └── experiment.go           # Experiment, Hypothesis, MetricThreshold types\n│   └── storage/\n│       ├── experiment_store.go     # Experiment persistence interface\n│       └── filestore.go            # File-based implementation\n└── pkg/\n    └── api/\n        └── v1/\n            └── experiment.go       # REST/GRPC API definitions</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-cleanupensurer\">Infrastructure Starter Code: CleanupEnsurer</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/orchestrator/cleanup_ensurer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> orchestrator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultRecord represents a fault that needs cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExperimentID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"experimentId\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"faultId\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Target       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"target\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FaultType    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"faultType\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InjectTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"injectTime\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CleanupCmd   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"cleanupCmd\"`</span><span style=\"color:#6A737D\"> // Command to execute for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupEnsurer ensures faults are cleaned up even after crashes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupEnsurer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeFaults </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCleanupEnsurer creates a cleanup ensurer with persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCleanupEnsurer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dataDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filePath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dataDir, </span><span style=\"color:#9ECBFF\">\"active_faults.json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ensurer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        filePath:     filePath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeFaults: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load existing active faults on startup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ensurer.</span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"loading active faults: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ensurer, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterFault records a fault that will need cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#B392F0\"> FaultRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.activeFaults[record.FaultID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompleteFault removes a fault from cleanup registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CompleteFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    delete</span><span style=\"color:#E1E4E8\">(c.activeFaults, faultID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetOrphanedFaults returns all faults that are still active</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetOrphanedFaults</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faults </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(c.activeFaults))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> c.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(faults, fault)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> faults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupOrphanedFaults executes cleanup for all orphaned faults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupOrphanedFaults</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cleanupFunc</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    orphaned </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">GetOrphanedFaults</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> cleanupErrors []</span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> orphaned {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> cleanupFunc</span><span style=\"color:#E1E4E8\">(fault); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cleanupErrors </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cleanupErrors, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cleaning up fault </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, fault.FaultID, err))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Only remove from registry if cleanup succeeded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">CompleteFault</span><span style=\"color:#E1E4E8\">(fault.FaultID); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cleanupErrors </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cleanupErrors, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(cleanupErrors) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to cleanup some faults: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, cleanupErrors)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// load reads active faults from persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">load</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(c.filePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> faults []</span><span style=\"color:#B392F0\">FaultRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">faults); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.activeFaults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> faults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.activeFaults[fault.FaultID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// save writes active faults to persistence file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">save</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faults </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(c.activeFaults))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, fault </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> c.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(faults, fault)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(faults, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write to temp file first, then rename for atomicity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tempPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.filePath </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \".tmp\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(tempPath, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Rename</span><span style=\"color:#E1E4E8\">(tempPath, c.filePath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-experiment-state-machine\">Core Logic Skeleton: Experiment State Machine</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/orchestrator/state_machine.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> orchestrator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeStateMachine runs the experiment through its lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeStateMachine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Cleanup resources on exit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(instance.ResultsChan)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        o.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        delete</span><span style=\"color:#E1E4E8\">(o.experiments, instance.Experiment.ID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        o.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance.CancelFunc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cancel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // State machine loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Continue state execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> instance.State {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> types.StateBaselineValidation:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            o.</span><span style=\"color:#B392F0\">executeBaselineValidation</span><span style=\"color:#E1E4E8\">(ctx, instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> types.StateInjecting:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            o.</span><span style=\"color:#B392F0\">executeInjecting</span><span style=\"color:#E1E4E8\">(ctx, instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> types.StateMonitoring:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            o.</span><span style=\"color:#B392F0\">executeMonitoring</span><span style=\"color:#E1E4E8\">(ctx, instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> types.StateRollback:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            o.</span><span style=\"color:#B392F0\">executeRollback</span><span style=\"color:#E1E4E8\">(ctx, instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> types.StateAnalysis:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            o.</span><span style=\"color:#B392F0\">executeAnalysis</span><span style=\"color:#E1E4E8\">(ctx, instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> types.StateCompleted, types.StateAborted:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Final states - exit state machine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            o.</span><span style=\"color:#B392F0\">persistExperimentResult</span><span style=\"color:#E1E4E8\">(instance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            log.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown state </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> for experiment </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, instance.State, instance.Experiment.ID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            instance.State </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> types.StateAborted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeBaselineValidation implements BASELINE_VALIDATION state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeBaselineValidation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instance.Experiment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For each MetricThreshold in exp.Hypothesis.Metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Parse Duration field (e.g., \"2m\" -> 2 minutes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Start collecting metric via metricsCollector.GetMetric() with appropriate step</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for all metric collection to complete (or context cancellation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use time.After() for timeout based on the longest duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check ctx.Done() for cancellation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate baseline statistics for each metric</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store min, max, mean, p95 in instance.MetricsBaseline map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate each baseline against its threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For each threshold, check if baseline value within [Min, Max] range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If any threshold violated, transition to ABORTED with error message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If all baselines valid, transition to INJECTING state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - instance.State = types.StateInjecting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle errors gracefully - log and transition to ABORTED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeMonitoring implements MONITORING state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeMonitoring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exp </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> instance.Experiment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start duration timer for exp.Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    durationTimer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTimer</span><span style=\"color:#E1E4E8\">(exp.Duration)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start safety monitoring goroutine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Pass exp.SafetyRules to checkSafetyRules()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Channel to receive safety events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start metrics collection goroutine for hypothesis validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Collect metrics referenced in exp.Hypothesis.Metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store in buffer for later analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for either:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Duration timer expiry (normal completion)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Safety rule trigger (emergency rollback)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Context cancellation (external abort)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If safety rule triggered:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Record SafetyEvent in instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Transition to ROLLBACK state immediately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If duration timer expired:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Transition to ROLLBACK state normally</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Clean up monitoring goroutines before exiting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// validateHypothesis validates steady-state hypothesis against collected metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validateHypothesis</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    hypothesis</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Hypothesis</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    baseline</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    duringMetrics</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HypothesisValidation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HypothesisValidation</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MetricResults: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetricValidationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(hypothesis.Metrics)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For each MetricThreshold in hypothesis.Metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Retrieve baseline value from baseline map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate statistics from duringMetrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Compute min, max, mean, p95 during fault injection period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store in MetricSample struct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply statistical validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check if during-metrics stay within threshold bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - For thresholds with Duration, check violation persistence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Record violation periods if any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Determine if metric passed validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Pass = during-metrics within bounds AND no prolonged violations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set overall hypothesis validation result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Overall = true only if ALL metrics passed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return comprehensive validation result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Concurrency Pattern:</strong> Use <code>errgroup.WithContext</code> for managing related goroutines in monitoring state. It provides automatic cancellation if any goroutine fails.</p>\n</li>\n<li><p><strong>Metrics Collection:</strong> Implement <code>MetricsCollector</code> interface with caching to avoid overwhelming metrics backend with duplicate queries during baseline and monitoring phases.</p>\n</li>\n<li><p><strong>State Persistence:</strong> For crash recovery, periodically checkpoint experiment state to disk. Use atomic file writes (write to temp file, then rename) to prevent corruption.</p>\n</li>\n<li><p><strong>Expression Evaluation:</strong> Use <code>github.com/Knetic/govaluate</code> for simple safety rule condition parsing (e.g., <code>&quot;error_rate &gt; 0.05 AND latency_p95 &gt; 200&quot;</code>).</p>\n</li>\n<li><p><strong>Testing:</strong> Use fake implementations of <code>MetricsCollector</code> and <code>fault.Injector</code> for unit testing state transitions without real dependencies.</p>\n</li>\n</ol>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p><strong>Command to verify implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run orchestrator tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/orchestrator/...</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -count=1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output should show:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ TestExperimentStateMachine_ValidBaseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ TestExperimentStateMachine_BaselineViolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ TestExperimentStateMachine_SafetyTrigger</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ✓ TestExperimentStateMachine_CleanupOnAbort</span></span></code></pre></div>\n\n<p><strong>Manual verification steps:</strong></p>\n<ol>\n<li>Start the orchestrator service: <code>go run cmd/orchestrator/main.go</code></li>\n<li>Create an experiment definition file <code>test-exp.json</code> with a simple hypothesis (e.g., &quot;CPU utilization &lt; 80%&quot;)</li>\n<li>Submit via API: <code>curl -X POST http://localhost:8080/experiments -d @test-exp.json</code></li>\n<li>Verify experiment transitions through states:<ul>\n<li>Initially shows as <code>DRAFT</code></li>\n<li>After starting, shows <code>BASELINE_VALIDATION</code> for 1-2 minutes</li>\n<li>If baseline valid, transitions to <code>INJECTING</code> then <code>MONITORING</code></li>\n<li>After duration, transitions to <code>ROLLBACK</code>, <code>ANALYSIS</code>, then <code>COMPLETED</code></li>\n</ul>\n</li>\n<li>Check results show hypothesis validation with actual metric values.</li>\n</ol>\n<p><strong>Debugging signs:</strong></p>\n<ul>\n<li>Experiment stuck in <code>BASELINE_VALIDATION</code>: Likely metrics query failing. Check metrics collector connectivity.</li>\n<li>Faults not injecting: Fault injector not reachable or validation failing. Check fault injector logs.</li>\n<li>No auto-rollback on degradation: Safety rules not evaluating correctly. Check rule syntax and metric names.</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (GameDay Automation)</p>\n</blockquote>\n<h2 id=\"component-design-gameday-automation\">Component Design: GameDay Automation</h2>\n<p>The <strong>GameDay Automation</strong> component elevates chaos engineering from isolated experiments to coordinated, realistic disaster simulations. While the <code>Orchestrator</code> runs single experiments, the GameDay engine sequences multiple experiments, integrates manual runbooks, and simulates incident response workflows, turning theoretical resilience into practiced preparedness.</p>\n<h3 id=\"mental-model-the-disaster-simulation-drill\">Mental Model: The Disaster Simulation Drill</h3>\n<p>Think of a GameDay as a city-wide emergency response drill, like a simulated earthquake or hurricane. City officials don&#39;t just test one building&#39;s fire alarm; they coordinate multiple agencies (fire, police, hospitals), simulate cascading failures (power grid down, communications overload), and practice recovery protocols with real people following checklists. Similarly, a GameDay:</p>\n<ol>\n<li><strong>Orchestrates multiple, related failure scenarios</strong> in a logical sequence (e.g., first a network partition, then a database CPU spike during the resulting recovery attempt).</li>\n<li><strong>Involves human observers and responders</strong> who follow runbooks, make decisions, and practice communication, just as they would in a real incident.</li>\n<li><strong>Simulates the pressure and ambiguity</strong> of a real outage by introducing &quot;injects&quot;—external events like a simulated customer complaint or a management escalation—that the team must handle.</li>\n<li><strong>Generates a comprehensive after-action report</strong> detailing what broke, how the team responded, and what improvements are needed.</li>\n</ol>\n<p>This component is the <strong>drill conductor</strong>, managing the timeline, pausing for manual steps, collecting observations, and ensuring the simulation remains safe and informative.</p>\n<h3 id=\"interface-definition\">Interface Definition</h3>\n<p>The GameDay engine is implemented as a <code>GameDayController</code> struct, which manages the execution of <code>Scenario</code> definitions. It exposes a control API and integrates with the existing <code>Orchestrator</code> to run individual experiments.</p>\n<h4 id=\"core-data-structures\">Core Data Structures</h4>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Scenario</code></td>\n<td>struct</td>\n<td>A complete GameDay plan containing sequential steps.</td>\n</tr>\n<tr>\n<td><code>ScenarioStep</code></td>\n<td>struct</td>\n<td>A single unit of work in a scenario: an experiment, a manual task, or a pause.</td>\n</tr>\n<tr>\n<td><code>ScenarioStatus</code></td>\n<td>string constant</td>\n<td>Current state of a scenario: <code>PENDING</code>, <code>RUNNING</code>, <code>PAUSED_MANUAL</code>, <code>PAUSED_OBSERVER</code>, <code>COMPLETED</code>, <code>ABORTED</code>.</td>\n</tr>\n<tr>\n<td><code>RunbookTask</code></td>\n<td>struct</td>\n<td>A manual task for human operators, with instructions and expected completion criteria.</td>\n</tr>\n<tr>\n<td><code>ObserverBriefing</code></td>\n<td>struct</td>\n<td>Pre-prepared information package for observers, describing the scenario&#39;s goals and what to watch.</td>\n</tr>\n<tr>\n<td><code>GameDayReport</code></td>\n<td>struct</td>\n<td>Consolidated report of a completed scenario, aggregating experiment results and observer notes.</td>\n</tr>\n</tbody></table>\n<p><strong>Scenario Struct Fields:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for the scenario.</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Human-readable name (e.g., &quot;Q4 Payment Service Resilience Drill&quot;).</td>\n</tr>\n<tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Overview of the scenario&#39;s goals and narrative.</td>\n</tr>\n<tr>\n<td><code>Steps</code></td>\n<td><code>[]ScenarioStep</code></td>\n<td>Ordered list of steps to execute.</td>\n</tr>\n<tr>\n<td><code>ObserverBriefing</code></td>\n<td><code>ObserverBriefing</code></td>\n<td>Pre-experiment briefing material.</td>\n</tr>\n<tr>\n<td><code>CreatedAt</code></td>\n<td><code>time.Time</code></td>\n<td>When the scenario was defined.</td>\n</tr>\n<tr>\n<td><code>ScheduledFor</code></td>\n<td><code>*time.Time</code></td>\n<td>Optional future start time.</td>\n</tr>\n<tr>\n<td><code>BlastRadiusLimit</code></td>\n<td><code>BlastRadius</code></td>\n<td>Global constraint applied to all experiments in the scenario (can be overridden per step).</td>\n</tr>\n<tr>\n<td><code>SafetyOverride</code></td>\n<td><code>[]SafetyRule</code></td>\n<td>Additional safety rules applied to all experiments.</td>\n</tr>\n</tbody></table>\n<p><strong>ScenarioStep Struct Fields:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>StepType</code></td>\n<td>One of: <code>EXPERIMENT</code>, <code>MANUAL_TASK</code>, <code>PAUSE</code>, <code>INJECT</code>.</td>\n</tr>\n<tr>\n<td><code>Name</code></td>\n<td><code>string</code></td>\n<td>Step name for logging and reporting.</td>\n</tr>\n<tr>\n<td><code>Description</code></td>\n<td><code>string</code></td>\n<td>Detailed instructions for this step.</td>\n</tr>\n<tr>\n<td><code>Experiment</code></td>\n<td><code>*Experiment</code></td>\n<td>If <code>Type</code> is <code>EXPERIMENT</code>, the experiment to run.</td>\n</tr>\n<tr>\n<td><code>RunbookTask</code></td>\n<td><code>*RunbookTask</code></td>\n<td>If <code>Type</code> is <code>MANUAL_TASK</code>, the manual task definition.</td>\n</tr>\n<tr>\n<td><code>PauseDuration</code></td>\n<td><code>*time.Duration</code></td>\n<td>If <code>Type</code> is <code>PAUSE</code>, how long to wait.</td>\n</tr>\n<tr>\n<td><code>InjectMessage</code></td>\n<td><code>*string</code></td>\n<td>If <code>Type</code> is <code>INJECT</code>, a simulated event message (e.g., &quot;CEO is asking for an ETA&quot;).</td>\n</tr>\n<tr>\n<td><code>RequiresApproval</code></td>\n<td><code>bool</code></td>\n<td>If true, the scenario pauses after this step and waits for explicit operator approval to continue.</td>\n</tr>\n<tr>\n<td><code>AutoProceedAfter</code></td>\n<td><code>*time.Duration</code></td>\n<td>Optional maximum wait time for approval before auto-aborting the scenario.</td>\n</tr>\n</tbody></table>\n<h4 id=\"controller-interface-methods\">Controller Interface Methods</h4>\n<p>The <code>GameDayController</code> provides the following public methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LoadScenario</code></td>\n<td><code>scenario Scenario</code></td>\n<td><code>(scenarioID string, error)</code></td>\n<td>Validates and registers a new scenario definition. Returns a unique ID.</td>\n</tr>\n<tr>\n<td><code>StartScenario</code></td>\n<td><code>scenarioID string</code></td>\n<td><code>error</code></td>\n<td>Begins execution of a loaded scenario. Transitions to <code>RUNNING</code> and starts the first step.</td>\n</tr>\n<tr>\n<td><code>PauseScenario</code></td>\n<td><code>scenarioID string, reason string</code></td>\n<td><code>error</code></td>\n<td>Pauses the scenario at the current step. Status becomes <code>PAUSED_MANUAL</code>.</td>\n</tr>\n<tr>\n<td><code>ResumeScenario</code></td>\n<td><code>scenarioID string</code></td>\n<td><code>error</code></td>\n<td>Resumes a paused scenario. Continues the current step or moves to the next if the step was completed before pause.</td>\n</tr>\n<tr>\n<td><code>ApproveStep</code></td>\n<td><code>scenarioID string, stepIndex int, approvalNotes string</code></td>\n<td><code>error</code></td>\n<td>Provides manual approval for a step marked <code>RequiresApproval</code>. Allows the scenario to proceed.</td>\n</tr>\n<tr>\n<td><code>AbortScenario</code></td>\n<td><code>scenarioID string, reason string</code></td>\n<td><code>error</code></td>\n<td>Aborts the entire scenario, cleaning up any active experiments. Status becomes <code>ABORTED</code>.</td>\n</tr>\n<tr>\n<td><code>GetScenarioStatus</code></td>\n<td><code>scenarioID string</code></td>\n<td><code>(ScenarioStatus, *ScenarioStep, error)</code></td>\n<td>Returns current status and the active step (if any).</td>\n</tr>\n<tr>\n<td><code>AddObservation</code></td>\n<td><code>scenarioID string, observation Observation</code></td>\n<td><code>error</code></td>\n<td>Allows observers to attach notes, metrics, or screenshots to the scenario&#39;s report.</td>\n</tr>\n<tr>\n<td><code>GenerateReport</code></td>\n<td><code>scenarioID string</code></td>\n<td><code>(*GameDayReport, error)</code></td>\n<td>Compiles a final report after scenario completion or abortion.</td>\n</tr>\n<tr>\n<td><code>ListScenarios</code></td>\n<td><code>filter ScenarioFilter</code></td>\n<td><code>([]Scenario, error)</code></td>\n<td>Retrieves scenarios matching filter criteria (status, time range, etc.).</td>\n</tr>\n</tbody></table>\n<h3 id=\"internal-behavior\">Internal Behavior</h3>\n<p>The core of the GameDay engine is a stateful loop that processes <code>ScenarioStep</code> items sequentially. It integrates tightly with the <code>Orchestrator</code> to run experiments and with a <code>RunbookRenderer</code> to present manual tasks to human operators via a UI or chat-bot interface.</p>\n<h4 id=\"execution-algorithm\">Execution Algorithm</h4>\n<p>When <code>StartScenario</code> is called, the controller begins the following loop in a dedicated goroutine:</p>\n<ol>\n<li><strong>Initialization</strong>: Load the scenario, verify its steps are valid (e.g., experiments reference valid faults), and transition status to <code>RUNNING</code>. Emit an audit log event.</li>\n<li><strong>Briefing Dispatch</strong>: If an <code>ObserverBriefing</code> exists, push it to all registered observer channels (e.g., Slack, email, dashboard). This step is non-blocking.</li>\n<li><strong>Step Iteration</strong>: For each <code>ScenarioStep</code> in <code>Steps</code>:\na. <strong>Pre-step Check</strong>: Verify the overall system health via a quick global health check. If critical metrics are already breaching safety thresholds, abort the scenario.\nb. <strong>Step Execution</strong>:<ul>\n<li>If <code>Type</code> is <code>EXPERIMENT</code>:\n i. Apply any scenario-level <code>BlastRadiusLimit</code> and <code>SafetyOverride</code> to the experiment definition (merging with step-specific rules).\n ii. Call <code>Orchestrator.StartExperiment</code> with the modified experiment. The orchestrator handles its own lifecycle (baseline validation, injection, monitoring, rollback).\n iii. Monitor the experiment&#39;s status channel. If it enters <code>StateAborted</code> due to a safety breach, record the cause and decide whether to abort the entire scenario based on scenario configuration.</li>\n<li>If <code>Type</code> is <code>MANUAL_TASK</code>:\n i. Render the <code>RunbookTask</code> instructions and expected actions to the operator interface.\n ii. Wait for a task completion signal (e.g., an operator clicks &quot;Task Complete&quot; in the UI). Optionally, the operator may be required to input verification data (e.g., a screenshot, a command output).</li>\n<li>If <code>Type</code> is <code>PAUSE</code>:\n i. Sleep for the specified <code>PauseDuration</code>. This can be used to simulate &quot;waiting for the on-call engineer to respond&quot; or to allow system behavior to stabilize.</li>\n<li>If <code>Type</code> is <code>INJECT</code>:\n i. Deliver the <code>InjectMessage</code> to observer channels (e.g., &quot;Simulated customer tweet: &#39;Is the site down?&#39;&quot;).\n ii. Record the inject as an observation.\nc. <strong>Post-step Approval Gate</strong>: If the step has <code>RequiresApproval</code> set to true:\n i. Pause the scenario, set status to <code>PAUSED_OBSERVER</code>.\n ii. Wait for an <code>ApproveStep</code> call from an operator. While waiting, if <code>AutoProceedAfter</code> is set, start a timer. If the timer fires before approval, abort the scenario.\n iii. Upon approval, record the approval notes and resume the scenario.\nd. <strong>Observation Collection</strong>: Throughout the step, observations from operators and automated monitors are collected via <code>AddObservation</code> and attached to the step&#39;s record.\ne. <strong>Step Completion</strong>: Mark the step as complete, record its duration and outcome (success, failure with reason).</li>\n</ul>\n</li>\n<li><strong>Scenario Completion</strong>: After all steps are processed, transition status to <code>COMPLETED</code>. Trigger automatic report generation and distribution.</li>\n<li><strong>Cleanup</strong>: Ensure all resources (experiment monitors, temporary files) are released.</li>\n</ol>\n<h4 id=\"state-machine\">State Machine</h4>\n<p>The scenario follows a linear but interruptible state machine:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PENDING</code></td>\n<td><code>StartScenario</code></td>\n<td><code>RUNNING</code></td>\n<td>Validate scenario, dispatch briefing, begin step loop.</td>\n</tr>\n<tr>\n<td><code>RUNNING</code></td>\n<td>Step completes without requiring approval</td>\n<td><code>RUNNING</code></td>\n<td>Move to next step, execute it.</td>\n</tr>\n<tr>\n<td><code>RUNNING</code></td>\n<td>Step completes with <code>RequiresApproval</code></td>\n<td><code>PAUSED_OBSERVER</code></td>\n<td>Halt execution, notify operators approval is needed.</td>\n</tr>\n<tr>\n<td><code>RUNNING</code></td>\n<td><code>PauseScenario</code> called</td>\n<td><code>PAUSED_MANUAL</code></td>\n<td>Suspend step execution (if possible, pause any ongoing experiment).</td>\n</tr>\n<tr>\n<td><code>RUNNING</code></td>\n<td><code>AbortScenario</code> called or auto-abort condition met</td>\n<td><code>ABORTED</code></td>\n<td>Immediately stop, call <code>Orchestrator.AbortExperiment</code> for any active experiment, clean up.</td>\n</tr>\n<tr>\n<td><code>RUNNING</code></td>\n<td>All steps completed</td>\n<td><code>COMPLETED</code></td>\n<td>Generate final report, notify observers.</td>\n</tr>\n<tr>\n<td><code>PAUSED_OBSERVER</code></td>\n<td><code>ApproveStep</code> called</td>\n<td><code>RUNNING</code></td>\n<td>Resume execution with next step.</td>\n</tr>\n<tr>\n<td><code>PAUSED_OBSERVER</code></td>\n<td><code>AutoProceedAfter</code> timer expires</td>\n<td><code>ABORTED</code></td>\n<td>Abort scenario due to lack of approval.</td>\n</tr>\n<tr>\n<td><code>PAUSED_OBSERVER</code></td>\n<td><code>AbortScenario</code> called</td>\n<td><code>ABORTED</code></td>\n<td>Abort scenario.</td>\n</tr>\n<tr>\n<td><code>PAUSED_MANUAL</code></td>\n<td><code>ResumeScenario</code> called</td>\n<td><code>RUNNING</code></td>\n<td>Resume execution from the point of pause.</td>\n</tr>\n<tr>\n<td><code>PAUSED_MANUAL</code></td>\n<td><code>AbortScenario</code> called</td>\n<td><code>ABORTED</code></td>\n<td>Abort scenario.</td>\n</tr>\n<tr>\n<td>Any state</td>\n<td>System-wide emergency stop signal</td>\n<td><code>ABORTED</code></td>\n<td>Immediate forced abort, highest priority cleanup.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The distinction between <code>PAUSED_OBSERVER</code> (waiting for explicit approval) and <code>PAUSED_MANUAL</code> (general pause) is crucial. The former is a gating mechanism for runbook steps; the latter is a safety valve for unexpected issues during the drill.</p>\n</blockquote>\n<h4 id=\"integration-with-orchestrator\">Integration with Orchestrator</h4>\n<p>The GameDay controller does not duplicate experiment execution logic. Instead, it delegates to the existing <code>Orchestrator</code>, treating each experiment step as a black box. However, it enhances safety by:</p>\n<ul>\n<li><strong>Adding scenario-level safety rules</strong> on top of experiment-specific ones.</li>\n<li><strong>Monitoring for experiment abortion</strong> and deciding whether that should cascade to abort the entire scenario.</li>\n<li><strong>Aggregating results</strong> from all experiments into a unified GameDay report.</li>\n</ul>\n<p>The controller subscribes to the <code>Orchestrator</code>&#39;s result channel for each experiment to capture the final <code>ExperimentResult</code> and any real-time <code>Observation</code> events.</p>\n<h3 id=\"adr-integration-with-incident-management\">ADR: Integration with Incident Management</h3>\n<blockquote>\n<p><strong>Decision: Simulated Incident Tickets Only (No Live Integration)</strong></p>\n</blockquote>\n<ul>\n<li><strong>Context</strong>: GameDays simulate real incidents. A key question is whether to integrate with the production incident management system (e.g., create real PagerDuty incidents, JIRA tickets) to make the drill feel authentic, or to keep simulations entirely isolated to avoid noise and confusion.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Full Production Integration</strong>: Create real tickets, pages, and conference bridges. This provides the most realistic training pressure.</li>\n<li><strong>Shadow Integration</strong>: Create tickets in a dedicated &quot;drill&quot; project within the same tooling (e.g., a separate PagerDuty service, a JIRA label &quot;SIMULATION&quot;). Real processes are followed, but the artifacts are clearly marked as non-production.</li>\n<li><strong>No Integration (Simulated Only)</strong>: Use internal GameDay dashboards and chat channels for all communication. No external systems are modified.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 2, <strong>Shadow Integration</strong>, is chosen for the initial implementation.</li>\n<li><strong>Rationale</strong>:<ul>\n<li><strong>Realism without Risk</strong>: Using the actual tools (e.g., clicking the same &quot;Declare Incident&quot; button in JIRA) builds muscle memory, but doing so in a sandboxed environment prevents accidental waking of on-call engineers or polluting production metrics.</li>\n<li><strong>Process Validation</strong>: It allows validation that the incident management workflows themselves function correctly (e.g., escalation rules, notification templates) without causing alert fatigue.</li>\n<li><strong>Clear Audit Trail</strong>: Tickets created in a dedicated project provide a perfect audit trail for the drill, which can be reviewed later.</li>\n<li><strong>Progressive Enhancement</strong>: This serves as a stepping stone. Teams that mature in their chaos practices can opt-in to &quot;full integration&quot; drills occasionally, but the platform defaults to safe isolation.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Additional Configuration Required</strong>: The platform needs to be configured with API keys and project IDs for the shadow environments.</li>\n<li><strong>Slightly Reduced Pressure</strong>: Engineers may subconsciously treat the drill differently knowing the tickets aren&#39;t &quot;real,&quot; though clear marking helps maintain seriousness.</li>\n<li><strong>Need for Cleanup</strong>: The GameDay engine must include a post-drill cleanup phase to close or archive the shadow tickets.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Comparison Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Full Production Integration</td>\n<td>Maximum realism, tests full pipeline</td>\n<td>High risk of confusion/alert fatigue, potentially destructive</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Shadow Integration</td>\n<td>Good realism, safe, validates tooling</td>\n<td>Requires setup of duplicate environments, slightly less pressure</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Simulated Only</td>\n<td>Simplest, zero risk of leakage</td>\n<td>Unrealistic, doesn&#39;t test incident tooling workflow</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Running the Drill Without Briefing Observers</strong>\n<em>Description:</em> Jumping directly into executing a complex GameDay scenario without first briefing the participating engineers and stakeholders.\n<em>Why it&#39;s wrong:</em> Unprepared observers will waste time figuring out what&#39;s happening instead of observing system behavior and practicing response. They might misinterpret simulated faults as real outages and initiate unnecessary escalation, or they might miss critical learning opportunities because they don&#39;t know what to look for.\n<em>How to fix:</em> The <code>GameDayController</code> must enforce that the <code>ObserverBriefing</code> is delivered and acknowledged before the first step begins. Implement a mandatory &quot;briefing acknowledged&quot; gate, where key participants must signal they&#39;ve read the briefing. The briefing should include: the scenario narrative, the schedule, what faults will be injected, what the expected system behavior is, and clear instructions on how to distinguish simulation from reality (e.g., &quot;all alerts will be prefixed with [GAMEDAY]&quot;).</p>\n<p>⚠️ <strong>Pitfall: Overly Complex Scenario Scripting</strong>\n<em>Description:</em> Creating a GameDay scenario with dozens of intricate, interdependent steps that are impossible to manage or debug.\n<em>Why it&#39;s wrong:</em> Complexity increases the chance of something going wrong with the chaos platform itself, derailing the entire drill. It also makes it difficult to isolate which fault caused which observed effect, muddying the learning outcomes.\n<em>How to fix:</em> Design scenarios using the <strong>&quot;Single Fault, Clear Hypothesis&quot;</strong> principle. Each experiment step should test one specific aspect of resilience. Use <code>PAUSE</code> and <code>MANUAL_TASK</code> steps to separate concerns and allow for analysis. Start with 2-3 step scenarios and gradually increase complexity as the team&#39;s familiarity grows.</p>\n<p>⚠️ <strong>Pitfall: Ignoring the &quot;Injects&quot;</strong>\n<em>Description:</em> Treating the GameDay as a purely technical sequence of fault injections, ignoring the human and process elements simulated by <code>INJECT</code> steps.\n<em>Why it&#39;s wrong:</em> Real incidents involve external pressure—customer complaints, management questions, partner escalations. Not simulating these leaves the team unprepared for the communication and prioritization challenges of a real outage.\n<em>How to fix:</em> Mandate at least one <code>INJECT</code> step per GameDay that simulates external communication. Use a realistic channel (e.g., a simulated customer support ticket, a message in an executive chat room). Observe and debrief on how the team handles the communication, not just the technical mitigation.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Scenario Storage</td>\n<td>File-based YAML definitions in <code>scenarios/</code> directory</td>\n<td>Database table with versioning and audit history</td>\n</tr>\n<tr>\n<td>Observer Notifications</td>\n<td>Logging to stdout and a file</td>\n<td>Integration with Slack/Teams webhooks and email (SMTP)</td>\n</tr>\n<tr>\n<td>Runbook Task UI</td>\n<td>CLI prompts requiring operator input</td>\n<td>Web dashboard with real-time collaboration and task tracking</td>\n</tr>\n<tr>\n<td>Shadow Incident Integration</td>\n<td>Mock API client that logs actions</td>\n<td>Full integration with JIRA/PagerDuty/Servicenow test instances</td>\n</tr>\n<tr>\n<td>Report Generation</td>\n<td>Plain text markdown report</td>\n<td>HTML report with embedded charts (using metrics collector data)</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<p>Add the GameDay component to the existing project layout:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── chaos-server/          # Main API server\n│   └── gameday-cli/           # CLI for controlling GameDays\n├── internal/\n│   ├── experiment/            # Existing orchestrator\n│   ├── fault/                 # Existing fault injector\n│   ├── metrics/               # Existing metrics collector\n│   ├── safety/                # Existing safety monitor\n│   ├── gameday/               # NEW: GameDay automation component\n│   │   ├── controller.go      # GameDayController implementation\n│   │   ├── scenario.go        # Scenario, ScenarioStep struct definitions\n│   │   ├── runbook.go         # RunbookTask rendering and completion tracking\n│   │   ├── briefing.go        # ObserverBriefing generation and delivery\n│   │   ├── report.go          # GameDayReport generation\n│   │   └── integrations/      # Integrations with external systems\n│   │       ├── slack.go\n│   │       ├── jira.go        # Shadow ticket creation\n│   │       └── pagerduty.go\n│   └── types.go               # Shared types (updated with GameDay types)\n├── scenarios/                 # Directory for YAML scenario definitions\n│   └── payment-service-drill.yaml\n└── web/ui/                   # Optional web dashboard\n    └── gameday/              # GameDay-specific UI components</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-scenario-yaml-parser\">Infrastructure Starter Code: Scenario YAML Parser</h4>\n<p>The following is a complete, ready-to-use parser for loading scenario definitions from YAML files. It uses the <code>gopkg.in/yaml.v3</code> package.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/gameday/loader.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> gameday</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io/ioutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/experiment</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">gopkg.in/yaml.v3</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadScenarioFromFile reads a YAML file and returns a Scenario struct.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadScenarioFromFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Scenario</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(filePath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to read scenario file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> scenario </span><span style=\"color:#B392F0\">Scenario</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> yaml.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">scenario); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to parse scenario YAML: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate required fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> scenario.ID </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scenario must have an ID\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> scenario.Name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scenario must have a name\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(scenario.Steps) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scenario must have at least one step\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate each step</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, step </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> scenario.Steps {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> step.Name </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> must have a name\"</span><span style=\"color:#E1E4E8\">, i)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> step.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"EXPERIMENT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> step.Experiment </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) is of type EXPERIMENT but has no experiment definition\"</span><span style=\"color:#E1E4E8\">, i, step.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // You could add more validation for the experiment here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"MANUAL_TASK\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> step.RunbookTask </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) is of type MANUAL_TASK but has no runbook task\"</span><span style=\"color:#E1E4E8\">, i, step.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"PAUSE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> step.PauseDuration </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">step.PauseDuration </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) is of type PAUSE but has invalid or missing duration\"</span><span style=\"color:#E1E4E8\">, i, step.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"INJECT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> step.InjectMessage </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">step.InjectMessage </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) is of type INJECT but has no message\"</span><span style=\"color:#E1E4E8\">, i, step.Name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) has unknown type: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, i, step.Name, step.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">scenario, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SaveScenarioToFile writes a Scenario struct to a YAML file.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SaveScenarioToFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">scenario</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Scenario</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> yaml.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(scenario)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to marshal scenario to YAML: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(filePath, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to write scenario file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-sequential-scenario-executor\">Core Logic Skeleton: Sequential Scenario Executor</h4>\n<p>This is the main driver method of the <code>GameDayController</code>. Learners must fill in the TODOs.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/gameday/controller.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> gameday</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/experiment</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GameDayController</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu            </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scenarios     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">scenarioInstance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    orchestrator  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">experiment</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Orchestrator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    notifier      </span><span style=\"color:#B392F0\">Notifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other fields (e.g., integrations, observation channels)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> scenarioInstance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scenario   </span><span style=\"color:#B392F0\">Scenario</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status     </span><span style=\"color:#B392F0\">ScenarioStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentStep </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EndedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Observations []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Observation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... additional execution state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeScenario is the main loop for running a scenario. It is called in a goroutine by StartScenario.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GameDayController</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeScenario</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">scenarioID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.scenarios[scenarioID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">ok {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scenario </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, scenarioID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance.Status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RUNNING</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance.StartedAt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Dispatch the observer briefing via the notifier.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   Use c.notifier.SendBriefing(instance.Scenario.ObserverBriefing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   Optionally, wait for acknowledgments if required.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterate through steps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> stepIdx, step </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> instance.Scenario.Steps {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        instance.CurrentStep </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stepIdx</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        log.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[GameDay </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] Starting step </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, scenarioID, stepIdx, step.Name)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Pre-step health check.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   Perform a quick global health check (e.g., call a predefined health endpoint).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   If health is critical, abort the scenario with reason \"pre-step health check failed\".</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Execute step based on type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> step.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"EXPERIMENT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Apply scenario-level overrides to the experiment.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Merge instance.Scenario.BlastRadiusLimit and SafetyOverride with step.Experiment fields.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Ensure the merged experiment is valid.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Run the experiment via the orchestrator.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Create a channel to receive the experiment result.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Call c.orchestrator.StartExperiment(mergedExperiment, resultChan).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Monitor the experiment status. If it aborts due to safety, decide whether to abort scenario.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Wait for the experiment to complete (reach COMPLETED or ABORTED state).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Collect the final ExperimentResult and add it to the scenario report.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"MANUAL_TASK\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Present the manual task to operators.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Use c.notifier.SendTask(step.RunbookTask) to post instructions.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Wait for a task completion signal (e.g., from a channel or callback).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Optionally, validate any verification data provided by the operator.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"PAUSE\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 6: Pause for the specified duration.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Use time.Sleep(*step.PauseDuration).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Log a message and optionally notify observers that the scenario is pausing.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#9ECBFF\"> \"INJECT\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 7: Deliver the inject message.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Use c.notifier.SendInject(*step.InjectMessage).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            //   Record the inject as an observation with source \"inject\".</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // This should have been caught in validation, but handle gracefully.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            log.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown step type: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, step.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 8: Handle post-step approval gate.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   If step.RequiresApproval is true:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //     - Set instance.Status to PAUSED_OBSERVER.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //     - Notify observers that approval is required.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //     - Start a timer for step.AutoProceedAfter if set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //     - Wait for either an ApproveStep call or the timer to expire.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //     - If timer expires, abort scenario with reason \"approval timeout\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //     - If approved, record approval notes and resume.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 9: Collect any observations that were added during this step.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //   Observations can be added concurrently via AddObservation. Gather them and attach to the step record.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Scenario completion.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   Set instance.Status to COMPLETED, record EndedAt.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   Trigger report generation (call c.generateReport(scenarioID)).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   Notify observers that the scenario has ended.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartScenario begins execution of a loaded scenario.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GameDayController</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartScenario</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">scenarioID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    c.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> c.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.scenarios[scenarioID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">ok {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scenario </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not found\"</span><span style=\"color:#E1E4E8\">, scenarioID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> instance.Status </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> PENDING {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scenario </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> is not in PENDING state (current: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, scenarioID, instance.Status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Launch execution in a goroutine so the API call returns immediately.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">executeScenario</span><span style=\"color:#E1E4E8\">(scenarioID); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            log.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Scenario </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, scenarioID, err)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Handle failure (e.g., set status to ABORTED)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><strong>Concurrency Management:</strong> Use <code>sync.RWMutex</code> on the <code>GameDayController</code> to protect the <code>scenarios</code> map. Each <code>scenarioInstance</code> should have its own mutex if its internal fields are accessed from multiple goroutines (e.g., from the main execution loop and from the <code>AddObservation</code> method).</li>\n<li><strong>Context Propagation:</strong> Pass a <code>context.Context</code> through the execution chain, especially for steps that involve network calls (e.g., starting an experiment). This allows for centralized cancellation if the scenario is aborted.</li>\n<li><strong>Error Handling in Goroutines:</strong> Ensure that panics in the <code>executeScenario</code> goroutine are recovered and logged, and the scenario status is updated to <code>FAILED</code>. Consider using a <code>panicHandler</code> middleware.</li>\n<li><strong>YAML Parsing:</strong> Use the <code>gopkg.in/yaml.v3</code> package for robust YAML parsing. It preserves order of fields and has good error messages. Remember to define YAML struct tags (<code>`yaml:&quot;field_name&quot;`</code>) on all struct fields that need to be serialized.</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the GameDay Automation component, you should be able to:</p>\n<ol>\n<li><strong>Load a scenario definition:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/gameday-cli/main.go</span><span style=\"color:#9ECBFF\"> load-scenario</span><span style=\"color:#9ECBFF\"> scenarios/payment-service-drill.yaml</span></span></code></pre></div>\n<p>   Expected output: <code>Scenario &quot;payment-service-drill&quot; loaded with ID: drill_12345</code></p>\n<ol start=\"2\">\n<li><strong>Start the scenario:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/gameday-cli/main.go</span><span style=\"color:#9ECBFF\"> start-scenario</span><span style=\"color:#9ECBFF\"> drill_12345</span></span></code></pre></div>\n<p>   Expected behavior: The CLI returns immediately. In the logs, you should see:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   Dispatching observer briefing...\n   Starting step 0: Inject database latency...\n   Starting experiment exp_001...</code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Simulate manual approval:</strong>\nIf a step requires approval, the scenario should pause. You can then call:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/gameday-cli/main.go</span><span style=\"color:#9ECBFF\"> approve-step</span><span style=\"color:#9ECBFF\"> drill_12345</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#9ECBFF\"> \"Looks good, proceed.\"</span></span></code></pre></div>\n<p>   The scenario should resume and continue to the next step.</p>\n<ol start=\"4\">\n<li><strong>Generate a report:</strong>\nAfter completion, run:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/gameday-cli/main.go</span><span style=\"color:#9ECBFF\"> report</span><span style=\"color:#9ECBFF\"> drill_12345</span></span></code></pre></div>\n<p>   This should output a markdown report summarizing each step, experiment results, and observations.</p>\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong>Scenario gets stuck:</strong> Check that the <code>executeScenario</code> loop is properly handling each step type and moving to the next step. Add detailed logging at each transition.</li>\n<li><strong>Experiments not starting:</strong> Verify that the <code>Orchestrator</code> client is correctly configured and that the experiment definition is valid after merging scenario-level overrides.</li>\n<li><strong>Observations lost:</strong> Ensure the <code>AddObservation</code> method is thread-safe and correctly appending to the <code>instance.Observations</code> slice. Use a mutex.</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (cross-cutting interaction patterns for entire platform)</p>\n</blockquote>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<h3 id=\"mental-model-the-air-traffic-control-tower\">Mental Model: The Air Traffic Control Tower</h3>\n<p>Imagine a busy international airport where multiple flights are simultaneously taxiing, taking off, and landing. The <strong>air traffic control tower</strong> coordinates all these activities through a well-defined communication protocol:</p>\n<ol>\n<li><strong>Flight Plans</strong> (experiment definitions) are submitted in advance with specific routes and schedules</li>\n<li><strong>Clearance Delivery</strong> (orchestrator) validates plans and issues start permissions</li>\n<li><strong>Ground Control</strong> (fault injector) manages movement on taxiways (applying faults)</li>\n<li><strong>Tower Control</strong> (safety monitor) watches active runways for conflicts (metric breaches)</li>\n<li><strong>Approach/Departure</strong> (metrics collector) tracks flights throughout their journey</li>\n<li><strong>Flight Recorders</strong> (result analyzer) capture all communications and outcomes</li>\n</ol>\n<p>Just as air traffic controllers use specific radio phraseology (&quot;Delta 123, cleared for takeoff runway 27L&quot;), our components communicate through structured messages with precise semantics. This section details those communication patterns that enable safe, coordinated chaos experiments.</p>\n<h3 id=\"key-sequence-running-an-experiment\">Key Sequence: Running an Experiment</h3>\n<p>The most critical workflow in the platform is executing a single chaos experiment from start to finish. This sequence involves all five major components (Experiment Controller, Fault Injector, Safety Monitor, Metrics Collector, and Result Analyzer) and follows the scientific method: hypothesize, experiment, observe, conclude.</p>\n<h4 id=\"pre-flight-checklist-experiment-creation-and-validation\">Pre-Flight Checklist: Experiment Creation and Validation</h4>\n<p>Before any fault injection occurs, the experiment must be properly defined and validated:</p>\n<ol>\n<li><p><strong>Definition Submission</strong>: A user or automated system creates an <code>Experiment</code> struct with all required fields (hypothesis, faults, schedule, safety rules) and calls <code>CreateExperiment()</code> on the Experiment Controller.</p>\n</li>\n<li><p><strong>Structural Validation</strong>: The controller validates the experiment definition:</p>\n<ul>\n<li>Syntax checking (required fields, proper types)</li>\n<li>Fault parameter validation (e.g., latency values within reasonable bounds)</li>\n<li>Target existence verification (ensuring specified services/pods exist)</li>\n<li>Safety rule sanity checking (thresholds that make sense)</li>\n</ul>\n</li>\n<li><p><strong>Storage</strong>: The validated experiment is persisted to durable storage (database or file system) with status <code>DRAFT</code>.</p>\n</li>\n<li><p><strong>Scheduling</strong>: If the schedule type is <code>IMMEDIATE</code>, the experiment is queued for immediate execution. For <code>ONE_TIME</code> or <code>CRON</code> schedules, it&#39;s stored for future execution by a scheduler component.</p>\n</li>\n</ol>\n<h4 id=\"experiment-execution-a-detailed-walkthrough\">Experiment Execution: A Detailed Walkthrough</h4>\n<p>Consider a concrete example: Testing a payment service&#39;s resilience to database latency spikes. The experiment injects 500ms of latency between the payment service and its MySQL database for 5 minutes, while monitoring the 95th percentile response time and error rate.</p>\n<p><strong>Step-by-Step Sequence:</strong></p>\n<ol>\n<li><p><strong>Experiment Start Command</strong>: </p>\n<ul>\n<li>User calls <code>StartExperiment()</code> on the Experiment Controller with the experiment ID</li>\n<li>Controller loads the experiment from storage, validates it&#39;s in a startable state (not already running), and creates an <code>ExperimentInstance</code></li>\n<li>Status transitions from <code>DRAFT</code> to <code>BASELINE_VALIDATION</code></li>\n</ul>\n</li>\n<li><p><strong>Baseline Establishment Phase</strong>:</p>\n<ul>\n<li>Controller calls <code>ValidateHypothesis()</code> on the Safety Monitor, passing the experiment&#39;s <code>Hypothesis</code> and requesting a 2-minute baseline measurement</li>\n<li>Safety Monitor queries the Metrics Collector for each metric in the hypothesis using <code>GetMetric()</code> with a time window of <code>[now-2min, now]</code></li>\n<li>Metrics Collector retrieves time-series data from monitoring systems (Prometheus, Datadog, etc.)</li>\n<li>Safety Monitor computes statistical baselines (mean, percentiles) for each metric</li>\n<li>If any metric violates its threshold during baseline (system already unhealthy), the experiment transitions to <code>ABORTED</code> with appropriate diagnostics</li>\n<li>If baseline validation passes, the experiment transitions to <code>INJECTING</code></li>\n</ul>\n</li>\n<li><p><strong>Fault Injection Coordination</strong>:</p>\n<ul>\n<li>Controller iterates through the experiment&#39;s <code>Faults</code> array</li>\n<li>For each fault, it calls <code>InjectFault()</code> on the appropriate Fault Injector agent</li>\n<li>The Fault Injector validates the fault parameters, applies the fault (e.g., using <code>tc netem</code> for network latency), and returns a <code>faultID</code></li>\n<li>Controller records each <code>FaultInjectionRecord</code> with injection timestamp and status</li>\n<li>After all faults are applied, experiment transitions to <code>MONITORING</code></li>\n<li><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-seq-fault.svg\" alt=\"Sequence Diagram: Injecting a Network Latency Fault\"></li>\n</ul>\n</li>\n<li><p><strong>Active Monitoring Phase</strong>:</p>\n<ul>\n<li>Controller starts two concurrent monitoring loops:<ul>\n<li><strong>Duration Timer</strong>: Counts down the experiment&#39;s <code>Duration</code> (5 minutes in our example)</li>\n<li><strong>Safety Monitoring</strong>: Continuously calls <code>checkSafetyRules()</code> on the Safety Monitor</li>\n</ul>\n</li>\n<li>Safety Monitor periodically queries the Metrics Collector for current metric values</li>\n<li>If any safety rule triggers (e.g., error rate exceeds 5% for 30 seconds):<ul>\n<li>Safety Monitor sends an <code>AbortEvent</code> to the Controller</li>\n<li>Controller immediately transitions to <code>ROLLBACK</code> phase</li>\n</ul>\n</li>\n<li><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-seq-safety.svg\" alt=\"Sequence Diagram: Safety-Triggered Auto-Rollback\"></li>\n</ul>\n</li>\n<li><p><strong>Rollback Phase</strong>:</p>\n<ul>\n<li>Controller iterates through all active faults and calls <code>CleanupFault()</code> on each Fault Injector</li>\n<li>Each Fault Injector removes the applied fault (e.g., deletes <code>tc</code> rules, kills stress processes)</li>\n<li>Fault Injector confirms cleanup completion</li>\n<li>Controller updates each <code>FaultInjectionRecord</code> with cleanup timestamp</li>\n<li>Experiment transitions to <code>ANALYSIS</code></li>\n</ul>\n</li>\n<li><p><strong>Post-Experiment Analysis</strong>:</p>\n<ul>\n<li>Controller calls <code>ValidateHypothesis()</code> again on the Safety Monitor, this time comparing:<ul>\n<li>Baseline period metrics (before injection)</li>\n<li>Injection period metrics (during fault)</li>\n<li>Recovery period metrics (after cleanup)</li>\n</ul>\n</li>\n<li>Safety Monitor performs statistical comparison (t-tests, threshold checking)</li>\n<li>Result Analyzer compiles a comprehensive <code>ExperimentResult</code> including:<ul>\n<li>Hypothesis validation outcome (pass/fail with confidence intervals)</li>\n<li>Timeline of events (injection times, safety triggers, rollback)</li>\n<li>Metric graphs and statistical summaries</li>\n<li>Observations and annotations</li>\n</ul>\n</li>\n<li>Experiment transitions to <code>COMPLETED</code></li>\n<li>Final report is persisted and optionally sent to notification channels</li>\n</ul>\n</li>\n<li><p><strong>Cleanup Ensurer Double-Check</strong>:</p>\n<ul>\n<li>Regardless of success or failure, the <code>CleanupEnsurer</code> component verifies that no orphaned faults remain</li>\n<li>On system restart, <code>RecoverOrphanedFaults()</code> scans for active fault records and initiates cleanup</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"state-transition-table-during-execution\">State Transition Table During Execution</h4>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event Trigger</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DRAFT</code></td>\n<td><code>StartExperiment()</code> called</td>\n<td><code>BASELINE_VALIDATION</code></td>\n<td>Load experiment, create instance, start baseline timer</td>\n</tr>\n<tr>\n<td><code>BASELINE_VALIDATION</code></td>\n<td>Baseline validation passes</td>\n<td><code>INJECTING</code></td>\n<td>Record baseline metrics, begin fault injection</td>\n</tr>\n<tr>\n<td><code>BASELINE_VALIDATION</code></td>\n<td>Baseline validation fails</td>\n<td><code>ABORTED</code></td>\n<td>Record failure reason, generate result</td>\n</tr>\n<tr>\n<td><code>INJECTING</code></td>\n<td>All faults injected successfully</td>\n<td><code>MONITORING</code></td>\n<td>Start duration timer, begin safety monitoring</td>\n</tr>\n<tr>\n<td><code>INJECTING</code></td>\n<td>Any fault injection fails</td>\n<td><code>ROLLBACK</code></td>\n<td>Cleanup already-injected faults, record error</td>\n</tr>\n<tr>\n<td><code>MONITORING</code></td>\n<td>Duration timer expires</td>\n<td><code>ROLLBACK</code></td>\n<td>Initiate normal cleanup sequence</td>\n</tr>\n<tr>\n<td><code>MONITORING</code></td>\n<td>Safety rule triggers</td>\n<td><code>ROLLBACK</code></td>\n<td>Record safety event, initiate emergency cleanup</td>\n</tr>\n<tr>\n<td><code>ROLLBACK</code></td>\n<td>All faults cleaned up</td>\n<td><code>ANALYSIS</code></td>\n<td>Compile fault timeline, begin post-analysis</td>\n</tr>\n<tr>\n<td><code>ANALYSIS</code></td>\n<td>Analysis complete</td>\n<td><code>COMPLETED</code></td>\n<td>Generate final report, persist results</td>\n</tr>\n<tr>\n<td>Any state</td>\n<td>External abort command</td>\n<td><code>ROLLBACK</code></td>\n<td>Record abort reason, begin cleanup</td>\n</tr>\n</tbody></table>\n<h4 id=\"error-recovery-scenarios\">Error Recovery Scenarios</h4>\n<p><strong>Scenario 1: Fault Injector Agent Unreachable During Injection</strong></p>\n<ul>\n<li>Controller attempts <code>InjectFault()</code> RPC call with 30-second timeout</li>\n<li>On timeout, controller marks that specific fault as <code>FAILED</code></li>\n<li>If experiment has <code>continueOnFaultFailure: false</code> (default), experiment transitions to <code>ROLLBACK</code> immediately</li>\n<li>If <code>continueOnFaultFailure: true</code>, controller skips that fault and continues with others</li>\n<li>Failed fault is recorded in results with error details</li>\n</ul>\n<p><strong>Scenario 2: Metrics Collector Service Down During Monitoring</strong></p>\n<ul>\n<li>Safety Monitor&#39;s <code>checkSafetyRules()</code> call to Metrics Collector fails</li>\n<li>Safety Monitor retries with exponential backoff (1s, 2s, 4s, 8s)</li>\n<li>After 4 failures, Safety Monitor sends <code>MetricsUnavailableEvent</code> to Controller</li>\n<li>Controller pauses experiment (enters <code>PAUSED</code> substate), waiting for metrics to return</li>\n<li>If metrics return within 5 minutes, experiment resumes</li>\n<li>If metrics remain unavailable, experiment transitions to <code>ROLLBACK</code> with &quot;metrics unavailable&quot; reason</li>\n</ul>\n<p><strong>Scenario 3: Controller Process Crashes Mid-Experiment</strong></p>\n<ul>\n<li>On restart, Controller scans for experiments in active states (<code>BASELINE_VALIDATION</code> through <code>ANALYSIS</code>)</li>\n<li>For each, it calls <code>RecoverOrphanedFaults()</code> on the Fault Injector</li>\n<li>Fault Injector reports which faults are still active</li>\n<li>Controller resumes experiment from appropriate state based on:<ul>\n<li>If faults active → resume in <code>MONITORING</code> or <code>ROLLBACK</code> depending on elapsed time</li>\n<li>If no faults active but experiment wasn&#39;t complete → resume in <code>ANALYSIS</code></li>\n<li>Uses <code>CleanupEnsurer</code>&#39;s persistent record as ground truth</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"message-formats\">Message Formats</h3>\n<p>Components communicate through two primary patterns: synchronous RPC (for control operations) and asynchronous events (for monitoring and alerts). All messages use Protocol Buffers for serialization, providing strong typing and backward/forward compatibility.</p>\n<h4 id=\"control-plane-rpc-messages\">Control Plane RPC Messages</h4>\n<p>These messages follow request-response semantics and are used for experiment management, fault injection commands, and status queries.</p>\n<p><strong>Experiment Management RPCs:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Direction</th>\n<th>Purpose</th>\n<th>Fields (Type → Description)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateExperimentRequest</code></td>\n<td>Client → Controller</td>\n<td>Create new experiment definition</td>\n<td><code>experiment</code> (<code>Experiment</code>) → Full experiment specification</td>\n</tr>\n<tr>\n<td><code>CreateExperimentResponse</code></td>\n<td>Controller → Client</td>\n<td>Acknowledge creation</td>\n<td><code>experiment_id</code> (<code>string</code>) → Unique identifier for created experiment<br><code>warnings</code> (<code>[]string</code>) → Validation warnings (non-fatal)</td>\n</tr>\n<tr>\n<td><code>StartExperimentRequest</code></td>\n<td>Client → Controller</td>\n<td>Begin experiment execution</td>\n<td><code>experiment_id</code> (<code>string</code>) → ID of experiment to start<br><code>override_params</code> (<code>map&lt;string, string&gt;</code>) → Optional parameter overrides</td>\n</tr>\n<tr>\n<td><code>StartExperimentResponse</code></td>\n<td>Controller → Client</td>\n<td>Acknowledge start</td>\n<td><code>instance_id</code> (<code>string</code>) → ID of this experiment instance<br><code>estimated_duration</code> (<code>Duration</code>) → Expected total runtime</td>\n</tr>\n<tr>\n<td><code>AbortExperimentRequest</code></td>\n<td>Any → Controller</td>\n<td>Forcefully stop experiment</td>\n<td><code>experiment_id</code> (<code>string</code>) → ID of experiment to abort<br><code>reason</code> (<code>string</code>) → Human-readable abort reason<br><code>emergency</code> (<code>bool</code>) → Skip graceful cleanup if true</td>\n</tr>\n<tr>\n<td><code>AbortExperimentResponse</code></td>\n<td>Controller → Any</td>\n<td>Confirm abort initiated</td>\n<td><code>abort_initiated</code> (<code>bool</code>) → Whether abort was accepted<br><code>cleanup_estimated</code> (<code>Duration</code>) → Estimated time for cleanup</td>\n</tr>\n</tbody></table>\n<p><strong>Fault Injection RPCs:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Direction</th>\n<th>Purpose</th>\n<th>Fields (Type → Description)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>InjectFaultRequest</code></td>\n<td>Controller → Fault Injector</td>\n<td>Apply a specific fault</td>\n<td><code>fault</code> (<code>Fault</code>) → Fault definition to apply<br><code>experiment_id</code> (<code>string</code>) → Experiment context ID<br><code>request_id</code> (<code>string</code>) → Unique request ID for idempotency</td>\n</tr>\n<tr>\n<td><code>InjectFaultResponse</code></td>\n<td>Fault Injector → Controller</td>\n<td>Confirm fault injection</td>\n<td><code>fault_id</code> (<code>string</code>) → Unique identifier for this fault instance<br><code>status</code> (<code>FaultStatus</code>) → Initial status details<br><code>warnings</code> (<code>[]string</code>) → Non-critical warnings</td>\n</tr>\n<tr>\n<td><code>CleanupFaultRequest</code></td>\n<td>Controller → Fault Injector</td>\n<td>Remove previously injected fault</td>\n<td><code>fault_id</code> (<code>string</code>) → ID of fault to clean up<br><code>force</code> (<code>bool</code>) → Force removal even if cleanup commands fail</td>\n</tr>\n<tr>\n<td><code>CleanupFaultResponse</code></td>\n<td>Fault Injector → Controller</td>\n<td>Confirm cleanup</td>\n<td><code>cleaned</code> (<code>bool</code>) → Whether cleanup succeeded<br><code>details</code> (<code>string</code>) → Cleanup execution details<br><code>remaining_faults</code> (<code>int32</code>) → Count of other active faults from same experiment</td>\n</tr>\n</tbody></table>\n<p><strong>Metrics and Safety RPCs:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Direction</th>\n<th>Purpose</th>\n<th>Fields (Type → Description)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ValidateHypothesisRequest</code></td>\n<td>Controller → Safety Monitor</td>\n<td>Validate steady-state hypothesis</td>\n<td><code>hypothesis</code> (<code>Hypothesis</code>) → Hypothesis to validate<br><code>time_range</code> (<code>TimeRange</code>) → Time window to analyze<br><code>baseline_only</code> (<code>bool</code>) → If true, only collect baseline (no during/after)</td>\n</tr>\n<tr>\n<td><code>ValidateHypothesisResponse</code></td>\n<td>Safety Monitor → Controller</td>\n<td>Hypothesis validation results</td>\n<td><code>validation</code> (<code>HypothesisValidation</code>) → Detailed validation results<br><code>data_quality</code> (<code>DataQuality</code>) → Metrics on data completeness/quality</td>\n</tr>\n<tr>\n<td><code>QueryMetricsRequest</code></td>\n<td>Safety Monitor → Metrics Collector</td>\n<td>Retrieve time-series metrics</td>\n<td><code>queries</code> (<code>[]MetricQuery</code>) → List of metric queries<br><code>start_time</code> (<code>Timestamp</code>) → Start of time range<br><code>end_time</code> (<code>Timestamp</code>) → End of time range<br><code>step</code> (<code>Duration</code>) → Resolution for returned data</td>\n</tr>\n<tr>\n<td><code>QueryMetricsResponse</code></td>\n<td>Metrics Collector → Safety Monitor</td>\n<td>Time-series metric data</td>\n<td><code>results</code> (<code>[]MetricSeries</code>) → One series per query<br><code>query_errors</code> (<code>[]QueryError</code>) → Errors for individual failed queries</td>\n</tr>\n</tbody></table>\n<h4 id=\"event-bus-messages\">Event Bus Messages</h4>\n<p>These messages are published asynchronously to an event bus (like NATS or Kafka) for decoupled communication between components. Events use a common envelope structure:</p>\n<p><strong>Event Envelope (all events contain these fields):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>event_id</code></td>\n<td><code>string</code></td>\n<td>Unique event identifier (UUID)</td>\n</tr>\n<tr>\n<td><code>event_type</code></td>\n<td><code>string</code></td>\n<td>Event type name (e.g., &quot;SafetyThresholdBreached&quot;)</td>\n</tr>\n<tr>\n<td><code>timestamp</code></td>\n<td><code>Timestamp</code></td>\n<td>When event was published</td>\n</tr>\n<tr>\n<td><code>source_component</code></td>\n<td><code>string</code></td>\n<td>Component that published the event</td>\n</tr>\n<tr>\n<td><code>correlation_id</code></td>\n<td><code>string</code></td>\n<td>Links related events (e.g., all from same experiment)</td>\n</tr>\n<tr>\n<td><code>payload</code></td>\n<td><code>bytes</code></td>\n<td>Serialized event-specific payload</td>\n</tr>\n</tbody></table>\n<p><strong>Key Event Types and Their Payloads:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Published By</th>\n<th>Consumed By</th>\n<th>Payload Fields (Type → Description)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ExperimentStateChanged</code></td>\n<td>Controller</td>\n<td>Result Analyzer, Notification Service</td>\n<td><code>experiment_id</code> (<code>string</code>) → Experiment identifier<br><code>old_state</code> (<code>string</code>) → Previous state<br><code>new_state</code> (<code>string</code>) → New state<br><code>reason</code> (<code>string</code>) → Why state changed</td>\n</tr>\n<tr>\n<td><code>SafetyThresholdBreached</code></td>\n<td>Safety Monitor</td>\n<td>Controller</td>\n<td><code>experiment_id</code> (<code>string</code>) → Experiment identifier<br><code>rule</code> (<code>SafetyRule</code>) → Rule that was breached<br><code>current_value</code> (<code>float64</code>) → Metric value that triggered breach<br><code>duration_breached</code> (<code>Duration</code>) → How long threshold was exceeded</td>\n</tr>\n<tr>\n<td><code>FaultInjectionCompleted</code></td>\n<td>Fault Injector</td>\n<td>Controller, Result Analyzer</td>\n<td><code>fault_id</code> (<code>string</code>) → Fault instance identifier<br><code>experiment_id</code> (<code>string</code>) → Experiment identifier<br><code>fault_type</code> (<code>FaultType</code>) → Type of fault injected<br><code>target</code> (<code>string</code>) → What was affected<br><code>commands_executed</code> (<code>[]ExecutedCommand</code>) → Commands run to apply fault</td>\n</tr>\n<tr>\n<td><code>MetricsCollectionFailed</code></td>\n<td>Metrics Collector</td>\n<td>Controller, Safety Monitor</td>\n<td><code>experiment_id</code> (<code>string</code>) → Experiment identifier (if applicable)<br><code>query</code> (<code>string</code>) → Failed metric query<br><code>error</code> (<code>string</code>) → Failure reason<br><code>retry_count</code> (<code>int32</code>) → How many retries attempted</td>\n</tr>\n<tr>\n<td><code>ManualApprovalRequired</code></td>\n<td>GameDay Controller</td>\n<td>Notification Service, UI</td>\n<td><code>scenario_id</code> (<code>string</code>) → Scenario identifier<br><code>step_index</code> (<code>int32</code>) → Which step requires approval<br><code>step_description</code> (<code>string</code>) → Human-readable description<br><code>approval_deadline</code> (<code>Timestamp</code>) → When auto-proceed will happen</td>\n</tr>\n<tr>\n<td><code>ObserverAnnotationAdded</code></td>\n<td>Any component</td>\n<td>Result Analyzer</td>\n<td><code>experiment_id</code> (<code>string</code>) → Experiment identifier (optional)<br><code>scenario_id</code> (<code>string</code>) → Scenario identifier (optional)<br><code>observation</code> (<code>Observation</code>) → Observation details<br><code>author</code> (<code>string</code>) → Who added the observation</td>\n</tr>\n</tbody></table>\n<h4 id=\"internal-component-communication-patterns\">Internal Component Communication Patterns</h4>\n<p><strong>Pattern 1: Command-Query Responsibility Segregation (CQRS) for Metrics</strong></p>\n<ul>\n<li><strong>Command Side</strong>: Fault Injector publishes <code>FaultInjectionCompleted</code> events when faults are applied</li>\n<li><strong>Query Side</strong>: Metrics Collector listens to these events and begins collecting specialized metrics for that fault period</li>\n<li><strong>Benefit</strong>: Decouples fault application from metric collection, allowing different collection strategies per fault type</li>\n</ul>\n<p><strong>Pattern 2: Saga Pattern for Experiment Rollback</strong></p>\n<ul>\n<li>When experiment needs to roll back (due to safety breach or manual abort):<ol>\n<li>Controller publishes <code>ExperimentRollbackInitiated</code> event</li>\n<li>Each Fault Injector listens for this event with correlation ID matching its experiment</li>\n<li>Each injector independently cleans up its faults and publishes <code>FaultCleanupCompleted</code></li>\n<li>Controller listens for all expected cleanup events with timeout</li>\n<li>If timeout expires, controller directly calls <code>CleanupFault()</code> RPC for missing faults</li>\n</ol>\n</li>\n<li><strong>Benefit</strong>: Fault tolerance - if one injector fails, others still clean up; controller orchestrates recovery</li>\n</ul>\n<p><strong>Pattern 3: Event Sourcing for Audit Trail</strong></p>\n<ul>\n<li>All state changes (<code>ExperimentStateChanged</code>) are published as events</li>\n<li>Result Analyzer subscribes to all events and builds complete audit trail</li>\n<li>On restart, components can replay events to reconstruct state</li>\n<li><strong>Benefit</strong>: Complete observability and debuggability of all experiment executions</li>\n</ul>\n<h4 id=\"message-serialization-example\">Message Serialization Example</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">protobuf</span><pre class=\"arch-pre shiki-highlighted\"><code>// Example Protocol Buffer definition for key messages\nsyntax = &quot;proto3&quot;;\n\npackage chaos.platform.v1;\n\nimport &quot;google/protobuf/timestamp.proto&quot;;\nimport &quot;google/protobuf/duration.proto&quot;;\n\nmessage InjectFaultRequest {\n  Fault fault = 1;\n  string experiment_id = 2;\n  string request_id = 3;  // For idempotency\n}\n\nmessage SafetyThresholdBreachedEvent {\n  string event_id = 1;\n  google.protobuf.Timestamp timestamp = 2;\n  string source_component = 3;\n  string correlation_id = 4;\n  \n  // Event-specific payload\n  string experiment_id = 5;\n  SafetyRule rule = 6;\n  double current_value = 7;\n  google.protobuf.Duration duration_breached = 8;\n}</code></pre></div>\n\n<h3 id=\"component-interaction-during-gameday-scenarios\">Component Interaction During GameDay Scenarios</h3>\n<p>GameDay scenarios introduce additional complexity by coordinating multiple experiments with manual intervention points. The communication pattern becomes a choreographed sequence rather than a single experiment flow.</p>\n<p><img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-flow-gameday.svg\" alt=\"Flowchart: GameDay Scenario Execution\"></p>\n<p><strong>GameDay Execution Sequence:</strong></p>\n<ol>\n<li><p><strong>Scenario Loading</strong>: <code>GameDayController.LoadScenario()</code> reads YAML definition, validates it, and stores it with status <code>PENDING</code></p>\n</li>\n<li><p><strong>Step-by-Step Execution</strong>:</p>\n<ul>\n<li>For each <code>ScenarioStep</code> in the scenario:<ul>\n<li>If step type is <code>EXPERIMENT</code>: Controller calls <code>StartExperiment()</code> and waits for completion</li>\n<li>If step type is <code>PAUSE</code>: Controller sleeps for specified duration, publishing heartbeat events</li>\n<li>If step type is <code>INJECT</code>: Controller publishes custom event to observer briefing channel</li>\n<li>If step type is <code>MANUAL_TASK</code>: Controller publishes <code>ManualApprovalRequired</code> event and waits</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Approval Workflow</strong>:</p>\n<ul>\n<li>When <code>ManualApprovalRequired</code> is published, UI shows approval dialog to authorized users</li>\n<li>User approves/rejects via <code>ApproveStep()</code> RPC call</li>\n<li>If approved, scenario proceeds to next step</li>\n<li>If rejected or timeout occurs, scenario may abort or skip step based on configuration</li>\n</ul>\n</li>\n<li><p><strong>Observer Participation</strong>:</p>\n<ul>\n<li>Observers can call <code>AddObservation()</code> at any time during scenario</li>\n<li>Observations are published as <code>ObserverAnnotationAdded</code> events</li>\n<li>Result Analyzer incorporates observations into final GameDay report</li>\n</ul>\n</li>\n<li><p><strong>Cross-Experiment Safety</strong>:</p>\n<ul>\n<li>Safety Monitor maintains system-wide safety rules during entire GameDay</li>\n<li>If any safety rule triggers, all active experiments are aborted, scenario transitions to emergency cleanup</li>\n<li>GameDay controller publishes <code>GameDayEmergencyAbort</code> event with root cause analysis</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"data-flow-visualization\">Data Flow Visualization</h3>\n<p>The component diagram below shows the five main subsystems and their interaction patterns:\n<img src=\"/api/project/chaos-engineering/architecture-doc/asset?path=diagrams%2Fdiag-system.svg\" alt=\"Chaos Platform System Overview\"></p>\n<p><strong>Key Data Flows Illustrated:</strong></p>\n<ol>\n<li><strong>Experiment Definition Flow</strong> (solid blue arrows): User → Experiment Controller → Persistent Storage</li>\n<li><strong>Fault Injection Flow</strong> (solid red arrows): Experiment Controller → Fault Injector Agents → Target Systems</li>\n<li><strong>Metrics Collection Flow</strong> (dashed green arrows): Target Systems → Metrics Collector ← Safety Monitor</li>\n<li><strong>Safety Monitoring Flow</strong> (dotted orange arrows): Safety Monitor → Experiment Controller (abort commands)</li>\n<li><strong>Result Reporting Flow</strong> (dot-dash purple arrows): All Components → Result Analyzer → Reports/UI</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>RPC Transport</strong></td>\n<td>HTTP/JSON with <code>net/http</code></td>\n<td>gRPC with Protocol Buffers</td>\n</tr>\n<tr>\n<td><strong>Event Bus</strong></td>\n<td>In-memory Go channels</td>\n<td>NATS or Apache Kafka</td>\n</tr>\n<tr>\n<td><strong>Message Serialization</strong></td>\n<td>JSON with <code>encoding/json</code></td>\n<td>Protocol Buffers with <code>google.golang.org/protobuf</code></td>\n</tr>\n<tr>\n<td><strong>Service Discovery</strong></td>\n<td>Static configuration in YAML</td>\n<td>Consul or Kubernetes Service Discovery</td>\n</tr>\n<tr>\n<td><strong>Retry Logic</strong></td>\n<td>Simple exponential backoff</td>\n<td>Adaptive retry with circuit breaker pattern</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── controller/                 # Experiment Controller main\n│   │   └── main.go\n│   ├── fault-injector/             # Fault Injector agent\n│   │   └── main.go\n│   └── safety-monitor/             # Safety Monitor service\n│       └── main.go\n├── internal/\n│   ├── rpc/                        # RPC message definitions\n│   │   ├── messages.proto          # Protocol Buffer definitions\n│   │   ├── messages.pb.go          # Generated Go code\n│   │   └── client.go               # RPC client helpers\n│   ├── events/                     # Event definitions and bus\n│   │   ├── event.go                # Event envelope struct\n│   │   ├── publisher.go            # Event publishing interface\n│   │   ├── subscriber.go           # Event subscription interface\n│   │   └── nats/                   # NATS implementation (optional)\n│   │       ├── publisher.go\n│   │       └── subscriber.go\n│   ├── orchestrator/               # Experiment Orchestration Engine\n│   │   ├── orchestrator.go         # Main orchestrator logic\n│   │   ├── statemachine.go         # Experiment state machine\n│   │   └── recovery.go             # Crash recovery logic\n│   ├── fault/                      # Fault Injection Framework\n│   │   ├── injector.go             # Fault injection interface\n│   │   ├── manager.go              # Fault lifecycle management\n│   │   └── types.go                # Fault-related types\n│   └── gameday/                    # GameDay Automation\n│       ├── controller.go           # GameDay controller\n│       ├── scenario.go             # Scenario definition and parsing\n│       └── executor.go             # Scenario step executor\n└── api/\n    └── v1/\n        ├── experiment.go           # Experiment API handlers\n        ├── fault.go                # Fault injection API\n        └── gameday.go              # GameDay API handlers</code></pre></div>\n\n<h4 id=\"event-bus-starter-code\">Event Bus Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/events/event.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> events</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Event represents a generic event in the system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID            </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"event_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"event_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">       `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Source        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"source_component\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CorrelationID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"correlation_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload       </span><span style=\"color:#B392F0\">json</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RawMessage</span><span style=\"color:#9ECBFF\"> `json:\"payload\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Publisher defines the interface for publishing events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Publisher</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Publish</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">eventType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">correlationID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PublishEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Subscriber defines the interface for subscribing to events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Subscriber</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">eventTypes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Event</span><span style=\"color:#E1E4E8\">)) (</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SubscribeWithCorrelation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">eventTypes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">correlationID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Event</span><span style=\"color:#E1E4E8\">)) (</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InMemoryPubSub provides a simple in-memory event bus for development</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InMemoryPubSub</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscribers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Event</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewInMemoryPubSub</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryPubSub</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">InMemoryPubSub</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        subscribers: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Event</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryPubSub</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Publish</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">eventType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#FFAB70\">correlationID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payloadBytes, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"marshal payload: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ID:            uuid.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type:          eventType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:     time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UTC</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Source:        </span><span style=\"color:#9ECBFF\">\"in-memory\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CorrelationID: correlationID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Payload:       payloadBytes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ps.</span><span style=\"color:#B392F0\">PublishEvent</span><span style=\"color:#E1E4E8\">(event)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryPubSub</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PublishEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> Event</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ps.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handlers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ps.subscribers[event.Type]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Also deliver to \"*\" wildcard subscribers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handlers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(handlers, ps.subscribers[</span><span style=\"color:#9ECBFF\">\"*\"</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, handler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> handlers {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#E1E4E8\">(event) </span><span style=\"color:#6A737D\">// Fire and forget</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ps </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">InMemoryPubSub</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Subscribe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">eventTypes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Event</span><span style=\"color:#E1E4E8\">)) (</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ps.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ps.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, eventType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> eventTypes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ps.subscribers[eventType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(ps.subscribers[eventType], handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return unsubscribe function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ps.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        defer</span><span style=\"color:#E1E4E8\"> ps.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, eventType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> eventTypes {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Remove handler from slice</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            handlers </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ps.subscribers[eventType]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> i, h </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> handlers {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">h </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">handler {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    ps.subscribers[eventType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(handlers[:i], handlers[i</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"rpc-client-helper\">RPC Client Helper</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/rpc/client.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> rpc</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Client provides a reusable HTTP RPC client with retries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Client</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseURL    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    httpClient </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxRetries </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retryDelay </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">baseURL</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        baseURL: baseURL,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        httpClient: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Timeout: </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxRetries: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        retryDelay: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Call makes an HTTP POST request with JSON marshaling and retries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Call</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">method</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">response</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastErr </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; attempt </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> c.maxRetries; attempt</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">time.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(c.retryDelay </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(attempt)):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> c.</span><span style=\"color:#B392F0\">callOnce</span><span style=\"color:#E1E4E8\">(ctx, method, request, response)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastErr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Only retry on network errors or 5xx status codes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isRetryableError</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"after </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> retries: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, c.maxRetries, lastErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">callOnce</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">method</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">response</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation details...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Marshal request to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create HTTP POST request with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set appropriate headers (Content-Type: application/json)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send request using httpClient</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check status code - 200 OK for success</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: For non-2xx status codes, parse error response if available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Unmarshal successful response into response struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return appropriate error based on status code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> isRetryableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement logic to determine if error is retryable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Network errors (timeout, connection refused)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - HTTP 5xx status codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Not HTTP 4xx (client errors) except 429 (rate limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-orchestrator-skeleton\">Core Orchestrator Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/orchestrator/orchestrator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> orchestrator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/events</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/rpc</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Orchestrator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    experiments </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExperimentInstance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metricsCollector </span><span style=\"color:#B392F0\">rpc</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetricsClient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    safetyMonitor    </span><span style=\"color:#B392F0\">rpc</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SafetyClient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faultInjector    </span><span style=\"color:#B392F0\">rpc</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultClient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventPublisher   </span><span style=\"color:#B392F0\">events</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Publisher</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanupEnsurer   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">exp</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">resultsChan</span><span style=\"color:#F97583\"> chan&#x3C;-</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentResult</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate experiment is in DRAFT state and all fields are valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create ExperimentInstance with unique ID and initial state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store instance in experiments map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Publish ExperimentStateChanged event (DRAFT → BASELINE_VALIDATION)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start background goroutine running executeStateMachine for this instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return instance ID to caller</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeStateMachine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    instance.CancelFunc </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cancel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Implement state machine logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Use a switch statement on instance.State</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Each case should handle one state and transition to next</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Call appropriate helper methods for each state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validateBaseline</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Call safetyMonitor.ValidateHypothesis with baseline time range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for validation results (timeout after 5 minutes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If validation fails, transition to ABORTED state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If validation passes, record baseline metrics and transition to INJECTING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Publish appropriate events for state changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">injectFaults</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For each fault in instance.Experiment.Faults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call faultInjector.InjectFault with fault details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Record FaultInjectionRecord for successful injections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If any injection fails and continueOnFaultFailure is false, abort</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: After all faults injected, transition to MONITORING state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Start duration timer and safety monitoring goroutine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">o </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Orchestrator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">monitorExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">instance</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExperimentInstance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start two goroutines:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Duration timer: sleeps for instance.Experiment.Duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Safety monitor: calls safetyMonitor.checkSafetyRules periodically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for either:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Duration timer expires → transition to ROLLBACK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Safety breach event → transition to ROLLBACK with emergency flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - External abort command → transition to ROLLBACK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Cancel both goroutines when transition occurs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Context Propagation</strong>: Use <code>context.Context</code> throughout for cancellation and timeouts. Create derived contexts with <code>context.WithTimeout()</code> for RPC calls.</p>\n</li>\n<li><p><strong>Concurrency Patterns</strong>: Use <code>sync.WaitGroup</code> for coordinating multiple goroutines in fault injection. Use <code>select</code> with multiple channels for monitoring timeouts and events.</p>\n</li>\n<li><p><strong>Error Wrapping</strong>: Use <code>fmt.Errorf(&quot;... %w&quot;, err)</code> to wrap errors with context. Create custom error types for domain-specific errors (e.g., <code>ErrExperimentAborted</code>).</p>\n</li>\n<li><p><strong>Idempotency Keys</strong>: Generate UUIDs for all RPC requests using <code>github.com/google/uuid</code>. Include these in requests and log them for debugging.</p>\n</li>\n<li><p><strong>Graceful Shutdown</strong>: Implement signal handling for <code>SIGTERM</code> and <code>SIGINT</code>. On shutdown, abort all running experiments and wait for cleanup.</p>\n</li>\n<li><p><strong>Structured Logging</strong>: Use a logging library like <code>log/slog</code> or <code>zap</code> with fields for experiment ID, fault ID, correlation IDs.</p>\n</li>\n</ol>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the interaction patterns, verify with:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start all components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/controller/main.go</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/fault-injector/main.go</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/safety-monitor/main.go</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create and run a simple experiment</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/v1/experiments</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"name\": \"latency-test\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"hypothesis\": {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"description\": \"Payment service handles 200ms DB latency\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"metrics\": [{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"name\": \"p95_response_time\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"query\": \"histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\\\"payment\\\"}[1m]))\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"max\": 0.5</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      }]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    },</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"faults\": [{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"type\": \"LATENCY\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"target\": {\"type\": \"service\", \"selector\": {\"app\": \"payment-db\"}},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      \"parameters\": {\"latency_ms\": \"200\", \"duration\": \"1m\"}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    }],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"duration\": \"1m\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"blast_radius\": {\"percentage\": 50}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check experiment status</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/v1/experiments/latency-test/status</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. Experiment should move through states: DRAFT → BASELINE_VALIDATION → INJECTING → MONITORING → ROLLBACK → ANALYSIS → COMPLETED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Check logs show RPC calls between components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Fault should be applied for exactly 1 minute then cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Final result should show hypothesis validation outcome</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Experiment hangs in BASELINE_VALIDATION</td>\n<td>Metrics Collector unavailable</td>\n<td>Check Safety Monitor logs for connection errors</td>\n<td>Ensure Metrics Collector is running and reachable</td>\n</tr>\n<tr>\n<td>Fault injection fails with &quot;permission denied&quot;</td>\n<td>Lack of CAP_NET_ADMIN capability</td>\n<td>Check Fault Injector logs for <code>tc</code> command errors</td>\n<td>Run agent with proper capabilities or as root</td>\n</tr>\n<tr>\n<td>Safety breach not triggering rollback</td>\n<td>Thresholds too high or metric lag</td>\n<td>Check Safety Monitor query interval and metric collection delay</td>\n<td>Adjust safety rule thresholds or increase metric collection frequency</td>\n</tr>\n<tr>\n<td>Events not being delivered</td>\n<td>Event bus connectivity issue</td>\n<td>Check if subscribers are registered and publishers are working</td>\n<td>Verify event bus configuration; use in-memory bus for development</td>\n</tr>\n<tr>\n<td>Experiment state inconsistent after restart</td>\n<td>Crash recovery incomplete</td>\n<td>Check CleanupEnsurer logs on startup</td>\n<td>Ensure CleanupEnsurer runs RecoverOrphanedFaults() on startup</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational resilience of the platform itself)</p>\n</blockquote>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<p>In a chaos engineering platform, the tool designed to test system resilience must itself be exceptionally resilient. The inherent contradiction—a system that injects failures must not become a failure point itself—requires careful design of error handling and edge case management. This section outlines the failure modes of the platform&#39;s own components and the strategies for graceful degradation, ensuring that chaos experiments remain controlled, reversible, and observable even when the platform encounters issues.</p>\n<p>The core mental model for this component is <strong>The Flight Recorder and Crash Cart</strong>. Imagine an airplane&#39;s black box that continues recording even during a catastrophic failure, and a hospital&#39;s crash cart that can restore vital functions when systems falter. The chaos platform must have similar self-preservation and recovery mechanisms: it must log its own state persistently to survive crashes, and it must have automated &quot;defibrillators&quot; that restore normal system operation if the platform itself becomes unresponsive.</p>\n<h3 id=\"fault-cleanup-failure-ensuring-reversibility-after-orchestrator-crash\">Fault Cleanup Failure: Ensuring Reversibility After Orchestrator Crash</h3>\n<p>The most critical failure mode in a chaos engineering platform is the inability to clean up injected faults. If the <code>Orchestrator</code> crashes or becomes partitioned during an experiment, faults could persist indefinitely, causing ongoing system degradation that outlives the experiment. This violates the fundamental principle of controlled, reversible testing.</p>\n<p><strong>Mental Model: The Dead Man&#39;s Switch</strong>\nPicture a train engineer who must hold down a lever; if they release it (or become incapacitated), the brakes automatically engage to prevent catastrophe. The fault cleanup system operates on a similar principle: it continuously verifies the orchestrator&#39;s heartbeat, and if the heartbeat stops, it triggers automatic fault rollback. This ensures that faults cannot outlive their controlling process.</p>\n<h4 id=\"architecture-decision-persisted-fault-registry-with-recovery-scanner\">Architecture Decision: Persisted Fault Registry with Recovery Scanner</h4>\n<blockquote>\n<p><strong>Decision: Fault Cleanup via Persistent Registry and Startup Recovery Scan</strong></p>\n<ul>\n<li><strong>Context</strong>: The <code>Orchestrator</code> may crash at any point during an experiment&#39;s lifecycle, leaving active faults without a controlling process. We need a mechanism to guarantee cleanup regardless of orchestrator state.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>In-Memory Tracking Only</strong>: Store active fault state only in the orchestrator&#39;s memory.</li>\n<li><strong>Persistent Fault Registry with Async Cleanup</strong>: Write all fault injection commands and their reversal commands to a durable log, with a separate recovery process.</li>\n<li><strong>Lease-Based Heartbeat with External Watchdog</strong>: Have each fault injector agent acquire a time-bound lease from the orchestrator; if the lease expires, the agent self-cleans.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Persistent Fault Registry with Async Cleanup</strong> (Option 2), combined with a synchronous startup recovery scan.</li>\n<li><strong>Rationale</strong>:<ul>\n<li>In-memory tracking (Option 1) is unacceptable for a resilience tool—it creates a single point of failure.</li>\n<li>The lease-based approach (Option 3) adds complexity and requires the fault injector agents to have cleanup logic, which increases the attack surface and maintenance burden.</li>\n<li>A persistent registry provides a simple, auditable trail of all fault injections. The startup recovery scan is a straightforward, synchronous operation that guarantees no orphaned faults exist when the orchestrator starts. It aligns with the idempotent operations principle: cleanup commands can be safely re-executed.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Guarantees fault cleanup even after catastrophic platform failure. Provides an audit log for compliance and debugging.</li>\n<li><strong>Negative</strong>: Introduces a disk I/O dependency. Requires careful serialization of fault records to avoid log corruption.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>In-Memory Tracking Only</td>\n<td>Simple, no I/O overhead</td>\n<td>Faults become permanent on crash; unacceptable</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Persistent Fault Registry with Async Cleanup</td>\n<td>Durable, auditable, allows recovery</td>\n<td>Disk I/O, requires serialization</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Lease-Based Heartbeat with External Watchdog</td>\n<td>Decentralized cleanup responsibility</td>\n<td>Complex, agents become stateful, new failure modes</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-mechanism-the-cleanupensurer\">Core Mechanism: The <code>CleanupEnsurer</code></h4>\n<p>The <code>CleanupEnsurer</code> is a dedicated component responsible for recording every fault injection in a persistent, append-only log file and ensuring its reversal. It operates through three key methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RegisterFault</code></td>\n<td><code>record FaultRecord</code></td>\n<td><code>error</code></td>\n<td>Atomically appends a fault record to the log and updates the in-memory map of active faults. The record includes the exact cleanup command.</td>\n</tr>\n<tr>\n<td><code>CompleteFault</code></td>\n<td><code>faultID string</code></td>\n<td><code>error</code></td>\n<td>Marks a fault as cleaned up in the log (by appending a completion record) and removes it from the in-memory active map.</td>\n</tr>\n<tr>\n<td><code>RecoverOrphanedFaults</code></td>\n<td>None</td>\n<td><code>error</code></td>\n<td>Called on orchestrator startup. Reads the entire log, identifies any faults marked as injected but not cleaned up, and executes their cleanup commands.</td>\n</tr>\n</tbody></table>\n<p>The <code>FaultRecord</code> data structure captures all information needed for cleanup:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ExperimentID</code></td>\n<td><code>string</code></td>\n<td>Identifier of the owning experiment.</td>\n</tr>\n<tr>\n<td><code>FaultID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for this fault instance.</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td><code>string</code></td>\n<td>The system component targeted (e.g., pod name, service endpoint).</td>\n</tr>\n<tr>\n<td><code>FaultType</code></td>\n<td><code>string</code></td>\n<td>The type of fault (e.g., <code>LATENCY</code>, <code>PROCESS_KILL</code>).</td>\n</tr>\n<tr>\n<td><code>InjectTime</code></td>\n<td><code>time.Time</code></td>\n<td>When the fault was injected.</td>\n</tr>\n<tr>\n<td><code>CleanupCmd</code></td>\n<td><code>string</code></td>\n<td>The exact shell command or API call needed to reverse the fault (e.g., <code>tc qdisc del dev eth0 root netem</code>).</td>\n</tr>\n</tbody></table>\n<p><strong>Algorithm for Fault Injection with Cleanup Guarantee</strong>:</p>\n<ol>\n<li><strong>Pre-injection Logging</strong>: Before executing the fault injection command, the <code>Orchestrator</code> calls <code>RegisterFault</code> with a <code>FaultRecord</code> containing the planned cleanup command. This write is flushed to disk (using <code>fsync</code>) to ensure durability.</li>\n<li><strong>Fault Execution</strong>: The orchestrator executes the fault injection command (e.g., via a system call or RPC to a fault injector agent).</li>\n<li><strong>Post-Injection Confirmation</strong>: If injection succeeds, the fault state is updated to <code>ACTIVE</code>. If injection fails, the orchestrator immediately calls <code>CompleteFault</code> to mark the record as cleaned (since no fault was applied) and retries or aborts the experiment.</li>\n<li><strong>Cleanup Trigger</strong>: During normal experiment flow (completion or abort), the orchestrator executes the cleanup command and, upon success, calls <code>CompleteFault</code>.</li>\n<li><strong>Crash Recovery</strong>: On restart, the <code>Orchestrator</code> calls <code>RecoverOrphanedFaults</code>. This function scans the log, re-executes the <code>CleanupCmd</code> for any fault without a completion record, and then marks them as completed.</li>\n</ol>\n<h4 id=\"edge-cases-and-mitigations\">Edge Cases and Mitigations</h4>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Orchestrator crashes mid-injection (after log write, before fault application)</td>\n<td><code>RecoverOrphanedFaults</code> finds a record with no corresponding active fault in the system.</td>\n<td>Execute the <code>CleanupCmd</code>. Since the fault was never applied, the command is idempotent and will likely return an error (e.g., &quot;no such qdisc&quot;). Log the error and mark the record as completed.</td>\n</tr>\n<tr>\n<td>Orchestrator crashes mid-cleanup (after cleanup started but before log completion)</td>\n<td><code>RecoverOrphanedFaults</code> finds a record still marked as injected, but the cleanup command may have partially succeeded.</td>\n<td>Re-execute the idempotent cleanup command. This ensures the system state is clean even if the previous attempt was interrupted.</td>\n</tr>\n<tr>\n<td>Persistent log file corruption</td>\n<td>Checksum verification on log entries during startup scan.</td>\n<td>If corruption is detected in the middle of the log, the safest action is to attempt cleanup for all potentially orphaned faults (by reading valid records up to the corruption point) and then truncate the log file. A warning is raised for operator intervention.</td>\n</tr>\n<tr>\n<td>Cleanup command itself fails (e.g., target resource no longer exists)</td>\n<td>The cleanup command returns a non-zero exit code or error response.</td>\n<td>Retry with exponential backoff (up to a limit). If cleanup ultimately fails, escalate via an alert to platform operators, as this indicates a system drift from the expected state.</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls\">Common Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Assuming Cleanup Commands Are Always Idempotent</strong></p>\n<ul>\n<li><strong>Description</strong>: Writing a cleanup command that, if run twice, causes an error or changes system state beyond the desired cleanup.</li>\n<li><strong>Why It&#39;s Wrong</strong>: The recovery scanner may execute cleanup commands multiple times (e.g., after a crash during cleanup). Non-idempotent commands could throw errors that halt the recovery process or, worse, apply incorrect configuration.</li>\n<li><strong>Fix</strong>: Design all fault injection and cleanup commands to be idempotent. For example, instead of <code>kill -9 &lt;pid&gt;</code> (which fails if the process is already dead), use a pattern that checks existence first, or use <code>pkill</code> with a pattern that tolerates missing processes. For network rules, use <code>tc qdisc replace</code> instead of <code>add</code>, or wrap commands in logic that checks current state before modifying.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Blocking Synchronous Disk Flushing During Experiment Execution</strong></p>\n<ul>\n<li><strong>Description</strong>: Calling <code>fsync</code> after every <code>RegisterFault</code> write, which can block the orchestrator for tens of milliseconds, affecting experiment timing and scalability.</li>\n<li><strong>Why It&#39;s Wrong</strong>: While durability is critical, synchronous disk I/O can become a performance bottleneck, especially for experiments with many rapid fault injections.</li>\n<li><strong>Fix</strong>: Use a <strong>write-ahead log (WAL) with batch flushing</strong>. The <code>CleanupEnsurer</code> can buffer multiple <code>FaultRecord</code> writes in memory and flush them to disk every 100ms or after a certain number of records. The risk window of losing recent records before a crash is acceptable because:<ol>\n<li>The platform&#39;s own crash is a rare event.</li>\n<li>The blast radius of a few unlogged faults is limited (they would be orphaned but could be manually cleaned).</li>\n<li>The trade-off favors experiment performance over absolute guarantee for every single fault.</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"metrics-collection-interruption-maintaining-safety-without-data\">Metrics Collection Interruption: Maintaining Safety Without Data</h3>\n<p>The <strong>Safety Monitor</strong> relies on a continuous stream of system metrics to evaluate <code>SafetyRule</code> conditions and trigger auto-rollback. If the metrics collection pipeline is interrupted (e.g., metrics collector failure, network partition, or scraping timeout), the safety monitor operates blind, unable to detect if the system has breached safety thresholds.</p>\n<p><strong>Mental Model: The Instrument Flight Rules (IFR) vs. Visual Flight Rules (VFR)</strong>\nIn aviation, pilots rely on instruments when visibility is poor. Similarly, the safety monitor has two modes of operation: <strong>&quot;Instrumented&quot; mode</strong> (normal, with full metrics) and <strong>&quot;Procedural&quot; mode</strong> (when metrics are unavailable). In procedural mode, the platform follows pre-defined conservative procedures—like an immediate rollback—because it cannot verify system health.</p>\n<h4 id=\"architecture-decision-fail-safe-rollback-on-metrics-unavailability\">Architecture Decision: Fail-Safe Rollback on Metrics Unavailability</h4>\n<blockquote>\n<p><strong>Decision: Trigger Auto-Rollback After Sustained Metrics Collection Failure</strong></p>\n<ul>\n<li><strong>Context</strong>: The <code>SafetyMonitor</code> component periodically queries the <code>MetricsCollector</code> for current system metrics. If these queries fail repeatedly, the monitor loses situational awareness.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Continue Experiment Blindly</strong>: Assume the system is healthy and proceed with the experiment.</li>\n<li><strong>Pause Experiment</strong>: Halt further fault injection but leave existing faults active until metrics return.</li>\n<li><strong>Fail-Safe Rollback</strong>: Immediately initiate rollback of all faults and abort the experiment.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: <strong>Fail-Safe Rollback</strong> (Option 3) after a short grace period (e.g., 3 consecutive collection failures).</li>\n<li><strong>Rationale</strong>:<ul>\n<li>Continuing blindly (Option 1) is reckless; the system could be experiencing a catastrophic failure induced by the experiment, and we wouldn&#39;t know.</li>\n<li>Pausing (Option 2) leaves faults active in an unknown state, potentially prolonging damage.</li>\n<li>Fail-safe rollback prioritizes system stability over experiment completion. It treats loss of observability as a serious risk factor, aligning with the chaos engineering principle of minimizing blast radius and ensuring safety.</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li><strong>Positive</strong>: Eliminates risk of undetected degradation due to monitoring failure. Simple to implement and reason about.</li>\n<li><strong>Negative</strong>: May cause unnecessary experiment abortions in cases of transient metrics collection issues (e.g., a brief network glitch). This is a conservative trade-off.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Continue Experiment Blindly</td>\n<td>Maximizes experiment completion rate</td>\n<td>Potentially catastrophic; violates safety</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Pause Experiment</td>\n<td>Prevents new damage; waits for visibility</td>\n<td>Leaves existing faults active; complex state</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Fail-Safe Rollback</td>\n<td>Guarantees system safety; simple</td>\n<td>May abort experiments unnecessarily</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"implementation-strategy-health-aware-metrics-collection\">Implementation Strategy: Health-Aware Metrics Collection</h4>\n<p>The <code>SafetyMonitor</code> uses a dedicated method <code>checkSafetyRules</code> that includes logic for detecting metrics collection failures. The algorithm extends as follows:</p>\n<ol>\n<li><strong>Metric Collection Attempt</strong>: For each safety rule, the monitor calls <code>GetCurrentValue</code> on the <code>MetricsCollector</code>. This call has a short timeout (e.g., 5 seconds).</li>\n<li><strong>Failure Counting</strong>: If the call fails (returns error or times out), increment a failure counter for that specific metric source (e.g., Prometheus endpoint). Success resets the counter.</li>\n<li><strong>Threshold Evaluation</strong>: If the failure counter exceeds a configured threshold (e.g., 3), the monitor triggers a <strong>&quot;MetricsUnavailable&quot;</strong> safety event.</li>\n<li><strong>Automatic Action</strong>: The <code>Orchestrator</code>, upon receiving this event, immediately transitions the experiment to the <code>ROLLBACK</code> state, regardless of other conditions. This is a <strong>circuit breaker</strong> pattern for observability.</li>\n</ol>\n<p>To distinguish between a complete metrics blackout and degradation of a specific metric, the system uses a <strong>heartbeat metric</strong>—a simple, always-available metric like the metrics collector&#39;s own uptime. If the heartbeat metric is also unavailable, it indicates a total collection failure.</p>\n<h4 id=\"data-structure-extension-safetyevent-for-collection-failures\">Data Structure Extension: <code>SafetyEvent</code> for Collection Failures</h4>\n<p>The existing <code>SafetyEvent</code> struct is extended to capture metrics collection failures:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Rule</code></td>\n<td><code>SafetyRule</code></td>\n<td>The safety rule that could not be evaluated.</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>time.Time</code></td>\n<td>When the failure occurred.</td>\n</tr>\n<tr>\n<td><code>Value</code></td>\n<td><code>float64</code></td>\n<td>Last known value (if any).</td>\n</tr>\n<tr>\n<td><code>Triggered</code></td>\n<td><code>bool</code></td>\n<td>Whether the rule condition was met (always <code>false</code> for collection failure).</td>\n</tr>\n<tr>\n<td><code>DurationMet</code></td>\n<td><code>bool</code></td>\n<td>Whether the condition held for the required duration.</td>\n</tr>\n<tr>\n<td><code>ActionTaken</code></td>\n<td><code>string</code></td>\n<td>Description of action taken (e.g., <code>&quot;Rollback triggered due to metrics unavailability&quot;</code>).</td>\n</tr>\n<tr>\n<td><code>Error</code></td>\n<td><code>*string</code></td>\n<td>New field: The error message from the metrics collection failure (e.g., <code>&quot;connection timeout&quot;</code>).</td>\n</tr>\n</tbody></table>\n<h4 id=\"edge-cases-and-mitigations\">Edge Cases and Mitigations</h4>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Intermittent metric scraping failure for one service</td>\n<td>Some metrics succeed, others fail. The failure counter is per-metric-source.</td>\n<td>If only a subset of metrics fail, the safety monitor can still evaluate rules based on available metrics. The experiment continues, but an observation is logged about partial data loss.</td>\n</tr>\n<tr>\n<td>Complete metrics backend outage (e.g., Prometheus down)</td>\n<td>Heartbeat metric fails, and all metric queries time out.</td>\n<td>The failure counter for the heartbeat metric quickly reaches threshold, triggering global rollback. The platform should alert operators about the monitoring system failure.</td>\n</tr>\n<tr>\n<td>Metrics lag (delayed data)</td>\n<td>Metric values are stale; timestamps show data older than a threshold (e.g., 30 seconds).</td>\n<td>Treat stale data as a collection failure. The safety monitor should check data freshness and increment the failure counter if data is beyond an acceptable age. This prevents making abort decisions based on outdated information.</td>\n</tr>\n<tr>\n<td>Safety monitor process crash</td>\n<td>The <code>Orchestrator</code> notices missed health pings from the monitor (via a simple heartbeat goroutine).</td>\n<td>The orchestrator, lacking safety oversight, should immediately initiate rollback. This is a higher-level fail-safe beyond the metrics collection logic.</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls\">Common Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Using a Single Global Failure Counter for All Metrics</strong></p>\n<ul>\n<li><strong>Description</strong>: Aggregating failures across all metrics into one counter, causing a rollback due to a single flaky metric while other critical metrics are flowing.</li>\n<li><strong>Why It&#39;s Wrong</strong>: Overly broad failure detection leads to unnecessary experiment abortions and reduces confidence in the platform. It also masks the real issue—which specific metric source is problematic.</li>\n<li><strong>Fix</strong>: Implement <strong>per-metric-source failure tracking</strong>. Each independent metrics endpoint (e.g., each Prometheus target, each service&#39;s metrics port) gets its own failure counter. Rollback only triggers if a critical mass of sources fail (e.g., &gt;50%) or if a designated &quot;heartbeat&quot; source fails.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Metrics Freshness</strong></p>\n<ul>\n<li><strong>Description</strong>: Using the last successfully scraped metric value without checking its timestamp, potentially making safety decisions based on minutes-old data.</li>\n<li><strong>Why It&#39;s Wrong</strong>: During rapid degradation, stale metrics can show a healthy system while the actual system is failing. This delays auto-rollback and increases damage.</li>\n<li><strong>Fix</strong>: Every metric query should return both value and timestamp. The <code>SafetyMonitor</code> must compare the timestamp to the current time; if the data is older than a threshold (e.g., <code>scrape_interval + 10s</code>), treat it as a collection failure.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides the concrete code structures and skeletons to implement the error handling strategies described above.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Persistent Fault Log</td>\n<td>Append-only text file with JSON lines</td>\n<td>Embedded database (SQLite) with WAL mode</td>\n</tr>\n<tr>\n<td>Metrics Collection Failure Detection</td>\n<td>Simple timeout and retry counter</td>\n<td>Adaptive circuit breaker with exponential backoff</td>\n</tr>\n<tr>\n<td>Orchestrator-Safety Monitor Heartbeat</td>\n<td>Periodic HTTP health check</td>\n<td>Bidirectional gRPC stream with keepalive</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── orchestrator/\n│   │   └── main.go\n│   └── cleanup-agent/\n│       └── main.go          # Optional standalone recovery agent\n├── internal/\n│   ├── orchestrator/\n│   │   ├── orchestrator.go\n│   │   ├── experiment_instance.go\n│   │   └── orchestrator_test.go\n│   ├── fault/\n│   │   ├── injector.go\n│   │   ├── cleanup_ensurer.go    # &lt;-- NEW: Persistent fault registry\n│   │   └── recovery.go           # &lt;-- NEW: Recovery scanner\n│   ├── safety/\n│   │   ├── monitor.go\n│   │   ├── metrics_checker.go    # &lt;-- Enhanced with failure detection\n│   │   └── circuit_breaker.go\n│   └── types/\n│       └── types.go              # All data structures\n└── pkg/\n    └── persistence/\n        ├── wal.go                # Generic write-ahead log\n        └── wal_test.go</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-write-ahead-log-wal\">Infrastructure Starter Code: Write-Ahead Log (WAL)</h4>\n<p>The following is a complete, reusable write-ahead log implementation that the <code>CleanupEnsurer</code> can use for fault record persistence. It provides atomic append and recovery scanning.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/persistence/wal.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> persistence</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WAL represents a write-ahead log file.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WAL</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">os</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">File</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    writer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Writer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewWAL creates or opens a WAL file at the given path.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewWAL</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create WAL directory: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Open in append mode, create if not exists.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">OpenFile</span><span style=\"color:#E1E4E8\">(path, os.O_APPEND</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_CREATE</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">os.O_WRONLY, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open WAL file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file:   file,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        writer: bufio.</span><span style=\"color:#B392F0\">NewWriter</span><span style=\"color:#E1E4E8\">(file),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path:   path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Append marshals the record to JSON and appends it as a line to the WAL.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It flushes to disk (fsync) to ensure durability.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Append</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(record)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"marshal record: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.writer.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(data); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write to buffer: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Flush buffer to OS.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.writer.</span><span style=\"color:#B392F0\">Flush</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"flush buffer: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure data is written to disk.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Sync</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fsync: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Scan reads the entire WAL file line by line, unmarshaling each line into the provided function.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The function f is called for each record. If f returns an error, scanning stops.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">f</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">line</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Open for reading only.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(w.path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open for reading: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scanner </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bufio.</span><span style=\"color:#B392F0\">NewScanner</span><span style=\"color:#E1E4E8\">(file)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> f</span><span style=\"color:#E1E4E8\">(scanner.</span><span style=\"color:#B392F0\">Bytes</span><span style=\"color:#E1E4E8\">()); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"scan error: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close closes the WAL file.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WAL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> w.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> w.file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-cleanupensurer\">Core Logic Skeleton: CleanupEnsurer</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/fault/cleanup_ensurer.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> fault</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/pkg/persistence</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupEnsurer ensures fault cleanup even after a crash.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CleanupEnsurer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wal         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">persistence</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">WAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeFaults </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#6A737D\">  // faultID -> record</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCleanupEnsurer creates a CleanupEnsurer with a persistent WAL at dataDir/cleanup.wal.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCleanupEnsurer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dataDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wal, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> persistence.</span><span style=\"color:#B392F0\">NewWAL</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(dataDir, </span><span style=\"color:#9ECBFF\">\"cleanup.wal\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ce </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wal:         wal,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeFaults: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // On startup, recover any orphaned faults from previous run.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ce.</span><span style=\"color:#B392F0\">RecoverOrphanedFaults</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"recover orphaned faults: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ce, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterFault records a fault injection in the WAL and marks it as active.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ce </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ce.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ce.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Assign a unique FaultID if not already set (e.g., using UUID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set InjectTime to current time if not set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Append the record to the WAL (use ce.wal.Append)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If WAL append succeeds, add record to activeFaults map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return any error from WAL append; otherwise return nil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompleteFault marks a fault as cleaned up in the WAL and removes it from active map.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ce </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CompleteFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ce.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ce.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if faultID exists in activeFaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create a completion record (e.g., a JSON with faultID and completion timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Append completion record to WAL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If WAL append succeeds, delete faultID from activeFaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return any error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoverOrphanedFaults scans the WAL and re-executes cleanup for any fault without a completion record.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ce </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecoverOrphanedFaults</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create a map to track the latest state of each faultID from the WAL.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         We'll parse each line and update state: \"injected\" or \"completed\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Use ce.wal.Scan to read each line. For each line:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    - Unmarshal into a generic map to check type.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    - If it's a fault record (has InjectTime), mark faultID as injected.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //    - If it's a completion record, mark faultID as completed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: After scan, iterate over all faultIDs marked as injected but not completed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each orphaned fault, execute its CleanupCmd (use os/exec or equivalent).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Log the outcome.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: After attempting cleanup, append a completion record for each orphaned fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         (to prevent re-cleanup on next restart).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clear the activeFaults map and repopulate with currently active faults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         (should be empty after recovery).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetActiveFaults returns a copy of the currently active faults (for debugging).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ce </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CleanupEnsurer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetActiveFaults</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ce.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ce.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faults </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(ce.activeFaults))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, f </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> ce.activeFaults {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        faults </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(faults, f)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> faults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-enhanced-safety-monitor-with-failure-detection\">Core Logic Skeleton: Enhanced Safety Monitor with Failure Detection</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/safety/metrics_checker.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> safety</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">chaos-platform/internal/metrics</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricsChecker evaluates safety rules and detects metrics collection failures.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsChecker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collector        </span><span style=\"color:#B392F0\">metrics</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Collector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureCounters  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // metric source -> consecutive failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureThreshold </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heartbeatQuery   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMetricsChecker creates a new MetricsChecker.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMetricsChecker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">collector</span><span style=\"color:#B392F0\"> metrics</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Collector</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">failureThreshold</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">heartbeatQuery</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsChecker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MetricsChecker</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        collector:        collector,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failureCounters:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failureThreshold: failureThreshold,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        heartbeatQuery:   heartbeatQuery,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckSafetyRules evaluates all safety rules and returns safety events.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It also checks for metrics collection failures and triggers a failure event if needed.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckSafetyRules</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rules</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SafetyRule</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SafetyEvent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> events []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SafetyEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overallSafe </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // First, check heartbeat metric to ensure overall metrics collection is alive.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Call mc.collector.GetCurrentValue with mc.heartbeatQuery and a timeout.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If heartbeat check fails, increment its failure counter.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If heartbeat failure counter >= mc.failureThreshold, create a SafetyEvent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         with ActionTaken \"Rollback triggered due to metrics unavailability\".</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Return this event and overallSafe = false (triggering rollback).</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Evaluate each safety rule.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, rule </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> rules {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Determine the metric source for this rule (e.g., from rule.Metric).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Call mc.collector.GetCurrentValue for rule.Metric with timeout.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: If call fails, increment failure counter for this source.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //         If failure counter >= threshold, create a SafetyEvent for collection failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: If call succeeds, reset failure counter for this source.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //         Then compare value against rule.Condition (e.g., \"error_rate > 0.05\").</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 8: If condition violated, create a SafetyEvent with Triggered=true.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //         Update overallSafe accordingly.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> events, overallSafe, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li><strong>Go&#39;s <code>os/exec</code> for Cleanup Commands</strong>: Use <code>exec.CommandContext</code> with a timeout to run cleanup shell commands. Always capture <code>stdout</code> and <code>stderr</code> for logging.</li>\n<li><strong>Concurrent Map Access</strong>: Use <code>sync.RWMutex</code> for the <code>activeFaults</code> map in <code>CleanupEnsurer</code>. The pattern is: lock for writes (<code>RegisterFault</code>, <code>CompleteFault</code>), and RLock for reads (<code>GetActiveFaults</code>).</li>\n<li><strong>JSON Serialization</strong>: Use <code>encoding/json</code> for marshaling <code>FaultRecord</code>. Ensure that the <code>CleanupCmd</code> field is a string containing the exact command, and consider using a <code>json.RawMessage</code> for flexible parameter storage.</li>\n<li><strong>Context for Timeouts</strong>: Pass a <code>context.Context</code> with timeout to all external calls (metrics collection, command execution). This prevents hangs.</li>\n</ul>\n<h4 id=\"milestone-checkpoint-verifying-cleanup-recovery\">Milestone Checkpoint: Verifying Cleanup Recovery</h4>\n<p>After implementing the <code>CleanupEnsurer</code>:</p>\n<ol>\n<li><strong>Start the orchestrator</strong> and inject a simple fault (e.g., network latency).</li>\n<li><strong>Simulate a crash</strong> by forcibly killing the orchestrator process (<code>kill -9</code>).</li>\n<li><strong>Restart the orchestrator</strong>. Observe the logs during startup.</li>\n<li><strong>Expected Behavior</strong>: The orchestrator should log &quot;Recovering orphaned faults&quot; and execute the cleanup command for the previously injected latency fault. After restart, verify that the fault is no longer active (e.g., by checking <code>tc qdisc show</code>).</li>\n<li><strong>Verification Command</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # After step 2, before step 3, check that the fault is still present</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   tc</span><span style=\"color:#9ECBFF\"> qdisc</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> dev</span><span style=\"color:#9ECBFF\"> eth0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # After step 3, the same command should show no netem rules.</span></span></code></pre></div>\n<ol start=\"6\">\n<li><strong>Sign of Success</strong>: The orphaned fault is automatically cleaned up on restart.</li>\n<li><strong>Common Issue</strong>: If the cleanup command fails, check the exact command string in the <code>FaultRecord</code>. Ensure it uses idempotent forms (e.g., <code>tc qdisc del ...</code> may fail if the rule doesn&#39;t exist; consider using <code>tc qdisc replace</code> or a script that checks first).</li>\n</ol>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Orphaned faults not cleaned up on restart</td>\n<td><code>RecoverOrphanedFaults</code> not scanning WAL correctly</td>\n<td>Check WAL file contents (<code>cat cleanup.wal</code>). Ensure each line is valid JSON.</td>\n<td>Fix JSON marshaling in <code>RegisterFault</code>. Ensure WAL scanning logic correctly identifies completion records.</td>\n</tr>\n<tr>\n<td>Metrics collection failure triggers unnecessary rollback</td>\n<td>Transient network blip causes a few timeouts</td>\n<td>Check logs for metrics collection errors. Look at <code>failureCounters</code> in <code>MetricsChecker</code>.</td>\n<td>Increase <code>failureThreshold</code> (e.g., from 3 to 5) or implement a circuit breaker that allows occasional failures.</td>\n</tr>\n<tr>\n<td>Cleanup command fails during recovery because target resource gone</td>\n<td>Non-idempotent cleanup command (e.g., <code>kill -9 &lt;pid&gt;</code> on a dead process)</td>\n<td>Examine the error log from the cleanup attempt.</td>\n<td>Rewrite cleanup command to be idempotent: wrap in a script that checks resource existence first, or use commands that tolerate missing targets.</td>\n</tr>\n<tr>\n<td>WAL file grows indefinitely</td>\n<td>Completion records are written but old records never purged</td>\n<td>Check file size of <code>cleanup.wal</code>.</td>\n<td>Implement log rotation: after recovery, start a new WAL file and archive the old one. Or, switch to a database with automatic compaction.</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (testing is a cross-cutting concern that applies to every stage of development)</p>\n</blockquote>\n<h3 id=\"mental-model-the-chaos-platform39s-safety-harness\">Mental Model: The Chaos Platform&#39;s Safety Harness</h3>\n<p>Imagine building a <strong>parachute-testing facility</strong>—you&#39;re designing equipment that saves lives by deploying reliably under extreme conditions. You wouldn&#39;t trust a parachute that hasn&#39;t been rigorously tested, nor would you test it by jumping from a plane without verification first. Similarly, a chaos engineering platform that injects failures into production systems must itself be <strong>more reliable than the systems it tests</strong>. The testing strategy serves as our safety harness—a comprehensive verification system that ensures every component behaves predictably, faults are always reversible, and the platform never becomes the source of the outages it&#39;s designed to prevent.</p>\n<p>This section outlines how to verify the platform&#39;s correctness through a multi-layered approach: from unit tests that validate individual fault types to integration tests that simulate full chaos experiments in isolated environments. We&#39;ll provide concrete checkpoints for each milestone, giving you clear signals that your implementation is progressing correctly.</p>\n<h3 id=\"testing-approach-and-properties\">Testing Approach and Properties</h3>\n<p>Testing a chaos engineering platform presents unique challenges: we must verify that <strong>failure injection works correctly</strong> while simultaneously ensuring <strong>it never causes permanent damage</strong>. This duality requires three complementary testing strategies operating at different levels of abstraction.</p>\n<p><strong>Unit Testing: The Component Microscope</strong> focuses on individual components in isolation, verifying their internal logic without external dependencies. Each component—<code>Fault</code>, <code>Experiment</code>, <code>SafetyMonitor</code>—has well-defined responsibilities that can be tested with mock dependencies.</p>\n<p><strong>Integration Testing: The System Integration Lab</strong> verifies interactions between components, ensuring they cooperate correctly to execute complex workflows like experiment orchestration. This layer tests the platform&#39;s ability to coordinate fault injection with safety monitoring and cleanup.</p>\n<p><strong>Property-Based Testing: The Invariant Verifier</strong> moves beyond example-based testing to verify universal properties that must hold for all possible inputs. For a chaos platform, properties like &quot;all faults must be reversible&quot; are more valuable than testing specific parameter combinations.</p>\n<p>The following table summarizes the test categories, their purpose, and typical scope:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Purpose</th>\n<th>Scope Example</th>\n<th>Execution Frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unit Tests</strong></td>\n<td>Verify component logic in isolation</td>\n<td><code>Fault.Validate()</code> returns error for invalid parameters</td>\n<td>On every code change (fast: &lt;100ms)</td>\n</tr>\n<tr>\n<td><strong>Integration Tests</strong></td>\n<td>Verify component interactions</td>\n<td><code>Orchestrator</code> successfully runs experiment with mock fault injector</td>\n<td>On every pull request (medium: &lt;30s)</td>\n</tr>\n<tr>\n<td><strong>Property Tests</strong></td>\n<td>Verify universal invariants</td>\n<td>For any valid <code>Fault</code>, <code>CleanupFault()</code> restores original state</td>\n<td>Nightly or weekly (slow: minutes)</td>\n</tr>\n<tr>\n<td><strong>End-to-End Tests</strong></td>\n<td>Verify full platform in realistic environment</td>\n<td>Complete GameDay scenario against test microservices</td>\n<td>Weekly or before releases (slow: minutes-hours)</td>\n</tr>\n<tr>\n<td><strong>Chaos Tests</strong></td>\n<td>Verify platform resilience under self-inflicted chaos</td>\n<td>Inject network partition during experiment execution</td>\n<td>Monthly (experimental)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: The most critical property of any chaos engineering platform is <strong>reversibility</strong>—the guarantee that every injected fault can be completely cleaned up, restoring the system to its original state. This property is so fundamental that we&#39;ll verify it through multiple testing layers.</p>\n</blockquote>\n<h4 id=\"property-based-testing-core-invariants\">Property-Based Testing: Core Invariants</h4>\n<p>Property-based testing generates hundreds of random inputs to verify that certain properties always hold true. For our chaos platform, we identify several non-negotiable invariants:</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Description</th>\n<th>Test Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Reversibility</strong></td>\n<td>Every fault injection has a corresponding cleanup that restores the original system state</td>\n<td>Generate random fault parameters, inject fault, run cleanup, compare system state before/after</td>\n</tr>\n<tr>\n<td><strong>Idempotency</strong></td>\n<td>Applying the same fault twice has the same effect as applying it once; cleaning up twice has the same effect as cleaning up once</td>\n<td>Inject fault, verify state, inject again, verify no change; repeat for cleanup</td>\n</tr>\n<tr>\n<td><strong>Isolation</strong></td>\n<td>Faults only affect targets within their specified blast radius</td>\n<td>Inject fault on target A, verify target B remains unaffected</td>\n</tr>\n<tr>\n<td><strong>Safety Responsiveness</strong></td>\n<td>When safety thresholds are breached, the platform automatically initiates rollback within a bounded time</td>\n<td>Simulate metric breach, measure time to rollback initiation</td>\n</tr>\n<tr>\n<td><strong>Crash Recovery</strong></td>\n<td>If the platform crashes during fault injection, it recovers and cleans up all orphaned faults on restart</td>\n<td>Kill platform process during experiment, restart, verify no active faults remain</td>\n</tr>\n<tr>\n<td><strong>Deterministic Cleanup</strong></td>\n<td>Cleanup operations produce the same final state regardless of when they&#39;re executed (immediately vs. after delay)</td>\n<td>Inject fault, wait random duration, cleanup, verify state matches baseline</td>\n</tr>\n</tbody></table>\n<p>These properties form the foundation of our testing strategy. The following ADR explains our approach to implementing property-based testing:</p>\n<blockquote>\n<p><strong>Decision: Property-Based Testing Framework Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to verify critical invariants across the entire parameter space of fault injections, not just specific examples.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Manual example-based tests only</strong>: Write traditional unit tests with handcrafted examples for common cases.</li>\n<li><strong>Property-based testing with Go&#39;s <code>testing/quick</code></strong>: Use the built-in library for generating random inputs.</li>\n<li><strong>Property-based testing with <code>gopter</code></strong>: Use a third-party library offering more sophisticated generators and property verification.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>gopter</code> for property-based testing of critical invariants, supplemented by example-based tests for edge cases.</li>\n<li><strong>Rationale</strong>: <code>gopter</code> provides richer generators (including recursive structures), better shrinking (minimizing failing test cases), and integrated reporting. While <code>testing/quick</code> is simpler, it lacks the flexibility needed for complex <code>Fault</code> structures with nested parameters. The additional dependency is justified by the improved debugging experience when properties fail.</li>\n<li><strong>Consequences</strong>: We gain robust invariant verification but add an external dependency. Test execution time increases due to generated test cases, requiring careful balancing of iteration count.</li>\n</ul>\n</blockquote>\n<p>Table: Property Testing Framework Comparison</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Selected?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Manual examples only</td>\n<td>Simple, fast, predictable</td>\n<td>Misses edge cases, limited coverage</td>\n<td>No (supplementary only)</td>\n</tr>\n<tr>\n<td><code>testing/quick</code></td>\n<td>Built into Go standard library, no dependencies</td>\n<td>Limited generator flexibility, poor shrinking</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>gopter</code></td>\n<td>Rich generators, excellent shrinking, good reporting</td>\n<td>External dependency, steeper learning curve</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"integration-testing-strategy\">Integration Testing Strategy</h4>\n<p>Integration tests verify that components work together correctly. Given the platform&#39;s potential to cause real system disruption, we employ a <strong>defense-in-depth</strong> approach with multiple safety layers:</p>\n<ol>\n<li><strong>Test Doubles for Dangerous Operations</strong>: Network fault injection (<code>tc</code>, <code>iptables</code>) is replaced with mock implementations that record intent without executing commands.</li>\n<li><strong>Containerized Test Environments</strong>: Run integration tests in isolated Docker containers with controlled resource limits.</li>\n<li><strong>State Verification Points</strong>: Before and after each test, verify system state matches expectations.</li>\n</ol>\n<p>The integration test flow follows this pattern:</p>\n<ol>\n<li>Setup test environment with known initial state</li>\n<li>Execute platform operation (e.g., <code>StartExperiment</code>)</li>\n<li>Verify intended effects were recorded (e.g., fault injection commands logged)</li>\n<li>Verify no unintended side effects occurred</li>\n<li>Cleanup test environment</li>\n</ol>\n<h4 id=\"chaos-testing-the-chaos-platform\">Chaos Testing the Chaos Platform</h4>\n<p>A self-referential but valuable approach: we can apply chaos engineering principles to the platform itself. This &quot;meta-chaos&quot; testing verifies the platform&#39;s resilience to its own failures:</p>\n<ol>\n<li><strong>Network Chaos During Experiments</strong>: Inject packet loss between the <code>Orchestrator</code> and <code>FaultInjector</code> while an experiment is running.</li>\n<li><strong>Process Kill of Platform Components</strong>: Terminate the <code>SafetyMonitor</code> during fault injection to verify fail-safe behavior.</li>\n<li><strong>Resource Exhaustion of Platform</strong>: Stress CPU/memory while the platform manages multiple experiments.</li>\n</ol>\n<p>These tests validate that the platform&#39;s safety mechanisms (like the <code>CleanupEnsurer</code> with its write-ahead log) work correctly even when the platform itself is under stress.</p>\n<h3 id=\"milestone-implementation-checkpoints\">Milestone Implementation Checkpoints</h3>\n<p>Each milestone has specific acceptance criteria that translate into verifiable implementation checkpoints. The following tables provide concrete commands to run and observable behaviors to verify for each milestone. Use these as progress indicators—if a checkpoint fails, revisit the corresponding component design.</p>\n<h4 id=\"milestone-1-fault-injection-framework\">Milestone 1: Fault Injection Framework</h4>\n<p>This milestone establishes the foundation: the ability to inject controlled faults. Verification focuses on both the positive case (faults apply correctly) and the safety case (faults clean up completely).</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Command</th>\n<th>Expected Observable Behavior</th>\n<th>What to Check If Failing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Latency Injection</strong></td>\n<td><code>go test ./pkg/fault -run TestLatencyFault -v</code></td>\n<td>Test passes. If run with root privileges on Linux, you can manually verify with <code>tc qdisc show dev lo</code> that netem rules appear and disappear.</td>\n<td>- Check <code>CAP_NET_ADMIN</code> capability<br>- Verify <code>tc</code> command is available in PATH<br>- Confirm network interface exists</td>\n</tr>\n<tr>\n<td><strong>Packet Loss Simulation</strong></td>\n<td><code>go test ./pkg/fault -run TestPacketLossFault -v</code></td>\n<td>Test passes. Packet loss rules apply and clean up. Use <code>ping -c 100 127.0.0.1</code> during test to observe actual packet loss.</td>\n<td>- Same as latency plus iptables permissions<br>- Check for conflicting firewall rules</td>\n</tr>\n<tr>\n<td><strong>Process Kill Fault</strong></td>\n<td><code>go test ./pkg/fault -run TestProcessKill -v</code></td>\n<td>Test passes. A test process (e.g., <code>sleep 3600</code>) is started, killed, and optionally restarted. Process monitor shows lifecycle.</td>\n<td>- Process PID tracking<br>- Signal permissions (SIGTERM vs SIGKILL)<br>- Orphaned child processes</td>\n</tr>\n<tr>\n<td><strong>CPU Stress Fault</strong></td>\n<td><code>go test ./pkg/fault -run TestCPUStress -v</code></td>\n<td>Test passes. CPU utilization spikes in controlled cgroup. Use <code>top</code> or <code>mpstat 1</code> to observe load during test.</td>\n<td>- Cgroup filesystem mounted<br>- <code>stress-ng</code> or similar tool available<br>- CPU quota correctly calculated</td>\n</tr>\n<tr>\n<td><strong>Memory Stress Fault</strong></td>\n<td><code>go test ./pkg/fault -run TestMemoryStress -v</code></td>\n<td>Test passes. Memory usage increases within limits. Monitor with <code>free -m</code> or cgroup memory stats.</td>\n<td>- Memory cgroup enabled<br>- Overcommit settings<br>- Swap interference</td>\n</tr>\n<tr>\n<td><strong>Fault Reversibility Property</strong></td>\n<td><code>go test ./pkg/fault -run TestFaultReversibility -v</code></td>\n<td>Property test passes for all fault types. Generates 100 random fault configurations, injects and cleans each, verifying original state restored.</td>\n<td>- State comparison logic<br>- Timing issues with async cleanup<br>- Resource leakage detection</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-2-experiment-orchestration\">Milestone 2: Experiment Orchestration</h4>\n<p>This milestone introduces the experiment lifecycle with safety controls. Verification requires simulating the full experiment flow with mocked dependencies.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Command</th>\n<th>Expected Observable Behavior</th>\n<th>What to Check If Failing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Experiment Creation &amp; Validation</strong></td>\n<td><code>go test ./pkg/experiment -run TestCreateExperiment -v</code></td>\n<td>Test passes. Valid experiments are accepted; invalid ones (missing hypothesis, zero duration) return descriptive errors.</td>\n<td>- Validation logic completeness<br>- JSON/YAML parsing<br>- Required field checking</td>\n</tr>\n<tr>\n<td><strong>Steady-State Hypothesis Validation</strong></td>\n<td><code>go test ./pkg/experiment -run TestValidateHypothesis -v</code></td>\n<td>Test passes. Mock metrics collector returns controlled data; hypothesis passes or fails as expected.</td>\n<td>- Metric query formatting<br>- Threshold comparison logic<br>- Time window handling</td>\n</tr>\n<tr>\n<td><strong>Experiment State Machine</strong></td>\n<td><code>go test ./pkg/experiment -run TestExperimentStateMachine -v</code></td>\n<td>Test passes. Experiment transitions through all states: <code>DRAFT</code> → <code>BASELINE_VALIDATION</code> → <code>INJECTING</code> → <code>MONITORING</code> → <code>ANALYSIS</code> → <code>COMPLETED</code>.</td>\n<td>- State transition triggers<br>- Concurrent access protection<br>- Context cancellation propagation</td>\n</tr>\n<tr>\n<td><strong>Safety-Triggered Abort</strong></td>\n<td><code>go test ./pkg/experiment -run TestSafetyAbort -v</code></td>\n<td>Test passes. When simulated error rate exceeds 5%, experiment transitions to <code>ABORTED</code>, all faults are cleaned up, abort reason recorded.</td>\n<td>- Safety monitor polling interval<br>- Metric aggregation window<br>- Rollback coordination timing</td>\n</tr>\n<tr>\n<td><strong>Cleanup After Crash</strong></td>\n<td><code>go test ./pkg/experiment -run TestCrashRecovery -v</code></td>\n<td>Test passes. Simulate platform crash (kill -9), restart, verify <code>RecoverOrphanedFaults()</code> finds and cleans up active faults from WAL.</td>\n<td>- WAL entry durability (fsync)<br>- Fault state serialization<br>- Idempotent cleanup commands</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-3-gameday-automation\">Milestone 3: GameDay Automation</h4>\n<p>GameDay automation coordinates multiple experiments. Verification requires testing scenario sequencing, pause/resume functionality, and report generation.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Command</th>\n<th>Expected Observable Behavior</th>\n<th>What to Check If Failing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Scenario Loading &amp; Parsing</strong></td>\n<td><code>go test ./pkg/gameday -run TestLoadScenario -v</code></td>\n<td>Test passes. YAML scenario file loads into <code>Scenario</code> struct with all steps, approvals, and briefing.</td>\n<td>- YAML structure mapping<br>- Nested object parsing<br>- Validation of required fields</td>\n</tr>\n<tr>\n<td><strong>Scenario Step Execution</strong></td>\n<td><code>go test ./pkg/gameday -run TestExecuteScenario -v</code></td>\n<td>Test passes. Scenario executes steps in sequence: experiment, pause, manual task, inject. Progress tracked in <code>scenarioInstance</code>.</td>\n<td>- Step type switching logic<br>- Timing of pauses<br>- State persistence between steps</td>\n</tr>\n<tr>\n<td><strong>Manual Approval Flow</strong></td>\n<td><code>go test ./pkg/gameday -run TestManualApproval -v</code></td>\n<td>Test passes. Scenario pauses at step with <code>RequiresApproval: true</code>, waits for <code>ApproveStep()</code>, then continues.</td>\n<td>- Approval timeout handling<br>- Multiple observer coordination<br>- Approval state persistence</td>\n</tr>\n<tr>\n<td><strong>GameDay Report Generation</strong></td>\n<td><code>go test ./pkg/gameday -run TestGenerateReport -v</code></td>\n<td>Test passes. Report includes experiment results, observer observations, timing data, and overall success/failure determination.</td>\n<td>- Data aggregation from multiple experiments<br>- Report formatting<br>- Observation correlation</td>\n</tr>\n<tr>\n<td><strong>Scenario Abort &amp; Rollback</strong></td>\n<td><code>go test ./pkg/gameday -run TestScenarioAbort -v</code></td>\n<td>Test passes. Aborting scenario midway rolls back active experiments, records reason, moves to <code>ABORTED</code> state.</td>\n<td>- Nested experiment cleanup<br>- Partial rollback handling<br>- State consistency</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-4-steady-state-hypothesis-amp-metrics-validation\">Milestone 4: Steady-State Hypothesis &amp; Metrics Validation</h4>\n<p>This milestone focuses on statistical validation of system behavior. Verification requires sophisticated metric collection and analysis.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Command</th>\n<th>Expected Observable Behavior</th>\n<th>What to Check If Failing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Hypothesis DSL Parsing</strong></td>\n<td><code>go test ./pkg/hypothesis -run TestParseHypothesis -v</code></td>\n<td>Test passes. Natural language hypothesis (&quot;error rate &lt; 1% for 5 minutes&quot;) parses to <code>Hypothesis</code> with proper <code>MetricThreshold</code> values.</td>\n<td>- DSL grammar completeness<br>- Time duration parsing<br>- Comparative operator support</td>\n</tr>\n<tr>\n<td><strong>Metric Threshold Validation</strong></td>\n<td><code>go test ./pkg/metrics -run TestValidateThreshold -v</code></td>\n<td>Test passes. Given time-series data, correctly determines if metric stayed within threshold for required duration.</td>\n<td>- Sliding window calculation<br>- Missing data handling<br>- Boundary condition logic</td>\n</tr>\n<tr>\n<td><strong>Statistical Significance Testing</strong></td>\n<td><code>go test ./pkg/experiment -run TestStatisticalValidation -v</code></td>\n<td>Test passes. Compares experiment group metrics to control group using t-test, correctly identifies significant deviations.</td>\n<td>- Sample size calculation<br>- Variance handling<br>- P-value interpretation</td>\n</tr>\n<tr>\n<td><strong>Blast Radius Enforcement</strong></td>\n<td><code>go test ./pkg/experiment -run TestBlastRadius -v</code></td>\n<td>Test passes. When blast radius is 30%, faults affect approximately 30% of target population, not 100%.</td>\n<td>- Random selection algorithm<br>- Seed management for reproducibility<br>- Population counting</td>\n</tr>\n<tr>\n<td><strong>Metric Collection During Chaos</strong></td>\n<td><code>go test ./pkg/metrics -run TestCollectionDuringChaos -v</code></td>\n<td>Test passes. While network latency fault is active, metrics collector continues gathering data without gaps.</td>\n<td>- Collector resilience to faults<br>- Retry logic with backoff<br>- Metric timestamp accuracy</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-5-network-chaos-amp-infrastructure-faults\">Milestone 5: Network Chaos &amp; Infrastructure Faults</h4>\n<p>Advanced fault types require careful testing due to their potential for system-wide impact. Verification emphasizes containment and reversibility.</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Command</th>\n<th>Expected Observable Behavior</th>\n<th>What to Check If Failing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Network Partition Simulation</strong></td>\n<td><code>sudo go test ./pkg/fault -run TestNetworkPartition -v</code></td>\n<td>Test passes. iptables rules isolate two containers; ping fails during partition, succeeds after cleanup.</td>\n<td>- iptables chain management<br>- Rule collision avoidance<br>- Dual-direction blocking</td>\n</tr>\n<tr>\n<td><strong>DNS Failure Injection</strong></td>\n<td><code>go test ./pkg/fault -run TestDNSFault -v</code></td>\n<td>Test passes. DNS resolution fails (NXDOMAIN, timeout) for targeted domains, other domains unaffected.</td>\n<td>- /etc/resolv.conf modification<br>- Local DNS server management<br>- DNS cache interference</td>\n</tr>\n<tr>\n<td><strong>Disk Full Simulation</strong></td>\n<td><code>sudo go test ./pkg/fault -run TestDiskFull -v</code></td>\n<td>Test passes. Filesystem usage increases to specified percentage, write operations fail appropriately, cleanup restores space.</td>\n<td>- Filesystem monitoring<br>- dd/mkfile operations<br>- inode exhaustion cases</td>\n</tr>\n<tr>\n<td><strong>OOM Killer Simulation</strong></td>\n<td><code>sudo go test ./pkg/fault -run TestOOMFault -v</code></td>\n<td>Test passes. Memory pressure triggers OOM killer, targeted process dies, memory usage returns to normal after cleanup.</td>\n<td>- Memory cgroup configuration<br>- OOM score adjustment<br>- Process selection algorithm</td>\n</tr>\n<tr>\n<td><strong>Bandwidth Throttling</strong></td>\n<td><code>sudo go test ./pkg/fault -run TestBandwidthThrottle -v</code></td>\n<td>Test passes. Network throughput limited to specified rate, verified with iperf3, cleanup restores full bandwidth.</td>\n<td>- tc htb configuration<br>- Burst parameter calculation<br>- Interface selection logic</td>\n</tr>\n</tbody></table>\n<h4 id=\"cross-milestone-integration-verification\">Cross-Milestone Integration Verification</h4>\n<p>After implementing multiple milestones, run integration tests that span component boundaries:</p>\n<table>\n<thead>\n<tr>\n<th>Checkpoint</th>\n<th>Verification Command</th>\n<th>Expected Observable Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Full Experiment Lifecycle</strong></td>\n<td><code>go test ./integration -run TestFullExperimentLifecycle -v</code></td>\n<td>Complete experiment with hypothesis, faults, safety rules executes successfully from start to report generation.</td>\n</tr>\n<tr>\n<td><strong>GameDay with Real Faults</strong></td>\n<td><code>sudo go test ./integration -run TestGameDayRealFaults -v</code></td>\n<td>GameDay scenario executes multiple experiments with actual (not mocked) fault injection in isolated containers.</td>\n</tr>\n<tr>\n<td><strong>Platform Resilience</strong></td>\n<td><code>go test ./integration -run TestPlatformResilience -v</code></td>\n<td>Platform continues operating correctly when subjected to network latency, packet loss, and process kills.</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-testing-chaos-code\">Common Pitfalls in Testing Chaos Code</h3>\n<p>Testing code that injects failures presents unique challenges. Avoid these common mistakes:</p>\n<p>⚠️ <strong>Pitfall: Testing with Insufficient Isolation</strong></p>\n<ul>\n<li><strong>Description</strong>: Running fault injection tests that affect the host machine or shared development environment.</li>\n<li><strong>Why it&#39;s wrong</strong>: Network faults can disrupt other developers&#39; work; process kills can terminate important services; resource exhaustion can crash the test runner itself.</li>\n<li><strong>How to fix</strong>: Always use containerized test environments (Docker containers with resource limits) and network namespaces. Mock dangerous operations in unit tests, reserving real injection for carefully isolated integration tests.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Assuming Cleanup Always Succeeds</strong></p>\n<ul>\n<li><strong>Description</strong>: Writing tests that only verify fault injection works, without verifying cleanup restores the original state.</li>\n<li><strong>Why it&#39;s wrong</strong>: In production, failed cleanup leaves systems permanently impaired—the exact opposite of chaos engineering&#39;s safety goals.</li>\n<li><strong>How to fix</strong>: Every fault injection test must include a cleanup verification phase. Use property-based testing to ensure reversibility holds for all parameter combinations.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Timing and Race Conditions</strong></p>\n<ul>\n<li><strong>Description</strong>: Writing synchronous tests for inherently asynchronous operations (fault application, metric collection, safety monitoring).</li>\n<li><strong>Why it&#39;s wrong</strong>: Real-world execution involves delays: tc rules take milliseconds to apply, metrics have collection latency, safety checks run on intervals.</li>\n<li><strong>How to fix</strong>: Use eventual consistency patterns in tests: poll for expected state with timeout. Test race conditions explicitly by injecting delays at synchronization points.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Over-Mocking Dependencies</strong></p>\n<ul>\n<li><strong>Description</strong>: Mocking so many dependencies that the test verifies nothing about real interactions.</li>\n<li><strong>Why it&#39;s wrong</strong>: A test that passes with mocks may fail in production because the mocked component behaved differently than the real one.</li>\n<li><strong>How to fix</strong>: Follow the testing pyramid: unit tests with mocks for logic, integration tests with real components (in containers), end-to-end tests with minimal mocking.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Testing the Failure Modes of the Platform Itself</strong></p>\n<ul>\n<li><strong>Description</strong>: Only testing the sunny-day path where the platform works perfectly.</li>\n<li><strong>Why it&#39;s wrong</strong>: The platform must handle its own failures gracefully—network partitions between orchestrator and agents, agent crashes, metric collection failures.</li>\n<li><strong>How to fix</strong>: Implement chaos tests for the platform itself. Test recovery from crashes, network isolation, and resource exhaustion.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Easier to Implement)</th>\n<th>Advanced Option (More Production-Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unit Testing</strong></td>\n<td>Go&#39;s built-in <code>testing</code> package with table-driven tests</td>\n<td>Same plus testify/suite for structure</td>\n</tr>\n<tr>\n<td><strong>Property Testing</strong></td>\n<td>Manual example generation</td>\n<td><code>gopter</code> for automatic generation and shrinking</td>\n</tr>\n<tr>\n<td><strong>Mocking</strong></td>\n<td>Manual interface implementations</td>\n<td><code>gomock</code> or <code>mockery</code> for generated mocks</td>\n</tr>\n<tr>\n<td><strong>Integration Environment</strong></td>\n<td>Local processes with mocked system calls</td>\n<td>Docker containers with actual fault injection</td>\n</tr>\n<tr>\n<td><strong>Metrics Collection</strong></td>\n<td>Mock metrics returning fixed values</td>\n<td>Actual Prometheus queries to test instance</td>\n</tr>\n<tr>\n<td><strong>Test Containers</strong></td>\n<td>Manual container management with Docker CLI</td>\n<td><code>testcontainers-go</code> for programmatic control</td>\n</tr>\n<tr>\n<td><strong>Coverage Analysis</strong></td>\n<td><code>go test -cover</code></td>\n<td><code>go test -coverprofile</code> + HTML visualization</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure-for-tests\">B. Recommended File/Module Structure for Tests</h4>\n<p>Organize tests alongside implementation code following Go conventions:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── pkg/\n│   ├── fault/\n│   │   ├── fault.go              # Core fault types and interfaces\n│   │   ├── fault_test.go         # Unit tests for fault logic\n│   │   ├── injector/\n│   │   │   ├── injector.go       # Fault injection implementation\n│   │   │   ├── injector_test.go  # Unit tests (mocked)\n│   │   │   └── injector_it.go    # Integration tests (requires root)\n│   │   └── property/\n│   │       └── reversibility_test.go  # Property-based tests\n│   ├── experiment/\n│   │   ├── orchestrator.go\n│   │   ├── orchestrator_test.go\n│   │   ├── hypothesis/\n│   │   │   ├── validator.go\n│   │   │   └── validator_test.go\n│   │   └── safety/\n│   │       ├── monitor.go\n│   │       └── monitor_test.go\n│   ├── gameday/\n│   │   ├── controller.go\n│   │   ├── controller_test.go\n│   │   └── scenarios/\n│   │       ├── parser.go\n│   │       └── parser_test.go\n│   └── metrics/\n│       ├── collector.go\n│       ├── collector_test.go\n│       └── prometheus/\n│           ├── client.go\n│           └── client_test.go\n├── integration/\n│   ├── experiment_lifecycle_test.go  # Cross-component tests\n│   ├── gameday_scenario_test.go\n│   └── Dockerfile.test               # Test container definition\n└── cmd/\n    └── chaos-agent/\n        ├── main.go\n        └── main_test.go</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-test-helper-for-root-required-tests\">C. Infrastructure Starter Code: Test Helper for Root-Required Tests</h4>\n<p>Create a test helper that safely skips tests requiring root privileges or specific kernel capabilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/testutils/root_check.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> testutils</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SkipIfNotRoot skips the test if not running as root on Linux</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SkipIfNotRoot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Helper</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> runtime.GOOS </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"linux\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test requires Linux\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Geteuid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Test requires root privileges (CAP_NET_ADMIN for network faults)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SkipIfNoTC skips if tc command not available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SkipIfNoTC</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Helper</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> exec.</span><span style=\"color:#B392F0\">LookPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tc\"</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tc command not available in PATH\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SkipIfNoCgroup skips if cgroup filesystem not mounted</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SkipIfNoCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">subsystem</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Helper</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    path </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/fs/cgroup/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, subsystem)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(path); os.</span><span style=\"color:#B392F0\">IsNotExist</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Skipf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cgroup subsystem </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> not available at </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, subsystem, path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-property-based-test-for-fault-reversibility\">D. Core Logic Skeleton: Property-Based Test for Fault Reversibility</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/fault/property/reversibility_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> property</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter/gen</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/leanovate/gopter/prop</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/fault</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// faultGenerator creates random Fault instances for property testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> faultGenerator</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">gopter</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Gen</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> gen.</span><span style=\"color:#B392F0\">Struct</span><span style=\"color:#E1E4E8\">(reflect.</span><span style=\"color:#B392F0\">TypeOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">{}), </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">gopter</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Gen</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Type\"</span><span style=\"color:#E1E4E8\">: gen.</span><span style=\"color:#B392F0\">OneConst</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fault.FaultTypeLatency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fault.FaultTypePacketLoss,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fault.FaultTypeProcessKill,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fault.FaultTypeCPUStress,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fault.FaultTypeMemoryStress,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Target\"</span><span style=\"color:#E1E4E8\">: gen.</span><span style=\"color:#B392F0\">Struct</span><span style=\"color:#E1E4E8\">(reflect.</span><span style=\"color:#B392F0\">TypeOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Target</span><span style=\"color:#E1E4E8\">{}), </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">gopter</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Gen</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Type\"</span><span style=\"color:#E1E4E8\">:     gen.</span><span style=\"color:#B392F0\">Const</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pod\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Selector\"</span><span style=\"color:#E1E4E8\">: gen.</span><span style=\"color:#B392F0\">MapOf</span><span style=\"color:#E1E4E8\">(gen.</span><span style=\"color:#B392F0\">AlphaString</span><span style=\"color:#E1E4E8\">(), gen.</span><span style=\"color:#B392F0\">AlphaString</span><span style=\"color:#E1E4E8\">()),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Count\"</span><span style=\"color:#E1E4E8\">:    gen.</span><span style=\"color:#B392F0\">IntRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Parameters\"</span><span style=\"color:#E1E4E8\">: gen.</span><span style=\"color:#B392F0\">MapOf</span><span style=\"color:#E1E4E8\">(gen.</span><span style=\"color:#B392F0\">AlphaString</span><span style=\"color:#E1E4E8\">(), gen.</span><span style=\"color:#B392F0\">AlphaString</span><span style=\"color:#E1E4E8\">()),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestFaultReversibility</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gopter.</span><span style=\"color:#B392F0\">DefaultTestParameters</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters.MinSuccessfulTests </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#6A737D\">  // Test 100 random fault configurations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters.MaxDiscardRatio </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#6A737D\">      // Allow some generated faults to be invalid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> gopter.</span><span style=\"color:#B392F0\">NewProperties</span><span style=\"color:#E1E4E8\">(parameters)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">Property</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"All faults are reversible\"</span><span style=\"color:#E1E4E8\">, prop.</span><span style=\"color:#B392F0\">ForAll</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">originalFault</span><span style=\"color:#B392F0\"> fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Create a test environment snapshot (baseline state)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Record network configuration (tc rules, iptables)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Record process list and states</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Record resource usage (CPU, memory, disk)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Validate the fault parameters are injectable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Skip invalid configurations (return true to discard)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - For network faults, ensure target interface exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - For process faults, ensure test process exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Inject the fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Use fault injector with test mode enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Capture any error during injection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Verify fault is active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Check tc rules for network faults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Check process status for process kill</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Check cgroup limits for resource faults</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Clean up the fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Call CleanupFault with the fault ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Verify cleanup command succeeds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 6: Compare system state to baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Network configuration should match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Process states should match (except temporary test processes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Resource limits should be removed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 7: Return true if state matches baseline, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Include detailed diagnostic information in error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        faultGenerator</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    properties.</span><span style=\"color:#B392F0\">TestingRun</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-for-go-testing\">E. Language-Specific Hints for Go Testing</h4>\n<ol>\n<li><strong>Use <code>t.Cleanup()</code> for reliable test teardown</strong>: Register cleanup functions that run even if the test fails.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestNetworkFault</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       cleanup </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> setupTestNetwork</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       t.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">(cleanup)  </span><span style=\"color:#6A737D\">// Guaranteed to run</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Test logic (even if this panics, cleanup runs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Test main functions with <code>TestMain</code></strong>: Use <code>TestMain</code> for global setup/teardown:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestMain</span><span style=\"color:#E1E4E8\">(m </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.M) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Global setup (start Docker daemon, create test network)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       code </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Global teardown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Parallelize independent tests</strong>: Use <code>t.Parallel()</code> for tests without shared state:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestIndependentFeature</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       t.</span><span style=\"color:#B392F0\">Parallel</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\">// Runs concurrently with other parallel tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">       // Test logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Use table-driven tests for parameter variations</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> TestFaultValidation</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">testing.T) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       testCases </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           name </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           fault </span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           expectError </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           {</span><span style=\"color:#9ECBFF\">\"valid latency\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">{Type: fault.FaultTypeLatency, </span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           {</span><span style=\"color:#9ECBFF\">\"missing target\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">fault</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">{Type: fault.FaultTypeLatency, </span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> testCases {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tc.name, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tc.fault.</span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               if</span><span style=\"color:#E1E4E8\"> tc.expectError </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   t.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"expected error but got none\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">               // ... more assertions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint-commands-summary\">F. Milestone Checkpoint Commands Summary</h4>\n<p>Create a <code>Makefile</code> with checkpoint verification targets:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code>.PHONY: checkpoint-m1 checkpoint-m2 checkpoint-m3 checkpoint-m4 checkpoint-m5\n\ncheckpoint-m1:  # Milestone 1: Fault Injection Framework\n\tgo test ./pkg/fault -run &quot;TestLatencyFault|TestPacketLossFault|TestProcessKill|TestCPUStress|TestMemoryStress&quot; -v\n\tsudo go test ./pkg/fault -run TestFaultReversibility -v 2&gt;/dev/null || echo &quot;Note: Property test may require root&quot;\n\ncheckpoint-m2:  # Milestone 2: Experiment Orchestration\n\tgo test ./pkg/experiment -run &quot;TestCreateExperiment|TestValidateHypothesis|TestExperimentStateMachine|TestSafetyAbort|TestCrashRecovery&quot; -v\n\ncheckpoint-m3:  # Milestone 3: GameDay Automation\n\tgo test ./pkg/gameday -run &quot;TestLoadScenario|TestExecuteScenario|TestManualApproval|TestGenerateReport|TestScenarioAbort&quot; -v\n\ncheckpoint-m4:  # Milestone 4: Steady-State Hypothesis\n\tgo test ./pkg/hypothesis -run TestParseHypothesis -v\n\tgo test ./pkg/metrics -run TestValidateThreshold -v\n\tgo test ./pkg/experiment -run &quot;TestStatisticalValidation|TestBlastRadius|TestCollectionDuringChaos&quot; -v\n\ncheckpoint-m5:  # Milestone 5: Network &amp; Infrastructure Faults\n\tsudo go test ./pkg/fault -run &quot;TestNetworkPartition|TestDNSFault|TestDiskFull|TestOOMFault|TestBandwidthThrottle&quot; -v 2&gt;/dev/null || echo &quot;Note: These tests require root and specific kernel features&quot;\n\ncheckpoint-all: checkpoint-m1 checkpoint-m2 checkpoint-m3 checkpoint-m4 checkpoint-m5</code></pre></div>\n\n<h4 id=\"g-debugging-tips-for-failing-tests\">G. Debugging Tips for Failing Tests</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Test passes locally but fails in CI</strong></td>\n<td>Environment differences (missing commands, permissions, kernel features)</td>\n<td>Compare <code>uname -a</code>, <code>which tc</code>, <code>cat /proc/filesystems</code> between environments</td>\n<td>Add prerequisite checks with <code>t.Skip()</code> for missing dependencies</td>\n</tr>\n<tr>\n<td><strong>Network fault test leaves iptables rules</strong></td>\n<td>Cleanup not called due to test panic or early exit</td>\n<td>Check test logs for panic; use <code>sudo iptables -L -n -v</code> after test failure</td>\n<td>Wrap test logic in defer cleanup or use <code>t.Cleanup()</code></td>\n</tr>\n<tr>\n<td><strong>Property test finds counterexample but shrinking fails</strong></td>\n<td>Shrinker doesn&#39;t understand custom generator</td>\n<td>Print the failing case; implement custom shrinker for <code>Fault</code> type</td>\n<td>Implement <code>gopter.Shrinker</code> interface for fault generator</td>\n</tr>\n<tr>\n<td><strong>Race condition in concurrent experiment tests</strong></td>\n<td>Shared state between tests (global variables)</td>\n<td>Run tests with <code>-race</code> flag; look for data race warnings</td>\n<td>Use test-local state, avoid global variables, add mutex protection</td>\n</tr>\n<tr>\n<td><strong>Metrics collection test times out</strong></td>\n<td>Prometheus query takes too long or hangs</td>\n<td>Add query timeout; check Prometheus server logs; mock for unit tests</td>\n<td>Implement context with timeout for metric queries</td>\n</tr>\n<tr>\n<td><strong>Containerized test leaves dangling containers</strong></td>\n<td>Test doesn&#39;t clean up containers on failure</td>\n<td>Check Docker with <code>docker ps -a</code> after test; look for containers with test labels</td>\n<td>Use <code>testcontainers-go</code> which auto-cleans, or defer <code>container.Remove()</code></td>\n</tr>\n<tr>\n<td><strong>Root-required test skipped even as root</strong></td>\n<td>Effective vs real UID mismatch (sudo vs su)</td>\n<td>Print <code>os.Geteuid()</code> and <code>os.Getuid()</code> in test setup</td>\n<td>Use <code>sudo</code> with preserved environment: <code>sudo -E go test</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Final Testing Principle</strong>: The chaos platform must be <strong>more thoroughly tested than the systems it tests</strong>. Every line of code that injects failures should have corresponding tests that verify it can be safely reverted. This rigorous testing discipline transforms the platform from a potential source of outages into a reliable tool for building resilience.</p>\n</blockquote>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (debugging is a cross-cutting concern for the entire platform)</p>\n</blockquote>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<p>Building a chaos engineering platform involves complex interactions between network manipulation, system calls, state machines, and distributed coordination. When things go wrong, the platform itself—designed to inject failures—must be debuggable. This section provides a structured approach to diagnosing common issues, organized as a symptom-cause-fix reference manual for developers building the platform.</p>\n<h3 id=\"mental-model-the-chaos-platform39s-own-flight-recorder\">Mental Model: The Chaos Platform&#39;s Own Flight Recorder</h3>\n<p>Think of debugging this system as investigating an <strong>aircraft incident</strong>. The chaos platform has its own &quot;flight recorders&quot; (logs, metrics, and audit trails) that capture every action taken. When a fault injection fails or an experiment behaves unexpectedly, you need to:</p>\n<ol>\n<li><strong>Check the black box</strong> (the platform&#39;s own observability data)</li>\n<li><strong>Reconstruct the sequence of events</strong> (what commands were issued in what order)</li>\n<li><strong>Verify the actual system state</strong> (what actually happened versus what was supposed to happen)</li>\n<li><strong>Test the control mechanisms</strong> (are the platform&#39;s own safety systems working?)</li>\n</ol>\n<p>The debugging approach follows this investigative pattern, moving from observable symptoms to root causes.</p>\n<h3 id=\"common-bug-patterns\">Common Bug Patterns</h3>\n<p>The following table categorizes the most frequent issues encountered during platform development, organized by symptom area. Each entry provides diagnostic steps to isolate the cause and recommended fixes.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fault not applied</strong> - The fault definition appears valid but no observable effect occurs on target systems</td>\n<td>1. Insufficient permissions for network manipulation<br>2. Target selector mismatch<br>3. Fault injection agent not running<br>4. Network namespace isolation (containers)<br>5. Timing issue: fault hasn&#39;t propagated yet</td>\n<td>1. Check agent logs for permission errors (<code>CAP_NET_ADMIN</code> missing)<br>2. Verify target selector matches actual pods/services: <code>kubectl get pods -l app=target-app</code><br>3. Confirm agent process is running: `ps aux</td>\n<td>grep chaos-agent<code>&lt;br&gt;4. Check if target is in container: </code>docker exec -it container_id ip addr show<code>&lt;br&gt;5. Wait 5-10 seconds, then verify fault status via </code>GetFaultStatus()`</td>\n</tr>\n<tr>\n<td><strong>Fault cleanup fails</strong> - Fault remains active after experiment completion or manual rollback</td>\n<td>1. Cleanup command malformed or incorrect<br>2. Agent crash during cleanup phase<br>3. Network isolation prevents cleanup commands from reaching target<br>4. State inconsistency: fault already cleaned up but status not updated<br>5. Orphaned resources from previous crashed experiment</td>\n<td>1. Examine <code>FaultRecord.CleanupCmd</code> field in WAL<br>2. Check agent restart logs for recovery attempts<br>3. Verify network connectivity to target during cleanup<br>4. Compare <code>FaultState</code> with actual system state<br>5. Run <code>RecoverOrphanedFaults()</code> on platform startup</td>\n<td>1. Use idempotent cleanup commands that can run multiple times<br>2. Implement <code>CleanupEnsurer</code> with persistent WAL<br>3. Test cleanup path during fault validation<br>4. Add state verification before marking cleanup complete<br>5. Schedule periodic orphaned resource scans</td>\n</tr>\n<tr>\n<td><strong>Safety monitor fails to trigger auto-rollback</strong> despite metric breaches</td>\n<td>1. Metric collection lag or sampling interval too long<br>2. Safety rule threshold incorrectly specified<br>3. Metric query returns no data or wrong data<br>4. Safety monitor component crashed or stuck<br>5. Race condition: fault injected after safety check passed</td>\n<td>1. Check metric timestamps vs. current time (lag &gt; 30s indicates problem)<br>2. Validate <code>SafetyRule.Condition</code> syntax and threshold values<br>3. Test metric query directly against metrics backend<br>4. Verify safety monitor heartbeat and health status<br>5. Examine event timestamps in <code>ExperimentResult.SafetyEvents</code></td>\n<td>1. Reduce metric collection interval during experiments<br>2. Add syntax validation for safety rules during experiment creation<br>3. Implement metric query validation and fallback values<br>4. Add dead man&#39;s switch with <code>MetricsChecker.heartbeatQuery</code><br>5. Implement sliding window checks instead of single-point evaluations</td>\n</tr>\n<tr>\n<td><strong>Experiment hangs in BASELINE_VALIDATION state</strong> indefinitely</td>\n<td>1. Hypothesis validation timeout too long<br>2. Metric thresholds impossible to meet (system never in steady state)<br>3. Metrics collector unreachable or returning errors<br>4. Validation algorithm deadlock or infinite loop<br>5. Missing metric data for required time period</td>\n<td>1. Check <code>validateBaseline</code> function timeout configuration<br>2. Examine <code>Hypothesis.Metrics</code> thresholds vs. actual system capability<br>3. Test metrics collector connectivity: <code>GetCurrentValue(&quot;up&quot;)</code><br>4. Check for mutex deadlocks in validation logic<br>5. Verify metric exists and has data for required <code>Duration</code></td>\n<td>1. Implement configurable timeout with default (e.g., 2 minutes)<br>2. Add baseline validation threshold adjustment or warning system<br>3. Implement retry with exponential backoff for metric queries<br>4. Use timeout contexts for all validation operations<br>5. Add pre-flight check for metric availability before experiment start</td>\n</tr>\n<tr>\n<td><strong>Network chaos affects chaos tool itself</strong> - Platform becomes unreachable during network partition experiments</td>\n<td>1. Blast radius includes chaos platform components<br>2. Network fault applied indiscriminately to all traffic<br>3. Agent running on same node as target without isolation<br>4. Platform uses same network path as target traffic</td>\n<td>1. Check <code>BlastRadius.Services</code> excludes chaos platform services<br>2. Verify <code>Target.Selector</code> specificity (not matching everything)<br>3. Check if agent and target share network namespace<br>4. Test network partition with <code>iptables -L</code> to see affected IP ranges</td>\n<td>1. Always exclude chaos platform from blast radius by default<br>2. Use precise iptables rules targeting specific IP:port combinations<br>3. Run chaos agents on dedicated nodes or with network isolation<br>4. Implement control plane traffic over separate network interface</td>\n</tr>\n<tr>\n<td><strong>Scenario pauses but manual approval not requested</strong> - GameDay automation halts unexpectedly</td>\n<td>1. <code>ScenarioStep.RequiresApproval</code> incorrectly set<br>2. Approval gate timeout expired without action<br>3. Observer notification mechanism failed<br>4. Scenario state machine incorrectly transitioned<br>5. Concurrent modification of scenario state</td>\n<td>1. Check step definition in <code>Scenario.Steps[CurrentStep]</code><br>2. Verify <code>AutoProceedAfter</code> duration and timer logic<br>3. Test notification system (webhook, email, chat integration)<br>4. Examine scenario state transitions in logs<br>5. Check for race conditions in <code>PauseScenario</code>/<code>ResumeScenario</code></td>\n<td>1. Add validation for approval step configuration<br>2. Implement approval timeout logging and alerting<br>3. Add redundant notification channels and confirmation receipts<br>4. Use state machine with proper transition guards<br>5. Add mutex protection for <code>scenarioInstance</code> modifications</td>\n</tr>\n<tr>\n<td><strong>Metrics show no change during fault injection</strong> despite expected impact</td>\n<td>1. Fault not actually applied (see first symptom)<br>2. Wrong metrics being monitored for this fault type<br>3. System has redundancy that masks the fault<br>4. Fault parameters too weak (e.g., 5ms latency on 500ms baseline)<br>5. Metrics aggregation hides short-term spikes</td>\n<td>1. Confirm fault is active via <code>GetFaultStatus()</code> and system checks<br>2. Verify metric queries align with expected fault impact<br>3. Check if load balancer routes around faulty instance<br>4. Compare fault parameters with baseline measurements<br>5. Reduce metrics aggregation window or use higher resolution</td>\n<td>1. Add fault effectiveness verification (pre/post metrics comparison)<br>2. Include recommended metrics in fault type documentation<br>3. Test with single instance or disable redundancy temporarily<br>4. Scale fault parameters based on baseline measurements<br>5. Configure high-resolution metrics collection during experiments</td>\n</tr>\n<tr>\n<td><strong>CPU/Memory stress faults cause agent OOM kill or high CPU</strong></td>\n<td>1. Stress tool not isolated from agent process<br>2. Memory limits not set on stress process<br>3. Agent shares cgroup with stress process<br>4. Cleanup fails to terminate stress processes</td>\n<td>1. Check if agent memory usage increases during stress fault<br>2. Verify stress processes are in separate cgroup<br>3. Examine process tree: <code>pstree -p agent_pid</code><br>4. Check for zombie stress processes after cleanup</td>\n<td>1. Run stress tools in separate containers or cgroups<br>2. Set memory limits on stress processes<br>3. Use process namespace isolation<br>4. Implement double-kill with SIGKILL after SIGTERM timeout</td>\n</tr>\n<tr>\n<td><strong>Experiment results show &quot;PASS&quot; despite obvious system degradation</strong></td>\n<td>1. Hypothesis thresholds too lenient<br>2. Validation uses wrong time ranges (before/during/after)<br>3. Statistical test incorrectly applied (e.g., mean vs. P95)<br>4. Results analysis ignores safety breach events<br>5. Bug in <code>validateHypothesis</code> algorithm</td>\n<td>1. Compare metric values against thresholds manually<br>2. Verify <code>MetricSample</code> time ranges cover injection period<br>3. Check which statistic is used in <code>MetricValidationResult</code><br>4. Examine <code>ExperimentResult.SafetyEvents</code> for triggered rules<br>5. Test hypothesis validation with synthetic known data</td>\n<td>1. Add severity levels to hypothesis violations<br>2. Implement time range validation in results generation<br>3. Use appropriate statistics for each metric type<br>4. Include safety breaches in overall experiment result<br>5. Add unit tests for hypothesis validation edge cases</td>\n</tr>\n<tr>\n<td><strong>Platform crashes and loses experiment state on restart</strong></td>\n<td>1. In-memory state not persisted<br>2. WAL not properly fsync&#39;d before acknowledging operations<br>3. State recovery logic incomplete or buggy<br>4. Concurrent writes corrupt state file<br>5. Disk full or permission issues</td>\n<td>1. Check if <code>Experiment</code> objects exist after restart<br>2. Examine WAL file for incomplete records<br>3. Test <code>RecoverOrphanedFaults()</code> function<br>4. Look for file corruption errors in logs<br>5. Check disk space and file permissions</td>\n<td>1. Implement persistent storage for all state<br>2. Use WAL with proper fsync for critical operations<br>3. Complete recovery logic covering all state types<br>4. Use file locking for state file access<br>5. Add disk space monitoring and pre-flight checks</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> The most dangerous bugs in a chaos platform are those that prevent cleanup or auto-rollback. Always test the &quot;undo&quot; path more rigorously than the &quot;do&quot; path. A fault that fails to apply is a missed experiment; a fault that can&#39;t be cleaned up is an actual outage.</p>\n</blockquote>\n<h3 id=\"domain-specific-debugging-techniques\">Domain-Specific Debugging Techniques</h3>\n<p>Chaos engineering platforms interact with system internals in ways that require specialized debugging approaches beyond standard application debugging. These techniques leverage system tools and platform-specific instrumentation.</p>\n<h4 id=\"network-fault-verification\">Network Fault Verification</h4>\n<p>When network faults (latency, packet loss, partition) don&#39;t behave as expected:</p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>Command/Action</th>\n<th>Expected Output</th>\n<th>Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Verify tc rules</strong></td>\n<td><code>tc qdisc show dev eth0</code><br><code>tc class show dev eth0</code></td>\n<td>Lists queueing disciplines with parameters like <code>latency 200ms</code> <code>loss 10%</code></td>\n<td>Rules present = fault applied correctly. Missing rules = injection failed.</td>\n</tr>\n<tr>\n<td><strong>Check iptables for partitions</strong></td>\n<td><code>iptables -L -n -v</code><br><code>iptables -t nat -L -n -v</code></td>\n<td>Shows packet counts matching DROP/REJECT rules between specific IPs</td>\n<td>Packet counts increasing = rule active and traffic being blocked.</td>\n</tr>\n<tr>\n<td><strong>Test connectivity</strong></td>\n<td><code>mtr -r -c 10 target_ip</code><br><code>tcping -p 80 target_ip</code></td>\n<td>Shows latency distribution and packet loss percentages</td>\n<td>Measured values should match fault parameters ± margin.</td>\n</tr>\n<tr>\n<td><strong>Namespace isolation check</strong></td>\n<td><code>ls -la /proc/self/ns/net</code><br><code>nsenter -t pid -n ip addr show</code></td>\n<td>Compare network namespace IDs; view network from target&#39;s perspective</td>\n<td>Different namespace IDs mean container isolation; commands need <code>nsenter</code>.</td>\n</tr>\n</tbody></table>\n<h4 id=\"resource-exhaustion-monitoring\">Resource Exhaustion Monitoring</h4>\n<p>For CPU, memory, and disk stress faults:</p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>Command/Action</th>\n<th>Expected Output</th>\n<th>Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Check cgroup limits</strong></td>\n<td><code>cat /sys/fs/cgroup/cpu/target_cgroup/cpu.cfs_quota_us</code><br><code>cat /sys/fs/cgroup/memory/target_cgroup/memory.limit_in_bytes</code></td>\n<td>Shows configured CPU quota and memory limit</td>\n<td>Values should reflect stress fault parameters.</td>\n</tr>\n<tr>\n<td><strong>Monitor process tree</strong></td>\n<td><code>ps aux --forest</code><br><code>pstree -p agent_pid</code></td>\n<td>Shows parent-child relationships of stress processes</td>\n<td>Stress processes should be child of agent or in separate container.</td>\n</tr>\n<tr>\n<td><strong>Verify resource usage</strong></td>\n<td><code>top -b -n 1 -p target_pid</code><br><code>free -m</code></td>\n<td>Shows CPU% and memory usage of target processes</td>\n<td>Should approach configured utilization levels.</td>\n</tr>\n<tr>\n<td><strong>Check OOM killer logs</strong></td>\n<td><code>dmesg | grep -i oom</code><br><code>journalctl -k | grep -i oom</code></td>\n<td>Shows out-of-memory events and killed processes</td>\n<td>Expected for memory stress tests; verify correct process killed.</td>\n</tr>\n</tbody></table>\n<h4 id=\"platform-internal-state-inspection\">Platform Internal State Inspection</h4>\n<p>Debug the chaos platform&#39;s own state machines and coordination:</p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>Command/Action</th>\n<th>Expected Output</th>\n<th>Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Dump experiment state</strong></td>\n<td>Call <code>GetExperimentStatus()</code> via API or inspect <code>Orchestrator.experiments</code> map</td>\n<td>Returns <code>ExperimentInstance.State</code> and timestamps</td>\n<td>Shows which state machine step is stuck or failed.</td>\n</tr>\n<tr>\n<td><strong>Check WAL for recovery</strong></td>\n<td><code>strings /var/lib/chaos/wal.log | tail -20</code></td>\n<td>Shows recent fault injection/cleanup commands</td>\n<td>Indicates what operations were attempted before crash.</td>\n</tr>\n<tr>\n<td><strong>Verify event flow</strong></td>\n<td>Subscribe to <code>InMemoryPubSub</code> events and log all messages</td>\n<td>Shows event sequence: <code>experiment_started</code> → <code>fault_injecting</code> → etc.</td>\n<td>Missing events indicate broken publish/subscribe.</td>\n</tr>\n<tr>\n<td><strong>Inspect safety metrics</strong></td>\n<td>Call <code>GetCurrentValue()</code> for each safety metric during experiment</td>\n<td>Returns numeric values for error rates, latency, etc.</td>\n<td>Values above thresholds should trigger safety events.</td>\n</tr>\n</tbody></table>\n<h4 id=\"pre-flight-validation-checklist\">Pre-Flight Validation Checklist</h4>\n<p>Before running any experiment, execute these validation steps to catch common configuration issues:</p>\n<ol>\n<li><strong>Target Validation:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Verify target selectors match actual resources</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> pods</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#E1E4E8\"> $SELECTOR </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> tr</span><span style=\"color:#9ECBFF\"> ','</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> $TARGET_IP</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   nc</span><span style=\"color:#79B8FF\"> -zv</span><span style=\"color:#E1E4E8\"> $TARGET_IP $TARGET_PORT</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Permission Validation:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Check for required capabilities</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pidof</span><span style=\"color:#9ECBFF\"> chaos-agent</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#9ECBFF\">/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> Cap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should include CapEff: 0000000000200000 (CAP_NET_ADMIN)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Metric Availability:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Test metric queries return data</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$METRICS_URL</span><span style=\"color:#9ECBFF\">/api/v1/query?query=up\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> '.data.result'</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Cleanup Command Test:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Dry-run cleanup commands to verify syntax</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#E1E4E8\"> $CLEANUP_CMD </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> sh</span><span style=\"color:#79B8FF\"> -n</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Blast Radius Verification:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Ensure platform components are excluded</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> [[ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">$PLATFORM_SERVICE</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> =~</span><span style=\"color:#E1E4E8\"> $BLAST_RADIUS_SERVICES ]]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     echo</span><span style=\"color:#9ECBFF\"> \"ERROR: Platform service included in blast radius\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   fi</span></span></code></pre></div>\n\n<h4 id=\"diagnostic-logging-strategy\">Diagnostic Logging Strategy</h4>\n<p>Add strategic logging to the platform to capture debugging information:</p>\n<table>\n<thead>\n<tr>\n<th>Log Location</th>\n<th>What to Log</th>\n<th>Debugging Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Before fault injection</strong></td>\n<td>Target verification results, permission checks, parameter validation</td>\n<td>Identifies why injection might fail before attempting</td>\n</tr>\n<tr>\n<td><strong>After each system command</strong></td>\n<td>Command executed, stdout, stderr, exit code</td>\n<td>Shows exactly what happened at system level</td>\n</tr>\n<tr>\n<td><strong>State transitions</strong></td>\n<td><code>ExperimentState</code> changes with timestamps and triggering event</td>\n<td>Tracks state machine progress and identifies stuck states</td>\n</tr>\n<tr>\n<td><strong>Metric collection</strong></td>\n<td>Query executed, data points returned, timestamps</td>\n<td>Verifies metrics are being collected correctly</td>\n</tr>\n<tr>\n<td><strong>Safety evaluations</strong></td>\n<td>Rule checked, metric value, threshold, result</td>\n<td>Shows why safety rules did or didn&#39;t trigger</td>\n</tr>\n<tr>\n<td><strong>Cleanup operations</strong></td>\n<td>Cleanup command, success/failure, system state after</td>\n<td>Critical for ensuring fault reversal</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Practice:</strong> Implement a <strong>debug mode</strong> that can be enabled via feature flag or environment variable. When enabled, the platform should log at DEBUG level, capture all system command outputs, and perform extra validation steps. This mode will generate more log data but is essential for diagnosing complex issues during development.</p>\n</blockquote>\n<h4 id=\"time-synchronization-considerations\">Time Synchronization Considerations</h4>\n<p>Many chaos experiments rely on precise timing for:</p>\n<ul>\n<li>Fault duration measurements</li>\n<li>Metric sampling windows</li>\n<li>State machine timeouts</li>\n<li>Scheduled experiment execution</li>\n</ul>\n<p><strong>Problem:</strong> If system clocks drift between the chaos platform components, metrics may be analyzed against wrong time windows, making hypothesis validation unreliable.</p>\n<p><strong>Diagnosis:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check clock drift between components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">date</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#E1E4E8\"> $AGENT_URL</span><span style=\"color:#9ECBFF\">/api/health</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> current_time</span></span></code></pre></div>\n\n<p><strong>Fix:</strong> </p>\n<ol>\n<li>Run NTP daemon on all platform components</li>\n<li>Use monotonic clocks (<code>time.Now()</code> in Go) for duration measurements</li>\n<li>Include timestamp in all cross-component messages</li>\n<li>Allow configurable time tolerance in metric validation (e.g., ±2 seconds)</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Debugging a chaos platform requires building diagnostic capabilities into the platform itself. This guidance provides concrete implementation patterns for the debugging features discussed above.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Diagnostic Logging</strong></td>\n<td>Structured JSON logging with log levels</td>\n<td>Distributed tracing with OpenTelemetry</td>\n</tr>\n<tr>\n<td><strong>Metrics Collection</strong></td>\n<td>Direct Prometheus queries with retries</td>\n<td>Metrics proxy with caching and validation</td>\n</tr>\n<tr>\n<td><strong>System Command Debug</strong></td>\n<td>Log command + stdout/stderr + exit code</td>\n<td>Command execution with timeout and replay capability</td>\n</tr>\n<tr>\n<td><strong>State Inspection</strong></td>\n<td>HTTP endpoints returning JSON state dumps</td>\n<td>Real-time WebSocket stream of state changes</td>\n</tr>\n<tr>\n<td><strong>Pre-flight Checks</strong></td>\n<td>Synchronous validation before experiment start</td>\n<td>Continuous health checks with circuit breakers</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Add debugging utilities to the project structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   ├── chaos-controller/         # Main orchestrator\n│   └── chaos-agent/              # Fault injection agent\n├── internal/\n│   ├── debug/                    # Debugging utilities\n│   │   ├── inspector.go          # State inspection endpoints\n│   │   ├── preflight.go          # Pre-flight validation checks\n│   │   ├── logger.go             # Enhanced structured logging\n│   │   └── diagnostics.go        # Health checks and diagnostics\n│   ├── orchestrator/             # Experiment orchestration\n│   ├── fault/                    # Fault injection\n│   ├── metrics/                  # Metrics collection\n│   └── safety/                   # Safety monitoring\n├── pkg/\n│   └── types/                    # Shared types (Experiment, Fault, etc.)\n└── tools/\n    ├── debug-cli/                # Command-line debugging tool\n    └── chaos-replay/             # Tool to replay experiments from logs</code></pre></div>\n\n<h4 id=\"c-diagnostic-logging-implementation\">C. Diagnostic Logging Implementation</h4>\n<p>Here&#39;s a complete structured logging implementation for the chaos platform:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/logger.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogLevel represents the severity of a log entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LevelDebug</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DEBUG\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LevelInfo</span><span style=\"color:#B392F0\">  LogLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"INFO\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LevelWarn</span><span style=\"color:#B392F0\">  LogLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"WARN\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LevelError</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ERROR\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogEntry represents a structured log entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LogEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Level      </span><span style=\"color:#B392F0\">LogLevel</span><span style=\"color:#9ECBFF\">               `json:\"level\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Component  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"component\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"message\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Fields     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"fields,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Experiment </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"experiment,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Fault      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"fault,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiagnosticLogger provides structured logging with fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DiagnosticLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    component </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debugMode </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDiagnosticLogger creates a new logger for a component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDiagnosticLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">component</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">debugMode</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        component: component,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        debugMode: debugMode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger:    log.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(os.Stdout, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#6A737D\">// No prefix - we'll format ourselves</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// logInternal handles the actual logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">logInternal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#B392F0\"> LogLevel</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Skip debug logs if debug mode is disabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> level </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LevelDebug </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">l.debugMode {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> LogEntry</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UTC</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Level:     level,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Component: l.component,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:   msg,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Fields:    fields,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Marshal to JSON for structured logging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    jsonBytes, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(entry)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fallback to simple logging if JSON marshaling fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        l.logger.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, level, l.component, msg, fields)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.logger.</span><span style=\"color:#B392F0\">Println</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(jsonBytes))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Debug logs a debug message with optional fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mergedFields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> mergeFields</span><span style=\"color:#E1E4E8\">(fields</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logInternal</span><span style=\"color:#E1E4E8\">(LevelDebug, msg, mergedFields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Info logs an info message with optional fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mergedFields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> mergeFields</span><span style=\"color:#E1E4E8\">(fields</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logInternal</span><span style=\"color:#E1E4E8\">(LevelInfo, msg, mergedFields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Warn logs a warning message with optional fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mergedFields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> mergeFields</span><span style=\"color:#E1E4E8\">(fields</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logInternal</span><span style=\"color:#E1E4E8\">(LevelWarn, msg, mergedFields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error logs an error message with optional fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mergedFields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> mergeFields</span><span style=\"color:#E1E4E8\">(fields</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> mergedFields </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            mergedFields </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mergedFields[</span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    l.</span><span style=\"color:#B392F0\">logInternal</span><span style=\"color:#E1E4E8\">(LevelError, msg, mergedFields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithExperiment adds experiment context to subsequent logs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">experimentID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return a wrapper that adds experiment context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base:        l,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        experimentID: experimentID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithFault adds fault context to subsequent logs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base:    l,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        faultID: faultID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to merge multiple field maps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> mergeFields</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, f </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> fields {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> f </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> k, v </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> f {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result[k] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> v</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContextLogger adds context to log entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContextLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    experimentID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faultID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Debug with context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cl </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContextLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fields</span><span style=\"color:#F97583\"> ...map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mergedFields </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> mergeFields</span><span style=\"color:#E1E4E8\">(fields</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> mergedFields </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mergedFields </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cl.experimentID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mergedFields[</span><span style=\"color:#9ECBFF\">\"experiment\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cl.experimentID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cl.faultID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mergedFields[</span><span style=\"color:#9ECBFF\">\"fault\"</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cl.faultID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cl.base.</span><span style=\"color:#B392F0\">Debug</span><span style=\"color:#E1E4E8\">(msg, mergedFields)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Similar implementations for Info, Warn, Error...</span></span></code></pre></div>\n\n<h4 id=\"d-state-inspector-skeleton-code\">D. State Inspector Skeleton Code</h4>\n<p>Implement an HTTP endpoint for inspecting platform state:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/inspector.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateInspector provides HTTP endpoints for debugging platform state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    orchestrator </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#6A737D\">// Would be *orchestrator.Orchestrator in real code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewStateInspector creates a new state inspector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewStateInspector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">orc</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        orchestrator: orc,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterRoutes registers debug endpoints with an HTTP mux</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">si </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterRoutes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mux</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ServeMux</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/state/experiments\"</span><span style=\"color:#E1E4E8\">, si.handleExperiments)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/state/faults\"</span><span style=\"color:#E1E4E8\">, si.handleFaults)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/state/scenarios\"</span><span style=\"color:#E1E4E8\">, si.handleScenarios)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/debug/health\"</span><span style=\"color:#E1E4E8\">, si.handleHealth)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleExperiments returns all experiments with their current state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">si </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleExperiments</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    si.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> si.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract experiments from orchestrator (type assertion needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Convert to JSON-safe structure (avoid cycles)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Marshal to JSON and write response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Include state, timestamps, and any errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add filtering by status if query parameter provided</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Example response structure:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // json.NewEncoder(w).Encode(map[string]interface{}{</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     \"experiments\": experiments,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //     \"timestamp\": time.Now().UTC(),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleFaults returns all active faults with their status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">si </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleFaults</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query fault injector for all active faults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Include fault parameters, target, and injection time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add verification status (is fault actually active?)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Include cleanup commands for each fault</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add filtering by experiment ID if provided</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleScenarios returns all scenarios with their current step</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">si </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleScenarios</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query GameDayController for all scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Include current step, status, and pause reason if paused</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add approval status for steps requiring approval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Include scenario schedule and execution history</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleHealth returns platform health status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">si </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    health </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"status\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"healthy\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UTC</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"components\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"orchestrator\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ok\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Add actual health checks for each component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(health)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-pre-flight-validation-skeleton\">E. Pre-Flight Validation Skeleton</h4>\n<p>Implement comprehensive pre-flight checks:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/preflight.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PreFlightCheck represents a single validation check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PreFlightCheck</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"critical\", \"warning\", \"info\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CheckFunc   </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PreFlightValidator runs validation checks before experiment execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PreFlightValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checks []</span><span style=\"color:#B392F0\">PreFlightCheck</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiagnosticLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPreFlightValidator creates a validator with default checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPreFlightValidator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">logger</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">DiagnosticLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pv </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger: logger,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pv.</span><span style=\"color:#B392F0\">registerDefaultChecks</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pv</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// registerDefaultChecks registers common validation checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">registerDefaultChecks</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pv.checks </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(pv.checks, []</span><span style=\"color:#B392F0\">PreFlightCheck</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:        </span><span style=\"color:#9ECBFF\">\"metrics_connectivity\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Description: </span><span style=\"color:#9ECBFF\">\"Verify metrics collector is reachable\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Severity:    </span><span style=\"color:#9ECBFF\">\"critical\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CheckFunc:   pv.checkMetricsConnectivity,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:        </span><span style=\"color:#9ECBFF\">\"agent_connectivity\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Description: </span><span style=\"color:#9ECBFF\">\"Verify fault injection agents are reachable\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Severity:    </span><span style=\"color:#9ECBFF\">\"critical\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CheckFunc:   pv.checkAgentConnectivity,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:        </span><span style=\"color:#9ECBFF\">\"permission_validation\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Description: </span><span style=\"color:#9ECBFF\">\"Verify agents have required permissions\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Severity:    </span><span style=\"color:#9ECBFF\">\"critical\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CheckFunc:   pv.checkPermissions,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:        </span><span style=\"color:#9ECBFF\">\"target_existence\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Description: </span><span style=\"color:#9ECBFF\">\"Verify experiment targets exist\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Severity:    </span><span style=\"color:#9ECBFF\">\"critical\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CheckFunc:   pv.checkTargetExistence,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:        </span><span style=\"color:#9ECBFF\">\"platform_exclusion\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Description: </span><span style=\"color:#9ECBFF\">\"Verify chaos platform is excluded from blast radius\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Severity:    </span><span style=\"color:#9ECBFF\">\"critical\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CheckFunc:   pv.checkPlatformExclusion,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateExperiment runs all checks for an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateExperiment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">exp</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ExperimentID: exp.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:    time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UTC</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Checks:       </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">CheckResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(pv.checks)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: For each check in pv.checks, run the CheckFunc with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Capture success/failure, message, and any error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Stop early if critical check fails (configurable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Aggregate results and determine overall validation status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log detailed results using pv.logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// checkMetricsConnectivity verifies metrics collector is reachable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">checkMetricsConnectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Attempt to query a simple metric (e.g., \"up\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check response time and data freshness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify required metrics for experiment exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success/failure with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// checkAgentConnectivity verifies agents are reachable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">checkAgentConnectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Ping each agent endpoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify agent version compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check agent health status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success/failure with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// checkPermissions verifies agents have required capabilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">checkPermissions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query agent for capabilities (CAP_NET_ADMIN, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify based on fault types in experiment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check filesystem permissions for required commands</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success/failure with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// checkTargetExistence verifies experiment targets exist</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">checkTargetExistence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse target selectors from experiment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Query Kubernetes/cloud provider for matching resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify at least one target matches selector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success/failure with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// checkPlatformExclusion verifies chaos platform is excluded from blast radius</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PreFlightValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">checkPlatformExclusion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract platform service names from configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare with blast radius services/namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return failure if any platform component is included</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success/failure with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationResult contains results of pre-flight validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExperimentID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Overall      </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Checks       []</span><span style=\"color:#B392F0\">CheckResult</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Warnings     []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckResult represents the result of a single check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CheckResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Passed   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Error    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duration </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"f-debug-mode-configuration\">F. Debug Mode Configuration</h4>\n<p>Add debug mode to the platform configuration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// config/config.go (excerpt)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... other configuration fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Debug </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Enabled     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">          `yaml:\"enabled\" env:\"DEBUG_ENABLED\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LogLevel    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `yaml:\"logLevel\" env:\"DEBUG_LOG_LEVEL\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        StateDump   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">          `yaml:\"stateDump\" env:\"DEBUG_STATE_DUMP\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PreFlight   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">          `yaml:\"preFlight\" env:\"DEBUG_PRE_FLIGHT\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Trace       </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">          `yaml:\"trace\" env:\"DEBUG_TRACE\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#9ECBFF\">`yaml:\"debug\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In main initialization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> loadConfig</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create logger with debug mode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> debug.</span><span style=\"color:#B392F0\">NewDiagnosticLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"orchestrator\"</span><span style=\"color:#E1E4E8\">, config.Debug.Enabled)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable additional debugging based on config</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.Debug.StateDump {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inspector </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> debug.</span><span style=\"color:#B392F0\">NewStateInspector</span><span style=\"color:#E1E4E8\">(orchestrator)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        inspector.</span><span style=\"color:#B392F0\">RegisterRoutes</span><span style=\"color:#E1E4E8\">(http.DefaultServeMux)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.Debug.PreFlight {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validator </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> debug.</span><span style=\"color:#B392F0\">NewPreFlightValidator</span><span style=\"color:#E1E4E8\">(logger)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Use validator before experiment execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"g-milestone-debugging-checkpoints\">G. Milestone Debugging Checkpoints</h4>\n<p>After implementing each milestone, verify the debugging capabilities:</p>\n<p><strong>Milestone 1 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start platform with debug mode enabled</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">DEBUG_ENABLED</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">true</span><span style=\"color:#B392F0\"> ./chaos-controller</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test debug endpoints</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/health</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/state/faults</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify logs show structured JSON with experiment context</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">tail</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> chaos.log</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> '.'</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test pre-flight validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/v1/experiments/validate</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> @experiment.json</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check experiment state during execution</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/state/experiments</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify safety monitor logs show rule evaluations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> safety</span><span style=\"color:#9ECBFF\"> chaos.log</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> '.'</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test scenario debugging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/debug/state/scenarios</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Add observation during scenario execution</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/v1/scenarios/{id}/observations</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"message\": \"Manual observation\", \"severity\": \"info\"}'</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Debug endpoints return JSON with current state</li>\n<li>Logs show structured entries with experiment/fault context</li>\n<li>Pre-flight validation catches common configuration errors</li>\n<li>State inspector shows accurate state machine status</li>\n</ul>\n<p><strong>Signs of Issues:</strong></p>\n<ul>\n<li>Debug endpoints return 404 or empty responses</li>\n<li>Logs contain unstructured text instead of JSON</li>\n<li>Pre-flight checks pass but experiments still fail</li>\n<li>State inspector shows stale or incorrect state information</li>\n</ul>\n<h4 id=\"h-language-specific-debugging-hints-for-go\">H. Language-Specific Debugging Hints for Go</h4>\n<ol>\n<li><strong>Use <code>pprof</code> for performance debugging:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">net/http/pprof</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // Add to main(): go func() { log.Println(http.ListenAndServe(\":6060\", nil)) }()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // Then: go tool pprof http://localhost:6060/debug/pprof/heap</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Context timeouts for hanging operations:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   result, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> someOperation</span><span style=\"color:#E1E4E8\">(ctx)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Structured errors with wrapping:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> doSomething</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to do something with param </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, param, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Use <code>sync.Once</code> for initialization:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   var</span><span style=\"color:#E1E4E8\"> initOnce </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Once</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   func</span><span style=\"color:#B392F0\"> initialize</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       initOnce.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">           // Initialization code that should run only once</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"5\">\n<li><strong>Debug concurrent map access with race detector:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#79B8FF\"> -race</span><span style=\"color:#9ECBFF\"> ./cmd/chaos-controller</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ./chaos-controller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Race conditions will be reported to stderr</span></span></code></pre></div>\n\n<p>By implementing these debugging capabilities throughout the platform, developers can quickly diagnose issues during development and operators can troubleshoot problems in production deployments. The key principle is that a chaos engineering platform must be more observable and debuggable than the systems it tests.</p>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (forward-looking capabilities that build upon the foundational architecture)</p>\n</blockquote>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Mental Model: The Evolution of a Mature Platform</strong><br>Think of the chaos engineering platform as a living organism that grows in sophistication. The current architecture provides the essential skeletal structure—organs for fault injection, nervous system for orchestration, and brain for decision-making. Future extensions represent the development of specialized organs (advanced fault types), enhanced senses (richer observability), and higher cognitive functions (AI-driven analysis) that transform a basic lifeform into a highly evolved species.</p>\n</blockquote>\n<p>The platform&#39;s current design intentionally focuses on core capabilities to ensure reliability and safety. However, the architecture is built with extension points that enable future enhancements without requiring major refactoring. These extensions align with the <strong>chaos maturity progression</strong> from manual experiments to continuous, intelligent resilience validation.</p>\n<h3 id=\"potential-enhancements\">Potential Enhancements</h3>\n<h4 id=\"visual-ui-for-experiment-management\">Visual UI for Experiment Management</h4>\n<p><strong>Description:</strong> A web-based graphical interface for creating, monitoring, and analyzing chaos experiments without using CLI tools or API calls directly.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>New Component:</strong> Web UI Server component added to the architecture</li>\n<li><strong>Extended Interfaces:</strong> REST API endpoints for the existing <code>Orchestrator</code>, <code>GameDayController</code>, and metrics components</li>\n<li><strong>Data Flow Changes:</strong> UI becomes primary interaction point; API layer handles authentication, authorization, and rate limiting</li>\n<li><strong>Storage Requirements:</strong> User preferences, saved experiment templates, and visualization configurations</li>\n</ul>\n<p><strong>Expected Benefits:</strong></p>\n<ul>\n<li>Lower barrier to entry for non-developer roles (SREs, product managers)</li>\n<li>Real-time visual monitoring of active experiments with drill-down capabilities</li>\n<li>Collaborative experiment design with team sharing features</li>\n<li>Historical trend visualization of experiment outcomes over time</li>\n</ul>\n<p><strong>Implementation Considerations:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Existing Architecture Extension Points:\n1. Experiment Controller (API layer) → Add REST endpoints with OpenAPI documentation\n2. Metrics Collector → Add WebSocket endpoints for real-time metric streaming\n3. Result Analyzer → Generate visualization-friendly JSON summaries</code></pre></div>\n\n<p><strong>Integration Pattern:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">mermaid</span><pre class=\"arch-pre shiki-highlighted\"><code>graph TD\n    User[User Browser] --&gt; UIServer[Web UI Server]\n    UIServer --&gt; APIGateway[API Gateway]\n    APIGateway --&gt; Orchestrator[Experiment Orchestrator]\n    APIGateway --&gt; MetricsAPI[Metrics Collector API]\n    APIGateway --&gt; ResultsAPI[Result Analyzer API]\n    MetricsAPI -.-&gt;|WebSocket| User</code></pre></div>\n\n<h4 id=\"integration-with-cicd-pipelines\">Integration with CI/CD Pipelines</h4>\n<p><strong>Description:</strong> Automated chaos testing integrated into deployment pipelines to validate resilience before production releases.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>New Integration Points:</strong> CI/CD system plugins (GitHub Actions, GitLab CI, Jenkins)</li>\n<li><strong>Extended Data Model:</strong> <code>Experiment</code> gains <code>PipelineContext</code> field with build/deployment metadata</li>\n<li><strong>New Safety Mechanism:</strong> Pipeline-specific safety rules with tighter thresholds</li>\n<li><strong>Result Integration:</strong> Experiment results reported back to CI system as test results</li>\n</ul>\n<p><strong>Expected Benefits:</strong></p>\n<ul>\n<li>Shift-left resilience testing catches issues earlier in development cycle</li>\n<li>Automated validation of resilience assumptions for each deployment</li>\n<li>Integration with canary deployment strategies for progressive validation</li>\n<li>Correlation between code changes and resilience impact</li>\n</ul>\n<p><strong>Implementation Approaches:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Description</th>\n<th>Complexity</th>\n<th>Integration Depth</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Pre-Deployment Validation</strong></td>\n<td>Run chaos experiments in staging before production deployment</td>\n<td>Medium</td>\n<td>Experiment results block deployment if safety thresholds breached</td>\n</tr>\n<tr>\n<td><strong>Post-Deployment Verification</strong></td>\n<td>Run targeted experiments immediately after deployment</td>\n<td>Low</td>\n<td>Non-blocking; alerts only on significant deviations</td>\n</tr>\n<tr>\n<td><strong>Canary Validation</strong></td>\n<td>Run experiments only on canary instances</td>\n<td>High</td>\n<td>Requires service mesh integration for traffic routing</td>\n</tr>\n<tr>\n<td><strong>Blue-Green Testing</strong></td>\n<td>Run comprehensive experiments on inactive environment before cutover</td>\n<td>High</td>\n<td>Requires full environment duplication</td>\n</tr>\n</tbody></table>\n<p><strong>Example CI/CD Integration Flow:</strong></p>\n<ol>\n<li>Developer pushes code → CI pipeline builds and deploys to staging</li>\n<li>Chaos platform automatically runs pre-configured experiment suite</li>\n<li>If experiments pass (steady-state maintained), deployment proceeds to production</li>\n<li>If experiments fail, pipeline halts and team receives detailed failure analysis</li>\n<li>Post-production, lightweight verification experiments run in production with minimal blast radius</li>\n</ol>\n<h4 id=\"ai-generated-fault-scenarios-based-on-service-graphs\">AI-Generated Fault Scenarios Based on Service Graphs</h4>\n<p><strong>Description:</strong> Machine learning models that analyze system topology and historical failure data to suggest realistic, high-impact fault scenarios.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>New Component:</strong> Scenario Recommender with ML capabilities</li>\n<li><strong>Extended Data Sources:</strong> Service discovery integration, dependency graphs, historical incident data</li>\n<li><strong>Training Pipeline:</strong> Offline model training using past experiment outcomes</li>\n<li><strong>Feedback Loop:</strong> Experiment results used to improve recommendation quality</li>\n</ul>\n<p><strong>Expected Benefits:</strong></p>\n<ul>\n<li>Discovery of unexpected failure modes not considered by human operators</li>\n<li>Prioritization of experiments based on predicted impact and likelihood</li>\n<li>Adaptive scenario generation that evolves with system changes</li>\n<li>Reduced time to design comprehensive test coverage</li>\n</ul>\n<p><strong>AI Integration Architecture:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Data Sources → Feature Engineering → ML Model → Recommendations\n     ↓               ↓                ↓            ↓\nService    Historical   Dependency  Failure   Generated\nRegistry   Incidents    Graphs      Patterns  Scenarios</code></pre></div>\n\n<p><strong>Recommendation Algorithm Phases:</strong></p>\n<ol>\n<li><strong>Graph Analysis Phase:</strong> Parse service dependency graph to identify critical paths, single points of failure, and tight coupling</li>\n<li><strong>Historical Learning Phase:</strong> Analyze past incidents and experiment outcomes to learn which fault combinations cause cascading failures</li>\n<li><strong>Impact Prediction Phase:</strong> Use ML model to predict steady-state metric impact for candidate fault scenarios</li>\n<li><strong>Scenario Generation Phase:</strong> Convert top predictions into executable <code>Scenario</code> definitions with appropriate blast radius limits</li>\n</ol>\n<p><strong>Implementation Roadmap:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Capability</th>\n<th>Data Requirements</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Basic Dependency Analysis</td>\n<td>Service discovery data</td>\n<td>Critical path identification</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Historical Pattern Matching</td>\n<td>Past experiment results</td>\n<td>Similar scenario suggestions</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Predictive Impact Modeling</td>\n<td>Metrics history + dependency graphs</td>\n<td>Impact scores for candidate scenarios</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Autonomous Scenario Generation</td>\n<td>All above + failure mode database</td>\n<td>Complete <code>Scenario</code> definitions</td>\n</tr>\n</tbody></table>\n<h4 id=\"advanced-scheduling-and-recurring-experiments\">Advanced Scheduling and Recurring Experiments</h4>\n<p><strong>Description:</strong> Sophisticated scheduling capabilities for regular chaos testing, including calendar-based scheduling, dependency-aware sequencing, and conditional execution based on system state.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>Enhanced <code>Schedule</code> Type:</strong> Add complex scheduling rules (cron expressions with time zones, business hours exclusion)</li>\n<li><strong>New Component:</strong> Scheduler Service with persistent job queue</li>\n<li><strong>State-Aware Execution:</strong> Pre-execution checks for system readiness</li>\n<li><strong>Recurrence Management:</strong> Experiment series with gradual parameter evolution</li>\n</ul>\n<p><strong>Expected Benefits:</strong></p>\n<ul>\n<li>Regular, automated resilience validation without manual intervention</li>\n<li>Business-hour awareness to avoid disrupting peak traffic periods</li>\n<li>Progressive testing with increasing intensity over time</li>\n<li>Integration with maintenance windows and change freezes</li>\n</ul>\n<p><strong>Enhanced Schedule Definition:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example enhanced schedule specification</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">schedule</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">RECURRING</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  cron</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"0 2 * * *\"</span><span style=\"color:#6A737D\">  # 2 AM daily</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  timezone</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"America/New_York\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  exclude</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">days</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"sat\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sun\"</span><span style=\"color:#E1E4E8\">]           </span><span style=\"color:#6A737D\"># Skip weekends</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">hours</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"09:00-17:00\"</span><span style=\"color:#6A737D\">           # Skip business hours</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">dates</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"2024-12-25\"</span><span style=\"color:#E1E4E8\">]          </span><span style=\"color:#6A737D\"># Skip Christmas</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  conditions</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">metric</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"system.load.1m\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      operator</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"&#x3C;\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      value</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0.7</span><span style=\"color:#6A737D\">                     # Only run if load &#x3C; 70%</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">status</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"no_active_incidents\"</span><span style=\"color:#6A737D\">  # Only run if no active incidents</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  progression</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"GRADUAL_INCREASE\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    parameter</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"blast_radius.percentage\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    start</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    end</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">25</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    step</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    max_failures</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#6A737D\">                  # Stop progression after 2 failures</span></span></code></pre></div>\n\n<p><strong>Scheduler Architecture:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>                  [Scheduler Service]\n                         ↓\n           [Persistent Job Store (WAL)]\n                         ↓\n    ┌───────────────────┼───────────────────┐\n    ↓                   ↓                   ↓\n[Time-Based]   [Event-Based]      [Condition-Based]\n  Triggers       Triggers            Triggers\n    ↓                   ↓                   ↓\n[Validate     [Check System    [Evaluate Metric\n Conditions]     State]          Conditions]\n    ↓                   ↓                   ↓\n       [Execute Experiment via Orchestrator]</code></pre></div>\n\n<h4 id=\"multi-environment-and-multi-cloud-support\">Multi-Environment and Multi-Cloud Support</h4>\n<p><strong>Description:</strong> Unified chaos engineering across heterogeneous environments including multiple cloud providers, on-premises data centers, and hybrid configurations.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>Environment Abstraction Layer:</strong> Unified interface for different infrastructure providers</li>\n<li><strong>Fault Injector Adapters:</strong> Provider-specific implementations for cloud-native fault injection</li>\n<li><strong>Cross-Environment Experiments:</strong> Faults that span multiple environments (e.g., simulating cloud region failure affecting on-prem services)</li>\n<li><strong>Unified Observability:</strong> Aggregated metrics across all environments</li>\n</ul>\n<p><strong>Expected Benefits:</strong></p>\n<ul>\n<li>Consistent chaos engineering practices across all deployment environments</li>\n<li>Testing of cross-environment failure modes (critical for hybrid architectures)</li>\n<li>Leverage cloud-native chaos capabilities (AWS Fault Injection Service, Azure Chaos Studio)</li>\n<li>Centralized reporting and compliance across the entire organization</li>\n</ul>\n<p><strong>Environment Abstraction Design:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Environment interface abstracts provider differences</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Provider identification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Provider</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Region</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource discovery</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ListServices</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">selector</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Service</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ListNodes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">selector</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fault injection capabilities</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SupportedFaults</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">FaultType</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    InjectFault</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fault</span><span style=\"color:#B392F0\"> Fault</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> Target</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Metrics collection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetMetrics</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">query</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeframe</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Provider implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AWSEnvironment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* AWS-specific implementation */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AzureEnvironment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* Azure-specific implementation */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> KubernetesEnvironment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* K8s-specific implementation */</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OnPremEnvironment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* On-premises implementation */</span><span style=\"color:#E1E4E8\"> }</span></span></code></pre></div>\n\n<p><strong>Cross-Environment Experiment Example:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">experiment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"cross-cloud-region-failure\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  hypothesis</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Services failover correctly when primary cloud region becomes unavailable\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  environments</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">provider</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">aws</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      region</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">us-east-1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      role</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">primary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">provider</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">aws</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      region</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">us-west-2</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      role</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">secondary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">provider</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">on-prem</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      location</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">datacenter-a</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      role</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">backup</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  faults</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">NETWORK_PARTITION</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      target</span><span style=\"color:#E1E4E8\">: </span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        environment</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">aws</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        region</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">us-east-1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      parameters</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        isolation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">complete</span></span></code></pre></div>\n\n<h4 id=\"extended-fault-injection-library\">Extended Fault Injection Library</h4>\n<p><strong>Description:</strong> Expansion of fault types beyond the core set to include application-level faults, database corruption, message queue delays, and stateful service failures.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>Extended <code>FaultType</code> Enum:</strong> Additional fault type constants</li>\n<li><strong>Specialized Fault Injectors:</strong> Application-aware injection mechanisms</li>\n<li><strong>Stateful Fault Patterns:</strong> Faults that maintain state across injection cycles</li>\n<li><strong>Application Instrumentation:</strong> Lightweight agents or library integrations for deep fault injection</li>\n</ul>\n<p><strong>New Fault Categories:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Example Faults</th>\n<th>Injection Method</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Database Faults</strong></td>\n<td>Query latency, transaction failure, data corruption, connection pool exhaustion</td>\n<td>Database driver proxy, stored procedures, direct DB manipulation</td>\n<td>Testing database failover and query resilience</td>\n</tr>\n<tr>\n<td><strong>Message Queue Faults</strong></td>\n<td>Message loss, duplicate delivery, out-of-order delivery, consumer lag</td>\n<td>Queue proxy, consumer instrumentation, broker configuration</td>\n<td>Testing event-driven architecture reliability</td>\n</tr>\n<tr>\n<td><strong>Stateful Service Faults</strong></td>\n<td>State corruption, rollback failure, snapshot corruption, leader election issues</td>\n<td>Service-specific instrumentation, state manipulation</td>\n<td>Testing state management and recovery mechanisms</td>\n</tr>\n<tr>\n<td><strong>External Dependency Faults</strong></td>\n<td>Third-party API failures, payment gateway timeouts, geolocation service errors</td>\n<td>HTTP proxy, DNS manipulation, mock service injection</td>\n<td>Testing circuit breakers and fallback mechanisms</td>\n</tr>\n<tr>\n<td><strong>Security Faults</strong></td>\n<td>TLS certificate expiration, authentication service failure, authorization misconfiguration</td>\n<td>Security middleware instrumentation</td>\n<td>Testing security incident response</td>\n</tr>\n</tbody></table>\n<p><strong>Fault Library Extension Pattern:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Fault type registry pattern for extensibility</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> faultRegistry </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">FaultType</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultInjector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FAULT_TYPE_LATENCY:         </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">NetworkLatencyInjector</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FAULT_TYPE_PACKET_LOSS:     </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">PacketLossInjector</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FAULT_TYPE_DB_CORRUPTION:   </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">DatabaseCorruptionInjector</span><span style=\"color:#E1E4E8\">{},  </span><span style=\"color:#6A737D\">// New</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FAULT_TYPE_MQ_REORDERING:   </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">MessageQueueReorderingInjector</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#6A737D\">// New</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Additional fault types can be registered at runtime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Runtime registration allows third-party extensions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RegisterFaultType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">faultType</span><span style=\"color:#B392F0\"> FaultType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">injector</span><span style=\"color:#B392F0\"> FaultInjector</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faultRegistry[faultType] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> injector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"compliance-and-audit-logging\">Compliance and Audit Logging</h4>\n<p><strong>Description:</strong> Comprehensive audit trails, compliance reporting, and regulatory evidence collection for chaos engineering activities in regulated industries.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>Enhanced Event System:</strong> Immutable event logging with cryptographic signing</li>\n<li><strong>Audit Report Generation:</strong> Compliance-ready documentation of experiments</li>\n<li><strong>Access Control Integration:</strong> Role-based experiment authorization</li>\n<li><strong>Change Approval Workflows:</strong> Formal approval chains for production experiments</li>\n</ul>\n<p><strong>Compliance Framework Integration:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Chaos Platform → [Compliance Adapter] → Regulatory Framework\n      ↓                   ↓                   ↓\n  Experiments      Evidence Mapping      Audit Reports\n      ↓                   ↓                   ↓\n  [Execute] → [Collect Metrics] → [Generate Evidence] → [Sign &amp; Store]</code></pre></div>\n\n<p><strong>Audit Log Requirements:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Implementation Approach</th>\n<th>Retention Period</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Non-Repudiation</strong></td>\n<td>Cryptographic signing of experiment records</td>\n<td>7+ years</td>\n</tr>\n<tr>\n<td><strong>Tamper Evidence</strong></td>\n<td>Append-only WAL with hash chain</td>\n<td>7+ years</td>\n</tr>\n<tr>\n<td><strong>Access Logging</strong></td>\n<td>All API calls logged with user context</td>\n<td>2+ years</td>\n</tr>\n<tr>\n<td><strong>Change Tracking</strong></td>\n<td>Versioned experiment definitions</td>\n<td>Indefinite</td>\n</tr>\n<tr>\n<td><strong>Decision Audit</strong></td>\n<td>Approval/rejection records with reasoning</td>\n<td>7+ years</td>\n</tr>\n</tbody></table>\n<p><strong>Regulatory Mapping Example:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">compliance_mapping</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  framework</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"SOC2\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  controls</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">control</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"CC6.1\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      evidence_source</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"experiment_results\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      validation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Automated resilience testing proves logical access controls\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">control</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"CC7.1\"</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      evidence_source</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"system_change_logs\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      validation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Chaos experiments validate change management procedures\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  framework</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"HIPAA\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  controls</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    - </span><span style=\"color:#85E89D\">control</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"164.308(a)(7)\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      evidence_source</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"disaster_recovery_tests\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      validation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Chaos experiments simulate disaster scenarios and validate recovery\"</span></span></code></pre></div>\n\n<h4 id=\"real-time-collaboration-and-observer-tools\">Real-time Collaboration and Observer Tools</h4>\n<p><strong>Description:</strong> Collaborative features for GameDays including real-time chat, shared observations, incident simulation interfaces, and coordinated response workflows.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>Collaboration Server:</strong> Real-time communication backend (WebSocket)</li>\n<li><strong>Shared State Management:</strong> Synchronized experiment views across multiple observers</li>\n<li><strong>Incident Simulation Interface:</strong> Mock incident management system integration</li>\n<li><strong>Runbook Execution Tracking:</strong> Collaborative runbook progress tracking</li>\n</ul>\n<p><strong>Collaboration Architecture:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>          [Web UI Clients]\n                ↓\n    [WebSocket Connection Pool]\n                ↓\n    [Collaboration Server]\n         ↓              ↓\n[State Sync]    [Message Broker]\n     ↓              ↓\n[Orchestrator]  [Observation Store]</code></pre></div>\n\n<p><strong>Collaboration Features:</strong></p>\n<ol>\n<li><strong>Real-time Experiment Dashboard:</strong> All observers see the same experiment status, metrics, and safety events</li>\n<li><strong>Collaborative Observations:</strong> Team members can add observations that are visible to all participants</li>\n<li><strong>Incident Simulation Console:</strong> Mock incident creation and assignment to simulate real response workflows</li>\n<li><strong>Runbook Task Assignment:</strong> Tasks can be assigned to specific team members with due dates</li>\n<li><strong>Post-GameDay Debrief Tools:</strong> Structured retrospective templates and action item tracking</li>\n</ol>\n<p><strong>Example Collaboration Workflow:</strong></p>\n<ol>\n<li>GameDay starts → All participants join the collaborative session</li>\n<li>Orchestrator begins experiment → Real-time metrics displayed to all</li>\n<li>Safety threshold breached → Alert sent to all participants simultaneously</li>\n<li>Incident simulation triggered → Mock incident ticket created in simulated system</li>\n<li>Team members collaborate on response → Chat, task assignments, observations</li>\n<li>GameDay completes → Automated report generation with all collaborative inputs</li>\n</ol>\n<h4 id=\"predictive-resilience-analytics\">Predictive Resilience Analytics</h4>\n<p><strong>Description:</strong> Advanced analytics that predict system resilience based on historical experiment data, identify resilience degradation trends, and recommend remediation actions.</p>\n<p><strong>Architectural Impact:</strong></p>\n<ul>\n<li><strong>Analytics Engine:</strong> Time-series analysis and machine learning component</li>\n<li><strong>Resilience Score Model:</strong> Mathematical model quantifying system resilience</li>\n<li><strong>Trend Analysis:</strong> Detection of resilience degradation over time</li>\n<li><strong>Remediation Recommender:</strong> Actionable recommendations to improve resilience</li>\n</ul>\n<p><strong>Resilience Analytics Pipeline:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Historical Data → Feature Extraction → Model Training → Prediction\n     ↓                ↓                  ↓              ↓\nExperiment   Metric Patterns  Resilience  Future\nResults      Failure Modes    Score Model Resilience\n                                  ↓\n                           [Recommendations]</code></pre></div>\n\n<p><strong>Analytics Capabilities:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Description</th>\n<th>Output Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Resilience Score</strong></td>\n<td>Quantitative measure of system resilience (0-100)</td>\n<td>&quot;Resilience score: 78/100&quot;</td>\n</tr>\n<tr>\n<td><strong>Degradation Detection</strong></td>\n<td>Identify declining resilience before incidents occur</td>\n<td>&quot;Resilience trend: -5% over last 30 days&quot;</td>\n</tr>\n<tr>\n<td><strong>Weakest Link Identification</strong></td>\n<td>Pinpoint services/components with lowest resilience</td>\n<td>&quot;Weakest link: PaymentService (resilience: 45/100)&quot;</td>\n</tr>\n<tr>\n<td><strong>Remediation ROI Analysis</strong></td>\n<td>Prioritize fixes based on expected resilience improvement</td>\n<td>&quot;Fix database connection pooling: +15 resilience points&quot;</td>\n</tr>\n<tr>\n<td><strong>Capacity Planning Insights</strong></td>\n<td>Resilience implications of scaling decisions</td>\n<td>&quot;Adding 2 more instances improves resilience by 8 points&quot;</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Approach:</strong></p>\n<ol>\n<li><strong>Data Collection Phase:</strong> Aggregate historical experiment results, system metrics, and incident data</li>\n<li><strong>Feature Engineering Phase:</strong> Extract resilience-relevant features (failure recovery time, error rate impact, cascade patterns)</li>\n<li><strong>Model Training Phase:</strong> Train supervised ML models to predict experiment outcomes</li>\n<li><strong>Inference Phase:</strong> Apply models to current system state to generate resilience insights</li>\n<li><strong>Recommendation Phase:</strong> Map resilience gaps to specific architectural or operational improvements</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-for-extensions\">Technology Recommendations for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Area</th>\n<th>Simple Option (Quick Start)</th>\n<th>Advanced Option (Enterprise Scale)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Visual UI</strong></td>\n<td>React SPA + Go HTTP server</td>\n<td>Next.js SSR + GraphQL API + OAuth2</td>\n</tr>\n<tr>\n<td><strong>CI/CD Integration</strong></td>\n<td>Webhook handlers + status API</td>\n<td>Dedicated CI/CD plugin ecosystem</td>\n</tr>\n<tr>\n<td><strong>AI Scenario Generation</strong></td>\n<td>Rule-based heuristic engine</td>\n<td>TensorFlow/PyTorch ML models + feature store</td>\n</tr>\n<tr>\n<td><strong>Multi-Cloud Support</strong></td>\n<td>Provider-specific adapters</td>\n<td>Cross-cloud abstraction layer + Terraform integration</td>\n</tr>\n<tr>\n<td><strong>Compliance Logging</strong></td>\n<td>Structured logging + external analysis</td>\n<td>Integrated compliance engine + blockchain immutability</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-for-extensions\">Recommended File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chaos-platform/\n├── cmd/\n│   ├── chaos-server/          # Main orchestrator\n│   ├── chaos-ui/              # Web UI server (NEW)\n│   └── chaos-analytics/       # Analytics engine (NEW)\n├── internal/\n│   ├── extensions/            # Extension framework\n│   │   ├── registry.go        # Extension point registry\n│   │   └── lifecycle.go       # Extension lifecycle management\n│   ├── ui/                    # Web UI backend (NEW)\n│   │   ├── server.go\n│   │   ├── handlers/\n│   │   └── static/            # SPA build assets\n│   ├── analytics/             # Resilience analytics (NEW)\n│   │   ├── engine.go\n│   │   ├── models/\n│   │   └── predictors/\n│   ├── integrations/          # External system integrations\n│   │   ├── ci/\n│   │   │   ├── github.go\n│   │   │   ├── gitlab.go\n│   │   │   └── jenkins.go\n│   │   ├── cloud/\n│   │   │   ├── aws.go\n│   │   │   ├── azure.go\n│   │   │   └── gcp.go\n│   │   └── compliance/\n│   │       ├── soc2.go\n│   │       └── hipaa.go\n│   └── collaboration/         # Real-time collaboration (NEW)\n│       ├── server.go\n│       ├── rooms.go\n│       └── events.go\n└── pkg/\n    └── extensions/            # Public extension API\n        ├── types.go\n        └── interfaces.go</code></pre></div>\n\n<h4 id=\"extension-point-skeleton-code\">Extension Point Skeleton Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/extensions/interfaces.go</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extension point interfaces for third-party developers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentGenerator generates experiment scenarios</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExperimentGenerator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate generates experiment scenarios based on system analysis</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Generate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">systemInfo</span><span style=\"color:#B392F0\"> SystemInfo</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Name returns the generator's display name</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Name</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Version returns the generator version</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Version</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultInjectorPlugin extends fault injection capabilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultInjectorPlugin</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // FaultType returns the fault type this plugin handles</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    FaultType</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Inject applies the fault to the target</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Inject</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fault</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Target</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cleanup removes the fault</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">faultID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate checks if the fault definition is valid</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fault</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricsAnalyzer provides advanced metric analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsAnalyzer</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // AnalyzeTrends analyzes metric trends for resilience insights</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AnalyzeTrends</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                  metrics</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MetricPoint</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                  baseline</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResilienceReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PredictImpact predicts the impact of a fault on metrics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PredictImpact</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                  fault</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Fault</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                  currentMetrics</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">PredictedImpact</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// pkg/extensions/registry.go</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Extension registry for runtime registration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    experimentGenerators </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ExperimentGenerator</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faultInjectorPlugins </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">FaultType</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultInjectorPlugin</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metricsAnalyzers     </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">MetricsAnalyzer</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterExperimentGenerator registers a new experiment generator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RegisterExperimentGenerator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">generator</span><span style=\"color:#B392F0\"> ExperimentGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if generator with same name already registered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate generator interface implementation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add to experimentGenerators map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log registration for audit purposes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterFaultInjectorPlugin registers a new fault injector plugin</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RegisterFaultInjectorPlugin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">plugin</span><span style=\"color:#B392F0\"> FaultInjectorPlugin</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if plugin for this fault type already registered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate plugin interface implementation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add to faultInjectorPlugins map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update fault type registry in main orchestrator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetExperimentGenerators returns all registered experiment generators</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> GetExperimentGenerators</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">ExperimentGenerator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Convert map values to slice</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Sort by name for consistent ordering</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"cicd-integration-starter-code\">CI/CD Integration Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/integrations/ci/github.go</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GitHub Actions integration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GitHubIntegration</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">github</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    owner     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    repo      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    webhookSecret </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewGitHubIntegration creates a new GitHub integration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewGitHubIntegration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">token</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">owner</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">repo</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GitHubIntegration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create GitHub client with authentication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate repository access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up webhook if not already present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateCheckRun creates a GitHub check run for an experiment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GitHubIntegration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateCheckRun</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                          experiment</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Experiment</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                          sha</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create check run with \"in_progress\" status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Include experiment details in output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return check run ID for updates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateCheckRun updates a GitHub check run with experiment results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GitHubIntegration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateCheckRun</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                          checkRunID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                          result</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ExperimentResult</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Determine check run conclusion from experiment result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Format detailed output with metrics and observations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update check run with conclusion and output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add annotations for failed safety rules if applicable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleWebhook handles GitHub webhook events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">GitHubIntegration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleWebhook</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">signature</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate webhook signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse webhook event type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle pull_request events for CI integration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle check_suite events for experiment status updates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"visual-ui-api-endpoint-skeleton\">Visual UI API Endpoint Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/ui/handlers/experiments.go</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Web UI API handlers for experiments</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ListExperimentsHandler returns experiments for UI display</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ListExperimentsHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse query parameters (filter, pagination)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call orchestrator.ListExperiments with filter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Transform results for UI consumption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return JSON response with pagination metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExperimentStreamHandler streams real-time experiment updates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ExperimentStreamHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set up Server-Sent Events (SSE) headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Subscribe to experiment events via pub/sub</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Stream events as they occur</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle client disconnection cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateExperimentHandler creates a new experiment via UI</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CreateExperimentHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse and validate experiment JSON from request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply UI-specific defaults (e.g., safety rules)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call orchestrator.CreateExperiment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return created experiment with ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-extensions\">Language-Specific Hints for Extensions</h4>\n<p><strong>Go-Specific Implementation Tips:</strong></p>\n<ol>\n<li><strong>Extension Discovery:</strong> Use <code>go/build</code> package to discover plugins in a plugins directory</li>\n<li><strong>Hot Reloading:</strong> Implement <code>fsnotify</code> to watch for plugin changes in development</li>\n<li><strong>UI Development:</strong> Consider <code>embed</code> package for bundling React build artifacts</li>\n<li><strong>Real-time Updates:</strong> Use <code>gorilla/websocket</code> for WebSocket connections or Server-Sent Events</li>\n<li><strong>ML Integration:</strong> Use <code>cgo</code> to call Python ML libraries or <code>gorgonia</code> for Go-native ML</li>\n</ol>\n<p><strong>Performance Considerations:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// For real-time collaboration, consider connection pooling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConnectionPool</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connections </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">websocket</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Conn</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement connection lifecycle management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement message broadcasting with connection health checks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For analytics processing, consider batch processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AnalyticsBatchProcessor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    batchSize   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    batchWindow </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processor   </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">AnalyticsEvent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement batching with flush on size or timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement retry logic for failed batches</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-for-extensions\">Milestone Checkpoint for Extensions</h4>\n<p><strong>Extension Development Verification Steps:</strong></p>\n<ol>\n<li><strong>Visual UI Checkpoint:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   # Start UI server\n   go run cmd/chaos-ui/main.go --port=8080\n   \n   # Expected: Web UI accessible at http://localhost:8080\n   # Verify: Experiment list loads, real-time updates work, can create new experiment</code></pre></div>\n\n<ol start=\"2\">\n<li><strong>CI/CD Integration Checkpoint:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   # Simulate GitHub webhook\n   curl -X POST http://localhost:8080/api/webhooks/github \\\n        -H &quot;X-GitHub-Event: pull_request&quot; \\\n        -H &quot;Content-Type: application/json&quot; \\\n        -d '{&quot;action&quot;:&quot;opened&quot;,&quot;pull_request&quot;:{&quot;head&quot;:{&quot;sha&quot;:&quot;abc123&quot;}}}'\n   \n   # Expected: Experiment automatically created for PR validation\n   # Verify: Check run appears in GitHub UI with experiment status</code></pre></div>\n\n<ol start=\"3\">\n<li><strong>AI Scenario Generation Checkpoint:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>   # Generate scenarios from service graph\n   curl -X POST http://localhost:8080/api/scenarios/generate \\\n        -H &quot;Content-Type: application/json&quot; \\\n        -d '{&quot;service_graph&quot;:&quot;dependency-graph.json&quot;}'\n   \n   # Expected: JSON array of generated scenario definitions\n   # Verify: Scenarios target critical paths and include realistic fault combinations</code></pre></div>\n\n<h4 id=\"debugging-tips-for-extensions\">Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>UI shows &quot;Loading...&quot; indefinitely</strong></td>\n<td>CORS configuration missing</td>\n<td>Check browser console for CORS errors</td>\n<td>Add proper CORS headers to API endpoints</td>\n</tr>\n<tr>\n<td><strong>CI/CD webhooks not triggering experiments</strong></td>\n<td>Webhook signature validation failing</td>\n<td>Check webhook logs for validation errors</td>\n<td>Ensure webhook secret matches between systems</td>\n</tr>\n<tr>\n<td><strong>AI-generated scenarios are unrealistic</strong></td>\n<td>Insufficient training data</td>\n<td>Check scenario generator logs for data warnings</td>\n<td>Add more historical incident data to training set</td>\n</tr>\n<tr>\n<td><strong>Real-time collaboration messages delayed</strong></td>\n<td>WebSocket connection pooling bottleneck</td>\n<td>Monitor connection pool metrics and goroutine count</td>\n<td>Implement connection pruning and load balancing</td>\n</tr>\n<tr>\n<td><strong>Multi-cloud experiments fail on specific provider</strong></td>\n<td>Provider API rate limiting</td>\n<td>Check provider API response headers for rate limits</td>\n<td>Implement exponential backoff and request queuing</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (cross-cutting terminology that appears throughout the document)</p>\n</blockquote>\n<h2 id=\"glossary\">Glossary</h2>\n<h3 id=\"term-definitions\">Term Definitions</h3>\n<p>This glossary defines key terms, concepts, and mental models used throughout the Chaos Engineering Platform design document. Each term includes a clear definition and references the section where it first appears in the document.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>First Appearance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Air Traffic Control Tower</strong></td>\n<td>Mental model for the platform&#39;s coordination system, where the <strong>Orchestrator</strong> acts as the tower coordinating multiple &quot;flights&quot; (experiments) simultaneously. Each component has aviation-themed analogies: flight plans (experiments), clearance delivery (validation), ground control (fault injection), and tower control (safety monitoring).</td>\n<td>Interactions and Data Flow</td>\n</tr>\n<tr>\n<td><strong>Append-Only WAL</strong></td>\n<td>A <strong>write-ahead log</strong> implementation that only allows appending new records, never modifying or deleting existing ones. This property ensures audit trails cannot be tampered with after the fact, which is crucial for forensic analysis of chaos experiments.</td>\n<td>Component Design: Fault Injection Framework</td>\n</tr>\n<tr>\n<td><strong>Auto-Rollback</strong></td>\n<td>The automatic reversal of injected faults when safety thresholds are breached during an experiment. This prevents experiment-induced failures from escalating into actual outages. Auto-rollback can be triggered by time-based expiration or condition-based safety rule violations.</td>\n<td>Component Design: Experiment Orchestration Engine</td>\n</tr>\n<tr>\n<td><strong>Blast Radius</strong></td>\n<td>A scope limitation mechanism for chaos experiments that constrains the impact to a specific percentage of traffic, set of services, or namespaces. The <strong>BlastRadius</strong> struct defines these boundaries to ensure experiments don&#39;t cascade into unintended system-wide failures.</td>\n<td>Data Model</td>\n</tr>\n<tr>\n<td><strong>CAP_NET_ADMIN</strong></td>\n<td>A Linux capability required for network configuration operations like modifying traffic control (tc) rules and iptables. The fault injection framework needs this elevated permission when running network chaos experiments, which affects deployment architecture decisions.</td>\n<td>Component Design: Fault Injection Framework</td>\n</tr>\n<tr>\n<td><strong>Chaos Engineering</strong></td>\n<td>The practice of intentionally injecting failures into distributed systems to proactively test resilience, identify weaknesses, and build confidence that production systems can withstand unexpected turbulent conditions.</td>\n<td>Goals and Non-Goals</td>\n</tr>\n<tr>\n<td><strong>Chaos Maturity Progression</strong></td>\n<td>The evolutionary path of chaos engineering practices from manual, ad-hoc experiments to scheduled <strong>GameDays</strong> to continuous, automated resilience validation integrated into deployment pipelines. The platform supports all stages of this progression.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Circuit Breaker</strong></td>\n<td>A resilience pattern that monitors for failures in dependent services and fails fast when a threshold is exceeded, preventing cascading failures. The <strong>SafetyMonitor</strong> implements a similar pattern to automatically abort experiments when safety rules are breached.</td>\n<td>Component Design: Experiment Orchestration Engine</td>\n</tr>\n<tr>\n<td><strong>Cleanup Ensurer</strong></td>\n<td>A mechanism guaranteeing fault reversal even after platform crashes or network partitions. The <strong>CleanupEnsurer</strong> struct combines a <strong>write-ahead log</strong> with periodic health checks to ensure no orphaned faults remain active after experiments complete or abort.</td>\n<td>Component Design: Fault Injection Framework</td>\n</tr>\n<tr>\n<td><strong>Command-and-Control Architecture</strong></td>\n<td>The architectural pattern where a central coordinator (the <strong>Orchestrator</strong>) issues commands to distributed agents (fault injectors) while maintaining full visibility and control over the entire system. This contrasts with decentralized peer-to-peer architectures.</td>\n<td>High-Level Architecture</td>\n</tr>\n<tr>\n<td><strong>Cgo</strong></td>\n<td>The Go language mechanism for calling C code, used in the fault injection framework to interface with Linux system calls for network configuration (<strong>tc</strong> commands) and process management that require capabilities not available through pure Go libraries.</td>\n<td>Implementation Guidance (Fault Injection Framework)</td>\n</tr>\n<tr>\n<td><strong>Clearance Delivery</strong></td>\n<td>Aviation analogy for the <strong>Orchestrator</strong>&#39;s validation phase, where experiments undergo pre-flight checks including hypothesis validation, resource availability verification, and safety rule review before receiving approval to proceed to execution.</td>\n<td>Interactions and Data Flow</td>\n</tr>\n<tr>\n<td><strong>Cryptographic Signing</strong></td>\n<td>Using digital signatures to ensure authenticity and non-repudiation of experiment definitions, execution records, and results. This prevents unauthorized modification of experiment parameters and creates a verifiable audit trail for compliance.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Dead Man&#39;s Switch</strong></td>\n<td>A safety mechanism that triggers automatically when a heartbeat stops. The <strong>SafetyMonitor</strong> implements a variant where if the metrics collection heartbeat stops, the system assumes something is wrong and triggers automatic rollback of all active faults.</td>\n<td>Component Design: Experiment Orchestration Engine</td>\n</tr>\n<tr>\n<td><strong>Exponential Backoff</strong></td>\n<td>A retry strategy with increasing delay between attempts, used by the <strong>Client</strong> struct for resilient RPC communication between platform components. The delay grows exponentially (e.g., 1s, 2s, 4s, 8s) to avoid overwhelming recovering services.</td>\n<td>Error Handling and Edge Cases</td>\n</tr>\n<tr>\n<td><strong>Experiment</strong></td>\n<td>A controlled scientific test that formulates a <strong>steady-state hypothesis</strong>, injects one or more <strong>faults</strong> within a defined <strong>blast radius</strong>, monitors system behavior, and analyzes results. Represented by the <strong>Experiment</strong> struct containing hypothesis, faults, schedule, and safety rules.</td>\n<td>Data Model</td>\n</tr>\n<tr>\n<td><strong>Fault Injection</strong></td>\n<td>The controlled introduction of failures into a system to test its resilience. The platform supports multiple fault types including latency, packet loss, process termination, and resource exhaustion, each implemented by the <strong>FaultInjector</strong> component.</td>\n<td>Component Design: Fault Injection Framework</td>\n</tr>\n<tr>\n<td><strong>Feature Engineering</strong></td>\n<td>The process of transforming raw metric data into meaningful features for machine learning models. In the context of resilience analytics, this involves calculating derived metrics like error rate trends, recovery time patterns, and correlation coefficients between services.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Flight Plans</strong></td>\n<td>Aviation analogy for <strong>experiment definitions</strong>, which specify the intended route (hypothesis), expected conditions (steady state), potential turbulence (faults), and emergency procedures (safety rules) before the &quot;flight&quot; (experiment execution) begins.</td>\n<td>Interactions and Data Flow</td>\n</tr>\n<tr>\n<td><strong>Flight Recorders</strong></td>\n<td>Aviation analogy for the <strong>ResultAnalyzer</strong> component, which captures comprehensive telemetry during experiments for post-mortem analysis. Like black boxes in aircraft, these records help reconstruct what happened during chaotic conditions.</td>\n<td>Interactions and Data Flow</td>\n</tr>\n<tr>\n<td><strong>GameDay</strong></td>\n<td>An orchestrated event running multiple chaos experiments in sequence with integrated runbooks, observer briefings, and incident response practice. Represented by the <strong>Scenario</strong> struct containing sequential steps, approval gates, and safety overrides.</td>\n<td>Component Design: GameDay Automation</td>\n</tr>\n<tr>\n<td><strong>Ground Control</strong></td>\n<td>Aviation analogy for the <strong>FaultInjector</strong> component, which manages the &quot;ground operations&quot; of actually applying and removing faults in the target systems. Ground control executes commands from the tower but has local autonomy for technical implementation.</td>\n<td>Interactions and Data Flow</td>\n</tr>\n<tr>\n<td><strong>Hash Chain</strong></td>\n<td>A linked sequence of cryptographic hashes where each record includes the hash of the previous record, creating a tamper-evident audit trail. Used in the <strong>WAL</strong> implementation to detect unauthorized modifications to experiment execution logs.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Idempotent Operations</strong></td>\n<td>Operations that can be applied multiple times without changing the result beyond the initial application. All fault injection and cleanup methods are designed to be idempotent, ensuring safe retries after network failures or partial executions.</td>\n<td>Error Handling and Edge Cases</td>\n</tr>\n<tr>\n<td><strong>Inject (Event)</strong></td>\n<td>A simulated external event during a <strong>GameDay</strong> to increase realism, such as a notification about a concurrent deployment or a simulated customer complaint. Represented by the <strong>InjectMessage</strong> field in <strong>ScenarioStep</strong> to trigger observer response testing.</td>\n<td>Component Design: GameDay Automation</td>\n</tr>\n<tr>\n<td><strong>Metrics Collector</strong></td>\n<td>Component responsible for gathering time-series metrics from monitoring systems (Prometheus, Datadog, etc.) to establish baselines, monitor during experiments, and validate <strong>steady-state hypotheses</strong>. Provides the <strong>GetMetric</strong> and <strong>GetCurrentValue</strong> methods.</td>\n<td>High-Level Architecture</td>\n</tr>\n<tr>\n<td><strong>Orchestrator</strong></td>\n<td>The central coordination component that manages the complete lifecycle of chaos experiments. The <strong>Orchestrator</strong> struct maintains experiment state machines, coordinates fault injection, monitors safety rules, and generates results.</td>\n<td>Component Design: Experiment Orchestration Engine</td>\n</tr>\n<tr>\n<td><strong>Property-Based Testing</strong></td>\n<td>Testing method that verifies properties hold for all generated inputs rather than specific examples. Used to test the chaos platform itself, with properties like &quot;faults must always be reversible&quot; and &quot;cleanup must be idempotent.&quot;</td>\n<td>Testing Strategy</td>\n</tr>\n<tr>\n<td><strong>Resilience Score</strong></td>\n<td>A quantitative measure of system resilience calculated from historical experiment results, failure recovery times, and dependency health. The score provides a single metric for tracking resilience improvements over time and comparing different services.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Runbook</strong></td>\n<td>A predefined set of instructions for responding to an incident, integrated into <strong>GameDay</strong> scenarios to practice operational procedures. The <strong>RunbookTask</strong> struct represents manual steps that observers must execute during scenario execution.</td>\n<td>Component Design: GameDay Automation</td>\n</tr>\n<tr>\n<td><strong>Safety Monitor</strong></td>\n<td>Component that continuously watches system metrics during experiments and triggers <strong>auto-rollback</strong> when safety thresholds are breached. Implements the <strong>CheckSafetyRules</strong> method to evaluate metric conditions and duration requirements.</td>\n<td>High-Level Architecture</td>\n</tr>\n<tr>\n<td><strong>Scenario</strong></td>\n<td>A sequenced collection of experiments, manual tasks, pauses, and inject events that comprise a <strong>GameDay</strong>. The <strong>Scenario</strong> struct contains steps, observer briefing materials, scheduling information, and optional safety rule overrides.</td>\n<td>Component Design: GameDay Automation</td>\n</tr>\n<tr>\n<td><strong>Server-Sent Events (SSE)</strong></td>\n<td>Technology for server-to-client real-time updates over HTTP, used in the web interface to stream experiment status changes, metric updates, and safety alerts to observers during active <strong>GameDays</strong>.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Shadow Integration</strong></td>\n<td>Using a dedicated test environment within production tooling (like creating a shadow incident in PagerDuty or a test Slack channel) for simulations without triggering actual alerts or notifications to production on-call personnel.</td>\n<td>Component Design: GameDay Automation</td>\n</tr>\n<tr>\n<td><strong>Shift-Left Resilience Testing</strong></td>\n<td>The practice of testing resilience earlier in the development lifecycle, integrating chaos experiments into CI/CD pipelines to catch resilience issues before they reach production.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Sidecar Agent Model</strong></td>\n<td>Architecture pattern where a helper component (the fault injector agent) runs alongside each service instance, typically in the same pod or container. This contrasts with the proxy-based approach where traffic flows through a central interceptor.</td>\n<td>Component Design: Fault Injection Framework</td>\n</tr>\n<tr>\n<td><strong>Steady-State Hypothesis</strong></td>\n<td>The expected system behavior expressed as metric thresholds that should hold true before, during, and after fault injection. The <strong>Hypothesis</strong> struct defines these expectations, which are validated by the <strong>HypothesisValidator</strong>.</td>\n<td>Data Model</td>\n</tr>\n<tr>\n<td><strong>Test Double</strong></td>\n<td>Test substitute for a real component (mock, stub, fake) used in platform testing. The testing strategy employs test doubles for metrics collectors, fault injectors, and external dependencies to enable deterministic testing of chaos scenarios.</td>\n<td>Testing Strategy</td>\n</tr>\n<tr>\n<td><strong>Tower Control</strong></td>\n<td>Aviation analogy for the <strong>SafetyMonitor</strong> component, which watches all active &quot;flights&quot; (experiments) for signs of trouble and issues abort commands when safety boundaries are breached, similar to air traffic controllers monitoring aircraft separation.</td>\n<td>Interactions and Data Flow</td>\n</tr>\n<tr>\n<td><strong>WebSocket</strong></td>\n<td>Protocol for full-duplex communication over TCP, used in the real-time dashboard for bidirectional communication between the UI and backend, allowing observers to send commands (pause, approve steps) and receive live updates.</td>\n<td>Future Extensions</td>\n</tr>\n<tr>\n<td><strong>Write-Ahead Log (WAL)</strong></td>\n<td>A durable log where changes are recorded before being applied to the system. The <strong>CleanupEnsurer</strong> uses a WAL to record fault injection commands, ensuring they can be replayed for cleanup even after a crash or power loss.</td>\n<td>Component Design: Fault Injection Framework</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Consistent terminology is essential for a chaos engineering platform because miscommunication during active experiments could lead to real outages. The aviation-inspired mental models (air traffic control, flight plans, etc.) provide intuitive frameworks for teams to understand component responsibilities and interaction patterns, especially during high-stress <strong>GameDay</strong> scenarios.</p>\n</blockquote>\n<hr>\n","toc":[{"level":1,"text":"Chaos Engineering Platform: Design Document","id":"chaos-engineering-platform-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Must-Have Goals","id":"must-have-goals"},{"level":4,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Non-Functional Goals","id":"non-functional-goals"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended Initial File Structure","id":"recommended-initial-file-structure"},{"level":4,"text":"Core Data Types Skeleton","id":"core-data-types-skeleton"},{"level":4,"text":"Safety Infrastructure Starter Code","id":"safety-infrastructure-starter-code"},{"level":4,"text":"Core Orchestration Skeleton","id":"core-orchestration-skeleton"},{"level":4,"text":"Milestone 1 Checkpoint","id":"milestone-1-checkpoint"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Mental Model: The Chaos Control Room","id":"mental-model-the-chaos-control-room"},{"level":3,"text":"Component Diagram and Interactions","id":"component-diagram-and-interactions"},{"level":4,"text":"Core Components","id":"core-components"},{"level":4,"text":"Component Interactions","id":"component-interactions"},{"level":4,"text":"Component Interface Details","id":"component-interface-details"},{"level":4,"text":"Component Deployment Architecture","id":"component-deployment-architecture"},{"level":4,"text":"Data Flow Between Components","id":"data-flow-between-components"},{"level":4,"text":"ADR: Centralized vs. Distributed Control Plane","id":"adr-centralized-vs-distributed-control-plane"},{"level":4,"text":"Common Pitfalls in Architecture Design","id":"common-pitfalls-in-architecture-design"},{"level":3,"text":"Recommended File and Module Structure","id":"recommended-file-and-module-structure"},{"level":4,"text":"Package Dependency Graph","id":"package-dependency-graph"},{"level":4,"text":"Module Design Rationale","id":"module-design-rationale"},{"level":4,"text":"Build and Deployment Configuration","id":"build-and-deployment-configuration"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Starter Code for Project Structure","id":"starter-code-for-project-structure"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":4,"text":"Milestone Checkpoint: Architecture Validation","id":"milestone-checkpoint-architecture-validation"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Experiment and Fault Definitions","id":"experiment-and-fault-definitions"},{"level":4,"text":"Experiment Definition","id":"experiment-definition"},{"level":4,"text":"Hypothesis Definition","id":"hypothesis-definition"},{"level":4,"text":"Metric Threshold Definition","id":"metric-threshold-definition"},{"level":4,"text":"Fault Definition","id":"fault-definition"},{"level":4,"text":"Blast Radius Definition","id":"blast-radius-definition"},{"level":4,"text":"Safety Rule Definition","id":"safety-rule-definition"},{"level":4,"text":"Schedule Definition","id":"schedule-definition"},{"level":4,"text":"Target Definition","id":"target-definition"},{"level":4,"text":"Fault Parameters Definition","id":"fault-parameters-definition"},{"level":3,"text":"Metrics and Results","id":"metrics-and-results"},{"level":4,"text":"Experiment Result Definition","id":"experiment-result-definition"},{"level":4,"text":"Hypothesis Validation Definition","id":"hypothesis-validation-definition"},{"level":4,"text":"Metric Validation Result Definition","id":"metric-validation-result-definition"},{"level":4,"text":"Metric Sample Definition","id":"metric-sample-definition"},{"level":4,"text":"Safety Event Definition","id":"safety-event-definition"},{"level":4,"text":"Observation Definition","id":"observation-definition"},{"level":4,"text":"Fault Injection Record Definition","id":"fault-injection-record-definition"},{"level":4,"text":"Cleanup Ensurer and Fault Record","id":"cleanup-ensurer-and-fault-record"},{"level":4,"text":"Experiment Status Constants","id":"experiment-status-constants"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":2,"text":"Component Design: Fault Injection Framework","id":"component-design-fault-injection-framework"},{"level":3,"text":"Mental Model: The Saboteur in the Factory","id":"mental-model-the-saboteur-in-the-factory"},{"level":3,"text":"Interface Definition","id":"interface-definition"},{"level":3,"text":"Internal Behavior and State Machine","id":"internal-behavior-and-state-machine"},{"level":3,"text":"ADR: Fault Injection Method (Proxy vs. Sidecar)","id":"adr-fault-injection-method-proxy-vs-sidecar"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Cleanup Ensurer","id":"infrastructure-starter-code-cleanup-ensurer"},{"level":4,"text":"Core Logic Skeleton: Fault Injector","id":"core-logic-skeleton-fault-injector"},{"level":4,"text":"Core Logic Skeleton: Network Latency Fault Implementation","id":"core-logic-skeleton-network-latency-fault-implementation"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Component Design: Experiment Orchestration Engine","id":"component-design-experiment-orchestration-engine"},{"level":3,"text":"Mental Model: The Scientific Experiment Lab","id":"mental-model-the-scientific-experiment-lab"},{"level":3,"text":"Interface Definition","id":"interface-definition"},{"level":4,"text":"Management API Methods","id":"management-api-methods"},{"level":4,"text":"Internal Coordination Methods","id":"internal-coordination-methods"},{"level":3,"text":"Internal Behavior and State Machine","id":"internal-behavior-and-state-machine"},{"level":4,"text":"Experiment State Machine","id":"experiment-state-machine"},{"level":4,"text":"Detailed Algorithm: Experiment Execution","id":"detailed-algorithm-experiment-execution"},{"level":4,"text":"Safety Monitoring Algorithm","id":"safety-monitoring-algorithm"},{"level":3,"text":"ADR: Rollback Strategy (Time-based vs. Condition-based)","id":"adr-rollback-strategy-time-based-vs-condition-based"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":4,"text":"⚠️ Pitfall: Skipping Steady-State Verification","id":"-pitfall-skipping-steady-state-verification"},{"level":4,"text":"⚠️ Pitfall: Not Handling Orphaned Faults","id":"-pitfall-not-handling-orphaned-faults"},{"level":4,"text":"⚠️ Pitfall: Ignoring Metric Collection Lag","id":"-pitfall-ignoring-metric-collection-lag"},{"level":4,"text":"⚠️ Pitfall: Single Safety Monitor Failure Point","id":"-pitfall-single-safety-monitor-failure-point"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: CleanupEnsurer","id":"infrastructure-starter-code-cleanupensurer"},{"level":4,"text":"Core Logic Skeleton: Experiment State Machine","id":"core-logic-skeleton-experiment-state-machine"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Component Design: GameDay Automation","id":"component-design-gameday-automation"},{"level":3,"text":"Mental Model: The Disaster Simulation Drill","id":"mental-model-the-disaster-simulation-drill"},{"level":3,"text":"Interface Definition","id":"interface-definition"},{"level":4,"text":"Core Data Structures","id":"core-data-structures"},{"level":4,"text":"Controller Interface Methods","id":"controller-interface-methods"},{"level":3,"text":"Internal Behavior","id":"internal-behavior"},{"level":4,"text":"Execution Algorithm","id":"execution-algorithm"},{"level":4,"text":"State Machine","id":"state-machine"},{"level":4,"text":"Integration with Orchestrator","id":"integration-with-orchestrator"},{"level":3,"text":"ADR: Integration with Incident Management","id":"adr-integration-with-incident-management"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Scenario YAML Parser","id":"infrastructure-starter-code-scenario-yaml-parser"},{"level":4,"text":"Core Logic Skeleton: Sequential Scenario Executor","id":"core-logic-skeleton-sequential-scenario-executor"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Mental Model: The Air Traffic Control Tower","id":"mental-model-the-air-traffic-control-tower"},{"level":3,"text":"Key Sequence: Running an Experiment","id":"key-sequence-running-an-experiment"},{"level":4,"text":"Pre-Flight Checklist: Experiment Creation and Validation","id":"pre-flight-checklist-experiment-creation-and-validation"},{"level":4,"text":"Experiment Execution: A Detailed Walkthrough","id":"experiment-execution-a-detailed-walkthrough"},{"level":4,"text":"State Transition Table During Execution","id":"state-transition-table-during-execution"},{"level":4,"text":"Error Recovery Scenarios","id":"error-recovery-scenarios"},{"level":3,"text":"Message Formats","id":"message-formats"},{"level":4,"text":"Control Plane RPC Messages","id":"control-plane-rpc-messages"},{"level":4,"text":"Event Bus Messages","id":"event-bus-messages"},{"level":4,"text":"Internal Component Communication Patterns","id":"internal-component-communication-patterns"},{"level":4,"text":"Message Serialization Example","id":"message-serialization-example"},{"level":3,"text":"Component Interaction During GameDay Scenarios","id":"component-interaction-during-gameday-scenarios"},{"level":3,"text":"Data Flow Visualization","id":"data-flow-visualization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Event Bus Starter Code","id":"event-bus-starter-code"},{"level":4,"text":"RPC Client Helper","id":"rpc-client-helper"},{"level":4,"text":"Core Orchestrator Skeleton","id":"core-orchestrator-skeleton"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Fault Cleanup Failure: Ensuring Reversibility After Orchestrator Crash","id":"fault-cleanup-failure-ensuring-reversibility-after-orchestrator-crash"},{"level":4,"text":"Architecture Decision: Persisted Fault Registry with Recovery Scanner","id":"architecture-decision-persisted-fault-registry-with-recovery-scanner"},{"level":4,"text":"Core Mechanism: The CleanupEnsurer","id":"core-mechanism-the-cleanupensurer"},{"level":4,"text":"Edge Cases and Mitigations","id":"edge-cases-and-mitigations"},{"level":4,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Metrics Collection Interruption: Maintaining Safety Without Data","id":"metrics-collection-interruption-maintaining-safety-without-data"},{"level":4,"text":"Architecture Decision: Fail-Safe Rollback on Metrics Unavailability","id":"architecture-decision-fail-safe-rollback-on-metrics-unavailability"},{"level":4,"text":"Implementation Strategy: Health-Aware Metrics Collection","id":"implementation-strategy-health-aware-metrics-collection"},{"level":4,"text":"Data Structure Extension: SafetyEvent for Collection Failures","id":"data-structure-extension-safetyevent-for-collection-failures"},{"level":4,"text":"Edge Cases and Mitigations","id":"edge-cases-and-mitigations"},{"level":4,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Infrastructure Starter Code: Write-Ahead Log (WAL)","id":"infrastructure-starter-code-write-ahead-log-wal"},{"level":4,"text":"Core Logic Skeleton: CleanupEnsurer","id":"core-logic-skeleton-cleanupensurer"},{"level":4,"text":"Core Logic Skeleton: Enhanced Safety Monitor with Failure Detection","id":"core-logic-skeleton-enhanced-safety-monitor-with-failure-detection"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint: Verifying Cleanup Recovery","id":"milestone-checkpoint-verifying-cleanup-recovery"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: The Chaos Platform&#39;s Safety Harness","id":"mental-model-the-chaos-platform39s-safety-harness"},{"level":3,"text":"Testing Approach and Properties","id":"testing-approach-and-properties"},{"level":4,"text":"Property-Based Testing: Core Invariants","id":"property-based-testing-core-invariants"},{"level":4,"text":"Integration Testing Strategy","id":"integration-testing-strategy"},{"level":4,"text":"Chaos Testing the Chaos Platform","id":"chaos-testing-the-chaos-platform"},{"level":3,"text":"Milestone Implementation Checkpoints","id":"milestone-implementation-checkpoints"},{"level":4,"text":"Milestone 1: Fault Injection Framework","id":"milestone-1-fault-injection-framework"},{"level":4,"text":"Milestone 2: Experiment Orchestration","id":"milestone-2-experiment-orchestration"},{"level":4,"text":"Milestone 3: GameDay Automation","id":"milestone-3-gameday-automation"},{"level":4,"text":"Milestone 4: Steady-State Hypothesis &amp; Metrics Validation","id":"milestone-4-steady-state-hypothesis-amp-metrics-validation"},{"level":4,"text":"Milestone 5: Network Chaos &amp; Infrastructure Faults","id":"milestone-5-network-chaos-amp-infrastructure-faults"},{"level":4,"text":"Cross-Milestone Integration Verification","id":"cross-milestone-integration-verification"},{"level":3,"text":"Common Pitfalls in Testing Chaos Code","id":"common-pitfalls-in-testing-chaos-code"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure for Tests","id":"b-recommended-filemodule-structure-for-tests"},{"level":4,"text":"C. Infrastructure Starter Code: Test Helper for Root-Required Tests","id":"c-infrastructure-starter-code-test-helper-for-root-required-tests"},{"level":4,"text":"D. Core Logic Skeleton: Property-Based Test for Fault Reversibility","id":"d-core-logic-skeleton-property-based-test-for-fault-reversibility"},{"level":4,"text":"E. Language-Specific Hints for Go Testing","id":"e-language-specific-hints-for-go-testing"},{"level":4,"text":"F. Milestone Checkpoint Commands Summary","id":"f-milestone-checkpoint-commands-summary"},{"level":4,"text":"G. Debugging Tips for Failing Tests","id":"g-debugging-tips-for-failing-tests"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: The Chaos Platform&#39;s Own Flight Recorder","id":"mental-model-the-chaos-platform39s-own-flight-recorder"},{"level":3,"text":"Common Bug Patterns","id":"common-bug-patterns"},{"level":3,"text":"Domain-Specific Debugging Techniques","id":"domain-specific-debugging-techniques"},{"level":4,"text":"Network Fault Verification","id":"network-fault-verification"},{"level":4,"text":"Resource Exhaustion Monitoring","id":"resource-exhaustion-monitoring"},{"level":4,"text":"Platform Internal State Inspection","id":"platform-internal-state-inspection"},{"level":4,"text":"Pre-Flight Validation Checklist","id":"pre-flight-validation-checklist"},{"level":4,"text":"Diagnostic Logging Strategy","id":"diagnostic-logging-strategy"},{"level":4,"text":"Time Synchronization Considerations","id":"time-synchronization-considerations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Diagnostic Logging Implementation","id":"c-diagnostic-logging-implementation"},{"level":4,"text":"D. State Inspector Skeleton Code","id":"d-state-inspector-skeleton-code"},{"level":4,"text":"E. Pre-Flight Validation Skeleton","id":"e-pre-flight-validation-skeleton"},{"level":4,"text":"F. Debug Mode Configuration","id":"f-debug-mode-configuration"},{"level":4,"text":"G. Milestone Debugging Checkpoints","id":"g-milestone-debugging-checkpoints"},{"level":4,"text":"H. Language-Specific Debugging Hints for Go","id":"h-language-specific-debugging-hints-for-go"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Potential Enhancements","id":"potential-enhancements"},{"level":4,"text":"Visual UI for Experiment Management","id":"visual-ui-for-experiment-management"},{"level":4,"text":"Integration with CI/CD Pipelines","id":"integration-with-cicd-pipelines"},{"level":4,"text":"AI-Generated Fault Scenarios Based on Service Graphs","id":"ai-generated-fault-scenarios-based-on-service-graphs"},{"level":4,"text":"Advanced Scheduling and Recurring Experiments","id":"advanced-scheduling-and-recurring-experiments"},{"level":4,"text":"Multi-Environment and Multi-Cloud Support","id":"multi-environment-and-multi-cloud-support"},{"level":4,"text":"Extended Fault Injection Library","id":"extended-fault-injection-library"},{"level":4,"text":"Compliance and Audit Logging","id":"compliance-and-audit-logging"},{"level":4,"text":"Real-time Collaboration and Observer Tools","id":"real-time-collaboration-and-observer-tools"},{"level":4,"text":"Predictive Resilience Analytics","id":"predictive-resilience-analytics"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Extensions","id":"technology-recommendations-for-extensions"},{"level":4,"text":"Recommended File Structure for Extensions","id":"recommended-file-structure-for-extensions"},{"level":4,"text":"Extension Point Skeleton Code","id":"extension-point-skeleton-code"},{"level":4,"text":"CI/CD Integration Starter Code","id":"cicd-integration-starter-code"},{"level":4,"text":"Visual UI API Endpoint Skeleton","id":"visual-ui-api-endpoint-skeleton"},{"level":4,"text":"Language-Specific Hints for Extensions","id":"language-specific-hints-for-extensions"},{"level":4,"text":"Milestone Checkpoint for Extensions","id":"milestone-checkpoint-for-extensions"},{"level":4,"text":"Debugging Tips for Extensions","id":"debugging-tips-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Term Definitions","id":"term-definitions"}],"title":"Chaos Engineering Platform: Design Document","markdown":"# Chaos Engineering Platform: Design Document\n\n\n## Overview\n\nThis document describes the design of a Chaos Engineering platform that injects controlled failures into distributed systems to proactively test resilience. The key architectural challenge is building a safe, controlled, and observable failure injection system that can model real-world faults without causing unintended outages.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n> **Milestone(s):** All milestones (foundational requirements)\n\n## Goals and Non-Goals\n\nThis section defines the mandatory capabilities and explicit boundaries for the Chaos Engineering Platform. Establishing clear goals and non-goals is critical for maintaining architectural focus and preventing scope creep during implementation. The platform's primary purpose is to provide a **safe, controlled, and observable** system for proactively testing resilience through controlled failure injection.\n\nThink of building this platform as creating a **surgical robot for system operations**. A surgical robot must:\n1. **Execute precise, predefined interventions** (specific fault types)\n2. **Maintain constant monitoring of vital signs** (steady-state metrics)\n3. **Include emergency stop mechanisms** (safety abort conditions)\n4. **Operate only on consenting patients** (explicit targeting)\n5. **Leave no permanent damage** (full reversibility)\n\nThis mental model emphasizes the delicate balance between deliberate disruption and absolute safety that defines professional chaos engineering.\n\n### Must-Have Goals\n\nThe platform must satisfy the following core requirements, categorized by functional and non-functional dimensions.\n\n#### Functional Goals\n\nThese define what the system must be able to do operationally.\n\n| Goal Category | Specific Requirement | Description | Corresponding Milestone |\n|---------------|----------------------|-------------|-------------------------|\n| **Fault Injection** | Network fault primitives | Inject configurable network latency, packet loss, and bandwidth throttling between services using `tc netem` and `iptables`. | Milestone 1, 5 |\n| | Process and resource faults | Terminate specified processes and exhaust CPU/memory resources to configurable levels using `cgroups` and stress utilities. | Milestone 1, 5 |\n| | Infrastructure fault simulation | Simulate disk full conditions, DNS failures (NXDOMAIN, timeout), and network partitions between service pairs. | Milestone 5 |\n| | Reversible fault application | All faults must be fully reversible with automatic cleanup mechanisms that restore original system state. | Milestone 1 |\n| **Experiment Management** | Hypothesis-driven experiments | Define experiments with explicit steady-state hypotheses using metric thresholds (e.g., latency < 200ms, error rate < 1%). | Milestone 2, 4 |\n| | Automated execution lifecycle | Orchestrate experiment state transitions: baseline validation → fault injection → monitoring → rollback → analysis. | Milestone 2 |\n| | Safety controls and auto-rollback | Automatically abort experiments and roll back faults when safety thresholds are breached (error rate > 5%, latency > 1s). | Milestone 2, 4 |\n| | Blast radius control | Limit experiment scope to specific percentages of traffic, specific services, or specific infrastructure components. | Milestone 4 |\n| **Observability & Analysis** | Metrics collection and validation | Collect system metrics before, during, and after experiments; validate against hypothesis thresholds with statistical tests. | Milestone 4 |\n| | Comprehensive result reporting | Generate detailed experiment reports showing hypothesis validation, metric trends, and pass/fail outcomes. | Milestone 2 |\n| | Observability correlation | Correlate experiment execution timestamps with application logs, metrics, and traces for root cause analysis. | Milestone 2 |\n| **Scenario Orchestration** | Multi-experiment GameDays | Execute sequences of experiments with pauses, manual approval gates, and integrated runbooks. | Milestone 3 |\n| | Automated health checks | Continuously monitor system health throughout scenario execution with configurable check intervals. | Milestone 3 |\n| | Incident simulation | Replicate realistic failure scenarios (e.g., dependency failure, regional outage) in controlled environments. | Milestone 3 |\n\n#### Non-Functional Goals\n\nThese define the quality attributes the system must exhibit.\n\n| Attribute | Requirement | Rationale |\n|-----------|-------------|-----------|\n| **Safety** | Fail-safe design by default | The platform must never leave systems in a permanently degraded state. Faults must have time limits and automatic rollback. |\n| **Observability** | Comprehensive logging and metrics | Operators must understand exactly what the platform is doing and its impact on systems. All actions must be logged, and platform health must be monitorable. |\n| **Controllability** | Precise blast radius limitation | Operators must control which systems are affected and to what degree, preventing uncontrolled cascading failures. |\n| **Operational Simplicity** | Clear operational model and APIs | The platform should be easy to operate, with intuitive interfaces and clear documentation of its effects and limitations. |\n| **Reliability** | Platform resilience to its own faults | The chaos platform must not be vulnerable to the faults it injects (e.g., network chaos shouldn't break the platform's control plane). |\n| **Performance** | Minimal overhead during non-experiment periods | When not actively injecting faults, the platform should impose negligible resource overhead on target systems. |\n| **Security** | Principle of least privilege | The platform requires elevated privileges (CAP_NET_ADMIN, root) for fault injection but must operate with minimal necessary permissions and include access controls. |\n\n> **Design Principle: Safety First**\n> The most critical non-functional requirement is safety. Every architectural decision must prioritize preventing unintended production outages. This includes automatic rollback mechanisms, comprehensive pre-flight checks, and explicit confirmation for production experiments.\n\n### Explicit Non-Goals\n\nClearly stating what the platform will **not** do prevents misunderstanding and sets realistic expectations. These boundaries help focus development efforts on core value.\n\n| Non-Goal | Rationale | Alternative/Workaround |\n|----------|-----------|------------------------|\n| **Production testing by default** | The platform is designed for resilience testing, but production experiments require explicit opt-in, additional safeguards, and organizational readiness. | Default targeting to pre-production/staging environments; require explicit environment flags and manual approval for production. |\n| **Replacing traditional testing** | Chaos engineering complements but does not replace unit, integration, or load testing. It focuses on emergent properties in complex systems. | Continue existing testing practices; use chaos experiments for resilience validation beyond functional correctness. |\n| **Automated fault discovery** | The platform executes predefined experiments rather than randomly exploring failure modes. Random fault injection (like Chaos Monkey) is a different approach. | Manual experiment design based on failure mode analysis; consider future extension for automated scenario generation. |\n| **Performance/load testing** | While resource exhaustion faults stress systems, the platform is not optimized for sustained load generation or performance benchmarking. | Use dedicated load testing tools (e.g., Locust, Gatling) for performance testing; chaos experiments can complement by testing under failure conditions. |\n| **Permanent infrastructure changes** | All faults must be reversible. The platform will not make permanent configuration changes to infrastructure. | For testing permanent failure scenarios, use isolated environments that can be rebuilt, not modified in-place. |\n| **Cross-cloud/on-premises deployment** | Initial version focuses on single Kubernetes cluster or standalone host deployment patterns. | Future versions could extend to multi-cloud, but initial complexity is limited to manageable scope. |\n| **Real-time attack simulation** | The platform tests resilience, not security. It will not simulate security breaches or penetration testing scenarios. | Use dedicated security testing tools for attack simulation; chaos engineering focuses on reliability failures. |\n| **Complete autonomy (no human oversight)** | While automated, the platform requires human oversight for experiment design, approval of production experiments, and analysis of results. | Maintain manual approval gates for critical experiments; humans interpret results and refine hypotheses. |\n| **Stateful application data corruption** | The platform will not intentionally corrupt application data or databases. Faults are at infrastructure/network level. | Test data resilience through other means (backup/restore tests); chaos experiments focus on availability, not data integrity. |\n| **Legacy system support** | Initial focus is on containerized and cloud-native workloads with modern observability. | Older systems may require custom fault injectors or be tested through dependency failure scenarios. |\n\n> **Architectural Decision: Development Phasing**\n> The non-goals represent deliberate choices to limit initial scope. By focusing on reversible, infrastructure-level faults in controlled environments, we build a foundation that can safely expand to more ambitious use cases once core safety mechanisms are proven reliable.\n\n### Implementation Guidance\n\nWhile this section primarily defines requirements, the following implementation considerations emerge from these goals and non-goals.\n\n#### Technology Recommendations Table\n\n| Component | Simple Option (Initial Implementation) | Advanced Option (Future Consideration) |\n|-----------|----------------------------------------|---------------------------------------|\n| **Fault Injection** | Direct execution of `tc`, `iptables`, `cgroups` commands via Go's `os/exec` | eBPF-based fault injection for finer-grained control without external commands |\n| **Experiment Orchestration** | In-memory state machine with file-based persistence | Distributed state management using etcd or Redis for high availability |\n| **Metrics Collection** | Prometheus queries via HTTP API | Multiple backend support (Prometheus, Datadog, Cloud Monitoring) with adapter pattern |\n| **Safety Monitoring** | Periodic polling of metrics during experiments | Streaming metrics analysis with real-time alerting |\n| **API Layer** | RESTful HTTP with JSON serialization | gRPC with Protocol Buffers for better performance and bidirectional streaming |\n| **Storage** | Local filesystem for experiment definitions and results | Database backend (PostgreSQL) for history, search, and analytics |\n\n#### Recommended Initial File Structure\n\nGiven the Go-centric implementation, organize code to reflect the separation of concerns aligned with our goals:\n\n```\nchaos-platform/\n├── cmd/\n│   ├── chaos-controller/          # Main experiment orchestration daemon\n│   │   └── main.go\n│   └── chaos-agent/               # Fault injection agent (runs on target nodes)\n│       └── main.go\n├── internal/\n│   ├── experiment/                # Experiment lifecycle management\n│   │   ├── orchestrator.go        # State machine implementation\n│   │   ├── hypothesis.go          # Steady-state validation logic\n│   │   └── scheduler.go           # Experiment timing control\n│   ├── fault/                     # Fault injection primitives\n│   │   ├── injector.go            # Interface for all fault types\n│   │   ├── network/               # Network faults (latency, packet loss)\n│   │   │   ├── latency.go\n│   │   │   └── packetloss.go\n│   │   ├── resource/              # Resource exhaustion faults\n│   │   │   ├── cpu.go\n│   │   │   └── memory.go\n│   │   └── process/               # Process faults\n│   │       └── kill.go\n│   ├── safety/                    # Safety monitoring and auto-rollback\n│   │   ├── monitor.go             # Metric threshold checking\n│   │   └── circuitbreaker.go      # Abort condition evaluation\n│   ├── metrics/                   # Metrics collection and analysis\n│   │   ├── collector.go           # Query Prometheus/other backends\n│   │   └── validator.go           # Statistical validation against hypotheses\n│   ├── gameday/                   # GameDay scenario orchestration\n│   │   ├── scenario.go            # Multi-experiment sequence execution\n│   │   └── runbook.go             # Manual step integration\n│   └── api/                       # REST/GRPC API definitions\n│       ├── server.go\n│       └── types.go               # Request/response structs\n├── pkg/\n│   └── types/                     # Public data types shared across components\n│       ├── experiment.go          # Experiment, Hypothesis, Fault definitions\n│       └── result.go              # ExperimentResult, MetricSnapshot\n├── configs/                       # Configuration files and examples\n│   ├── experiment-example.yaml\n│   └── gameday-scenario.yaml\n└── scripts/                       # Utility scripts for setup and verification\n    ├── install-dependencies.sh    # Install tc, iptables, stress-ng\n    └── verify-fault-cleanup.sh    # Post-experiment cleanup verification\n```\n\n#### Core Data Types Skeleton\n\nThese types form the foundation of the platform's data model, reflecting the goals around experiment definition and safety.\n\n```go\n// pkg/types/experiment.go\npackage types\n\nimport (\n    \"time\"\n)\n\n// Experiment defines a chaos experiment with hypothesis, faults, and safety controls\ntype Experiment struct {\n    ID           string        `json:\"id\"`            // Unique identifier\n    Name         string        `json:\"name\"`          // Human-readable name\n    Description  string        `json:\"description\"`   // Purpose of experiment\n    \n    Hypothesis   Hypothesis    `json:\"hypothesis\"`    // Steady-state hypothesis to validate\n    Faults       []Fault       `json:\"faults\"`       // Faults to inject (can be multiple)\n    \n    Schedule     Schedule      `json:\"schedule\"`      // When to run (immediate or cron)\n    Duration     time.Duration `json:\"duration\"`      // How long faults remain active\n    \n    BlastRadius  BlastRadius   `json:\"blast_radius\"`  // Scope limitation\n    SafetyRules  []SafetyRule  `json:\"safety_rules\"`  // Conditions for auto-abort\n    \n    Status       ExperimentStatus `json:\"status\"`     // Current state\n    CreatedAt    time.Time     `json:\"created_at\"`\n    StartedAt    *time.Time    `json:\"started_at,omitempty\"`\n    CompletedAt  *time.Time    `json:\"completed_at,omitempty\"`\n}\n\n// Hypothesis defines the expected steady-state behavior\ntype Hypothesis struct {\n    Description string           `json:\"description\"` // Textual hypothesis\n    Metrics     []MetricThreshold `json:\"metrics\"`    // Quantifiable thresholds\n    // TODO: Add validation method to check all required metrics are available\n}\n\n// MetricThreshold defines a metric to monitor and its acceptable range\ntype MetricThreshold struct {\n    Name      string    `json:\"name\"`      // Metric name (e.g., \"http_request_duration_seconds\")\n    Query     string    `json:\"query\"`     // Prometheus query to fetch metric\n    Min       *float64  `json:\"min,omitempty\"`       // Minimum acceptable value\n    Max       *float64  `json:\"max,omitempty\"`       // Maximum acceptable value\n    Duration  string    `json:\"duration\"`  // Time window for evaluation (e.g., \"5m\")\n    // TODO: Add statistical comparison method (e.g., compared to baseline)\n}\n\n// Fault defines a single failure to inject\ntype Fault struct {\n    Type        FaultType     `json:\"type\"`        // LATENCY, PACKET_LOSS, CPU_STRESS, etc.\n    Target      Target        `json:\"target\"`      // What to affect\n    Parameters  FaultParams   `json:\"parameters\"`  // Type-specific parameters\n    // TODO: Add validation method to ensure parameters match fault type\n}\n\n// BlastRadius limits the scope of an experiment\ntype BlastRadius struct {\n    Percentage  float64 `json:\"percentage\"`  // Percentage of traffic/services affected (0-100)\n    Services    []string `json:\"services\"`   // Specific service names to target\n    Namespaces  []string `json:\"namespaces\"` // Kubernetes namespaces to target\n    // TODO: Add method to check if a specific request/service falls within blast radius\n}\n\n// SafetyRule defines conditions that trigger experiment abortion\ntype SafetyRule struct {\n    Metric      string  `json:\"metric\"`      // Metric to monitor\n    Condition   string  `json:\"condition\"`   // Condition expression (e.g., \"> 5\")\n    Duration    string  `json:\"duration\"`    // How long condition must hold before abort\n    // TODO: Add evaluation method to check condition against metric values\n}\n```\n\n#### Safety Infrastructure Starter Code\n\nSafety is the foremost non-functional goal. This complete helper ensures fault cleanup even if the orchestrator crashes.\n\n```go\n// internal/safety/cleanup_ensurer.go\npackage safety\n\nimport (\n    \"encoding/json\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n)\n\n// CleanupEnsurer guarantees fault cleanup by persisting active faults to disk\ntype CleanupEnsurer struct {\n    mu     sync.RWMutex\n    filePath string\n    activeFaults map[string]FaultRecord // faultID -> record\n}\n\n// FaultRecord represents a fault that needs cleanup\ntype FaultRecord struct {\n    ExperimentID string    `json:\"experiment_id\"`\n    FaultID      string    `json:\"fault_id\"`\n    Target       string    `json:\"target\"`\n    FaultType    string    `json:\"fault_type\"`\n    InjectTime   time.Time `json:\"inject_time\"`\n    CleanupCmd   string    `json:\"cleanup_cmd\"` // Command to reverse the fault\n}\n\n// NewCleanupEnsurer creates a new ensurer with persistence file\nfunc NewCleanupEnsurer(dataDir string) (*CleanupEnsurer, error) {\n    filePath := filepath.Join(dataDir, \"active_faults.json\")\n    ensurer := &CleanupEnsurer{\n        filePath: filePath,\n        activeFaults: make(map[string]FaultRecord),\n    }\n    \n    // Load existing active faults on startup (for crash recovery)\n    if err := ensurer.load(); err != nil && !os.IsNotExist(err) {\n        return nil, err\n    }\n    \n    // Immediately attempt cleanup of any orphaned faults from previous run\n    go ensurer.cleanupOrphanedFaults()\n    \n    return ensurer, nil\n}\n\n// RegisterFault records a fault that will need cleanup\nfunc (c *CleanupEnsurer) RegisterFault(record FaultRecord) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    c.activeFaults[record.FaultID] = record\n    return c.save()\n}\n\n// CompleteFault removes a fault from the cleanup registry\nfunc (c *CleanupEnsurer) CompleteFault(faultID string) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    delete(c.activeFaults, faultID)\n    return c.save()\n}\n\n// cleanupOrphanedFaults cleans up any faults that were active during a crash\nfunc (c *CleanupEnsurer) cleanupOrphanedFaults() {\n    c.mu.RLock()\n    records := make([]FaultRecord, 0, len(c.activeFaults))\n    for _, record := range c.activeFaults {\n        records = append(records, record)\n    }\n    c.mu.RUnlock()\n    \n    for _, record := range records {\n        // Execute the cleanup command\n        // TODO: Execute record.CleanupCmd via exec.Command\n        // Log successful cleanup\n        c.CompleteFault(record.FaultID)\n    }\n}\n\n// save persists active faults to disk\nfunc (c *CleanupEnsurer) save() error {\n    data, err := json.MarshalIndent(c.activeFaults, \"\", \"  \")\n    if err != nil {\n        return err\n    }\n    \n    tmpPath := c.filePath + \".tmp\"\n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return err\n    }\n    \n    return os.Rename(tmpPath, c.filePath)\n}\n\n// load reads active faults from disk\nfunc (c *CleanupEnsurer) load() error {\n    data, err := os.ReadFile(c.filePath)\n    if err != nil {\n        return err\n    }\n    \n    return json.Unmarshal(data, &c.activeFaults)\n}\n```\n\n#### Core Orchestration Skeleton\n\nThis skeleton implements the experiment state machine central to the platform's operation.\n\n```go\n// internal/experiment/orchestrator.go\npackage experiment\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"chaos-platform/pkg/types\"\n)\n\n// Orchestrator manages the lifecycle of chaos experiments\ntype Orchestrator struct {\n    experiments map[string]*ExperimentInstance\n    mu          sync.RWMutex\n    metricsCollector metrics.Collector\n    safetyMonitor    safety.Monitor\n    faultInjector    fault.Injector\n}\n\n// ExperimentInstance represents a running experiment with its state\ntype ExperimentInstance struct {\n    Experiment types.Experiment\n    State      ExperimentState\n    CancelFunc context.CancelFunc\n    MetricsBaseline map[string]float64\n    ResultsChan chan<- types.ExperimentResult\n}\n\n// ExperimentState represents the current state in the lifecycle\ntype ExperimentState string\n\nconst (\n    StateDraft           ExperimentState = \"DRAFT\"\n    StateBaselineValidation ExperimentState = \"BASELINE_VALIDATION\"\n    StateInjecting       ExperimentState = \"INJECTING\"\n    StateMonitoring      ExperimentState = \"MONITORING\"\n    StateRollback        ExperimentState = \"ROLLBACK\"\n    StateAnalysis        ExperimentState = \"ANALYSIS\"\n    StateCompleted       ExperimentState = \"COMPLETED\"\n    StateAborted         ExperimentState = \"ABORTED\"\n)\n\n// StartExperiment begins execution of a defined experiment\nfunc (o *Orchestrator) StartExperiment(exp types.Experiment, resultsChan chan<- types.ExperimentResult) error {\n    // TODO 1: Validate experiment definition (hypothesis, faults, schedule)\n    // TODO 2: Create ExperimentInstance with initial state StateDraft\n    // TODO 3: Check if target systems are within allowed blast radius (safety check)\n    // TODO 4: Transition to StateBaselineValidation and begin baseline metrics collection\n    // TODO 5: Start background goroutine to execute state machine transitions\n    // TODO 6: Return experiment ID for tracking\n    return nil\n}\n\n// executeStateMachine runs the experiment through its lifecycle\nfunc (o *Orchestrator) executeStateMachine(instance *ExperimentInstance) {\n    ctx, cancel := context.WithCancel(context.Background())\n    instance.CancelFunc = cancel\n    \n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            switch instance.State {\n            case StateDraft:\n                // TODO: Transition to StateBaselineValidation\n                \n            case StateBaselineValidation:\n                // TODO 1: Collect metrics for baseline period (e.g., 5 minutes)\n                // TODO 2: Validate baseline meets hypothesis criteria\n                // TODO 3: If validation fails, transition to StateAborted\n                // TODO 4: If validation succeeds, transition to StateInjecting\n                \n            case StateInjecting:\n                // TODO 1: For each fault in experiment, call faultInjector.Inject()\n                // TODO 2: Register each fault with CleanupEnsurer for safety\n                // TODO 3: Transition to StateMonitoring\n                \n            case StateMonitoring:\n                // TODO 1: Start safety monitor to watch for threshold breaches\n                // TODO 2: Start metrics collection for hypothesis validation\n                // TODO 3: Wait for experiment duration or abort signal\n                // TODO 4: On completion or abort, transition to StateRollback\n                \n            case StateRollback:\n                // TODO 1: For each active fault, call faultInjector.Cleanup()\n                // TODO 2: Verify cleanup succeeded for each fault\n                // TODO 3: Transition to StateAnalysis\n                \n            case StateAnalysis:\n                // TODO 1: Collect post-experiment metrics\n                // TODO 2: Compare baseline, experiment, and post-experiment metrics\n                // TODO 3: Determine if hypothesis was validated (pass/fail)\n                // TODO 4: Generate comprehensive ExperimentResult\n                // TODO 5: Send result to resultsChan\n                // TODO 6: Transition to StateCompleted\n                \n            case StateCompleted, StateAborted:\n                // TODO: Clean up resources, remove from active experiments map\n                return\n            }\n        }\n    }\n}\n\n// AbortExperiment forcefully stops an experiment and rolls back faults\nfunc (o *Orchestrator) AbortExperiment(experimentID string, reason string) error {\n    // TODO 1: Look up experiment instance by ID\n    // TODO 2: If in StateMonitoring, cancel context to stop monitoring\n    // TODO 3: Immediately transition to StateRollback regardless of current state\n    // TODO 4: Record abort reason in experiment results\n    // TODO 5: Ensure all faults are cleaned up\n    return nil\n}\n```\n\n#### Milestone 1 Checkpoint\n\nAfter implementing the fault injection framework (Milestone 1), you should be able to:\n\n**Command to test:**\n```bash\n# Build and run a test that injects network latency\ngo test ./internal/fault/network/... -v -run TestLatencyInjection\n```\n\n**Expected behavior:**\n1. Test should apply 200ms latency to loopback interface using `tc netem`\n2. Should measure actual latency increase via ping or HTTP request timing\n3. Should automatically clean up latency rule after test completes\n4. Should verify no residual `tc` rules remain after cleanup\n\n**Manual verification:**\n```bash\n# Before/during test execution, check tc rules\nsudo tc qdisc show dev lo\n\n# After test completes, verify cleanup\nsudo tc qdisc show dev lo | grep -q \"netem\" && echo \"FAIL: Rules not cleaned up\" || echo \"PASS: Cleanup successful\"\n```\n\n**Common early failures:**\n- **Symptom**: \"Permission denied\" when running `tc` commands\n  - **Cause**: Insufficient privileges (need CAP_NET_ADMIN or root)\n  - **Fix**: Run agent with appropriate capabilities or use sudo with controlled command execution\n  \n- **Symptom**: Fault affects the chaos platform itself\n  - **Cause**: Network fault applied to interface used by control plane\n  - **Fix**: Exclude localhost/control interfaces from fault targeting or run control plane on separate network namespace\n\n\n> **Milestone(s):** All milestones (foundational architecture for entire platform)\n\n## High-Level Architecture\n\n### Mental Model: The Chaos Control Room\n\nImagine a **space mission control center** coordinating multiple systems during a rocket launch. The mission control (our platform) doesn't physically interact with the rocket—instead, it sends precise commands to various systems (fault injectors), monitors telemetry data (metrics), and has emergency abort procedures (safety monitors). This separation of concerns ensures that a failure in one system (like a faulty monitor) doesn't cascade into uncontrolled chaos.\n\nSimilarly, our Chaos Engineering Platform follows a **command-and-control architecture** where:\n- A central **Experiment Controller** orchestrates the mission plan (experiment)\n- Remote **Fault Injectors** execute specific sabotage operations on target systems\n- Independent **Safety Monitors** watch critical telemetry streams and can trigger abort sequences\n- **Metrics Collectors** gather observational data before, during, and after the experiment\n- **Result Analyzers** compile mission reports to determine success or failure\n\nThis architectural separation provides three critical benefits: **safety** (faults can be rolled back even if the controller fails), **scalability** (multiple fault injectors can operate simultaneously), and **observability** (independent monitoring prevents single-point failures in the chaos system itself).\n\n### Component Diagram and Interactions\n\nThe platform consists of five core subsystems that work together to safely execute chaos experiments. Each component has a distinct responsibility and communicates through well-defined interfaces.\n\n![Chaos Platform System Overview](./diagrams/diag-system.svg)\n\n#### Core Components\n\n| Component | Responsibility | Key Data Owned | Interface Pattern |\n|-----------|----------------|----------------|-------------------|\n| **Experiment Controller** | Orchestrates experiment lifecycle, manages state transitions, coordinates other components | `Experiment` definitions, experiment state, execution history | REST API (external), gRPC (internal), state machine |\n| **Fault Injector** | Executes specific fault operations on target systems, ensures fault cleanup | Active fault registry, cleanup commands, fault status | gRPC service with `InjectFault()`, `Cleanup()` methods |\n| **Safety Monitor** | Continuously evaluates safety rules, triggers automatic rollback when thresholds breached | Safety rule configurations, current metric evaluations | Event stream consumer, publishes abort events |\n| **Metrics Collector** | Gathers and aggregates system metrics from observability sources | Metric time-series data, baseline calculations | Pull-based collection (Prometheus) and push-based (custom metrics) |\n| **Result Analyzer** | Compares pre-experiment, during-experiment, and post-experiment metrics, generates reports | Experiment results, statistical comparisons, pass/fail determinations | Batch processor with report generation |\n\n#### Component Interactions\n\nThe components communicate through two primary patterns:\n\n1. **Command/Response (Synchronous)**: For control operations where immediate acknowledgment is required\n2. **Event Stream (Asynchronous)**: For monitoring and safety operations where latency tolerance is higher\n\n**Key Interaction Flows:**\n\n**Experiment Execution Flow:**\n1. User submits an `Experiment` definition to the Experiment Controller via REST API\n2. Controller validates the experiment and transitions it to `StateBaselineValidation`\n3. Controller queries Metrics Collector for baseline metrics to verify steady state\n4. If baseline passes, Controller calls Fault Injector's `InjectFault()` method for each fault\n5. Fault Injector executes the fault (e.g., runs `tc netem` commands) and registers cleanup\n6. Controller transitions experiment to `StateMonitoring` and begins safety monitoring\n7. Safety Monitor continuously evaluates metrics against safety rules\n8. If safety breach detected, Safety Monitor publishes abort event to Controller\n9. Controller calls Fault Injector's `Cleanup()` method and transitions to `StateRollback`\n10. After fault cleanup, Controller transitions to `StateAnalysis`\n11. Result Analyzer compares metrics and generates final report\n12. Controller transitions to `StateCompleted` or `StateAborted` with detailed results\n\n**Safety Monitoring Flow:**\n1. Metrics Collector continuously scrapes system metrics from various sources\n2. Safety Monitor subscribes to relevant metric streams (error rates, latency, CPU usage)\n3. For each active experiment, Safety Monitor evaluates configured `SafetyRule` conditions\n4. If condition breaches for specified duration, Safety Monitor publishes abort event\n5. Experiment Controller receives abort event and initiates rollback sequence\n6. Cleanup is executed regardless of Controller state (via `CleanupEnsurer` persistence)\n\n#### Component Interface Details\n\n**Experiment Controller API:**\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `CreateExperiment` | `Experiment` definition | `ExperimentID`, error | Validates and stores new experiment |\n| `StartExperiment` | `experimentID string` | error | Begins execution of approved experiment |\n| `GetExperimentStatus` | `experimentID string` | `ExperimentStatus`, error | Returns current state and progress |\n| `AbortExperiment` | `experimentID string`, `reason string` | error | Manually aborts running experiment |\n| `ListExperiments` | `filter ExperimentFilter` | `[]Experiment`, error | Returns experiments matching criteria |\n\n**Fault Injector Service (gRPC):**\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `InjectFault` | `Fault`, `ExperimentID string` | `FaultID string`, error | Applies specified fault to target system |\n| `CleanupFault` | `FaultID string` | error | Removes previously injected fault |\n| `GetFaultStatus` | `FaultID string` | `FaultStatus`, error | Returns current state of fault |\n| `ListActiveFaults` | `ExperimentID string` | `[]FaultStatus`, error | Returns all active faults for experiment |\n\n**Safety Monitor Event Interface:**\n| Event Type | Fields | Published When |\n|------------|--------|----------------|\n| `SafetyBreach` | `ExperimentID string`, `Rule SafetyRule`, `MetricValue float64`, `Timestamp time.Time` | Safety rule condition breaches for configured duration |\n| `SafetyCleared` | `ExperimentID string`, `Rule SafetyRule`, `Timestamp time.Time` | Previously breached safety condition returns to normal |\n\n**Metrics Collector Query Interface:**\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `GetMetric` | `query string`, `start time.Time`, `end time.Time`, `step time.Duration` | `[]MetricPoint`, error | Returns time-series metric data |\n| `GetCurrentValue` | `query string` | `float64`, error | Returns most recent value for metric |\n| `ValidateThreshold` | `threshold MetricThreshold`, `duration string` | `bool`, error | Checks if metric meets threshold for duration |\n\n#### Component Deployment Architecture\n\nThe platform supports two deployment modes:\n\n1. **Centralized Deployment**: All components run as a single service (for development/testing)\n2. **Distributed Deployment**: Components deploy independently with the following topology:\n\n```\n                          +----------------------+\n                          |   Load Balancer      |\n                          |   (Optional)         |\n                          +----------+-----------+\n                                     | HTTP/REST\n                          +----------v-----------+\n                          |  Experiment Controller|\n                          |  (Stateless)          |\n                          +----------+-----------+\n                                     | gRPC\n            +------------------------+------------------------+\n            |                         |                       |\n+-----------v-----------+   +---------v----------+   +--------v----------+\n|   Fault Injector      |   |   Safety Monitor   |   |  Metrics Collector|\n|   (Per-node agent)    |   |   (Stateful)       |   |  (Stateless)      |\n+-----------------------+   +--------------------+   +-------------------+\n```\n\n> **Design Insight**: The Fault Injector must run with elevated privileges (CAP_NET_ADMIN, root access) on target nodes. To minimize attack surface, we deploy it as a separate, tightly-scoped daemon rather than bundling it with the Controller. This follows the principle of least privilege—the Controller itself doesn't need root access.\n\n#### Data Flow Between Components\n\n**Experiment Definition Flow:**\n```\nUser → [REST/HTTP] → Experiment Controller → [Validate] → [Store in DB]\n```\n\n**Fault Execution Flow:**\n```\nExperiment Controller → [gRPC] → Fault Injector → [Execute Command] → Target System\n                      ↑                                  ↓\n                [Acknowledge]                    [Register Cleanup]\n```\n\n**Safety Monitoring Flow:**\n```\nMetrics Collector → [Stream] → Safety Monitor → [Evaluate Rules] → [Publish Event]\n                                                     ↓\n                                            [Threshold Breach?] → [Abort Event]\n```\n\n**Result Compilation Flow:**\n```\nExperiment Controller → [Query] → Metrics Collector → [Time-series Data]\n         ↓\n[Generate Report] ← [Analyze] ← Result Analyzer\n```\n\n#### ADR: Centralized vs. Distributed Control Plane\n\n> **Decision: Hybrid Control Plane Architecture**\n> - **Context**: The platform needs to coordinate across multiple nodes (for network faults) but maintain safety guarantees even if the control plane experiences partial failures.\n> - **Options Considered**:\n>   1. Fully centralized: Single controller managing all nodes\n>   2. Fully decentralized: Each node autonomous with consensus\n>   3. Hybrid: Central coordinator with persistent fault registries\n> - **Decision**: Hybrid architecture with persistent `CleanupEnsurer` on each node\n> - **Rationale**: Central coordination simplifies experiment management and state tracking, while persistent local cleanup registries guarantee fault reversal even if the controller crashes or network partitions occur. This provides the safety of decentralization with the simplicity of central control.\n> - **Consequences**: Requires synchronization between controller and nodes, but local persistence ensures no \"orphaned faults\" remain after controller failure.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Fully Centralized | Simple to implement, consistent state | Single point of failure, network latency to nodes | No |\n| Fully Decentralized | Highly available, fault-tolerant | Complex coordination, eventual consistency issues | No |\n| Hybrid (Central + Local Persistence) | Safety guarantees, simpler than full decentralization | Requires sync mechanism, slightly more complex | **Yes** |\n\n#### Common Pitfalls in Architecture Design\n\n⚡ **Pitfall: Tight Coupling Between Controller and Fault Injection**\n- **Description**: Implementing fault injection logic directly in the Experiment Controller\n- **Why it's wrong**: Controller needs elevated privileges, becomes single point of failure, hard to scale\n- **How to fix**: Strict separation: Controller only orchestrates, Fault Injector executes with proper isolation\n\n⚡ **Pitfall: Missing Idempotency in Fault Operations**\n- **Description**: Fault injection commands that fail if retried (e.g., adding duplicate `tc` rules)\n- **Why it's wrong**: Network flakes or retries can leave system in inconsistent state\n- **How to fix**: Design all fault operations as idempotent: \"ensure this fault is active\" not \"add this fault\"\n\n⚡ **Pitfall: Synchronous Safety Monitoring**\n- **Description**: Controller polls safety status in main experiment loop\n- **Why it's wrong**: Adds latency to abort decisions, blocks experiment progression\n- **How to fix**: Event-driven safety monitoring with publish/subscribe pattern\n\n⚡ **Pitfall: No Cleanup Guarantees**\n- **Description**: Assuming controller will always be available to clean up faults\n- **Why it's wrong**: Controller crashes leave systems permanently impaired\n- **How to fix**: Persistent `CleanupEnsurer` that records faults before applying them\n\n### Recommended File and Module Structure\n\n> **Principle**: Organize by domain responsibility, not by technical layer. Each package should have a single, clear purpose and minimal dependencies on other packages.\n\n```\nchaos-platform/\n├── cmd/                          # Entry points for executables\n│   ├── controller/               # Experiment Controller main\n│   │   ├── main.go               # CLI parsing, config loading\n│   │   └── Dockerfile            # Container build file\n│   ├── injector-agent/           # Fault Injector daemon\n│   │   ├── main.go               # Agent startup, gRPC server\n│   │   └── Dockerfile            # Privileged container\n│   ├── safety-monitor/           # Safety Monitor service\n│   │   ├── main.go               # Metric consumer, event publisher\n│   │   └── Dockerfile\n│   └── metrics-collector/        # Optional: custom metrics collector\n│       ├── main.go\n│       └── Dockerfile\n├── internal/                     # Private application code\n│   ├── api/                      # External API definitions\n│   │   ├── v1/                   # API versioning\n│   │   │   ├── types.go          # Request/response structs\n│   │   │   ├── handlers.go       # HTTP handlers\n│   │   │   └── router.go         # Route definitions\n│   │   └── middleware/           # Auth, logging, validation\n│   ├── controller/               # Experiment orchestration logic\n│   │   ├── orchestrator.go       # `Orchestrator` struct and methods\n│   │   ├── state_machine.go      # `executeStateMachine` implementation\n│   │   ├── scheduler.go          # Experiment scheduling\n│   │   └── cleanup.go            # Cleanup coordination logic\n│   ├── fault/                    # Fault injection domain\n│   │   ├── injector.go           # `Injector` interface implementation\n│   │   ├── registry.go           # Fault type registry\n│   │   ├── types.go              # `Fault`, `FaultParams`, etc.\n│   │   ├── network/              # Network fault implementations\n│   │   │   ├── latency.go        # Network latency injection\n│   │   │   ├── packet_loss.go    # Packet loss simulation\n│   │   │   └── partition.go      # Network partition\n│   │   ├── resource/             # Resource fault implementations\n│   │   │   ├── cpu_stress.go     # CPU exhaustion\n│   │   │   ├── memory_pressure.go # Memory pressure\n│   │   │   └── disk_fill.go      # Disk space exhaustion\n│   │   └── process/              # Process faults\n│   │       ├── kill.go           # Process termination\n│   │       └── restart.go        # Process restart simulation\n│   ├── safety/                   # Safety monitoring domain\n│   │   ├── monitor.go            # `Monitor` implementation\n│   │   ├── evaluator.go          # Safety rule evaluation\n│   │   ├── events.go             # Event publishing\n│   │   └── rules.go              # `SafetyRule` validation\n│   ├── metrics/                  # Metrics collection domain\n│   │   ├── collector.go          # `Collector` interface\n│   │   ├── prometheus.go         # Prometheus implementation\n│   │   ├── aggregator.go         # Metric aggregation\n│   │   └── baseline.go           # Baseline calculation\n│   ├── analysis/                 # Result analysis domain\n│   │   ├── analyzer.go           # `Analyzer` implementation\n│   │   ├── reporter.go           # Report generation\n│   │   └── statistical.go        # Statistical comparisons\n│   ├── persistence/              # Data persistence layer\n│   │   ├── experiment_store.go   # Experiment CRUD\n│   │   ├── cleanup_store.go      # `CleanupEnsurer` implementation\n│   │   └── metrics_store.go      # Metric data storage\n│   ├── gameday/                  # GameDay automation (Milestone 3)\n│   │   ├── scenario.go           # Scenario execution\n│   │   ├── runbook.go            # Runbook automation\n│   │   └── sequencer.go          # Multi-experiment sequencing\n│   └── types/                    # Shared type definitions\n│       ├── experiment.go         # `Experiment`, `Hypothesis`, etc.\n│       ├── fault.go              # `Fault`, `FaultType`, etc.\n│       ├── metrics.go            # `MetricThreshold`, etc.\n│       └── common.go             # Enums, constants\n├── pkg/                          # Public libraries (if any)\n│   └── chaosclient/              # Go client library for API\n├── api/                          # Protocol definitions\n│   ├── protos/                   # gRPC protocol buffers\n│   │   ├── fault_injector.proto  # Fault injector service\n│   │   └── safety_monitor.proto  # Safety monitoring events\n│   └── openapi/                  # OpenAPI/Swagger specs\n│       └── v1.yaml               # REST API specification\n├── configs/                      # Configuration files\n│   ├── controller.yaml           # Controller configuration\n│   ├── injector.yaml             # Injector agent configuration\n│   └── safety.yaml               # Safety monitor configuration\n├── deployments/                  # Deployment manifests\n│   ├── kubernetes/               # K8s manifests for all components\n│   │   ├── controller.yaml\n│   │   ├── injector-daemonset.yaml\n│   │   └── safety-monitor.yaml\n│   └── docker-compose/           # Local development setup\n│       └── docker-compose.yaml\n├── scripts/                      # Utility scripts\n│   ├── install-dependencies.sh   # System dependency setup\n│   ├── generate-protos.sh        # Protocol buffer generation\n│   └── preflight-check.sh        # System validation before experiments\n├── tests/                        # Integration and e2e tests\n│   ├── integration/              # Component integration tests\n│   └── e2e/                      # End-to-end scenario tests\n├── examples/                     # Example configurations\n│   ├── experiments/              # Example experiment definitions\n│   └── scenarios/                # Example GameDay scenarios\n├── go.mod                        # Go module definition\n├── go.sum                        # Go dependencies checksum\n├── Makefile                      # Build, test, deploy commands\n└── README.md                     # Project documentation\n```\n\n#### Package Dependency Graph\n\nTo maintain clean architecture, follow these dependency rules:\n\n```\ncmd/* (entry points)\n  ↓\ninternal/api (depends on internal/types)\n  ↓\ninternal/controller (depends on internal/types, internal/fault, internal/safety, internal/metrics)\n  ↓\ninternal/fault (depends on internal/types)\n  ↓\ninternal/safety (depends on internal/types, internal/metrics)\n  ↓\ninternal/metrics (depends on internal/types)\n  ↓\ninternal/analysis (depends on internal/types, internal/metrics)\n  ↓\ninternal/persistence (depends on internal/types)\n  ↓\ninternal/types (no dependencies)\n```\n\n> **Key Principle**: Dependencies flow inward toward domain types. The `internal/types` package has zero dependencies and contains only data structures. This enables easy testing and prevents circular dependencies.\n\n#### Module Design Rationale\n\n**Why separate `internal/fault` from `internal/controller`?**\n- Fault injection requires system-level operations (root access, `tc` commands)\n- Controller should remain unprivileged for security\n- Enables independent testing of fault logic\n- Allows replacement of fault implementations (e.g., different network manipulation tools)\n\n**Why `internal/types` as a separate package?**\n- Shared by all other packages without import cycles\n- Serialization/deserialization logic centralized\n- Versioning of data structures managed in one place\n- Generated code (protobuf, OpenAPI) can reference these types\n\n**Why `cmd/` structure with multiple binaries?**\n- Each component has different deployment requirements\n- Fault Injector needs privileged containers, others don't\n- Independent scaling of components\n- Separate configuration and dependency management\n\n#### Build and Deployment Configuration\n\n**Multi-stage Docker builds** for each component:\n- **Controller**: Lightweight Go binary on distroless base\n- **Injector**: Privileged container with `iproute2`, `stress-ng`, `iptables` tools\n- **Safety Monitor**: Event-driven service with metric client libraries\n\n**Kubernetes Deployment Strategy:**\n- Controller: Deployment with 3 replicas for high availability\n- Injector: DaemonSet (one per node) with `hostNetwork: true` and privileged security context\n- Safety Monitor: StatefulSet with persistent storage for rule evaluations\n- Metrics Collector: Optional sidecar or separate deployment depending on metrics volume\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| Component | Simple Option (Getting Started) | Advanced Option (Production) |\n|-----------|---------------------------------|------------------------------|\n| **API Transport** | HTTP REST with JSON (Go's `net/http`) | gRPC with Protocol Buffers + HTTP/JSON gateway |\n| **Metrics Collection** | Prometheus client library + direct queries | Multiple adapters (Prometheus, Datadog, Cloud Monitoring) |\n| **Persistence** | SQLite (embedded) + file-based cleanup registry | PostgreSQL + Redis for caching |\n| **Event System** | Go channels + in-memory pub/sub | Apache Kafka or NATS for distributed events |\n| **Configuration** | YAML files + environment variables | Config management with HashiCorp Consul |\n| **Container Runtime** | Docker Compose for local development | Kubernetes with Helm charts for production |\n\n#### Starter Code for Project Structure\n\n**File: `internal/types/experiment.go`** (Complete foundational code)\n```go\npackage types\n\nimport (\n\t\"time\"\n)\n\n// ExperimentStatus represents the current state of an experiment\ntype ExperimentStatus string\n\nconst (\n\tStateDraft              ExperimentStatus = \"DRAFT\"\n\tStateBaselineValidation ExperimentStatus = \"BASELINE_VALIDATION\"\n\tStateInjecting          ExperimentStatus = \"INJECTING\"\n\tStateMonitoring         ExperimentStatus = \"MONITORING\"\n\tStateRollback           ExperimentStatus = \"ROLLBACK\"\n\tStateAnalysis           ExperimentStatus = \"ANALYSIS\"\n\tStateCompleted          ExperimentStatus = \"COMPLETED\"\n\tStateAborted            ExperimentStatus = \"ABORTED\"\n)\n\n// Experiment defines a chaos experiment\ntype Experiment struct {\n\tID           string        `json:\"id\" yaml:\"id\"`\n\tName         string        `json:\"name\" yaml:\"name\"`\n\tDescription  string        `json:\"description\" yaml:\"description\"`\n\tHypothesis   Hypothesis    `json:\"hypothesis\" yaml:\"hypothesis\"`\n\tFaults       []Fault       `json:\"faults\" yaml:\"faults\"`\n\tSchedule     Schedule      `json:\"schedule\" yaml:\"schedule\"`\n\tDuration     time.Duration `json:\"duration\" yaml:\"duration\"`\n\tBlastRadius  BlastRadius   `json:\"blastRadius\" yaml:\"blastRadius\"`\n\tSafetyRules  []SafetyRule  `json:\"safetyRules\" yaml:\"safetyRules\"`\n\tStatus       ExperimentStatus `json:\"status\" yaml:\"status\"`\n\tCreatedAt    time.Time     `json:\"createdAt\" yaml:\"createdAt\"`\n\tStartedAt    *time.Time    `json:\"startedAt,omitempty\" yaml:\"startedAt,omitempty\"`\n\tCompletedAt  *time.Time    `json:\"completedAt,omitempty\" yaml:\"completedAt,omitempty\"`\n}\n\n// Hypothesis defines the steady-state hypothesis for an experiment\ntype Hypothesis struct {\n\tDescription string            `json:\"description\" yaml:\"description\"`\n\tMetrics     []MetricThreshold `json:\"metrics\" yaml:\"metrics\"`\n}\n\n// MetricThreshold defines acceptable bounds for a metric\ntype MetricThreshold struct {\n\tName     string   `json:\"name\" yaml:\"name\"`\n\tQuery    string   `json:\"query\" yaml:\"query\"`\n\tMin      *float64 `json:\"min,omitempty\" yaml:\"min,omitempty\"`\n\tMax      *float64 `json:\"max,omitempty\" yaml:\"max,omitempty\"`\n\tDuration string   `json:\"duration\" yaml:\"duration\"` // e.g., \"5m\", \"30s\"\n}\n\n// Fault defines a single fault to inject\ntype Fault struct {\n\tType       FaultType   `json:\"type\" yaml:\"type\"`\n\tTarget     Target      `json:\"target\" yaml:\"target\"`\n\tParameters FaultParams `json:\"parameters\" yaml:\"parameters\"`\n}\n\n// BlastRadius limits the scope of an experiment\ntype BlastRadius struct {\n\tPercentage  float64  `json:\"percentage\" yaml:\"percentage\"`\n\tServices    []string `json:\"services,omitempty\" yaml:\"services,omitempty\"`\n\tNamespaces  []string `json:\"namespaces,omitempty\" yaml:\"namespaces,omitempty\"`\n}\n\n// SafetyRule defines conditions for automatic experiment abort\ntype SafetyRule struct {\n\tMetric    string `json:\"metric\" yaml:\"metric\"`\n\tCondition string `json:\"condition\" yaml:\"condition\"` // e.g., \"> 5%\", \"< 200ms\"\n\tDuration  string `json:\"duration\" yaml:\"duration\"`   // How long condition must hold before abort\n}\n```\n\n**File: `cmd/controller/main.go`** (Entry point skeleton)\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\t\n\t\"chaos-platform/internal/api/v1\"\n\t\"chaos-platform/internal/controller\"\n\t\"chaos-platform/internal/persistence\"\n\t// Additional imports as needed\n)\n\nfunc main() {\n\t// TODO 1: Load configuration from file and environment variables\n\t// TODO 2: Initialize persistence layer (experiment store, cleanup registry)\n\t// TODO 3: Initialize components: metrics collector, safety monitor, fault injector client\n\t// TODO 4: Create Orchestrator instance with all dependencies\n\t// TODO 5: Set up HTTP server with API routes\n\t// TODO 6: Start background goroutines for experiment scheduling\n\t// TODO 7: Implement graceful shutdown on SIGTERM/SIGINT\n\t// TODO 8: Run HTTP server with health checks\n\t\n\tlog.Println(\"Chaos Platform Controller starting...\")\n\t\n\t// Example structure:\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\t\n\t// Setup graceful shutdown\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)\n\t\n\tgo func() {\n\t\tsig := <-sigChan\n\t\tlog.Printf(\"Received signal: %v, initiating shutdown...\", sig)\n\t\tcancel()\n\t\t// Give services time to clean up\n\t\ttime.Sleep(5 * time.Second)\n\t\tos.Exit(0)\n\t}()\n\t\n\t// TODO: Start server and block\n\tserver := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: setupRouter(), // Implement this\n\t}\n\t\n\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\tlog.Fatalf(\"HTTP server error: %v\", err)\n\t}\n}\n\nfunc setupRouter() http.Handler {\n\t// TODO: Create router, add middleware, register API routes\n\t// Use internal/api/v1 handlers\n\treturn nil\n}\n```\n\n**File: `internal/controller/orchestrator.go`** (Core logic skeleton)\n```go\npackage controller\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n\t\n\t\"chaos-platform/internal/types\"\n\t\"chaos-platform/internal/metrics\"\n\t\"chaos-platform/internal/safety\"\n\t\"chaos-platform/internal/fault\"\n)\n\n// Orchestrator manages the lifecycle of chaos experiments\ntype Orchestrator struct {\n\tmu              sync.RWMutex\n\texperiments     map[string]*ExperimentInstance\n\tmetricsCollector metrics.Collector\n\tsafetyMonitor   safety.Monitor\n\tfaultInjector   fault.Injector\n\t// Additional fields as needed\n}\n\n// ExperimentInstance tracks runtime state of an experiment\ntype ExperimentInstance struct {\n\tExperiment     types.Experiment\n\tState          types.ExperimentStatus\n\tCancelFunc     context.CancelFunc\n\tMetricsBaseline map[string]float64\n\tResultsChan    chan<- types.ExperimentResult\n\t// Additional runtime fields\n}\n\n// StartExperiment begins execution of a defined experiment\nfunc (o *Orchestrator) StartExperiment(exp types.Experiment, resultsChan chan<- types.ExperimentResult) error {\n\t// TODO 1: Validate experiment is in DRAFT state\n\t// TODO 2: Create ExperimentInstance with initial state\n\t// TODO 3: Store instance in orchestrator's map\n\t// TODO 4: Create context with cancellation for experiment\n\t// TODO 5: Launch executeStateMachine in a goroutine\n\t// TODO 6: Return immediately (experiment runs asynchronously)\n\treturn nil\n}\n\n// executeStateMachine runs the experiment through its lifecycle\nfunc (o *Orchestrator) executeStateMachine(instance *ExperimentInstance) {\n\t// TODO 1: Transition to BASELINE_VALIDATION\n\t// TODO 2: Collect baseline metrics using metricsCollector\n\t// TODO 3: Validate hypothesis against baseline\n\t// TODO 4: If validation fails, transition to ABORTED and return\n\t// TODO 5: Transition to INJECTING\n\t// TODO 6: For each fault in experiment, call faultInjector.InjectFault()\n\t// TODO 7: Register each fault with cleanup ensurer\n\t// TODO 8: Transition to MONITORING\n\t// TODO 9: Start safety monitoring for experiment duration\n\t// TODO 10: If safety breach detected, transition to ROLLBACK\n\t// TODO 11: If duration elapsed, transition to ROLLBACK\n\t// TODO 12: Clean up all faults\n\t// TODO 13: Transition to ANALYSIS\n\t// TODO 14: Collect post-experiment metrics\n\t// TODO 15: Analyze results compared to baseline\n\t// TODO 16: Generate experiment result\n\t// TODO 17: Send result to resultsChan\n\t// TODO 18: Transition to COMPLETED or ABORTED\n}\n\n// AbortExperiment forcefully stops an experiment and rolls back faults\nfunc (o *Orchestrator) AbortExperiment(experimentID string, reason string) error {\n\t// TODO 1: Look up experiment instance\n\t// TODO 2: If experiment is in injectable state (INJECTING, MONITORING), cancel context\n\t// TODO 3: Transition to ROLLBACK state\n\t// TODO 4: Clean up all faults for this experiment\n\t// TODO 5: Transition to ABORTED state\n\t// TODO 6: Record abort reason\n\treturn nil\n}\n```\n\n#### Language-Specific Implementation Hints\n\n**Go-Specific Patterns:**\n- Use `context.Context` for cancellation across all goroutines\n- Implement interfaces for testability: `type Injector interface { InjectFault(...) }`\n- Use `sync.Map` for concurrent access to experiment registry if high contention expected\n- Leverage `time.Ticker` for periodic safety checks rather than `time.Sleep`\n- Use `os/exec` for running system commands (like `tc`) with proper timeout handling\n\n**Error Handling Strategy:**\n- Use sentinel errors for expected failure cases: `var ErrExperimentNotFound = errors.New(\"experiment not found\")`\n- Wrap system command errors with context: `fmt.Errorf(\"tc command failed: %w\", err)`\n- Implement retry with exponential backoff for transient failures (network calls to metrics)\n\n**Concurrency Patterns:**\n- One goroutine per experiment (managed by orchestrator)\n- Worker pool for fault injection (limits concurrent system operations)\n- Channel-based communication between components (non-blocking where possible)\n\n#### Milestone Checkpoint: Architecture Validation\n\nAfter setting up the basic structure:\n\n```bash\n# Build all components to verify dependencies\ngo build ./cmd/controller/\ngo build ./cmd/injector-agent/\ngo build ./cmd/safety-monitor/\n\n# Run unit tests for core types\ngo test ./internal/types/...\n\n# Verify the project structure compiles\ngo build ./...\n\n# Expected output: No errors, all binaries created in current directory\n```\n\n**Manual Verification Steps:**\n1. Check that `internal/types` has no dependencies on other packages\n2. Verify each `cmd/` directory has a proper `main.go` with package `main`\n3. Ensure `go.mod` declares correct module path\n4. Test that controller can be imported without circular dependency errors\n\n**Common Build Issues:**\n- **Symptom**: `import cycle not allowed`\n  - **Cause**: Two-way dependency between packages\n  - **Fix**: Refactor to move shared types to `internal/types`, use interfaces\n- **Symptom**: `undefined: types.Experiment`\n  - **Cause**: Incorrect import path or package name mismatch\n  - **Fix**: Check `go.mod` module name matches import paths\n\n---\n\n\n> **Milestone(s):** All milestones (foundational data structures for entire platform)\n\n## Data Model\n\n> **Mental Model: The Scientific Experiment Blueprint**\n> Think of the chaos engineering platform as a sophisticated laboratory that runs controlled experiments on complex systems. Just like a scientific experiment needs a **protocol** (defining the hypothesis, materials, methods, and analysis plan), our platform needs structured data models to represent every aspect of chaos experiments. The data model serves as the standardized blueprint that ensures experiments are well-defined, repeatable, analyzable, and—most importantly—safe.\n\nThis section defines the core data structures that capture the complete lifecycle of chaos engineering: from experiment design and fault specification to hypothesis validation and result analysis. These structures form the backbone of the entire platform, ensuring consistency across components and enabling the safe, controlled injection of failures.\n\n![Core Data Model Relationships](./diagrams/diag-datamodel.svg)\n\n### Experiment and Fault Definitions\n\n> **Mental Model: The Recipe for Controlled Chaos**\n> An experiment definition is like a **recipe for controlled chaos**. It specifies exactly what ingredients (faults) to use, what system to test, what outcome to expect, and what safety precautions to take. Just as a recipe needs precise measurements and steps to ensure consistent results, our experiment definitions need structured fields to guarantee reproducible, safe experiments.\n\nThe experiment data model captures everything needed to define, execute, and analyze a chaos experiment. At its core, an `Experiment` combines a **steady-state hypothesis** (what we expect to remain true) with a set of **faults** (what we're going to break) and **safety controls** (how we'll prevent catastrophe).\n\n#### Experiment Definition\n\nThe `Experiment` struct represents a complete chaos experiment definition, from hypothesis through execution to results:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `string` | Unique identifier for the experiment, typically a UUID. Used to reference the experiment across all system components and for idempotent operations. |\n| `Name` | `string` | Human-readable name for the experiment (e.g., \"Payment Service Latency Test\"). Used for display and organization purposes. |\n| `Description` | `string` | Detailed description of the experiment's purpose, what it tests, and any important context. Helps future maintainers understand why the experiment exists. |\n| `Hypothesis` | `Hypothesis` | The steady-state hypothesis being tested. Defines the expected system behavior as a set of metric thresholds that should remain true during the experiment. |\n| `Faults` | `[]Fault` | Ordered list of faults to inject during the experiment. Multiple faults can be specified to simulate complex failure scenarios. The order matters—some faults may need to be applied sequentially. |\n| `Schedule` | `Schedule` | When and how often to run the experiment. Can be immediate, one-time future execution, or recurring (e.g., \"every Monday at 2 AM\"). |\n| `Duration` | `time.Duration` | How long to keep faults active once injected. After this duration, the system should automatically roll back faults even if no safety breach is detected. |\n| `BlastRadius` | `BlastRadius` | Scope limitation for the experiment. Defines what percentage of traffic or which specific services/namespaces are affected, ensuring experiments don't impact the entire system. |\n| `SafetyRules` | `[]SafetyRule` | Automatic abort conditions. If any of these rules evaluate to true during the experiment, the system immediately rolls back all faults and marks the experiment as aborted. |\n| `Status` | `ExperimentStatus` | Current execution state of the experiment. Tracks progress through the experiment lifecycle (DRAFT → BASELINE_VALIDATION → INJECTING → etc.). |\n| `CreatedAt` | `time.Time` | Timestamp when the experiment was first defined. Used for auditing and to determine experiment age. |\n| `StartedAt` | `*time.Time` | Timestamp when experiment execution began (nil if not started). Used to calculate experiment duration and for timing analysis. |\n| `CompletedAt` | `*time.Time` | Timestamp when experiment reached final state (COMPLETED or ABORTED; nil if still in progress). Used to determine when cleanup can occur. |\n\n#### Hypothesis Definition\n\nThe `Hypothesis` struct formalizes the expected system behavior that should remain true despite the injected faults:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Description` | `string` | Natural language description of what should remain true (e.g., \"User checkout flow completes within 2 seconds with < 0.5% error rate\"). |\n| `Metrics` | `[]MetricThreshold` | Quantitative definitions of steady state. Each metric threshold specifies what \"normal\" looks like for a specific system metric. |\n\n#### Metric Threshold Definition\n\nThe `MetricThreshold` struct provides a precise, query-based definition of acceptable system behavior:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Name` | `string` | Descriptive name for this metric threshold (e.g., \"API Latency p95\"). Used in reports and UI displays. |\n| `Query` | `string` | Metric query expression that fetches the relevant time-series data. Format depends on the metrics backend (e.g., PromQL, SQL, or custom). |\n| `Min` | `*float64` | Minimum acceptable value (inclusive). If nil, no lower bound is enforced. Use for metrics like \"requests per second\" where you need at least some throughput. |\n| `Max` | `*float64` | Maximum acceptable value (inclusive). If nil, no upper bound is enforced. Use for metrics like \"latency\" or \"error rate\" where values should not exceed thresholds. |\n| `Duration` | `string` | Time window over which the metric must stay within bounds (e.g., \"30s\", \"2m\"). This prevents transient spikes from triggering false aborts and ensures sustained violations are detected. |\n\n#### Fault Definition\n\nThe `Fault` struct defines a specific failure to inject into the system:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Type` | `FaultType` | Category of fault being injected. Determines which fault injection implementation to use. Common types: LATENCY, PACKET_LOSS, PROCESS_KILL, CPU_STRESS, MEMORY_STRESS, NETWORK_PARTITION. |\n| `Target` | `Target` | What system component to affect. Specifies the service, pod, container, or network path where the fault should be applied. |\n| `Parameters` | `FaultParams` | Configuration specific to this fault type. For latency: delay amount; for packet loss: percentage; for process kill: signal type; etc. |\n\n#### Blast Radius Definition\n\nThe `BlastRadius` struct limits the scope of an experiment to prevent uncontrolled outages:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Percentage` | `float64` | Percentage of traffic or instances to affect (0.0 to 100.0). For example, 10.0 means only 10% of requests or 10% of service instances experience the fault. |\n| `Services` | `[]string` | Specific service names to target (empty means all services). Provides precise targeting for experiments focused on particular microservices. |\n| `Namespaces` | `[]string` | Kubernetes namespaces to target (empty means all namespaces). Enables environment-specific testing (e.g., only staging namespaces). |\n\n> **Design Insight: The Importance of Blast Radius**\n> Blast radius is the most critical safety mechanism in chaos engineering. Without it, a single experiment could take down your entire production system. By default, new experiments should have a very small blast radius (e.g., 1% of traffic) that gradually increases as confidence grows.\n\n#### Safety Rule Definition\n\nThe `SafetyRule` struct defines automatic abort conditions that protect the system:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Metric` | `string` | Name of the metric to monitor (must match a `MetricThreshold.Name` from the hypothesis). |\n| `Condition` | `string` | Boolean expression that triggers abort when true (e.g., \"value > 0.05\" for error rate > 5%). The expression can reference the metric's current value as `value`. |\n| `Duration` | `string` | How long the condition must remain true before triggering abort (e.g., \"30s\"). Prevents transient spikes from unnecessarily aborting experiments. |\n\n#### Schedule Definition\n\nWhile not explicitly defined in the naming conventions, the `Schedule` type (referenced in `Experiment`) typically follows this structure:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Type` | `string` | Schedule type: \"immediate\", \"one_time\", or \"cron\". |\n| `When` | `*time.Time` | For \"one_time\" schedules: when to run the experiment. For \"immediate\": nil. |\n| `CronExpression` | `string` | For \"cron\" schedules: cron expression defining recurrence (e.g., \"0 2 * * 1\" for weekly Monday at 2 AM). |\n| `TimeZone` | `string` | Timezone for cron schedules (e.g., \"America/New_York\"). |\n\n#### Target Definition\n\nThe `Target` struct (referenced in `Fault`) specifies where to apply a fault:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Type` | `string` | Target type: \"service\", \"pod\", \"node\", \"network_path\", or \"process\". |\n| `Selector` | `map[string]string` | Key-value pairs for selecting the target. For services: {\"service\": \"payment-service\"}. For pods: {\"namespace\": \"production\", \"label\": \"app=payment\"}. |\n| `Count` | `int` | Number of instances to target (if applicable). For percentage-based selection, use blast radius percentage instead. |\n\n#### Fault Parameters Definition\n\nThe `FaultParams` type (referenced in `Fault`) is a flexible structure that varies by fault type. We represent it as a map with type-specific fields:\n\n| Fault Type | Example Parameters | Description |\n|------------|-------------------|-------------|\n| `LATENCY` | `{\"delay_ms\": \"200\", \"jitter_ms\": \"50\", \"correlation\": \"0.5\"}` | Adds network delay with optional jitter and correlation between packets. |\n| `PACKET_LOSS` | `{\"percentage\": \"10\", \"correlation\": \"0.3\"}` | Drops a percentage of network packets with optional correlation. |\n| `PROCESS_KILL` | `{\"signal\": \"SIGKILL\", \"process_name\": \"payment-processor\"}` | Kills a specific process with the given signal. |\n| `CPU_STRESS` | `{\"utilization_percent\": \"90\", \"duration\": \"2m\"}` | Stresses CPU to target utilization percentage for given duration. |\n| `MEMORY_STRESS` | `{\"bytes\": \"1073741824\", \"duration\": \"1m\"}` | Allocates specified bytes of memory for given duration. |\n| `NETWORK_PARTITION` | `{\"direction\": \"both\", \"from_selector\": \"...\", \"to_selector\": \"...\"}` | Partitions network between two sets of pods/services. |\n\n### Metrics and Results\n\n> **Mental Model: The Laboratory Notebook**\n> Just as a scientist meticulously records observations, measurements, and conclusions in a laboratory notebook, our platform captures detailed metrics and results for every experiment. This \"notebook\" serves multiple purposes: verifying the hypothesis, understanding system behavior under stress, identifying weaknesses, and providing evidence for improvements.\n\nThe results data model captures what actually happened during an experiment—both the quantitative metrics and qualitative observations. This enables evidence-based decisions about system resilience.\n\n#### Experiment Result Definition\n\nThe `ExperimentResult` struct captures the complete outcome of an experiment:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ExperimentID` | `string` | References the original experiment definition. Links results back to the hypothesis and configuration. |\n| `Status` | `ResultStatus` | Overall outcome: \"PASS\" (hypothesis confirmed), \"FAIL\" (hypothesis rejected), \"ABORTED\" (safety triggered), or \"ERROR\" (platform failure). |\n| `StartTime` | `time.Time` | When experiment execution began (copied from `Experiment.StartedAt`). |\n| `EndTime` | `time.Time` | When experiment reached final state (copied from `Experiment.CompletedAt`). |\n| `HypothesisValidation` | `HypothesisValidation` | Detailed validation results for each metric in the hypothesis, showing before/during/after comparisons. |\n| `SafetyEvents` | `[]SafetyEvent` | List of safety rule evaluations and any abort triggers that occurred. |\n| `Observations` | `[]Observation` | Human observations recorded during the experiment (by automated checks or human observers). |\n| `FaultInjections` | `[]FaultInjectionRecord` | Records of each fault that was injected, including timing and any errors. |\n| `Error` | `*string` | If the experiment ended in ERROR state, this captures what went wrong (e.g., \"failed to inject fault: permission denied\"). |\n\n#### Hypothesis Validation Definition\n\nThe `HypothesisValidation` struct provides detailed statistical validation of the hypothesis:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `MetricResults` | `[]MetricValidationResult` | Validation results for each metric threshold in the hypothesis. |\n| `Overall` | `bool` | Whether ALL metric thresholds were satisfied (true = hypothesis confirmed). |\n\n#### Metric Validation Result Definition\n\nThe `MetricValidationResult` struct shows how a specific metric performed:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `MetricName` | `string` | Name of the metric being validated (from `MetricThreshold.Name`). |\n| `Threshold` | `MetricThreshold` | The threshold definition that was tested. |\n| `Before` | `MetricSample` | Metric values during the baseline period (before fault injection). |\n| `During` | `MetricSample` | Metric values during fault injection. |\n| `After` | `MetricSample` | Metric values during recovery period (after fault cleanup). |\n| `Passed` | `bool` | Whether the metric stayed within thresholds during the experiment. |\n| `ViolationPeriods` | `[]TimeRange` | Time ranges when the metric was outside acceptable thresholds (empty if passed). |\n\n#### Metric Sample Definition\n\nThe `MetricSample` struct captures statistical summaries of metric values:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Min` | `float64` | Minimum observed value during the period. |\n| `Max` | `float64` | Maximum observed value during the period. |\n| `Mean` | `float64` | Average value during the period. |\n| `P95` | `float64` | 95th percentile value (useful for latency metrics). |\n| `DataPoints` | `int` | Number of data points collected. |\n| `Duration` | `time.Duration` | Time period covered by this sample. |\n\n#### Safety Event Definition\n\nThe `SafetyEvent` struct records safety rule evaluations:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Rule` | `SafetyRule` | The safety rule that was evaluated. |\n| `Timestamp` | `time.Time` | When the evaluation occurred. |\n| `Value` | `float64` | Metric value at evaluation time. |\n| `Triggered` | `bool` | Whether the rule condition was met (true = should abort). |\n| `DurationMet` | `bool` | Whether the condition held for the required duration. |\n| `ActionTaken` | `string` | What action was taken if triggered (e.g., \"abort_initiated\", \"logged_only\"). |\n\n#### Observation Definition\n\nThe `Observation` struct captures human or automated observations:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Time` | `time.Time` | When the observation was recorded. |\n| `Source` | `string` | Who/what recorded it: \"automated_check\", \"human_observer:alice\", \"system_log\". |\n| `Message` | `string` | The observation text (e.g., \"User interface became unresponsive at 14:32\"). |\n| `Severity` | `string` | Severity level: \"info\", \"warning\", \"error\", \"critical\". |\n\n#### Fault Injection Record Definition\n\nThe `FaultInjectionRecord` tracks the execution of a specific fault:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `FaultID` | `string` | Unique identifier for this fault instance. |\n| `FaultType` | `FaultType` | Type of fault injected. |\n| `Target` | `string` | What was targeted (human-readable description). |\n| `Parameters` | `map[string]string` | Fault parameters used. |\n| `InjectTime` | `time.Time` | When the fault was successfully injected. |\n| `CleanupTime` | `*time.Time` | When the fault was cleaned up (nil if not yet cleaned). |\n| `Status` | `string` | Injection status: \"pending\", \"injected\", \"cleanup_failed\", \"cleaned_up\". |\n| `Error` | `*string` | Any error that occurred during injection or cleanup. |\n\n#### Cleanup Ensurer and Fault Record\n\nThe `CleanupEnsurer` and `FaultRecord` types provide crash-safe fault cleanup:\n\n**CleanupEnsurer:**\n| Field | Type | Description |\n|-------|------|-------------|\n| `mu` | `sync.RWMutex` | Mutex for thread-safe access to the active faults map. |\n| `filePath` | `string` | Path to the persistence file where active faults are saved. |\n| `activeFaults` | `map[string]FaultRecord` | Map of fault ID to fault record for all currently active faults. |\n\n**FaultRecord:**\n| Field | Type | Description |\n|-------|------|-------------|\n| `ExperimentID` | `string` | Which experiment this fault belongs to. |\n| `FaultID` | `string` | Unique identifier for this fault instance. |\n| `Target` | `string` | Target system component (for display and cleanup). |\n| `FaultType` | `string` | Type of fault (for determining cleanup method). |\n| `InjectTime` | `time.Time` | When the fault was injected. |\n| `CleanupCmd` | `string` | Command or method to clean up this fault (e.g., \"tc qdisc del dev eth0 root\"). |\n\n> **ADR: Structured vs. Flexible Fault Parameters**\n> - **Context**: Faults have widely varying configuration needs. Latency needs delay amounts, packet loss needs percentages, process kill needs signal types.\n> - **Options Considered**:\n>   1. **Strictly typed structs**: Each fault type has its own Go struct with validated fields.\n>   2. **Flexible map**: All faults use `map[string]string` for parameters.\n>   3. **Protocol Buffers oneof**: Use Protobuf's oneof to represent different parameter types.\n> - **Decision**: Use flexible `map[string]string` for parameters in the core data model.\n> - **Rationale**: This provides maximum flexibility for new fault types without requiring schema changes. Validation happens in the fault injector implementation, not the data model. The map is easy to serialize/deserialize and pass between components.\n> - **Consequences**: Parameters are not type-checked at compile time, requiring runtime validation. Documentation becomes crucial for knowing what parameters each fault type expects.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Strictly typed structs | Compile-time type safety, IDE autocompletion | Requires code changes for new fault types, harder to serialize | No |\n| Flexible map | Extensible without code changes, easy serialization | No compile-time checking, requires documentation | **Yes** |\n| Protocol Buffers oneof | Type-safe extensibility, good serialization | Complex setup, still requires proto changes for new types | No |\n\n#### Experiment Status Constants\n\nThe `ExperimentStatus` type uses these string constants to track experiment lifecycle:\n\n| Constant | Value | Description |\n|----------|-------|-------------|\n| `StateDraft` | \"DRAFT\" | Experiment is defined but not yet scheduled or approved. |\n| `StateBaselineValidation` | \"BASELINE_VALIDATION\" | System is being checked to ensure it's in a steady state before fault injection. |\n| `StateInjecting` | \"INJECTING\" | Faults are being applied to the target system. |\n| `StateMonitoring` | \"MONITORING\" | Faults are active and system behavior is being observed. |\n| `StateRollback` | \"ROLLBACK\" | Faults are being cleaned up (either due to completion or abort). |\n| `StateAnalysis` | \"ANALYSIS\" | Results are being compiled and hypothesis is being evaluated. |\n| `StateCompleted` | \"COMPLETED\" | Experiment finished successfully (hypothesis confirmed or rejected). |\n| `StateAborted` | \"ABORTED\" | Experiment was aborted due to safety breach or manual intervention. |\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Data Serialization | JSON (encoding/json) with Go struct tags | Protocol Buffers with gRPC |\n| Metrics Collection | Direct Prometheus queries (prometheus/client_golang) | Multi-backend abstraction (Prometheus, Datadog, Cloud Monitoring) |\n| Result Storage | Local filesystem (JSON files) | PostgreSQL with TimescaleDB extension |\n| Fault Parameter Validation | Manual validation in each fault injector | JSON Schema validation with shared definitions |\n\n#### Recommended File/Module Structure\n\n```\nchaos-platform/\n├── cmd/\n│   ├── chaos-controller/           # Main experiment orchestrator\n│   │   └── main.go\n│   └── chaos-agent/                # Fault injection agent\n│       └── main.go\n├── internal/\n│   ├── types/                      # Core data model definitions\n│   │   ├── experiment.go           # Experiment, Hypothesis, MetricThreshold\n│   │   ├── fault.go                # Fault, Target, FaultParams\n│   │   ├── results.go              # ExperimentResult, HypothesisValidation, etc.\n│   │   ├── safety.go               # SafetyRule, SafetyEvent\n│   │   └── schedule.go             # Schedule definitions\n│   ├── persistence/                # Data storage layer\n│   │   ├── experiment_store.go     # Experiment CRUD operations\n│   │   ├── result_store.go         # Result storage and retrieval\n│   │   └── cleanup_store.go        # CleanupEnsurer implementation\n│   └── validation/                 # Validation utilities\n│       ├── experiment_validator.go # Validates experiment definitions\n│       └── metric_validator.go     # Validates metric thresholds\n└── pkg/\n    ├── api/                        # REST API definitions\n    ├── metrics/                    # Metrics collection abstraction\n    └── fault/                      # Fault injection implementations\n```\n\n#### Infrastructure Starter Code\n\nHere's a complete, ready-to-use implementation of the core data types:\n\n```go\n// internal/types/experiment.go\npackage types\n\nimport (\n\t\"time\"\n)\n\n// ExperimentStatus represents the lifecycle state of an experiment\ntype ExperimentStatus string\n\nconst (\n\tStateDraft              ExperimentStatus = \"DRAFT\"\n\tStateBaselineValidation ExperimentStatus = \"BASELINE_VALIDATION\"\n\tStateInjecting          ExperimentStatus = \"INJECTING\"\n\tStateMonitoring         ExperimentStatus = \"MONITORING\"\n\tStateRollback           ExperimentStatus = \"ROLLBACK\"\n\tStateAnalysis           ExperimentStatus = \"ANALYSIS\"\n\tStateCompleted          ExperimentStatus = \"COMPLETED\"\n\tStateAborted            ExperimentStatus = \"ABORTED\"\n)\n\n// Experiment defines a complete chaos experiment\ntype Experiment struct {\n\tID           string        `json:\"id\"`\n\tName         string        `json:\"name\"`\n\tDescription  string        `json:\"description\"`\n\tHypothesis   Hypothesis    `json:\"hypothesis\"`\n\tFaults       []Fault       `json:\"faults\"`\n\tSchedule     Schedule      `json:\"schedule\"`\n\tDuration     time.Duration `json:\"duration\"`\n\tBlastRadius  BlastRadius   `json:\"blastRadius\"`\n\tSafetyRules  []SafetyRule  `json:\"safetyRules\"`\n\tStatus       ExperimentStatus `json:\"status\"`\n\tCreatedAt    time.Time     `json:\"createdAt\"`\n\tStartedAt    *time.Time    `json:\"startedAt,omitempty\"`\n\tCompletedAt  *time.Time    `json:\"completedAt,omitempty\"`\n}\n\n// Hypothesis defines the steady-state hypothesis being tested\ntype Hypothesis struct {\n\tDescription string            `json:\"description\"`\n\tMetrics     []MetricThreshold `json:\"metrics\"`\n}\n\n// MetricThreshold defines acceptable bounds for a system metric\ntype MetricThreshold struct {\n\tName     string   `json:\"name\"`\n\tQuery    string   `json:\"query\"`\n\tMin      *float64 `json:\"min,omitempty\"`\n\tMax      *float64 `json:\"max,omitempty\"`\n\tDuration string   `json:\"duration\"` // e.g., \"30s\", \"2m\"\n}\n\n// BlastRadius limits the scope of an experiment\ntype BlastRadius struct {\n\tPercentage  float64  `json:\"percentage\"`  // 0.0 to 100.0\n\tServices    []string `json:\"services\"`    // empty means all services\n\tNamespaces  []string `json:\"namespaces\"`  // empty means all namespaces\n}\n\n// SafetyRule defines an automatic abort condition\ntype SafetyRule struct {\n\tMetric    string `json:\"metric\"`    // matches MetricThreshold.Name\n\tCondition string `json:\"condition\"` // e.g., \"value > 0.05\"\n\tDuration  string `json:\"duration\"`  // e.g., \"30s\"\n}\n\n// internal/types/fault.go\npackage types\n\n// FaultType represents the category of fault to inject\ntype FaultType string\n\nconst (\n\tFaultTypeLatency          FaultType = \"LATENCY\"\n\tFaultTypePacketLoss       FaultType = \"PACKET_LOSS\"\n\tFaultTypeProcessKill      FaultType = \"PROCESS_KILL\"\n\tFaultTypeCPUStress        FaultType = \"CPU_STRESS\"\n\tFaultTypeMemoryStress     FaultType = \"MEMORY_STRESS\"\n\tFaultTypeNetworkPartition FaultType = \"NETWORK_PARTITION\"\n)\n\n// Fault defines a specific failure to inject\ntype Fault struct {\n\tType       FaultType           `json:\"type\"`\n\tTarget     Target              `json:\"target\"`\n\tParameters map[string]string   `json:\"parameters\"` // fault-specific config\n}\n\n// Target specifies where to apply a fault\ntype Target struct {\n\tType     string            `json:\"type\"`     // \"service\", \"pod\", \"node\", etc.\n\tSelector map[string]string `json:\"selector\"` // key-value selectors\n\tCount    int               `json:\"count,omitempty\"` // number of instances\n}\n\n// internal/types/schedule.go\npackage types\n\nimport (\n\t\"time\"\n)\n\n// ScheduleType defines when an experiment should run\ntype ScheduleType string\n\nconst (\n\tScheduleImmediate ScheduleType = \"IMMEDIATE\"\n\tScheduleOneTime   ScheduleType = \"ONE_TIME\"\n\tScheduleCron      ScheduleType = \"CRON\"\n)\n\n// Schedule defines when and how often to run an experiment\ntype Schedule struct {\n\tType           ScheduleType `json:\"type\"`\n\tWhen           *time.Time   `json:\"when,omitempty\"`           // for ONE_TIME\n\tCronExpression string       `json:\"cronExpression,omitempty\"` // for CRON\n\tTimeZone       string       `json:\"timeZone,omitempty\"`       // for CRON\n}\n```\n\n#### Core Logic Skeleton Code\n\nHere's skeleton code for the result validation logic that learners should implement:\n\n```go\n// internal/validation/metric_validator.go\npackage validation\n\nimport (\n\t\"time\"\n\t\"github.com/chaos-platform/internal/types\"\n)\n\n// ValidateHypothesis checks if the system satisfies the hypothesis metrics\n// TODO 1: Collect baseline metrics for each threshold in the hypothesis\n// TODO 2: Apply statistical smoothing if duration is specified (e.g., moving average)\n// TODO 3: Check each metric against its min/max bounds\n// TODO 4: Return detailed results showing which metrics passed/failed\n// TODO 5: Include confidence intervals if sufficient data points are available\nfunc ValidateHypothesis(\n\thypothesis types.Hypothesis,\n\tstartTime time.Time,\n\tendTime time.Time,\n\tmetricsCollector MetricsCollector,\n) (*types.HypothesisValidation, error) {\n\t// Implementation goes here\n\treturn nil, nil\n}\n\n// internal/persistence/experiment_store.go\npackage persistence\n\nimport (\n\t\"context\"\n\t\"time\"\n\t\"github.com/chaos-platform/internal/types\"\n)\n\n// ExperimentFilter allows querying experiments by various criteria\ntype ExperimentFilter struct {\n\tStatus     *types.ExperimentStatus\n\tCreatedAfter  *time.Time\n\tCreatedBefore *time.Time\n\tNamePrefix string\n\tLimit       int\n\tOffset      int\n}\n\n// TODO 1: Implement CreateExperiment with validation and ID generation\n// TODO 2: Implement GetExperiment with proper error handling for not found\n// TODO 3: Implement ListExperiments with filtering and pagination\n// TODO 4: Implement UpdateExperimentStatus for state transitions\n// TODO 5: Implement DeleteExperiment with cleanup of related resources\n```\n\n#### Language-Specific Hints\n\n1. **Use `json` struct tags**: All data model structs should include JSON struct tags for serialization/deserialization. Use `omitempty` for optional pointer fields.\n\n2. **Time handling**: Use `time.Time` for timestamps and `time.Duration` for durations. For JSON serialization of durations, you may want to implement custom marshaling/unmarshaling if you want human-readable strings like \"30s\" instead of nanoseconds.\n\n3. **Thread safety**: The `CleanupEnsurer` needs proper synchronization using `sync.RWMutex` since it will be accessed from multiple goroutines.\n\n4. **Validation**: Use the `validator` package (go-playground/validator) for struct validation, or implement custom validation logic for complex constraints like blast radius percentages.\n\n5. **Error handling**: Return descriptive error messages that help debug data model issues, especially for validation failures.\n\n#### Common Pitfalls\n\n⚠️ **Pitfall: Missing field validation in data model**\n- **Description**: Not validating that blast radius percentage is between 0 and 100, or that schedule times are in the future.\n- **Why it's wrong**: Invalid experiments can be created that either do nothing (0% blast radius) or are impossible to schedule (past times).\n- **How to fix**: Implement comprehensive validation in the `CreateExperiment` method and reject invalid experiments with clear error messages.\n\n⚠️ **Pitfall: Not handling time zones in schedules**\n- **Description**: Storing cron schedule times without timezone information.\n- **Why it's wrong**: An experiment scheduled for \"2 AM\" will run at different times in different data centers, causing confusion and potential production issues.\n- **How to fix**: Always store timezone with schedules and convert to UTC for internal processing.\n\n⚠️ **Pitfall: Using floating-point equality for metric thresholds**\n- **Description**: Checking `if value == 0.05` instead of `if value > 0.05 - epsilon`.\n- **Why it's wrong**: Floating-point rounding errors can cause valid values to fail threshold checks.\n- **How to fix**: Use a small epsilon value (e.g., 1e-9) when comparing floating-point numbers, or use decimal types for precise calculations.\n\n⚠️ **Pitfall: Not persisting intermediate experiment state**\n- **Description**: Only storing experiment state when it reaches a final state (COMPLETED/ABORTED).\n- **Why it's wrong**: If the chaos controller crashes during an experiment, you lose all information about what was happening and can't resume or properly clean up.\n- **How to fix**: Persist state after every transition, and implement recovery logic that reads persisted state on startup.\n\n\n> **Milestone(s):** Milestone 1 (Fault Injection Framework) & Milestone 5 (Network Chaos & Infrastructure Faults)\n\n## Component Design: Fault Injection Framework\n\n### Mental Model: The Saboteur in the Factory\n\nThink of the fault injection framework as a **controlled saboteur working on a factory assembly line**. In a well-run factory, you have a complex system of machines (services), conveyor belts (network traffic), and power supplies (resources) all working together to produce goods. To test the factory's resilience, you hire a professional saboteur who can introduce specific, controlled defects exactly when and where you tell them to. This saboteur can:\n\n1. **Slow down a conveyor belt** (network latency) to simulate transportation delays\n2. **Randomly drop packages** (packet loss) to simulate damaged goods in transit\n3. **Turn off a specific machine** (process kill) to test redundancy\n4. **Overload the power grid** (resource exhaustion) to test backup generators\n5. **Build a temporary wall between two workstations** (network partition) to test communication failures\n\nThe key characteristics of this saboteur are:\n- **Controlled**: They only act on specific, authorized instructions\n- **Reversible**: Every defect they create can be completely undone\n- **Observable**: They report exactly what they did and when\n- **Isolated**: They never sabotage their own control systems or tools\n\nThis mental model helps us understand the core responsibilities of the fault injection framework: to apply specific, reversible defects to a running system in a controlled manner, while ensuring the chaos platform itself remains operational.\n\n### Interface Definition\n\nThe fault injection framework exposes a clean interface that other components (particularly the experiment orchestrator) use to inject and manage faults. This interface abstracts away the complexity of different fault types and execution environments.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `InjectFault` | `fault Fault`, `experimentID string` | `faultID string`, `error` | Applies the specified fault to the target system. Returns a unique fault identifier that can be used for subsequent operations. The fault is associated with the given experiment ID for tracking and cleanup. |\n| `CleanupFault` | `faultID string` | `error` | Removes a previously injected fault, restoring normal operation. This must be idempotent - calling it multiple times on the same fault should not cause errors. |\n| `GetFaultStatus` | `faultID string` | `FaultStatus`, `error` | Returns the current state of a fault, including whether it's active, what commands were executed, and any errors encountered. |\n| `ListActiveFaults` | `experimentID string` | `[]FaultStatus`, `error` | Returns all active faults for a given experiment, useful for bulk cleanup or status monitoring. |\n| `ValidateFault` | `fault Fault` | `[]ValidationError`, `error` | Validates that a fault definition is syntactically and semantically correct before attempting injection. Checks for things like required parameters, valid target selectors, and supported fault types. |\n\nThe `Fault` parameter follows the data model defined earlier, but let's examine its structure in detail for this component's context:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Type` | `FaultType` | The type of fault to inject (e.g., `LATENCY`, `PACKET_LOSS`, `PROCESS_KILL`). Determines which injection mechanism to use. |\n| `Target` | `Target` | Specifies where to apply the fault. Contains a selector (like Kubernetes pod labels) and a count of how many instances to affect. |\n| `Parameters` | `FaultParams` | A key-value map of fault-specific parameters. For latency: `{\"delay\": \"200ms\", \"jitter\": \"50ms\"}`. For packet loss: `{\"percentage\": \"10%\"}`. |\n\nThe returned `FaultStatus` structure provides visibility into fault execution:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `FaultID` | `string` | Unique identifier for this fault instance |\n| `ExperimentID` | `string` | Experiment this fault belongs to |\n| `Type` | `FaultType` | Type of fault |\n| `Target` | `string` | Human-readable description of what was targeted |\n| `State` | `FaultState` | Current state: `PENDING`, `INJECTING`, `ACTIVE`, `CLEANING`, `DONE`, `FAILED` |\n| `InjectTime` | `*time.Time` | When the fault was successfully injected |\n| `CleanupTime` | `*time.Time` | When the fault was cleaned up |\n| `Commands` | `[]ExecutedCommand` | The actual OS commands or API calls made to inject/cleanup |\n| `Error` | `*string` | Any error that occurred during injection or cleanup |\n\n### Internal Behavior and State Machine\n\nWhen the fault injector receives an `InjectFault` call, it follows a precise, stateful procedure to ensure reliable fault application. The algorithm proceeds through these steps:\n\n1. **Validation Phase**: The fault definition is validated for correctness. This includes checking that all required parameters are present and valid (e.g., latency values are positive durations, packet loss percentages are between 0-100), verifying that the target selector matches at least one entity, and confirming the fault type is supported in the current environment.\n\n2. **Target Resolution**: The abstract `Target` selector is resolved to concrete instances. For example, if the target is `{\"app\": \"payment-service\"}`, the injector queries the container runtime or Kubernetes API to find all pods matching those labels, then selects the specified number of instances (or all if no count specified).\n\n3. **Privilege Check**: The injector verifies it has the necessary permissions to apply the fault. Network faults require `CAP_NET_ADMIN` or root privileges, while process faults require appropriate process signal permissions. If running in a containerized environment, it checks for the necessary capabilities.\n\n4. **Pre-flight Health Check**: Before applying any destructive changes, the injector performs a quick health check on the target to ensure it's in a normal state. This prevents exacerbating existing problems.\n\n5. **Fault Application**: The specific fault implementation is executed. This involves:\n   - For network latency: Running `tc qdisc add` commands with `netem` parameters\n   - For packet loss: Configuring `iptables` rules with random drop probability\n   - For process kill: Sending `SIGTERM` or `SIGKILL` to the target PID\n   - For resource exhaustion: Starting stress-ng processes or configuring cgroup limits\n   - For network partition: Setting up `iptables` DROP rules between specific IP ranges\n\n6. **Verification**: After applying the fault, the injector verifies it was actually applied. For network faults, it runs `tc qdisc show` to confirm the rules exist. For process faults, it checks that the target process is no longer running (or has been restarted if that's the expected behavior).\n\n7. **Registration**: The fault is registered with the cleanup ensurer, which persists the fault details to disk. This ensures the fault can be cleaned up even if the orchestrator crashes.\n\n8. **Monitoring**: While active, the fault injector periodically verifies the fault is still in place (some faults, like process kills, are one-time events, while others like network rules need to persist).\n\nThe fault lifecycle follows a well-defined state machine:\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| `PENDING` | `INJECT_REQUESTED` | `INJECTING` | Begin validation and target resolution |\n| `INJECTING` | `INJECTION_SUCCESS` | `ACTIVE` | Register fault with cleanup ensurer, start monitoring timer |\n| `INJECTING` | `INJECTION_FAILED` | `FAILED` | Log error, notify orchestrator |\n| `ACTIVE` | `CLEANUP_REQUESTED` | `CLEANING` | Begin cleanup procedure |\n| `ACTIVE` | `MONITOR_TIMEOUT` | `ACTIVE` | Verify fault still applied, reapply if necessary |\n| `CLEANING` | `CLEANUP_SUCCESS` | `DONE` | Deregister from cleanup ensurer, release resources |\n| `CLEANING` | `CLEANUP_FAILED` | `FAILED` | Log error, schedule retry, notify orchestrator |\n| `FAILED` | `RETRY_REQUESTED` | `INJECTING` or `CLEANING` | Attempt operation again (with backoff) |\n| Any state | `FORCE_ABORT` | `DONE` | Emergency cleanup, skip normal validation |\n\n> **Key Insight:** The state machine ensures that every fault has a clear lifecycle and that cleanup can always be attempted, even from failure states. The `FAILED` state is not terminal - retries can move the fault back to an operational state.\n\n![Sequence Diagram: Injecting a Network Latency Fault](./diagrams/diag-seq-fault.svg)\n\n### ADR: Fault Injection Method (Proxy vs. Sidecar)\n\n> **Decision: Sidecar Agent Model for Fault Injection**\n> - **Context**: We need to inject faults into potentially containerized, distributed systems with minimal performance overhead and maximum compatibility. The system must work across different runtime environments (bare metal, VMs, containers) and support various fault types (network, process, resource).\n> - **Options Considered**:\n>   1. **Proxy-based interception**: All traffic flows through a chaos proxy that can inject latency, errors, or packet loss\n>   2. **Sidecar agent model**: A lightweight agent runs alongside each service and modifies the host/container environment\n>   3. **Centralized daemon**: A single powerful agent runs on each node and manages faults for all services on that node\n> - **Decision**: Use a **sidecar agent model** for most faults, with selective use of proxy-based approaches for HTTP/gRPC-specific faults.\n> - **Rationale**: \n>   - **Isolation**: Sidecars can be isolated from their own faults (a network fault sidecar shouldn't lose its own control traffic)\n>   - **Flexibility**: Sidecars can inject process, resource, and network faults without requiring all traffic to flow through a proxy\n>   - **Modern infrastructure alignment**: Sidecars align with service mesh architectures (like Istio) which already use this pattern\n>   - **Gradual adoption**: Services can opt-in by deploying the sidecar, rather than requiring a wholesale infrastructure change\n>   - **Performance**: Avoids the single bottleneck and latency addition of a proxy for all traffic\n> - **Consequences**:\n>   - **Positive**: Can inject faults at multiple layers (network, process, resource), not just network traffic\n>   - **Positive**: Better isolation - if a fault crashes the sidecar, the service may continue (though fault cleanup might be affected)\n>   - **Negative**: More deployment complexity - each service needs the sidecar container\n>   - **Negative**: Resource overhead from running many sidecar instances\n>   - **Mitigation**: Use DaemonSets in Kubernetes for node-level agents where appropriate, and keep sidecars extremely lightweight\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| **Proxy-based** | - Simple centralized control<br>- Can inspect/modify application-layer protocols<br>- Easy to implement for HTTP/gRPC | - Single point of failure/bottleneck<br>- Requires routing all traffic through proxy<br>- Cannot inject process/resource faults<br>- Adds latency to all traffic | **No** for general faults, but useful for app-layer chaos |\n| **Sidecar Agent** | - Fault isolation (agent not affected by its own faults)<br>- Can inject all fault types<br>- Aligns with service mesh patterns<br>- Gradual adoption possible | - Deployment complexity<br>- Resource overhead<br>- Coordination needed across many agents | **Yes**, primary model |\n| **Centralized Daemon** | - Less resource overhead than many sidecars<br>- Easy to manage/upgrade<br>- Can see whole node context | - Single point of failure on node<br>- Less isolation (daemon crashes affect all faults)<br>- Security concerns (high privilege needed) | **No**, but useful for node-level faults |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Forgetting Root Privileges for Network Faults**\n- **Description**: Attempting to run `tc` or `iptables` commands without `CAP_NET_ADMIN` capability or root access\n- **Why it's wrong**: These commands fail silently or with permission errors, leaving the system in an inconsistent state where the orchestrator thinks a fault is active but it isn't\n- **How to fix**: \n  1. Always check privileges during the validation phase\n  2. Run the fault injector with appropriate capabilities: `docker run --cap-add=NET_ADMIN`\n  3. For Kubernetes, use a privileged container or specific capabilities in the pod security context\n  4. Provide clear error messages indicating the missing permissions\n\n⚠️ **Pitfall: Fault Injection Affecting the Chaos Tool Itself**\n- **Description**: Applying network partition or packet loss that isolates the fault injector from the orchestrator, creating a \"split-brain\" scenario\n- **Why it's wrong**: The orchestrator loses ability to monitor or clean up the fault, potentially leaving destructive changes permanently applied\n- **How to fix**:\n  1. Use **control plane isolation**: Ensure fault injector control traffic uses a separate network interface or VLAN\n  2. Implement **heartbeat monitoring**: If the orchestrator loses contact with an injector, trigger automatic cleanup\n  3. Use **out-of-band management**: For critical systems, have a separate management network for chaos control traffic\n  4. Design faults to **exclude control IPs**: Automatically exclude orchestrator and injector IPs from network fault rules\n\n⚠️ **Pitfall: Non-idempotent Cleanup Operations**\n- **Description**: Cleanup commands that fail or behave incorrectly when run multiple times (e.g., trying to delete a `tc` rule that doesn't exist)\n- **Why it's wrong**: During retries or crash recovery, cleanup might be attempted multiple times, causing errors that prevent proper restoration\n- **How to fix**:\n  1. Design all cleanup operations to be **idempotent**\n  2. Use \"delete if exists\" patterns: `tc qdisc del dev eth0 root 2>/dev/null || true`\n  3. Check current state before attempting modification\n  4. Log but ignore \"already cleaned up\" errors during retry\n\n⚠️ **Pitfall: Resource Exhaustion Crashing the Injector**\n- **Description**: Running a CPU stress test that consumes all CPU on the node, starving the fault injector process itself\n- **Why it's wrong**: The injector becomes unresponsive and cannot monitor or clean up the fault\n- **How to fix**:\n  1. Use **cgroups to isolate** the stress process from the injector\n  2. Set **CPU affinity** to restrict stress processes to specific cores\n  3. Implement **watchdog timers** - if the injector doesn't check in, a separate monitor process triggers cleanup\n  4. For memory exhaustion, use **swap or memory limits** to prevent complete node failure\n\n⚠️ **Pitfall: Assuming Process Kill Means Service Down**\n- **Description**: Killing a process without considering that it might be managed by a supervisor (systemd, Kubernetes, supervisord) that automatically restarts it\n- **Why it's wrong**: The \"fault\" has no observable effect - the service restarts so quickly that resilience appears perfect when it might not be\n- **How to fix**:\n  1. **Monitor actual availability** during the fault, not just process existence\n  2. For containerized environments, consider **pod kill** instead of process kill\n  3. Optionally **disable auto-restart** during the experiment (but remember to re-enable it!)\n  4. Measure **recovery time** rather than binary \"up/down\" status\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Network Faults** | `tc` (traffic control) with `netem` for latency/loss, `iptables` for packet manipulation | eBPF programs for fine-grained, low-overhead network fault injection |\n| **Process Faults** | `kill` system calls via `os` package | `ptrace` or process namespace manipulation for more controlled faults |\n| **Resource Exhaustion** | `stress-ng` binary execution | Direct cgroup manipulation via `github.com/containerd/cgroups` |\n| **Command Execution** | `os/exec` package | Agent model with gRPC for remote execution |\n| **Fault Persistence** | JSON file on disk | Embedded database (SQLite) or distributed store (etcd) |\n\n#### Recommended File/Module Structure\n\n```\nchaos-platform/\n├── cmd/\n│   ├── chaos-controller/          # Central orchestrator\n│   └── chaos-agent/               # Sidecar fault injector\n├── pkg/\n│   ├── fault/                     # Fault injection framework\n│   │   ├── injector.go            # Main interface and registry\n│   │   ├── types.go               # Fault types and constants\n│   │   ├── network/               # Network fault implementations\n│   │   │   ├── latency.go\n│   │   │   ├── packet_loss.go\n│   │   │   ├── partition.go\n│   │   │   └── network_utils.go   # tc/iptables helpers\n│   │   ├── process/               # Process fault implementations\n│   │   │   ├── kill.go\n│   │   │   └── restart.go\n│   │   ├── resource/              # Resource exhaustion implementations\n│   │   │   ├── cpu_stress.go\n│   │   │   ├── memory_stress.go\n│   │   │   └── disk_fill.go\n│   │   ├── registry.go            # Fault type registry\n│   │   └── cleanup/               # Cleanup ensurer implementation\n│   │       ├── ensurer.go\n│   │       └── persistence.go\n│   ├── orchestrator/              # Experiment orchestration\n│   └── metrics/                   # Metrics collection\n└── internal/\n    └── util/                      # Shared utilities\n```\n\n#### Infrastructure Starter Code: Cleanup Ensurer\n\nThe cleanup ensurer is critical infrastructure that ensures faults are rolled back even if the orchestrator crashes. It persists fault records to disk and provides recovery on startup.\n\n```go\n// pkg/fault/cleanup/ensurer.go\npackage cleanup\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n    \"time\"\n)\n\n// FaultRecord represents a fault that needs cleanup\ntype FaultRecord struct {\n    ExperimentID string    `json:\"experiment_id\"`\n    FaultID      string    `json:\"fault_id\"`\n    Target       string    `json:\"target\"`\n    FaultType    string    `json:\"fault_type\"`\n    InjectTime   time.Time `json:\"inject_time\"`\n    CleanupCmd   string    `json:\"cleanup_cmd\"` // Command to execute for cleanup\n}\n\n// CleanupEnsurer ensures faults are cleaned up even after crashes\ntype CleanupEnsurer struct {\n    mu           sync.RWMutex\n    filePath     string\n    activeFaults map[string]FaultRecord\n}\n\n// NewCleanupEnsurer creates a new cleanup ensurer with persistence file\nfunc NewCleanupEnsurer(dataDir string) (*CleanupEnsurer, error) {\n    filePath := filepath.Join(dataDir, \"active_faults.json\")\n    ensurer := &CleanupEnsurer{\n        filePath:     filePath,\n        activeFaults: make(map[string]FaultRecord),\n    }\n    \n    // Load existing faults from disk\n    if err := ensurer.loadFromDisk(); err != nil && !os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"failed to load fault records: %w\", err)\n    }\n    \n    return ensurer, nil\n}\n\n// RegisterFault records a fault that will need cleanup\nfunc (c *CleanupEnsurer) RegisterFault(record FaultRecord) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    c.activeFaults[record.FaultID] = record\n    return c.saveToDisk()\n}\n\n// CompleteFault removes a fault from cleanup registry\nfunc (c *CleanupEnsurer) CompleteFault(faultID string) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    if _, exists := c.activeFaults[faultID]; !exists {\n        return fmt.Errorf(\"fault %s not found\", faultID)\n    }\n    \n    delete(c.activeFaults, faultID)\n    return c.saveToDisk()\n}\n\n// GetActiveFaults returns all faults needing cleanup\nfunc (c *CleanupEnsurer) GetActiveFaults() []FaultRecord {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    \n    faults := make([]FaultRecord, 0, len(c.activeFaults))\n    for _, fault := range c.activeFaults {\n        faults = append(faults, fault)\n    }\n    return faults\n}\n\n// RecoverAndCleanup is called on startup to clean up any orphaned faults\nfunc (c *CleanupEnsurer) RecoverAndCleanup(cleanupFunc func(FaultRecord) error) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    var cleanupErrors []error\n    for id, fault := range c.activeFaults {\n        if err := cleanupFunc(fault); err != nil {\n            cleanupErrors = append(cleanupErrors, \n                fmt.Errorf(\"failed to cleanup fault %s: %w\", id, err))\n            // Continue trying to clean up other faults\n            continue\n        }\n        delete(c.activeFaults, id)\n    }\n    \n    if err := c.saveToDisk(); err != nil {\n        cleanupErrors = append(cleanupErrors, \n            fmt.Errorf(\"failed to save cleanup state: %w\", err))\n    }\n    \n    if len(cleanupErrors) > 0 {\n        return fmt.Errorf(\"recovery had errors: %v\", cleanupErrors)\n    }\n    return nil\n}\n\n// loadFromDisk loads active faults from the persistence file\nfunc (c *CleanupEnsurer) loadFromDisk() error {\n    data, err := os.ReadFile(c.filePath)\n    if err != nil {\n        return err\n    }\n    \n    var faults []FaultRecord\n    if err := json.Unmarshal(data, &faults); err != nil {\n        return fmt.Errorf(\"failed to unmarshal fault records: %w\", err)\n    }\n    \n    c.activeFaults = make(map[string]FaultRecord)\n    for _, fault := range faults {\n        c.activeFaults[fault.FaultID] = fault\n    }\n    \n    return nil\n}\n\n// saveToDisk saves active faults to the persistence file\nfunc (c *CleanupEnsurer) saveToDisk() error {\n    faults := make([]FaultRecord, 0, len(c.activeFaults))\n    for _, fault := range c.activeFaults {\n        faults = append(faults, fault)\n    }\n    \n    data, err := json.MarshalIndent(faults, \"\", \"  \")\n    if err != nil {\n        return fmt.Errorf(\"failed to marshal fault records: %w\", err)\n    }\n    \n    // Write to temp file first, then rename for atomicity\n    tempPath := c.filePath + \".tmp\"\n    if err := os.WriteFile(tempPath, data, 0644); err != nil {\n        return fmt.Errorf(\"failed to write temp file: %w\", err)\n    }\n    \n    return os.Rename(tempPath, c.filePath)\n}\n```\n\n#### Core Logic Skeleton: Fault Injector\n\n```go\n// pkg/fault/injector.go\npackage fault\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Injector is the main interface for fault injection\ntype Injector struct {\n    mu            sync.RWMutex\n    registry      FaultRegistry\n    cleanupEnsurer *cleanup.CleanupEnsurer\n    activeFaults  map[string]*FaultInstance\n}\n\n// FaultInstance represents an active fault instance\ntype FaultInstance struct {\n    FaultID      string\n    ExperimentID string\n    Fault        Fault\n    State        FaultState\n    Status       FaultStatus\n    CancelFunc   context.CancelFunc\n}\n\n// NewInjector creates a new fault injector\nfunc NewInjector(dataDir string) (*Injector, error) {\n    cleanupEnsurer, err := cleanup.NewCleanupEnsurer(dataDir)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create cleanup ensurer: %w\", err)\n    }\n    \n    return &Injector{\n        registry:      NewFaultRegistry(),\n        cleanupEnsurer: cleanupEnsurer,\n        activeFaults:  make(map[string]*FaultInstance),\n    }, nil\n}\n\n// InjectFault applies the specified fault to the target system\nfunc (i *Injector) InjectFault(fault Fault, experimentID string) (string, error) {\n    // TODO 1: Generate a unique fault ID using UUID or similar\n    // TODO 2: Validate the fault definition (check required parameters, valid target, etc.)\n    // TODO 3: Create a FaultInstance with initial state PENDING\n    // TODO 4: Check if we have the required permissions for this fault type\n    // TODO 5: Resolve the target selector to concrete instances (pods, containers, etc.)\n    // TODO 6: Execute pre-flight health check on targets\n    // TODO 7: Execute fault-specific injection logic (delegate to registered fault handler)\n    // TODO 8: If successful, update state to ACTIVE and register with cleanup ensurer\n    // TODO 9: Start monitoring goroutine to periodically verify fault is still applied\n    // TODO 10: Return fault ID and nil error on success\n    return \"\", fmt.Errorf(\"not implemented\")\n}\n\n// CleanupFault removes a previously injected fault\nfunc (i *Injector) CleanupFault(faultID string) error {\n    i.mu.Lock()\n    instance, exists := i.activeFaults[faultID]\n    i.mu.Unlock()\n    \n    if !exists {\n        return fmt.Errorf(\"fault %s not found\", faultID)\n    }\n    \n    // TODO 1: Update fault state to CLEANING\n    // TODO 2: Cancel any monitoring goroutine for this fault\n    // TODO 3: Execute fault-specific cleanup logic (delegate to registered fault handler)\n    // TODO 4: Ensure cleanup is idempotent (safe to retry)\n    // TODO 5: If successful, update state to DONE and remove from activeFaults\n    // TODO 6: Notify cleanup ensurer that fault is complete\n    // TODO 7: Log cleanup completion\n    return fmt.Errorf(\"not implemented\")\n}\n\n// GetFaultStatus returns the current state of a fault\nfunc (i *Injector) GetFaultStatus(faultID string) (FaultStatus, error) {\n    i.mu.RLock()\n    defer i.mu.RUnlock()\n    \n    instance, exists := i.activeFaults[faultID]\n    if !exists {\n        return FaultStatus{}, fmt.Errorf(\"fault %s not found\", faultID)\n    }\n    \n    return instance.Status, nil\n}\n\n// ListActiveFaults returns all active faults for an experiment\nfunc (i *Injector) ListActiveFaults(experimentID string) ([]FaultStatus, error) {\n    i.mu.RLock()\n    defer i.mu.RUnlock()\n    \n    var faults []FaultStatus\n    for _, instance := range i.activeFaults {\n        if instance.ExperimentID == experimentID {\n            faults = append(faults, instance.Status)\n        }\n    }\n    \n    return faults, nil\n}\n\n// RecoverOrphanedFaults cleans up any faults that were active during a crash\nfunc (i *Injector) RecoverOrphanedFaults() error {\n    // TODO 1: Get all active faults from cleanup ensurer\n    // TODO 2: For each fault, check if it's already in activeFaults (resumed session)\n    // TODO 3: For faults not in activeFaults, attempt cleanup\n    // TODO 4: Log recovery results\n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Core Logic Skeleton: Network Latency Fault Implementation\n\n```go\n// pkg/fault/network/latency.go\npackage network\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n    \"strings\"\n)\n\n// LatencyFault implements network latency injection\ntype LatencyFault struct{}\n\n// Inject applies network latency to the target\nfunc (f *LatencyFault) Inject(target Target, params map[string]string) (string, error) {\n    // TODO 1: Parse parameters: delay (required), jitter (optional), correlation (optional)\n    // TODO 2: Validate parameters: delay must be positive duration (e.g., \"200ms\")\n    // TODO 3: Resolve target to specific network interfaces\n    // TODO 4: Build tc command: `tc qdisc add dev <interface> root netem delay <delay>`\n    // TODO 5: Add jitter if specified: `delay <delay> <jitter>`\n    // TODO 6: Add correlation if specified: `delay <delay> <jitter> <correlation>%`\n    // TODO 7: Execute command with appropriate privileges\n    // TODO 8: Verify command succeeded by checking `tc qdisc show dev <interface>`\n    // TODO 9: Return cleanup command for this fault\n    return \"\", fmt.Errorf(\"not implemented\")\n}\n\n// Cleanup removes network latency from the target\nfunc (f *LatencyFault) Cleanup(target Target, cleanupCmd string) error {\n    // TODO 1: Parse cleanup command (contains interface name and original state)\n    // TODO 2: Execute `tc qdisc del dev <interface> root` to remove netem rule\n    // TODO 3: If deletion fails with \"No such file or directory\", log and return nil (idempotent)\n    // TODO 4: Verify cleanup by checking `tc qdisc show dev <interface>` doesn't show netem\n    return fmt.Errorf(\"not implemented\")\n}\n\n// verifyTcRule checks if a tc rule is applied to an interface\nfunc verifyTcRule(interfaceName string) (bool, error) {\n    cmd := exec.Command(\"tc\", \"qdisc\", \"show\", \"dev\", interfaceName)\n    output, err := cmd.Output()\n    if err != nil {\n        return false, fmt.Errorf(\"failed to check tc rules: %w\", err)\n    }\n    \n    // Check if output contains \"netem\" (indicating latency rule)\n    return strings.Contains(string(output), \"netem\"), nil\n}\n```\n\n#### Language-Specific Hints\n\n- **Privilege Escalation**: Use `exec.Command` with `sudo` or ensure the Go binary has `CAP_NET_ADMIN` capability set via `setcap cap_net_admin+ep /path/to/binary`\n- **Command Execution**: Always use `exec.CommandContext` with timeout to prevent hanging if a command freezes\n- **Error Handling**: For OS commands, check both the error return and the exit code: `if err != nil || !cmd.ProcessState.Success()`\n- **Concurrency**: Use `sync.RWMutex` for protecting the active faults map - multiple readers, single writer\n- **ID Generation**: Use `github.com/google/uuid` for generating unique fault IDs: `uuid.New().String()`\n- **Duration Parsing**: Use `time.ParseDuration` for parsing strings like \"200ms\", \"2s\", \"1m30s\"\n- **JSON Persistence**: Use `encoding/json` with `MarshalIndent` for human-readable persistence files\n- **Context Propagation**: Use `context.WithCancel` for fault monitoring goroutines that need to be stopped during cleanup\n\n#### Milestone Checkpoint\n\n**Verification Command for Milestone 1:**\n```bash\n# Build and run the chaos agent\ngo build ./cmd/chaos-agent\nsudo ./chaos-agent --data-dir=/tmp/chaos\n\n# In another terminal, test fault injection via API\ncurl -X POST http://localhost:8080/faults/inject \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"type\": \"LATENCY\",\n    \"target\": {\"type\": \"pod\", \"selector\": {\"app\": \"demo-service\"}},\n    \"parameters\": {\"delay\": \"200ms\", \"jitter\": \"50ms\"}\n  }'\n```\n\n**Expected Behavior:**\n1. The agent should start and log \"Cleanup ensurer initialized\"\n2. The API call should return a JSON response with a `faultID`\n3. The agent logs should show:\n   - \"Injecting LATENCY fault on pod demo-service-xxx\"\n   - \"Executing: tc qdisc add dev eth0 root netem delay 200ms 50ms\"\n   - \"Fault injection successful, faultID: abc-123\"\n4. Running `tc qdisc show dev eth0` on the target pod should show the netem rule\n5. Subsequent API call to list active faults should show the fault as ACTIVE\n\n**Signs of Problems:**\n- \"Permission denied\" errors: Agent needs `CAP_NET_ADMIN` or sudo\n- \"No such file or directory\" for `tc`: Ensure `iproute2` package is installed\n- Fault disappears immediately: Check if a network manager is overwriting tc rules\n- Agent crashes on cleanup: Check idempotency of cleanup commands\n\n---\n\n\n> **Milestone(s):** Milestone 2 (Experiment Orchestration) & Milestone 4 (Steady-State Hypothesis & Metrics Validation)\n\n## Component Design: Experiment Orchestration Engine\n\nThe **Experiment Orchestration Engine** is the central nervous system of the chaos engineering platform. It transforms abstract experiment definitions into concrete, safe, and observable fault injection campaigns while rigorously testing hypotheses about system resilience. If the fault injection framework is the saboteur introducing controlled defects, the orchestrator is the scientist designing, monitoring, and analyzing the experiment.\n\n### Mental Model: The Scientific Experiment Lab\n\nImagine a **high-precision scientific laboratory** studying material resilience. The lab doesn't randomly stress materials—it follows a rigorous experimental protocol: first, it establishes a baseline measurement of the material's normal properties. Then it formulates a hypothesis: \"This alloy will maintain structural integrity under 500°C for 5 minutes.\" Next, it applies controlled thermal stress while continuously monitoring deformation. If sensors detect catastrophic deformation approaching, it immediately removes heat (auto-rollback). Finally, it compares post-stress measurements to the baseline, determining if the hypothesis was validated or rejected.\n\nSimilarly, the orchestrator treats each chaos experiment as a scientific study of system resilience:\n- **Hypothesis** = Steady-state prediction expressed as metric thresholds (error rate < 1%, latency < 200ms)\n- **Baseline** = System metrics collected during normal operation\n- **Controlled stimulus** = Precisely injected faults (latency, errors, resource exhaustion)\n- **Continuous monitoring** = Real-time metric collection during fault injection\n- **Safety protocols** = Automatic abort conditions preventing catastrophic failure\n- **Results analysis** = Statistical comparison of pre-fault, during-fault, and post-fault states\n\nThis scientific approach transforms chaos engineering from random breaking to hypothesis-driven resilience validation.\n\n### Interface Definition\n\nThe orchestrator exposes both a management API for experiment lifecycle operations and internal interfaces for coordinating with other components. The primary interface is the `Orchestrator` struct, which manages the complete lifecycle of experiment instances.\n\n#### Management API Methods\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `CreateExperiment` | `exp Experiment` | `ExperimentID, error` | Validates experiment definition, stores it, assigns unique ID. Performs pre-flight validation of faults, targets, and metric queries. |\n| `StartExperiment` | `experimentID string, resultsChan chan<- ExperimentResult` | `error` | Begins execution of approved experiment. Creates experiment instance, starts state machine in goroutine, returns immediately. Results are streamed to the provided channel. |\n| `AbortExperiment` | `experimentID string, reason string` | `error` | Forcefully stops running experiment. Triggers immediate fault cleanup, transitions to `ABORTED` state, records abort reason. |\n| `GetExperimentStatus` | `experimentID string` | `ExperimentStatus, error` | Returns current status (DRAFT, RUNNING, COMPLETED, ABORTED) and progress percentage. |\n| `ListExperiments` | `filter ExperimentFilter` | `[]Experiment, error` | Returns experiments matching criteria (status, time range, name prefix) with pagination support via `Limit` and `Offset`. |\n| `GetExperimentResult` | `experimentID string` | `*ExperimentResult, error` | Retrieves detailed results including hypothesis validation, safety events, and fault injection records. |\n\n#### Internal Coordination Methods\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `executeStateMachine` | `instance *ExperimentInstance` | (none) | Internal state machine driver. Runs in dedicated goroutine per experiment, transitions through states, coordinates component interactions. |\n| `validateHypothesis` | `hypothesis Hypothesis, baseline map[string]float64, duringMetrics map[string][]MetricPoint` | `*HypothesisValidation, error` | Validates steady-state hypothesis against collected metrics. Compares baseline (pre-fault) metrics with during-fault metrics using statistical tests. |\n| `checkSafetyRules` | `rules []SafetyRule, metricsCollector metrics.Collector` | `[]SafetyEvent, bool, error` | Continuously monitors safety rules during fault injection. Returns safety events and boolean indicating if any rule triggered abort condition. |\n| `injectAllFaults` | `faults []Fault, experimentID string` | `[]FaultInjectionRecord, error` | Coordinates injection of all faults defined in experiment. Creates fault instances, calls fault injector, records injection metadata. |\n| `cleanupAllFaults` | `faults []FaultInstance` | `[]FaultInjectionRecord, error` | Ensures all injected faults are cleaned up, even if some fail. Retries failed cleanups with exponential backoff. |\n\n### Internal Behavior and State Machine\n\nThe orchestrator implements a deterministic state machine that guides each experiment through its lifecycle. This state machine ensures proper sequencing (baseline collection before fault injection) and provides well-defined recovery points for failures.\n\n#### Experiment State Machine\n\n![Experiment Orchestration State Machine](./diagrams/diag-state-experiment.svg)\n\nThe state machine contains seven primary states with specific entry actions and exit conditions:\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| `DRAFT` | `StartExperiment()` | `BASELINE_VALIDATION` | Validate experiment definition. Create `ExperimentInstance`. Initialize metrics baseline collection. |\n| `BASELINE_VALIDATION` | `Baseline metrics collected` | `INJECTING` | Collect steady-state metrics for duration specified in hypothesis. Validate baseline meets hypothesis thresholds. If validation fails, transition to `ABORTED`. |\n| `INJECTING` | `All faults injected` | `MONITORING` | Sequentially inject each fault via fault injector. Record injection timestamps and commands. Handle partial injection failures (cleanup injected faults, abort experiment). |\n| `MONITORING` | `Safety rule breach detected` | `ROLLBACK` | Immediate transition regardless of duration. Record safety event. Cancel monitoring goroutines. |\n| `MONITORING` | `Experiment duration elapsed` | `ROLLBACK` | Normal completion. Stop monitoring goroutines. |\n| `ROLLBACK` | `All faults cleaned up` | `ANALYSIS` | Clean up all injected faults. Retry failed cleanups up to 3 times. Record cleanup timestamps. |\n| `ANALYSIS` | `Hypothesis validation complete` | `COMPLETED` | Collect post-fault metrics. Validate hypothesis against baseline and during-fault metrics. Generate comprehensive result. |\n| `ANALYSIS` | `Validation error` | `ABORTED` | If hypothesis validation fails due to system error (not hypothesis failure). Record error. |\n| *Any state* | `AbortExperiment()` | `ABORTED` | Immediate fault cleanup. Cancel all goroutines. Record abort reason. |\n\n#### Detailed Algorithm: Experiment Execution\n\nWhen `StartExperiment` is called, the orchestrator spawns a dedicated goroutine running the `executeStateMachine` function:\n\n1. **State: BASELINE_VALIDATION**\n   - Start metrics collection for all metrics referenced in hypothesis `MetricThresholds`\n   - Wait for collection duration specified in each threshold's `Duration` field\n   - Calculate baseline statistics (mean, p95, min, max) for each metric\n   - Validate each baseline metric meets its threshold\n   - **If any baseline violates threshold:** Transition to `ABORTED` with error \"System not in steady state before experiment\"\n   - **If all baselines valid:** Transition to `INJECTING`\n\n2. **State: INJECTING**\n   - For each fault in experiment's `Faults` array:\n     - Call fault injector's `ValidateFault()` for pre-flight validation\n     - Call `InjectFault()` with fault parameters and experiment ID\n     - Record `FaultInjectionRecord` with injection time and status\n     - **If injection fails:** Attempt to clean up previously injected faults, then transition to `ABORTED`\n   - Start safety monitoring goroutine that continuously evaluates `SafetyRules`\n   - Start metrics collection for hypothesis validation metrics\n   - Transition to `MONITORING`\n\n3. **State: MONITORING**\n   - Start timer for experiment `Duration`\n   - Concurrently:\n     - Monitor safety rules via `checkSafetyRules()` (runs every 5 seconds)\n     - Collect metrics for hypothesis validation\n   - **If safety rule triggers:** Transition to `ROLLBACK` immediately\n   - **If duration timer expires:** Transition to `ROLLBACK` normally\n\n4. **State: ROLLBACK**\n   - Stop safety monitoring and metrics collection goroutines\n   - For each active fault (in reverse injection order for dependency reasons):\n     - Call `CleanupFault()` on fault injector\n     - Update `FaultInjectionRecord` with cleanup time and status\n     - **If cleanup fails:** Retry with exponential backoff (max 3 attempts)\n   - **If any fault cannot be cleaned after retries:** Log critical error but continue (manual intervention required)\n   - Transition to `ANALYSIS`\n\n5. **State: ANALYSIS**\n   - Collect post-fault metrics (same duration as baseline collection)\n   - Call `validateHypothesis()` with:\n     - Baseline metrics (pre-fault)\n     - During-fault metrics (collected during MONITORING state)\n     - Post-fault metrics (collected after rollback)\n   - Generate `HypothesisValidation` result with statistical comparison\n   - Compile complete `ExperimentResult` including all safety events and fault injection records\n   - Send result to `resultsChan`\n   - Transition to `COMPLETED`\n\n6. **State: COMPLETED/ABORTED**\n   - Clean up experiment instance resources\n   - Persist final result to storage\n   - Notify any registered listeners of experiment conclusion\n\n#### Safety Monitoring Algorithm\n\nThe safety monitoring runs in a separate goroutine during the `MONITORING` state:\n\n1. For each `SafetyRule` in experiment's `SafetyRules`:\n   - Parse `Condition` (e.g., \"error_rate > 0.05\" for 5% error rate)\n   - Parse `Duration` (e.g., \"2m\" means condition must hold for 2 minutes)\n2. Every 5 seconds (configurable sampling interval):\n   - Query current value for each rule's metric via `GetCurrentValue()`\n   - Evaluate condition against current value\n   - If condition is true:\n     - Start/update timer for that rule\n     - If timer exceeds rule's `Duration`:\n       - Record `SafetyEvent` with `Triggered: true`, `DurationMet: true`\n       - Return trigger signal to state machine\n   - Else (condition false):\n     - Reset timer for that rule\n3. Continue until state machine exits `MONITORING` state\n\n> **Key Insight:** Safety rules use a **duration threshold** to prevent false positives from transient spikes. A 5% error rate for 30 seconds might be acceptable, but the same rate for 2 minutes indicates real degradation requiring auto-rollback.\n\n### ADR: Rollback Strategy (Time-based vs. Condition-based)\n\n> **Decision: Hybrid Rollback with Condition-based Safety Rules and Time-based Fallback**\n>\n> **Context:** Chaos experiments must balance between gathering sufficient data during faults and preventing catastrophic system damage. The orchestrator needs a deterministic strategy for when to terminate fault injection and restore normal operation.\n>\n> **Options Considered:**\n> 1. **Pure Time-based:** Experiments run for fixed duration specified in `Experiment.Duration`, then automatically rollback.\n> 2. **Pure Condition-based:** Experiments run indefinitely until safety rules trigger auto-rollback.\n> 3. **Hybrid Approach:** Experiments run until EITHER safety rules trigger OR maximum duration elapses, whichever comes first.\n>\n> **Decision:** Implement hybrid approach (Option 3) as the default strategy.\n>\n> **Rationale:** \n> - **Time-based alone** risks excessive damage if faults cause degradation before duration elapses\n> - **Condition-based alone** risks experiments running indefinitely if safety thresholds are improperly configured or metrics collection fails\n> - **Hybrid approach** provides safety guarantee (rollback on degradation) while maintaining experiment determinism (maximum bound on runtime)\n> - This matches production chaos engineering practices at Netflix and Amazon, where GameDays have both safety monitors and strict timeboxes\n>\n> **Consequences:**\n> - Requires implementing both safety rule evaluation and duration timers\n> - Experiments may end earlier than planned if safety triggers, reducing fault exposure time\n> - Provides defense against \"runaway experiments\" where safety monitoring fails\n> - Simplifies experiment scheduling (known maximum runtime)\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Pure Time-based | Simple to implement, predictable runtime | No protection against rapid degradation before timeout | ❌ |\n| Pure Condition-based | Maximally safe, adapts to system response | Risk of infinite run if rules never trigger, harder to schedule | ❌ |\n| **Hybrid Approach** | Safety protection + time bounding, matches industry practice | Slightly more complex implementation | ✅ |\n\n### Common Pitfalls\n\n#### ⚠️ **Pitfall: Skipping Steady-State Verification**\n**Description:** Injecting faults before verifying the system is in a healthy, steady state. For example, starting a CPU stress experiment when the system already has 90% CPU utilization.\n**Why it's wrong:** You can't measure the impact of chaos if you don't have a valid baseline. The experiment results become meaningless (\"system was already broken\"). More dangerously, you might push an already degraded system over the edge into failure.\n**How to fix:** Always implement the `BASELINE_VALIDATION` state. Collect metrics for the duration specified in the hypothesis thresholds, and abort the experiment if any baseline metric violates its threshold. Log the violation clearly: \"Aborted experiment: baseline error rate 2.1% exceeds threshold 1.0%.\"\n\n#### ⚠️ **Pitfall: Not Handling Orphaned Faults**\n**Description:** The orchestrator crashes during fault injection, leaving faults active with no cleanup mechanism.\n**Why it's wrong:** Chaos becomes uncontrolled—injected latency, packet loss, or resource exhaustion persists indefinitely, causing ongoing production issues.\n**How to fix:** Implement a **cleanup ensurer** pattern. Before injecting any fault, record it in a persistent registry (e.g., JSON file on disk) with enough information to clean it up. On orchestrator startup, scan for orphaned faults and clean them up. The `CleanupEnsurer` struct provides this capability.\n\n#### ⚠️ **Pitfall: Ignoring Metric Collection Lag**\n**Description:** Assuming metrics are real-time when they actually have 30-60 second aggregation windows in systems like Prometheus.\n**Why it's wrong:** Safety rules may trigger too late because they're evaluating stale data. By the time the metrics show 10% error rate, the actual system might already be at 40%.\n**How to fix:** Use a combination of metrics: fast local metrics (application logs, local health checks) for immediate safety triggers, and aggregated metrics for hypothesis validation. Document the expected lag for each metric source in your platform documentation.\n\n#### ⚠️ **Pitfall: Single Safety Monitor Failure Point**\n**Description:** Running safety monitoring in the same process as the orchestrator without redundancy.\n**Why it's wrong:** If the orchestrator process crashes, safety monitoring stops, but injected faults continue.\n**How to fix:** Implement a **distributed safety monitor** pattern where multiple independent monitors watch the same metrics. Alternatively, configure external monitoring systems (like Prometheus alerts) as backup abort triggers. At minimum, ensure the cleanup ensurer runs as a separate watchdog process.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| State Machine | Explicit switch-case in `executeStateMachine` | State pattern with `State` interface and concrete implementations |\n| Metrics Collection | Direct Prometheus HTTP API queries | Abstract `MetricsCollector` interface with adapters for Prometheus, Datadog, CloudWatch |\n| Safety Rule Evaluation | Simple expression parser (e.g., `govaluate`) | Custom DSL compiler with optimized evaluation engine |\n| Persistence | JSON files on local disk | PostgreSQL with GORM/ent for rich querying |\n| Concurrency | Goroutines with channels for coordination | Actor model using `proto.Actor` or `errgroup` with context cancellation |\n\n#### Recommended File/Module Structure\n\n```\nchaos-platform/\n├── cmd/\n│   └── orchestrator/\n│       └── main.go                 # Orchestrator service entry point\n├── internal/\n│   ├── orchestrator/\n│   │   ├── orchestrator.go         # Main Orchestrator struct and public API\n│   │   ├── state_machine.go        # executeStateMachine and state transitions\n│   │   ├── hypothesis_validator.go # validateHypothesis implementation\n│   │   ├── safety_monitor.go       # checkSafetyRules implementation\n│   │   ├── cleanup_ensurer.go      # CleanupEnsurer for fault persistence\n│   │   └── orchestrator_test.go    # Comprehensive tests\n│   ├── metrics/\n│   │   ├── collector.go            # MetricsCollector interface\n│   │   └── prometheus.go           # Prometheus implementation\n│   ├── types/\n│   │   └── experiment.go           # Experiment, Hypothesis, MetricThreshold types\n│   └── storage/\n│       ├── experiment_store.go     # Experiment persistence interface\n│       └── filestore.go            # File-based implementation\n└── pkg/\n    └── api/\n        └── v1/\n            └── experiment.go       # REST/GRPC API definitions\n```\n\n#### Infrastructure Starter Code: CleanupEnsurer\n\n```go\n// internal/orchestrator/cleanup_ensurer.go\npackage orchestrator\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n    \"time\"\n)\n\n// FaultRecord represents a fault that needs cleanup\ntype FaultRecord struct {\n    ExperimentID string    `json:\"experimentId\"`\n    FaultID      string    `json:\"faultId\"`\n    Target       string    `json:\"target\"`\n    FaultType    string    `json:\"faultType\"`\n    InjectTime   time.Time `json:\"injectTime\"`\n    CleanupCmd   string    `json:\"cleanupCmd\"` // Command to execute for cleanup\n}\n\n// CleanupEnsurer ensures faults are cleaned up even after crashes\ntype CleanupEnsurer struct {\n    mu           sync.RWMutex\n    filePath     string\n    activeFaults map[string]FaultRecord\n}\n\n// NewCleanupEnsurer creates a cleanup ensurer with persistence file\nfunc NewCleanupEnsurer(dataDir string) (*CleanupEnsurer, error) {\n    filePath := filepath.Join(dataDir, \"active_faults.json\")\n    ensurer := &CleanupEnsurer{\n        filePath:     filePath,\n        activeFaults: make(map[string]FaultRecord),\n    }\n    \n    // Load existing active faults on startup\n    if err := ensurer.load(); err != nil && !os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"loading active faults: %w\", err)\n    }\n    \n    return ensurer, nil\n}\n\n// RegisterFault records a fault that will need cleanup\nfunc (c *CleanupEnsurer) RegisterFault(record FaultRecord) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    c.activeFaults[record.FaultID] = record\n    return c.save()\n}\n\n// CompleteFault removes a fault from cleanup registry\nfunc (c *CleanupEnsurer) CompleteFault(faultID string) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    \n    delete(c.activeFaults, faultID)\n    return c.save()\n}\n\n// GetOrphanedFaults returns all faults that are still active\nfunc (c *CleanupEnsurer) GetOrphanedFaults() []FaultRecord {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    \n    faults := make([]FaultRecord, 0, len(c.activeFaults))\n    for _, fault := range c.activeFaults {\n        faults = append(faults, fault)\n    }\n    return faults\n}\n\n// CleanupOrphanedFaults executes cleanup for all orphaned faults\nfunc (c *CleanupEnsurer) CleanupOrphanedFaults(cleanupFunc func(FaultRecord) error) error {\n    orphaned := c.GetOrphanedFaults()\n    var cleanupErrors []error\n    \n    for _, fault := range orphaned {\n        if err := cleanupFunc(fault); err != nil {\n            cleanupErrors = append(cleanupErrors, \n                fmt.Errorf(\"cleaning up fault %s: %w\", fault.FaultID, err))\n            continue\n        }\n        // Only remove from registry if cleanup succeeded\n        if err := c.CompleteFault(fault.FaultID); err != nil {\n            cleanupErrors = append(cleanupErrors, err)\n        }\n    }\n    \n    if len(cleanupErrors) > 0 {\n        return fmt.Errorf(\"failed to cleanup some faults: %v\", cleanupErrors)\n    }\n    return nil\n}\n\n// load reads active faults from persistence file\nfunc (c *CleanupEnsurer) load() error {\n    data, err := os.ReadFile(c.filePath)\n    if err != nil {\n        return err\n    }\n    \n    var faults []FaultRecord\n    if err := json.Unmarshal(data, &faults); err != nil {\n        return err\n    }\n    \n    c.activeFaults = make(map[string]FaultRecord)\n    for _, fault := range faults {\n        c.activeFaults[fault.FaultID] = fault\n    }\n    return nil\n}\n\n// save writes active faults to persistence file\nfunc (c *CleanupEnsurer) save() error {\n    faults := make([]FaultRecord, 0, len(c.activeFaults))\n    for _, fault := range c.activeFaults {\n        faults = append(faults, fault)\n    }\n    \n    data, err := json.MarshalIndent(faults, \"\", \"  \")\n    if err != nil {\n        return err\n    }\n    \n    // Write to temp file first, then rename for atomicity\n    tempPath := c.filePath + \".tmp\"\n    if err := os.WriteFile(tempPath, data, 0644); err != nil {\n        return err\n    }\n    return os.Rename(tempPath, c.filePath)\n}\n```\n\n#### Core Logic Skeleton: Experiment State Machine\n\n```go\n// internal/orchestrator/state_machine.go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n    \"chaos-platform/internal/types\"\n)\n\n// executeStateMachine runs the experiment through its lifecycle\nfunc (o *Orchestrator) executeStateMachine(instance *ExperimentInstance) {\n    defer func() {\n        // Cleanup resources on exit\n        close(instance.ResultsChan)\n        o.mu.Lock()\n        delete(o.experiments, instance.Experiment.ID)\n        o.mu.Unlock()\n    }()\n    \n    ctx, cancel := context.WithCancel(context.Background())\n    instance.CancelFunc = cancel\n    \n    // State machine loop\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            // Continue state execution\n        }\n        \n        switch instance.State {\n        case types.StateBaselineValidation:\n            o.executeBaselineValidation(ctx, instance)\n        case types.StateInjecting:\n            o.executeInjecting(ctx, instance)\n        case types.StateMonitoring:\n            o.executeMonitoring(ctx, instance)\n        case types.StateRollback:\n            o.executeRollback(ctx, instance)\n        case types.StateAnalysis:\n            o.executeAnalysis(ctx, instance)\n        case types.StateCompleted, types.StateAborted:\n            // Final states - exit state machine\n            o.persistExperimentResult(instance)\n            return\n        default:\n            log.Printf(\"Unknown state %s for experiment %s\", instance.State, instance.Experiment.ID)\n            instance.State = types.StateAborted\n        }\n    }\n}\n\n// executeBaselineValidation implements BASELINE_VALIDATION state\nfunc (o *Orchestrator) executeBaselineValidation(ctx context.Context, instance *ExperimentInstance) {\n    exp := instance.Experiment\n    \n    // TODO 1: For each MetricThreshold in exp.Hypothesis.Metrics\n    //   - Parse Duration field (e.g., \"2m\" -> 2 minutes)\n    //   - Start collecting metric via metricsCollector.GetMetric() with appropriate step\n    \n    // TODO 2: Wait for all metric collection to complete (or context cancellation)\n    //   - Use time.After() for timeout based on the longest duration\n    //   - Check ctx.Done() for cancellation\n    \n    // TODO 3: Calculate baseline statistics for each metric\n    //   - Store min, max, mean, p95 in instance.MetricsBaseline map\n    \n    // TODO 4: Validate each baseline against its threshold\n    //   - For each threshold, check if baseline value within [Min, Max] range\n    //   - If any threshold violated, transition to ABORTED with error message\n    \n    // TODO 5: If all baselines valid, transition to INJECTING state\n    //   - instance.State = types.StateInjecting\n    \n    // TODO 6: Handle errors gracefully - log and transition to ABORTED\n}\n\n// executeMonitoring implements MONITORING state\nfunc (o *Orchestrator) executeMonitoring(ctx context.Context, instance *ExperimentInstance) {\n    exp := instance.Experiment\n    \n    // TODO 1: Start duration timer for exp.Duration\n    durationTimer := time.NewTimer(exp.Duration)\n    \n    // TODO 2: Start safety monitoring goroutine\n    //   - Pass exp.SafetyRules to checkSafetyRules()\n    //   - Channel to receive safety events\n    \n    // TODO 3: Start metrics collection goroutine for hypothesis validation\n    //   - Collect metrics referenced in exp.Hypothesis.Metrics\n    //   - Store in buffer for later analysis\n    \n    // TODO 4: Wait for either:\n    //   - Duration timer expiry (normal completion)\n    //   - Safety rule trigger (emergency rollback)\n    //   - Context cancellation (external abort)\n    \n    // TODO 5: If safety rule triggered:\n    //   - Record SafetyEvent in instance\n    //   - Transition to ROLLBACK state immediately\n    \n    // TODO 6: If duration timer expired:\n    //   - Transition to ROLLBACK state normally\n    \n    // TODO 7: Clean up monitoring goroutines before exiting\n}\n\n// validateHypothesis validates steady-state hypothesis against collected metrics\nfunc (o *Orchestrator) validateHypothesis(\n    hypothesis types.Hypothesis,\n    baseline map[string]float64,\n    duringMetrics map[string][]types.MetricPoint,\n) (*types.HypothesisValidation, error) {\n    result := &types.HypothesisValidation{\n        MetricResults: make([]types.MetricValidationResult, 0, len(hypothesis.Metrics)),\n    }\n    \n    // TODO 1: For each MetricThreshold in hypothesis.Metrics\n    //   - Retrieve baseline value from baseline map\n    \n    // TODO 2: Calculate statistics from duringMetrics\n    //   - Compute min, max, mean, p95 during fault injection period\n    //   - Store in MetricSample struct\n    \n    // TODO 3: Apply statistical validation\n    //   - Check if during-metrics stay within threshold bounds\n    //   - For thresholds with Duration, check violation persistence\n    //   - Record violation periods if any\n    \n    // TODO 4: Determine if metric passed validation\n    //   - Pass = during-metrics within bounds AND no prolonged violations\n    \n    // TODO 5: Set overall hypothesis validation result\n    //   - Overall = true only if ALL metrics passed\n    \n    // TODO 6: Return comprehensive validation result\n    \n    return result, nil\n}\n```\n\n#### Language-Specific Hints\n\n1. **Concurrency Pattern:** Use `errgroup.WithContext` for managing related goroutines in monitoring state. It provides automatic cancellation if any goroutine fails.\n\n2. **Metrics Collection:** Implement `MetricsCollector` interface with caching to avoid overwhelming metrics backend with duplicate queries during baseline and monitoring phases.\n\n3. **State Persistence:** For crash recovery, periodically checkpoint experiment state to disk. Use atomic file writes (write to temp file, then rename) to prevent corruption.\n\n4. **Expression Evaluation:** Use `github.com/Knetic/govaluate` for simple safety rule condition parsing (e.g., `\"error_rate > 0.05 AND latency_p95 > 200\"`).\n\n5. **Testing:** Use fake implementations of `MetricsCollector` and `fault.Injector` for unit testing state transitions without real dependencies.\n\n#### Milestone Checkpoint\n\n**Command to verify implementation:**\n```bash\n# Run orchestrator tests\ngo test ./internal/orchestrator/... -v -count=1\n\n# Expected output should show:\n# ✓ TestExperimentStateMachine_ValidBaseline\n# ✓ TestExperimentStateMachine_BaselineViolation\n# ✓ TestExperimentStateMachine_SafetyTrigger\n# ✓ TestExperimentStateMachine_CleanupOnAbort\n```\n\n**Manual verification steps:**\n1. Start the orchestrator service: `go run cmd/orchestrator/main.go`\n2. Create an experiment definition file `test-exp.json` with a simple hypothesis (e.g., \"CPU utilization < 80%\")\n3. Submit via API: `curl -X POST http://localhost:8080/experiments -d @test-exp.json`\n4. Verify experiment transitions through states:\n   - Initially shows as `DRAFT`\n   - After starting, shows `BASELINE_VALIDATION` for 1-2 minutes\n   - If baseline valid, transitions to `INJECTING` then `MONITORING`\n   - After duration, transitions to `ROLLBACK`, `ANALYSIS`, then `COMPLETED`\n5. Check results show hypothesis validation with actual metric values.\n\n**Debugging signs:**\n- Experiment stuck in `BASELINE_VALIDATION`: Likely metrics query failing. Check metrics collector connectivity.\n- Faults not injecting: Fault injector not reachable or validation failing. Check fault injector logs.\n- No auto-rollback on degradation: Safety rules not evaluating correctly. Check rule syntax and metric names.\n\n\n> **Milestone(s):** Milestone 3 (GameDay Automation)\n\n## Component Design: GameDay Automation\n\nThe **GameDay Automation** component elevates chaos engineering from isolated experiments to coordinated, realistic disaster simulations. While the `Orchestrator` runs single experiments, the GameDay engine sequences multiple experiments, integrates manual runbooks, and simulates incident response workflows, turning theoretical resilience into practiced preparedness.\n\n### Mental Model: The Disaster Simulation Drill\n\nThink of a GameDay as a city-wide emergency response drill, like a simulated earthquake or hurricane. City officials don't just test one building's fire alarm; they coordinate multiple agencies (fire, police, hospitals), simulate cascading failures (power grid down, communications overload), and practice recovery protocols with real people following checklists. Similarly, a GameDay:\n\n1. **Orchestrates multiple, related failure scenarios** in a logical sequence (e.g., first a network partition, then a database CPU spike during the resulting recovery attempt).\n2. **Involves human observers and responders** who follow runbooks, make decisions, and practice communication, just as they would in a real incident.\n3. **Simulates the pressure and ambiguity** of a real outage by introducing \"injects\"—external events like a simulated customer complaint or a management escalation—that the team must handle.\n4. **Generates a comprehensive after-action report** detailing what broke, how the team responded, and what improvements are needed.\n\nThis component is the **drill conductor**, managing the timeline, pausing for manual steps, collecting observations, and ensuring the simulation remains safe and informative.\n\n### Interface Definition\n\nThe GameDay engine is implemented as a `GameDayController` struct, which manages the execution of `Scenario` definitions. It exposes a control API and integrates with the existing `Orchestrator` to run individual experiments.\n\n#### Core Data Structures\n\n| Name | Type | Description |\n|------|------|-------------|\n| `Scenario` | struct | A complete GameDay plan containing sequential steps. |\n| `ScenarioStep` | struct | A single unit of work in a scenario: an experiment, a manual task, or a pause. |\n| `ScenarioStatus` | string constant | Current state of a scenario: `PENDING`, `RUNNING`, `PAUSED_MANUAL`, `PAUSED_OBSERVER`, `COMPLETED`, `ABORTED`. |\n| `RunbookTask` | struct | A manual task for human operators, with instructions and expected completion criteria. |\n| `ObserverBriefing` | struct | Pre-prepared information package for observers, describing the scenario's goals and what to watch. |\n| `GameDayReport` | struct | Consolidated report of a completed scenario, aggregating experiment results and observer notes. |\n\n**Scenario Struct Fields:**\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `string` | Unique identifier for the scenario. |\n| `Name` | `string` | Human-readable name (e.g., \"Q4 Payment Service Resilience Drill\"). |\n| `Description` | `string` | Overview of the scenario's goals and narrative. |\n| `Steps` | `[]ScenarioStep` | Ordered list of steps to execute. |\n| `ObserverBriefing` | `ObserverBriefing` | Pre-experiment briefing material. |\n| `CreatedAt` | `time.Time` | When the scenario was defined. |\n| `ScheduledFor` | `*time.Time` | Optional future start time. |\n| `BlastRadiusLimit` | `BlastRadius` | Global constraint applied to all experiments in the scenario (can be overridden per step). |\n| `SafetyOverride` | `[]SafetyRule` | Additional safety rules applied to all experiments. |\n\n**ScenarioStep Struct Fields:**\n| Field | Type | Description |\n|-------|------|-------------|\n| `Type` | `StepType` | One of: `EXPERIMENT`, `MANUAL_TASK`, `PAUSE`, `INJECT`. |\n| `Name` | `string` | Step name for logging and reporting. |\n| `Description` | `string` | Detailed instructions for this step. |\n| `Experiment` | `*Experiment` | If `Type` is `EXPERIMENT`, the experiment to run. |\n| `RunbookTask` | `*RunbookTask` | If `Type` is `MANUAL_TASK`, the manual task definition. |\n| `PauseDuration` | `*time.Duration` | If `Type` is `PAUSE`, how long to wait. |\n| `InjectMessage` | `*string` | If `Type` is `INJECT`, a simulated event message (e.g., \"CEO is asking for an ETA\"). |\n| `RequiresApproval` | `bool` | If true, the scenario pauses after this step and waits for explicit operator approval to continue. |\n| `AutoProceedAfter` | `*time.Duration` | Optional maximum wait time for approval before auto-aborting the scenario. |\n\n#### Controller Interface Methods\n\nThe `GameDayController` provides the following public methods:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `LoadScenario` | `scenario Scenario` | `(scenarioID string, error)` | Validates and registers a new scenario definition. Returns a unique ID. |\n| `StartScenario` | `scenarioID string` | `error` | Begins execution of a loaded scenario. Transitions to `RUNNING` and starts the first step. |\n| `PauseScenario` | `scenarioID string, reason string` | `error` | Pauses the scenario at the current step. Status becomes `PAUSED_MANUAL`. |\n| `ResumeScenario` | `scenarioID string` | `error` | Resumes a paused scenario. Continues the current step or moves to the next if the step was completed before pause. |\n| `ApproveStep` | `scenarioID string, stepIndex int, approvalNotes string` | `error` | Provides manual approval for a step marked `RequiresApproval`. Allows the scenario to proceed. |\n| `AbortScenario` | `scenarioID string, reason string` | `error` | Aborts the entire scenario, cleaning up any active experiments. Status becomes `ABORTED`. |\n| `GetScenarioStatus` | `scenarioID string` | `(ScenarioStatus, *ScenarioStep, error)` | Returns current status and the active step (if any). |\n| `AddObservation` | `scenarioID string, observation Observation` | `error` | Allows observers to attach notes, metrics, or screenshots to the scenario's report. |\n| `GenerateReport` | `scenarioID string` | `(*GameDayReport, error)` | Compiles a final report after scenario completion or abortion. |\n| `ListScenarios` | `filter ScenarioFilter` | `([]Scenario, error)` | Retrieves scenarios matching filter criteria (status, time range, etc.). |\n\n### Internal Behavior\n\nThe core of the GameDay engine is a stateful loop that processes `ScenarioStep` items sequentially. It integrates tightly with the `Orchestrator` to run experiments and with a `RunbookRenderer` to present manual tasks to human operators via a UI or chat-bot interface.\n\n#### Execution Algorithm\n\nWhen `StartScenario` is called, the controller begins the following loop in a dedicated goroutine:\n\n1. **Initialization**: Load the scenario, verify its steps are valid (e.g., experiments reference valid faults), and transition status to `RUNNING`. Emit an audit log event.\n2. **Briefing Dispatch**: If an `ObserverBriefing` exists, push it to all registered observer channels (e.g., Slack, email, dashboard). This step is non-blocking.\n3. **Step Iteration**: For each `ScenarioStep` in `Steps`:\n   a. **Pre-step Check**: Verify the overall system health via a quick global health check. If critical metrics are already breaching safety thresholds, abort the scenario.\n   b. **Step Execution**:\n      - If `Type` is `EXPERIMENT`:\n         i. Apply any scenario-level `BlastRadiusLimit` and `SafetyOverride` to the experiment definition (merging with step-specific rules).\n         ii. Call `Orchestrator.StartExperiment` with the modified experiment. The orchestrator handles its own lifecycle (baseline validation, injection, monitoring, rollback).\n         iii. Monitor the experiment's status channel. If it enters `StateAborted` due to a safety breach, record the cause and decide whether to abort the entire scenario based on scenario configuration.\n      - If `Type` is `MANUAL_TASK`:\n         i. Render the `RunbookTask` instructions and expected actions to the operator interface.\n         ii. Wait for a task completion signal (e.g., an operator clicks \"Task Complete\" in the UI). Optionally, the operator may be required to input verification data (e.g., a screenshot, a command output).\n      - If `Type` is `PAUSE`:\n         i. Sleep for the specified `PauseDuration`. This can be used to simulate \"waiting for the on-call engineer to respond\" or to allow system behavior to stabilize.\n      - If `Type` is `INJECT`:\n         i. Deliver the `InjectMessage` to observer channels (e.g., \"Simulated customer tweet: 'Is the site down?'\").\n         ii. Record the inject as an observation.\n   c. **Post-step Approval Gate**: If the step has `RequiresApproval` set to true:\n         i. Pause the scenario, set status to `PAUSED_OBSERVER`.\n         ii. Wait for an `ApproveStep` call from an operator. While waiting, if `AutoProceedAfter` is set, start a timer. If the timer fires before approval, abort the scenario.\n         iii. Upon approval, record the approval notes and resume the scenario.\n   d. **Observation Collection**: Throughout the step, observations from operators and automated monitors are collected via `AddObservation` and attached to the step's record.\n   e. **Step Completion**: Mark the step as complete, record its duration and outcome (success, failure with reason).\n4. **Scenario Completion**: After all steps are processed, transition status to `COMPLETED`. Trigger automatic report generation and distribution.\n5. **Cleanup**: Ensure all resources (experiment monitors, temporary files) are released.\n\n#### State Machine\n\nThe scenario follows a linear but interruptible state machine:\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| `PENDING` | `StartScenario` | `RUNNING` | Validate scenario, dispatch briefing, begin step loop. |\n| `RUNNING` | Step completes without requiring approval | `RUNNING` | Move to next step, execute it. |\n| `RUNNING` | Step completes with `RequiresApproval` | `PAUSED_OBSERVER` | Halt execution, notify operators approval is needed. |\n| `RUNNING` | `PauseScenario` called | `PAUSED_MANUAL` | Suspend step execution (if possible, pause any ongoing experiment). |\n| `RUNNING` | `AbortScenario` called or auto-abort condition met | `ABORTED` | Immediately stop, call `Orchestrator.AbortExperiment` for any active experiment, clean up. |\n| `RUNNING` | All steps completed | `COMPLETED` | Generate final report, notify observers. |\n| `PAUSED_OBSERVER` | `ApproveStep` called | `RUNNING` | Resume execution with next step. |\n| `PAUSED_OBSERVER` | `AutoProceedAfter` timer expires | `ABORTED` | Abort scenario due to lack of approval. |\n| `PAUSED_OBSERVER` | `AbortScenario` called | `ABORTED` | Abort scenario. |\n| `PAUSED_MANUAL` | `ResumeScenario` called | `RUNNING` | Resume execution from the point of pause. |\n| `PAUSED_MANUAL` | `AbortScenario` called | `ABORTED` | Abort scenario. |\n| Any state | System-wide emergency stop signal | `ABORTED` | Immediate forced abort, highest priority cleanup. |\n\n> **Key Insight:** The distinction between `PAUSED_OBSERVER` (waiting for explicit approval) and `PAUSED_MANUAL` (general pause) is crucial. The former is a gating mechanism for runbook steps; the latter is a safety valve for unexpected issues during the drill.\n\n#### Integration with Orchestrator\n\nThe GameDay controller does not duplicate experiment execution logic. Instead, it delegates to the existing `Orchestrator`, treating each experiment step as a black box. However, it enhances safety by:\n- **Adding scenario-level safety rules** on top of experiment-specific ones.\n- **Monitoring for experiment abortion** and deciding whether that should cascade to abort the entire scenario.\n- **Aggregating results** from all experiments into a unified GameDay report.\n\nThe controller subscribes to the `Orchestrator`'s result channel for each experiment to capture the final `ExperimentResult` and any real-time `Observation` events.\n\n### ADR: Integration with Incident Management\n\n> **Decision: Simulated Incident Tickets Only (No Live Integration)**\n\n- **Context**: GameDays simulate real incidents. A key question is whether to integrate with the production incident management system (e.g., create real PagerDuty incidents, JIRA tickets) to make the drill feel authentic, or to keep simulations entirely isolated to avoid noise and confusion.\n- **Options Considered**:\n  1. **Full Production Integration**: Create real tickets, pages, and conference bridges. This provides the most realistic training pressure.\n  2. **Shadow Integration**: Create tickets in a dedicated \"drill\" project within the same tooling (e.g., a separate PagerDuty service, a JIRA label \"SIMULATION\"). Real processes are followed, but the artifacts are clearly marked as non-production.\n  3. **No Integration (Simulated Only)**: Use internal GameDay dashboards and chat channels for all communication. No external systems are modified.\n- **Decision**: Option 2, **Shadow Integration**, is chosen for the initial implementation.\n- **Rationale**:\n  - **Realism without Risk**: Using the actual tools (e.g., clicking the same \"Declare Incident\" button in JIRA) builds muscle memory, but doing so in a sandboxed environment prevents accidental waking of on-call engineers or polluting production metrics.\n  - **Process Validation**: It allows validation that the incident management workflows themselves function correctly (e.g., escalation rules, notification templates) without causing alert fatigue.\n  - **Clear Audit Trail**: Tickets created in a dedicated project provide a perfect audit trail for the drill, which can be reviewed later.\n  - **Progressive Enhancement**: This serves as a stepping stone. Teams that mature in their chaos practices can opt-in to \"full integration\" drills occasionally, but the platform defaults to safe isolation.\n- **Consequences**:\n  - **Additional Configuration Required**: The platform needs to be configured with API keys and project IDs for the shadow environments.\n  - **Slightly Reduced Pressure**: Engineers may subconsciously treat the drill differently knowing the tickets aren't \"real,\" though clear marking helps maintain seriousness.\n  - **Need for Cleanup**: The GameDay engine must include a post-drill cleanup phase to close or archive the shadow tickets.\n\n**Comparison Table:**\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Full Production Integration | Maximum realism, tests full pipeline | High risk of confusion/alert fatigue, potentially destructive | No |\n| Shadow Integration | Good realism, safe, validates tooling | Requires setup of duplicate environments, slightly less pressure | **Yes** |\n| Simulated Only | Simplest, zero risk of leakage | Unrealistic, doesn't test incident tooling workflow | No |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Running the Drill Without Briefing Observers**\n*Description:* Jumping directly into executing a complex GameDay scenario without first briefing the participating engineers and stakeholders.\n*Why it's wrong:* Unprepared observers will waste time figuring out what's happening instead of observing system behavior and practicing response. They might misinterpret simulated faults as real outages and initiate unnecessary escalation, or they might miss critical learning opportunities because they don't know what to look for.\n*How to fix:* The `GameDayController` must enforce that the `ObserverBriefing` is delivered and acknowledged before the first step begins. Implement a mandatory \"briefing acknowledged\" gate, where key participants must signal they've read the briefing. The briefing should include: the scenario narrative, the schedule, what faults will be injected, what the expected system behavior is, and clear instructions on how to distinguish simulation from reality (e.g., \"all alerts will be prefixed with [GAMEDAY]\").\n\n⚠️ **Pitfall: Overly Complex Scenario Scripting**\n*Description:* Creating a GameDay scenario with dozens of intricate, interdependent steps that are impossible to manage or debug.\n*Why it's wrong:* Complexity increases the chance of something going wrong with the chaos platform itself, derailing the entire drill. It also makes it difficult to isolate which fault caused which observed effect, muddying the learning outcomes.\n*How to fix:* Design scenarios using the **\"Single Fault, Clear Hypothesis\"** principle. Each experiment step should test one specific aspect of resilience. Use `PAUSE` and `MANUAL_TASK` steps to separate concerns and allow for analysis. Start with 2-3 step scenarios and gradually increase complexity as the team's familiarity grows.\n\n⚠️ **Pitfall: Ignoring the \"Injects\"**\n*Description:* Treating the GameDay as a purely technical sequence of fault injections, ignoring the human and process elements simulated by `INJECT` steps.\n*Why it's wrong:* Real incidents involve external pressure—customer complaints, management questions, partner escalations. Not simulating these leaves the team unprepared for the communication and prioritization challenges of a real outage.\n*How to fix:* Mandate at least one `INJECT` step per GameDay that simulates external communication. Use a realistic channel (e.g., a simulated customer support ticket, a message in an executive chat room). Observe and debrief on how the team handles the communication, not just the technical mitigation.\n\n### Implementation Guidance\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Scenario Storage | File-based YAML definitions in `scenarios/` directory | Database table with versioning and audit history |\n| Observer Notifications | Logging to stdout and a file | Integration with Slack/Teams webhooks and email (SMTP) |\n| Runbook Task UI | CLI prompts requiring operator input | Web dashboard with real-time collaboration and task tracking |\n| Shadow Incident Integration | Mock API client that logs actions | Full integration with JIRA/PagerDuty/Servicenow test instances |\n| Report Generation | Plain text markdown report | HTML report with embedded charts (using metrics collector data) |\n\n#### Recommended File/Module Structure\n\nAdd the GameDay component to the existing project layout:\n\n```\nchaos-platform/\n├── cmd/\n│   ├── chaos-server/          # Main API server\n│   └── gameday-cli/           # CLI for controlling GameDays\n├── internal/\n│   ├── experiment/            # Existing orchestrator\n│   ├── fault/                 # Existing fault injector\n│   ├── metrics/               # Existing metrics collector\n│   ├── safety/                # Existing safety monitor\n│   ├── gameday/               # NEW: GameDay automation component\n│   │   ├── controller.go      # GameDayController implementation\n│   │   ├── scenario.go        # Scenario, ScenarioStep struct definitions\n│   │   ├── runbook.go         # RunbookTask rendering and completion tracking\n│   │   ├── briefing.go        # ObserverBriefing generation and delivery\n│   │   ├── report.go          # GameDayReport generation\n│   │   └── integrations/      # Integrations with external systems\n│   │       ├── slack.go\n│   │       ├── jira.go        # Shadow ticket creation\n│   │       └── pagerduty.go\n│   └── types.go               # Shared types (updated with GameDay types)\n├── scenarios/                 # Directory for YAML scenario definitions\n│   └── payment-service-drill.yaml\n└── web/ui/                   # Optional web dashboard\n    └── gameday/              # GameDay-specific UI components\n```\n\n#### Infrastructure Starter Code: Scenario YAML Parser\n\nThe following is a complete, ready-to-use parser for loading scenario definitions from YAML files. It uses the `gopkg.in/yaml.v3` package.\n\n```go\n// internal/gameday/loader.go\npackage gameday\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"time\"\n\n    \"chaos-platform/internal/experiment\"\n    \"gopkg.in/yaml.v3\"\n)\n\n// LoadScenarioFromFile reads a YAML file and returns a Scenario struct.\nfunc LoadScenarioFromFile(filePath string) (*Scenario, error) {\n    data, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read scenario file: %w\", err)\n    }\n\n    var scenario Scenario\n    if err := yaml.Unmarshal(data, &scenario); err != nil {\n        return nil, fmt.Errorf(\"failed to parse scenario YAML: %w\", err)\n    }\n\n    // Validate required fields\n    if scenario.ID == \"\" {\n        return nil, fmt.Errorf(\"scenario must have an ID\")\n    }\n    if scenario.Name == \"\" {\n        return nil, fmt.Errorf(\"scenario must have a name\")\n    }\n    if len(scenario.Steps) == 0 {\n        return nil, fmt.Errorf(\"scenario must have at least one step\")\n    }\n\n    // Validate each step\n    for i, step := range scenario.Steps {\n        if step.Name == \"\" {\n            return nil, fmt.Errorf(\"step %d must have a name\", i)\n        }\n        switch step.Type {\n        case \"EXPERIMENT\":\n            if step.Experiment == nil {\n                return nil, fmt.Errorf(\"step %d (%s) is of type EXPERIMENT but has no experiment definition\", i, step.Name)\n            }\n            // You could add more validation for the experiment here\n        case \"MANUAL_TASK\":\n            if step.RunbookTask == nil {\n                return nil, fmt.Errorf(\"step %d (%s) is of type MANUAL_TASK but has no runbook task\", i, step.Name)\n            }\n        case \"PAUSE\":\n            if step.PauseDuration == nil || *step.PauseDuration <= 0 {\n                return nil, fmt.Errorf(\"step %d (%s) is of type PAUSE but has invalid or missing duration\", i, step.Name)\n            }\n        case \"INJECT\":\n            if step.InjectMessage == nil || *step.InjectMessage == \"\" {\n                return nil, fmt.Errorf(\"step %d (%s) is of type INJECT but has no message\", i, step.Name)\n            }\n        default:\n            return nil, fmt.Errorf(\"step %d (%s) has unknown type: %s\", i, step.Name, step.Type)\n        }\n    }\n\n    return &scenario, nil\n}\n\n// SaveScenarioToFile writes a Scenario struct to a YAML file.\nfunc SaveScenarioToFile(scenario *Scenario, filePath string) error {\n    data, err := yaml.Marshal(scenario)\n    if err != nil {\n        return fmt.Errorf(\"failed to marshal scenario to YAML: %w\", err)\n    }\n    if err := ioutil.WriteFile(filePath, data, 0644); err != nil {\n        return fmt.Errorf(\"failed to write scenario file: %w\", err)\n    }\n    return nil\n}\n```\n\n#### Core Logic Skeleton: Sequential Scenario Executor\n\nThis is the main driver method of the `GameDayController`. Learners must fill in the TODOs.\n\n```go\n// internal/gameday/controller.go\npackage gameday\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"time\"\n\n    \"chaos-platform/internal/experiment\"\n    \"chaos-platform/internal/types\"\n)\n\ntype GameDayController struct {\n    mu            sync.RWMutex\n    scenarios     map[string]*scenarioInstance\n    orchestrator  *experiment.Orchestrator\n    notifier      Notifier\n    // ... other fields (e.g., integrations, observation channels)\n}\n\ntype scenarioInstance struct {\n    Scenario   Scenario\n    Status     ScenarioStatus\n    CurrentStep int\n    StartedAt  time.Time\n    EndedAt    *time.Time\n    Observations []types.Observation\n    // ... additional execution state\n}\n\n// executeScenario is the main loop for running a scenario. It is called in a goroutine by StartScenario.\nfunc (c *GameDayController) executeScenario(scenarioID string) error {\n    c.mu.Lock()\n    instance, ok := c.scenarios[scenarioID]\n    if !ok {\n        c.mu.Unlock()\n        return fmt.Errorf(\"scenario %s not found\", scenarioID)\n    }\n    instance.Status = RUNNING\n    instance.StartedAt = time.Now()\n    c.mu.Unlock()\n\n    // TODO 1: Dispatch the observer briefing via the notifier.\n    //   Use c.notifier.SendBriefing(instance.Scenario.ObserverBriefing)\n    //   Optionally, wait for acknowledgments if required.\n\n    // Iterate through steps\n    for stepIdx, step := range instance.Scenario.Steps {\n        c.mu.Lock()\n        instance.CurrentStep = stepIdx\n        c.mu.Unlock()\n\n        log.Printf(\"[GameDay %s] Starting step %d: %s\", scenarioID, stepIdx, step.Name)\n\n        // TODO 2: Pre-step health check.\n        //   Perform a quick global health check (e.g., call a predefined health endpoint).\n        //   If health is critical, abort the scenario with reason \"pre-step health check failed\".\n\n        // Execute step based on type\n        switch step.Type {\n        case \"EXPERIMENT\":\n            // TODO 3: Apply scenario-level overrides to the experiment.\n            //   Merge instance.Scenario.BlastRadiusLimit and SafetyOverride with step.Experiment fields.\n            //   Ensure the merged experiment is valid.\n\n            // TODO 4: Run the experiment via the orchestrator.\n            //   Create a channel to receive the experiment result.\n            //   Call c.orchestrator.StartExperiment(mergedExperiment, resultChan).\n            //   Monitor the experiment status. If it aborts due to safety, decide whether to abort scenario.\n            //   Wait for the experiment to complete (reach COMPLETED or ABORTED state).\n            //   Collect the final ExperimentResult and add it to the scenario report.\n\n        case \"MANUAL_TASK\":\n            // TODO 5: Present the manual task to operators.\n            //   Use c.notifier.SendTask(step.RunbookTask) to post instructions.\n            //   Wait for a task completion signal (e.g., from a channel or callback).\n            //   Optionally, validate any verification data provided by the operator.\n\n        case \"PAUSE\":\n            // TODO 6: Pause for the specified duration.\n            //   Use time.Sleep(*step.PauseDuration).\n            //   Log a message and optionally notify observers that the scenario is pausing.\n\n        case \"INJECT\":\n            // TODO 7: Deliver the inject message.\n            //   Use c.notifier.SendInject(*step.InjectMessage).\n            //   Record the inject as an observation with source \"inject\".\n\n        default:\n            // This should have been caught in validation, but handle gracefully.\n            log.Printf(\"Unknown step type: %s\", step.Type)\n        }\n\n        // TODO 8: Handle post-step approval gate.\n        //   If step.RequiresApproval is true:\n        //     - Set instance.Status to PAUSED_OBSERVER.\n        //     - Notify observers that approval is required.\n        //     - Start a timer for step.AutoProceedAfter if set.\n        //     - Wait for either an ApproveStep call or the timer to expire.\n        //     - If timer expires, abort scenario with reason \"approval timeout\".\n        //     - If approved, record approval notes and resume.\n\n        // TODO 9: Collect any observations that were added during this step.\n        //   Observations can be added concurrently via AddObservation. Gather them and attach to the step record.\n    }\n\n    // TODO 10: Scenario completion.\n    //   Set instance.Status to COMPLETED, record EndedAt.\n    //   Trigger report generation (call c.generateReport(scenarioID)).\n    //   Notify observers that the scenario has ended.\n\n    return nil\n}\n\n// StartScenario begins execution of a loaded scenario.\nfunc (c *GameDayController) StartScenario(scenarioID string) error {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    instance, ok := c.scenarios[scenarioID]\n    if !ok {\n        return fmt.Errorf(\"scenario %s not found\", scenarioID)\n    }\n    if instance.Status != PENDING {\n        return fmt.Errorf(\"scenario %s is not in PENDING state (current: %s)\", scenarioID, instance.Status)\n    }\n\n    // Launch execution in a goroutine so the API call returns immediately.\n    go func() {\n        if err := c.executeScenario(scenarioID); err != nil {\n            log.Printf(\"Scenario %s failed: %v\", scenarioID, err)\n            // Handle failure (e.g., set status to ABORTED)\n        }\n    }()\n    return nil\n}\n```\n\n#### Language-Specific Hints\n\n- **Concurrency Management:** Use `sync.RWMutex` on the `GameDayController` to protect the `scenarios` map. Each `scenarioInstance` should have its own mutex if its internal fields are accessed from multiple goroutines (e.g., from the main execution loop and from the `AddObservation` method).\n- **Context Propagation:** Pass a `context.Context` through the execution chain, especially for steps that involve network calls (e.g., starting an experiment). This allows for centralized cancellation if the scenario is aborted.\n- **Error Handling in Goroutines:** Ensure that panics in the `executeScenario` goroutine are recovered and logged, and the scenario status is updated to `FAILED`. Consider using a `panicHandler` middleware.\n- **YAML Parsing:** Use the `gopkg.in/yaml.v3` package for robust YAML parsing. It preserves order of fields and has good error messages. Remember to define YAML struct tags (`` `yaml:\"field_name\"` ``) on all struct fields that need to be serialized.\n\n#### Milestone Checkpoint\n\nAfter implementing the GameDay Automation component, you should be able to:\n\n1. **Load a scenario definition:**\n   ```bash\n   go run cmd/gameday-cli/main.go load-scenario scenarios/payment-service-drill.yaml\n   ```\n   Expected output: `Scenario \"payment-service-drill\" loaded with ID: drill_12345`\n\n2. **Start the scenario:**\n   ```bash\n   go run cmd/gameday-cli/main.go start-scenario drill_12345\n   ```\n   Expected behavior: The CLI returns immediately. In the logs, you should see:\n   ```\n   Dispatching observer briefing...\n   Starting step 0: Inject database latency...\n   Starting experiment exp_001...\n   ```\n\n3. **Simulate manual approval:**\n   If a step requires approval, the scenario should pause. You can then call:\n   ```bash\n   go run cmd/gameday-cli/main.go approve-step drill_12345 0 \"Looks good, proceed.\"\n   ```\n   The scenario should resume and continue to the next step.\n\n4. **Generate a report:**\n   After completion, run:\n   ```bash\n   go run cmd/gameday-cli/main.go report drill_12345\n   ```\n   This should output a markdown report summarizing each step, experiment results, and observations.\n\n**Signs of Trouble:**\n- **Scenario gets stuck:** Check that the `executeScenario` loop is properly handling each step type and moving to the next step. Add detailed logging at each transition.\n- **Experiments not starting:** Verify that the `Orchestrator` client is correctly configured and that the experiment definition is valid after merging scenario-level overrides.\n- **Observations lost:** Ensure the `AddObservation` method is thread-safe and correctly appending to the `instance.Observations` slice. Use a mutex.\n\n\n> **Milestone(s):** All milestones (cross-cutting interaction patterns for entire platform)\n\n## Interactions and Data Flow\n\n### Mental Model: The Air Traffic Control Tower\n\nImagine a busy international airport where multiple flights are simultaneously taxiing, taking off, and landing. The **air traffic control tower** coordinates all these activities through a well-defined communication protocol:\n\n1. **Flight Plans** (experiment definitions) are submitted in advance with specific routes and schedules\n2. **Clearance Delivery** (orchestrator) validates plans and issues start permissions\n3. **Ground Control** (fault injector) manages movement on taxiways (applying faults)\n4. **Tower Control** (safety monitor) watches active runways for conflicts (metric breaches)\n5. **Approach/Departure** (metrics collector) tracks flights throughout their journey\n6. **Flight Recorders** (result analyzer) capture all communications and outcomes\n\nJust as air traffic controllers use specific radio phraseology (\"Delta 123, cleared for takeoff runway 27L\"), our components communicate through structured messages with precise semantics. This section details those communication patterns that enable safe, coordinated chaos experiments.\n\n### Key Sequence: Running an Experiment\n\nThe most critical workflow in the platform is executing a single chaos experiment from start to finish. This sequence involves all five major components (Experiment Controller, Fault Injector, Safety Monitor, Metrics Collector, and Result Analyzer) and follows the scientific method: hypothesize, experiment, observe, conclude.\n\n#### Pre-Flight Checklist: Experiment Creation and Validation\n\nBefore any fault injection occurs, the experiment must be properly defined and validated:\n\n1. **Definition Submission**: A user or automated system creates an `Experiment` struct with all required fields (hypothesis, faults, schedule, safety rules) and calls `CreateExperiment()` on the Experiment Controller.\n\n2. **Structural Validation**: The controller validates the experiment definition:\n   - Syntax checking (required fields, proper types)\n   - Fault parameter validation (e.g., latency values within reasonable bounds)\n   - Target existence verification (ensuring specified services/pods exist)\n   - Safety rule sanity checking (thresholds that make sense)\n\n3. **Storage**: The validated experiment is persisted to durable storage (database or file system) with status `DRAFT`.\n\n4. **Scheduling**: If the schedule type is `IMMEDIATE`, the experiment is queued for immediate execution. For `ONE_TIME` or `CRON` schedules, it's stored for future execution by a scheduler component.\n\n#### Experiment Execution: A Detailed Walkthrough\n\nConsider a concrete example: Testing a payment service's resilience to database latency spikes. The experiment injects 500ms of latency between the payment service and its MySQL database for 5 minutes, while monitoring the 95th percentile response time and error rate.\n\n**Step-by-Step Sequence:**\n\n1. **Experiment Start Command**: \n   - User calls `StartExperiment()` on the Experiment Controller with the experiment ID\n   - Controller loads the experiment from storage, validates it's in a startable state (not already running), and creates an `ExperimentInstance`\n   - Status transitions from `DRAFT` to `BASELINE_VALIDATION`\n\n2. **Baseline Establishment Phase**:\n   - Controller calls `ValidateHypothesis()` on the Safety Monitor, passing the experiment's `Hypothesis` and requesting a 2-minute baseline measurement\n   - Safety Monitor queries the Metrics Collector for each metric in the hypothesis using `GetMetric()` with a time window of `[now-2min, now]`\n   - Metrics Collector retrieves time-series data from monitoring systems (Prometheus, Datadog, etc.)\n   - Safety Monitor computes statistical baselines (mean, percentiles) for each metric\n   - If any metric violates its threshold during baseline (system already unhealthy), the experiment transitions to `ABORTED` with appropriate diagnostics\n   - If baseline validation passes, the experiment transitions to `INJECTING`\n\n3. **Fault Injection Coordination**:\n   - Controller iterates through the experiment's `Faults` array\n   - For each fault, it calls `InjectFault()` on the appropriate Fault Injector agent\n   - The Fault Injector validates the fault parameters, applies the fault (e.g., using `tc netem` for network latency), and returns a `faultID`\n   - Controller records each `FaultInjectionRecord` with injection timestamp and status\n   - After all faults are applied, experiment transitions to `MONITORING`\n   - ![Sequence Diagram: Injecting a Network Latency Fault](./diagrams/diag-seq-fault.svg)\n\n4. **Active Monitoring Phase**:\n   - Controller starts two concurrent monitoring loops:\n     - **Duration Timer**: Counts down the experiment's `Duration` (5 minutes in our example)\n     - **Safety Monitoring**: Continuously calls `checkSafetyRules()` on the Safety Monitor\n   - Safety Monitor periodically queries the Metrics Collector for current metric values\n   - If any safety rule triggers (e.g., error rate exceeds 5% for 30 seconds):\n     - Safety Monitor sends an `AbortEvent` to the Controller\n     - Controller immediately transitions to `ROLLBACK` phase\n   - ![Sequence Diagram: Safety-Triggered Auto-Rollback](./diagrams/diag-seq-safety.svg)\n\n5. **Rollback Phase**:\n   - Controller iterates through all active faults and calls `CleanupFault()` on each Fault Injector\n   - Each Fault Injector removes the applied fault (e.g., deletes `tc` rules, kills stress processes)\n   - Fault Injector confirms cleanup completion\n   - Controller updates each `FaultInjectionRecord` with cleanup timestamp\n   - Experiment transitions to `ANALYSIS`\n\n6. **Post-Experiment Analysis**:\n   - Controller calls `ValidateHypothesis()` again on the Safety Monitor, this time comparing:\n     - Baseline period metrics (before injection)\n     - Injection period metrics (during fault)\n     - Recovery period metrics (after cleanup)\n   - Safety Monitor performs statistical comparison (t-tests, threshold checking)\n   - Result Analyzer compiles a comprehensive `ExperimentResult` including:\n     - Hypothesis validation outcome (pass/fail with confidence intervals)\n     - Timeline of events (injection times, safety triggers, rollback)\n     - Metric graphs and statistical summaries\n     - Observations and annotations\n   - Experiment transitions to `COMPLETED`\n   - Final report is persisted and optionally sent to notification channels\n\n7. **Cleanup Ensurer Double-Check**:\n   - Regardless of success or failure, the `CleanupEnsurer` component verifies that no orphaned faults remain\n   - On system restart, `RecoverOrphanedFaults()` scans for active fault records and initiates cleanup\n\n#### State Transition Table During Execution\n\n| Current State | Event Trigger | Next State | Actions Taken |\n|---------------|---------------|------------|---------------|\n| `DRAFT` | `StartExperiment()` called | `BASELINE_VALIDATION` | Load experiment, create instance, start baseline timer |\n| `BASELINE_VALIDATION` | Baseline validation passes | `INJECTING` | Record baseline metrics, begin fault injection |\n| `BASELINE_VALIDATION` | Baseline validation fails | `ABORTED` | Record failure reason, generate result |\n| `INJECTING` | All faults injected successfully | `MONITORING` | Start duration timer, begin safety monitoring |\n| `INJECTING` | Any fault injection fails | `ROLLBACK` | Cleanup already-injected faults, record error |\n| `MONITORING` | Duration timer expires | `ROLLBACK` | Initiate normal cleanup sequence |\n| `MONITORING` | Safety rule triggers | `ROLLBACK` | Record safety event, initiate emergency cleanup |\n| `ROLLBACK` | All faults cleaned up | `ANALYSIS` | Compile fault timeline, begin post-analysis |\n| `ANALYSIS` | Analysis complete | `COMPLETED` | Generate final report, persist results |\n| Any state | External abort command | `ROLLBACK` | Record abort reason, begin cleanup |\n\n#### Error Recovery Scenarios\n\n**Scenario 1: Fault Injector Agent Unreachable During Injection**\n- Controller attempts `InjectFault()` RPC call with 30-second timeout\n- On timeout, controller marks that specific fault as `FAILED`\n- If experiment has `continueOnFaultFailure: false` (default), experiment transitions to `ROLLBACK` immediately\n- If `continueOnFaultFailure: true`, controller skips that fault and continues with others\n- Failed fault is recorded in results with error details\n\n**Scenario 2: Metrics Collector Service Down During Monitoring**\n- Safety Monitor's `checkSafetyRules()` call to Metrics Collector fails\n- Safety Monitor retries with exponential backoff (1s, 2s, 4s, 8s)\n- After 4 failures, Safety Monitor sends `MetricsUnavailableEvent` to Controller\n- Controller pauses experiment (enters `PAUSED` substate), waiting for metrics to return\n- If metrics return within 5 minutes, experiment resumes\n- If metrics remain unavailable, experiment transitions to `ROLLBACK` with \"metrics unavailable\" reason\n\n**Scenario 3: Controller Process Crashes Mid-Experiment**\n- On restart, Controller scans for experiments in active states (`BASELINE_VALIDATION` through `ANALYSIS`)\n- For each, it calls `RecoverOrphanedFaults()` on the Fault Injector\n- Fault Injector reports which faults are still active\n- Controller resumes experiment from appropriate state based on:\n  - If faults active → resume in `MONITORING` or `ROLLBACK` depending on elapsed time\n  - If no faults active but experiment wasn't complete → resume in `ANALYSIS`\n  - Uses `CleanupEnsurer`'s persistent record as ground truth\n\n### Message Formats\n\nComponents communicate through two primary patterns: synchronous RPC (for control operations) and asynchronous events (for monitoring and alerts). All messages use Protocol Buffers for serialization, providing strong typing and backward/forward compatibility.\n\n#### Control Plane RPC Messages\n\nThese messages follow request-response semantics and are used for experiment management, fault injection commands, and status queries.\n\n**Experiment Management RPCs:**\n\n| Message Type | Direction | Purpose | Fields (Type → Description) |\n|--------------|-----------|---------|----------------------------|\n| `CreateExperimentRequest` | Client → Controller | Create new experiment definition | `experiment` (`Experiment`) → Full experiment specification |\n| `CreateExperimentResponse` | Controller → Client | Acknowledge creation | `experiment_id` (`string`) → Unique identifier for created experiment<br>`warnings` (`[]string`) → Validation warnings (non-fatal) |\n| `StartExperimentRequest` | Client → Controller | Begin experiment execution | `experiment_id` (`string`) → ID of experiment to start<br>`override_params` (`map<string, string>`) → Optional parameter overrides |\n| `StartExperimentResponse` | Controller → Client | Acknowledge start | `instance_id` (`string`) → ID of this experiment instance<br>`estimated_duration` (`Duration`) → Expected total runtime |\n| `AbortExperimentRequest` | Any → Controller | Forcefully stop experiment | `experiment_id` (`string`) → ID of experiment to abort<br>`reason` (`string`) → Human-readable abort reason<br>`emergency` (`bool`) → Skip graceful cleanup if true |\n| `AbortExperimentResponse` | Controller → Any | Confirm abort initiated | `abort_initiated` (`bool`) → Whether abort was accepted<br>`cleanup_estimated` (`Duration`) → Estimated time for cleanup |\n\n**Fault Injection RPCs:**\n\n| Message Type | Direction | Purpose | Fields (Type → Description) |\n|--------------|-----------|---------|----------------------------|\n| `InjectFaultRequest` | Controller → Fault Injector | Apply a specific fault | `fault` (`Fault`) → Fault definition to apply<br>`experiment_id` (`string`) → Experiment context ID<br>`request_id` (`string`) → Unique request ID for idempotency |\n| `InjectFaultResponse` | Fault Injector → Controller | Confirm fault injection | `fault_id` (`string`) → Unique identifier for this fault instance<br>`status` (`FaultStatus`) → Initial status details<br>`warnings` (`[]string`) → Non-critical warnings |\n| `CleanupFaultRequest` | Controller → Fault Injector | Remove previously injected fault | `fault_id` (`string`) → ID of fault to clean up<br>`force` (`bool`) → Force removal even if cleanup commands fail |\n| `CleanupFaultResponse` | Fault Injector → Controller | Confirm cleanup | `cleaned` (`bool`) → Whether cleanup succeeded<br>`details` (`string`) → Cleanup execution details<br>`remaining_faults` (`int32`) → Count of other active faults from same experiment |\n\n**Metrics and Safety RPCs:**\n\n| Message Type | Direction | Purpose | Fields (Type → Description) |\n|--------------|-----------|---------|----------------------------|\n| `ValidateHypothesisRequest` | Controller → Safety Monitor | Validate steady-state hypothesis | `hypothesis` (`Hypothesis`) → Hypothesis to validate<br>`time_range` (`TimeRange`) → Time window to analyze<br>`baseline_only` (`bool`) → If true, only collect baseline (no during/after) |\n| `ValidateHypothesisResponse` | Safety Monitor → Controller | Hypothesis validation results | `validation` (`HypothesisValidation`) → Detailed validation results<br>`data_quality` (`DataQuality`) → Metrics on data completeness/quality |\n| `QueryMetricsRequest` | Safety Monitor → Metrics Collector | Retrieve time-series metrics | `queries` (`[]MetricQuery`) → List of metric queries<br>`start_time` (`Timestamp`) → Start of time range<br>`end_time` (`Timestamp`) → End of time range<br>`step` (`Duration`) → Resolution for returned data |\n| `QueryMetricsResponse` | Metrics Collector → Safety Monitor | Time-series metric data | `results` (`[]MetricSeries`) → One series per query<br>`query_errors` (`[]QueryError`) → Errors for individual failed queries |\n\n#### Event Bus Messages\n\nThese messages are published asynchronously to an event bus (like NATS or Kafka) for decoupled communication between components. Events use a common envelope structure:\n\n**Event Envelope (all events contain these fields):**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `event_id` | `string` | Unique event identifier (UUID) |\n| `event_type` | `string` | Event type name (e.g., \"SafetyThresholdBreached\") |\n| `timestamp` | `Timestamp` | When event was published |\n| `source_component` | `string` | Component that published the event |\n| `correlation_id` | `string` | Links related events (e.g., all from same experiment) |\n| `payload` | `bytes` | Serialized event-specific payload |\n\n**Key Event Types and Their Payloads:**\n\n| Event Type | Published By | Consumed By | Payload Fields (Type → Description) |\n|------------|--------------|-------------|-------------------------------------|\n| `ExperimentStateChanged` | Controller | Result Analyzer, Notification Service | `experiment_id` (`string`) → Experiment identifier<br>`old_state` (`string`) → Previous state<br>`new_state` (`string`) → New state<br>`reason` (`string`) → Why state changed |\n| `SafetyThresholdBreached` | Safety Monitor | Controller | `experiment_id` (`string`) → Experiment identifier<br>`rule` (`SafetyRule`) → Rule that was breached<br>`current_value` (`float64`) → Metric value that triggered breach<br>`duration_breached` (`Duration`) → How long threshold was exceeded |\n| `FaultInjectionCompleted` | Fault Injector | Controller, Result Analyzer | `fault_id` (`string`) → Fault instance identifier<br>`experiment_id` (`string`) → Experiment identifier<br>`fault_type` (`FaultType`) → Type of fault injected<br>`target` (`string`) → What was affected<br>`commands_executed` (`[]ExecutedCommand`) → Commands run to apply fault |\n| `MetricsCollectionFailed` | Metrics Collector | Controller, Safety Monitor | `experiment_id` (`string`) → Experiment identifier (if applicable)<br>`query` (`string`) → Failed metric query<br>`error` (`string`) → Failure reason<br>`retry_count` (`int32`) → How many retries attempted |\n| `ManualApprovalRequired` | GameDay Controller | Notification Service, UI | `scenario_id` (`string`) → Scenario identifier<br>`step_index` (`int32`) → Which step requires approval<br>`step_description` (`string`) → Human-readable description<br>`approval_deadline` (`Timestamp`) → When auto-proceed will happen |\n| `ObserverAnnotationAdded` | Any component | Result Analyzer | `experiment_id` (`string`) → Experiment identifier (optional)<br>`scenario_id` (`string`) → Scenario identifier (optional)<br>`observation` (`Observation`) → Observation details<br>`author` (`string`) → Who added the observation |\n\n#### Internal Component Communication Patterns\n\n**Pattern 1: Command-Query Responsibility Segregation (CQRS) for Metrics**\n- **Command Side**: Fault Injector publishes `FaultInjectionCompleted` events when faults are applied\n- **Query Side**: Metrics Collector listens to these events and begins collecting specialized metrics for that fault period\n- **Benefit**: Decouples fault application from metric collection, allowing different collection strategies per fault type\n\n**Pattern 2: Saga Pattern for Experiment Rollback**\n- When experiment needs to roll back (due to safety breach or manual abort):\n  1. Controller publishes `ExperimentRollbackInitiated` event\n  2. Each Fault Injector listens for this event with correlation ID matching its experiment\n  3. Each injector independently cleans up its faults and publishes `FaultCleanupCompleted`\n  4. Controller listens for all expected cleanup events with timeout\n  5. If timeout expires, controller directly calls `CleanupFault()` RPC for missing faults\n- **Benefit**: Fault tolerance - if one injector fails, others still clean up; controller orchestrates recovery\n\n**Pattern 3: Event Sourcing for Audit Trail**\n- All state changes (`ExperimentStateChanged`) are published as events\n- Result Analyzer subscribes to all events and builds complete audit trail\n- On restart, components can replay events to reconstruct state\n- **Benefit**: Complete observability and debuggability of all experiment executions\n\n#### Message Serialization Example\n\n```protobuf\n// Example Protocol Buffer definition for key messages\nsyntax = \"proto3\";\n\npackage chaos.platform.v1;\n\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/duration.proto\";\n\nmessage InjectFaultRequest {\n  Fault fault = 1;\n  string experiment_id = 2;\n  string request_id = 3;  // For idempotency\n}\n\nmessage SafetyThresholdBreachedEvent {\n  string event_id = 1;\n  google.protobuf.Timestamp timestamp = 2;\n  string source_component = 3;\n  string correlation_id = 4;\n  \n  // Event-specific payload\n  string experiment_id = 5;\n  SafetyRule rule = 6;\n  double current_value = 7;\n  google.protobuf.Duration duration_breached = 8;\n}\n```\n\n### Component Interaction During GameDay Scenarios\n\nGameDay scenarios introduce additional complexity by coordinating multiple experiments with manual intervention points. The communication pattern becomes a choreographed sequence rather than a single experiment flow.\n\n![Flowchart: GameDay Scenario Execution](./diagrams/diag-flow-gameday.svg)\n\n**GameDay Execution Sequence:**\n\n1. **Scenario Loading**: `GameDayController.LoadScenario()` reads YAML definition, validates it, and stores it with status `PENDING`\n\n2. **Step-by-Step Execution**:\n   - For each `ScenarioStep` in the scenario:\n     - If step type is `EXPERIMENT`: Controller calls `StartExperiment()` and waits for completion\n     - If step type is `PAUSE`: Controller sleeps for specified duration, publishing heartbeat events\n     - If step type is `INJECT`: Controller publishes custom event to observer briefing channel\n     - If step type is `MANUAL_TASK`: Controller publishes `ManualApprovalRequired` event and waits\n\n3. **Approval Workflow**:\n   - When `ManualApprovalRequired` is published, UI shows approval dialog to authorized users\n   - User approves/rejects via `ApproveStep()` RPC call\n   - If approved, scenario proceeds to next step\n   - If rejected or timeout occurs, scenario may abort or skip step based on configuration\n\n4. **Observer Participation**:\n   - Observers can call `AddObservation()` at any time during scenario\n   - Observations are published as `ObserverAnnotationAdded` events\n   - Result Analyzer incorporates observations into final GameDay report\n\n5. **Cross-Experiment Safety**:\n   - Safety Monitor maintains system-wide safety rules during entire GameDay\n   - If any safety rule triggers, all active experiments are aborted, scenario transitions to emergency cleanup\n   - GameDay controller publishes `GameDayEmergencyAbort` event with root cause analysis\n\n### Data Flow Visualization\n\nThe component diagram below shows the five main subsystems and their interaction patterns:\n![Chaos Platform System Overview](./diagrams/diag-system.svg)\n\n**Key Data Flows Illustrated:**\n\n1. **Experiment Definition Flow** (solid blue arrows): User → Experiment Controller → Persistent Storage\n2. **Fault Injection Flow** (solid red arrows): Experiment Controller → Fault Injector Agents → Target Systems\n3. **Metrics Collection Flow** (dashed green arrows): Target Systems → Metrics Collector ← Safety Monitor\n4. **Safety Monitoring Flow** (dotted orange arrows): Safety Monitor → Experiment Controller (abort commands)\n5. **Result Reporting Flow** (dot-dash purple arrows): All Components → Result Analyzer → Reports/UI\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **RPC Transport** | HTTP/JSON with `net/http` | gRPC with Protocol Buffers |\n| **Event Bus** | In-memory Go channels | NATS or Apache Kafka |\n| **Message Serialization** | JSON with `encoding/json` | Protocol Buffers with `google.golang.org/protobuf` |\n| **Service Discovery** | Static configuration in YAML | Consul or Kubernetes Service Discovery |\n| **Retry Logic** | Simple exponential backoff | Adaptive retry with circuit breaker pattern |\n\n#### Recommended File Structure\n\n```\nchaos-platform/\n├── cmd/\n│   ├── controller/                 # Experiment Controller main\n│   │   └── main.go\n│   ├── fault-injector/             # Fault Injector agent\n│   │   └── main.go\n│   └── safety-monitor/             # Safety Monitor service\n│       └── main.go\n├── internal/\n│   ├── rpc/                        # RPC message definitions\n│   │   ├── messages.proto          # Protocol Buffer definitions\n│   │   ├── messages.pb.go          # Generated Go code\n│   │   └── client.go               # RPC client helpers\n│   ├── events/                     # Event definitions and bus\n│   │   ├── event.go                # Event envelope struct\n│   │   ├── publisher.go            # Event publishing interface\n│   │   ├── subscriber.go           # Event subscription interface\n│   │   └── nats/                   # NATS implementation (optional)\n│   │       ├── publisher.go\n│   │       └── subscriber.go\n│   ├── orchestrator/               # Experiment Orchestration Engine\n│   │   ├── orchestrator.go         # Main orchestrator logic\n│   │   ├── statemachine.go         # Experiment state machine\n│   │   └── recovery.go             # Crash recovery logic\n│   ├── fault/                      # Fault Injection Framework\n│   │   ├── injector.go             # Fault injection interface\n│   │   ├── manager.go              # Fault lifecycle management\n│   │   └── types.go                # Fault-related types\n│   └── gameday/                    # GameDay Automation\n│       ├── controller.go           # GameDay controller\n│       ├── scenario.go             # Scenario definition and parsing\n│       └── executor.go             # Scenario step executor\n└── api/\n    └── v1/\n        ├── experiment.go           # Experiment API handlers\n        ├── fault.go                # Fault injection API\n        └── gameday.go              # GameDay API handlers\n```\n\n#### Event Bus Starter Code\n\n```go\n// internal/events/event.go\npackage events\n\nimport (\n    \"encoding/json\"\n    \"time\"\n)\n\n// Event represents a generic event in the system\ntype Event struct {\n    ID            string          `json:\"event_id\"`\n    Type          string          `json:\"event_type\"`\n    Timestamp     time.Time       `json:\"timestamp\"`\n    Source        string          `json:\"source_component\"`\n    CorrelationID string          `json:\"correlation_id\"`\n    Payload       json.RawMessage `json:\"payload\"`\n}\n\n// Publisher defines the interface for publishing events\ntype Publisher interface {\n    Publish(eventType string, payload interface{}, correlationID string) error\n    PublishEvent(event Event) error\n}\n\n// Subscriber defines the interface for subscribing to events\ntype Subscriber interface {\n    Subscribe(eventTypes []string, handler func(Event)) (func() error, error)\n    SubscribeWithCorrelation(eventTypes []string, correlationID string, handler func(Event)) (func() error, error)\n}\n\n// InMemoryPubSub provides a simple in-memory event bus for development\ntype InMemoryPubSub struct {\n    subscribers map[string][]func(Event)\n    mu          sync.RWMutex\n}\n\nfunc NewInMemoryPubSub() *InMemoryPubSub {\n    return &InMemoryPubSub{\n        subscribers: make(map[string][]func(Event)),\n    }\n}\n\nfunc (ps *InMemoryPubSub) Publish(eventType string, payload interface{}, correlationID string) error {\n    payloadBytes, err := json.Marshal(payload)\n    if err != nil {\n        return fmt.Errorf(\"marshal payload: %w\", err)\n    }\n    \n    event := Event{\n        ID:            uuid.New().String(),\n        Type:          eventType,\n        Timestamp:     time.Now().UTC(),\n        Source:        \"in-memory\",\n        CorrelationID: correlationID,\n        Payload:       payloadBytes,\n    }\n    \n    return ps.PublishEvent(event)\n}\n\nfunc (ps *InMemoryPubSub) PublishEvent(event Event) error {\n    ps.mu.RLock()\n    defer ps.mu.RUnlock()\n    \n    handlers := ps.subscribers[event.Type]\n    // Also deliver to \"*\" wildcard subscribers\n    handlers = append(handlers, ps.subscribers[\"*\"]...)\n    \n    for _, handler := range handlers {\n        go handler(event) // Fire and forget\n    }\n    \n    return nil\n}\n\nfunc (ps *InMemoryPubSub) Subscribe(eventTypes []string, handler func(Event)) (func() error, error) {\n    ps.mu.Lock()\n    defer ps.mu.Unlock()\n    \n    for _, eventType := range eventTypes {\n        ps.subscribers[eventType] = append(ps.subscribers[eventType], handler)\n    }\n    \n    // Return unsubscribe function\n    return func() error {\n        ps.mu.Lock()\n        defer ps.mu.Unlock()\n        \n        for _, eventType := range eventTypes {\n            // Remove handler from slice\n            handlers := ps.subscribers[eventType]\n            for i, h := range handlers {\n                if &h == &handler {\n                    ps.subscribers[eventType] = append(handlers[:i], handlers[i+1:]...)\n                    break\n                }\n            }\n        }\n        return nil\n    }, nil\n}\n```\n\n#### RPC Client Helper\n\n```go\n// internal/rpc/client.go\npackage rpc\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n)\n\n// Client provides a reusable HTTP RPC client with retries\ntype Client struct {\n    baseURL    string\n    httpClient *http.Client\n    maxRetries int\n    retryDelay time.Duration\n}\n\nfunc NewClient(baseURL string) *Client {\n    return &Client{\n        baseURL: baseURL,\n        httpClient: &http.Client{\n            Timeout: 30 * time.Second,\n        },\n        maxRetries: 3,\n        retryDelay: 1 * time.Second,\n    }\n}\n\n// Call makes an HTTP POST request with JSON marshaling and retries\nfunc (c *Client) Call(ctx context.Context, method string, request, response interface{}) error {\n    var lastErr error\n    \n    for attempt := 0; attempt <= c.maxRetries; attempt++ {\n        if attempt > 0 {\n            select {\n            case <-ctx.Done():\n                return ctx.Err()\n            case <-time.After(c.retryDelay * time.Duration(attempt)):\n                // Exponential backoff\n            }\n        }\n        \n        err := c.callOnce(ctx, method, request, response)\n        if err == nil {\n            return nil\n        }\n        \n        lastErr = err\n        // Only retry on network errors or 5xx status codes\n        if !isRetryableError(err) {\n            return err\n        }\n    }\n    \n    return fmt.Errorf(\"after %d retries: %w\", c.maxRetries, lastErr)\n}\n\nfunc (c *Client) callOnce(ctx context.Context, method string, request, response interface{}) error {\n    // Implementation details...\n    // TODO 1: Marshal request to JSON\n    // TODO 2: Create HTTP POST request with context\n    // TODO 3: Set appropriate headers (Content-Type: application/json)\n    // TODO 4: Send request using httpClient\n    // TODO 5: Check status code - 200 OK for success\n    // TODO 6: For non-2xx status codes, parse error response if available\n    // TODO 7: Unmarshal successful response into response struct\n    // TODO 8: Return appropriate error based on status code\n    return nil\n}\n\nfunc isRetryableError(err error) bool {\n    // TODO: Implement logic to determine if error is retryable\n    // - Network errors (timeout, connection refused)\n    // - HTTP 5xx status codes\n    // - Not HTTP 4xx (client errors) except 429 (rate limit)\n    return false\n}\n```\n\n#### Core Orchestrator Skeleton\n\n```go\n// internal/orchestrator/orchestrator.go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n    \n    \"chaos-platform/internal/events\"\n    \"chaos-platform/internal/rpc\"\n    \"chaos-platform/internal/types\"\n)\n\ntype Orchestrator struct {\n    experiments map[string]*ExperimentInstance\n    mu          sync.RWMutex\n    metricsCollector rpc.MetricsClient\n    safetyMonitor    rpc.SafetyClient\n    faultInjector    rpc.FaultClient\n    eventPublisher   events.Publisher\n    cleanupEnsurer   *CleanupEnsurer\n}\n\nfunc (o *Orchestrator) StartExperiment(exp types.Experiment, resultsChan chan<- types.ExperimentResult) error {\n    // TODO 1: Validate experiment is in DRAFT state and all fields are valid\n    // TODO 2: Create ExperimentInstance with unique ID and initial state\n    // TODO 3: Store instance in experiments map\n    // TODO 4: Publish ExperimentStateChanged event (DRAFT → BASELINE_VALIDATION)\n    // TODO 5: Start background goroutine running executeStateMachine for this instance\n    // TODO 6: Return instance ID to caller\n    return nil\n}\n\nfunc (o *Orchestrator) executeStateMachine(instance *ExperimentInstance) {\n    ctx, cancel := context.WithCancel(context.Background())\n    instance.CancelFunc = cancel\n    \n    for {\n        select {\n        case <-ctx.Done():\n            return\n        default:\n            // TODO: Implement state machine logic\n            // Use a switch statement on instance.State\n            // Each case should handle one state and transition to next\n            // Call appropriate helper methods for each state\n        }\n    }\n}\n\nfunc (o *Orchestrator) validateBaseline(instance *ExperimentInstance) error {\n    // TODO 1: Call safetyMonitor.ValidateHypothesis with baseline time range\n    // TODO 2: Wait for validation results (timeout after 5 minutes)\n    // TODO 3: If validation fails, transition to ABORTED state\n    // TODO 4: If validation passes, record baseline metrics and transition to INJECTING\n    // TODO 5: Publish appropriate events for state changes\n    return nil\n}\n\nfunc (o *Orchestrator) injectFaults(instance *ExperimentInstance) error {\n    // TODO 1: For each fault in instance.Experiment.Faults\n    // TODO 2: Call faultInjector.InjectFault with fault details\n    // TODO 3: Record FaultInjectionRecord for successful injections\n    // TODO 4: If any injection fails and continueOnFaultFailure is false, abort\n    // TODO 5: After all faults injected, transition to MONITORING state\n    // TODO 6: Start duration timer and safety monitoring goroutine\n    return nil\n}\n\nfunc (o *Orchestrator) monitorExperiment(instance *ExperimentInstance) {\n    // TODO 1: Start two goroutines:\n    //   - Duration timer: sleeps for instance.Experiment.Duration\n    //   - Safety monitor: calls safetyMonitor.checkSafetyRules periodically\n    // TODO 2: Wait for either:\n    //   - Duration timer expires → transition to ROLLBACK\n    //   - Safety breach event → transition to ROLLBACK with emergency flag\n    //   - External abort command → transition to ROLLBACK\n    // TODO 3: Cancel both goroutines when transition occurs\n}\n```\n\n#### Language-Specific Hints\n\n1. **Context Propagation**: Use `context.Context` throughout for cancellation and timeouts. Create derived contexts with `context.WithTimeout()` for RPC calls.\n\n2. **Concurrency Patterns**: Use `sync.WaitGroup` for coordinating multiple goroutines in fault injection. Use `select` with multiple channels for monitoring timeouts and events.\n\n3. **Error Wrapping**: Use `fmt.Errorf(\"... %w\", err)` to wrap errors with context. Create custom error types for domain-specific errors (e.g., `ErrExperimentAborted`).\n\n4. **Idempotency Keys**: Generate UUIDs for all RPC requests using `github.com/google/uuid`. Include these in requests and log them for debugging.\n\n5. **Graceful Shutdown**: Implement signal handling for `SIGTERM` and `SIGINT`. On shutdown, abort all running experiments and wait for cleanup.\n\n6. **Structured Logging**: Use a logging library like `log/slog` or `zap` with fields for experiment ID, fault ID, correlation IDs.\n\n#### Milestone Checkpoint\n\nAfter implementing the interaction patterns, verify with:\n\n```bash\n# Start all components\ngo run cmd/controller/main.go &\ngo run cmd/fault-injector/main.go &\ngo run cmd/safety-monitor/main.go &\n\n# Create and run a simple experiment\ncurl -X POST http://localhost:8080/api/v1/experiments \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"latency-test\",\n    \"hypothesis\": {\n      \"description\": \"Payment service handles 200ms DB latency\",\n      \"metrics\": [{\n        \"name\": \"p95_response_time\",\n        \"query\": \"histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\\\"payment\\\"}[1m]))\",\n        \"max\": 0.5\n      }]\n    },\n    \"faults\": [{\n      \"type\": \"LATENCY\",\n      \"target\": {\"type\": \"service\", \"selector\": {\"app\": \"payment-db\"}},\n      \"parameters\": {\"latency_ms\": \"200\", \"duration\": \"1m\"}\n    }],\n    \"duration\": \"1m\",\n    \"blast_radius\": {\"percentage\": 50}\n  }'\n\n# Check experiment status\ncurl http://localhost:8080/api/v1/experiments/latency-test/status\n\n# Expected behavior:\n# 1. Experiment should move through states: DRAFT → BASELINE_VALIDATION → INJECTING → MONITORING → ROLLBACK → ANALYSIS → COMPLETED\n# 2. Check logs show RPC calls between components\n# 3. Fault should be applied for exactly 1 minute then cleaned up\n# 4. Final result should show hypothesis validation outcome\n```\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Experiment hangs in BASELINE_VALIDATION | Metrics Collector unavailable | Check Safety Monitor logs for connection errors | Ensure Metrics Collector is running and reachable |\n| Fault injection fails with \"permission denied\" | Lack of CAP_NET_ADMIN capability | Check Fault Injector logs for `tc` command errors | Run agent with proper capabilities or as root |\n| Safety breach not triggering rollback | Thresholds too high or metric lag | Check Safety Monitor query interval and metric collection delay | Adjust safety rule thresholds or increase metric collection frequency |\n| Events not being delivered | Event bus connectivity issue | Check if subscribers are registered and publishers are working | Verify event bus configuration; use in-memory bus for development |\n| Experiment state inconsistent after restart | Crash recovery incomplete | Check CleanupEnsurer logs on startup | Ensure CleanupEnsurer runs RecoverOrphanedFaults() on startup |\n\n---\n\n\n> **Milestone(s):** All milestones (foundational resilience of the platform itself)\n\n## Error Handling and Edge Cases\n\nIn a chaos engineering platform, the tool designed to test system resilience must itself be exceptionally resilient. The inherent contradiction—a system that injects failures must not become a failure point itself—requires careful design of error handling and edge case management. This section outlines the failure modes of the platform's own components and the strategies for graceful degradation, ensuring that chaos experiments remain controlled, reversible, and observable even when the platform encounters issues.\n\nThe core mental model for this component is **The Flight Recorder and Crash Cart**. Imagine an airplane's black box that continues recording even during a catastrophic failure, and a hospital's crash cart that can restore vital functions when systems falter. The chaos platform must have similar self-preservation and recovery mechanisms: it must log its own state persistently to survive crashes, and it must have automated \"defibrillators\" that restore normal system operation if the platform itself becomes unresponsive.\n\n### Fault Cleanup Failure: Ensuring Reversibility After Orchestrator Crash\n\nThe most critical failure mode in a chaos engineering platform is the inability to clean up injected faults. If the `Orchestrator` crashes or becomes partitioned during an experiment, faults could persist indefinitely, causing ongoing system degradation that outlives the experiment. This violates the fundamental principle of controlled, reversible testing.\n\n**Mental Model: The Dead Man's Switch**\nPicture a train engineer who must hold down a lever; if they release it (or become incapacitated), the brakes automatically engage to prevent catastrophe. The fault cleanup system operates on a similar principle: it continuously verifies the orchestrator's heartbeat, and if the heartbeat stops, it triggers automatic fault rollback. This ensures that faults cannot outlive their controlling process.\n\n#### Architecture Decision: Persisted Fault Registry with Recovery Scanner\n\n> **Decision: Fault Cleanup via Persistent Registry and Startup Recovery Scan**\n> - **Context**: The `Orchestrator` may crash at any point during an experiment's lifecycle, leaving active faults without a controlling process. We need a mechanism to guarantee cleanup regardless of orchestrator state.\n> - **Options Considered**:\n>    1. **In-Memory Tracking Only**: Store active fault state only in the orchestrator's memory.\n>    2. **Persistent Fault Registry with Async Cleanup**: Write all fault injection commands and their reversal commands to a durable log, with a separate recovery process.\n>    3. **Lease-Based Heartbeat with External Watchdog**: Have each fault injector agent acquire a time-bound lease from the orchestrator; if the lease expires, the agent self-cleans.\n> - **Decision**: **Persistent Fault Registry with Async Cleanup** (Option 2), combined with a synchronous startup recovery scan.\n> - **Rationale**:\n>     - In-memory tracking (Option 1) is unacceptable for a resilience tool—it creates a single point of failure.\n>     - The lease-based approach (Option 3) adds complexity and requires the fault injector agents to have cleanup logic, which increases the attack surface and maintenance burden.\n>     - A persistent registry provides a simple, auditable trail of all fault injections. The startup recovery scan is a straightforward, synchronous operation that guarantees no orphaned faults exist when the orchestrator starts. It aligns with the idempotent operations principle: cleanup commands can be safely re-executed.\n> - **Consequences**:\n>     - **Positive**: Guarantees fault cleanup even after catastrophic platform failure. Provides an audit log for compliance and debugging.\n>     - **Negative**: Introduces a disk I/O dependency. Requires careful serialization of fault records to avoid log corruption.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| In-Memory Tracking Only | Simple, no I/O overhead | Faults become permanent on crash; unacceptable | No |\n| Persistent Fault Registry with Async Cleanup | Durable, auditable, allows recovery | Disk I/O, requires serialization | **Yes** |\n| Lease-Based Heartbeat with External Watchdog | Decentralized cleanup responsibility | Complex, agents become stateful, new failure modes | No |\n\n#### Core Mechanism: The `CleanupEnsurer`\n\nThe `CleanupEnsurer` is a dedicated component responsible for recording every fault injection in a persistent, append-only log file and ensuring its reversal. It operates through three key methods:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `RegisterFault` | `record FaultRecord` | `error` | Atomically appends a fault record to the log and updates the in-memory map of active faults. The record includes the exact cleanup command. |\n| `CompleteFault` | `faultID string` | `error` | Marks a fault as cleaned up in the log (by appending a completion record) and removes it from the in-memory active map. |\n| `RecoverOrphanedFaults` | None | `error` | Called on orchestrator startup. Reads the entire log, identifies any faults marked as injected but not cleaned up, and executes their cleanup commands. |\n\nThe `FaultRecord` data structure captures all information needed for cleanup:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ExperimentID` | `string` | Identifier of the owning experiment. |\n| `FaultID` | `string` | Unique identifier for this fault instance. |\n| `Target` | `string` | The system component targeted (e.g., pod name, service endpoint). |\n| `FaultType` | `string` | The type of fault (e.g., `LATENCY`, `PROCESS_KILL`). |\n| `InjectTime` | `time.Time` | When the fault was injected. |\n| `CleanupCmd` | `string` | The exact shell command or API call needed to reverse the fault (e.g., `tc qdisc del dev eth0 root netem`). |\n\n**Algorithm for Fault Injection with Cleanup Guarantee**:\n1. **Pre-injection Logging**: Before executing the fault injection command, the `Orchestrator` calls `RegisterFault` with a `FaultRecord` containing the planned cleanup command. This write is flushed to disk (using `fsync`) to ensure durability.\n2. **Fault Execution**: The orchestrator executes the fault injection command (e.g., via a system call or RPC to a fault injector agent).\n3. **Post-Injection Confirmation**: If injection succeeds, the fault state is updated to `ACTIVE`. If injection fails, the orchestrator immediately calls `CompleteFault` to mark the record as cleaned (since no fault was applied) and retries or aborts the experiment.\n4. **Cleanup Trigger**: During normal experiment flow (completion or abort), the orchestrator executes the cleanup command and, upon success, calls `CompleteFault`.\n5. **Crash Recovery**: On restart, the `Orchestrator` calls `RecoverOrphanedFaults`. This function scans the log, re-executes the `CleanupCmd` for any fault without a completion record, and then marks them as completed.\n\n#### Edge Cases and Mitigations\n\n| Failure Mode | Detection Method | Recovery Strategy |\n|--------------|------------------|-------------------|\n| Orchestrator crashes mid-injection (after log write, before fault application) | `RecoverOrphanedFaults` finds a record with no corresponding active fault in the system. | Execute the `CleanupCmd`. Since the fault was never applied, the command is idempotent and will likely return an error (e.g., \"no such qdisc\"). Log the error and mark the record as completed. |\n| Orchestrator crashes mid-cleanup (after cleanup started but before log completion) | `RecoverOrphanedFaults` finds a record still marked as injected, but the cleanup command may have partially succeeded. | Re-execute the idempotent cleanup command. This ensures the system state is clean even if the previous attempt was interrupted. |\n| Persistent log file corruption | Checksum verification on log entries during startup scan. | If corruption is detected in the middle of the log, the safest action is to attempt cleanup for all potentially orphaned faults (by reading valid records up to the corruption point) and then truncate the log file. A warning is raised for operator intervention. |\n| Cleanup command itself fails (e.g., target resource no longer exists) | The cleanup command returns a non-zero exit code or error response. | Retry with exponential backoff (up to a limit). If cleanup ultimately fails, escalate via an alert to platform operators, as this indicates a system drift from the expected state. |\n\n#### Common Pitfalls\n\n⚠️ **Pitfall: Assuming Cleanup Commands Are Always Idempotent**\n- **Description**: Writing a cleanup command that, if run twice, causes an error or changes system state beyond the desired cleanup.\n- **Why It's Wrong**: The recovery scanner may execute cleanup commands multiple times (e.g., after a crash during cleanup). Non-idempotent commands could throw errors that halt the recovery process or, worse, apply incorrect configuration.\n- **Fix**: Design all fault injection and cleanup commands to be idempotent. For example, instead of `kill -9 <pid>` (which fails if the process is already dead), use a pattern that checks existence first, or use `pkill` with a pattern that tolerates missing processes. For network rules, use `tc qdisc replace` instead of `add`, or wrap commands in logic that checks current state before modifying.\n\n⚠️ **Pitfall: Blocking Synchronous Disk Flushing During Experiment Execution**\n- **Description**: Calling `fsync` after every `RegisterFault` write, which can block the orchestrator for tens of milliseconds, affecting experiment timing and scalability.\n- **Why It's Wrong**: While durability is critical, synchronous disk I/O can become a performance bottleneck, especially for experiments with many rapid fault injections.\n- **Fix**: Use a **write-ahead log (WAL) with batch flushing**. The `CleanupEnsurer` can buffer multiple `FaultRecord` writes in memory and flush them to disk every 100ms or after a certain number of records. The risk window of losing recent records before a crash is acceptable because:\n    1. The platform's own crash is a rare event.\n    2. The blast radius of a few unlogged faults is limited (they would be orphaned but could be manually cleaned).\n    3. The trade-off favors experiment performance over absolute guarantee for every single fault.\n\n### Metrics Collection Interruption: Maintaining Safety Without Data\n\nThe **Safety Monitor** relies on a continuous stream of system metrics to evaluate `SafetyRule` conditions and trigger auto-rollback. If the metrics collection pipeline is interrupted (e.g., metrics collector failure, network partition, or scraping timeout), the safety monitor operates blind, unable to detect if the system has breached safety thresholds.\n\n**Mental Model: The Instrument Flight Rules (IFR) vs. Visual Flight Rules (VFR)**\nIn aviation, pilots rely on instruments when visibility is poor. Similarly, the safety monitor has two modes of operation: **\"Instrumented\" mode** (normal, with full metrics) and **\"Procedural\" mode** (when metrics are unavailable). In procedural mode, the platform follows pre-defined conservative procedures—like an immediate rollback—because it cannot verify system health.\n\n#### Architecture Decision: Fail-Safe Rollback on Metrics Unavailability\n\n> **Decision: Trigger Auto-Rollback After Sustained Metrics Collection Failure**\n> - **Context**: The `SafetyMonitor` component periodically queries the `MetricsCollector` for current system metrics. If these queries fail repeatedly, the monitor loses situational awareness.\n> - **Options Considered**:\n>    1. **Continue Experiment Blindly**: Assume the system is healthy and proceed with the experiment.\n>    2. **Pause Experiment**: Halt further fault injection but leave existing faults active until metrics return.\n>    3. **Fail-Safe Rollback**: Immediately initiate rollback of all faults and abort the experiment.\n> - **Decision**: **Fail-Safe Rollback** (Option 3) after a short grace period (e.g., 3 consecutive collection failures).\n> - **Rationale**:\n>     - Continuing blindly (Option 1) is reckless; the system could be experiencing a catastrophic failure induced by the experiment, and we wouldn't know.\n>     - Pausing (Option 2) leaves faults active in an unknown state, potentially prolonging damage.\n>     - Fail-safe rollback prioritizes system stability over experiment completion. It treats loss of observability as a serious risk factor, aligning with the chaos engineering principle of minimizing blast radius and ensuring safety.\n> - **Consequences**:\n>     - **Positive**: Eliminates risk of undetected degradation due to monitoring failure. Simple to implement and reason about.\n>     - **Negative**: May cause unnecessary experiment abortions in cases of transient metrics collection issues (e.g., a brief network glitch). This is a conservative trade-off.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Continue Experiment Blindly | Maximizes experiment completion rate | Potentially catastrophic; violates safety | No |\n| Pause Experiment | Prevents new damage; waits for visibility | Leaves existing faults active; complex state | No |\n| Fail-Safe Rollback | Guarantees system safety; simple | May abort experiments unnecessarily | **Yes** |\n\n#### Implementation Strategy: Health-Aware Metrics Collection\n\nThe `SafetyMonitor` uses a dedicated method `checkSafetyRules` that includes logic for detecting metrics collection failures. The algorithm extends as follows:\n\n1. **Metric Collection Attempt**: For each safety rule, the monitor calls `GetCurrentValue` on the `MetricsCollector`. This call has a short timeout (e.g., 5 seconds).\n2. **Failure Counting**: If the call fails (returns error or times out), increment a failure counter for that specific metric source (e.g., Prometheus endpoint). Success resets the counter.\n3. **Threshold Evaluation**: If the failure counter exceeds a configured threshold (e.g., 3), the monitor triggers a **\"MetricsUnavailable\"** safety event.\n4. **Automatic Action**: The `Orchestrator`, upon receiving this event, immediately transitions the experiment to the `ROLLBACK` state, regardless of other conditions. This is a **circuit breaker** pattern for observability.\n\nTo distinguish between a complete metrics blackout and degradation of a specific metric, the system uses a **heartbeat metric**—a simple, always-available metric like the metrics collector's own uptime. If the heartbeat metric is also unavailable, it indicates a total collection failure.\n\n#### Data Structure Extension: `SafetyEvent` for Collection Failures\n\nThe existing `SafetyEvent` struct is extended to capture metrics collection failures:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Rule` | `SafetyRule` | The safety rule that could not be evaluated. |\n| `Timestamp` | `time.Time` | When the failure occurred. |\n| `Value` | `float64` | Last known value (if any). |\n| `Triggered` | `bool` | Whether the rule condition was met (always `false` for collection failure). |\n| `DurationMet` | `bool` | Whether the condition held for the required duration. |\n| `ActionTaken` | `string` | Description of action taken (e.g., `\"Rollback triggered due to metrics unavailability\"`). |\n| `Error` | `*string` | New field: The error message from the metrics collection failure (e.g., `\"connection timeout\"`). |\n\n#### Edge Cases and Mitigations\n\n| Failure Mode | Detection Method | Recovery Strategy |\n|--------------|------------------|-------------------|\n| Intermittent metric scraping failure for one service | Some metrics succeed, others fail. The failure counter is per-metric-source. | If only a subset of metrics fail, the safety monitor can still evaluate rules based on available metrics. The experiment continues, but an observation is logged about partial data loss. |\n| Complete metrics backend outage (e.g., Prometheus down) | Heartbeat metric fails, and all metric queries time out. | The failure counter for the heartbeat metric quickly reaches threshold, triggering global rollback. The platform should alert operators about the monitoring system failure. |\n| Metrics lag (delayed data) | Metric values are stale; timestamps show data older than a threshold (e.g., 30 seconds). | Treat stale data as a collection failure. The safety monitor should check data freshness and increment the failure counter if data is beyond an acceptable age. This prevents making abort decisions based on outdated information. |\n| Safety monitor process crash | The `Orchestrator` notices missed health pings from the monitor (via a simple heartbeat goroutine). | The orchestrator, lacking safety oversight, should immediately initiate rollback. This is a higher-level fail-safe beyond the metrics collection logic. |\n\n#### Common Pitfalls\n\n⚠️ **Pitfall: Using a Single Global Failure Counter for All Metrics**\n- **Description**: Aggregating failures across all metrics into one counter, causing a rollback due to a single flaky metric while other critical metrics are flowing.\n- **Why It's Wrong**: Overly broad failure detection leads to unnecessary experiment abortions and reduces confidence in the platform. It also masks the real issue—which specific metric source is problematic.\n- **Fix**: Implement **per-metric-source failure tracking**. Each independent metrics endpoint (e.g., each Prometheus target, each service's metrics port) gets its own failure counter. Rollback only triggers if a critical mass of sources fail (e.g., >50%) or if a designated \"heartbeat\" source fails.\n\n⚠️ **Pitfall: Ignoring Metrics Freshness**\n- **Description**: Using the last successfully scraped metric value without checking its timestamp, potentially making safety decisions based on minutes-old data.\n- **Why It's Wrong**: During rapid degradation, stale metrics can show a healthy system while the actual system is failing. This delays auto-rollback and increases damage.\n- **Fix**: Every metric query should return both value and timestamp. The `SafetyMonitor` must compare the timestamp to the current time; if the data is older than a threshold (e.g., `scrape_interval + 10s`), treat it as a collection failure.\n\n### Implementation Guidance\n\nThis section provides the concrete code structures and skeletons to implement the error handling strategies described above.\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Persistent Fault Log | Append-only text file with JSON lines | Embedded database (SQLite) with WAL mode |\n| Metrics Collection Failure Detection | Simple timeout and retry counter | Adaptive circuit breaker with exponential backoff |\n| Orchestrator-Safety Monitor Heartbeat | Periodic HTTP health check | Bidirectional gRPC stream with keepalive |\n\n#### Recommended File/Module Structure\n\n```\nchaos-platform/\n├── cmd/\n│   ├── orchestrator/\n│   │   └── main.go\n│   └── cleanup-agent/\n│       └── main.go          # Optional standalone recovery agent\n├── internal/\n│   ├── orchestrator/\n│   │   ├── orchestrator.go\n│   │   ├── experiment_instance.go\n│   │   └── orchestrator_test.go\n│   ├── fault/\n│   │   ├── injector.go\n│   │   ├── cleanup_ensurer.go    # <-- NEW: Persistent fault registry\n│   │   └── recovery.go           # <-- NEW: Recovery scanner\n│   ├── safety/\n│   │   ├── monitor.go\n│   │   ├── metrics_checker.go    # <-- Enhanced with failure detection\n│   │   └── circuit_breaker.go\n│   └── types/\n│       └── types.go              # All data structures\n└── pkg/\n    └── persistence/\n        ├── wal.go                # Generic write-ahead log\n        └── wal_test.go\n```\n\n#### Infrastructure Starter Code: Write-Ahead Log (WAL)\n\nThe following is a complete, reusable write-ahead log implementation that the `CleanupEnsurer` can use for fault record persistence. It provides atomic append and recovery scanning.\n\n```go\n// pkg/persistence/wal.go\npackage persistence\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n)\n\n// WAL represents a write-ahead log file.\ntype WAL struct {\n    mu     sync.Mutex\n    file   *os.File\n    writer *bufio.Writer\n    path   string\n}\n\n// NewWAL creates or opens a WAL file at the given path.\nfunc NewWAL(path string) (*WAL, error) {\n    if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {\n        return nil, fmt.Errorf(\"create WAL directory: %w\", err)\n    }\n    // Open in append mode, create if not exists.\n    file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n    if err != nil {\n        return nil, fmt.Errorf(\"open WAL file: %w\", err)\n    }\n    return &WAL{\n        file:   file,\n        writer: bufio.NewWriter(file),\n        path:   path,\n    }, nil\n}\n\n// Append marshals the record to JSON and appends it as a line to the WAL.\n// It flushes to disk (fsync) to ensure durability.\nfunc (w *WAL) Append(record interface{}) error {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n\n    data, err := json.Marshal(record)\n    if err != nil {\n        return fmt.Errorf(\"marshal record: %w\", err)\n    }\n    data = append(data, '\\n')\n\n    if _, err := w.writer.Write(data); err != nil {\n        return fmt.Errorf(\"write to buffer: %w\", err)\n    }\n    // Flush buffer to OS.\n    if err := w.writer.Flush(); err != nil {\n        return fmt.Errorf(\"flush buffer: %w\", err)\n    }\n    // Ensure data is written to disk.\n    if err := w.file.Sync(); err != nil {\n        return fmt.Errorf(\"fsync: %w\", err)\n    }\n    return nil\n}\n\n// Scan reads the entire WAL file line by line, unmarshaling each line into the provided function.\n// The function f is called for each record. If f returns an error, scanning stops.\nfunc (w *WAL) Scan(f func(line []byte) error) error {\n    // Open for reading only.\n    file, err := os.Open(w.path)\n    if err != nil {\n        return fmt.Errorf(\"open for reading: %w\", err)\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        if err := f(scanner.Bytes()); err != nil {\n            return err\n        }\n    }\n    if err := scanner.Err(); err != nil {\n        return fmt.Errorf(\"scan error: %w\", err)\n    }\n    return nil\n}\n\n// Close closes the WAL file.\nfunc (w *WAL) Close() error {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n    return w.file.Close()\n}\n```\n\n#### Core Logic Skeleton: CleanupEnsurer\n\n```go\n// internal/fault/cleanup_ensurer.go\npackage fault\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n\n    \"chaos-platform/pkg/persistence\"\n    \"chaos-platform/internal/types\"\n)\n\n// CleanupEnsurer ensures fault cleanup even after a crash.\ntype CleanupEnsurer struct {\n    mu          sync.RWMutex\n    wal         *persistence.WAL\n    activeFaults map[string]types.FaultRecord  // faultID -> record\n}\n\n// NewCleanupEnsurer creates a CleanupEnsurer with a persistent WAL at dataDir/cleanup.wal.\nfunc NewCleanupEnsurer(dataDir string) (*CleanupEnsurer, error) {\n    wal, err := persistence.NewWAL(filepath.Join(dataDir, \"cleanup.wal\"))\n    if err != nil {\n        return nil, err\n    }\n    ce := &CleanupEnsurer{\n        wal:         wal,\n        activeFaults: make(map[string]types.FaultRecord),\n    }\n    // On startup, recover any orphaned faults from previous run.\n    if err := ce.RecoverOrphanedFaults(); err != nil {\n        return nil, fmt.Errorf(\"recover orphaned faults: %w\", err)\n    }\n    return ce, nil\n}\n\n// RegisterFault records a fault injection in the WAL and marks it as active.\nfunc (ce *CleanupEnsurer) RegisterFault(record types.FaultRecord) error {\n    ce.mu.Lock()\n    defer ce.mu.Unlock()\n\n    // TODO 1: Assign a unique FaultID if not already set (e.g., using UUID)\n    // TODO 2: Set InjectTime to current time if not set\n    // TODO 3: Append the record to the WAL (use ce.wal.Append)\n    // TODO 4: If WAL append succeeds, add record to activeFaults map\n    // TODO 5: Return any error from WAL append; otherwise return nil\n    return nil\n}\n\n// CompleteFault marks a fault as cleaned up in the WAL and removes it from active map.\nfunc (ce *CleanupEnsurer) CompleteFault(faultID string) error {\n    ce.mu.Lock()\n    defer ce.mu.Unlock()\n\n    // TODO 1: Check if faultID exists in activeFaults\n    // TODO 2: Create a completion record (e.g., a JSON with faultID and completion timestamp)\n    // TODO 3: Append completion record to WAL\n    // TODO 4: If WAL append succeeds, delete faultID from activeFaults\n    // TODO 5: Return any error\n    return nil\n}\n\n// RecoverOrphanedFaults scans the WAL and re-executes cleanup for any fault without a completion record.\nfunc (ce *CleanupEnsurer) RecoverOrphanedFaults() error {\n    // TODO 1: Create a map to track the latest state of each faultID from the WAL.\n    //         We'll parse each line and update state: \"injected\" or \"completed\".\n    // TODO 2: Use ce.wal.Scan to read each line. For each line:\n    //    - Unmarshal into a generic map to check type.\n    //    - If it's a fault record (has InjectTime), mark faultID as injected.\n    //    - If it's a completion record, mark faultID as completed.\n    // TODO 3: After scan, iterate over all faultIDs marked as injected but not completed.\n    // TODO 4: For each orphaned fault, execute its CleanupCmd (use os/exec or equivalent).\n    //         Log the outcome.\n    // TODO 5: After attempting cleanup, append a completion record for each orphaned fault\n    //         (to prevent re-cleanup on next restart).\n    // TODO 6: Clear the activeFaults map and repopulate with currently active faults\n    //         (should be empty after recovery).\n    return nil\n}\n\n// GetActiveFaults returns a copy of the currently active faults (for debugging).\nfunc (ce *CleanupEnsurer) GetActiveFaults() []types.FaultRecord {\n    ce.mu.RLock()\n    defer ce.mu.RUnlock()\n    faults := make([]types.FaultRecord, 0, len(ce.activeFaults))\n    for _, f := range ce.activeFaults {\n        faults = append(faults, f)\n    }\n    return faults\n}\n```\n\n#### Core Logic Skeleton: Enhanced Safety Monitor with Failure Detection\n\n```go\n// internal/safety/metrics_checker.go\npackage safety\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n\n    \"chaos-platform/internal/types\"\n    \"chaos-platform/internal/metrics\"\n)\n\n// MetricsChecker evaluates safety rules and detects metrics collection failures.\ntype MetricsChecker struct {\n    collector        metrics.Collector\n    failureCounters  map[string]int // metric source -> consecutive failures\n    failureThreshold int\n    heartbeatQuery   string\n}\n\n// NewMetricsChecker creates a new MetricsChecker.\nfunc NewMetricsChecker(collector metrics.Collector, failureThreshold int, heartbeatQuery string) *MetricsChecker {\n    return &MetricsChecker{\n        collector:        collector,\n        failureCounters:  make(map[string]int),\n        failureThreshold: failureThreshold,\n        heartbeatQuery:   heartbeatQuery,\n    }\n}\n\n// CheckSafetyRules evaluates all safety rules and returns safety events.\n// It also checks for metrics collection failures and triggers a failure event if needed.\nfunc (mc *MetricsChecker) CheckSafetyRules(rules []types.SafetyRule) ([]types.SafetyEvent, bool, error) {\n    var events []types.SafetyEvent\n    overallSafe := true\n\n    // First, check heartbeat metric to ensure overall metrics collection is alive.\n    // TODO 1: Call mc.collector.GetCurrentValue with mc.heartbeatQuery and a timeout.\n    // TODO 2: If heartbeat check fails, increment its failure counter.\n    // TODO 3: If heartbeat failure counter >= mc.failureThreshold, create a SafetyEvent\n    //         with ActionTaken \"Rollback triggered due to metrics unavailability\".\n    //         Return this event and overallSafe = false (triggering rollback).\n\n    // Evaluate each safety rule.\n    for _, rule := range rules {\n        // TODO 4: Determine the metric source for this rule (e.g., from rule.Metric).\n        // TODO 5: Call mc.collector.GetCurrentValue for rule.Metric with timeout.\n        // TODO 6: If call fails, increment failure counter for this source.\n        //         If failure counter >= threshold, create a SafetyEvent for collection failure.\n        // TODO 7: If call succeeds, reset failure counter for this source.\n        //         Then compare value against rule.Condition (e.g., \"error_rate > 0.05\").\n        // TODO 8: If condition violated, create a SafetyEvent with Triggered=true.\n        //         Update overallSafe accordingly.\n    }\n    return events, overallSafe, nil\n}\n```\n\n#### Language-Specific Hints\n\n- **Go's `os/exec` for Cleanup Commands**: Use `exec.CommandContext` with a timeout to run cleanup shell commands. Always capture `stdout` and `stderr` for logging.\n- **Concurrent Map Access**: Use `sync.RWMutex` for the `activeFaults` map in `CleanupEnsurer`. The pattern is: lock for writes (`RegisterFault`, `CompleteFault`), and RLock for reads (`GetActiveFaults`).\n- **JSON Serialization**: Use `encoding/json` for marshaling `FaultRecord`. Ensure that the `CleanupCmd` field is a string containing the exact command, and consider using a `json.RawMessage` for flexible parameter storage.\n- **Context for Timeouts**: Pass a `context.Context` with timeout to all external calls (metrics collection, command execution). This prevents hangs.\n\n#### Milestone Checkpoint: Verifying Cleanup Recovery\n\nAfter implementing the `CleanupEnsurer`:\n\n1. **Start the orchestrator** and inject a simple fault (e.g., network latency).\n2. **Simulate a crash** by forcibly killing the orchestrator process (`kill -9`).\n3. **Restart the orchestrator**. Observe the logs during startup.\n4. **Expected Behavior**: The orchestrator should log \"Recovering orphaned faults\" and execute the cleanup command for the previously injected latency fault. After restart, verify that the fault is no longer active (e.g., by checking `tc qdisc show`).\n5. **Verification Command**: \n   ```bash\n   # After step 2, before step 3, check that the fault is still present\n   tc qdisc show dev eth0\n   # After step 3, the same command should show no netem rules.\n   ```\n6. **Sign of Success**: The orphaned fault is automatically cleaned up on restart.\n7. **Common Issue**: If the cleanup command fails, check the exact command string in the `FaultRecord`. Ensure it uses idempotent forms (e.g., `tc qdisc del ...` may fail if the rule doesn't exist; consider using `tc qdisc replace` or a script that checks first).\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Orphaned faults not cleaned up on restart | `RecoverOrphanedFaults` not scanning WAL correctly | Check WAL file contents (`cat cleanup.wal`). Ensure each line is valid JSON. | Fix JSON marshaling in `RegisterFault`. Ensure WAL scanning logic correctly identifies completion records. |\n| Metrics collection failure triggers unnecessary rollback | Transient network blip causes a few timeouts | Check logs for metrics collection errors. Look at `failureCounters` in `MetricsChecker`. | Increase `failureThreshold` (e.g., from 3 to 5) or implement a circuit breaker that allows occasional failures. |\n| Cleanup command fails during recovery because target resource gone | Non-idempotent cleanup command (e.g., `kill -9 <pid>` on a dead process) | Examine the error log from the cleanup attempt. | Rewrite cleanup command to be idempotent: wrap in a script that checks resource existence first, or use commands that tolerate missing targets. |\n| WAL file grows indefinitely | Completion records are written but old records never purged | Check file size of `cleanup.wal`. | Implement log rotation: after recovery, start a new WAL file and archive the old one. Or, switch to a database with automatic compaction. |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (testing is a cross-cutting concern that applies to every stage of development)\n\n### Mental Model: The Chaos Platform's Safety Harness\n\nImagine building a **parachute-testing facility**—you're designing equipment that saves lives by deploying reliably under extreme conditions. You wouldn't trust a parachute that hasn't been rigorously tested, nor would you test it by jumping from a plane without verification first. Similarly, a chaos engineering platform that injects failures into production systems must itself be **more reliable than the systems it tests**. The testing strategy serves as our safety harness—a comprehensive verification system that ensures every component behaves predictably, faults are always reversible, and the platform never becomes the source of the outages it's designed to prevent.\n\nThis section outlines how to verify the platform's correctness through a multi-layered approach: from unit tests that validate individual fault types to integration tests that simulate full chaos experiments in isolated environments. We'll provide concrete checkpoints for each milestone, giving you clear signals that your implementation is progressing correctly.\n\n### Testing Approach and Properties\n\nTesting a chaos engineering platform presents unique challenges: we must verify that **failure injection works correctly** while simultaneously ensuring **it never causes permanent damage**. This duality requires three complementary testing strategies operating at different levels of abstraction.\n\n**Unit Testing: The Component Microscope** focuses on individual components in isolation, verifying their internal logic without external dependencies. Each component—`Fault`, `Experiment`, `SafetyMonitor`—has well-defined responsibilities that can be tested with mock dependencies.\n\n**Integration Testing: The System Integration Lab** verifies interactions between components, ensuring they cooperate correctly to execute complex workflows like experiment orchestration. This layer tests the platform's ability to coordinate fault injection with safety monitoring and cleanup.\n\n**Property-Based Testing: The Invariant Verifier** moves beyond example-based testing to verify universal properties that must hold for all possible inputs. For a chaos platform, properties like \"all faults must be reversible\" are more valuable than testing specific parameter combinations.\n\nThe following table summarizes the test categories, their purpose, and typical scope:\n\n| Test Category | Purpose | Scope Example | Execution Frequency |\n|---------------|---------|---------------|---------------------|\n| **Unit Tests** | Verify component logic in isolation | `Fault.Validate()` returns error for invalid parameters | On every code change (fast: <100ms) |\n| **Integration Tests** | Verify component interactions | `Orchestrator` successfully runs experiment with mock fault injector | On every pull request (medium: <30s) |\n| **Property Tests** | Verify universal invariants | For any valid `Fault`, `CleanupFault()` restores original state | Nightly or weekly (slow: minutes) |\n| **End-to-End Tests** | Verify full platform in realistic environment | Complete GameDay scenario against test microservices | Weekly or before releases (slow: minutes-hours) |\n| **Chaos Tests** | Verify platform resilience under self-inflicted chaos | Inject network partition during experiment execution | Monthly (experimental) |\n\n> **Key Insight**: The most critical property of any chaos engineering platform is **reversibility**—the guarantee that every injected fault can be completely cleaned up, restoring the system to its original state. This property is so fundamental that we'll verify it through multiple testing layers.\n\n#### Property-Based Testing: Core Invariants\n\nProperty-based testing generates hundreds of random inputs to verify that certain properties always hold true. For our chaos platform, we identify several non-negotiable invariants:\n\n| Property | Description | Test Strategy |\n|----------|-------------|---------------|\n| **Reversibility** | Every fault injection has a corresponding cleanup that restores the original system state | Generate random fault parameters, inject fault, run cleanup, compare system state before/after |\n| **Idempotency** | Applying the same fault twice has the same effect as applying it once; cleaning up twice has the same effect as cleaning up once | Inject fault, verify state, inject again, verify no change; repeat for cleanup |\n| **Isolation** | Faults only affect targets within their specified blast radius | Inject fault on target A, verify target B remains unaffected |\n| **Safety Responsiveness** | When safety thresholds are breached, the platform automatically initiates rollback within a bounded time | Simulate metric breach, measure time to rollback initiation |\n| **Crash Recovery** | If the platform crashes during fault injection, it recovers and cleans up all orphaned faults on restart | Kill platform process during experiment, restart, verify no active faults remain |\n| **Deterministic Cleanup** | Cleanup operations produce the same final state regardless of when they're executed (immediately vs. after delay) | Inject fault, wait random duration, cleanup, verify state matches baseline |\n\nThese properties form the foundation of our testing strategy. The following ADR explains our approach to implementing property-based testing:\n\n> **Decision: Property-Based Testing Framework Selection**\n> - **Context**: We need to verify critical invariants across the entire parameter space of fault injections, not just specific examples.\n> - **Options Considered**:\n>     1. **Manual example-based tests only**: Write traditional unit tests with handcrafted examples for common cases.\n>     2. **Property-based testing with Go's `testing/quick`**: Use the built-in library for generating random inputs.\n>     3. **Property-based testing with `gopter`**: Use a third-party library offering more sophisticated generators and property verification.\n> - **Decision**: Use `gopter` for property-based testing of critical invariants, supplemented by example-based tests for edge cases.\n> - **Rationale**: `gopter` provides richer generators (including recursive structures), better shrinking (minimizing failing test cases), and integrated reporting. While `testing/quick` is simpler, it lacks the flexibility needed for complex `Fault` structures with nested parameters. The additional dependency is justified by the improved debugging experience when properties fail.\n> - **Consequences**: We gain robust invariant verification but add an external dependency. Test execution time increases due to generated test cases, requiring careful balancing of iteration count.\n\nTable: Property Testing Framework Comparison\n\n| Option | Pros | Cons | Selected? |\n|--------|------|------|-----------|\n| Manual examples only | Simple, fast, predictable | Misses edge cases, limited coverage | No (supplementary only) |\n| `testing/quick` | Built into Go standard library, no dependencies | Limited generator flexibility, poor shrinking | No |\n| `gopter` | Rich generators, excellent shrinking, good reporting | External dependency, steeper learning curve | **Yes** |\n\n#### Integration Testing Strategy\n\nIntegration tests verify that components work together correctly. Given the platform's potential to cause real system disruption, we employ a **defense-in-depth** approach with multiple safety layers:\n\n1. **Test Doubles for Dangerous Operations**: Network fault injection (`tc`, `iptables`) is replaced with mock implementations that record intent without executing commands.\n2. **Containerized Test Environments**: Run integration tests in isolated Docker containers with controlled resource limits.\n3. **State Verification Points**: Before and after each test, verify system state matches expectations.\n\nThe integration test flow follows this pattern:\n1. Setup test environment with known initial state\n2. Execute platform operation (e.g., `StartExperiment`)\n3. Verify intended effects were recorded (e.g., fault injection commands logged)\n4. Verify no unintended side effects occurred\n5. Cleanup test environment\n\n#### Chaos Testing the Chaos Platform\n\nA self-referential but valuable approach: we can apply chaos engineering principles to the platform itself. This \"meta-chaos\" testing verifies the platform's resilience to its own failures:\n\n1. **Network Chaos During Experiments**: Inject packet loss between the `Orchestrator` and `FaultInjector` while an experiment is running.\n2. **Process Kill of Platform Components**: Terminate the `SafetyMonitor` during fault injection to verify fail-safe behavior.\n3. **Resource Exhaustion of Platform**: Stress CPU/memory while the platform manages multiple experiments.\n\nThese tests validate that the platform's safety mechanisms (like the `CleanupEnsurer` with its write-ahead log) work correctly even when the platform itself is under stress.\n\n### Milestone Implementation Checkpoints\n\nEach milestone has specific acceptance criteria that translate into verifiable implementation checkpoints. The following tables provide concrete commands to run and observable behaviors to verify for each milestone. Use these as progress indicators—if a checkpoint fails, revisit the corresponding component design.\n\n#### Milestone 1: Fault Injection Framework\n\nThis milestone establishes the foundation: the ability to inject controlled faults. Verification focuses on both the positive case (faults apply correctly) and the safety case (faults clean up completely).\n\n| Checkpoint | Verification Command | Expected Observable Behavior | What to Check If Failing |\n|------------|---------------------|------------------------------|---------------------------|\n| **Latency Injection** | `go test ./pkg/fault -run TestLatencyFault -v` | Test passes. If run with root privileges on Linux, you can manually verify with `tc qdisc show dev lo` that netem rules appear and disappear. | - Check `CAP_NET_ADMIN` capability<br>- Verify `tc` command is available in PATH<br>- Confirm network interface exists |\n| **Packet Loss Simulation** | `go test ./pkg/fault -run TestPacketLossFault -v` | Test passes. Packet loss rules apply and clean up. Use `ping -c 100 127.0.0.1` during test to observe actual packet loss. | - Same as latency plus iptables permissions<br>- Check for conflicting firewall rules |\n| **Process Kill Fault** | `go test ./pkg/fault -run TestProcessKill -v` | Test passes. A test process (e.g., `sleep 3600`) is started, killed, and optionally restarted. Process monitor shows lifecycle. | - Process PID tracking<br>- Signal permissions (SIGTERM vs SIGKILL)<br>- Orphaned child processes |\n| **CPU Stress Fault** | `go test ./pkg/fault -run TestCPUStress -v` | Test passes. CPU utilization spikes in controlled cgroup. Use `top` or `mpstat 1` to observe load during test. | - Cgroup filesystem mounted<br>- `stress-ng` or similar tool available<br>- CPU quota correctly calculated |\n| **Memory Stress Fault** | `go test ./pkg/fault -run TestMemoryStress -v` | Test passes. Memory usage increases within limits. Monitor with `free -m` or cgroup memory stats. | - Memory cgroup enabled<br>- Overcommit settings<br>- Swap interference |\n| **Fault Reversibility Property** | `go test ./pkg/fault -run TestFaultReversibility -v` | Property test passes for all fault types. Generates 100 random fault configurations, injects and cleans each, verifying original state restored. | - State comparison logic<br>- Timing issues with async cleanup<br>- Resource leakage detection |\n\n#### Milestone 2: Experiment Orchestration\n\nThis milestone introduces the experiment lifecycle with safety controls. Verification requires simulating the full experiment flow with mocked dependencies.\n\n| Checkpoint | Verification Command | Expected Observable Behavior | What to Check If Failing |\n|------------|---------------------|------------------------------|---------------------------|\n| **Experiment Creation & Validation** | `go test ./pkg/experiment -run TestCreateExperiment -v` | Test passes. Valid experiments are accepted; invalid ones (missing hypothesis, zero duration) return descriptive errors. | - Validation logic completeness<br>- JSON/YAML parsing<br>- Required field checking |\n| **Steady-State Hypothesis Validation** | `go test ./pkg/experiment -run TestValidateHypothesis -v` | Test passes. Mock metrics collector returns controlled data; hypothesis passes or fails as expected. | - Metric query formatting<br>- Threshold comparison logic<br>- Time window handling |\n| **Experiment State Machine** | `go test ./pkg/experiment -run TestExperimentStateMachine -v` | Test passes. Experiment transitions through all states: `DRAFT` → `BASELINE_VALIDATION` → `INJECTING` → `MONITORING` → `ANALYSIS` → `COMPLETED`. | - State transition triggers<br>- Concurrent access protection<br>- Context cancellation propagation |\n| **Safety-Triggered Abort** | `go test ./pkg/experiment -run TestSafetyAbort -v` | Test passes. When simulated error rate exceeds 5%, experiment transitions to `ABORTED`, all faults are cleaned up, abort reason recorded. | - Safety monitor polling interval<br>- Metric aggregation window<br>- Rollback coordination timing |\n| **Cleanup After Crash** | `go test ./pkg/experiment -run TestCrashRecovery -v` | Test passes. Simulate platform crash (kill -9), restart, verify `RecoverOrphanedFaults()` finds and cleans up active faults from WAL. | - WAL entry durability (fsync)<br>- Fault state serialization<br>- Idempotent cleanup commands |\n\n#### Milestone 3: GameDay Automation\n\nGameDay automation coordinates multiple experiments. Verification requires testing scenario sequencing, pause/resume functionality, and report generation.\n\n| Checkpoint | Verification Command | Expected Observable Behavior | What to Check If Failing |\n|------------|---------------------|------------------------------|---------------------------|\n| **Scenario Loading & Parsing** | `go test ./pkg/gameday -run TestLoadScenario -v` | Test passes. YAML scenario file loads into `Scenario` struct with all steps, approvals, and briefing. | - YAML structure mapping<br>- Nested object parsing<br>- Validation of required fields |\n| **Scenario Step Execution** | `go test ./pkg/gameday -run TestExecuteScenario -v` | Test passes. Scenario executes steps in sequence: experiment, pause, manual task, inject. Progress tracked in `scenarioInstance`. | - Step type switching logic<br>- Timing of pauses<br>- State persistence between steps |\n| **Manual Approval Flow** | `go test ./pkg/gameday -run TestManualApproval -v` | Test passes. Scenario pauses at step with `RequiresApproval: true`, waits for `ApproveStep()`, then continues. | - Approval timeout handling<br>- Multiple observer coordination<br>- Approval state persistence |\n| **GameDay Report Generation** | `go test ./pkg/gameday -run TestGenerateReport -v` | Test passes. Report includes experiment results, observer observations, timing data, and overall success/failure determination. | - Data aggregation from multiple experiments<br>- Report formatting<br>- Observation correlation |\n| **Scenario Abort & Rollback** | `go test ./pkg/gameday -run TestScenarioAbort -v` | Test passes. Aborting scenario midway rolls back active experiments, records reason, moves to `ABORTED` state. | - Nested experiment cleanup<br>- Partial rollback handling<br>- State consistency |\n\n#### Milestone 4: Steady-State Hypothesis & Metrics Validation\n\nThis milestone focuses on statistical validation of system behavior. Verification requires sophisticated metric collection and analysis.\n\n| Checkpoint | Verification Command | Expected Observable Behavior | What to Check If Failing |\n|------------|---------------------|------------------------------|---------------------------|\n| **Hypothesis DSL Parsing** | `go test ./pkg/hypothesis -run TestParseHypothesis -v` | Test passes. Natural language hypothesis (\"error rate < 1% for 5 minutes\") parses to `Hypothesis` with proper `MetricThreshold` values. | - DSL grammar completeness<br>- Time duration parsing<br>- Comparative operator support |\n| **Metric Threshold Validation** | `go test ./pkg/metrics -run TestValidateThreshold -v` | Test passes. Given time-series data, correctly determines if metric stayed within threshold for required duration. | - Sliding window calculation<br>- Missing data handling<br>- Boundary condition logic |\n| **Statistical Significance Testing** | `go test ./pkg/experiment -run TestStatisticalValidation -v` | Test passes. Compares experiment group metrics to control group using t-test, correctly identifies significant deviations. | - Sample size calculation<br>- Variance handling<br>- P-value interpretation |\n| **Blast Radius Enforcement** | `go test ./pkg/experiment -run TestBlastRadius -v` | Test passes. When blast radius is 30%, faults affect approximately 30% of target population, not 100%. | - Random selection algorithm<br>- Seed management for reproducibility<br>- Population counting |\n| **Metric Collection During Chaos** | `go test ./pkg/metrics -run TestCollectionDuringChaos -v` | Test passes. While network latency fault is active, metrics collector continues gathering data without gaps. | - Collector resilience to faults<br>- Retry logic with backoff<br>- Metric timestamp accuracy |\n\n#### Milestone 5: Network Chaos & Infrastructure Faults\n\nAdvanced fault types require careful testing due to their potential for system-wide impact. Verification emphasizes containment and reversibility.\n\n| Checkpoint | Verification Command | Expected Observable Behavior | What to Check If Failing |\n|------------|---------------------|------------------------------|---------------------------|\n| **Network Partition Simulation** | `sudo go test ./pkg/fault -run TestNetworkPartition -v` | Test passes. iptables rules isolate two containers; ping fails during partition, succeeds after cleanup. | - iptables chain management<br>- Rule collision avoidance<br>- Dual-direction blocking |\n| **DNS Failure Injection** | `go test ./pkg/fault -run TestDNSFault -v` | Test passes. DNS resolution fails (NXDOMAIN, timeout) for targeted domains, other domains unaffected. | - /etc/resolv.conf modification<br>- Local DNS server management<br>- DNS cache interference |\n| **Disk Full Simulation** | `sudo go test ./pkg/fault -run TestDiskFull -v` | Test passes. Filesystem usage increases to specified percentage, write operations fail appropriately, cleanup restores space. | - Filesystem monitoring<br>- dd/mkfile operations<br>- inode exhaustion cases |\n| **OOM Killer Simulation** | `sudo go test ./pkg/fault -run TestOOMFault -v` | Test passes. Memory pressure triggers OOM killer, targeted process dies, memory usage returns to normal after cleanup. | - Memory cgroup configuration<br>- OOM score adjustment<br>- Process selection algorithm |\n| **Bandwidth Throttling** | `sudo go test ./pkg/fault -run TestBandwidthThrottle -v` | Test passes. Network throughput limited to specified rate, verified with iperf3, cleanup restores full bandwidth. | - tc htb configuration<br>- Burst parameter calculation<br>- Interface selection logic |\n\n#### Cross-Milestone Integration Verification\n\nAfter implementing multiple milestones, run integration tests that span component boundaries:\n\n| Checkpoint | Verification Command | Expected Observable Behavior |\n|------------|---------------------|------------------------------|\n| **Full Experiment Lifecycle** | `go test ./integration -run TestFullExperimentLifecycle -v` | Complete experiment with hypothesis, faults, safety rules executes successfully from start to report generation. |\n| **GameDay with Real Faults** | `sudo go test ./integration -run TestGameDayRealFaults -v` | GameDay scenario executes multiple experiments with actual (not mocked) fault injection in isolated containers. |\n| **Platform Resilience** | `go test ./integration -run TestPlatformResilience -v` | Platform continues operating correctly when subjected to network latency, packet loss, and process kills. |\n\n### Common Pitfalls in Testing Chaos Code\n\nTesting code that injects failures presents unique challenges. Avoid these common mistakes:\n\n⚠️ **Pitfall: Testing with Insufficient Isolation**\n\n- **Description**: Running fault injection tests that affect the host machine or shared development environment.\n- **Why it's wrong**: Network faults can disrupt other developers' work; process kills can terminate important services; resource exhaustion can crash the test runner itself.\n- **How to fix**: Always use containerized test environments (Docker containers with resource limits) and network namespaces. Mock dangerous operations in unit tests, reserving real injection for carefully isolated integration tests.\n\n⚠️ **Pitfall: Assuming Cleanup Always Succeeds**\n\n- **Description**: Writing tests that only verify fault injection works, without verifying cleanup restores the original state.\n- **Why it's wrong**: In production, failed cleanup leaves systems permanently impaired—the exact opposite of chaos engineering's safety goals.\n- **How to fix**: Every fault injection test must include a cleanup verification phase. Use property-based testing to ensure reversibility holds for all parameter combinations.\n\n⚠️ **Pitfall: Ignoring Timing and Race Conditions**\n\n- **Description**: Writing synchronous tests for inherently asynchronous operations (fault application, metric collection, safety monitoring).\n- **Why it's wrong**: Real-world execution involves delays: tc rules take milliseconds to apply, metrics have collection latency, safety checks run on intervals.\n- **How to fix**: Use eventual consistency patterns in tests: poll for expected state with timeout. Test race conditions explicitly by injecting delays at synchronization points.\n\n⚠️ **Pitfall: Over-Mocking Dependencies**\n\n- **Description**: Mocking so many dependencies that the test verifies nothing about real interactions.\n- **Why it's wrong**: A test that passes with mocks may fail in production because the mocked component behaved differently than the real one.\n- **How to fix**: Follow the testing pyramid: unit tests with mocks for logic, integration tests with real components (in containers), end-to-end tests with minimal mocking.\n\n⚠️ **Pitfall: Not Testing the Failure Modes of the Platform Itself**\n\n- **Description**: Only testing the sunny-day path where the platform works perfectly.\n- **Why it's wrong**: The platform must handle its own failures gracefully—network partitions between orchestrator and agents, agent crashes, metric collection failures.\n- **How to fix**: Implement chaos tests for the platform itself. Test recovery from crashes, network isolation, and resource exhaustion.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Easier to Implement) | Advanced Option (More Production-Ready) |\n|-----------|--------------------------------------|----------------------------------------|\n| **Unit Testing** | Go's built-in `testing` package with table-driven tests | Same plus testify/suite for structure |\n| **Property Testing** | Manual example generation | `gopter` for automatic generation and shrinking |\n| **Mocking** | Manual interface implementations | `gomock` or `mockery` for generated mocks |\n| **Integration Environment** | Local processes with mocked system calls | Docker containers with actual fault injection |\n| **Metrics Collection** | Mock metrics returning fixed values | Actual Prometheus queries to test instance |\n| **Test Containers** | Manual container management with Docker CLI | `testcontainers-go` for programmatic control |\n| **Coverage Analysis** | `go test -cover` | `go test -coverprofile` + HTML visualization |\n\n#### B. Recommended File/Module Structure for Tests\n\nOrganize tests alongside implementation code following Go conventions:\n\n```\nproject-root/\n├── pkg/\n│   ├── fault/\n│   │   ├── fault.go              # Core fault types and interfaces\n│   │   ├── fault_test.go         # Unit tests for fault logic\n│   │   ├── injector/\n│   │   │   ├── injector.go       # Fault injection implementation\n│   │   │   ├── injector_test.go  # Unit tests (mocked)\n│   │   │   └── injector_it.go    # Integration tests (requires root)\n│   │   └── property/\n│   │       └── reversibility_test.go  # Property-based tests\n│   ├── experiment/\n│   │   ├── orchestrator.go\n│   │   ├── orchestrator_test.go\n│   │   ├── hypothesis/\n│   │   │   ├── validator.go\n│   │   │   └── validator_test.go\n│   │   └── safety/\n│   │       ├── monitor.go\n│   │       └── monitor_test.go\n│   ├── gameday/\n│   │   ├── controller.go\n│   │   ├── controller_test.go\n│   │   └── scenarios/\n│   │       ├── parser.go\n│   │       └── parser_test.go\n│   └── metrics/\n│       ├── collector.go\n│       ├── collector_test.go\n│       └── prometheus/\n│           ├── client.go\n│           └── client_test.go\n├── integration/\n│   ├── experiment_lifecycle_test.go  # Cross-component tests\n│   ├── gameday_scenario_test.go\n│   └── Dockerfile.test               # Test container definition\n└── cmd/\n    └── chaos-agent/\n        ├── main.go\n        └── main_test.go\n```\n\n#### C. Infrastructure Starter Code: Test Helper for Root-Required Tests\n\nCreate a test helper that safely skips tests requiring root privileges or specific kernel capabilities:\n\n```go\n// pkg/testutils/root_check.go\npackage testutils\n\nimport (\n    \"os\"\n    \"runtime\"\n    \"testing\"\n)\n\n// SkipIfNotRoot skips the test if not running as root on Linux\nfunc SkipIfNotRoot(t *testing.T) {\n    t.Helper()\n    if runtime.GOOS != \"linux\" {\n        t.Skip(\"Test requires Linux\")\n    }\n    if os.Geteuid() != 0 {\n        t.Skip(\"Test requires root privileges (CAP_NET_ADMIN for network faults)\")\n    }\n}\n\n// SkipIfNoTC skips if tc command not available\nfunc SkipIfNoTC(t *testing.T) {\n    t.Helper()\n    if _, err := exec.LookPath(\"tc\"); err != nil {\n        t.Skip(\"tc command not available in PATH\")\n    }\n}\n\n// SkipIfNoCgroup skips if cgroup filesystem not mounted\nfunc SkipIfNoCgroup(t *testing.T, subsystem string) {\n    t.Helper()\n    path := fmt.Sprintf(\"/sys/fs/cgroup/%s\", subsystem)\n    if _, err := os.Stat(path); os.IsNotExist(err) {\n        t.Skipf(\"cgroup subsystem %s not available at %s\", subsystem, path)\n    }\n}\n```\n\n#### D. Core Logic Skeleton: Property-Based Test for Fault Reversibility\n\n```go\n// pkg/fault/property/reversibility_test.go\npackage property\n\nimport (\n    \"testing\"\n    \"github.com/leanovate/gopter\"\n    \"github.com/leanovate/gopter/gen\"\n    \"github.com/leanovate/gopter/prop\"\n    \"github.com/yourproject/pkg/fault\"\n)\n\n// faultGenerator creates random Fault instances for property testing\nfunc faultGenerator() gopter.Gen {\n    return gen.Struct(reflect.TypeOf(fault.Fault{}), map[string]gopter.Gen{\n        \"Type\": gen.OneConst(\n            fault.FaultTypeLatency,\n            fault.FaultTypePacketLoss,\n            fault.FaultTypeProcessKill,\n            fault.FaultTypeCPUStress,\n            fault.FaultTypeMemoryStress,\n        ),\n        \"Target\": gen.Struct(reflect.TypeOf(fault.Target{}), map[string]gopter.Gen{\n            \"Type\":     gen.Const(\"pod\"),\n            \"Selector\": gen.MapOf(gen.AlphaString(), gen.AlphaString()),\n            \"Count\":    gen.IntRange(1, 10),\n        }),\n        \"Parameters\": gen.MapOf(gen.AlphaString(), gen.AlphaString()),\n    })\n}\n\nfunc TestFaultReversibility(t *testing.T) {\n    parameters := gopter.DefaultTestParameters()\n    parameters.MinSuccessfulTests = 100  // Test 100 random fault configurations\n    parameters.MaxDiscardRatio = 10      // Allow some generated faults to be invalid\n    \n    properties := gopter.NewProperties(parameters)\n    \n    properties.Property(\"All faults are reversible\", prop.ForAll(\n        func(originalFault fault.Fault) (bool, error) {\n            // TODO 1: Create a test environment snapshot (baseline state)\n            // - Record network configuration (tc rules, iptables)\n            // - Record process list and states\n            // - Record resource usage (CPU, memory, disk)\n            \n            // TODO 2: Validate the fault parameters are injectable\n            // - Skip invalid configurations (return true to discard)\n            // - For network faults, ensure target interface exists\n            // - For process faults, ensure test process exists\n            \n            // TODO 3: Inject the fault\n            // - Use fault injector with test mode enabled\n            // - Capture any error during injection\n            \n            // TODO 4: Verify fault is active\n            // - Check tc rules for network faults\n            // - Check process status for process kill\n            // - Check cgroup limits for resource faults\n            \n            // TODO 5: Clean up the fault\n            // - Call CleanupFault with the fault ID\n            // - Verify cleanup command succeeds\n            \n            // TODO 6: Compare system state to baseline\n            // - Network configuration should match\n            // - Process states should match (except temporary test processes)\n            // - Resource limits should be removed\n            \n            // TODO 7: Return true if state matches baseline, false otherwise\n            // Include detailed diagnostic information in error\n            \n            return true, nil\n        },\n        faultGenerator(),\n    ))\n    \n    properties.TestingRun(t)\n}\n```\n\n#### E. Language-Specific Hints for Go Testing\n\n1. **Use `t.Cleanup()` for reliable test teardown**: Register cleanup functions that run even if the test fails.\n   ```go\n   func TestNetworkFault(t *testing.T) {\n       // Setup\n       cleanup := setupTestNetwork()\n       t.Cleanup(cleanup)  // Guaranteed to run\n       \n       // Test logic (even if this panics, cleanup runs)\n   }\n   ```\n\n2. **Test main functions with `TestMain`**: Use `TestMain` for global setup/teardown:\n   ```go\n   func TestMain(m *testing.M) {\n       // Global setup (start Docker daemon, create test network)\n       code := m.Run()\n       // Global teardown\n       os.Exit(code)\n   }\n   ```\n\n3. **Parallelize independent tests**: Use `t.Parallel()` for tests without shared state:\n   ```go\n   func TestIndependentFeature(t *testing.T) {\n       t.Parallel()  // Runs concurrently with other parallel tests\n       // Test logic\n   }\n   ```\n\n4. **Use table-driven tests for parameter variations**:\n   ```go\n   func TestFaultValidation(t *testing.T) {\n       testCases := []struct{\n           name string\n           fault fault.Fault\n           expectError bool\n       }{\n           {\"valid latency\", fault.Fault{Type: fault.FaultTypeLatency, ...}, false},\n           {\"missing target\", fault.Fault{Type: fault.FaultTypeLatency, ...}, true},\n       }\n       \n       for _, tc := range testCases {\n           t.Run(tc.name, func(t *testing.T) {\n               err := tc.fault.Validate()\n               if tc.expectError && err == nil {\n                   t.Error(\"expected error but got none\")\n               }\n               // ... more assertions\n           })\n       }\n   }\n   ```\n\n#### F. Milestone Checkpoint Commands Summary\n\nCreate a `Makefile` with checkpoint verification targets:\n\n```makefile\n.PHONY: checkpoint-m1 checkpoint-m2 checkpoint-m3 checkpoint-m4 checkpoint-m5\n\ncheckpoint-m1:  # Milestone 1: Fault Injection Framework\n\tgo test ./pkg/fault -run \"TestLatencyFault|TestPacketLossFault|TestProcessKill|TestCPUStress|TestMemoryStress\" -v\n\tsudo go test ./pkg/fault -run TestFaultReversibility -v 2>/dev/null || echo \"Note: Property test may require root\"\n\ncheckpoint-m2:  # Milestone 2: Experiment Orchestration\n\tgo test ./pkg/experiment -run \"TestCreateExperiment|TestValidateHypothesis|TestExperimentStateMachine|TestSafetyAbort|TestCrashRecovery\" -v\n\ncheckpoint-m3:  # Milestone 3: GameDay Automation\n\tgo test ./pkg/gameday -run \"TestLoadScenario|TestExecuteScenario|TestManualApproval|TestGenerateReport|TestScenarioAbort\" -v\n\ncheckpoint-m4:  # Milestone 4: Steady-State Hypothesis\n\tgo test ./pkg/hypothesis -run TestParseHypothesis -v\n\tgo test ./pkg/metrics -run TestValidateThreshold -v\n\tgo test ./pkg/experiment -run \"TestStatisticalValidation|TestBlastRadius|TestCollectionDuringChaos\" -v\n\ncheckpoint-m5:  # Milestone 5: Network & Infrastructure Faults\n\tsudo go test ./pkg/fault -run \"TestNetworkPartition|TestDNSFault|TestDiskFull|TestOOMFault|TestBandwidthThrottle\" -v 2>/dev/null || echo \"Note: These tests require root and specific kernel features\"\n\ncheckpoint-all: checkpoint-m1 checkpoint-m2 checkpoint-m3 checkpoint-m4 checkpoint-m5\n```\n\n#### G. Debugging Tips for Failing Tests\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Test passes locally but fails in CI** | Environment differences (missing commands, permissions, kernel features) | Compare `uname -a`, `which tc`, `cat /proc/filesystems` between environments | Add prerequisite checks with `t.Skip()` for missing dependencies |\n| **Network fault test leaves iptables rules** | Cleanup not called due to test panic or early exit | Check test logs for panic; use `sudo iptables -L -n -v` after test failure | Wrap test logic in defer cleanup or use `t.Cleanup()` |\n| **Property test finds counterexample but shrinking fails** | Shrinker doesn't understand custom generator | Print the failing case; implement custom shrinker for `Fault` type | Implement `gopter.Shrinker` interface for fault generator |\n| **Race condition in concurrent experiment tests** | Shared state between tests (global variables) | Run tests with `-race` flag; look for data race warnings | Use test-local state, avoid global variables, add mutex protection |\n| **Metrics collection test times out** | Prometheus query takes too long or hangs | Add query timeout; check Prometheus server logs; mock for unit tests | Implement context with timeout for metric queries |\n| **Containerized test leaves dangling containers** | Test doesn't clean up containers on failure | Check Docker with `docker ps -a` after test; look for containers with test labels | Use `testcontainers-go` which auto-cleans, or defer `container.Remove()` |\n| **Root-required test skipped even as root** | Effective vs real UID mismatch (sudo vs su) | Print `os.Geteuid()` and `os.Getuid()` in test setup | Use `sudo` with preserved environment: `sudo -E go test` |\n\n> **Final Testing Principle**: The chaos platform must be **more thoroughly tested than the systems it tests**. Every line of code that injects failures should have corresponding tests that verify it can be safely reverted. This rigorous testing discipline transforms the platform from a potential source of outages into a reliable tool for building resilience.\n\n\n> **Milestone(s):** All milestones (debugging is a cross-cutting concern for the entire platform)\n\n## Debugging Guide\n\nBuilding a chaos engineering platform involves complex interactions between network manipulation, system calls, state machines, and distributed coordination. When things go wrong, the platform itself—designed to inject failures—must be debuggable. This section provides a structured approach to diagnosing common issues, organized as a symptom-cause-fix reference manual for developers building the platform.\n\n### Mental Model: The Chaos Platform's Own Flight Recorder\nThink of debugging this system as investigating an **aircraft incident**. The chaos platform has its own \"flight recorders\" (logs, metrics, and audit trails) that capture every action taken. When a fault injection fails or an experiment behaves unexpectedly, you need to:\n1. **Check the black box** (the platform's own observability data)\n2. **Reconstruct the sequence of events** (what commands were issued in what order)\n3. **Verify the actual system state** (what actually happened versus what was supposed to happen)\n4. **Test the control mechanisms** (are the platform's own safety systems working?)\n\nThe debugging approach follows this investigative pattern, moving from observable symptoms to root causes.\n\n### Common Bug Patterns\n\nThe following table categorizes the most frequent issues encountered during platform development, organized by symptom area. Each entry provides diagnostic steps to isolate the cause and recommended fixes.\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|-------------|------------------|-----|\n| **Fault not applied** - The fault definition appears valid but no observable effect occurs on target systems | 1. Insufficient permissions for network manipulation<br>2. Target selector mismatch<br>3. Fault injection agent not running<br>4. Network namespace isolation (containers)<br>5. Timing issue: fault hasn't propagated yet | 1. Check agent logs for permission errors (`CAP_NET_ADMIN` missing)<br>2. Verify target selector matches actual pods/services: `kubectl get pods -l app=target-app`<br>3. Confirm agent process is running: `ps aux | grep chaos-agent`<br>4. Check if target is in container: `docker exec -it container_id ip addr show`<br>5. Wait 5-10 seconds, then verify fault status via `GetFaultStatus()` | 1. Ensure agent runs with `CAP_NET_ADMIN` capability or as root<br>2. Adjust selector labels or use direct IP targeting<br>3. Restart agent with proper configuration<br>4. Use container-aware injection: execute commands inside target namespace<br>5. Implement synchronous fault injection confirmation |\n| **Fault cleanup fails** - Fault remains active after experiment completion or manual rollback | 1. Cleanup command malformed or incorrect<br>2. Agent crash during cleanup phase<br>3. Network isolation prevents cleanup commands from reaching target<br>4. State inconsistency: fault already cleaned up but status not updated<br>5. Orphaned resources from previous crashed experiment | 1. Examine `FaultRecord.CleanupCmd` field in WAL<br>2. Check agent restart logs for recovery attempts<br>3. Verify network connectivity to target during cleanup<br>4. Compare `FaultState` with actual system state<br>5. Run `RecoverOrphanedFaults()` on platform startup | 1. Use idempotent cleanup commands that can run multiple times<br>2. Implement `CleanupEnsurer` with persistent WAL<br>3. Test cleanup path during fault validation<br>4. Add state verification before marking cleanup complete<br>5. Schedule periodic orphaned resource scans |\n| **Safety monitor fails to trigger auto-rollback** despite metric breaches | 1. Metric collection lag or sampling interval too long<br>2. Safety rule threshold incorrectly specified<br>3. Metric query returns no data or wrong data<br>4. Safety monitor component crashed or stuck<br>5. Race condition: fault injected after safety check passed | 1. Check metric timestamps vs. current time (lag > 30s indicates problem)<br>2. Validate `SafetyRule.Condition` syntax and threshold values<br>3. Test metric query directly against metrics backend<br>4. Verify safety monitor heartbeat and health status<br>5. Examine event timestamps in `ExperimentResult.SafetyEvents` | 1. Reduce metric collection interval during experiments<br>2. Add syntax validation for safety rules during experiment creation<br>3. Implement metric query validation and fallback values<br>4. Add dead man's switch with `MetricsChecker.heartbeatQuery`<br>5. Implement sliding window checks instead of single-point evaluations |\n| **Experiment hangs in BASELINE_VALIDATION state** indefinitely | 1. Hypothesis validation timeout too long<br>2. Metric thresholds impossible to meet (system never in steady state)<br>3. Metrics collector unreachable or returning errors<br>4. Validation algorithm deadlock or infinite loop<br>5. Missing metric data for required time period | 1. Check `validateBaseline` function timeout configuration<br>2. Examine `Hypothesis.Metrics` thresholds vs. actual system capability<br>3. Test metrics collector connectivity: `GetCurrentValue(\"up\")`<br>4. Check for mutex deadlocks in validation logic<br>5. Verify metric exists and has data for required `Duration` | 1. Implement configurable timeout with default (e.g., 2 minutes)<br>2. Add baseline validation threshold adjustment or warning system<br>3. Implement retry with exponential backoff for metric queries<br>4. Use timeout contexts for all validation operations<br>5. Add pre-flight check for metric availability before experiment start |\n| **Network chaos affects chaos tool itself** - Platform becomes unreachable during network partition experiments | 1. Blast radius includes chaos platform components<br>2. Network fault applied indiscriminately to all traffic<br>3. Agent running on same node as target without isolation<br>4. Platform uses same network path as target traffic | 1. Check `BlastRadius.Services` excludes chaos platform services<br>2. Verify `Target.Selector` specificity (not matching everything)<br>3. Check if agent and target share network namespace<br>4. Test network partition with `iptables -L` to see affected IP ranges | 1. Always exclude chaos platform from blast radius by default<br>2. Use precise iptables rules targeting specific IP:port combinations<br>3. Run chaos agents on dedicated nodes or with network isolation<br>4. Implement control plane traffic over separate network interface |\n| **Scenario pauses but manual approval not requested** - GameDay automation halts unexpectedly | 1. `ScenarioStep.RequiresApproval` incorrectly set<br>2. Approval gate timeout expired without action<br>3. Observer notification mechanism failed<br>4. Scenario state machine incorrectly transitioned<br>5. Concurrent modification of scenario state | 1. Check step definition in `Scenario.Steps[CurrentStep]`<br>2. Verify `AutoProceedAfter` duration and timer logic<br>3. Test notification system (webhook, email, chat integration)<br>4. Examine scenario state transitions in logs<br>5. Check for race conditions in `PauseScenario`/`ResumeScenario` | 1. Add validation for approval step configuration<br>2. Implement approval timeout logging and alerting<br>3. Add redundant notification channels and confirmation receipts<br>4. Use state machine with proper transition guards<br>5. Add mutex protection for `scenarioInstance` modifications |\n| **Metrics show no change during fault injection** despite expected impact | 1. Fault not actually applied (see first symptom)<br>2. Wrong metrics being monitored for this fault type<br>3. System has redundancy that masks the fault<br>4. Fault parameters too weak (e.g., 5ms latency on 500ms baseline)<br>5. Metrics aggregation hides short-term spikes | 1. Confirm fault is active via `GetFaultStatus()` and system checks<br>2. Verify metric queries align with expected fault impact<br>3. Check if load balancer routes around faulty instance<br>4. Compare fault parameters with baseline measurements<br>5. Reduce metrics aggregation window or use higher resolution | 1. Add fault effectiveness verification (pre/post metrics comparison)<br>2. Include recommended metrics in fault type documentation<br>3. Test with single instance or disable redundancy temporarily<br>4. Scale fault parameters based on baseline measurements<br>5. Configure high-resolution metrics collection during experiments |\n| **CPU/Memory stress faults cause agent OOM kill or high CPU** | 1. Stress tool not isolated from agent process<br>2. Memory limits not set on stress process<br>3. Agent shares cgroup with stress process<br>4. Cleanup fails to terminate stress processes | 1. Check if agent memory usage increases during stress fault<br>2. Verify stress processes are in separate cgroup<br>3. Examine process tree: `pstree -p agent_pid`<br>4. Check for zombie stress processes after cleanup | 1. Run stress tools in separate containers or cgroups<br>2. Set memory limits on stress processes<br>3. Use process namespace isolation<br>4. Implement double-kill with SIGKILL after SIGTERM timeout |\n| **Experiment results show \"PASS\" despite obvious system degradation** | 1. Hypothesis thresholds too lenient<br>2. Validation uses wrong time ranges (before/during/after)<br>3. Statistical test incorrectly applied (e.g., mean vs. P95)<br>4. Results analysis ignores safety breach events<br>5. Bug in `validateHypothesis` algorithm | 1. Compare metric values against thresholds manually<br>2. Verify `MetricSample` time ranges cover injection period<br>3. Check which statistic is used in `MetricValidationResult`<br>4. Examine `ExperimentResult.SafetyEvents` for triggered rules<br>5. Test hypothesis validation with synthetic known data | 1. Add severity levels to hypothesis violations<br>2. Implement time range validation in results generation<br>3. Use appropriate statistics for each metric type<br>4. Include safety breaches in overall experiment result<br>5. Add unit tests for hypothesis validation edge cases |\n| **Platform crashes and loses experiment state on restart** | 1. In-memory state not persisted<br>2. WAL not properly fsync'd before acknowledging operations<br>3. State recovery logic incomplete or buggy<br>4. Concurrent writes corrupt state file<br>5. Disk full or permission issues | 1. Check if `Experiment` objects exist after restart<br>2. Examine WAL file for incomplete records<br>3. Test `RecoverOrphanedFaults()` function<br>4. Look for file corruption errors in logs<br>5. Check disk space and file permissions | 1. Implement persistent storage for all state<br>2. Use WAL with proper fsync for critical operations<br>3. Complete recovery logic covering all state types<br>4. Use file locking for state file access<br>5. Add disk space monitoring and pre-flight checks |\n\n> **Key Insight:** The most dangerous bugs in a chaos platform are those that prevent cleanup or auto-rollback. Always test the \"undo\" path more rigorously than the \"do\" path. A fault that fails to apply is a missed experiment; a fault that can't be cleaned up is an actual outage.\n\n### Domain-Specific Debugging Techniques\n\nChaos engineering platforms interact with system internals in ways that require specialized debugging approaches beyond standard application debugging. These techniques leverage system tools and platform-specific instrumentation.\n\n#### Network Fault Verification\nWhen network faults (latency, packet loss, partition) don't behave as expected:\n\n| Technique | Command/Action | Expected Output | Interpretation |\n|-----------|---------------|-----------------|----------------|\n| **Verify tc rules** | `tc qdisc show dev eth0`<br>`tc class show dev eth0` | Lists queueing disciplines with parameters like `latency 200ms` `loss 10%` | Rules present = fault applied correctly. Missing rules = injection failed. |\n| **Check iptables for partitions** | `iptables -L -n -v`<br>`iptables -t nat -L -n -v` | Shows packet counts matching DROP/REJECT rules between specific IPs | Packet counts increasing = rule active and traffic being blocked. |\n| **Test connectivity** | `mtr -r -c 10 target_ip`<br>`tcping -p 80 target_ip` | Shows latency distribution and packet loss percentages | Measured values should match fault parameters ± margin. |\n| **Namespace isolation check** | `ls -la /proc/self/ns/net`<br>`nsenter -t pid -n ip addr show` | Compare network namespace IDs; view network from target's perspective | Different namespace IDs mean container isolation; commands need `nsenter`. |\n\n#### Resource Exhaustion Monitoring\nFor CPU, memory, and disk stress faults:\n\n| Technique | Command/Action | Expected Output | Interpretation |\n|-----------|---------------|-----------------|----------------|\n| **Check cgroup limits** | `cat /sys/fs/cgroup/cpu/target_cgroup/cpu.cfs_quota_us`<br>`cat /sys/fs/cgroup/memory/target_cgroup/memory.limit_in_bytes` | Shows configured CPU quota and memory limit | Values should reflect stress fault parameters. |\n| **Monitor process tree** | `ps aux --forest`<br>`pstree -p agent_pid` | Shows parent-child relationships of stress processes | Stress processes should be child of agent or in separate container. |\n| **Verify resource usage** | `top -b -n 1 -p target_pid`<br>`free -m` | Shows CPU% and memory usage of target processes | Should approach configured utilization levels. |\n| **Check OOM killer logs** | `dmesg \\| grep -i oom`<br>`journalctl -k \\| grep -i oom` | Shows out-of-memory events and killed processes | Expected for memory stress tests; verify correct process killed. |\n\n#### Platform Internal State Inspection\nDebug the chaos platform's own state machines and coordination:\n\n| Technique | Command/Action | Expected Output | Interpretation |\n|-----------|---------------|-----------------|----------------|\n| **Dump experiment state** | Call `GetExperimentStatus()` via API or inspect `Orchestrator.experiments` map | Returns `ExperimentInstance.State` and timestamps | Shows which state machine step is stuck or failed. |\n| **Check WAL for recovery** | `strings /var/lib/chaos/wal.log \\| tail -20` | Shows recent fault injection/cleanup commands | Indicates what operations were attempted before crash. |\n| **Verify event flow** | Subscribe to `InMemoryPubSub` events and log all messages | Shows event sequence: `experiment_started` → `fault_injecting` → etc. | Missing events indicate broken publish/subscribe. |\n| **Inspect safety metrics** | Call `GetCurrentValue()` for each safety metric during experiment | Returns numeric values for error rates, latency, etc. | Values above thresholds should trigger safety events. |\n\n#### Pre-Flight Validation Checklist\nBefore running any experiment, execute these validation steps to catch common configuration issues:\n\n1. **Target Validation:**\n   ```bash\n   # Verify target selectors match actual resources\n   kubectl get pods -l $(echo $SELECTOR | tr ',' ' ')\n   ping -c 1 $TARGET_IP\n   nc -zv $TARGET_IP $TARGET_PORT\n   ```\n\n2. **Permission Validation:**\n   ```bash\n   # Check for required capabilities\n   cat /proc/$(pidof chaos-agent)/status | grep Cap\n   # Should include CapEff: 0000000000200000 (CAP_NET_ADMIN)\n   ```\n\n3. **Metric Availability:**\n   ```bash\n   # Test metric queries return data\n   curl -s \"$METRICS_URL/api/v1/query?query=up\" | jq '.data.result'\n   ```\n\n4. **Cleanup Command Test:**\n   ```bash\n   # Dry-run cleanup commands to verify syntax\n   echo $CLEANUP_CMD | sh -n\n   ```\n\n5. **Blast Radius Verification:**\n   ```bash\n   # Ensure platform components are excluded\n   if [[ \"$PLATFORM_SERVICE\" =~ $BLAST_RADIUS_SERVICES ]]; then\n     echo \"ERROR: Platform service included in blast radius\"\n   fi\n   ```\n\n#### Diagnostic Logging Strategy\nAdd strategic logging to the platform to capture debugging information:\n\n| Log Location | What to Log | Debugging Value |\n|--------------|-------------|-----------------|\n| **Before fault injection** | Target verification results, permission checks, parameter validation | Identifies why injection might fail before attempting |\n| **After each system command** | Command executed, stdout, stderr, exit code | Shows exactly what happened at system level |\n| **State transitions** | `ExperimentState` changes with timestamps and triggering event | Tracks state machine progress and identifies stuck states |\n| **Metric collection** | Query executed, data points returned, timestamps | Verifies metrics are being collected correctly |\n| **Safety evaluations** | Rule checked, metric value, threshold, result | Shows why safety rules did or didn't trigger |\n| **Cleanup operations** | Cleanup command, success/failure, system state after | Critical for ensuring fault reversal |\n\n> **Critical Practice:** Implement a **debug mode** that can be enabled via feature flag or environment variable. When enabled, the platform should log at DEBUG level, capture all system command outputs, and perform extra validation steps. This mode will generate more log data but is essential for diagnosing complex issues during development.\n\n#### Time Synchronization Considerations\nMany chaos experiments rely on precise timing for:\n- Fault duration measurements\n- Metric sampling windows\n- State machine timeouts\n- Scheduled experiment execution\n\n**Problem:** If system clocks drift between the chaos platform components, metrics may be analyzed against wrong time windows, making hypothesis validation unreliable.\n\n**Diagnosis:**\n```bash\n# Check clock drift between components\ndate\ncurl -s $AGENT_URL/api/health | grep current_time\n```\n\n**Fix:** \n1. Run NTP daemon on all platform components\n2. Use monotonic clocks (`time.Now()` in Go) for duration measurements\n3. Include timestamp in all cross-component messages\n4. Allow configurable time tolerance in metric validation (e.g., ±2 seconds)\n\n### Implementation Guidance\n\nDebugging a chaos platform requires building diagnostic capabilities into the platform itself. This guidance provides concrete implementation patterns for the debugging features discussed above.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Diagnostic Logging** | Structured JSON logging with log levels | Distributed tracing with OpenTelemetry |\n| **Metrics Collection** | Direct Prometheus queries with retries | Metrics proxy with caching and validation |\n| **System Command Debug** | Log command + stdout/stderr + exit code | Command execution with timeout and replay capability |\n| **State Inspection** | HTTP endpoints returning JSON state dumps | Real-time WebSocket stream of state changes |\n| **Pre-flight Checks** | Synchronous validation before experiment start | Continuous health checks with circuit breakers |\n\n#### B. Recommended File/Module Structure\n\nAdd debugging utilities to the project structure:\n\n```\nproject-root/\n├── cmd/\n│   ├── chaos-controller/         # Main orchestrator\n│   └── chaos-agent/              # Fault injection agent\n├── internal/\n│   ├── debug/                    # Debugging utilities\n│   │   ├── inspector.go          # State inspection endpoints\n│   │   ├── preflight.go          # Pre-flight validation checks\n│   │   ├── logger.go             # Enhanced structured logging\n│   │   └── diagnostics.go        # Health checks and diagnostics\n│   ├── orchestrator/             # Experiment orchestration\n│   ├── fault/                    # Fault injection\n│   ├── metrics/                  # Metrics collection\n│   └── safety/                   # Safety monitoring\n├── pkg/\n│   └── types/                    # Shared types (Experiment, Fault, etc.)\n└── tools/\n    ├── debug-cli/                # Command-line debugging tool\n    └── chaos-replay/             # Tool to replay experiments from logs\n```\n\n#### C. Diagnostic Logging Implementation\n\nHere's a complete structured logging implementation for the chaos platform:\n\n```go\n// internal/debug/logger.go\npackage debug\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"time\"\n)\n\n// LogLevel represents the severity of a log entry\ntype LogLevel string\n\nconst (\n    LevelDebug LogLevel = \"DEBUG\"\n    LevelInfo  LogLevel = \"INFO\"\n    LevelWarn  LogLevel = \"WARN\"\n    LevelError LogLevel = \"ERROR\"\n)\n\n// LogEntry represents a structured log entry\ntype LogEntry struct {\n    Timestamp  time.Time              `json:\"timestamp\"`\n    Level      LogLevel               `json:\"level\"`\n    Component  string                 `json:\"component\"`\n    Message    string                 `json:\"message\"`\n    Fields     map[string]interface{} `json:\"fields,omitempty\"`\n    Experiment string                 `json:\"experiment,omitempty\"`\n    Fault      string                 `json:\"fault,omitempty\"`\n}\n\n// DiagnosticLogger provides structured logging with fields\ntype DiagnosticLogger struct {\n    component string\n    debugMode bool\n    logger    *log.Logger\n}\n\n// NewDiagnosticLogger creates a new logger for a component\nfunc NewDiagnosticLogger(component string, debugMode bool) *DiagnosticLogger {\n    return &DiagnosticLogger{\n        component: component,\n        debugMode: debugMode,\n        logger:    log.New(os.Stdout, \"\", 0), // No prefix - we'll format ourselves\n    }\n}\n\n// logInternal handles the actual logging\nfunc (l *DiagnosticLogger) logInternal(level LogLevel, msg string, fields map[string]interface{}) {\n    // Skip debug logs if debug mode is disabled\n    if level == LevelDebug && !l.debugMode {\n        return\n    }\n    \n    entry := LogEntry{\n        Timestamp: time.Now().UTC(),\n        Level:     level,\n        Component: l.component,\n        Message:   msg,\n        Fields:    fields,\n    }\n    \n    // Marshal to JSON for structured logging\n    jsonBytes, err := json.Marshal(entry)\n    if err != nil {\n        // Fallback to simple logging if JSON marshaling fails\n        l.logger.Printf(\"[%s] %s: %s %v\", level, l.component, msg, fields)\n        return\n    }\n    \n    l.logger.Println(string(jsonBytes))\n}\n\n// Debug logs a debug message with optional fields\nfunc (l *DiagnosticLogger) Debug(msg string, fields ...map[string]interface{}) {\n    mergedFields := mergeFields(fields...)\n    l.logInternal(LevelDebug, msg, mergedFields)\n}\n\n// Info logs an info message with optional fields\nfunc (l *DiagnosticLogger) Info(msg string, fields ...map[string]interface{}) {\n    mergedFields := mergeFields(fields...)\n    l.logInternal(LevelInfo, msg, mergedFields)\n}\n\n// Warn logs a warning message with optional fields\nfunc (l *DiagnosticLogger) Warn(msg string, fields ...map[string]interface{}) {\n    mergedFields := mergeFields(fields...)\n    l.logInternal(LevelWarn, msg, mergedFields)\n}\n\n// Error logs an error message with optional fields\nfunc (l *DiagnosticLogger) Error(msg string, err error, fields ...map[string]interface{}) {\n    mergedFields := mergeFields(fields...)\n    if err != nil {\n        if mergedFields == nil {\n            mergedFields = make(map[string]interface{})\n        }\n        mergedFields[\"error\"] = err.Error()\n    }\n    l.logInternal(LevelError, msg, mergedFields)\n}\n\n// WithExperiment adds experiment context to subsequent logs\nfunc (l *DiagnosticLogger) WithExperiment(experimentID string) *DiagnosticLogger {\n    // Return a wrapper that adds experiment context\n    return &ContextLogger{\n        base:        l,\n        experimentID: experimentID,\n    }\n}\n\n// WithFault adds fault context to subsequent logs\nfunc (l *DiagnosticLogger) WithFault(faultID string) *DiagnosticLogger {\n    return &ContextLogger{\n        base:    l,\n        faultID: faultID,\n    }\n}\n\n// Helper function to merge multiple field maps\nfunc mergeFields(fields ...map[string]interface{}) map[string]interface{} {\n    var result map[string]interface{}\n    for _, f := range fields {\n        if f != nil {\n            if result == nil {\n                result = make(map[string]interface{})\n            }\n            for k, v := range f {\n                result[k] = v\n            }\n        }\n    }\n    return result\n}\n\n// ContextLogger adds context to log entries\ntype ContextLogger struct {\n    base         *DiagnosticLogger\n    experimentID string\n    faultID      string\n}\n\n// Debug with context\nfunc (cl *ContextLogger) Debug(msg string, fields ...map[string]interface{}) {\n    mergedFields := mergeFields(fields...)\n    if mergedFields == nil {\n        mergedFields = make(map[string]interface{})\n    }\n    if cl.experimentID != \"\" {\n        mergedFields[\"experiment\"] = cl.experimentID\n    }\n    if cl.faultID != \"\" {\n        mergedFields[\"fault\"] = cl.faultID\n    }\n    cl.base.Debug(msg, mergedFields)\n}\n\n// Similar implementations for Info, Warn, Error...\n```\n\n#### D. State Inspector Skeleton Code\n\nImplement an HTTP endpoint for inspecting platform state:\n\n```go\n// internal/debug/inspector.go\npackage debug\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n    \"sync\"\n)\n\n// StateInspector provides HTTP endpoints for debugging platform state\ntype StateInspector struct {\n    orchestrator interface{} // Would be *orchestrator.Orchestrator in real code\n    mu           sync.RWMutex\n}\n\n// NewStateInspector creates a new state inspector\nfunc NewStateInspector(orc interface{}) *StateInspector {\n    return &StateInspector{\n        orchestrator: orc,\n    }\n}\n\n// RegisterRoutes registers debug endpoints with an HTTP mux\nfunc (si *StateInspector) RegisterRoutes(mux *http.ServeMux) {\n    mux.HandleFunc(\"/debug/state/experiments\", si.handleExperiments)\n    mux.HandleFunc(\"/debug/state/faults\", si.handleFaults)\n    mux.HandleFunc(\"/debug/state/scenarios\", si.handleScenarios)\n    mux.HandleFunc(\"/debug/health\", si.handleHealth)\n}\n\n// handleExperiments returns all experiments with their current state\nfunc (si *StateInspector) handleExperiments(w http.ResponseWriter, r *http.Request) {\n    si.mu.RLock()\n    defer si.mu.RUnlock()\n    \n    // TODO 1: Extract experiments from orchestrator (type assertion needed)\n    // TODO 2: Convert to JSON-safe structure (avoid cycles)\n    // TODO 3: Marshal to JSON and write response\n    // TODO 4: Include state, timestamps, and any errors\n    // TODO 5: Add filtering by status if query parameter provided\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    // Example response structure:\n    // json.NewEncoder(w).Encode(map[string]interface{}{\n    //     \"experiments\": experiments,\n    //     \"timestamp\": time.Now().UTC(),\n    // })\n}\n\n// handleFaults returns all active faults with their status\nfunc (si *StateInspector) handleFaults(w http.ResponseWriter, r *http.Request) {\n    // TODO 1: Query fault injector for all active faults\n    // TODO 2: Include fault parameters, target, and injection time\n    // TODO 3: Add verification status (is fault actually active?)\n    // TODO 4: Include cleanup commands for each fault\n    // TODO 5: Add filtering by experiment ID if provided\n}\n\n// handleScenarios returns all scenarios with their current step\nfunc (si *StateInspector) handleScenarios(w http.ResponseWriter, r *http.Request) {\n    // TODO 1: Query GameDayController for all scenarios\n    // TODO 2: Include current step, status, and pause reason if paused\n    // TODO 3: Add approval status for steps requiring approval\n    // TODO 4: Include scenario schedule and execution history\n}\n\n// handleHealth returns platform health status\nfunc (si *StateInspector) handleHealth(w http.ResponseWriter, r *http.Request) {\n    health := map[string]interface{}{\n        \"status\": \"healthy\",\n        \"timestamp\": time.Now().UTC(),\n        \"components\": map[string]string{\n            \"orchestrator\": \"ok\",\n            // TODO: Add actual health checks for each component\n        },\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(health)\n}\n```\n\n#### E. Pre-Flight Validation Skeleton\n\nImplement comprehensive pre-flight checks:\n\n```go\n// internal/debug/preflight.go\npackage debug\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\n// PreFlightCheck represents a single validation check\ntype PreFlightCheck struct {\n    Name        string\n    Description string\n    Severity    string // \"critical\", \"warning\", \"info\"\n    CheckFunc   func(context.Context) (bool, string, error)\n}\n\n// PreFlightValidator runs validation checks before experiment execution\ntype PreFlightValidator struct {\n    checks []PreFlightCheck\n    logger *DiagnosticLogger\n}\n\n// NewPreFlightValidator creates a validator with default checks\nfunc NewPreFlightValidator(logger *DiagnosticLogger) *PreFlightValidator {\n    pv := &PreFlightValidator{\n        logger: logger,\n    }\n    pv.registerDefaultChecks()\n    return pv\n}\n\n// registerDefaultChecks registers common validation checks\nfunc (pv *PreFlightValidator) registerDefaultChecks() {\n    pv.checks = append(pv.checks, []PreFlightCheck{\n        {\n            Name:        \"metrics_connectivity\",\n            Description: \"Verify metrics collector is reachable\",\n            Severity:    \"critical\",\n            CheckFunc:   pv.checkMetricsConnectivity,\n        },\n        {\n            Name:        \"agent_connectivity\", \n            Description: \"Verify fault injection agents are reachable\",\n            Severity:    \"critical\",\n            CheckFunc:   pv.checkAgentConnectivity,\n        },\n        {\n            Name:        \"permission_validation\",\n            Description: \"Verify agents have required permissions\",\n            Severity:    \"critical\",\n            CheckFunc:   pv.checkPermissions,\n        },\n        {\n            Name:        \"target_existence\",\n            Description: \"Verify experiment targets exist\",\n            Severity:    \"critical\", \n            CheckFunc:   pv.checkTargetExistence,\n        },\n        {\n            Name:        \"platform_exclusion\",\n            Description: \"Verify chaos platform is excluded from blast radius\",\n            Severity:    \"critical\",\n            CheckFunc:   pv.checkPlatformExclusion,\n        },\n    }...)\n}\n\n// ValidateExperiment runs all checks for an experiment\nfunc (pv *PreFlightValidator) ValidateExperiment(ctx context.Context, exp types.Experiment) (*ValidationResult, error) {\n    result := &ValidationResult{\n        ExperimentID: exp.ID,\n        Timestamp:    time.Now().UTC(),\n        Checks:       make([]CheckResult, 0, len(pv.checks)),\n    }\n    \n    // TODO 1: For each check in pv.checks, run the CheckFunc with timeout\n    // TODO 2: Capture success/failure, message, and any error\n    // TODO 3: Stop early if critical check fails (configurable)\n    // TODO 4: Aggregate results and determine overall validation status\n    // TODO 5: Log detailed results using pv.logger\n    \n    return result, nil\n}\n\n// checkMetricsConnectivity verifies metrics collector is reachable\nfunc (pv *PreFlightValidator) checkMetricsConnectivity(ctx context.Context) (bool, string, error) {\n    // TODO 1: Attempt to query a simple metric (e.g., \"up\")\n    // TODO 2: Check response time and data freshness\n    // TODO 3: Verify required metrics for experiment exist\n    // TODO 4: Return success/failure with descriptive message\n    \n    return false, \"not implemented\", nil\n}\n\n// checkAgentConnectivity verifies agents are reachable\nfunc (pv *PreFlightValidator) checkAgentConnectivity(ctx context.Context) (bool, string, error) {\n    // TODO 1: Ping each agent endpoint\n    // TODO 2: Verify agent version compatibility\n    // TODO 3: Check agent health status\n    // TODO 4: Return success/failure with descriptive message\n    \n    return false, \"not implemented\", nil\n}\n\n// checkPermissions verifies agents have required capabilities\nfunc (pv *PreFlightValidator) checkPermissions(ctx context.Context) (bool, string, error) {\n    // TODO 1: Query agent for capabilities (CAP_NET_ADMIN, etc.)\n    // TODO 2: Verify based on fault types in experiment\n    // TODO 3: Check filesystem permissions for required commands\n    // TODO 4: Return success/failure with descriptive message\n    \n    return false, \"not implemented\", nil\n}\n\n// checkTargetExistence verifies experiment targets exist\nfunc (pv *PreFlightValidator) checkTargetExistence(ctx context.Context) (bool, string, error) {\n    // TODO 1: Parse target selectors from experiment\n    // TODO 2: Query Kubernetes/cloud provider for matching resources\n    // TODO 3: Verify at least one target matches selector\n    // TODO 4: Return success/failure with descriptive message\n    \n    return false, \"not implemented\", nil\n}\n\n// checkPlatformExclusion verifies chaos platform is excluded from blast radius\nfunc (pv *PreFlightValidator) checkPlatformExclusion(ctx context.Context) (bool, string, error) {\n    // TODO 1: Extract platform service names from configuration\n    // TODO 2: Compare with blast radius services/namespaces\n    // TODO 3: Return failure if any platform component is included\n    // TODO 4: Return success/failure with descriptive message\n    \n    return false, \"not implemented\", nil\n}\n\n// ValidationResult contains results of pre-flight validation\ntype ValidationResult struct {\n    ExperimentID string\n    Timestamp    time.Time\n    Overall      bool\n    Checks       []CheckResult\n    Warnings     []string\n}\n\n// CheckResult represents the result of a single check\ntype CheckResult struct {\n    Name     string\n    Passed   bool\n    Message  string\n    Error    string\n    Severity string\n    Duration time.Duration\n}\n```\n\n#### F. Debug Mode Configuration\n\nAdd debug mode to the platform configuration:\n\n```go\n// config/config.go (excerpt)\ntype Config struct {\n    // ... other configuration fields\n    \n    Debug struct {\n        Enabled     bool          `yaml:\"enabled\" env:\"DEBUG_ENABLED\"`\n        LogLevel    string        `yaml:\"logLevel\" env:\"DEBUG_LOG_LEVEL\"`\n        StateDump   bool          `yaml:\"stateDump\" env:\"DEBUG_STATE_DUMP\"`\n        PreFlight   bool          `yaml:\"preFlight\" env:\"DEBUG_PRE_FLIGHT\"`\n        Trace       bool          `yaml:\"trace\" env:\"DEBUG_TRACE\"`\n    } `yaml:\"debug\"`\n}\n\n// In main initialization\nfunc main() {\n    config := loadConfig()\n    \n    // Create logger with debug mode\n    logger := debug.NewDiagnosticLogger(\"orchestrator\", config.Debug.Enabled)\n    \n    // Enable additional debugging based on config\n    if config.Debug.StateDump {\n        inspector := debug.NewStateInspector(orchestrator)\n        inspector.RegisterRoutes(http.DefaultServeMux)\n    }\n    \n    if config.Debug.PreFlight {\n        validator := debug.NewPreFlightValidator(logger)\n        // Use validator before experiment execution\n    }\n}\n```\n\n#### G. Milestone Debugging Checkpoints\n\nAfter implementing each milestone, verify the debugging capabilities:\n\n**Milestone 1 Checkpoint:**\n```bash\n# Start platform with debug mode enabled\nDEBUG_ENABLED=true ./chaos-controller\n\n# Test debug endpoints\ncurl http://localhost:8080/debug/health\ncurl http://localhost:8080/debug/state/faults\n\n# Verify logs show structured JSON with experiment context\ntail -f chaos.log | jq '.'\n```\n\n**Milestone 2 Checkpoint:**\n```bash\n# Test pre-flight validation\ncurl -X POST http://localhost:8080/api/v1/experiments/validate \\\n  -d @experiment.json \\\n  -H \"Content-Type: application/json\"\n\n# Check experiment state during execution\ncurl http://localhost:8080/debug/state/experiments\n\n# Verify safety monitor logs show rule evaluations\ngrep -i safety chaos.log | jq '.'\n```\n\n**Milestone 3 Checkpoint:**\n```bash\n# Test scenario debugging\ncurl http://localhost:8080/debug/state/scenarios\n\n# Add observation during scenario execution\ncurl -X POST http://localhost:8080/api/v1/scenarios/{id}/observations \\\n  -d '{\"message\": \"Manual observation\", \"severity\": \"info\"}'\n```\n\n**Expected Behavior:**\n- Debug endpoints return JSON with current state\n- Logs show structured entries with experiment/fault context\n- Pre-flight validation catches common configuration errors\n- State inspector shows accurate state machine status\n\n**Signs of Issues:**\n- Debug endpoints return 404 or empty responses\n- Logs contain unstructured text instead of JSON\n- Pre-flight checks pass but experiments still fail\n- State inspector shows stale or incorrect state information\n\n#### H. Language-Specific Debugging Hints for Go\n\n1. **Use `pprof` for performance debugging:**\n   ```go\n   import _ \"net/http/pprof\"\n   // Add to main(): go func() { log.Println(http.ListenAndServe(\":6060\", nil)) }()\n   // Then: go tool pprof http://localhost:6060/debug/pprof/heap\n   ```\n\n2. **Context timeouts for hanging operations:**\n   ```go\n   ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n   defer cancel()\n   result, err := someOperation(ctx)\n   ```\n\n3. **Structured errors with wrapping:**\n   ```go\n   import \"fmt\"\n   err := doSomething()\n   if err != nil {\n       return fmt.Errorf(\"failed to do something with param %s: %w\", param, err)\n   }\n   ```\n\n4. **Use `sync.Once` for initialization:**\n   ```go\n   var initOnce sync.Once\n   func initialize() {\n       initOnce.Do(func() {\n           // Initialization code that should run only once\n       })\n   }\n   ```\n\n5. **Debug concurrent map access with race detector:**\n   ```bash\n   go build -race ./cmd/chaos-controller\n   ./chaos-controller\n   # Race conditions will be reported to stderr\n   ```\n\nBy implementing these debugging capabilities throughout the platform, developers can quickly diagnose issues during development and operators can troubleshoot problems in production deployments. The key principle is that a chaos engineering platform must be more observable and debuggable than the systems it tests.\n\n\n> **Milestone(s):** All milestones (forward-looking capabilities that build upon the foundational architecture)\n\n## Future Extensions\n\n> **Mental Model: The Evolution of a Mature Platform**  \n> Think of the chaos engineering platform as a living organism that grows in sophistication. The current architecture provides the essential skeletal structure—organs for fault injection, nervous system for orchestration, and brain for decision-making. Future extensions represent the development of specialized organs (advanced fault types), enhanced senses (richer observability), and higher cognitive functions (AI-driven analysis) that transform a basic lifeform into a highly evolved species.\n\nThe platform's current design intentionally focuses on core capabilities to ensure reliability and safety. However, the architecture is built with extension points that enable future enhancements without requiring major refactoring. These extensions align with the **chaos maturity progression** from manual experiments to continuous, intelligent resilience validation.\n\n### Potential Enhancements\n\n#### Visual UI for Experiment Management\n**Description:** A web-based graphical interface for creating, monitoring, and analyzing chaos experiments without using CLI tools or API calls directly.\n\n**Architectural Impact:**\n- **New Component:** Web UI Server component added to the architecture\n- **Extended Interfaces:** REST API endpoints for the existing `Orchestrator`, `GameDayController`, and metrics components\n- **Data Flow Changes:** UI becomes primary interaction point; API layer handles authentication, authorization, and rate limiting\n- **Storage Requirements:** User preferences, saved experiment templates, and visualization configurations\n\n**Expected Benefits:**\n- Lower barrier to entry for non-developer roles (SREs, product managers)\n- Real-time visual monitoring of active experiments with drill-down capabilities\n- Collaborative experiment design with team sharing features\n- Historical trend visualization of experiment outcomes over time\n\n**Implementation Considerations:**\n```\nExisting Architecture Extension Points:\n1. Experiment Controller (API layer) → Add REST endpoints with OpenAPI documentation\n2. Metrics Collector → Add WebSocket endpoints for real-time metric streaming\n3. Result Analyzer → Generate visualization-friendly JSON summaries\n```\n\n**Integration Pattern:**\n```mermaid\ngraph TD\n    User[User Browser] --> UIServer[Web UI Server]\n    UIServer --> APIGateway[API Gateway]\n    APIGateway --> Orchestrator[Experiment Orchestrator]\n    APIGateway --> MetricsAPI[Metrics Collector API]\n    APIGateway --> ResultsAPI[Result Analyzer API]\n    MetricsAPI -.->|WebSocket| User\n```\n\n#### Integration with CI/CD Pipelines\n**Description:** Automated chaos testing integrated into deployment pipelines to validate resilience before production releases.\n\n**Architectural Impact:**\n- **New Integration Points:** CI/CD system plugins (GitHub Actions, GitLab CI, Jenkins)\n- **Extended Data Model:** `Experiment` gains `PipelineContext` field with build/deployment metadata\n- **New Safety Mechanism:** Pipeline-specific safety rules with tighter thresholds\n- **Result Integration:** Experiment results reported back to CI system as test results\n\n**Expected Benefits:**\n- Shift-left resilience testing catches issues earlier in development cycle\n- Automated validation of resilience assumptions for each deployment\n- Integration with canary deployment strategies for progressive validation\n- Correlation between code changes and resilience impact\n\n**Implementation Approaches:**\n| Approach | Description | Complexity | Integration Depth |\n|----------|-------------|------------|-------------------|\n| **Pre-Deployment Validation** | Run chaos experiments in staging before production deployment | Medium | Experiment results block deployment if safety thresholds breached |\n| **Post-Deployment Verification** | Run targeted experiments immediately after deployment | Low | Non-blocking; alerts only on significant deviations |\n| **Canary Validation** | Run experiments only on canary instances | High | Requires service mesh integration for traffic routing |\n| **Blue-Green Testing** | Run comprehensive experiments on inactive environment before cutover | High | Requires full environment duplication |\n\n**Example CI/CD Integration Flow:**\n1. Developer pushes code → CI pipeline builds and deploys to staging\n2. Chaos platform automatically runs pre-configured experiment suite\n3. If experiments pass (steady-state maintained), deployment proceeds to production\n4. If experiments fail, pipeline halts and team receives detailed failure analysis\n5. Post-production, lightweight verification experiments run in production with minimal blast radius\n\n#### AI-Generated Fault Scenarios Based on Service Graphs\n**Description:** Machine learning models that analyze system topology and historical failure data to suggest realistic, high-impact fault scenarios.\n\n**Architectural Impact:**\n- **New Component:** Scenario Recommender with ML capabilities\n- **Extended Data Sources:** Service discovery integration, dependency graphs, historical incident data\n- **Training Pipeline:** Offline model training using past experiment outcomes\n- **Feedback Loop:** Experiment results used to improve recommendation quality\n\n**Expected Benefits:**\n- Discovery of unexpected failure modes not considered by human operators\n- Prioritization of experiments based on predicted impact and likelihood\n- Adaptive scenario generation that evolves with system changes\n- Reduced time to design comprehensive test coverage\n\n**AI Integration Architecture:**\n```\nData Sources → Feature Engineering → ML Model → Recommendations\n     ↓               ↓                ↓            ↓\nService    Historical   Dependency  Failure   Generated\nRegistry   Incidents    Graphs      Patterns  Scenarios\n```\n\n**Recommendation Algorithm Phases:**\n1. **Graph Analysis Phase:** Parse service dependency graph to identify critical paths, single points of failure, and tight coupling\n2. **Historical Learning Phase:** Analyze past incidents and experiment outcomes to learn which fault combinations cause cascading failures\n3. **Impact Prediction Phase:** Use ML model to predict steady-state metric impact for candidate fault scenarios\n4. **Scenario Generation Phase:** Convert top predictions into executable `Scenario` definitions with appropriate blast radius limits\n\n**Implementation Roadmap:**\n| Phase | Capability | Data Requirements | Output |\n|-------|------------|-------------------|--------|\n| 1 | Basic Dependency Analysis | Service discovery data | Critical path identification |\n| 2 | Historical Pattern Matching | Past experiment results | Similar scenario suggestions |\n| 3 | Predictive Impact Modeling | Metrics history + dependency graphs | Impact scores for candidate scenarios |\n| 4 | Autonomous Scenario Generation | All above + failure mode database | Complete `Scenario` definitions |\n\n#### Advanced Scheduling and Recurring Experiments\n**Description:** Sophisticated scheduling capabilities for regular chaos testing, including calendar-based scheduling, dependency-aware sequencing, and conditional execution based on system state.\n\n**Architectural Impact:**\n- **Enhanced `Schedule` Type:** Add complex scheduling rules (cron expressions with time zones, business hours exclusion)\n- **New Component:** Scheduler Service with persistent job queue\n- **State-Aware Execution:** Pre-execution checks for system readiness\n- **Recurrence Management:** Experiment series with gradual parameter evolution\n\n**Expected Benefits:**\n- Regular, automated resilience validation without manual intervention\n- Business-hour awareness to avoid disrupting peak traffic periods\n- Progressive testing with increasing intensity over time\n- Integration with maintenance windows and change freezes\n\n**Enhanced Schedule Definition:**\n```yaml\n# Example enhanced schedule specification\nschedule:\n  type: RECURRING\n  cron: \"0 2 * * *\"  # 2 AM daily\n  timezone: \"America/New_York\"\n  exclude:\n    - days: [\"sat\", \"sun\"]           # Skip weekends\n    - hours: \"09:00-17:00\"           # Skip business hours\n    - dates: [\"2024-12-25\"]          # Skip Christmas\n  conditions:\n    - metric: \"system.load.1m\"\n      operator: \"<\"\n      value: 0.7                     # Only run if load < 70%\n    - status: \"no_active_incidents\"  # Only run if no active incidents\n  progression:\n    type: \"GRADUAL_INCREASE\"\n    parameter: \"blast_radius.percentage\"\n    start: 5\n    end: 25\n    step: 5\n    max_failures: 2                  # Stop progression after 2 failures\n```\n\n**Scheduler Architecture:**\n```\n                  [Scheduler Service]\n                         ↓\n           [Persistent Job Store (WAL)]\n                         ↓\n    ┌───────────────────┼───────────────────┐\n    ↓                   ↓                   ↓\n[Time-Based]   [Event-Based]      [Condition-Based]\n  Triggers       Triggers            Triggers\n    ↓                   ↓                   ↓\n[Validate     [Check System    [Evaluate Metric\n Conditions]     State]          Conditions]\n    ↓                   ↓                   ↓\n       [Execute Experiment via Orchestrator]\n```\n\n#### Multi-Environment and Multi-Cloud Support\n**Description:** Unified chaos engineering across heterogeneous environments including multiple cloud providers, on-premises data centers, and hybrid configurations.\n\n**Architectural Impact:**\n- **Environment Abstraction Layer:** Unified interface for different infrastructure providers\n- **Fault Injector Adapters:** Provider-specific implementations for cloud-native fault injection\n- **Cross-Environment Experiments:** Faults that span multiple environments (e.g., simulating cloud region failure affecting on-prem services)\n- **Unified Observability:** Aggregated metrics across all environments\n\n**Expected Benefits:**\n- Consistent chaos engineering practices across all deployment environments\n- Testing of cross-environment failure modes (critical for hybrid architectures)\n- Leverage cloud-native chaos capabilities (AWS Fault Injection Service, Azure Chaos Studio)\n- Centralized reporting and compliance across the entire organization\n\n**Environment Abstraction Design:**\n```go\n// Environment interface abstracts provider differences\ntype Environment interface {\n    // Provider identification\n    Provider() string\n    Region() string\n    \n    // Resource discovery\n    ListServices(selector map[string]string) ([]Service, error)\n    ListNodes(selector map[string]string) ([]Node, error)\n    \n    // Fault injection capabilities\n    SupportedFaults() []FaultType\n    InjectFault(fault Fault, target Target) (string, error)\n    \n    // Metrics collection\n    GetMetrics(query string, timeframe time.Duration) ([]MetricPoint, error)\n}\n\n// Provider implementations\ntype AWSEnvironment struct { /* AWS-specific implementation */ }\ntype AzureEnvironment struct { /* Azure-specific implementation */ }\ntype KubernetesEnvironment struct { /* K8s-specific implementation */ }\ntype OnPremEnvironment struct { /* On-premises implementation */ }\n```\n\n**Cross-Environment Experiment Example:**\n```yaml\nexperiment:\n  name: \"cross-cloud-region-failure\"\n  hypothesis: \"Services failover correctly when primary cloud region becomes unavailable\"\n  environments:\n    - provider: aws\n      region: us-east-1\n      role: primary\n    - provider: aws  \n      region: us-west-2\n      role: secondary\n    - provider: on-prem\n      location: datacenter-a\n      role: backup\n  faults:\n    - type: NETWORK_PARTITION\n      target: \n        environment: aws\n        region: us-east-1\n      parameters:\n        isolation: complete\n```\n\n#### Extended Fault Injection Library\n**Description:** Expansion of fault types beyond the core set to include application-level faults, database corruption, message queue delays, and stateful service failures.\n\n**Architectural Impact:**\n- **Extended `FaultType` Enum:** Additional fault type constants\n- **Specialized Fault Injectors:** Application-aware injection mechanisms\n- **Stateful Fault Patterns:** Faults that maintain state across injection cycles\n- **Application Instrumentation:** Lightweight agents or library integrations for deep fault injection\n\n**New Fault Categories:**\n| Category | Example Faults | Injection Method | Use Case |\n|----------|----------------|------------------|----------|\n| **Database Faults** | Query latency, transaction failure, data corruption, connection pool exhaustion | Database driver proxy, stored procedures, direct DB manipulation | Testing database failover and query resilience |\n| **Message Queue Faults** | Message loss, duplicate delivery, out-of-order delivery, consumer lag | Queue proxy, consumer instrumentation, broker configuration | Testing event-driven architecture reliability |\n| **Stateful Service Faults** | State corruption, rollback failure, snapshot corruption, leader election issues | Service-specific instrumentation, state manipulation | Testing state management and recovery mechanisms |\n| **External Dependency Faults** | Third-party API failures, payment gateway timeouts, geolocation service errors | HTTP proxy, DNS manipulation, mock service injection | Testing circuit breakers and fallback mechanisms |\n| **Security Faults** | TLS certificate expiration, authentication service failure, authorization misconfiguration | Security middleware instrumentation | Testing security incident response |\n\n**Fault Library Extension Pattern:**\n```go\n// Fault type registry pattern for extensibility\nvar faultRegistry = map[FaultType]FaultInjector{\n    FAULT_TYPE_LATENCY:         &NetworkLatencyInjector{},\n    FAULT_TYPE_PACKET_LOSS:     &PacketLossInjector{},\n    FAULT_TYPE_DB_CORRUPTION:   &DatabaseCorruptionInjector{},  // New\n    FAULT_TYPE_MQ_REORDERING:   &MessageQueueReorderingInjector{}, // New\n    // Additional fault types can be registered at runtime\n}\n\n// Runtime registration allows third-party extensions\nfunc RegisterFaultType(faultType FaultType, injector FaultInjector) {\n    faultRegistry[faultType] = injector\n}\n```\n\n#### Compliance and Audit Logging\n**Description:** Comprehensive audit trails, compliance reporting, and regulatory evidence collection for chaos engineering activities in regulated industries.\n\n**Architectural Impact:**\n- **Enhanced Event System:** Immutable event logging with cryptographic signing\n- **Audit Report Generation:** Compliance-ready documentation of experiments\n- **Access Control Integration:** Role-based experiment authorization\n- **Change Approval Workflows:** Formal approval chains for production experiments\n\n**Compliance Framework Integration:**\n```\nChaos Platform → [Compliance Adapter] → Regulatory Framework\n      ↓                   ↓                   ↓\n  Experiments      Evidence Mapping      Audit Reports\n      ↓                   ↓                   ↓\n  [Execute] → [Collect Metrics] → [Generate Evidence] → [Sign & Store]\n```\n\n**Audit Log Requirements:**\n| Requirement | Implementation Approach | Retention Period |\n|-------------|------------------------|------------------|\n| **Non-Repudiation** | Cryptographic signing of experiment records | 7+ years |\n| **Tamper Evidence** | Append-only WAL with hash chain | 7+ years |\n| **Access Logging** | All API calls logged with user context | 2+ years |\n| **Change Tracking** | Versioned experiment definitions | Indefinite |\n| **Decision Audit** | Approval/rejection records with reasoning | 7+ years |\n\n**Regulatory Mapping Example:**\n```yaml\ncompliance_mapping:\n  framework: \"SOC2\"\n  controls:\n    - control: \"CC6.1\"\n      evidence_source: \"experiment_results\"\n      validation: \"Automated resilience testing proves logical access controls\"\n    - control: \"CC7.1\"  \n      evidence_source: \"system_change_logs\"\n      validation: \"Chaos experiments validate change management procedures\"\n      \n  framework: \"HIPAA\"\n  controls:\n    - control: \"164.308(a)(7)\"\n      evidence_source: \"disaster_recovery_tests\"\n      validation: \"Chaos experiments simulate disaster scenarios and validate recovery\"\n```\n\n#### Real-time Collaboration and Observer Tools\n**Description:** Collaborative features for GameDays including real-time chat, shared observations, incident simulation interfaces, and coordinated response workflows.\n\n**Architectural Impact:**\n- **Collaboration Server:** Real-time communication backend (WebSocket)\n- **Shared State Management:** Synchronized experiment views across multiple observers\n- **Incident Simulation Interface:** Mock incident management system integration\n- **Runbook Execution Tracking:** Collaborative runbook progress tracking\n\n**Collaboration Architecture:**\n```\n          [Web UI Clients]\n                ↓\n    [WebSocket Connection Pool]\n                ↓\n    [Collaboration Server]\n         ↓              ↓\n[State Sync]    [Message Broker]\n     ↓              ↓\n[Orchestrator]  [Observation Store]\n```\n\n**Collaboration Features:**\n1. **Real-time Experiment Dashboard:** All observers see the same experiment status, metrics, and safety events\n2. **Collaborative Observations:** Team members can add observations that are visible to all participants\n3. **Incident Simulation Console:** Mock incident creation and assignment to simulate real response workflows\n4. **Runbook Task Assignment:** Tasks can be assigned to specific team members with due dates\n5. **Post-GameDay Debrief Tools:** Structured retrospective templates and action item tracking\n\n**Example Collaboration Workflow:**\n1. GameDay starts → All participants join the collaborative session\n2. Orchestrator begins experiment → Real-time metrics displayed to all\n3. Safety threshold breached → Alert sent to all participants simultaneously\n4. Incident simulation triggered → Mock incident ticket created in simulated system\n5. Team members collaborate on response → Chat, task assignments, observations\n6. GameDay completes → Automated report generation with all collaborative inputs\n\n#### Predictive Resilience Analytics\n**Description:** Advanced analytics that predict system resilience based on historical experiment data, identify resilience degradation trends, and recommend remediation actions.\n\n**Architectural Impact:**\n- **Analytics Engine:** Time-series analysis and machine learning component\n- **Resilience Score Model:** Mathematical model quantifying system resilience\n- **Trend Analysis:** Detection of resilience degradation over time\n- **Remediation Recommender:** Actionable recommendations to improve resilience\n\n**Resilience Analytics Pipeline:**\n```\nHistorical Data → Feature Extraction → Model Training → Prediction\n     ↓                ↓                  ↓              ↓\nExperiment   Metric Patterns  Resilience  Future\nResults      Failure Modes    Score Model Resilience\n                                  ↓\n                           [Recommendations]\n```\n\n**Analytics Capabilities:**\n| Capability | Description | Output Example |\n|------------|-------------|----------------|\n| **Resilience Score** | Quantitative measure of system resilience (0-100) | \"Resilience score: 78/100\" |\n| **Degradation Detection** | Identify declining resilience before incidents occur | \"Resilience trend: -5% over last 30 days\" |\n| **Weakest Link Identification** | Pinpoint services/components with lowest resilience | \"Weakest link: PaymentService (resilience: 45/100)\" |\n| **Remediation ROI Analysis** | Prioritize fixes based on expected resilience improvement | \"Fix database connection pooling: +15 resilience points\" |\n| **Capacity Planning Insights** | Resilience implications of scaling decisions | \"Adding 2 more instances improves resilience by 8 points\" |\n\n**Implementation Approach:**\n1. **Data Collection Phase:** Aggregate historical experiment results, system metrics, and incident data\n2. **Feature Engineering Phase:** Extract resilience-relevant features (failure recovery time, error rate impact, cascade patterns)\n3. **Model Training Phase:** Train supervised ML models to predict experiment outcomes\n4. **Inference Phase:** Apply models to current system state to generate resilience insights\n5. **Recommendation Phase:** Map resilience gaps to specific architectural or operational improvements\n\n### Implementation Guidance\n\n#### Technology Recommendations for Extensions\n\n| Extension Area | Simple Option (Quick Start) | Advanced Option (Enterprise Scale) |\n|----------------|-----------------------------|-----------------------------------|\n| **Visual UI** | React SPA + Go HTTP server | Next.js SSR + GraphQL API + OAuth2 |\n| **CI/CD Integration** | Webhook handlers + status API | Dedicated CI/CD plugin ecosystem |\n| **AI Scenario Generation** | Rule-based heuristic engine | TensorFlow/PyTorch ML models + feature store |\n| **Multi-Cloud Support** | Provider-specific adapters | Cross-cloud abstraction layer + Terraform integration |\n| **Compliance Logging** | Structured logging + external analysis | Integrated compliance engine + blockchain immutability |\n\n#### Recommended File Structure for Extensions\n\n```\nchaos-platform/\n├── cmd/\n│   ├── chaos-server/          # Main orchestrator\n│   ├── chaos-ui/              # Web UI server (NEW)\n│   └── chaos-analytics/       # Analytics engine (NEW)\n├── internal/\n│   ├── extensions/            # Extension framework\n│   │   ├── registry.go        # Extension point registry\n│   │   └── lifecycle.go       # Extension lifecycle management\n│   ├── ui/                    # Web UI backend (NEW)\n│   │   ├── server.go\n│   │   ├── handlers/\n│   │   └── static/            # SPA build assets\n│   ├── analytics/             # Resilience analytics (NEW)\n│   │   ├── engine.go\n│   │   ├── models/\n│   │   └── predictors/\n│   ├── integrations/          # External system integrations\n│   │   ├── ci/\n│   │   │   ├── github.go\n│   │   │   ├── gitlab.go\n│   │   │   └── jenkins.go\n│   │   ├── cloud/\n│   │   │   ├── aws.go\n│   │   │   ├── azure.go\n│   │   │   └── gcp.go\n│   │   └── compliance/\n│   │       ├── soc2.go\n│   │       └── hipaa.go\n│   └── collaboration/         # Real-time collaboration (NEW)\n│       ├── server.go\n│       ├── rooms.go\n│       └── events.go\n└── pkg/\n    └── extensions/            # Public extension API\n        ├── types.go\n        └── interfaces.go\n```\n\n#### Extension Point Skeleton Code\n\n```go\n// pkg/extensions/interfaces.go\n// Extension point interfaces for third-party developers\n\n// ExperimentGenerator generates experiment scenarios\ntype ExperimentGenerator interface {\n    // Generate generates experiment scenarios based on system analysis\n    Generate(ctx context.Context, systemInfo SystemInfo) ([]types.Experiment, error)\n    \n    // Name returns the generator's display name\n    Name() string\n    \n    // Version returns the generator version\n    Version() string\n}\n\n// FaultInjectorPlugin extends fault injection capabilities\ntype FaultInjectorPlugin interface {\n    // FaultType returns the fault type this plugin handles\n    FaultType() types.FaultType\n    \n    // Inject applies the fault to the target\n    Inject(ctx context.Context, fault types.Fault, target types.Target) (string, error)\n    \n    // Cleanup removes the fault\n    Cleanup(ctx context.Context, faultID string) error\n    \n    // Validate checks if the fault definition is valid\n    Validate(fault types.Fault) []error\n}\n\n// MetricsAnalyzer provides advanced metric analysis\ntype MetricsAnalyzer interface {\n    // AnalyzeTrends analyzes metric trends for resilience insights\n    AnalyzeTrends(ctx context.Context, \n                  metrics []types.MetricPoint, \n                  baseline map[string]float64) (*ResilienceReport, error)\n    \n    // PredictImpact predicts the impact of a fault on metrics\n    PredictImpact(ctx context.Context, \n                  fault types.Fault, \n                  currentMetrics map[string]float64) (map[string]PredictedImpact, error)\n}\n\n// pkg/extensions/registry.go\n// Extension registry for runtime registration\n\nvar (\n    experimentGenerators = make(map[string]ExperimentGenerator)\n    faultInjectorPlugins = make(map[types.FaultType]FaultInjectorPlugin)\n    metricsAnalyzers     = make(map[string]MetricsAnalyzer)\n)\n\n// RegisterExperimentGenerator registers a new experiment generator\nfunc RegisterExperimentGenerator(generator ExperimentGenerator) error {\n    // TODO 1: Check if generator with same name already registered\n    // TODO 2: Validate generator interface implementation\n    // TODO 3: Add to experimentGenerators map\n    // TODO 4: Log registration for audit purposes\n    return nil\n}\n\n// RegisterFaultInjectorPlugin registers a new fault injector plugin\nfunc RegisterFaultInjectorPlugin(plugin FaultInjectorPlugin) error {\n    // TODO 1: Check if plugin for this fault type already registered\n    // TODO 2: Validate plugin interface implementation\n    // TODO 3: Add to faultInjectorPlugins map\n    // TODO 4: Update fault type registry in main orchestrator\n    return nil\n}\n\n// GetExperimentGenerators returns all registered experiment generators\nfunc GetExperimentGenerators() []ExperimentGenerator {\n    // TODO 1: Convert map values to slice\n    // TODO 2: Sort by name for consistent ordering\n    return nil\n}\n```\n\n#### CI/CD Integration Starter Code\n\n```go\n// internal/integrations/ci/github.go\n// GitHub Actions integration\n\ntype GitHubIntegration struct {\n    client    *github.Client\n    owner     string\n    repo      string\n    webhookSecret string\n}\n\n// NewGitHubIntegration creates a new GitHub integration\nfunc NewGitHubIntegration(token, owner, repo string) (*GitHubIntegration, error) {\n    // TODO 1: Create GitHub client with authentication\n    // TODO 2: Validate repository access\n    // TODO 3: Set up webhook if not already present\n    return nil, nil\n}\n\n// CreateCheckRun creates a GitHub check run for an experiment\nfunc (g *GitHubIntegration) CreateCheckRun(ctx context.Context, \n                                          experiment types.Experiment,\n                                          sha string) (string, error) {\n    // TODO 1: Create check run with \"in_progress\" status\n    // TODO 2: Include experiment details in output\n    // TODO 3: Return check run ID for updates\n    return \"\", nil\n}\n\n// UpdateCheckRun updates a GitHub check run with experiment results\nfunc (g *GitHubIntegration) UpdateCheckRun(ctx context.Context,\n                                          checkRunID string,\n                                          result types.ExperimentResult) error {\n    // TODO 1: Determine check run conclusion from experiment result\n    // TODO 2: Format detailed output with metrics and observations\n    // TODO 3: Update check run with conclusion and output\n    // TODO 4: Add annotations for failed safety rules if applicable\n    return nil\n}\n\n// HandleWebhook handles GitHub webhook events\nfunc (g *GitHubIntegration) HandleWebhook(payload []byte, signature string) error {\n    // TODO 1: Validate webhook signature\n    // TODO 2: Parse webhook event type\n    // TODO 3: Handle pull_request events for CI integration\n    // TODO 4: Handle check_suite events for experiment status updates\n    return nil\n}\n```\n\n#### Visual UI API Endpoint Skeleton\n\n```go\n// internal/ui/handlers/experiments.go\n// Web UI API handlers for experiments\n\n// ListExperimentsHandler returns experiments for UI display\nfunc ListExperimentsHandler(w http.ResponseWriter, r *http.Request) {\n    // TODO 1: Parse query parameters (filter, pagination)\n    // TODO 2: Call orchestrator.ListExperiments with filter\n    // TODO 3: Transform results for UI consumption\n    // TODO 4: Return JSON response with pagination metadata\n}\n\n// ExperimentStreamHandler streams real-time experiment updates\nfunc ExperimentStreamHandler(w http.ResponseWriter, r *http.Request) {\n    // TODO 1: Set up Server-Sent Events (SSE) headers\n    // TODO 2: Subscribe to experiment events via pub/sub\n    // TODO 3: Stream events as they occur\n    // TODO 4: Handle client disconnection cleanup\n}\n\n// CreateExperimentHandler creates a new experiment via UI\nfunc CreateExperimentHandler(w http.ResponseWriter, r *http.Request) {\n    // TODO 1: Parse and validate experiment JSON from request\n    // TODO 2: Apply UI-specific defaults (e.g., safety rules)\n    // TODO 3: Call orchestrator.CreateExperiment\n    // TODO 4: Return created experiment with ID\n}\n```\n\n#### Language-Specific Hints for Extensions\n\n**Go-Specific Implementation Tips:**\n\n1. **Extension Discovery:** Use `go/build` package to discover plugins in a plugins directory\n2. **Hot Reloading:** Implement `fsnotify` to watch for plugin changes in development\n3. **UI Development:** Consider `embed` package for bundling React build artifacts\n4. **Real-time Updates:** Use `gorilla/websocket` for WebSocket connections or Server-Sent Events\n5. **ML Integration:** Use `cgo` to call Python ML libraries or `gorgonia` for Go-native ML\n\n**Performance Considerations:**\n\n```go\n// For real-time collaboration, consider connection pooling\ntype ConnectionPool struct {\n    mu          sync.RWMutex\n    connections map[string][]*websocket.Conn\n    // TODO: Implement connection lifecycle management\n    // TODO: Implement message broadcasting with connection health checks\n}\n\n// For analytics processing, consider batch processing\ntype AnalyticsBatchProcessor struct {\n    batchSize   int\n    batchWindow time.Duration\n    processor   func([]AnalyticsEvent) error\n    // TODO: Implement batching with flush on size or timeout\n    // TODO: Implement retry logic for failed batches\n}\n```\n\n#### Milestone Checkpoint for Extensions\n\n**Extension Development Verification Steps:**\n\n1. **Visual UI Checkpoint:**\n   ```\n   # Start UI server\n   go run cmd/chaos-ui/main.go --port=8080\n   \n   # Expected: Web UI accessible at http://localhost:8080\n   # Verify: Experiment list loads, real-time updates work, can create new experiment\n   ```\n\n2. **CI/CD Integration Checkpoint:**\n   ```\n   # Simulate GitHub webhook\n   curl -X POST http://localhost:8080/api/webhooks/github \\\n        -H \"X-GitHub-Event: pull_request\" \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\"action\":\"opened\",\"pull_request\":{\"head\":{\"sha\":\"abc123\"}}}'\n   \n   # Expected: Experiment automatically created for PR validation\n   # Verify: Check run appears in GitHub UI with experiment status\n   ```\n\n3. **AI Scenario Generation Checkpoint:**\n   ```\n   # Generate scenarios from service graph\n   curl -X POST http://localhost:8080/api/scenarios/generate \\\n        -H \"Content-Type: application/json\" \\\n        -d '{\"service_graph\":\"dependency-graph.json\"}'\n   \n   # Expected: JSON array of generated scenario definitions\n   # Verify: Scenarios target critical paths and include realistic fault combinations\n   ```\n\n#### Debugging Tips for Extensions\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **UI shows \"Loading...\" indefinitely** | CORS configuration missing | Check browser console for CORS errors | Add proper CORS headers to API endpoints |\n| **CI/CD webhooks not triggering experiments** | Webhook signature validation failing | Check webhook logs for validation errors | Ensure webhook secret matches between systems |\n| **AI-generated scenarios are unrealistic** | Insufficient training data | Check scenario generator logs for data warnings | Add more historical incident data to training set |\n| **Real-time collaboration messages delayed** | WebSocket connection pooling bottleneck | Monitor connection pool metrics and goroutine count | Implement connection pruning and load balancing |\n| **Multi-cloud experiments fail on specific provider** | Provider API rate limiting | Check provider API response headers for rate limits | Implement exponential backoff and request queuing |\n\n---\n\n\n> **Milestone(s):** All milestones (cross-cutting terminology that appears throughout the document)\n\n## Glossary\n\n### Term Definitions\n\nThis glossary defines key terms, concepts, and mental models used throughout the Chaos Engineering Platform design document. Each term includes a clear definition and references the section where it first appears in the document.\n\n| Term | Definition | First Appearance |\n|------|------------|------------------|\n| **Air Traffic Control Tower** | Mental model for the platform's coordination system, where the **Orchestrator** acts as the tower coordinating multiple \"flights\" (experiments) simultaneously. Each component has aviation-themed analogies: flight plans (experiments), clearance delivery (validation), ground control (fault injection), and tower control (safety monitoring). | Interactions and Data Flow |\n| **Append-Only WAL** | A **write-ahead log** implementation that only allows appending new records, never modifying or deleting existing ones. This property ensures audit trails cannot be tampered with after the fact, which is crucial for forensic analysis of chaos experiments. | Component Design: Fault Injection Framework |\n| **Auto-Rollback** | The automatic reversal of injected faults when safety thresholds are breached during an experiment. This prevents experiment-induced failures from escalating into actual outages. Auto-rollback can be triggered by time-based expiration or condition-based safety rule violations. | Component Design: Experiment Orchestration Engine |\n| **Blast Radius** | A scope limitation mechanism for chaos experiments that constrains the impact to a specific percentage of traffic, set of services, or namespaces. The **BlastRadius** struct defines these boundaries to ensure experiments don't cascade into unintended system-wide failures. | Data Model |\n| **CAP_NET_ADMIN** | A Linux capability required for network configuration operations like modifying traffic control (tc) rules and iptables. The fault injection framework needs this elevated permission when running network chaos experiments, which affects deployment architecture decisions. | Component Design: Fault Injection Framework |\n| **Chaos Engineering** | The practice of intentionally injecting failures into distributed systems to proactively test resilience, identify weaknesses, and build confidence that production systems can withstand unexpected turbulent conditions. | Goals and Non-Goals |\n| **Chaos Maturity Progression** | The evolutionary path of chaos engineering practices from manual, ad-hoc experiments to scheduled **GameDays** to continuous, automated resilience validation integrated into deployment pipelines. The platform supports all stages of this progression. | Future Extensions |\n| **Circuit Breaker** | A resilience pattern that monitors for failures in dependent services and fails fast when a threshold is exceeded, preventing cascading failures. The **SafetyMonitor** implements a similar pattern to automatically abort experiments when safety rules are breached. | Component Design: Experiment Orchestration Engine |\n| **Cleanup Ensurer** | A mechanism guaranteeing fault reversal even after platform crashes or network partitions. The **CleanupEnsurer** struct combines a **write-ahead log** with periodic health checks to ensure no orphaned faults remain active after experiments complete or abort. | Component Design: Fault Injection Framework |\n| **Command-and-Control Architecture** | The architectural pattern where a central coordinator (the **Orchestrator**) issues commands to distributed agents (fault injectors) while maintaining full visibility and control over the entire system. This contrasts with decentralized peer-to-peer architectures. | High-Level Architecture |\n| **Cgo** | The Go language mechanism for calling C code, used in the fault injection framework to interface with Linux system calls for network configuration (**tc** commands) and process management that require capabilities not available through pure Go libraries. | Implementation Guidance (Fault Injection Framework) |\n| **Clearance Delivery** | Aviation analogy for the **Orchestrator**'s validation phase, where experiments undergo pre-flight checks including hypothesis validation, resource availability verification, and safety rule review before receiving approval to proceed to execution. | Interactions and Data Flow |\n| **Cryptographic Signing** | Using digital signatures to ensure authenticity and non-repudiation of experiment definitions, execution records, and results. This prevents unauthorized modification of experiment parameters and creates a verifiable audit trail for compliance. | Future Extensions |\n| **Dead Man's Switch** | A safety mechanism that triggers automatically when a heartbeat stops. The **SafetyMonitor** implements a variant where if the metrics collection heartbeat stops, the system assumes something is wrong and triggers automatic rollback of all active faults. | Component Design: Experiment Orchestration Engine |\n| **Exponential Backoff** | A retry strategy with increasing delay between attempts, used by the **Client** struct for resilient RPC communication between platform components. The delay grows exponentially (e.g., 1s, 2s, 4s, 8s) to avoid overwhelming recovering services. | Error Handling and Edge Cases |\n| **Experiment** | A controlled scientific test that formulates a **steady-state hypothesis**, injects one or more **faults** within a defined **blast radius**, monitors system behavior, and analyzes results. Represented by the **Experiment** struct containing hypothesis, faults, schedule, and safety rules. | Data Model |\n| **Fault Injection** | The controlled introduction of failures into a system to test its resilience. The platform supports multiple fault types including latency, packet loss, process termination, and resource exhaustion, each implemented by the **FaultInjector** component. | Component Design: Fault Injection Framework |\n| **Feature Engineering** | The process of transforming raw metric data into meaningful features for machine learning models. In the context of resilience analytics, this involves calculating derived metrics like error rate trends, recovery time patterns, and correlation coefficients between services. | Future Extensions |\n| **Flight Plans** | Aviation analogy for **experiment definitions**, which specify the intended route (hypothesis), expected conditions (steady state), potential turbulence (faults), and emergency procedures (safety rules) before the \"flight\" (experiment execution) begins. | Interactions and Data Flow |\n| **Flight Recorders** | Aviation analogy for the **ResultAnalyzer** component, which captures comprehensive telemetry during experiments for post-mortem analysis. Like black boxes in aircraft, these records help reconstruct what happened during chaotic conditions. | Interactions and Data Flow |\n| **GameDay** | An orchestrated event running multiple chaos experiments in sequence with integrated runbooks, observer briefings, and incident response practice. Represented by the **Scenario** struct containing sequential steps, approval gates, and safety overrides. | Component Design: GameDay Automation |\n| **Ground Control** | Aviation analogy for the **FaultInjector** component, which manages the \"ground operations\" of actually applying and removing faults in the target systems. Ground control executes commands from the tower but has local autonomy for technical implementation. | Interactions and Data Flow |\n| **Hash Chain** | A linked sequence of cryptographic hashes where each record includes the hash of the previous record, creating a tamper-evident audit trail. Used in the **WAL** implementation to detect unauthorized modifications to experiment execution logs. | Future Extensions |\n| **Idempotent Operations** | Operations that can be applied multiple times without changing the result beyond the initial application. All fault injection and cleanup methods are designed to be idempotent, ensuring safe retries after network failures or partial executions. | Error Handling and Edge Cases |\n| **Inject (Event)** | A simulated external event during a **GameDay** to increase realism, such as a notification about a concurrent deployment or a simulated customer complaint. Represented by the **InjectMessage** field in **ScenarioStep** to trigger observer response testing. | Component Design: GameDay Automation |\n| **Metrics Collector** | Component responsible for gathering time-series metrics from monitoring systems (Prometheus, Datadog, etc.) to establish baselines, monitor during experiments, and validate **steady-state hypotheses**. Provides the **GetMetric** and **GetCurrentValue** methods. | High-Level Architecture |\n| **Orchestrator** | The central coordination component that manages the complete lifecycle of chaos experiments. The **Orchestrator** struct maintains experiment state machines, coordinates fault injection, monitors safety rules, and generates results. | Component Design: Experiment Orchestration Engine |\n| **Property-Based Testing** | Testing method that verifies properties hold for all generated inputs rather than specific examples. Used to test the chaos platform itself, with properties like \"faults must always be reversible\" and \"cleanup must be idempotent.\" | Testing Strategy |\n| **Resilience Score** | A quantitative measure of system resilience calculated from historical experiment results, failure recovery times, and dependency health. The score provides a single metric for tracking resilience improvements over time and comparing different services. | Future Extensions |\n| **Runbook** | A predefined set of instructions for responding to an incident, integrated into **GameDay** scenarios to practice operational procedures. The **RunbookTask** struct represents manual steps that observers must execute during scenario execution. | Component Design: GameDay Automation |\n| **Safety Monitor** | Component that continuously watches system metrics during experiments and triggers **auto-rollback** when safety thresholds are breached. Implements the **CheckSafetyRules** method to evaluate metric conditions and duration requirements. | High-Level Architecture |\n| **Scenario** | A sequenced collection of experiments, manual tasks, pauses, and inject events that comprise a **GameDay**. The **Scenario** struct contains steps, observer briefing materials, scheduling information, and optional safety rule overrides. | Component Design: GameDay Automation |\n| **Server-Sent Events (SSE)** | Technology for server-to-client real-time updates over HTTP, used in the web interface to stream experiment status changes, metric updates, and safety alerts to observers during active **GameDays**. | Future Extensions |\n| **Shadow Integration** | Using a dedicated test environment within production tooling (like creating a shadow incident in PagerDuty or a test Slack channel) for simulations without triggering actual alerts or notifications to production on-call personnel. | Component Design: GameDay Automation |\n| **Shift-Left Resilience Testing** | The practice of testing resilience earlier in the development lifecycle, integrating chaos experiments into CI/CD pipelines to catch resilience issues before they reach production. | Future Extensions |\n| **Sidecar Agent Model** | Architecture pattern where a helper component (the fault injector agent) runs alongside each service instance, typically in the same pod or container. This contrasts with the proxy-based approach where traffic flows through a central interceptor. | Component Design: Fault Injection Framework |\n| **Steady-State Hypothesis** | The expected system behavior expressed as metric thresholds that should hold true before, during, and after fault injection. The **Hypothesis** struct defines these expectations, which are validated by the **HypothesisValidator**. | Data Model |\n| **Test Double** | Test substitute for a real component (mock, stub, fake) used in platform testing. The testing strategy employs test doubles for metrics collectors, fault injectors, and external dependencies to enable deterministic testing of chaos scenarios. | Testing Strategy |\n| **Tower Control** | Aviation analogy for the **SafetyMonitor** component, which watches all active \"flights\" (experiments) for signs of trouble and issues abort commands when safety boundaries are breached, similar to air traffic controllers monitoring aircraft separation. | Interactions and Data Flow |\n| **WebSocket** | Protocol for full-duplex communication over TCP, used in the real-time dashboard for bidirectional communication between the UI and backend, allowing observers to send commands (pause, approve steps) and receive live updates. | Future Extensions |\n| **Write-Ahead Log (WAL)** | A durable log where changes are recorded before being applied to the system. The **CleanupEnsurer** uses a WAL to record fault injection commands, ensuring they can be replayed for cleanup even after a crash or power loss. | Component Design: Fault Injection Framework |\n\n> **Key Insight**: Consistent terminology is essential for a chaos engineering platform because miscommunication during active experiments could lead to real outages. The aviation-inspired mental models (air traffic control, flight plans, etc.) provide intuitive frameworks for teams to understand component responsibilities and interaction patterns, especially during high-stress **GameDay** scenarios.\n\n---\n"}