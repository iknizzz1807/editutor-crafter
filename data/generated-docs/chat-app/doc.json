{"html":"<h1 id=\"real-time-chat-application-design-document\">Real-time Chat Application: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This document outlines the architecture for a real-time chat application using WebSockets. It solves the key architectural challenge of maintaining persistent, bi-directional communication channels between a server and multiple web clients, enabling instant message delivery, user presence, and conversation history. The design balances simplicity for learning with scalable patterns used in production systems.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This foundational context applies to all milestones, establishing the core communication paradigm and technical challenges the entire system must address.</p>\n</blockquote>\n<p>At the heart of any real-time chat application lies a fundamental challenge: how can a web server instantly notify connected clients when something happens—like a new message being sent—without waiting for the client to ask first? This section explores this challenge by contrasting the traditional request-response model of the web with the persistent, bi-directional connection model of WebSockets. We will establish the mental models, define the core technical problems of managing stateful connections at scale, and evaluate the trade-offs between different real-time communication approaches.</p>\n<h3 id=\"mental-model-the-telephone-vs-the-mailbox\">Mental Model: The Telephone vs. The Mailbox</h3>\n<p>To understand the shift required for real-time communication, consider two everyday communication systems:</p>\n<ol>\n<li><p><strong>The Mailbox (HTTP Request-Response):</strong> Imagine you want to know if your friend has sent you a letter. Under the Hypertext Transfer Protocol (HTTP) that powers most of the web, you must walk to your mailbox, open it, and check for new letters. If there&#39;s nothing, you close it and return to your house. To get the next update, you must walk back to the mailbox and check again. This is the <strong>polling</strong> model: the client (you) must repeatedly initiate a request to the server (the mailbox) to ask for new data. The server cannot proactively deliver information; it can only respond when asked. This is efficient for infrequent updates but becomes wasteful and slow when you need to know the instant a letter arrives. You would be making constant, unnecessary trips to the mailbox.</p>\n</li>\n<li><p><strong>The Telephone Call (WebSocket Persistent Connection):</strong> Now, imagine you and your friend have an open telephone line. Once the call is connected, either of you can speak at any time. When your friend has something to say, they just say it, and you hear it immediately. There&#39;s no need for you to repeatedly ask, &quot;Do you have anything new to say?&quot; This is the <strong>WebSocket</strong> model: after an initial handshake (dialing the number), a persistent, two-way communication channel is established. The server can &quot;push&quot; data to the client the moment it becomes available, and the client can send data to the server just as freely. This enables true real-time interactivity but comes with the overhead of maintaining an open connection for each client.</p>\n</li>\n</ol>\n<p>This mental model highlights the paradigm shift. Traditional web development is built around stateless, transactional interactions (the mailbox). Real-time chat requires a stateful, session-oriented, and continuous flow of information (the telephone call). Our design must therefore manage not just individual requests, but long-lived <strong>connections</strong> that become first-class citizens in our system&#39;s architecture.</p>\n<h3 id=\"the-core-problem-stateful-connections-at-scale\">The Core Problem: Stateful Connections at Scale</h3>\n<p>Building a system that maintains a &quot;telephone call&quot; with every user introduces a set of interconnected technical hurdles that define the core problem space for our chat application.</p>\n<ol>\n<li><p><strong>Managing Thousands of Concurrent, Stateful Connections:</strong> Unlike a stateless HTTP request that is processed and forgotten, each WebSocket connection is a long-lived object in server memory. It holds resources like file descriptors, buffers, and—critically—application state (e.g., which user it represents, which room they are in). The server must track all active connections, associate them with users, and efficiently route messages to the correct subset. As user count grows, the management overhead (memory, CPU for housekeeping) grows linearly. The system must be designed to handle this growth gracefully, typically using efficient data structures (like <code>Map</code>s keyed by user ID) and non-blocking, event-driven I/O.</p>\n</li>\n<li><p><strong>Handling Disconnections Gracefully and Reliably:</strong> Network connections are inherently unreliable. A user&#39;s Wi-Fi may drop, their laptop may go to sleep, or they may close the browser tab. The server must detect when a connection is lost and perform necessary cleanup: removing the user from room member lists, broadcasting &quot;user left&quot; notifications, and freeing up allocated resources. Failure to do so creates <strong>&quot;ghost users&quot;</strong> (users who appear online but aren&#39;t) and memory leaks. This requires implementing a <strong>connection lifecycle</strong> with explicit events (<code>connect</code>, <code>disconnect</code>, <code>error</code>) and often a <strong>heartbeat</strong> mechanism (periodic ping/pong messages) to distinguish a slow connection from a dead one.</p>\n</li>\n<li><p><strong>Synchronizing State Across Clients in Real-Time:</strong> When User A sends a message to &quot;General&quot; room, all other users in that room must see it nearly simultaneously. This is a state synchronization problem. The server acts as the single source of truth. It must:</p>\n<ul>\n<li><strong>Receive</strong> the message from User A&#39;s connection.</li>\n<li><strong>Validate &amp; Persist</strong> it (check permissions, store to database if required).</li>\n<li><strong>Determine Recipients</strong> (find all connections currently in the &quot;General&quot; room, excluding User A).</li>\n<li><strong>Transmit</strong> the message to each recipient&#39;s connection.\nAny delay or failure in this pipeline breaks the illusion of a shared, synchronous space. The design must ensure this pipeline is fast, atomic where needed (e.g., persisting before broadcasting to ensure no message is lost if the server crashes mid-send), and resilient to partial failures of individual clients.</li>\n</ul>\n</li>\n<li><p><strong>Securing a Long-Lived, Bi-Directional Channel:</strong> An open connection is a larger attack surface than a series of short requests. The server must authenticate the user when the connection is established (or very soon after) and then authorize every subsequent action (e.g., &quot;can this user post to this room?&quot;). This is distinct from HTTP, where each request can carry authentication headers. We must also guard against abuse via the persistent channel, such as a malicious client flooding the server with high-volume messages.</p>\n</li>\n</ol>\n<blockquote>\n<p>The critical insight is that a WebSocket server is fundamentally a <strong>stateful message router</strong>. It maintains a live mapping of <code>{User Identity -&gt; Network Connection -&gt; Room Membership}</code> and uses this map to fan out messages from any single point to many others. This is a different architectural pattern than the stateless request-processing of a typical REST API.</p>\n</blockquote>\n<h3 id=\"existing-approaches-and-trade-offs\">Existing Approaches and Trade-offs</h3>\n<p>Before settling on WebSockets, it&#39;s essential to understand the landscape of techniques for achieving real-time communication on the web. Each has different capabilities, browser support, and trade-offs. The following table compares the most common approaches.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Approach</th>\n<th align=\"left\">How It Works</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Naive Polling</strong></td>\n<td align=\"left\">Client repeatedly sends HTTP requests (e.g., every 2 seconds) asking &quot;Any new messages?&quot;</td>\n<td align=\"left\">Extremely simple to implement. Works with any HTTP server.</td>\n<td align=\"left\">High latency (up to poll interval). High server/network overhead (many empty requests). Inefficient.</td>\n<td align=\"left\">Simple prototypes where real-time is not critical and load is negligible.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Long Polling</strong></td>\n<td align=\"left\">Client sends a request; server holds it open until new data is available or a timeout occurs. Client immediately re-connects after receiving a response.</td>\n<td align=\"left\">Reduces empty requests. Lower latency than naive polling. Still uses standard HTTP.</td>\n<td align=\"left\">Complex server-side connection management. Head-of-line blocking (a hanging request can delay others). Still has HTTP overhead per message.</td>\n<td align=\"left\">Systems where WebSockets are not available and moderate latency is acceptable.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Server-Sent Events (SSE)</strong></td>\n<td align=\"left\">Client opens a persistent HTTP connection; server can send &quot;events&quot; as text streams. <strong>One-way (server → client only)</strong>.</td>\n<td align=\"left\">Standardized, automatic reconnection. Simple protocol (plain text). Efficient for server-push scenarios.</td>\n<td align=\"left\"><strong>No bi-directional communication</strong> (client cannot send data over the same channel). Limited to text data. Not supported in older IE/Edge.</td>\n<td align=\"left\">Live news feeds, stock tickers, notifications—any update stream where the client only listens.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>WebSockets</strong></td>\n<td align=\"left\">Full-duplex, persistent connection established after an HTTP &quot;Upgrade&quot; handshake. Data flows both ways independently over the same TCP socket.</td>\n<td align=\"left\"><strong>True real-time, bi-directional communication</strong>. Low overhead per message (light framing, no HTTP headers). Efficient for high-frequency updates.</td>\n<td align=\"left\">More complex protocol to implement directly (though libraries abstract this). Requires stateful connection management on the server.</td>\n<td align=\"left\"><strong>Interactive applications: chat, collaborative editing, live gaming, trading terminals.</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Use WebSockets as the Core Transport</strong></p>\n<ul>\n<li><strong>Context</strong>: Our functional goal is a bi-directional, low-latency chat application where clients both send (messages, typing indicators) and receive (messages, presence updates) data in real-time.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Long Polling</strong>: Could simulate real-time but introduces higher latency and complexity in request handling.</li>\n<li><strong>Server-Sent Events (SSE)</strong>: Excellent for server-to-client push, but would require a separate channel (e.g., standard HTTP POST) for client-to-server messages, complicating the architecture.</li>\n<li><strong>WebSockets</strong>: Provides a single, unified, bi-directional channel ideal for conversational data flow.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement the real-time data plane using the WebSocket protocol.</li>\n<li><strong>Rationale</strong>: WebSockets are the industry standard for full-duplex web communication. They provide the lowest latency and most efficient use of network resources for our use case, where events flow constantly in both directions. While they require managing stateful connections, this complexity is inherent to the problem and is a valuable learning objective.</li>\n<li><strong>Consequences</strong>: We must implement a WebSocket server capable of handling the connection lifecycle, message framing, and error handling. We will rely on the <code>ws</code> library (for Node.js) to handle the low-level protocol details, allowing us to focus on the application logic.</li>\n</ul>\n</blockquote>\n<p>The choice of WebSockets sets the stage for our component design. In the following sections, we will decompose the problem of building a stateful message router into discrete, manageable components: the <strong>Connection Manager</strong> (Milestone 1), the <strong>Message Broker &amp; Room Manager</strong> (Milestones 2 &amp; 3), and the <strong>Persistence &amp; Authentication Service</strong> (Milestone 4).</p>\n<hr>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4). This section defines the fundamental requirements and constraints that guide the entire system&#39;s architecture and implementation, providing clear boundaries for what will and won&#39;t be built.</p>\n</blockquote>\n<h3 id=\"functional-goals-what-it-must-do\">Functional Goals (What it MUST do)</h3>\n<p>These are the core capabilities the system must deliver—the features users will directly interact with and depend upon. Think of these as the <strong>contract with the end user</strong>: if any of these are missing, the application fails to fulfill its basic purpose.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Description</th>\n<th>Why It Matters</th>\n<th>Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Real-time Messaging</strong></td>\n<td>Messages typed by one user must appear on other users&#39; screens with minimal perceptible delay (typically &lt; 200ms). This includes text content, sender identification, and accurate timestamps.</td>\n<td>This is the fundamental value proposition of a chat application. Without real-time delivery, it becomes email. The experience should feel immediate and conversational.</td>\n<td>2</td>\n</tr>\n<tr>\n<td><strong>Multiple Chat Rooms</strong></td>\n<td>Users must be able to create, join, and leave distinct conversation spaces (rooms/channels). Messages sent to a room must only be delivered to users currently in that room.</td>\n<td>This organizes conversations by topic, project, or team, preventing a single chaotic stream. It&#39;s a foundational pattern for scaling conversations beyond direct messaging.</td>\n<td>3</td>\n</tr>\n<tr>\n<td><strong>User Presence</strong></td>\n<td>The system must indicate which users are currently online/connected and which rooms they are actively participating in. Other users should see when someone joins or leaves a room or the entire application.</td>\n<td>Presence transforms a messaging tool from a passive mailbox into an active social space. It provides critical context about who is available for conversation.</td>\n<td>2, 4</td>\n</tr>\n<tr>\n<td><strong>Message History</strong></td>\n<td>When a user joins a room, they must see a configurable number of recent messages that were sent before they arrived. Messages must be persisted to survive server restarts.</td>\n<td>Conversation continuity is essential. Users shouldn&#39;t lose context when they reconnect, and need to catch up on what they missed.</td>\n<td>4</td>\n</tr>\n<tr>\n<td><strong>Typing Indicators</strong></td>\n<td>When a user begins composing a message, a visual indicator (e.g., &quot;Alice is typing...&quot;) must be broadcast to other users in the same room. The indicator must clear after a timeout or when the message is sent.</td>\n<td>This provides crucial feedback about the cadence of a conversation, reducing interruptions and signaling engagement.</td>\n<td>2</td>\n</tr>\n<tr>\n<td><strong>User Authentication</strong></td>\n<td>Users must provide credentials (username/password) to establish their identity before participating in chats. The server must validate this identity for each WebSocket connection.</td>\n<td>Authentication prevents impersonation, enables personalization, and is a prerequisite for proper message attribution and authorization.</td>\n<td>4</td>\n</tr>\n<tr>\n<td><strong>Connection Resilience</strong></td>\n<td>The application must automatically attempt to re-establish the WebSocket connection if it is dropped due to network instability. In-flight messages should be queued and delivered upon reconnection.</td>\n<td>Real-world networks are unreliable. A chat app that breaks on a spotty Wi-Fi signal is unusable. This goal is about graceful degradation.</td>\n<td>1, 2</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight:</strong> These functional goals are <strong>interdependent</strong>. Presence relies on real-time connections. Message history requires persistence. Room-based messaging necessitates user authentication for proper attribution. The architecture must be designed holistically to support these interactions.</p>\n</blockquote>\n<p><strong>Detailed Breakdown of Core Features:</strong></p>\n<ol>\n<li><p><strong>Real-time Messaging Protocol:</strong> Beyond simple delivery, the system must define a structured message format. Every message must include:</p>\n<ul>\n<li><code>sender</code>: The authenticated username of the originator.</li>\n<li><code>content</code>: The plain-text message body (with length limits).</li>\n<li><code>timestamp</code>: A server-assigned UTC timestamp (not client-provided, to prevent clock-skew issues).</li>\n<li><code>roomId</code>: The identifier of the destination room.\nThis structured data is the lifeblood of the system, flowing from client to server to other clients.</li>\n</ul>\n</li>\n<li><p><strong>Room Management Logic:</strong> The system must maintain a <strong>room directory</strong>. Key operations include:</p>\n<ul>\n<li><strong>Creation:</strong> A user can request a new room with a unique name. The server must sanitize the name (removing special characters) and check for conflicts.</li>\n<li><strong>Joining:</strong> A user can request to join an existing room. The server must add the user to the room&#39;s member list and notify existing members.</li>\n<li><strong>Listing:</strong> An endpoint (HTTP or via WebSocket) must provide a list of available rooms, including metadata like member count and activity timestamp.</li>\n<li><strong>Cleanup:</strong> The system should implement logic to archive or delete empty rooms after a period of inactivity to prevent resource leaks.</li>\n</ul>\n</li>\n<li><p><strong>Presence System Components:</strong> Presence is more than just &quot;online.&quot; It has multiple states:</p>\n<ul>\n<li><strong>Global Online Status:</strong> The user has an active WebSocket connection to the server.</li>\n<li><strong>Room Membership:</strong> The user is actively joined to one or more specific rooms.</li>\n<li><strong>Typing Activity:</strong> The user is currently composing a message in a specific room.\nThe system must track these states and broadcast relevant state changes (e.g., <code>user_joined</code>, <code>user_left</code>, <code>user_typing</code>) to affected room members.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"non-functional-goals-how-it-should-behave\">Non-Functional Goals (How it should behave)</h3>\n<p>These goals define the <strong>quality attributes</strong> of the system—how well it performs its functions. They are often constraints on the design and implementation. Think of these as the <strong>contract with the system operator</strong> (the developer running the server) and the <strong>implied contract with the user regarding experience quality</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>Target / Requirement</th>\n<th>Architectural Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Low Latency</strong></td>\n<td>Message delivery from sender to receiver should typically be under 200 milliseconds on a stable network. The 95th percentile (P95) latency should not exceed 500ms.</td>\n<td>Demands efficient message routing (O(1) room member lookups), non-blocking I/O, and minimal serialization/deserialization overhead. In-memory data structures for active sessions are essential.</td>\n</tr>\n<tr>\n<td><strong>Connection Resilience</strong></td>\n<td>The client must automatically attempt to reconnect after a disconnection, with exponential backoff (e.g., 1s, 2s, 4s, 8s... max 30s). Pending messages should be queued locally and sent upon reconnection.</td>\n<td>Requires a stable client-side connection state machine and a server that can handle reconnections gracefully (re-associating the new socket with the existing user session).</td>\n</tr>\n<tr>\n<td><strong>Basic Security</strong></td>\n<td>1. <strong>Authentication:</strong> Credentials must be validated; passwords must be hashed (e.g., with bcrypt) before storage.<br>2. <strong>Authorization:</strong> Users can only send messages to rooms they have joined.<br>3. <strong>Input Validation:</strong> All incoming messages must be validated for type, size, and content (sanitize HTML).<br>4. <strong>Transport:</strong> Use WSS (WebSocket Secure) in production to encrypt traffic.</td>\n<td>Influences the connection setup flow (authenticate <em>before</em> upgrading to WebSocket), adds validation layers in message handlers, and requires secure session management.</td>\n</tr>\n<tr>\n<td><strong>Debuggability &amp; Operability</strong></td>\n<td>The system must produce structured logs for key events: connection lifecycle, message broadcasts, room operations, and errors. Logs should include relevant IDs (userId, roomId, socketId).</td>\n<td>Dictates the use of a logging library and the careful instrumentation of core components. Logs are the primary window into the running system for developers.</td>\n</tr>\n<tr>\n<td><strong>Resource Efficiency</strong></td>\n<td>A single server instance should comfortably support thousands of concurrent connections on modest hardware. Memory usage should scale linearly with active connections and rooms.</td>\n<td>Requires careful management of in-memory state (leak-free cleanup), efficient broadcast algorithms (avoiding O(N²) operations), and the use of event-driven, non-blocking APIs.</td>\n</tr>\n<tr>\n<td><strong>Functional Correctness</strong></td>\n<td>The system must guarantee: 1) <strong>Message Ordering:</strong> Messages from a single user to a single room are delivered to all others in the order they were sent. 2) <strong>At-Least-Once Delivery:</strong> A message sent is delivered to all intended online recipients, barring catastrophic failure. 3) <strong>No Cross-Talk:</strong> Messages are never delivered to users outside the intended room.</td>\n<td>These are <strong>system invariants</strong>. They guide the design of the message broker and necessitate idempotent message handling where possible.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architectural Principle:</strong> Non-functional goals often involve <strong>trade-offs</strong>. For example, achieving low latency might involve keeping more data in memory (trading memory for speed). Our design prioritizes latency and simplicity for the learning context, accepting that this limits horizontal scalability—a conscious trade-off captured in our Non-Goals.</p>\n</blockquote>\n<p><strong>The &quot;Why&quot; Behind Non-Functional Goals:</strong></p>\n<ul>\n<li><strong>Low Latency</strong> is non-negotiable for conversational flow. Studies show delays over 200ms become perceptible and disruptive to turn-taking in dialogue.</li>\n<li><strong>Connection Resilience</strong> acknowledges the reality of mobile networks and Wi-Fi handoffs. A chat app that doesn&#39;t handle this feels brittle and unreliable.</li>\n<li><strong>Basic Security</strong> is the minimum bar for any application handling user-generated content and identities. While not implementing enterprise-grade security, we must avoid obvious vulnerabilities like plain-text passwords or SQL injection.</li>\n<li><strong>Debuggability</strong> is critical for a learning project. When things go wrong (and they will), clear logs are the fastest path to understanding. This also teaches good operational practices.</li>\n<li><strong>Resource Efficiency</strong> ensures the project remains runnable on a learner&#39;s laptop and demonstrates awareness of server-side constraints.</li>\n</ul>\n<h3 id=\"explicit-non-goals-what-it-does-not-do\">Explicit Non-Goals (What it does NOT do)</h3>\n<p>Defining what is <strong>out of scope</strong> is as important as defining what&#39;s in scope. It prevents scope creep, focuses effort on core learning objectives, and makes explicit the limitations of the current design. This is the <strong>anti-contract</strong>—a clear statement of what users and developers should not expect.</p>\n<table>\n<thead>\n<tr>\n<th>Feature / Capability</th>\n<th>Reason for Exclusion</th>\n<th>Implication / Workaround</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Video/Voice Chat</strong></td>\n<td>Significantly increases complexity (codecs, streaming, NAT traversal) and is a separate domain from real-time text messaging.</td>\n<td>Users must rely on external tools (e.g., Zoom, Discord) for voice/video communication.</td>\n</tr>\n<tr>\n<td><strong>File Sharing / Rich Media</strong></td>\n<td>Introduces concerns around storage, bandwidth, virus scanning, and content moderation. Moves focus from message routing to file handling.</td>\n<td>Users can share links to files stored elsewhere (e.g., Google Drive). The chat remains text-centric.</td>\n</tr>\n<tr>\n<td><strong>Advanced Moderation Tools</strong></td>\n<td>Tools like automated profanity filters, user banning, message deletion, or admin panels require a complex permissions system and content policy.</td>\n<td>Room creators have no special powers. All users in a room are equal peers.</td>\n</tr>\n<tr>\n<td><strong>Horizontal Scaling (Multi-Server)</strong></td>\n<td>Distributing WebSocket connections and real-time state across multiple servers introduces massive complexity (sticky sessions, shared state via Redis/PubSub, distributed consensus).</td>\n<td>The application is designed to run on a <strong>single server process</strong>. To scale, you would vertically scale (bigger machine) until this becomes limiting, then require a significant architectural rewrite.</td>\n</tr>\n<tr>\n<td><strong>Permanent Message Archive &amp; Search</strong></td>\n<td>Full-text search across all historical messages requires dedicated search infrastructure (like Elasticsearch) and complex pagination/querying.</td>\n<td>History is limited to a recent, configurable window (e.g., last 1000 messages per room). Searching is manual (Ctrl+F in the client).</td>\n</tr>\n<tr>\n<td><strong>Direct/Private Messaging (DMs)</strong></td>\n<td>While related to rooms, DMs require a different addressing scheme (user-to-user), privacy guarantees, and potentially a separate inbox model. It expands the core room-based mental model.</td>\n<td>Users can create a private room named for two people, but there is no first-class &quot;DM&quot; concept or privacy enforcement.</td>\n</tr>\n<tr>\n<td><strong>Read Receipts</strong> (&quot;Seen&quot; indicators)</td>\n<td>Requires tracking which messages have been <em>rendered</em> by each recipient, which is a client-side event that must be reported back to the server and stored. Adds significant state complexity.</td>\n<td>Users only know a message was <em>delivered</em> (recipient was online and in the room), not necessarily <em>read</em>.</td>\n</tr>\n<tr>\n<td><strong>Message Editing or Deletion</strong></td>\n<td>Allowing edits/deletes after broadcast requires tracking message versions, propagating updates, and handling the &quot;temporal consistency&quot; problem (what if someone saw the original?).</td>\n<td>Messages are immutable once sent. To &quot;correct&quot; a message, a user must send a new one.</td>\n</tr>\n<tr>\n<td><strong>Offline Message Queue &amp; Push Notifications</strong></td>\n<td>Storing messages for offline users and delivering them via mobile push (APNS/FCM) requires a separate queueing system, device token management, and a significant service integration.</td>\n<td>Messages are only delivered to users who are <strong>currently online and joined to the room</strong>. If you&#39;re offline, you miss the conversation until you reconnect and load history.</td>\n</tr>\n<tr>\n<td><strong>End-to-End Encryption (E2EE)</strong></td>\n<td>E2EE requires key exchange and management (e.g., Signal protocol), client-side encryption, and prevents the server from reading messages. This is a deep specialization in cryptographic engineering.</td>\n<td>All messages are visible to the server (necessary for broadcasting and persistence). Transport is encrypted (WSS), but server operators can technically view all content.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Philosophy:</strong> The choices in this table are guided by a <strong>pedagogical focus</strong>. We are building a <strong>learning vehicle</strong> for WebSockets, real-time state management, and basic full-stack architecture. Adding video chat or horizontal scaling would obscure these core lessons with ancillary complexity. This system is a <strong>foundation</strong>—a complete, working prototype that demonstrates the essential patterns. The &quot;Future Extensions&quot; section will discuss how one might evolve this foundation to support some of these excluded features.</p>\n</blockquote>\n<p><strong>The Consequences of Our Non-Goals:</strong>\nBy explicitly rejecting horizontal scaling, we are free to use simple, in-memory data structures (<code>Map</code> and <code>Set</code>) for tracking connections and rooms. This makes the code dramatically easier to understand and debug. By rejecting offline messaging, we avoid building a persistent queue system. By rejecting file sharing, we don&#39;t need to integrate with object storage or handle multipart uploads. <strong>These exclusions are liberating constraints that allow us to build a clean, understandable system focused on the core learning objectives.</strong></p>\n<h3 id=\"implementation-guidance-layer-2\">Implementation Guidance (Layer 2)</h3>\n<p>This section bridges the design concepts to concrete implementation choices and starter code.</p>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning Focus)</th>\n<th>Advanced Option (Production Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>WebSocket Library</strong></td>\n<td><code>ws</code> (minimal, follows standard WebSocket API)</td>\n<td><code>Socket.IO</code> (built-in reconnection, rooms, fallback to polling)</td>\n</tr>\n<tr>\n<td><strong>Server Framework</strong></td>\n<td>Native Node.js <code>http</code>/<code>https</code> modules</td>\n<td><code>Express.js</code> with middleware for HTTP routes</td>\n</tr>\n<tr>\n<td><strong>Authentication Storage</strong></td>\n<td>In-memory <code>Map</code> (for simplicity) or a simple JSON file</td>\n<td><code>SQLite</code> or <code>PostgreSQL</code> with a proper <code>users</code> table</td>\n</tr>\n<tr>\n<td><strong>Message Persistence</strong></td>\n<td>In-memory array per room (volatile) or append to a JSONL (JSON Lines) file</td>\n<td><code>SQLite</code>/<code>PostgreSQL</code> with a <code>messages</code> table and indexes on <code>roomId</code> and <code>timestamp</code></td>\n</tr>\n<tr>\n<td><strong>Client Library</strong></td>\n<td>Native <code>WebSocket</code> API</td>\n<td><code>Socket.IO</code> client for automatic reconnection</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Recommendation for Learners:</strong> Start with the <strong>Simple Options</strong> (<code>ws</code>, native <code>http</code>, in-memory storage). They have fewer abstractions, making it easier to see how the underlying protocols work. You can graduate to the advanced options as a later exercise.</p>\n</blockquote>\n<p><strong>B. Recommended File/Module Structure:</strong>\nOrganizing code from the start prevents a monolithic <code>server.js</code> file. Here&#39;s a suggested structure aligning with our components.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── package.json\n├── server/\n│   ├── index.js                      # Main entry point, creates HTTP server\n│   ├── connectionManager/            # Milestone 1: WebSocket Server &amp; Connection Manager\n│   │   ├── index.js                  # Exports the ConnectionManager class\n│   │   └── heartbeat.js              # Ping/pong heartbeat logic\n│   ├── roomManager/                  # Milestones 2 &amp; 3: Message Broker &amp; Room Manager\n│   │   ├── index.js                  # Exports the RoomManager class\n│   │   └── typingIndicator.js        # Logic for managing typing timeouts\n│   ├── persistence/                  # Milestone 4: Persistence &amp; Authentication\n│   │   ├── authService.js            # User registration, login, session validation\n│   │   ├── messageStore.js           # Save and load messages from storage\n│   │   └── simpleStore.js            # In-memory or file-based store (starter)\n│   └── utils/\n│       ├── logger.js                 # Structured logging utility\n│       ├── validation.js             # Input validation helpers\n│       └── constants.js              # Shared constants (event names, limits)\n└── client/\n    ├── public/\n    │   ├── index.html                # Main chat UI\n    │   ├── style.css                 # Styles\n    │   └── app.js                    # Client-side WebSocket &amp; UI logic</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (Simple In-Memory Store):</strong>\nThis is a complete, working <code>simpleStore.js</code> you can use for early milestones before adding a database. It provides a basic key-value interface.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/persistence/simpleStore.js</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * A simple, in-memory key-value store with optional file persistence.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * NOT for production use - data is lost on server restart unless saveToFile is used.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SimpleStore</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">persistFile</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// key -> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.persistFile </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> persistFile;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">loadFromFile</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Load initial data from a JSON file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  loadFromFile</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistFile) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> fs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'fs'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (fs.</span><span style=\"color:#B392F0\">existsSync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistFile)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> raw</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> fs.</span><span style=\"color:#B392F0\">readFileSync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistFile, </span><span style=\"color:#9ECBFF\">'utf8'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> entries</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(raw);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.data </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(entries);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Loaded ${</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">data</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">size</span><span style=\"color:#9ECBFF\">} entries from ${</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">persistFile</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to load persistent store:'</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Save current state to a JSON file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  saveToFile</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistFile) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> fs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'fs'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> entries</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Array.</span><span style=\"color:#B392F0\">from</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">entries</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> raw</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(entries, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      fs.</span><span style=\"color:#B392F0\">writeFileSync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistFile, raw, </span><span style=\"color:#9ECBFF\">'utf8'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to save persistent store:'</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Core CRUD operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(key, value);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">saveToFile</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  has</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  delete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> result</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">delete</span><span style=\"color:#E1E4E8\">(key);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">saveToFile</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Find all keys where the value matches a predicate</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  find</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">predicate</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> results</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">value</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">of</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">entries</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">predicate</span><span style=\"color:#E1E4E8\">(value, key)) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">({ key, value });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> results;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Get all entries as an array</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getAll</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> Array.</span><span style=\"color:#B392F0\">from</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.data.</span><span style=\"color:#B392F0\">entries</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> SimpleStore;</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code (Connection Manager):</strong>\nHere is the skeleton for the main <code>ConnectionManager</code> class. Fill in the TODOs based on the algorithm steps described in the Component Design section.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/connectionManager/index.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> logger</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../utils/logger'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">validateMessage</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../utils/validation'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">server</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ADR: Using Map for direct socket access by a unique connectionId</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.clients </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// connectionId -> { socket, userId, ... }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.wss </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">({ server });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setupEventHandlers</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">startCleanupInterval</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  setupEventHandlers</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.wss.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'connection'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 1: Generate a unique connectionId (e.g., uuid or timestamp+random)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 2: Create a client object with socket, connectionId, and metadata (ip, userAgent)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 3: Store client in this.clients Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 4: Attach message, close, and error event handlers to the socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 5: Log the connection event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 6: Optional: Implement immediate authentication check here (see Milestone 4 ADR)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Handle an incoming message from a client</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  handleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Try to parse rawMessage as JSON, catch error and send error response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate the parsed message has required fields (type, payload)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Look up the client object associated with this socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Route the message to the appropriate handler (e.g., roomManager.broadcast)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Wrap in try/catch - log any handler error and send error response to client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Handle client disconnection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  handleClose</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find the client object for this socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If found, notify the roomManager that this user left all rooms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove the client from this.clients Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log the disconnection event</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Send a message to a specific client socket</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  sendToClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up client by connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if client.socket.readyState === WebSocket.OPEN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If open, stringify message and send via client.socket.send()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If not open, log a warning and optionally clean up the client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Broadcast a message to multiple clients</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  broadcastToClients</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionIds</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate over connectionIds array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each id, call this.sendToClient(id, message)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Consider batching or using Promise.all if performance becomes an issue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Periodic cleanup of dead connections (fail-safe)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  startCleanupInterval</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setInterval</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 1: Iterate over this.clients</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 2: For each client, check if socket.readyState is CLOSED or CLOSING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO 3: If so, call this.handleClose for that socket</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">30000</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// Run every 30 seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Get statistics (for debugging/admin)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getStats</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      totalConnections: </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.clients.size,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // TODO: Add more stats like connections per user, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> ConnectionManager;</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (JavaScript/Node.js):</strong></p>\n<ul>\n<li><strong>Use <code>ws</code> library:</strong> Install via <code>npm install ws</code>. It&#39;s the most standard WebSocket server implementation for Node.js.</li>\n<li><strong>Connection IDs:</strong> Use <code>crypto.randomUUID()</code> (Node 15+) or the <code>uuid</code> package to generate unique connection identifiers.</li>\n<li><strong>Heartbeats:</strong> Implement using <code>socket.ping()</code> and <code>socket.pong()</code> listeners. Set a timer; if no pong is received within a timeout, terminate the connection.</li>\n<li><strong>Error Handling:</strong> Always attach an <code>&#39;error&#39;</code> listener to the WebSocket socket. Unhandled socket errors can crash the Node.js process.</li>\n<li><strong>Logging:</strong> Use a simple wrapper around <code>console.log</code> that prefixes with timestamps and log levels (INFO, ERROR). This dramatically improves debuggability.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint (End of Milestone 1):</strong>\nAfter implementing the Connection Manager skeleton:</p>\n<ol>\n<li><strong>Run the server:</strong> <code>node server/index.js</code></li>\n<li><strong>Test connection:</strong> Open <code>client/public/index.html</code> in a browser (or use a WebSocket testing tool like <code>wscat</code>). You should see &quot;Connected to server&quot; in your server logs.</li>\n<li><strong>Test multiple clients:</strong> Open a second browser tab. Both should connect independently.</li>\n<li><strong>Test disconnection:</strong> Close one tab. Within a few seconds, you should see a &quot;Client disconnected&quot; log.</li>\n<li><strong>Verify cleanup:</strong> Check that your <code>this.clients.size</code> decreases after a disconnection (you can add a temporary log or admin endpoint).</li>\n<li><strong>Expected Signs of Trouble:</strong><ul>\n<li><strong>Server crashes on connect/disconnect:</strong> Likely an unhandled error event on the socket. Add error listeners everywhere.</li>\n<li><strong>Client count keeps increasing:</strong> You are not removing clients on disconnect. Check your <code>handleClose</code> logic and cleanup interval.</li>\n<li><strong>No logs appear:</strong> Ensure your logger is called at each lifecycle event.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This architectural overview provides the foundation for all four milestones, outlining the major components and their interactions that will be built and integrated throughout the project.</p>\n</blockquote>\n<p>The high-level architecture visualizes the system as four collaborating pillars, each with distinct responsibilities but working together to deliver the chat experience. This decomposition follows the <strong>separation of concerns</strong> principle: each component handles one core aspect of the system, making the codebase easier to understand, test, and maintain.</p>\n<h3 id=\"component-overview-and-responsibilities\">Component Overview and Responsibilities</h3>\n<p>Think of the chat system as a <strong>modern conference center</strong>:</p>\n<ul>\n<li><strong>The WebSocket Server</strong> is the reception desk and switchboard, greeting visitors and connecting their calls</li>\n<li><strong>The Room &amp; Presence Manager</strong> is the conference coordinator, tracking who&#39;s in which meeting room and what they&#39;re doing</li>\n<li><strong>The Client Application</strong> is the attendee&#39;s smartphone app, providing the interface to participate</li>\n<li><strong>The Persistence Layer</strong> is the archives and security office, storing historical records and verifying identities</li>\n</ul>\n<p>This mental model helps visualize how responsibilities are divided while maintaining clear communication channels between components.</p>\n<p>The following diagram illustrates the component architecture and their primary interactions:</p>\n<p><img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fsys-component-diagram.svg\" alt=\"System Component Overview\"></p>\n<h4 id=\"core-components-and-their-responsibilities\">Core Components and Their Responsibilities</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Data Owned</th>\n<th>Critical Operations</th>\n<th>Interfaces With</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>WebSocket Server &amp; Connection Manager</strong></td>\n<td>Manages the lifecycle of real-time connections</td>\n<td>Set of active <code>ClientSession</code> objects, socket state</td>\n<td>Accept connections, route messages, handle disconnections</td>\n<td>Client browsers (via WebSocket), Room Manager, Auth Service</td>\n</tr>\n<tr>\n<td><strong>Room &amp; Presence Manager</strong></td>\n<td>Orchestrates room-based messaging and user presence</td>\n<td>Collection of <code>Room</code> objects with member lists, typing status</td>\n<td>Add/remove users from rooms, broadcast messages, track presence</td>\n<td>WebSocket Server (for message delivery), Persistence Layer (for history)</td>\n</tr>\n<tr>\n<td><strong>Persistence &amp; Authentication Service</strong></td>\n<td>Stores message history and manages user identity</td>\n<td><code>User</code> records, <code>ChatMessage</code> history in database</td>\n<td>User registration/login, message storage/retrieval, session validation</td>\n<td>WebSocket Server (for auth), Room Manager (for history)</td>\n</tr>\n<tr>\n<td><strong>Client Application</strong></td>\n<td>Provides the user interface for chat interaction</td>\n<td>Local message cache, UI state, connection status</td>\n<td>Render messages, capture user input, manage WebSocket connection</td>\n<td>WebSocket Server (via WebSocket protocol)</td>\n</tr>\n</tbody></table>\n<h4 id=\"detailed-component-descriptions\">Detailed Component Descriptions</h4>\n<p><strong>WebSocket Server &amp; Connection Manager</strong>\nThis component serves as the <strong>system&#39;s entry point</strong> for all real-time communication. It&#39;s responsible for the low-level WebSocket protocol handling: accepting HTTP upgrade requests, establishing persistent connections, managing connection state, and providing a clean interface for other components to send messages to clients. It maintains a live registry of all connected clients as <code>ClientSession</code> objects, each representing a single WebSocket connection with associated metadata (user ID, IP address, user agent). The server implements <strong>heartbeat mechanisms</strong> (ping/pong) to detect stale connections and ensures proper cleanup when clients disconnect.</p>\n<p><strong>Room &amp; Presence Manager</strong>\nOperating as the <strong>application&#39;s business logic layer</strong>, this component implements the chat-specific functionality. It manages the concept of rooms (chat channels), tracks which users are in which rooms, handles message broadcasting with appropriate exclusions, and maintains presence information (online/offline status, typing indicators). When a message arrives from a client, the Room Manager determines which room it belongs to, retrieves the list of members in that room (excluding the sender), and instructs the WebSocket Server to deliver the message to each member&#39;s socket. It also handles room lifecycle—creating rooms when the first user joins and cleaning up empty rooms if configured to do so.</p>\n<p><strong>Persistence &amp; Authentication Service</strong>\nThis dual-purpose component provides <strong>data durability and security</strong>. The authentication portion handles user registration, login credential verification, and session management. When a WebSocket connection attempt occurs, this service validates the provided credentials (typically via token or cookie) before allowing the upgrade. The persistence portion stores all chat messages in a database with proper indexing by room and timestamp, enabling historical message retrieval. It also manages user profiles and, in more advanced implementations, could handle read receipts or message editing history.</p>\n<p><strong>Client Application</strong>\nThe client is a <strong>stateful web application</strong> running in the user&#39;s browser. It establishes and maintains the WebSocket connection to the server, handles connection retries with exponential backoff, renders the chat interface, and manages local UI state (current room, message draft, unread counts). The client implements the event protocol defined by the server, sending properly formatted JSON messages for chat events and handling incoming messages to update the UI in real-time.</p>\n<h4 id=\"component-interaction-patterns\">Component Interaction Patterns</h4>\n<p>The components interact through three primary patterns:</p>\n<ol>\n<li><p><strong>Request-Response over WebSocket</strong>: The client sends a message (like <code>join_room</code>), the server processes it through the appropriate handlers, and sends back a response (like <code>room_joined</code> with message history).</p>\n</li>\n<li><p><strong>Event Notification</strong>: When something happens that other clients should know about (like a user joining a room), the Room Manager instructs the WebSocket Server to broadcast an event (like <code>EVENT_USER_JOINED</code>) to all relevant clients.</p>\n</li>\n<li><p><strong>Data Access</strong>: The Room Manager queries the Persistence Layer for message history when a user joins a room, and writes new messages to it after validation.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Design Insight:</strong> The WebSocket Server acts as a <strong>message transport layer</strong>, while the Room Manager contains the <strong>application logic</strong>. This separation allows the transport mechanism to potentially be swapped (e.g., for a different real-time protocol) without rewriting the core chat functionality.</p>\n</blockquote>\n<h4 id=\"data-flow-between-components\">Data Flow Between Components</h4>\n<p>When a user sends a chat message, the data flows through the system as follows:</p>\n<ol>\n<li><strong>Client → WebSocket Server</strong>: Raw WebSocket frame containing JSON</li>\n<li><strong>WebSocket Server → Room Manager</strong>: Parsed message object with sender metadata</li>\n<li><strong>Room Manager → Persistence Layer</strong>: Message stored to database</li>\n<li><strong>Room Manager → WebSocket Server</strong>: List of recipient connection IDs and formatted message</li>\n<li><strong>WebSocket Server → Multiple Clients</strong>: Individual WebSocket frames to each recipient</li>\n</ol>\n<p>This flow ensures that business logic (room membership, message formatting) remains separate from transport concerns (socket management, connection state).</p>\n<h3 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h3>\n<p>Organizing the codebase with a clear structure from the beginning prevents the common &quot;everything in one file&quot; antipattern that makes projects difficult to maintain. The recommended structure follows the <strong>component boundaries</strong> established in the architecture, with clear separation between transport logic, business logic, persistence, and client code.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── server/                          # Server-side code\n│   ├── src/                         # TypeScript source\n│   │   ├── core/                    # Foundational utilities\n│   │   │   ├── logger.ts            # Structured logging\n│   │   │   ├── config.ts            # Configuration management\n│   │   │   └── errors.ts            # Custom error classes\n│   │   ├── transport/               # WebSocket Server component\n│   │   │   ├── websocket-server.ts  # Main WebSocket server class\n│   │   │   ├── connection-manager.ts # Manages ClientSession objects\n│   │   │   ├── protocol/            # Message protocol definitions\n│   │   │   │   ├── message-types.ts # Constants like EVENT_CHAT_MESSAGE\n│   │   │   │   ├── validators.ts    # Message validation functions\n│   │   │   │   └── serializers.ts   # Message formatting utilities\n│   │   │   └── middleware/          # WebSocket middleware\n│   │   │       ├── auth-middleware.ts # Authentication on upgrade\n│   │   │       └── heartbeat-middleware.ts # Ping/pong handling\n│   │   ├── rooms/                   # Room &amp; Presence Manager component\n│   │   │   ├── room-manager.ts      # Main room management class\n│   │   │   ├── presence-tracker.ts  # Tracks online/typing status\n│   │   │   ├── room.ts              # Room class definition\n│   │   │   └── types.ts             # TypeScript interfaces for rooms\n│   │   ├── persistence/             # Persistence &amp; Auth component\n│   │   │   ├── auth/                # Authentication subsystem\n│   │   │   │   ├── auth-service.ts  # User registration/login\n│   │   │   │   ├── session-store.ts # Manages active sessions\n│   │   │   │   └── password-utils.ts # Password hashing/verification\n│   │   │   ├── database/            # Database abstraction\n│   │   │   │   ├── message-store.ts # ChatMessage CRUD operations\n│   │   │   │   ├── user-store.ts    # User profile management\n│   │   │   │   └── base-repository.ts # Shared database logic\n│   │   │   └── models/              # Data model definitions\n│   │   │       ├── chat-message.ts  # ChatMessage type/interface\n│   │   │       ├── user.ts          # User type/interface\n│   │   │       └── client-session.ts # ClientSession type/interface\n│   │   └── main.ts                  # Application entry point\n│   ├── tests/                       # Server-side tests\n│   │   ├── unit/                    # Unit tests by component\n│   │   └── integration/             # Integration tests\n│   ├── package.json                 # Node.js dependencies\n│   └── tsconfig.json                # TypeScript configuration\n├── client/                          # Web client application\n│   ├── src/                         # Client source code\n│   │   ├── lib/                     # Client-side libraries\n│   │   │   └── websocket-client.ts  # WebSocket connection wrapper\n│   │   ├── ui/                      # User interface components\n│   │   │   ├── chat-room.ts         # Main chat room component\n│   │   │   ├── message-list.ts      # Message display component\n│   │   │   ├── user-list.ts         # Online users component\n│   │   │   └── message-input.ts     # Message composition component\n│   │   ├── state/                   # Client-side state management\n│   │   │   ├── connection-store.ts  # WebSocket connection state\n│   │   │   ├── message-store.ts     # Local message cache\n│   │   │   └── user-store.ts        # Local user/profile state\n│   │   ├── utils/                   # Client utilities\n│   │   │   └── message-formatter.ts # Format messages for display\n│   │   └── main.ts                  # Client application entry point\n│   ├── public/                      # Static assets\n│   │   └── index.html               # Main HTML file\n│   └── package.json                 # Client dependencies\n├── shared/                          # Code shared between client and server\n│   └── types/                       # Shared TypeScript definitions\n│       └── protocol.ts              # Common message type definitions\n└── docker-compose.yml               # Local development with database</code></pre></div>\n\n<h4 id=\"key-structural-decisions\">Key Structural Decisions</h4>\n<p><strong>Decision: Separating Transport from Business Logic</strong></p>\n<ul>\n<li><strong>Context</strong>: The system needs to handle both the low-level WebSocket protocol and high-level chat semantics</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Combined transport and business logic in one module</li>\n<li>Separate transport layer with clean interface to business logic</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate transport (<code>transport/</code>) from business logic (<code>rooms/</code>)</li>\n<li><strong>Rationale</strong>: This separation allows each to evolve independently—the transport could switch to a different protocol (like Socket.IO or raw TCP) without affecting room management logic. It also enables cleaner testing, as the room logic can be tested without actual WebSocket connections.</li>\n<li><strong>Consequences</strong>: Requires well-defined interfaces between layers, slightly more code organization overhead, but yields more maintainable and testable code.</li>\n</ul>\n<p><strong>Decision: Client-Server Shared Types</strong></p>\n<ul>\n<li><strong>Context</strong>: Both client and server need to agree on message formats and data structures</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Duplicate type definitions in both codebases</li>\n<li>Shared TypeScript definitions in a common directory</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Shared type definitions in <code>shared/types/</code></li>\n<li><strong>Rationale</strong>: This ensures type safety across the entire stack—if a message format changes, TypeScript will catch inconsistencies at compile time rather than runtime. It&#39;s particularly valuable for the event protocol where client and server must agree exactly on field names and types.</li>\n<li><strong>Consequences</strong>: Requires build configuration to include shared directory in both client and server TypeScript compilation, but prevents a whole class of protocol mismatch bugs.</li>\n</ul>\n<p><strong>Decision: Database Abstraction Layer</strong></p>\n<ul>\n<li><strong>Context</strong>: The system needs to store messages and user data, but the specific database technology might evolve</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Direct database calls throughout the codebase</li>\n<li>Repository pattern with clean interfaces</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Repository pattern in <code>persistence/database/</code></li>\n<li><strong>Rationale</strong>: This abstraction allows switching database technologies (from SQLite for development to PostgreSQL for production) with minimal code changes. It also centralizes database queries, making optimization and debugging easier.</li>\n<li><strong>Consequences</strong>: Adds an extra layer of abstraction but significantly improves long-term maintainability and testability (via mocking).</li>\n</ul>\n<blockquote>\n<p><strong>Implementation Note:</strong> For simplicity in early milestones, you may start with in-memory storage in the Room Manager and add persistence later. The architecture supports this progression—the Room Manager interface to the persistence layer remains the same whether it&#39;s talking to an in-memory store or a real database.</p>\n</blockquote>\n<h4 id=\"module-dependencies-and-import-flow\">Module Dependencies and Import Flow</h4>\n<p>The dependency flow follows a <strong>unidirectional architecture</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>main.ts → websocket-server.ts → connection-manager.ts\n                                ↗\nroom-manager.ts ← persistence/ (auth-service, message-store)</code></pre></div>\n\n<p>Key dependency rules:</p>\n<ol>\n<li><strong>High-level components depend on low-level ones</strong>, not vice versa</li>\n<li><strong>The <code>transport/</code> layer knows about <code>rooms/</code> and <code>persistence/</code></strong> for message routing</li>\n<li><strong>The <code>rooms/</code> layer knows about <code>persistence/</code></strong> for data access</li>\n<li><strong>The <code>persistence/</code> layer has no dependencies</strong> on other business logic components</li>\n<li><strong>Shared types have no dependencies</strong> and are imported by both client and server</li>\n</ol>\n<p>This structure prevents circular dependencies and makes the system easier to reason about.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Technology Note:</strong> For this JavaScript/TypeScript project, we recommend starting with Node.js and the <code>ws</code> library for WebSocket support, as it provides a minimal, standards-compliant implementation without the additional abstractions of Socket.IO. This approach gives you direct exposure to the WebSocket protocol fundamentals.</p>\n</blockquote>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning Focus)</th>\n<th>Advanced Option (Production Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>WebSocket Server</strong></td>\n<td>Node.js + <code>ws</code> library</td>\n<td>Node.js + <code>ws</code> with connection pooling</td>\n</tr>\n<tr>\n<td><strong>Room Management</strong></td>\n<td>In-memory JavaScript objects</td>\n<td>Redis for distributed room state</td>\n</tr>\n<tr>\n<td><strong>Persistence</strong></td>\n<td>SQLite with <code>better-sqlite3</code></td>\n<td>PostgreSQL with connection pooling</td>\n</tr>\n<tr>\n<td><strong>Authentication</strong></td>\n<td>JWT tokens stored in memory</td>\n<td>OAuth2.0 with persistent session store</td>\n</tr>\n<tr>\n<td><strong>Client Framework</strong></td>\n<td>Vanilla JavaScript + DOM API</td>\n<td>React/Vue.js with state management</td>\n</tr>\n</tbody></table>\n<h4 id=\"starter-project-structure-setup\">Starter Project Structure Setup</h4>\n<p>Create the basic project structure with these commands:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create project root</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> real-time-chat</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> real-time-chat</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Initialize server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> server/src/{core,transport/{protocol,middleware},rooms,persistence/{auth,database,models}}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> server/tests/{unit,integration}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">npm</span><span style=\"color:#9ECBFF\"> init</span><span style=\"color:#79B8FF\"> -y</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">npm</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> ws</span><span style=\"color:#9ECBFF\"> typescript</span><span style=\"color:#9ECBFF\"> @types/node</span><span style=\"color:#9ECBFF\"> @types/ws</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">npm</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#79B8FF\"> -D</span><span style=\"color:#9ECBFF\"> ts-node</span><span style=\"color:#9ECBFF\"> nodemon</span><span style=\"color:#9ECBFF\"> jest</span><span style=\"color:#9ECBFF\"> @types/jest</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Initialize client</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> ..</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> client/src/{lib,ui,state,utils}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> client/public</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> client</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">npm</span><span style=\"color:#9ECBFF\"> init</span><span style=\"color:#79B8FF\"> -y</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">npm</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> typescript</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create shared types directory</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> ..</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> shared/types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create TypeScript configurations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (Details in next section)</span></span></code></pre></div>\n\n<h4 id=\"basic-typescript-configuration\">Basic TypeScript Configuration</h4>\n<p>Create <code>server/tsconfig.json</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"compilerOptions\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"target\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ES2020\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"module\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"commonjs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"lib\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"ES2020\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"outDir\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"./dist\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"rootDir\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"./src\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"strict\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"esModuleInterop\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"skipLibCheck\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"forceConsistentCasingInFileNames\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"resolveJsonModule\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"types\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"node\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"jest\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"include\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"src/**/*\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"exclude\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"node_modules\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"dist\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tests\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Create <code>client/tsconfig.json</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"compilerOptions\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"target\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ES2020\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"module\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ESNext\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"lib\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"ES2020\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"DOM\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"outDir\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"./dist\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"rootDir\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"./src\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"strict\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"esModuleInterop\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"skipLibCheck\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"moduleResolution\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"node\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"resolveJsonModule\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"include\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"src/**/*\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"exclude\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"node_modules\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"dist\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-infrastructure-starter-code\">Core Infrastructure Starter Code</h4>\n<p><strong>Shared Protocol Types (<code>shared/types/protocol.ts</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">typescript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Shared type definitions between client and server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> ChatMessage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  sender</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  content</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  timestamp</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// ISO format</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  roomId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> User</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  username</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  passwordHash</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  createdAt</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> ClientSession</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  connectionId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  socket</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Note: WebSocket type differs client vs server</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  userId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  ip</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  userAgent</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Event type constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> const</span><span style=\"color:#79B8FF\"> EVENT_CHAT_MESSAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'chat_message'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> const</span><span style=\"color:#79B8FF\"> EVENT_USER_JOINED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'user_joined'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> const</span><span style=\"color:#79B8FF\"> EVENT_USER_TYPING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'user_typing'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> const</span><span style=\"color:#79B8FF\"> MAX_MESSAGE_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message envelope for WebSocket communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#B392F0\"> WebSocketMessage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  type</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  payload</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  timestamp</span><span style=\"color:#F97583\">?:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Server Core Utilities (<code>server/src/core/logger.ts</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">typescript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Simple structured logger for development</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> Logger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  static</span><span style=\"color:#B392F0\"> info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metadata</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      level: </span><span style=\"color:#9ECBFF\">'INFO'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      message,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      ...</span><span style=\"color:#E1E4E8\">metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  static</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">error</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}, </span><span style=\"color:#FFAB70\">metadata</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      level: </span><span style=\"color:#9ECBFF\">'ERROR'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      message,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      error: error.message </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> String</span><span style=\"color:#E1E4E8\">(error),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      stack: error.stack,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      ...</span><span style=\"color:#E1E4E8\">metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  static</span><span style=\"color:#B392F0\"> warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metadata</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      level: </span><span style=\"color:#9ECBFF\">'WARN'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      message,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      ...</span><span style=\"color:#E1E4E8\">metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Server Entry Point Skeleton (<code>server/src/main.ts</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">typescript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { WebSocketServer } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> './transport/websocket-server'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Logger } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> './core/logger'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> PORT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> process.env.</span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  Logger.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Starting real-time chat server'</span><span style=\"color:#E1E4E8\">, { port: </span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO: Initialize database connection if using persistence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Create and start WebSocket server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> server</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WebSocketServer</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    port: </span><span style=\"color:#B392F0\">Number</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Pass configuration for room manager, auth service, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  server.</span><span style=\"color:#B392F0\">start</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Graceful shutdown handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  process.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'SIGTERM'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Logger.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Received SIGTERM, shutting down gracefully'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server.</span><span style=\"color:#B392F0\">stop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    process.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  process.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'SIGINT'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Logger.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Received SIGINT, shutting down gracefully'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server.</span><span style=\"color:#B392F0\">stop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    process.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">main</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">catch</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  Logger.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to start server'</span><span style=\"color:#E1E4E8\">, error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  process.</span><span style=\"color:#B392F0\">exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre></div>\n\n<p><strong>Client WebSocket Wrapper Skeleton (<code>client/src/lib/websocket-client.ts</code>)</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">typescript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { WebSocketMessage } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> '../../../shared/types/protocol'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> WebSocketClient</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> socket</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> reconnectAttempts</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> maxReconnectAttempts</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> reconnectDelay</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">private</span><span style=\"color:#FFAB70\"> url</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">) {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  connect</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create new WebSocket connection to this.url</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up event handlers for open, message, close, error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Implement exponential backoff for reconnection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store connection state for UI feedback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> WebSocketMessage</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if socket is in OPEN state (readyState === 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Stringify message to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send via socket.send()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle errors (queue for retry or notify UI)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  disconnect</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Close WebSocket connection gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Clean up event listeners</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Reset reconnect state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO: Add methods for specific message types (sendChatMessage, joinRoom, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"development-scripts\">Development Scripts</h4>\n<p>Add these scripts to <code>server/package.json</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"scripts\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"build\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"tsc\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"start\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"node dist/main.js\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"dev\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"nodemon --exec ts-node src/main.ts\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"test\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"jest\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"test:watch\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"jest --watch\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"next-steps-for-implementation\">Next Steps for Implementation</h4>\n<p>With this architecture in place, you&#39;ll implement the system component by component:</p>\n<ol>\n<li><strong>Start with the WebSocket Server</strong> (Milestone 1): Implement the connection lifecycle in <code>transport/</code></li>\n<li><strong>Add Room Management</strong> (Milestones 2-3): Build the room logic in <code>rooms/</code> </li>\n<li><strong>Implement Persistence</strong> (Milestone 4): Add database storage in <code>persistence/</code></li>\n<li><strong>Build the Client</strong> (Parallel development): Create the UI in <code>client/</code></li>\n</ol>\n<p>The clear separation between components allows you to work on one layer at a time, testing each in isolation before integrating them into the complete system.</p>\n<hr>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4). This section defines the foundational data structures and communication protocol that enable real-time messaging, room management, user presence, and message persistence across the entire system. The data model serves as the contract between components and clients.</p>\n</blockquote>\n<h3 id=\"core-types-and-structures\">Core Types and Structures</h3>\n<p>Think of the data model as the <strong>DNA of your chat application</strong>—it encodes all the information needed to represent users, conversations, and interactions. Just as DNA has four nucleotide bases (A, T, C, G) that combine in specific patterns to create genetic instructions, your chat system has four core data types (<code>ChatMessage</code>, <code>User</code>, <code>Room</code>, and <code>ClientSession</code>) that combine to represent the complete state of the application. These structures flow through your system like genetic information flows through a biological organism, providing the blueprint for all functionality.</p>\n<p>The following tables define each core type with exact field specifications. Note that these are <strong>in-memory representations</strong> used within the server—the wire format for transmitting this data to clients may differ slightly (e.g., using ISO string timestamps instead of Date objects).</p>\n<h4 id=\"chatmessage\">ChatMessage</h4>\n<p>A <code>ChatMessage</code> represents a single unit of communication between users. It&#39;s the atomic building block of conversation—like a sentence in a dialogue. Each message is immutable once created and serves as a historical record of what was said, by whom, when, and where.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description &amp; Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sender</code></td>\n<td><code>string</code></td>\n<td>The username of the user who sent this message. This must match an existing user&#39;s username in the system. Cannot be empty or contain only whitespace.</td>\n</tr>\n<tr>\n<td><code>content</code></td>\n<td><code>string</code></td>\n<td>The textual content of the message. Maximum length is defined by <code>MAX_MESSAGE_LENGTH</code> (1000 characters). Must be validated for length and sanitized for potentially malicious content (e.g., HTML tags) before storage or transmission.</td>\n</tr>\n<tr>\n<td><code>timestamp</code></td>\n<td><code>string</code> (ISO 8601)</td>\n<td>The UTC date and time when the server received and processed the message, expressed in ISO 8601 format (e.g., <code>&quot;2024-01-15T10:30:45.123Z&quot;</code>). Using a string format ensures consistent parsing across different clients and languages. The server assigns this timestamp, not the client, to prevent clock skew issues.</td>\n</tr>\n<tr>\n<td><code>roomId</code></td>\n<td><code>string</code></td>\n<td>The unique identifier of the room where this message was sent. This must correspond to an existing room&#39;s <code>id</code> field. Messages are always scoped to a specific room—they cannot exist outside of a room context.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>timestamp</code> field uses ISO 8601 string format rather than a numeric Unix timestamp for better human readability during debugging and compatibility with JavaScript&#39;s <code>Date.parse()</code> and <code>toISOString()</code> methods. However, this comes with a slight storage overhead compared to storing milliseconds as a number.</p>\n</blockquote>\n<h4 id=\"user\">User</h4>\n<p>A <code>User</code> represents a registered person who can participate in chat rooms. Think of it as a <strong>citizen of your chat universe</strong>—they have an identity (<code>username</code>), proof of citizenship (<code>passwordHash</code>), and a record of when they joined the community (<code>createdAt</code>). The <code>User</code> object contains authentication credentials and metadata, but note that it does NOT contain connection state—that&#39;s tracked separately in <code>ClientSession</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description &amp; Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>username</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for the user across the system. Typically 3-20 characters, alphanumeric with optional underscores or hyphens. Case-sensitive for simplicity (though you could normalize to lowercase).</td>\n</tr>\n<tr>\n<td><code>passwordHash</code></td>\n<td><code>string</code></td>\n<td>Hashed representation of the user&#39;s password using a secure one-way hash function (e.g., bcrypt, Argon2). Never store passwords in plain text. The hash should include a salt to prevent rainbow table attacks.</td>\n</tr>\n<tr>\n<td><code>createdAt</code></td>\n<td><code>Date</code></td>\n<td>The date and time when the user account was created. Used for administrative purposes and potentially for displaying &quot;member since&quot; information. Stored as a Date object server-side but serialized to ISO string when transmitted.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>User</code> object is separate from connection state (<code>ClientSession</code>) because a single user can be connected from multiple devices simultaneously (e.g., phone and laptop). This separation enables features like &quot;last seen&quot; timestamps and multi-device message synchronization in more advanced implementations.</p>\n</blockquote>\n<h4 id=\"room\">Room</h4>\n<p>A <code>Room</code> represents a named conversation space where users gather to exchange messages. Imagine it as a <strong>virtual conference room</strong> with a door, a nameplate, and a list of who&#39;s currently inside. Rooms are dynamic containers that hold both members (via <code>memberIds</code>) and the history of their conversation (via associated <code>ChatMessage</code> records in the database).</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description &amp; Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>id</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for the room, typically generated as a UUID or a URL-safe version of the room name. Used as a stable reference in URLs and message routing.</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>string</code></td>\n<td>Human-readable room name (e.g., &quot;general&quot;, &quot;random&quot;, &quot;project-discussion&quot;). Displayed in room lists and UI headers. Should be sanitized to prevent injection attacks.</td>\n</tr>\n<tr>\n<td><code>createdAt</code></td>\n<td><code>Date</code></td>\n<td>When the room was created. Useful for administrative cleanup of old, inactive rooms.</td>\n</tr>\n<tr>\n<td><code>memberIds</code></td>\n<td><code>Set&lt;string&gt;</code></td>\n<td>A collection of user IDs (usernames) who are currently present in the room. Using a <code>Set</code> ensures each user appears only once and provides O(1) membership tests. This set is updated in real-time as users join and leave.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> The <code>memberIds</code> field uses a <code>Set</code> rather than an <code>Array</code> for efficient membership testing (<code>Set.has()</code> is O(1) vs <code>Array.includes()</code> which is O(n)). This performance difference becomes critical when broadcasting messages to rooms with hundreds of members.</p>\n</blockquote>\n<h4 id=\"clientsession\">ClientSession</h4>\n<p>A <code>ClientSession</code> represents an <strong>active WebSocket connection</strong> from a specific user on a specific device. Think of it as a <strong>telephone handset</strong>—it&#39;s the physical connection through which a user participates in conversations. Each <code>ClientSession</code> links a low-level WebSocket object to a specific user identity (<code>userId</code>) and contains metadata about the connection itself.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description &amp; Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>connectionId</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for this specific WebSocket connection. Generated when the connection is established (e.g., using a UUID). Used to reference this specific session in message routing and disconnection handling.</td>\n</tr>\n<tr>\n<td><code>socket</code></td>\n<td><code>WebSocket</code></td>\n<td>The actual WebSocket object provided by your WebSocket library (e.g., <code>ws</code> in Node.js). This is the raw communication channel for sending and receiving data. The <code>readyState</code> property indicates if the connection is open, closing, or closed.</td>\n</tr>\n<tr>\n<td><code>userId</code></td>\n<td><code>string</code></td>\n<td>The username of the authenticated user associated with this connection. References the <code>User.username</code> field. A single user may have multiple <code>ClientSession</code> objects if connected from multiple devices.</td>\n</tr>\n<tr>\n<td><code>ip</code></td>\n<td><code>string</code></td>\n<td>The IP address of the client connection. Useful for logging, rate limiting, and security monitoring. Captured during the initial HTTP upgrade request.</td>\n</tr>\n<tr>\n<td><code>userAgent</code></td>\n<td><code>string</code></td>\n<td>The User-Agent header from the client&#39;s initial HTTP request. Helps identify client types (browser, mobile app, bot) for debugging and analytics.</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight:</strong> Storing the raw <code>WebSocket</code> object directly in the <code>ClientSession</code> is a pragmatic choice for this learning-focused implementation. In production systems, you might wrap the socket with additional abstractions to handle reconnections, message batching, and protocol upgrades, but for clarity and simplicity, we keep the direct reference.</p>\n</blockquote>\n<p>The relationship between these core types is visualized in the following diagram, which shows how users connect via sessions, join rooms, and send messages:</p>\n<p><img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fdata-model-diagram.svg\" alt=\"Core Data Relationships\"></p>\n<h3 id=\"wire-format-and-event-protocol\">Wire Format and Event Protocol</h3>\n<p>If the core types are the DNA, the wire format is the <strong>language spoken between clients and servers</strong>. All communication over WebSocket connections follows a consistent JSON-based protocol where clients and servers exchange structured &quot;events&quot; with typed payloads. This protocol defines the vocabulary and grammar of your chat application—what can be said, how it&#39;s structured, and what responses are expected.</p>\n<blockquote>\n<p><strong>Mental Model:</strong> Think of the WebSocket connection as a two-way radio channel. Clients and servers don&#39;t just send raw text back and forth—they send structured &quot;radio messages&quot; with a standard format: &quot;This is Unit A to Base, message type: STATUS_REPORT, payload: {battery: 85%, location: grid B7}&quot;. The message type tells the receiver how to interpret the payload, and both sides agree on the meaning of each message type beforehand.</p>\n</blockquote>\n<h4 id=\"websocketmessage-envelope\">WebSocketMessage Envelope</h4>\n<p>Every message sent over the WebSocket connection, regardless of direction (client→server or server→client), is wrapped in a standard envelope structure called <code>WebSocketMessage</code>. This envelope provides metadata about the message content and enables extensibility for future message types.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>type</code></td>\n<td><code>string</code></td>\n<td>Yes</td>\n<td>Identifies the kind of event or action this message represents. Must be one of the predefined <code>EVENT_*</code> constants (e.g., <code>EVENT_CHAT_MESSAGE</code>, <code>EVENT_USER_JOINED</code>). This field tells the receiver which handler to invoke and how to parse the payload.</td>\n</tr>\n<tr>\n<td><code>payload</code></td>\n<td><code>any</code> (JSON-serializable)</td>\n<td>Yes</td>\n<td>The data content specific to this message type. Structure varies by message type—see the Event Catalog below. Must be valid JSON (objects, arrays, strings, numbers, booleans, null).</td>\n</tr>\n<tr>\n<td><code>timestamp</code></td>\n<td><code>string</code> (ISO 8601)</td>\n<td>No (optional)</td>\n<td>When the sender created this message. For server-originated messages, this is always populated. For client messages, the server will typically ignore client-provided timestamps and assign its own upon receipt to maintain a single source of truth.</td>\n</tr>\n</tbody></table>\n<p><strong>Example Wire Format:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"chat_message\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"payload\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"sender\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"alice\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"content\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Hello everyone!\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"roomId\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"general\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"timestamp\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2024-01-15T10:30:45.123Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<blockquote>\n<p><strong>Design Insight:</strong> Using a consistent envelope format (<code>type</code> + <code>payload</code>) rather than free-form JSON messages makes the protocol self-describing and extensible. New message types can be added without breaking existing clients (as long as they ignore unknown types), and the type field enables efficient routing to appropriate handler functions.</p>\n</blockquote>\n<h4 id=\"event-catalog\">Event Catalog</h4>\n<p>The following table catalogues the standard event types that form the complete vocabulary of the chat protocol. These constants should be defined in your codebase and used consistently by both client and server implementations.</p>\n<table>\n<thead>\n<tr>\n<th>Event Constant</th>\n<th>Value</th>\n<th>Direction</th>\n<th>Purpose &amp; Payload Structure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EVENT_CHAT_MESSAGE</code></td>\n<td><code>&quot;chat_message&quot;</code></td>\n<td>Bidirectional</td>\n<td><strong>Client→Server:</strong> Sends a new chat message to a room. Payload: <code>{sender: string, content: string, roomId: string}</code>.<br><strong>Server→Client:</strong> Broadcasts a received message to all room members (excluding sender). Payload: A complete <code>ChatMessage</code> object with server-assigned <code>timestamp</code>.</td>\n</tr>\n<tr>\n<td><code>EVENT_USER_JOINED</code></td>\n<td><code>&quot;user_joined&quot;</code></td>\n<td>Server→Client</td>\n<td>Notifies existing room members that a new user has entered. Payload: <code>{username: string, roomId: string, timestamp: string}</code>. Typically sent after successful room join.</td>\n</tr>\n<tr>\n<td><code>EVENT_USER_LEFT</code></td>\n<td><code>&quot;user_left&quot;</code></td>\n<td>Server→Client</td>\n<td>Notifies room members that a user has left the room (either voluntarily or via disconnect). Payload: <code>{username: string, roomId: string, timestamp: string}</code>.</td>\n</tr>\n<tr>\n<td><code>EVENT_USER_TYPING</code></td>\n<td><code>&quot;user_typing&quot;</code></td>\n<td>Bidirectional</td>\n<td><strong>Client→Server:</strong> Indicates the user has started typing in a room. Payload: <code>{username: string, roomId: string, isTyping: boolean}</code> (where <code>isTyping</code> is <code>true</code> for start, <code>false</code> for stop).<br><strong>Server→Client:</strong> Broadcasts typing status to other room members. Payload same as client→server.</td>\n</tr>\n<tr>\n<td><code>EVENT_JOIN_ROOM</code></td>\n<td><code>&quot;join_room&quot;</code></td>\n<td>Client→Server</td>\n<td>Requests to join a specific chat room. Payload: <code>{roomId: string, username: string}</code>. Server validates authentication and room existence before granting access.</td>\n</tr>\n<tr>\n<td><code>EVENT_JOIN_ROOM_SUCCESS</code></td>\n<td><code>&quot;join_room_success&quot;</code></td>\n<td>Server→Client</td>\n<td>Response confirming successful room entry. Payload: <code>{roomId: string, roomName: string, members: string[], history: ChatMessage[]}</code>. Includes current member list and recent message history.</td>\n</tr>\n<tr>\n<td><code>EVENT_JOIN_ROOM_ERROR</code></td>\n<td><code>&quot;join_room_error&quot;</code></td>\n<td>Server→Client</td>\n<td>Response indicating room join failed. Payload: <code>{roomId: string, error: string}</code> with human-readable error message.</td>\n</tr>\n<tr>\n<td><code>EVENT_ROOM_LIST</code></td>\n<td><code>&quot;room_list&quot;</code></td>\n<td>Server→Client</td>\n<td>Response to room listing request. Payload: <code>{rooms: Array&lt;{id: string, name: string, memberCount: number}&gt;}</code>.</td>\n</tr>\n<tr>\n<td><code>EVENT_PRESENCE_UPDATE</code></td>\n<td><code>&quot;presence_update&quot;</code></td>\n<td>Server→Client</td>\n<td>Broadcasts changes in user online/offline status across the system (not room-specific). Payload: <code>{username: string, isOnline: boolean, lastSeen: string}</code>.</td>\n</tr>\n<tr>\n<td><code>EVENT_ERROR</code></td>\n<td><code>&quot;error&quot;</code></td>\n<td>Server→Client</td>\n<td>Generic error response for malformed messages, authentication failures, or server errors. Payload: <code>{code: string, message: string, originalEventType: string}</code>.</td>\n</tr>\n<tr>\n<td><code>EVENT_HEARTBEAT</code></td>\n<td><code>&quot;heartbeat&quot;</code></td>\n<td>Bidirectional</td>\n<td>Periodic ping/pong messages to keep connection alive and detect disconnections. Payload: <code>{sequence: number}</code> (monotonically increasing number).</td>\n</tr>\n</tbody></table>\n<h4 id=\"architecture-decision-structured-events-vs-ad-hoc-messages\">Architecture Decision: Structured Events vs. Ad-Hoc Messages</h4>\n<blockquote>\n<p><strong>Decision: Use Typed JSON Event Protocol</strong></p>\n<ul>\n<li><strong>Context:</strong> We need a communication protocol between client and server over WebSocket that supports multiple message types (chat, presence, typing indicators, etc.) with varying payload structures. The protocol must be easy to implement, debug, and extend.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Free-form JSON with implicit type:</strong> Send JSON objects with varying structures and infer meaning from field presence (e.g., <code>{text: &quot;hello&quot;}</code> is a chat message, <code>{typing: true}</code> is a typing indicator).</li>\n<li><strong>String prefix protocol:</strong> Send messages as strings with a type prefix and delimiter (e.g., <code>&quot;CHAT|alice|Hello&quot;</code> or <code>&quot;TYPING|alice|true&quot;</code>).</li>\n<li><strong>Structured JSON with explicit type field:</strong> Send JSON objects with a <code>type</code> field identifying the message type and a <code>payload</code> field containing type-specific data.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Option 3—structured JSON with explicit type field.</li>\n<li><strong>Rationale:</strong> <ul>\n<li><strong>Self-documenting:</strong> The <code>type</code> field makes messages immediately understandable during debugging.</li>\n<li><strong>Extensible:</strong> New message types can be added without breaking existing parsing logic.</li>\n<li><strong>Type-safe:</strong> On TypeScript clients, we can define discriminated unions based on the <code>type</code> field for compile-time validation.</li>\n<li><strong>Consistent with industry patterns:</strong> Similar to Redux actions, Socket.io events, and other event-driven architectures developers may encounter.</li>\n</ul>\n</li>\n<li><strong>Consequences:</strong><ul>\n<li>Slightly larger payload size due to the additional <code>type</code> field and nested <code>payload</code> structure.</li>\n<li>Requires proper validation of the <code>type</code> field against allowed values.</li>\n<li>Encourages a clean separation between message routing logic and message handling logic.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Free-form JSON</td>\n<td>Minimal overhead, simple to create</td>\n<td>Hard to extend, difficult to debug, ambiguous parsing</td>\n<td>Too fragile—adding new message types requires modifying parsing logic</td>\n</tr>\n<tr>\n<td>String prefix</td>\n<td>Very compact, fast parsing</td>\n<td>Not self-describing, hard to nest complex data</td>\n<td>Poor developer experience, error-prone string manipulation</td>\n</tr>\n<tr>\n<td><strong>Structured JSON</strong></td>\n<td><strong>Self-documenting, extensible, type-safe</strong></td>\n<td><strong>Slightly larger payloads</strong></td>\n<td><strong>CHOSEN: Best balance of clarity and practicality</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls-protocol-design-mistakes\">Common Pitfalls: Protocol Design Mistakes</h4>\n<p>⚠️ <strong>Pitfall: Inconsistent Payload Structures</strong></p>\n<ul>\n<li><strong>Description:</strong> Using different field names or structures for the same event type in different parts of the codebase (e.g., sending <code>user</code> in some places but <code>username</code> in others for <code>EVENT_USER_JOINED</code>).</li>\n<li><strong>Why it&#39;s wrong:</strong> Clients break because they expect consistent payloads. Debugging becomes difficult as you need to trace where each variant originates.</li>\n<li><strong>Fix:</strong> Define payload interfaces/types for each event and reuse them everywhere. Consider creating factory functions that generate properly structured events.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Missing Timestamps on Server-Originated Events</strong></p>\n<ul>\n<li><strong>Description:</strong> Forgetting to include the <code>timestamp</code> field in messages sent from server to client.</li>\n<li><strong>Why it&#39;s wrong:</strong> Clients cannot properly order messages from different sources or display &quot;time ago&quot; indicators. Message history becomes ambiguous.</li>\n<li><strong>Fix:</strong> Always add a <code>timestamp</code> field with <code>new Date().toISOString()</code> for server-originated messages. Create a helper function <code>createServerMessage(type, payload)</code> that automatically adds the timestamp.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Not Validating Client-Provided Payloads</strong></p>\n<ul>\n<li><strong>Description:</strong> Trusting that clients will always send valid, well-formed payloads according to the expected schema.</li>\n<li><strong>Why it&#39;s wrong:</strong> Malicious clients or buggy implementations can send malformed data that crashes the server or causes undefined behavior.</li>\n<li><strong>Fix:</strong> Validate every incoming message against a schema (using libraries like <code>joi</code>, <code>zod</code>, or manual checks). Check required fields, data types, string lengths, and value ranges before processing.</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Ignoring Unknown Message Types</strong></p>\n<ul>\n<li><strong>Description:</strong> When receiving a message with an unrecognized <code>type</code> field, throwing an error or crashing.</li>\n<li><strong>Why it&#39;s wrong:</strong> Prevents forward compatibility—if you deploy a server with new message types, older clients will crash when they receive messages they don&#39;t understand.</li>\n<li><strong>Fix:</strong> Log a warning for unknown message types but don&#39;t crash. Silently ignore or send a generic &quot;unsupported message type&quot; error response.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<blockquote>\n<p><strong>Target Language:</strong> JavaScript/Node.js (with TypeScript types for clarity where helpful)</p>\n</blockquote>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning Focus)</th>\n<th>Advanced Option (Production Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Message Serialization</strong></td>\n<td>Native <code>JSON.parse()</code> and <code>JSON.stringify()</code></td>\n<td>Schema validation with <code>zod</code> or <code>joi</code> before parsing</td>\n</tr>\n<tr>\n<td><strong>Type Safety</strong></td>\n<td>Manual type checking with <code>typeof</code> and <code>Array.isArray()</code></td>\n<td>TypeScript with strict mode and discriminated unions</td>\n</tr>\n<tr>\n<td><strong>Date Handling</strong></td>\n<td>JavaScript <code>Date</code> objects and <code>toISOString()</code></td>\n<td><code>date-fns</code> or <code>luxon</code> for robust date manipulation</td>\n</tr>\n<tr>\n<td><strong>Unique IDs</strong></td>\n<td><code>crypto.randomUUID()</code> (Node.js 15+) or <code>uuid</code> package</td>\n<td>ULID or NanoID for time-ordered, URL-safe IDs</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<p>Place data model definitions and protocol constants in a dedicated module for easy import throughout your codebase:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── package.json\n├── src/\n│   ├── server/\n│   │   ├── index.js              # Server entry point\n│   │   ├── connectionManager.js  # Component Design: WebSocket Server\n│   │   ├── roomManager.js        # Component Design: Message Broker &amp; Room Manager\n│   │   ├── authService.js        # Component Design: Persistence &amp; Authentication\n│   │   └── models/               # DATA MODEL FILES GO HERE\n│   │       ├── types.js          # Core type definitions (ChatMessage, User, etc.)\n│   │       ├── protocol.js       # Event constants and wire format utilities\n│   │       └── validation.js     # Schema validation for incoming messages\n│   ├── client/\n│   │   └── public/               # HTML/JS client files\n│   └── shared/                   # Code shared between client and server\n│       └── protocol.js           # Shared event constants (if using module bundler)\n└── tests/\n    └── unit/\n        └── models/               # Tests for data model validation</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>Create a complete, reusable module for message validation and serialization. This code handles the boilerplate of parsing JSON, validating structure, and ensuring type safety:</p>\n<p><strong>File: <code>src/server/models/validation.js</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validation utilities for WebSocket messages and data models</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> MAX_MESSAGE_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validates a raw WebSocket message string as a valid WebSocketMessage envelope</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> rawMessage</span><span style=\"color:#6A737D\"> - Raw string received from WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {{type: string, payload: any, timestamp?: string} | null}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {Error}</span><span style=\"color:#6A737D\"> If message is not valid JSON or lacks required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> parseAndValidateWebSocketMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> parsed</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(rawMessage);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate required fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> parsed.type </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> parsed.type.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must have a non-empty string \"type\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parsed.payload </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> undefined</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must have a \"payload\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Optional timestamp validation if present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (parsed.timestamp </span><span style=\"color:#F97583\">!==</span><span style=\"color:#79B8FF\"> undefined</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> parsed.timestamp </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Timestamp must be a string if provided'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Validate ISO format (basic check)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">\\d</span><span style=\"color:#F97583\">{4}</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#79B8FF\">\\d</span><span style=\"color:#F97583\">{2}</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#79B8FF\">\\d</span><span style=\"color:#F97583\">{2}</span><span style=\"color:#DBEDFF\">T</span><span style=\"color:#79B8FF\">\\d</span><span style=\"color:#F97583\">{2}</span><span style=\"color:#DBEDFF\">:</span><span style=\"color:#79B8FF\">\\d</span><span style=\"color:#F97583\">{2}</span><span style=\"color:#DBEDFF\">:</span><span style=\"color:#79B8FF\">\\d</span><span style=\"color:#F97583\">{2}</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">test</span><span style=\"color:#E1E4E8\">(parsed.timestamp)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Timestamp must be in ISO 8601 format'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      type: parsed.type.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      payload: parsed.payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      timestamp: parsed.timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enhance error message for JSON parsing errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (error </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#B392F0\"> SyntaxError</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Invalid JSON: ${</span><span style=\"color:#E1E4E8\">error</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#E1E4E8\"> error;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validates a ChatMessage payload structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - The payload to validate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {{sender: string, content: string, roomId: string, timestamp: string}}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {Error}</span><span style=\"color:#6A737D\"> If payload does not match ChatMessage structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> validateChatMessagePayload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> payload </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'object'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> payload </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Chat message payload must be an object'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">sender</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">content</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">timestamp</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> payload;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> sender </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> sender.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Chat message must have a non-empty sender field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Chat message must have a string content field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (content.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> MAX_MESSAGE_LENGTH</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Message content exceeds maximum length of ${</span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#9ECBFF\">} characters`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> roomId </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> roomId.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Chat message must have a non-empty roomId field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Server should assign timestamp, but validate if provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (timestamp </span><span style=\"color:#F97583\">!==</span><span style=\"color:#79B8FF\"> undefined</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> timestamp </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Chat message timestamp must be a string if provided'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sender: sender.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: content.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roomId: roomId.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: timestamp </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a properly formatted WebSocketMessage for server-originated events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> type</span><span style=\"color:#6A737D\"> - Event type (use protocol constants)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - Event-specific payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#6A737D\"> JSON string ready to send over WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createServerMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  parseAndValidateWebSocketMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  validateChatMessagePayload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createServerMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  MAX_MESSAGE_LENGTH</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>Here are the skeleton implementations for the key data model handling functions that you&#39;ll need to implement:</p>\n<p><strong>File: <code>src/server/models/types.js</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Core type definitions and factory functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Event constants - must match exactly with NAMING CONVENTIONS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> EVENT_CHAT_MESSAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'chat_message'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> EVENT_USER_JOINED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'user_joined'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> EVENT_USER_TYPING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'user_typing'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add other event constants from the Event Catalog here...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new ChatMessage object with server-assigned timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> sender</span><span style=\"color:#6A737D\"> - Username of the sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> content</span><span style=\"color:#6A737D\"> - Message content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - Room identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#6A737D\"> A complete ChatMessage object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createChatMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sender</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">content</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 1: Validate that sender is a non-empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 2: Validate that content is a string and doesn't exceed MAX_MESSAGE_LENGTH</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 3: Validate that roomId is a non-empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 4: Generate a timestamp using new Date().toISOString()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 5: Return an object with fields: sender, content, timestamp, roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 6: Ensure all string fields are trimmed of surrounding whitespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new Room object with initial empty member set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> name</span><span style=\"color:#6A737D\"> - Human-readable room name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Room}</span><span style=\"color:#6A737D\"> A new Room object with generated id and creation timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 1: Validate that name is a non-empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 2: Generate a unique room ID (consider using crypto.randomUUID() or a URL-safe slug)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 3: Create a new empty Set for memberIds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 4: Record current timestamp as createdAt (Date object)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 5: Return an object with fields: id, name, createdAt, memberIds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 6: Sanitize room name to prevent injection attacks (remove special chars)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a ClientSession object linking a WebSocket to a user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocket}</span><span style=\"color:#E1E4E8\"> socket</span><span style=\"color:#6A737D\"> - The WebSocket connection object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> userId</span><span style=\"color:#6A737D\"> - Authenticated username</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> ip</span><span style=\"color:#6A737D\"> - Client IP address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> userAgent</span><span style=\"color:#6A737D\"> - Client User-Agent header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {ClientSession}</span><span style=\"color:#6A737D\"> A new ClientSession object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createClientSession</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ip</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userAgent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 1: Validate that socket is a valid WebSocket object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 2: Validate that userId is a non-empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 3: Generate a unique connectionId (consider using crypto.randomUUID())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 4: Return an object with fields: connectionId, socket, userId, ip, userAgent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 5: Store the IP and UserAgent as provided (no need to validate format)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  EVENT_CHAT_MESSAGE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  EVENT_USER_JOINED,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  EVENT_USER_TYPING,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createChatMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createRoom,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createClientSession</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ol>\n<li><p><strong>Use <code>Map</code> for Connection Tracking:</strong> When storing <code>ClientSession</code> objects by <code>connectionId</code>, use a <code>Map</code> instead of a plain object for better performance with frequent additions/deletions and built-in iteration methods.</p>\n</li>\n<li><p><strong>Validate Early and Often:</strong> Always validate incoming WebSocket messages immediately after parsing. Don&#39;t trust client data. Use the validation utilities provided above.</p>\n</li>\n<li><p><strong>ISO Timestamps for Consistency:</strong> Always use <code>new Date().toISOString()</code> for timestamps in wire format. This ensures UTC timezone and consistent format across all clients.</p>\n</li>\n<li><p><strong>Trim User Input:</strong> Always call <code>.trim()</code> on string fields from clients (usernames, room names, message content) to remove accidental leading/trailing whitespace.</p>\n</li>\n<li><p><strong>Use Sets for Membership:</strong> When tracking room members, use JavaScript&#39;s <code>Set</code> object for O(1) membership tests and automatic deduplication.</p>\n</li>\n<li><p><strong>Weak References for Large Data:</strong> Consider using <code>WeakMap</code> or <code>WeakSet</code> if you need to associate metadata with WebSocket objects without preventing garbage collection, though for this learning project, a regular <code>Map</code> is fine.</p>\n</li>\n</ol>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the data model and protocol:</p>\n<ol>\n<li><p><strong>Start your server</strong> and open the browser console on your client page.</p>\n</li>\n<li><p><strong>Manually test the WebSocket connection</strong> by creating a raw WebSocket message in the console:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Assuming your WebSocket is stored in a variable named `ws`</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   const</span><span style=\"color:#79B8FF\"> testMessage</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     type: </span><span style=\"color:#9ECBFF\">'chat_message'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     payload: {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       sender: </span><span style=\"color:#9ECBFF\">'testuser'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       content: </span><span style=\"color:#9ECBFF\">'Hello world!'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       roomId: </span><span style=\"color:#9ECBFF\">'general'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   ws.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(testMessage));</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Expected behavior:</strong></p>\n<ul>\n<li>Server should log the parsed message with type and payload</li>\n<li>Server should validate the message structure</li>\n<li>Server should reject malformed JSON with an error response</li>\n<li>Server should reject messages missing required fields</li>\n</ul>\n</li>\n<li><p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li><strong>Server crashes on message:</strong> Check your JSON parsing error handling</li>\n<li><strong>Message ignored silently:</strong> Verify you&#39;re calling your message handlers</li>\n<li><strong>Validation not working:</strong> Test with intentionally bad data to ensure validation catches it</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Messages appear with wrong timestamp&quot;</td>\n<td>Client is sending timestamps and server is using them instead of assigning its own</td>\n<td>Check server logs to see if incoming messages have timestamp fields</td>\n<td>Always overwrite timestamp with server time in <code>createChatMessage</code></td>\n</tr>\n<tr>\n<td>&quot;Duplicate users in room member list&quot;</td>\n<td>Using array instead of Set for <code>memberIds</code>, or not checking if user already exists before adding</td>\n<td>Log room members before/after join operations</td>\n<td>Use <code>Set</code> for <code>memberIds</code> and check <code>Set.has()</code> before adding</td>\n</tr>\n<tr>\n<td>&quot;Server crashes when receiving malformed JSON&quot;</td>\n<td>No try-catch around <code>JSON.parse()</code></td>\n<td>Send a non-JSON string like &quot;invalid&quot; to the WebSocket</td>\n<td>Wrap <code>JSON.parse()</code> in try-catch and send error response</td>\n</tr>\n<tr>\n<td>&quot;Event types are case-sensitive mismatches&quot;</td>\n<td>Using different casing for constants in client vs server (e.g., &#39;chat_message&#39; vs &#39;CHAT_MESSAGE&#39;)</td>\n<td>Compare the <code>type</code> field values in server logs with your constant definitions</td>\n<td>Use exactly the same string constants in both client and server code</td>\n</tr>\n<tr>\n<td>&quot;Very long messages crash the server&quot;</td>\n<td>Not validating message length before processing</td>\n<td>Send a 10,000 character message</td>\n<td>Add length check in <code>validateChatMessagePayload</code> against <code>MAX_MESSAGE_LENGTH</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"component-design-websocket-server-amp-connection-manager\">Component Design: WebSocket Server &amp; Connection Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (WebSocket Server Setup). This component forms the foundational communication layer of the entire system, responsible for establishing and maintaining persistent connections with all clients.</p>\n</blockquote>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The <strong>WebSocket Server &amp; Connection Manager</strong> is the gateway and traffic controller for all real-time communication in the chat application. It sits at the network boundary and has three core responsibilities:</p>\n<ol>\n<li><strong>Protocol Handling</strong>: Manages the low-level WebSocket protocol, including accepting HTTP upgrade requests, establishing persistent connections, and handling the raw binary/text frames defined by RFC 6455.</li>\n<li><strong>Connection State Management</strong>: Maintains a real-time inventory of all active client connections, tracking their lifecycle from establishment through normal operation to termination (whether graceful or abrupt).</li>\n<li><strong>Message Routing Foundation</strong>: Acts as the initial entry point for all incoming real-time traffic, performing basic validation and routing messages to the appropriate higher-level business logic components (like the Room Manager).</li>\n</ol>\n<p>This component <strong>owns</strong> the following:</p>\n<ul>\n<li>The raw WebSocket connection objects for each client</li>\n<li>The mapping between connection identifiers and their underlying sockets</li>\n<li>Basic connection metadata (IP address, user agent, connection timestamp)</li>\n<li>The heartbeat/ping-pong mechanism for detecting dead connections</li>\n</ul>\n<p>This component <strong>does NOT own</strong>:</p>\n<ul>\n<li>User authentication state (delegated to Auth Service)</li>\n<li>Room membership information (delegated to Room Manager)</li>\n<li>Message persistence (delegated to Persistence Service)</li>\n<li>Business logic for chat operations (delegated to appropriate handlers)</li>\n</ul>\n<p>The scope is deliberately narrow: think of this component as the telephone company&#39;s switching hardware—it ensures calls can be connected and stay connected, but doesn&#39;t understand the content of the conversations or who should be talking to whom.</p>\n<h3 id=\"mental-model-the-telephone-switchboard-operator\">Mental Model: The Telephone Switchboard Operator</h3>\n<p>Imagine a bustling hotel in the 1950s. Guests (clients) arrive and want to make phone calls to other guests&#39; rooms. The <strong>switchboard operator</strong> (our WebSocket Server) has a physical panel with:</p>\n<ul>\n<li><strong>Jacks (sockets)</strong>: One for each guest room that wants phone service</li>\n<li><strong>Cords (connections)</strong>: Physical wires connecting callers</li>\n<li><strong>Indicator lights (heartbeats)</strong>: Showing which lines are still active</li>\n</ul>\n<p>When a new guest checks in (client connects), the operator plugs a jack into their room&#39;s socket. When the guest picks up the phone and says &quot;Connect me to Room 237&quot; (client sends a <code>join</code> message), the operator doesn&#39;t just blindly connect wires—they check if Room 237 exists (room validation), verify the guest is allowed to call there (authentication), then physically connect the cords (routing).</p>\n<p>The operator maintains a <strong>switchboard directory</strong> (connection map) showing which jack corresponds to which room. If a light goes out (connection drops), the operator immediately removes that jack from the board and notifies anyone who might be trying to call that room (cleanup and notification).</p>\n<p>This mental model captures several key concepts:</p>\n<ul>\n<li><strong>Persistent connections</strong> = physical jacks plugged in</li>\n<li><strong>Message routing</strong> = operator connecting the right cords</li>\n<li><strong>Connection tracking</strong> = the switchboard directory</li>\n<li><strong>Heartbeat detection</strong> = indicator lights showing line activity</li>\n<li><strong>Graceful degradation</strong> = operator can still work if some lights fail</li>\n</ul>\n<blockquote>\n<p><strong>Design Insight</strong>: The WebSocket Server is infrastructure, not business logic. Its job is to move bytes reliably, not understand what those bytes mean. This separation allows the business logic (rooms, messages, users) to evolve independently of the communication layer.</p>\n</blockquote>\n<h3 id=\"interface-and-connection-lifecycle\">Interface and Connection Lifecycle</h3>\n<p>Every WebSocket connection follows a predictable lifecycle with distinct states and events. The server must handle each transition appropriately.</p>\n<h4 id=\"connection-state-machine\">Connection State Machine</h4>\n<p>The following table describes the complete state machine for a client connection. Reference the state diagram: <img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fconn-state-machine.svg\" alt=\"WebSocket Connection State Machine\"></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event Trigger</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>None</em></td>\n<td>HTTP Upgrade request received</td>\n<td><code>Connecting</code></td>\n<td>1. Validate HTTP headers 2. Check authentication token (if required) 3. Generate unique <code>connectionId</code> 4. Send 101 Switching Protocols response</td>\n</tr>\n<tr>\n<td><code>Connecting</code></td>\n<td>WebSocket handshake completes successfully</td>\n<td><code>Connected</code></td>\n<td>1. Create <code>ClientSession</code> object 2. Add to connection tracking map 3. Start heartbeat timer (ping/pong) 4. Log connection event 5. Send <code>connection_established</code> event to client</td>\n</tr>\n<tr>\n<td><code>Connected</code></td>\n<td>Client sends valid <code>join_room</code> message</td>\n<td><code>Joined</code></td>\n<td>1. Validate room exists/user can join 2. Register with Room Manager 3. Update session with <code>roomId</code> 4. Send <code>room_joined</code> confirmation with history</td>\n</tr>\n<tr>\n<td><code>Joined</code></td>\n<td>Client sends <code>leave_room</code> message</td>\n<td><code>Connected</code></td>\n<td>1. Unregister from Room Manager 2. Clear session <code>roomId</code> 3. Send <code>room_left</code> confirmation</td>\n</tr>\n<tr>\n<td><code>Connected</code> or <code>Joined</code></td>\n<td>Client sends <code>chat_message</code></td>\n<td><em>Same state</em></td>\n<td>1. Parse and validate message 2. Forward to Room Manager for broadcasting 3. Acknowledge receipt to sender</td>\n</tr>\n<tr>\n<td><code>Connected</code> or <code>Joined</code></td>\n<td>Ping timeout (no pong received)</td>\n<td><code>Disconnected</code></td>\n<td>1. Mark connection as dead 2. Clean up from all tracking structures 3. Notify Room Manager of user departure</td>\n</tr>\n<tr>\n<td><code>Connected</code> or <code>Joined</code></td>\n<td>Socket <code>close</code> event received</td>\n<td><code>Disconnected</code></td>\n<td>1. Remove from connection map 2. Clear heartbeat timer 3. Notify Room Manager (if joined)</td>\n</tr>\n<tr>\n<td><code>Connected</code> or <code>Joined</code></td>\n<td>Socket <code>error</code> event</td>\n<td><code>Disconnected</code></td>\n<td>1. Log error details 2. Force socket closure 3. Perform same cleanup as <code>close</code> event</td>\n</tr>\n<tr>\n<td><code>Disconnected</code></td>\n<td>Cleanup completed</td>\n<td><em>None</em></td>\n<td>Memory released, no further actions</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-interface-methods\">Core Interface Methods</h4>\n<p>The Connection Manager exposes the following public API to other components:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>startServer</code></td>\n<td><code>port: number</code>, <code>options: Object</code></td>\n<td><code>Promise&lt;void&gt;</code></td>\n<td>Binds to specified port, starts listening for HTTP/WebSocket connections</td>\n</tr>\n<tr>\n<td><code>handleUpgrade</code></td>\n<td><code>request: HTTPRequest</code>, <code>socket: NetSocket</code>, <code>head: Buffer</code></td>\n<td><code>void</code></td>\n<td>Processes HTTP upgrade request, validates, establishes WebSocket connection</td>\n</tr>\n<tr>\n<td><code>handleMessage</code></td>\n<td><code>socket: WebSocket</code>, `rawMessage: string</td>\n<td>Buffer`</td>\n<td><code>void</code></td>\n</tr>\n<tr>\n<td><code>sendToClient</code></td>\n<td><code>connectionId: string</code>, <code>message: WebSocketMessage</code></td>\n<td><code>boolean</code></td>\n<td>Sends formatted message to specific client if socket is open; returns success/failure</td>\n</tr>\n<tr>\n<td><code>broadcastToAll</code></td>\n<td><code>message: WebSocketMessage</code>, <code>excludeConnectionId?: string</code></td>\n<td><code>void</code></td>\n<td>Sends message to all connected clients (rarely used directly)</td>\n</tr>\n<tr>\n<td><code>getActiveConnections</code></td>\n<td>-</td>\n<td><code>Map&lt;string, ClientSession&gt;</code></td>\n<td>Returns copy of current connection map for monitoring/debugging</td>\n</tr>\n<tr>\n<td><code>closeConnection</code></td>\n<td><code>connectionId: string</code>, <code>code: number</code>, <code>reason: string</code></td>\n<td><code>boolean</code></td>\n<td>Gracefully closes specified connection with WebSocket close frame</td>\n</tr>\n<tr>\n<td><code>getConnectionStats</code></td>\n<td>-</td>\n<td><code>{ total: number, byState: Object }</code></td>\n<td>Returns statistics about current connections</td>\n</tr>\n</tbody></table>\n<h4 id=\"event-handlers-internal-interface\">Event Handlers (Internal Interface)</h4>\n<p>The component reacts to these WebSocket-native events:</p>\n<table>\n<thead>\n<tr>\n<th>Event</th>\n<th>Handler Method</th>\n<th>Typical Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>connection</code></td>\n<td><code>onConnection(socket, request)</code></td>\n<td>Create <code>ClientSession</code>, start heartbeat, log connection</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td><code>onMessage(socket, data)</code></td>\n<td>Call <code>handleMessage()</code>, validate, route to business logic</td>\n</tr>\n<tr>\n<td><code>close</code></td>\n<td><code>onClose(socket, code, reason)</code></td>\n<td>Clean up connection state, notify Room Manager, log disconnection</td>\n</tr>\n<tr>\n<td><code>error</code></td>\n<td><code>onError(socket, error)</code></td>\n<td>Log error, force closure, clean up (treat as disconnect)</td>\n</tr>\n<tr>\n<td><code>pong</code></td>\n<td><code>onPong(socket, data)</code></td>\n<td>Update last activity timestamp, mark connection as alive</td>\n</tr>\n</tbody></table>\n<h3 id=\"adr-managing-active-connections\">ADR: Managing Active Connections</h3>\n<blockquote>\n<p><strong>Decision: Use Map&lt;string, ClientSession&gt; for Connection Tracking</strong></p>\n<ul>\n<li><strong>Context</strong>: The server needs to maintain real-time awareness of all connected clients to route messages efficiently and perform cleanup. Each connection must be uniquely identifiable and quickly accessible.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Set of WebSocket objects</strong>: Simple collection of raw socket objects</li>\n<li><strong>Array of connection objects</strong>: Sequential storage with manual ID management</li>\n<li><strong>Map&lt;string, ClientSession&gt;</strong>: Key-value store with connection ID as key</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>Map&lt;string, ClientSession&gt;</code> where key is a unique <code>connectionId</code> and value is a <code>ClientSession</code> object containing the socket and metadata.</li>\n<li><strong>Rationale</strong>: <ul>\n<li><strong>Direct Access</strong>: <code>Map.get(connectionId)</code> is O(1) for targeted message sending</li>\n<li><strong>Built-in Iteration</strong>: <code>Map.forEach()</code> efficiently broadcasts to all connections</li>\n<li><strong>Automatic Cleanup</strong>: Deleting entries is explicit and clear (<code>Map.delete()</code>)</li>\n<li><strong>Metadata Association</strong>: <code>ClientSession</code> struct can hold user ID, IP, room ID, etc., alongside the raw socket</li>\n<li><strong>Memory Safety</strong>: Unlike Sets with object references, string keys prevent memory leaks from object resurrection</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Adds slight memory overhead for the <code>ClientSession</code> wrapper</li>\n<li>Requires generating and managing unique connection IDs</li>\n<li>Provides excellent foundation for future features like direct messaging and connection monitoring</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The following comparison table illustrates the trade-offs:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Set of WebSocket objects</strong></td>\n<td>Simple, no ID management, native WebSocket API</td>\n<td>No metadata storage, O(n) lookup for specific connections, harder to debug</td>\n<td>Insufficient for routing needs; can&#39;t associate user ID with socket</td>\n</tr>\n<tr>\n<td><strong>Array of connection objects</strong></td>\n<td>Maintains order, simple iteration</td>\n<td>O(n) lookup, manual ID management, inefficient removals</td>\n<td>Performance degrades with hundreds of connections</td>\n</tr>\n<tr>\n<td><strong>Map&lt;string, ClientSession&gt;</strong></td>\n<td>O(1) lookup, clean metadata association, easy iteration</td>\n<td>Requires ID generation, wrapper object overhead</td>\n<td><strong>CHOSEN</strong>: Best balance of performance, functionality, and clarity</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-memory-leaks-and-silent-failures\">Common Pitfalls: Memory Leaks and Silent Failures</h3>\n<p>Building a WebSocket server involves several subtle traps that can cause gradual degradation or sudden failure. Here are the most common pitfalls and how to avoid them:</p>\n<h4 id=\"-pitfall-1-zombie-connections-not-cleaning-up-on-disconnect\">⚠️ <strong>Pitfall 1: Zombie Connections - Not Cleaning Up on Disconnect</strong></h4>\n<p><strong>The Mistake</strong>: Only removing connections on explicit <code>close</code> events, ignoring error conditions, timeouts, or network interruptions that don&#39;t trigger proper close frames.\n<strong>Why It&#39;s Wrong</strong>: Dead connections accumulate in the tracking map, causing memory leaks. The server continues trying to send messages to dead sockets, wasting CPU and potentially crashing when buffers fill.\n<strong>How to Fix</strong>: Implement a <strong>defense-in-depth cleanup strategy</strong>:</p>\n<ol>\n<li>Always remove from tracking in BOTH <code>close</code> and <code>error</code> handlers</li>\n<li>Implement heartbeat (ping/pong) with timeout detection</li>\n<li>Add periodic sanity checks that iterate through connections and verify socket state</li>\n<li>Use weak references or finalizers if available (though JavaScript lacks these)</li>\n</ol>\n<h4 id=\"-pitfall-2-the-silent-swallow-missing-error-handlers\">⚠️ <strong>Pitfall 2: The Silent Swallow - Missing Error Handlers</strong></h4>\n<p><strong>The Mistake</strong>: Not attaching error handlers to WebSocket objects, assuming connections will always close gracefully.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BAD: Socket errors become unhandled exceptions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#6A737D\">/* process */</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GOOD: Explicit error handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Socket error for ${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">}:`</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">closeConnection</span><span style=\"color:#E1E4E8\">(connectionId, </span><span style=\"color:#79B8FF\">1011</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Internal error'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre></div>\n<p><strong>Why It&#39;s Wrong</strong>: Unhandled socket errors can crash the entire Node.js process. Even if they don&#39;t crash, failures become invisible, making debugging nearly impossible.\n<strong>How to Fix</strong>: Attach error handlers to EVERY socket, EVERY EventEmitter, and wrap ALL asynchronous operations in try/catch. Log errors with context (connectionId, user ID) for debugging.</p>\n<h4 id=\"-pitfall-3-the-forgotten-heartbeat-no-liveness-detection\">⚠️ <strong>Pitfall 3: The Forgotten Heartbeat - No Liveness Detection</strong></h4>\n<p><strong>The Mistake</strong>: Assuming connections remain alive because the TCP socket is open, ignoring &quot;half-open&quot; connections where the client disappeared without closing.\n<strong>Why It&#39;s Wrong</strong>: Network issues, client crashes, or NAT timeouts can leave sockets in a &quot;zombie&quot; state—technically open but unable to send/receive data. The server thinks users are online when they&#39;re not.\n<strong>How to Fix</strong>: Implement <strong>RFC 6455 ping/pong frames</strong>:</p>\n<ol>\n<li>Periodically send ping frames to each connection (every 30-60 seconds)</li>\n<li>Set a timer expecting a pong response within 10-15 seconds</li>\n<li>Close connections that miss too many pongs (typically 2-3 consecutive failures)</li>\n<li>Update <code>lastActive</code> timestamp on any received message (including pong)</li>\n</ol>\n<h4 id=\"-pitfall-4-ready-state-race-condition-sending-to-closing-sockets\">⚠️ <strong>Pitfall 4: Ready State Race Condition - Sending to Closing Sockets</strong></h4>\n<p><strong>The Mistake</strong>: Not checking <code>socket.readyState</code> before sending, causing &quot;Cannot send after socket closed&quot; errors.\n<strong>Why It&#39;s Wrong</strong>: Between checking if a connection exists and actually sending, the socket could close (especially under load). This throws unhandled exceptions.\n<strong>How to Fix</strong>: Always verify ready state AND catch send errors:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">sendToClient</span><span style=\"color:#E1E4E8\">(connectionId, message) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> session</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.connections.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">session) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Check state before sending</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (session.socket.readyState </span><span style=\"color:#F97583\">!==</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">cleanupConnection</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    session.socket.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(message));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Socket closed between check and send</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">cleanupConnection</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"-pitfall-5-unbounded-message-queue-no-backpressure-handling\">⚠️ <strong>Pitfall 5: Unbounded Message Queue - No Backpressure Handling</strong></h4>\n<p><strong>The Mistake</strong>: Accepting and queuing unlimited messages from clients without considering server capacity.\n<strong>Why It&#39;s Wrong</strong>: A malicious or buggy client could flood the server with messages, consuming memory and CPU, eventually causing out-of-memory crashes.\n<strong>How to Fix</strong>: Implement <strong>per-connection backpressure</strong>:</p>\n<ol>\n<li>Track number of unprocessed messages per connection</li>\n<li>Pause socket reception when backlog exceeds threshold (using <code>socket.pause()</code>)</li>\n<li>Resume when backlog clears</li>\n<li>Implement maximum message size validation (enforce <code>MAX_MESSAGE_LENGTH</code>)</li>\n<li>Close connections that consistently exceed limits</li>\n</ol>\n<h4 id=\"-pitfall-6-the-shared-mutability-trap-concurrent-modification\">⚠️ <strong>Pitfall 6: The Shared Mutability Trap - Concurrent Modification</strong></h4>\n<p><strong>The Mistake</strong>: Iterating over the connections Map while other code modifies it (adding/removing connections).\n<strong>Why It&#39;s Wrong</strong>: In Node.js&#39;s single-threaded event loop, this seems safe, but asynchronous callbacks can interleave, causing modification during iteration errors or skipped connections.\n<strong>How to Fix</strong>: Use defensive copying or proper locking:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SAFE: Create copy before iterating</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">broadcastToAll</span><span style=\"color:#E1E4E8\">(message, excludeConnectionId) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> connectionsCopy</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.connections);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  connectionsCopy.</span><span style=\"color:#B392F0\">forEach</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">session</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (connectionId </span><span style=\"color:#F97583\">!==</span><span style=\"color:#E1E4E8\"> excludeConnectionId) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">sendToClient</span><span style=\"color:#E1E4E8\">(connectionId, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"implementation-guidance-layer-2\">Implementation Guidance (Layer 2)</h3>\n<p>This section provides concrete implementation guidance for building the WebSocket Server &amp; Connection Manager in JavaScript/Node.js, focusing on the <code>ws</code> library (the most popular WebSocket implementation for Node.js).</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning)</th>\n<th>Production-Ready Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>WebSocket Library</strong></td>\n<td><code>ws</code> (minimal, RFC-compliant)</td>\n<td><code>ws</code> with extensions (<code>permessage-deflate</code> for compression)</td>\n</tr>\n<tr>\n<td><strong>HTTP Server</strong></td>\n<td>Node.js built-in <code>http</code> or <code>https</code></td>\n<td>Express.js + <code>express-ws</code> for API co-existence</td>\n</tr>\n<tr>\n<td><strong>Connection Tracking</strong></td>\n<td>In-memory <code>Map&lt;string, ClientSession&gt;</code></td>\n<td>Redis for distributed tracking (multi-server)</td>\n</tr>\n<tr>\n<td><strong>Heartbeat Mechanism</strong></td>\n<td>Manual ping/pong with <code>setInterval</code></td>\n<td><code>ws</code> built-in ping/pong with configurable interval</td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td><code>console.log</code> with timestamps</td>\n<td>Structured logging (Winston, Pino) with connection context</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── package.json\n├── tsconfig.json (if using TypeScript)\n├── src/\n│   ├── server.ts (or server.js)          # Main entry point\n│   ├── core/\n│   │   ├── ConnectionManager.ts          # THIS COMPONENT (primary file)\n│   │   ├── types.ts                      # Shared type definitions\n│   │   └── constants.ts                  `EVENT_*`, `MAX_MESSAGE_LENGTH`, etc.\n│   ├── services/\n│   │   ├── RoomManager.ts                # Milestone 2-3 component\n│   │   └── AuthService.ts                # Milestone 4 component\n│   ├── persistence/\n│   │   └── MessageStore.ts               # Milestone 4 persistence\n│   └── client/\n│       └── index.html                    # Basic web client\n└── tests/\n    └── ConnectionManager.test.ts</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Complete WebSocket Server Setup with HTTP Upgrade Handling</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: src/server.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> http</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'http'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">ConnectionManager</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./core/ConnectionManager'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">parseAndValidateWebSocketMessage</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./core/messageUtils'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create HTTP server (could be Express in more advanced setups)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> server</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">createServer</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">req</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">res</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Handle regular HTTP requests (health checks, static files, API)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (req.url </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> '/health'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    res.</span><span style=\"color:#B392F0\">writeHead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">200</span><span style=\"color:#E1E4E8\">, { </span><span style=\"color:#9ECBFF\">'Content-Type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'application/json'</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    res.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({ status: </span><span style=\"color:#9ECBFF\">'ok'</span><span style=\"color:#E1E4E8\">, connections: connectionManager.</span><span style=\"color:#B392F0\">getConnectionStats</span><span style=\"color:#E1E4E8\">() }));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Default 404 for other HTTP requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  res.</span><span style=\"color:#B392F0\">writeHead</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  res.</span><span style=\"color:#B392F0\">end</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create WebSocket server attached to HTTP server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> wss</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">({ </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  server,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  clientTracking: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// We'll handle tracking ourselves</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  maxPayload: </span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// 1MB max message size</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize connection manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> connectionManager</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Handle WebSocket connections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">wss.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'connection'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">request</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Extract connection info from request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> ip</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> request.headers[</span><span style=\"color:#9ECBFF\">'x-forwarded-for'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> request.socket.remoteAddress;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> userAgent</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> request.headers[</span><span style=\"color:#9ECBFF\">'user-agent'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">||</span><span style=\"color:#9ECBFF\"> 'unknown'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Generate unique connection ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> connectionId</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> generateConnectionId</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Create client session (user ID will be added after authentication in Milestone 4)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> session</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connectionId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    socket,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    userId: </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Will be set after auth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ip,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    userAgent,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    joinedAt: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastActivity: Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roomId: </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Current room, if any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Add to connection tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  connectionManager.</span><span style=\"color:#B392F0\">addConnection</span><span style=\"color:#E1E4E8\">(connectionId, session);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`[${</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#9ECBFF\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}] Connection established: ${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">} from ${</span><span style=\"color:#E1E4E8\">ip</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Send welcome message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  socket.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type: </span><span style=\"color:#9ECBFF\">'connection_established'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload: { connectionId, serverTime: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">() },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Set up message handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">rawData</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Update activity timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      session.lastActivity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Parse and validate message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> parseAndValidateWebSocketMessage</span><span style=\"color:#E1E4E8\">(rawData.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Route to appropriate handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      connectionManager.</span><span style=\"color:#B392F0\">handleMessage</span><span style=\"color:#E1E4E8\">(connectionId, message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Error processing message from ${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">}:`</span><span style=\"color:#E1E4E8\">, error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Send error back to client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      socket.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        type: </span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        payload: { message: </span><span style=\"color:#9ECBFF\">'Invalid message format'</span><span style=\"color:#E1E4E8\">, details: error.message },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Set up close handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'close'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`[${</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#9ECBFF\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}] Connection closed: ${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">}, code: ${</span><span style=\"color:#E1E4E8\">code</span><span style=\"color:#9ECBFF\">}, reason: ${</span><span style=\"color:#E1E4E8\">reason</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connectionManager.</span><span style=\"color:#B392F0\">removeConnection</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Set up error handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`[${</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#9ECBFF\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}] Socket error for ${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">}:`</span><span style=\"color:#E1E4E8\">, error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connectionManager.</span><span style=\"color:#B392F0\">removeConnection</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    socket.</span><span style=\"color:#B392F0\">terminate</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// Force close</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Set up pong handler for heartbeat</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'pong'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    session.lastActivity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start heartbeat mechanism</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">setInterval</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  connectionManager.</span><span style=\"color:#B392F0\">checkHeartbeats</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">30000</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// Check every 30 seconds</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> PORT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> process.env.</span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server.</span><span style=\"color:#B392F0\">listen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Server listening on port ${</span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`WebSocket endpoint: ws://localhost:${</span><span style=\"color:#79B8FF\">PORT</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to generate connection IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> generateConnectionId</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#9ECBFF\"> `conn_${</span><span style=\"color:#E1E4E8\">Date</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}_${</span><span style=\"color:#E1E4E8\">Math</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#9ECBFF\">().</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#9ECBFF\">).</span><span style=\"color:#B392F0\">substr</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Message Validation Utilities</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: src/core/messageUtils.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> constants</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./constants'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Parses and validates raw WebSocket message string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> rawMessage</span><span style=\"color:#6A737D\"> - Raw message from WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#6A737D\"> - Parsed and validated message object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {Error}</span><span style=\"color:#6A737D\"> - If message is invalid JSON or missing required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> parseAndValidateWebSocketMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Check message length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (rawMessage.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> constants.</span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Message exceeds maximum length of ${</span><span style=\"color:#E1E4E8\">constants</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#9ECBFF\">} characters`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  let</span><span style=\"color:#E1E4E8\"> parsed;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(rawMessage);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Invalid JSON format'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Validate required fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> parsed.type </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> parsed.type.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must have a non-empty \"type\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (parsed.payload </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> undefined</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must have a \"payload\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Add timestamp if not present</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">parsed.timestamp) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parsed.timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type: parsed.type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload: parsed.payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: parsed.timestamp,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validates ChatMessage payload structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - The payload to validate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {boolean}</span><span style=\"color:#6A737D\"> - True if valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {Error}</span><span style=\"color:#6A737D\"> - If validation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> validateChatMessagePayload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> payload </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'object'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> payload </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Payload must be an object'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> payload.content </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> payload.content.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message content must be a non-empty string'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (payload.content.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#F97583\"> ></span><span style=\"color:#E1E4E8\"> constants.</span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Message content exceeds ${</span><span style=\"color:#E1E4E8\">constants</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#9ECBFF\">} characters`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (payload.roomId </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> payload.roomId </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'roomId must be a string if provided'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (payload.sender </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> payload.sender </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'sender must be a string if provided'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates properly formatted WebSocketMessage for server-originated events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> type</span><span style=\"color:#6A737D\"> - Event type (use constants.EVENT_*)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - Message payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#6A737D\"> - Formatted message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createServerMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  parseAndValidateWebSocketMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  validateChatMessagePayload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createServerMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Connection Manager Class with TODOs</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// File: src/core/ConnectionManager.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">createServerMessage</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./messageUtils'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> constants</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./constants'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ADR Decision: Using Map for connection tracking</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// connectionId -> ClientSession</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a real app, these would be injected dependencies</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.roomManager </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Will be set after RoomManager is created</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.authService </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Will be set in Milestone 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Heartbeat configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.heartbeatInterval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 30 seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.heartbeatTimeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 10 seconds timeout for pong</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Adds a new connection to tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Unique connection identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {ClientSession}</span><span style=\"color:#E1E4E8\"> session</span><span style=\"color:#6A737D\"> - Session object with socket and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  addConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">session</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate parameters (connectionId must be string, session must have socket)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if connectionId already exists (log warning if it does)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add to connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up initial heartbeat timer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log connection addition for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Removes a connection from tracking and cleans up resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Connection to remove</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {number}</span><span style=\"color:#E1E4E8\"> closeCode</span><span style=\"color:#6A737D\"> - WebSocket close code (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> closeReason</span><span style=\"color:#6A737D\"> - Human-readable close reason (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  removeConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">closeCode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">closeReason</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up connection in Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If connection was in a room, notify RoomManager to remove from room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If socket is still open, send close frame with provided code/reason</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clear any heartbeat timers for this connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove from connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log removal with connectionId and reason</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Main entry point for handling incoming WebSocket messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Reference flowchart: ./diagrams/flowchart-message-handling.svg</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Which connection sent the message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#E1E4E8\"> message</span><span style=\"color:#6A737D\"> - Parsed and validated message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  handleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up connection in connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update lastActivity timestamp on the session</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Route message based on type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type is 'join_room': call handleJoinRoom(connectionId, message.payload)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type is 'leave_room': call handleLeaveRoom(connectionId, message.payload)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type is 'chat_message': call handleChatMessage(connectionId, message.payload)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type is 'typing_indicator': call handleTypingIndicator(connectionId, message.payload)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type is 'ping': send 'pong' response immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Unknown type: send error response back to client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Catch any errors during processing and send appropriate error response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Handles join room request from client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Connection wanting to join</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {object}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - Should contain roomId or roomName</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  handleJoinRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get connection from connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate payload has roomId or roomName</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If user is already in a room, call handleLeaveRoom first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call roomManager.joinRoom(connectionId, payload.roomId, payload.roomName)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: On success, update session.roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Send success response to client with room info and message history</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: On error, send error response to client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Handles chat message from client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Connection that sent the message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {object}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - Should contain content and optionally roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  handleChatMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get connection from connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate payload.content is non-empty string and within length limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If payload.roomId is provided, use it; otherwise use session.roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create ChatMessage object with sender from session.userId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Call roomManager.broadcastToRoom(roomId, chatMessage, excludeConnectionId)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Send acknowledgment back to sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: On error (e.g., not in a room), send error response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Sends a message to a specific client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Target connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#E1E4E8\"> message</span><span style=\"color:#6A737D\"> - Message to send</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {boolean}</span><span style=\"color:#6A737D\"> - True if sent successfully, false if failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  sendToClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up connection in connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If not found, return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check socket.readyState === WebSocket.OPEN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If not open, call removeConnection and return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Try to send message with JSON.stringify</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Catch any send errors, call removeConnection, return false</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: On success, return true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Broadcasts message to all connected clients</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#E1E4E8\"> message</span><span style=\"color:#6A737D\"> - Message to broadcast</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> excludeConnectionId</span><span style=\"color:#6A737D\"> - Optional connection to exclude (e.g., sender)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  broadcastToAll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">excludeConnectionId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create a copy of connections Map to avoid modification during iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each connection in the copy:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If connectionId !== excludeConnectionId, call sendToClient</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Log broadcast statistics (how many sent, how many failed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Checks heartbeats for all connections and removes dead ones</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  checkHeartbeats</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> now</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> deadConnections</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through connections Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each connection, calculate time since lastActivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If time > heartbeatInterval + heartbeatTimeout, mark as dead</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send ping to connections that haven't been pinged recently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For dead connections, add to deadConnections array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean up dead connections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deadConnections.</span><span style=\"color:#B392F0\">forEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Connection ${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">} heartbeat failed, removing`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">removeConnection</span><span style=\"color:#E1E4E8\">(connectionId, </span><span style=\"color:#79B8FF\">1001</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'Heartbeat timeout'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log heartbeat check results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Gets connection statistics for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {object}</span><span style=\"color:#6A737D\"> - Statistics about current connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getConnectionStats</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize stats object with total count and by-state breakdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through connections Map to collect:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Total connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Connections with userId set (authenticated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Connections with roomId set (in a room)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Connections grouped by userAgent (browser types)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return statistics object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { ConnectionManager };</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-javascriptnodejs\">E. Language-Specific Hints (JavaScript/Node.js)</h4>\n<ol>\n<li><p><strong>WebSocket Library Choice</strong>: Use <code>ws</code> (npm install ws). It&#39;s the most battle-tested WebSocket library for Node.js and implements the full RFC 6455 specification.</p>\n</li>\n<li><p><strong>Connection ID Generation</strong>: Use a combination of timestamp and random string to avoid collisions:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   function</span><span style=\"color:#B392F0\"> generateId</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     return</span><span style=\"color:#9ECBFF\"> `conn_${</span><span style=\"color:#E1E4E8\">Date</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#9ECBFF\">()</span><span style=\"color:#9ECBFF\">}_${</span><span style=\"color:#E1E4E8\">Math</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#9ECBFF\">().</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#9ECBFF\">).</span><span style=\"color:#B392F0\">substr</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Handling Large Numbers of Connections</strong>: Node.js can handle thousands of concurrent WebSocket connections, but you need to:</p>\n<ul>\n<li>Increase the <code>ulimit</code> on Linux/Mac: <code>ulimit -n 10000</code></li>\n<li>Use <code>socket.setTimeout()</code> to detect stalled connections</li>\n<li>Consider using the <code>cluster</code> module to utilize multiple CPU cores</li>\n</ul>\n</li>\n<li><p><strong>Memory Management</strong>: </p>\n<ul>\n<li>Regularly check <code>process.memoryUsage()</code> in production</li>\n<li>Remove all references to sockets when connections close</li>\n<li>Consider using <code>WeakMap</code> for auxiliary data if you don&#39;t need to iterate over it</li>\n</ul>\n</li>\n<li><p><strong>Error Handling Best Practices</strong>:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   // Always attach error handlers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Don't throw, log and clean up</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Socket error:'</span><span style=\"color:#E1E4E8\">, error);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">cleanupConnection</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   // Handle async errors in message processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     await</span><span style=\"color:#B392F0\"> someAsyncOperation</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Send error to client instead of crashing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     socket.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({ type: </span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, payload: { message: error.message } }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"6\">\n<li><strong>Testing WebSocket Servers</strong>: Use <code>ws</code> client in tests:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'server accepts connections'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> ws</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws://localhost:8080'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     await</span><span style=\"color:#F97583\"> new</span><span style=\"color:#79B8FF\"> Promise</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">resolve</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'open'</span><span style=\"color:#E1E4E8\">, resolve);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">     expect</span><span style=\"color:#E1E4E8\">(ws.readyState).</span><span style=\"color:#B392F0\">toBe</span><span style=\"color:#E1E4E8\">(WebSocket.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   });</span></span></code></pre></div>\n\n<h4 id=\"f-milestone-checkpoint-websocket-server-setup\">F. Milestone Checkpoint: WebSocket Server Setup</h4>\n<p>After implementing the Connection Manager:</p>\n<p><strong>Expected Behavior</strong>:</p>\n<ol>\n<li>Start the server: <code>node src/server.js</code></li>\n<li>Open browser console at <code>http://localhost:8080</code> (you&#39;ll need a basic HTML file)</li>\n<li>Connect via WebSocket: <code>new WebSocket(&#39;ws://localhost:8080&#39;)</code></li>\n<li>See connection established message in browser console</li>\n<li>See connection log in server terminal</li>\n</ol>\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><strong>Multiple Connections</strong>: Open multiple browser tabs, verify each gets unique connection ID</li>\n<li><strong>Heartbeat Detection</strong>: Wait 45+ seconds without sending messages, verify connections stay alive (pings sent)</li>\n<li><strong>Clean Disconnect</strong>: Close a browser tab, verify server logs the disconnect and removes from tracking</li>\n<li><strong>Error Handling</strong>: Send malformed JSON message, verify server sends error response instead of crashing</li>\n<li><strong>Memory Check</strong>: Connect/disconnect 10+ times rapidly, verify connection count returns to zero</li>\n</ol>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li><strong>&quot;Too many open files&quot; error</strong>: Need to increase system ulimit</li>\n<li><strong>Memory keeps growing</strong>: Connections aren&#39;t being cleaned up properly</li>\n<li><strong>Server crashes on message send</strong>: Missing <code>readyState</code> check or error handler</li>\n<li><strong>&quot;Cannot send after socket closed&quot;</strong>: Race condition between check and send</li>\n</ul>\n<p><strong>Debugging Commands</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check active connections</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080/health</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor memory usage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">node</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"setInterval(() => console.log(process.memoryUsage()), 5000)\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test WebSocket connection manually (install wscat)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">npm</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#79B8FF\"> -g</span><span style=\"color:#9ECBFF\"> wscat</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">wscat</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> ws://localhost:8080</span></span></code></pre></div>\n\n<hr>\n<h2 id=\"component-design-message-broker-amp-room-manager\">Component Design: Message Broker &amp; Room Manager</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Message Broadcasting), Milestone 3 (Chat Rooms)</p>\n</blockquote>\n<p>This component is the heart of the chat application&#39;s business logic. While the WebSocket Server &amp; Connection Manager handles the low-level plumbing of persistent connections, the Message Broker &amp; Room Manager orchestrates the meaningful interactions within those connections: who can talk to whom, where messages should go, and who is currently active. It transforms raw WebSocket connections into a structured chat system with rooms, presence, and targeted message delivery.</p>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The <strong>Message Broker &amp; Room Manager</strong> (hereafter &quot;Room Manager&quot;) is a stateful server-side component that sits atop the connection layer. Its core responsibilities are:</p>\n<ol>\n<li><strong>Room Management:</strong> Creating, tracking, and destroying logical chat rooms (<code>Room</code> objects). A room is a named channel where messages are broadcast to all members.</li>\n<li><strong>Membership Management:</strong> Maintaining, for each room, the set of active users (represented by their <code>connectionId</code>s). It adds users when they join and removes them when they leave or disconnect.</li>\n<li><strong>Message Routing:</strong> Receiving incoming <code>ChatMessage</code> events and delivering them to all current members of the relevant room, excluding the original sender (unless specified otherwise). This is the &quot;broadcast&quot; pattern.</li>\n<li><strong>Presence Tracking:</strong> Maintaining and broadcasting real-time status information about users. This includes:<ul>\n<li><strong>Online/Offline:</strong> Tracking which users are connected to the server.</li>\n<li><strong>Room Membership:</strong> Knowing which users are in which rooms.</li>\n<li><strong>Typing Indicators:</strong> Temporarily tracking and broadcasting when a user is actively composing a message in a specific room.</li>\n</ul>\n</li>\n<li><strong>State Querying:</strong> Providing answers to questions like &quot;What rooms exist?&quot;, &quot;How many users are in room &#39;general&#39;?&quot;, and &quot;What are the last 20 messages in room &#39;lobby&#39;?&quot; (the latter via the Persistence layer).</li>\n</ol>\n<p>Its scope ends at the boundary of the <code>ClientSession</code> and the <code>WebSocket</code>. It does not handle the raw WebSocket protocol, HTTP upgrades, or individual socket events. Instead, it operates on logical constructs (<code>connectionId</code>, <code>roomId</code>, <code>userId</code>) provided by the Connection Manager. It also defers permanent storage of messages and user credentials to the Persistence &amp; Authentication Service, with which it collaborates.</p>\n<h3 id=\"mental-model-the-publishing-house-and-subscribers\">Mental Model: The Publishing House and Subscribers</h3>\n<p>A helpful analogy for understanding this component is a <strong>Publishing House (or Magazine)</strong> and its <strong>Subscribers</strong>.</p>\n<ul>\n<li><strong>Each Chat Room is a distinct Magazine</strong> (e.g., &quot;Tech News&quot;, &quot;Sports Talk&quot;). The magazine has a title (<code>roomId</code>) and a list of current subscribers.</li>\n<li><strong>Users are Subscribers.</strong> When a user joins a room, they subscribe to that magazine. They will receive every new issue (message) published to it.</li>\n<li><strong>Sending a Message is Publishing an Issue.</strong> When a user sends a chat message to a room, they are publishing a new article to that magazine. The publishing house (Room Manager) immediately prints and mails a copy to every current subscriber of that magazine.</li>\n<li><strong>Typing Indicators are &quot;Writer at Work&quot; Signs.</strong> If a subscriber starts drafting a letter to the editor (typing a message), the publishing house can put up a small sign in the magazine&#39;s office window: &quot;John is writing...&quot;. This sign is visible to all other subscribers of that magazine.</li>\n<li><strong>The Connection Manager is the Postal Service.</strong> It doesn&#39;t care about the content of the magazines; its job is to reliably deliver envelopes (WebSocket frames) between the publishing house and the individual subscribers&#39; mailboxes (client browsers).</li>\n</ul>\n<p>This model clarifies the decoupling: the Room Manager decides <em>what</em> to send and <em>to whom</em>, while the Connection Manager handles the <em>how</em> of the actual delivery.</p>\n<h3 id=\"interface-core-methods-and-events\">Interface: Core Methods and Events</h3>\n<p>The Room Manager exposes a programmatic interface used primarily by the Connection Manager&#39;s message handlers. The following table details its key methods.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Method</th>\n<th align=\"left\">Parameters</th>\n<th align=\"left\">Returns</th>\n<th align=\"left\">Description &amp; Side Effects</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>joinRoom</code></td>\n<td align=\"left\"><code>connectionId: string</code>, <code>roomId: string</code>, <code>userId: string</code></td>\n<td align=\"left\"><code>Promise&lt;Room&gt;</code></td>\n<td align=\"left\">Adds the user&#39;s <code>connectionId</code> to the room&#39;s <code>memberIds</code> set. Fetches recent message history from persistence. Broadcasts an <code>EVENT_USER_JOINED</code> message to all other members of the room. Returns the updated <code>Room</code> object.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>leaveRoom</code></td>\n<td align=\"left\"><code>connectionId: string</code>, <code>roomId: string</code></td>\n<td align=\"left\"><code>void</code></td>\n<td align=\"left\">Removes the <code>connectionId</code> from the room&#39;s <code>memberIds</code> set. If the room becomes empty, it may be scheduled for cleanup (see ADR). Broadcasts an <code>EVENT_USER_LEFT</code> message to the remaining members.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>leaveAllRooms</code></td>\n<td align=\"left\"><code>connectionId: string</code></td>\n<td align=\"left\"><code>void</code></td>\n<td align=\"left\">Removes the given <code>connectionId</code> from every room&#39;s membership. Typically called during connection cleanup (user disconnect).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>broadcastToRoom</code></td>\n<td align=\"left\"><code>roomId: string</code>, <code>message: WebSocketMessage</code>, <code>excludeConnectionId?: string</code></td>\n<td align=\"left\"><code>void</code></td>\n<td align=\"left\">Retrieves the set of <code>memberIds</code> for the given <code>roomId</code>. Iterates through each <code>connectionId</code>, and for each one that is not the <code>excludeConnectionId</code>, calls <code>ConnectionManager.sendToClient(connectionId, message)</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>getRoomList</code></td>\n<td align=\"left\">-</td>\n<td align=\"left\"><code>Array&lt;{id: string, name: string, memberCount: number}&gt;</code></td>\n<td align=\"left\">Returns a snapshot of all active rooms and their current member counts. Used for room listing UI.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>setUserTyping</code></td>\n<td align=\"left\"><code>connectionId: string</code>, <code>roomId: string</code>, <code>isTyping: boolean</code></td>\n<td align=\"left\"><code>void</code></td>\n<td align=\"left\">Updates an internal map tracking which users are typing in which rooms. Broadcasts an <code>EVENT_USER_TYPING</code> message to all other members of the room with the user&#39;s status. Manages a timeout to automatically clear the typing state after inactivity (e.g., 3 seconds).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>getRoomMembers</code></td>\n<td align=\"left\"><code>roomId: string</code></td>\n<td align=\"left\"><code>Set&lt;string&gt;</code> (connectionIds)</td>\n<td align=\"left\">Returns the current set of <code>connectionId</code>s for a given room. Used for targeted operations and presence updates.</td>\n</tr>\n</tbody></table>\n<p><strong>Key Internal Events:</strong> The Room Manager also listens for events from the Connection Manager, primarily <code>connectionClosed(connectionId)</code>. Upon receiving this, it must call <code>leaveAllRooms(connectionId)</code> to ensure state consistency.</p>\n<h3 id=\"adr-in-memory-vs-external-room-state\">ADR: In-Memory vs. External Room State</h3>\n<blockquote>\n<p><strong>Decision: Store Room and Membership State In-Memory</strong></p>\n<ul>\n<li><strong>Context:</strong> The Room Manager needs fast, low-latency access to room membership data to route messages and track presence. This data is highly volatile (changes with every join/leave) and is only relevant to the currently running server instance. We must choose where to store this operational state.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>In-Memory Data Structures:</strong> Store <code>Room</code> objects (with <code>memberIds</code> sets) in a plain JavaScript <code>Map</code> within the Room Manager&#39;s process memory.</li>\n<li><strong>External Shared Database:</strong> Store room membership in a fast, external data store like Redis (key: <code>room:&lt;id&gt;:members</code>, value: set of <code>userId</code> or <code>connectionId</code>).</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Use <strong>In-Memory Data Structures</strong> for the learning implementation.</li>\n<li><strong>Rationale:</strong> This project has <strong>intermediate</strong> difficulty and focuses on learning WebSocket patterns, not distributed systems. Using in-memory structures drastically simplifies the code, eliminates network latency for membership checks, and requires no additional infrastructure (Redis). The primary con—lack of shared state across multiple servers—is acceptable because the non-goals explicitly exclude horizontal scaling for this version. It allows learners to focus on the core algorithms of room management without the complexity of distributed state synchronization.</li>\n<li><strong>Consequences:</strong><ul>\n<li><strong>Positive:</strong> Maximum performance for read/write operations, simple implementation, no external dependencies.</li>\n<li><strong>Negative:</strong> State is lost on server restart. All rooms and membership information vanish. This is acceptable for a learning project, as clients will reconnect and re-join rooms. It also means the system cannot run in a multi-server (load-balanced) configuration without a major redesign.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Option</th>\n<th align=\"left\">Pros</th>\n<th align=\"left\">Cons</th>\n<th align=\"left\">Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>In-Memory</strong></td>\n<td align=\"left\">1. <strong>Extremely low latency</strong> (no network calls).<br>2. <strong>Simple implementation</strong> (native <code>Map</code> and <code>Set</code>).<br>3. <strong>No external dependencies</strong> to set up or manage.</td>\n<td align=\"left\">1. <strong>State is ephemeral</strong> (lost on server crash/restart).<br>2. <strong>Does not scale</strong> beyond a single server process.<br>3. Harder to inspect/debug state externally.</td>\n<td align=\"left\"><strong>Yes</strong> – Aligns with project&#39;s learning focus and non-goals.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>External DB (e.g., Redis)</strong></td>\n<td align=\"left\">1. <strong>State survives server restarts.</strong><br>2. <strong>Enables horizontal scaling</strong> (multiple chat servers can share state).<br>3. State can be inspected with external tools.</td>\n<td align=\"left\">1. <strong>Adds complexity</strong> (requires Redis setup, connection pooling, serialization).<br>2. <strong>Introduces network latency</strong> for every membership operation.<br>3. <strong>New failure modes</strong> (Redis downtime, network partitions).</td>\n<td align=\"left\">No – Overcomplicates the core learning objectives.</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>This component has several subtle traps that can lead to confusing bugs.</p>\n<p>⚠️ <strong>Pitfall 1: Accidental Broadcast to Sender (Echo)</strong></p>\n<ul>\n<li><strong>Description:</strong> When <code>broadcastToRoom</code> is called without providing the <code>excludeConnectionId</code> parameter, the user who sent the message receives their own message back via the WebSocket. This creates a confusing &quot;echo&quot; in their own client and often leads to duplicate message display.</li>\n<li><strong>Why it&#39;s wrong:</strong> It wastes bandwidth and processing, and violates the typical user expectation in a chat app (you see your own message in the UI because your client rendered it optimistically on send, not because the server echoed it back).</li>\n<li><strong>Fix:</strong> <strong>Always pass the sender&#39;s <code>connectionId</code> as the <code>excludeConnectionId</code> argument</strong> when broadcasting a message they originated. The <code>broadcastToRoom</code> method must explicitly skip this connection.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 2: Zombie Rooms (Memory Leak)</strong></p>\n<ul>\n<li><strong>Description:</strong> When the last user leaves a room, the <code>Room</code> object and its <code>memberIds</code> Set remain in the server&#39;s memory indefinitely. If users dynamically create many rooms (e.g., <code>project-abc</code>, <code>temp-meeting</code>), the server&#39;s memory will slowly fill with empty, unused rooms.</li>\n<li><strong>Why it&#39;s wrong:</strong> It causes a memory leak, which can eventually crash the server under sustained use.</li>\n<li><strong>Fix:</strong> Implement a cleanup mechanism. The <code>leaveRoom</code> method should check if the room&#39;s <code>memberIds</code> set is empty after removal. If it is, start a <strong>configurable timeout</strong> (e.g., 5 minutes). If no one joins the room before the timeout elapses, delete the <code>Room</code> object from the in-memory map. This allows for temporary empty rooms without permanent accumulation.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 3: Unsanitized Room Names</strong></p>\n<ul>\n<li><strong>Description:</strong> Accepting arbitrary user input (the desired room name) as a room identifier without validation can lead to security and stability issues. A user could create a room named <code>../../../etc/passwd</code> or <code>&lt;/script&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>.</li>\n<li><strong>Why it&#39;s wrong:</strong> If the room name is used in file paths, database queries, or reflected in client HTML, it could enable path traversal, injection attacks, or cross-site scripting (XSS).</li>\n<li><strong>Fix:</strong> <strong>Sanitize and normalize room names.</strong> Convert to a safe internal <code>roomId</code>. For example:<ol>\n<li>Trim whitespace.</li>\n<li>Convert to lowercase.</li>\n<li>Replace any non-alphanumeric characters (except hyphens/underscores) with a hyphen.</li>\n<li>Enforce a reasonable length limit (e.g., 50 characters).</li>\n<li>Use this normalized string as the internal <code>roomId</code>. The original <code>name</code> can be stored for display but never used for logic.</li>\n</ol>\n</li>\n</ul>\n<p>⚠️ <strong>Pitfall 4: Race Condition in Typing Indicators</strong></p>\n<ul>\n<li><strong>Description:</strong> When a user stops typing, the client sends a <code>typing: false</code> event. If the user quickly starts typing again, the server might process the events out of order (due to network latency) resulting in the final state being <code>false</code> even though the user is actively typing.</li>\n<li><strong>Why it&#39;s wrong:</strong> The typing indicator for that user disappears prematurely, confusing other chat participants.</li>\n<li><strong>Fix:</strong> Use a <strong>last-write-wins approach with a sequence number or timestamp.</strong> Attach a monotonic increasing number or the client&#39;s timestamp to each typing event. The server only updates the typing state if the incoming event&#39;s number is greater than the one currently stored for that user/room. Alternatively, use a <strong>debounce pattern on the server:</strong> each <code>typing: true</code> event resets a user-specific timeout. The <code>typing: false</code> broadcast is only sent when that timeout fires without being reset.</li>\n</ul>\n<p>⚠️ <strong>Pitfall 5: Not Validating Membership Before Broadcast</strong></p>\n<ul>\n<li><strong>Description:</strong> The <code>broadcastToRoom</code> method blindly retrieves a list of <code>connectionId</code>s and attempts to send to each. If a user has just disconnected, their <code>connectionId</code> may still be in the set, causing <code>ConnectionManager.sendToClient</code> to fail or log an error.</li>\n<li><strong>Why it&#39;s wrong:</strong> It creates unnecessary error noise and wasted cycles. The room membership state (<code>memberIds</code>) becomes slightly stale.</li>\n<li><strong>Fix:</strong> <strong>The Connection Manager must be the source of truth for active connections.</strong> When <code>leaveAllRooms</code> is called (during disconnect cleanup), it removes the <code>connectionId</code> from all room sets. This ensures the membership set is accurate before the next broadcast cycle. The <code>broadcastToRoom</code> method can then iterate with confidence. Implement this as a synchronous call from the Connection Manager&#39;s <code>connectionClosed</code> handler to the Room Manager&#39;s <code>leaveAllRooms</code>.</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This guidance provides the skeletal structure for the Room Manager component in JavaScript (Node.js), following the design outlined above.</p>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Component</th>\n<th align=\"left\">Simple Option (Learning)</th>\n<th align=\"left\">Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>In-Memory Store</strong></td>\n<td align=\"left\">JavaScript <code>Map</code> and <code>Set</code></td>\n<td align=\"left\">Redis with Pub/Sub for distributed state &amp; messaging</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Message Routing</strong></td>\n<td align=\"left\">Iterative loop over connection IDs</td>\n<td align=\"left\">Topic-based Pub/Sub (Redis, NATS, Kafka)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Presence Tracking</strong></td>\n<td align=\"left\">In-memory maps with timeouts</td>\n<td align=\"left\">Redis Sorted Sets with heartbeats</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── server/\n│   ├── index.js                      # Main server entry point\n│   ├── connectionManager.js          # From Milestone 1\n│   ├── roomManager.js                # This component (NEW)\n│   ├── authService.js                # For Milestone 4\n│   ├── messageStore.js               # For Milestone 4\n│   └── utils/\n│       ├── validation.js             # parseAndValidateWebSocketMessage, etc.\n│       └── messageFactory.js         # createServerMessage, createChatMessage\n└── client/                           # Frontend HTML/CSS/JS</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p>The following is a complete, usable utility for creating standardized server messages. Place this in <code>server/utils/messageFactory.js</code>.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/utils/messageFactory.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a properly formatted WebSocketMessage for server-originated events.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> type</span><span style=\"color:#6A737D\"> - The event type (e.g., EVENT_CHAT_MESSAGE).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - The data payload for the event.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#6A737D\"> A structured message object ready for JSON.stringify.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createServerMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#6A737D\">// Server's authoritative timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new ChatMessage object with a server-assigned timestamp.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> sender</span><span style=\"color:#6A737D\"> - The username of the sender.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> content</span><span style=\"color:#6A737D\"> - The text content of the message.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - The ID of the room where the message was sent.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#6A737D\"> A new ChatMessage object.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createChatMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sender</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">content</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sender,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        roomId</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new Room object.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> name</span><span style=\"color:#6A737D\"> - The display name of the room.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Room}</span><span style=\"color:#6A737D\"> A new Room object with a generated ID.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Simple ID generation: sanitize name and add random suffix for uniqueness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> baseId</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> name.</span><span style=\"color:#B392F0\">toLowerCase</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">replace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">[</span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\">a-z0-9-_]</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#F97583\">g</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> randomSuffix</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Math.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">substring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> id</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> `${</span><span style=\"color:#E1E4E8\">baseId</span><span style=\"color:#9ECBFF\">}-${</span><span style=\"color:#E1E4E8\">randomSuffix</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        id,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        createdAt: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        memberIds: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Set</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#6A737D\">// Tracks connectionIds, not userIds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    createServerMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    createChatMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    createRoom</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p>The main Room Manager class skeleton. Place this in <code>server/roomManager.js</code>. The TODO comments map directly to the algorithmic steps described in the design.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/roomManager.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">createServerMessage</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./utils/messageFactory'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">EVENT_USER_JOINED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">EVENT_USER_LEFT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">EVENT_USER_TYPING</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./constants'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RoomManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">messageStore</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // In-memory store: Map&#x3C;roomId, Room></span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.rooms </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // In-memory store: Map&#x3C;connectionId, Set&#x3C;roomId>> (reverse lookup)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.connectionRooms </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Typing state: Map&#x3C;roomId, Map&#x3C;userId, {isTyping: boolean, timeoutId: NodeJS.Timeout}>></span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.typingState </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Dependencies</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.connectionManager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connectionManager; </span><span style=\"color:#6A737D\">// To send messages to clients</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.messageStore </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> messageStore; </span><span style=\"color:#6A737D\">// To fetch history (optional for Milestone 3, required for 4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Adds a connection to a room, fetches history, and notifies others.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> userId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;Room>}</span><span style=\"color:#6A737D\"> The joined room object.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#B392F0\"> joinRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if the room exists. If not, create it using createRoom(roomId).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Retrieve the Room object from this.rooms.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Check if the user (connectionId) is already a member. If so, you may want to return early or handle re-join.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Add the connectionId to the room's memberIds Set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update the reverse lookup (this.connectionRooms): add this roomId to the set for this connectionId.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 6: [For Milestone 4] Fetch recent message history for this room from this.messageStore (e.g., last 50 messages).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 7: Broadcast an EVENT_USER_JOINED message to all OTHER members of the room.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //         Use createServerMessage(EVENT_USER_JOINED, { userId, roomId }) and broadcastToRoom (excluding the new joiner).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 8: Return the Room object (and optionally the message history to be sent directly to the joiner).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Removes a connection from a specific room and notifies others.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    leaveRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Retrieve the Room object from this.rooms. If room doesn't exist, return.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Remove the connectionId from the room's memberIds Set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Update the reverse lookup: remove this roomId from the set for this connectionId.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Broadcast an EVENT_USER_LEFT message to the REMAINING members of the room.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Check if the room's memberIds set is now empty. If yes, schedule this room for cleanup (start a timer to delete it after X minutes).</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Removes a connection from all rooms it belongs to.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Called when a WebSocket connection is closed.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    leaveAllRooms</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Get the set of roomIds this connection is in from this.connectionRooms. If empty, return.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: For each roomId in the set, call this.leaveRoom(connectionId, roomId).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Delete the entry for this connectionId from this.connectionRooms.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Clear any typing indicators for this connection/user across all rooms.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Sends a message to all members of a room, excluding an optional connection.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> [excludeConnectionId]</span><span style=\"color:#6A737D\"> - The connectionId to exclude (usually the sender).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    broadcastToRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">excludeConnectionId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Retrieve the Room object. If room doesn't exist, log a warning and return.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Iterate over the room.memberIds Set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each memberConnectionId, if it is NOT equal to excludeConnectionId, call this.connectionManager.sendToClient(memberConnectionId, message).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //         Hint: Check the connection manager's method signature.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Updates and broadcasts a user's typing status in a room.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {boolean}</span><span style=\"color:#E1E4E8\"> isTyping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setUserTyping</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">isTyping</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Retrieve the userId for this connectionId from the connectionManager (you may need to expose a getSession method).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Get or create the typing state map for this room (from this.typingState).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: Clear any existing timeout for this user in this room to prevent premature \"stopped typing\" messages.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: If isTyping is true:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //          a. Store the new state (isTyping: true) and set a new timeout for 3000ms.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //          b. When the timeout fires, automatically call setUserTyping again with isTyping: false for this user/room.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //          c. Broadcast an EVENT_USER_TYPING message to all OTHER room members with { userId, roomId, isTyping: true }.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: If isTyping is false:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //          a. Clear the timeout and remove the user's state from the room's map.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //          b. If the room's map becomes empty, you can delete it from this.typingState.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        //          c. Broadcast an EVENT_USER_TYPING message with isTyping: false.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * Returns a list of all active rooms with their member counts.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Array&#x3C;{id: string, name: string, memberCount: number}>}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    getRoomList</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Initialize an empty array `roomList`.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Iterate over this.rooms.values().</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: For each Room object, push an object with id, name, and memberCount (room.memberIds.size) to roomList.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 4: Return roomList.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> RoomManager;</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<ul>\n<li><strong>Use <code>Set</code> for Membership:</strong> The <code>Room.memberIds</code> should be a JavaScript <code>Set</code> for O(1) addition, deletion, and lookup.</li>\n<li><strong>Maps for Fast Lookup:</strong> Use <code>Map</code> for <code>this.rooms</code> (keyed by <code>roomId</code>) and <code>this.connectionRooms</code> (keyed by <code>connectionId</code>). They preserve insertion order and are more efficient than plain objects for frequent additions/deletions.</li>\n<li><strong>Cleaning Timeouts:</strong> Always store the <code>timeoutId</code> returned by <code>setTimeout</code> when scheduling room cleanup or typing indicator expiration. Clear it with <code>clearTimeout(timeoutId)</code> if the room becomes non-empty again or the user starts typing again to prevent memory leaks.</li>\n<li><strong>Error Handling in Broadcast:</strong> Wrap the <code>this.connectionManager.sendToClient</code> call in a try-catch block or ensure the connection manager handles closed sockets gracefully and doesn&#39;t throw.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint\">F. Milestone Checkpoint</h4>\n<p>After implementing the Room Manager and integrating it with the Connection Manager from Milestone 1, you should be able to test core chat functionality.</p>\n<p><strong>Expected Behavior (Milestone 2 &amp; 3):</strong></p>\n<ol>\n<li>Start your server (<code>node server/index.js</code>).</li>\n<li>Open two different browser tabs to your client page.</li>\n<li>In Tab 1, join a room (e.g., &quot;general&quot;). You should see a system message confirming your join.</li>\n<li>In Tab 2, join the same room &quot;general&quot;. Tab 1 should now receive a &quot;user joined&quot; notification.</li>\n<li>Type a message in Tab 2 and send it. The message should appear in Tab 1&#39;s chat log, but <strong>not</strong> a second time in Tab 2 (no echo). The message should have a timestamp, sender name, and content.</li>\n<li>Start typing in Tab 1. After a brief delay, Tab 2 should show a &quot;User is typing...&quot; indicator, which disappears when you send the message or stop typing for a few seconds.</li>\n<li>In a third tab, join a different room (e.g., &quot;random&quot;). Messages sent in &quot;general&quot; should <strong>not</strong> appear in this tab, demonstrating room isolation.</li>\n</ol>\n<p><strong>Commands to Verify:</strong></p>\n<ul>\n<li>Observe server logs. You should see log entries for <code>joinRoom</code>, <code>broadcastToRoom</code>, and <code>leaveRoom</code> operations.</li>\n<li>Check that the number of active connections and room counts are logged correctly.</li>\n</ul>\n<p><strong>Signs of Trouble:</strong></p>\n<ul>\n<li><strong>Messages appear duplicated in sender&#39;s tab:</strong> You are not excluding the sender in <code>broadcastToRoom</code>.</li>\n<li><strong>&quot;User joined&quot; message appears for the user themselves:</strong> The <code>EVENT_USER_JOINED</code> broadcast is not excluding the new joiner.</li>\n<li><strong>Typing indicator never disappears:</strong> The timeout logic in <code>setUserTyping</code> is not correctly clearing or setting the state to false.</li>\n<li><strong>Server memory usage grows indefinitely as rooms are created/left:</strong> The &quot;zombie room&quot; cleanup in <code>leaveRoom</code> is not implemented.</li>\n</ul>\n<h2 id=\"component-design-persistence-amp-authentication-service\">Component Design: Persistence &amp; Authentication Service</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (User Authentication &amp; Persistence)</p>\n</blockquote>\n<p>This component provides the foundational services for <strong>user identity management</strong> and <strong>message persistence</strong>—two critical requirements for any production chat application. While the WebSocket Server and Room Manager handle real-time interactions, the Persistence &amp; Authentication Service ensures that user identities are verified, conversations are preserved, and historical context is available when users reconnect or join rooms.</p>\n<h3 id=\"responsibility-and-scope\">Responsibility and Scope</h3>\n<p>The Persistence &amp; Authentication Service operates as two logically separate but closely collaborating subsystems:</p>\n<table>\n<thead>\n<tr>\n<th>Subsystem</th>\n<th>Primary Responsibilities</th>\n<th>Key Data Managed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authentication Service</strong></td>\n<td>1. User registration and credential storage<br>2. Session creation and validation during WebSocket connection establishment<br>3. User profile management (username, status)<br>4. Session cleanup (expired/inactive sessions)</td>\n<td>- <code>User</code> records (username, password hash)<br>- Session tokens or cookies<br>- Authentication state per connection</td>\n</tr>\n<tr>\n<td><strong>Message Persistence Store</strong></td>\n<td>1. Storing <code>ChatMessage</code> objects with metadata (sender, room, timestamp)<br>2. Retrieving message history with pagination support<br>3. Room message count and statistics<br>4. Optional message archival/cleanup policies</td>\n<td>- <code>ChatMessage</code> objects indexed by room and timestamp<br>- Message ID sequencing<br>- Pagination cursors</td>\n</tr>\n</tbody></table>\n<p>The service interfaces with the <strong>WebSocket Server</strong> during connection establishment (for authentication) and with the <strong>Room Manager</strong> when messages need to be stored or retrieved. Its scope is deliberately bounded to identity and persistence concerns, leaving real-time routing and room state management to the Room Manager.</p>\n<h3 id=\"mental-model-the-library-archivist-and-security-guard\">Mental Model: The Library Archivist and Security Guard</h3>\n<p>To build intuition, imagine this service as two roles in a physical library:</p>\n<blockquote>\n<p><strong>The Security Guard (Authentication Service)</strong> stands at the entrance, checking library cards (sessions) before allowing anyone inside. They maintain a registry of valid members (<code>User</code> records) and issue temporary passes (sessions) that expire after a period of inactivity. When someone presents an expired or forged pass, the guard denies entry and logs the attempt.</p>\n</blockquote>\n<blockquote>\n<p><strong>The Library Archivist (Message Persistence Store)</strong> works in the stacks, meticulously cataloging every conversation that occurs in the library&#39;s reading rooms. They organize messages by room (like books by shelf), maintain a chronological index, and can retrieve specific conversations when patrons request them. The archivist doesn&#39;t participate in the conversations but ensures they&#39;re preserved for future reference.</p>\n</blockquote>\n<p>This mental model clarifies the separation of concerns: authentication is a <strong>gatekeeping</strong> function performed at entry points, while persistence is a <strong>record-keeping</strong> function that operates continuously in the background.</p>\n<h3 id=\"adr-when-to-authenticate-http-vs-websocket\">ADR: When to Authenticate - HTTP vs. WebSocket</h3>\n<blockquote>\n<p><strong>Decision: Authenticate During HTTP Upgrade, Not Via WebSocket Messages</strong></p>\n<p><strong>Context</strong>: WebSocket connections begin as HTTP requests that &quot;upgrade&quot; to the WebSocket protocol. We need to verify user identity before allowing them to establish a persistent connection and access chat features, but we have multiple timing options for performing this verification.</p>\n<p><strong>Options Considered</strong>:</p>\n<ol>\n<li><strong>HTTP Upgrade Authentication</strong>: Validate credentials/session during the initial HTTP upgrade request before establishing the WebSocket connection.</li>\n<li><strong>Custom WebSocket Authentication Message</strong>: Accept all WebSocket connections, then require clients to send a special authentication message as their first action.</li>\n<li><strong>Hybrid Approach</strong>: Use HTTP for initial handshake with tokens, then allow reauthentication via WebSocket messages for session renewal.</li>\n</ol>\n<p><strong>Decision</strong>: We chose Option 1 (HTTP Upgrade Authentication) as the primary authentication mechanism.</p>\n<p><strong>Rationale</strong>:</p>\n<ul>\n<li><strong>Security</strong>: Rejecting unauthenticated connections at the HTTP layer prevents resource consumption by unauthorized clients. The WebSocket connection is never established if authentication fails.</li>\n<li><strong>Simplicity</strong>: The authentication logic runs once at connection time, simplifying subsequent message handling (no need to check auth state on every message).</li>\n<li><strong>Established Pattern</strong>: This aligns with how production WebSocket services (like Socket.IO with middleware) typically handle authentication using HTTP cookies or tokens.</li>\n<li><strong>Early Failure</strong>: Clients receive immediate feedback (HTTP 401/403) rather than establishing a connection only to be disconnected later.</li>\n</ul>\n<p><strong>Consequences</strong>:</p>\n<ul>\n<li><strong>Positive</strong>: Reduced server load from unauthorized connections, cleaner client code (auth handled during connection setup), immediate user feedback on auth failures.</li>\n<li><strong>Negative</strong>: Requires session management via HTTP cookies or tokens, cannot easily change user identity without reconnecting, slightly more complex upgrade handler implementation.</li>\n<li><strong>Mitigation</strong>: We&#39;ll implement a simple token-based system where clients pass an authentication token in the upgrade request headers.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTP Upgrade Authentication</strong></td>\n<td>- Early rejection saves resources<br>- Single authentication point<br>- Aligns with security best practices</td>\n<td>- Requires token/cookie management<br>- Cannot reauthenticate without reconnecting</td>\n<td><strong>CHOSEN</strong>: Provides security and simplicity for learning context</td>\n</tr>\n<tr>\n<td><strong>WebSocket Message Authentication</strong></td>\n<td>- Flexible reauthentication<br>- Can support multiple auth methods</td>\n<td>- Unauthenticated connections consume resources<br>- Must validate auth on every message initially<br>- Complex state management</td>\n<td>Rejected due to security concerns and complexity</td>\n</tr>\n<tr>\n<td><strong>Hybrid Approach</strong></td>\n<td>- Best of both worlds<br>- Supports session renewal</td>\n<td>- Most complex implementation<br>- Overkill for learning context</td>\n<td>Rejected as overly complex for our needs</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-unbounded-history-and-session-leaks\">Common Pitfalls: Unbounded History and Session Leaks</h3>\n<p>⚠️ <strong>Pitfall: Loading Entire Message History Without Pagination</strong></p>\n<p><strong>Description</strong>: When a user joins a room, the server attempts to load all historical messages from the database, which could be thousands or millions of records.</p>\n<p><strong>Why It&#39;s Wrong</strong>: This causes severe performance issues:</p>\n<ul>\n<li>High memory consumption on both server and client</li>\n<li>Long loading times blocking other operations</li>\n<li>Potential denial of service if many users join simultaneously</li>\n<li>Network bandwidth exhaustion sending massive payloads</li>\n</ul>\n<p><strong>How to Fix</strong>: Implement <strong>pagination</strong> with a reasonable default limit (e.g., 50 most recent messages). Use cursor-based pagination where the client can request older messages on demand. Store only the necessary fields in memory, not entire message objects.</p>\n<hr>\n<p>⚠️ <strong>Pitfall: Never Expiring Sessions or Cleaning Up Stale Data</strong></p>\n<p><strong>Description</strong>: Sessions (<code>ClientSession</code> objects) remain in memory indefinitely after users disconnect, and old messages accumulate in the database without cleanup.</p>\n<p><strong>Why It&#39;s Wrong</strong>: This leads to resource exhaustion and stale state:</p>\n<ul>\n<li>Memory leaks as disconnected sessions accumulate</li>\n<li>Database bloat affecting query performance</li>\n<li>Security risk from indefinitely valid session tokens</li>\n<li>Incorrect presence information if stale sessions aren&#39;t cleaned</li>\n</ul>\n<p><strong>How to Fix</strong>: Implement <strong>TTL (Time-To-Live)</strong> policies:</p>\n<ol>\n<li>Sessions: Remove <code>ClientSession</code> after WebSocket disconnection + short grace period</li>\n<li>Authentication tokens: Set expiration times (e.g., 24 hours)</li>\n<li>Messages: Consider archival or deletion policies for very old messages</li>\n<li>Use heartbeat mechanisms to detect and clean up &quot;zombie&quot; connections</li>\n</ol>\n<hr>\n<p>⚠️ <strong>Pitfall: Storing Passwords in Plain Text</strong></p>\n<p><strong>Description</strong>: User passwords are stored as plain text strings in the database rather than as cryptographic hashes.</p>\n<p><strong>Why It&#39;s Wrong</strong>: This creates catastrophic security vulnerabilities:</p>\n<ul>\n<li>Database compromise exposes all user passwords</li>\n<li>Users who reuse passwords across sites are at risk</li>\n<li>Violates security best practices and potentially regulations</li>\n</ul>\n<p><strong>How to Fix</strong>: Always hash passwords using a <strong>key derivation function</strong> like bcrypt, scrypt, or Argon2. Store only the hash, never the plaintext. During authentication, hash the provided password and compare it to the stored hash.</p>\n<hr>\n<p>⚠️ <strong>Pitfall: No Validation or Sanitization of Persistent Data</strong></p>\n<p><strong>Description</strong>: User-generated content (messages, room names, usernames) is stored directly without validation, sanitization, or encoding.</p>\n<p><strong>Why It&#39;s Wrong</strong>: This enables multiple attack vectors:</p>\n<ul>\n<li><strong>XSS (Cross-Site Scripting)</strong>: Malicious scripts in messages execute in other users&#39; browsers</li>\n<li><strong>SQL/NoSQL Injection</strong>: If using string concatenation for queries</li>\n<li><strong>Data corruption</strong>: Invalid data breaks application logic</li>\n<li><strong>Storage abuse</strong>: Extremely large messages consume excessive resources</li>\n</ul>\n<p><strong>How to Fix</strong>: Implement <strong>layered validation</strong>:</p>\n<ol>\n<li><strong>Client-side</strong>: Basic validation for user experience</li>\n<li><strong>Server-side before storage</strong>: <ul>\n<li>Length limits (enforce <code>MAX_MESSAGE_LENGTH</code>)</li>\n<li>Character encoding/escaping</li>\n<li>Content type validation</li>\n<li>Sanitize HTML/script tags from messages</li>\n</ul>\n</li>\n<li><strong>Database layer</strong>: Use parameterized queries to prevent injection</li>\n</ol>\n<h3 id=\"interface-core-methods-and-events\">Interface: Core Methods and Events</h3>\n<p>The Authentication Service and Message Store expose the following interfaces to other components:</p>\n<h4 id=\"authentication-service-interface\">Authentication Service Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>authenticateConnection(request)</code></td>\n<td><code>request</code>: HTTP Upgrade request object</td>\n<td><code>{ success: boolean, user: User | null, error: string | null }</code></td>\n<td>Validates credentials/token from HTTP upgrade headers. Returns authenticated <code>User</code> object or error.</td>\n</tr>\n<tr>\n<td><code>registerUser(username, password)</code></td>\n<td><code>username</code>: string, <code>password</code>: string</td>\n<td><code>Promise&lt;{ success: boolean, user: User | null, error: string | null }&gt;</code></td>\n<td>Creates new user with hashed password. Validates uniqueness, password strength.</td>\n</tr>\n<tr>\n<td><code>validateSession(sessionToken)</code></td>\n<td><code>sessionToken</code>: string</td>\n<td><code>Promise&lt;{ valid: boolean, user: User | null }&gt;</code></td>\n<td>Validates existing session token without creating new connection. Used for reconnection.</td>\n</tr>\n<tr>\n<td><code>createSession(userId, connectionInfo)</code></td>\n<td><code>userId</code>: string, <code>connectionInfo</code>: { ip, userAgent }</td>\n<td><code>Promise&lt;string&gt;</code> (sessionToken)</td>\n<td>Creates a new session for an authenticated user, returning a token for future validation.</td>\n</tr>\n<tr>\n<td><code>invalidateSession(sessionToken)</code></td>\n<td><code>sessionToken</code>: string</td>\n<td><code>Promise&lt;boolean&gt;</code></td>\n<td>Removes session, effectively logging out the user from that device/connection.</td>\n</tr>\n</tbody></table>\n<h4 id=\"message-persistence-store-interface\">Message Persistence Store Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>storeMessage(message)</code></td>\n<td><code>message</code>: <code>ChatMessage</code> object</td>\n<td><code>Promise&lt;ChatMessage&gt;</code> (with assigned ID)</td>\n<td>Stores a chat message with timestamp, assigns unique ID, indexes by room and timestamp.</td>\n</tr>\n<tr>\n<td><code>getMessagesForRoom(roomId, options)</code></td>\n<td><code>roomId</code>: string, <code>options</code>: { limit: number, before: timestamp | null }</td>\n<td><code>Promise&lt;ChatMessage[]&gt;</code></td>\n<td>Retrieves messages for a room with pagination. <code>before</code> parameter enables fetching older messages.</td>\n</tr>\n<tr>\n<td><code>getRecentMessagesForRoom(roomId, limit)</code></td>\n<td><code>roomId</code>: string, <code>limit</code>: number (default: 50)</td>\n<td><code>Promise&lt;ChatMessage[]&gt;</code></td>\n<td>Convenience method for getting most recent messages when joining a room.</td>\n</tr>\n<tr>\n<td><code>getMessageCountForRoom(roomId)</code></td>\n<td><code>roomId</code>: string</td>\n<td><code>Promise&lt;number&gt;</code></td>\n<td>Returns total message count in a room (for statistics or UI indicators).</td>\n</tr>\n<tr>\n<td><code>deleteMessagesOlderThan(timestamp)</code></td>\n<td><code>timestamp</code>: ISO date string</td>\n<td><code>Promise&lt;number&gt;</code> (deleted count)</td>\n<td>Cleanup method for removing very old messages (optional, for maintenance).</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-flow-authentication-during-connection-establishment\">Data Flow: Authentication During Connection Establishment</h3>\n<p>The authentication process integrates with the WebSocket connection lifecycle described in previous sections:</p>\n<ol>\n<li><p><strong>Client initiates connection</strong>: Browser JavaScript attempts to establish WebSocket connection with server endpoint.</p>\n</li>\n<li><p><strong>HTTP Upgrade request</strong>: The WebSocket handshake begins as an HTTP GET request with <code>Upgrade: websocket</code> header.</p>\n</li>\n<li><p><strong>Authentication interceptor</strong>: The WebSocket Server&#39;s HTTP upgrade handler extracts authentication credentials (typically from <code>Authorization</code> header or cookie).</p>\n</li>\n<li><p><strong>Credential validation</strong>: The Authentication Service validates the token/session:</p>\n<ul>\n<li><strong>Valid session</strong>: Proceeds to step 5</li>\n<li><strong>Invalid/expired session</strong>: Returns HTTP 401 Unauthorized, connection fails</li>\n<li><strong>No credentials</strong>: Returns HTTP 403 Forbidden, connection fails</li>\n</ul>\n</li>\n<li><p><strong>User lookup</strong>: If credentials are valid, the Authentication Service retrieves the corresponding <code>User</code> object.</p>\n</li>\n<li><p><strong>Session creation</strong>: A new <code>ClientSession</code> is created linking the WebSocket connection to the authenticated user.</p>\n</li>\n<li><p><strong>WebSocket connection established</strong>: HTTP 101 Switching Protocols is sent, WebSocket protocol begins.</p>\n</li>\n<li><p><strong>Initialization message</strong>: Server sends <code>connection_established</code> event with user info and available rooms.</p>\n</li>\n</ol>\n<p>This flow ensures that <strong>every active WebSocket connection has an associated authenticated user</strong>, simplifying subsequent authorization checks (e.g., &quot;does this user have permission to post in this room?&quot;).</p>\n<h3 id=\"data-flow-message-persistence\">Data Flow: Message Persistence</h3>\n<p>When a chat message flows through the system (as shown in <img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fseq-send-message.svg\" alt=\"Sequence: Broadcasting a Chat Message\">), persistence occurs at a specific point:</p>\n<ol>\n<li><p><strong>Message reception</strong>: <code>ConnectionManager.handleMessage()</code> receives a <code>chat_message</code> event from a client.</p>\n</li>\n<li><p><strong>Validation and processing</strong>: The message is validated, a <code>ChatMessage</code> object is created with server timestamp.</p>\n</li>\n<li><p><strong>Storage before broadcast</strong>: Before broadcasting to room members, the Room Manager calls <code>MessageStore.storeMessage(message)</code> to persist it.</p>\n</li>\n<li><p><strong>Synchronous storage</strong>: The message is written to the database. In our learning implementation, we&#39;ll wait for confirmation before proceeding.</p>\n</li>\n<li><p><strong>Broadcast</strong>: Once storage is confirmed, the message is broadcast to room members.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight</strong>: We store <strong>before</strong> broadcasting to ensure no message is delivered to users without being persisted. This guarantees that if the server crashes between broadcast and storage, the message won&#39;t be lost entirely (it won&#39;t have been seen by anyone). This is a <strong>safety-first</strong> approach suitable for chat applications where message loss is more critical than minimal latency.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning)</th>\n<th>Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authentication Storage</strong></td>\n<td>In-memory JavaScript Map</td>\n<td>Redis (sessions) + PostgreSQL (users)</td>\n</tr>\n<tr>\n<td><strong>Message Storage</strong></td>\n<td>In-memory array with periodic file dump</td>\n<td>PostgreSQL with JSONB or dedicated message DB</td>\n</tr>\n<tr>\n<td><strong>Password Hashing</strong></td>\n<td>bcrypt library (npm <code>bcrypt</code>)</td>\n<td>bcrypt with appropriate work factor</td>\n</tr>\n<tr>\n<td><strong>Session Tokens</strong></td>\n<td>JSON Web Tokens (JWT)</td>\n<td>JWT with refresh token rotation</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── server/\n│   ├── index.js                    # Main server entry point\n│   ├── connection-manager.js       # From Milestone 1\n│   ├── room-manager.js             # From Milestones 2-3\n│   ├── auth-service.js             # THIS COMPONENT: Authentication logic\n│   ├── message-store.js            # THIS COMPONENT: Message persistence\n│   ├── models.js                   # Shared type definitions (User, ChatMessage, etc.)\n│   └── utils.js                    # Helper functions (hashing, validation)\n├── client/\n│   └── public/                     # HTML, CSS, client JavaScript\n└── package.json</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code-simple-in-memory-message-store\">C. Infrastructure Starter Code: Simple In-Memory Message Store</h4>\n<p>Here&#39;s a complete, working in-memory message store suitable for learning and development. This implements the <code>MessageStore</code> interface with basic pagination:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/message-store.js</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Simple in-memory message store with periodic persistence to file.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * For learning purposes only - not suitable for production.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> fs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'fs'</span><span style=\"color:#E1E4E8\">).promises;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> path</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'path'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InMemoryMessageStore</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">persistenceFile</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> './message-store.json'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">persistIntervalMs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30000</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messages </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// roomId -> Array&#x3C;ChatMessage></span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.persistenceFile </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> persistenceFile;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.persistIntervalMs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> persistIntervalMs;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.nextMessageId </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Load existing messages from file if it exists</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">loadFromFile</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">catch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">warn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Could not load message store from file:'</span><span style=\"color:#E1E4E8\">, err.message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set up periodic persistence</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.persistenceInterval </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> setInterval</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">persistToFile</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">catch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to persist messages:'</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistIntervalMs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Store a chat message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#E1E4E8\"> message</span><span style=\"color:#6A737D\"> - Must have roomId, sender, content, timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;ChatMessage>}</span><span style=\"color:#6A737D\"> - Message with assigned id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> storeMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate required fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">message.roomId </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">message.sender </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">message.content </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">message.timestamp) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message missing required fields'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assign unique ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> messageWithId</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      ...</span><span style=\"color:#E1E4E8\">message,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      id: </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.nextMessageId</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize room array if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(message.roomId)) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(message.roomId, []);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add to room's messages</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(message.roomId).</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(messageWithId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> messageWithId;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Get messages for a room with pagination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {Object}</span><span style=\"color:#E1E4E8\"> options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {number}</span><span style=\"color:#E1E4E8\"> options.limit</span><span style=\"color:#6A737D\"> - Maximum messages to return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string|null}</span><span style=\"color:#E1E4E8\"> options.before</span><span style=\"color:#6A737D\"> - ISO timestamp: return messages before this time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;ChatMessage[]>}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> getMessagesForRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">options</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">limit</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">before</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> options;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(roomId)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> roomMessages </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(roomId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Filter by 'before' timestamp if provided</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (before) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      roomMessages </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> roomMessages.</span><span style=\"color:#B392F0\">filter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> msg.timestamp </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> before);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sort by timestamp descending (newest first) and take limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> roomMessages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      .</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">(b.timestamp) </span><span style=\"color:#F97583\">-</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">(a.timestamp))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      .</span><span style=\"color:#B392F0\">slice</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, limit);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Convenience method for getting recent messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {number}</span><span style=\"color:#E1E4E8\"> limit</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;ChatMessage[]>}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> getRecentMessagesForRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limit</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">getMessagesForRoom</span><span style=\"color:#E1E4E8\">(roomId, { limit });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Get message count for a room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;number>}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> getMessageCountForRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(roomId) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(roomId).</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Save messages to disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@private</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> persistToFile</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> data</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      messages: Object.</span><span style=\"color:#B392F0\">fromEntries</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.messages),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      nextMessageId: </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.nextMessageId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      persistedAt: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> fs.</span><span style=\"color:#B392F0\">writeFile</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.persistenceFile,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      'utf-8'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Load messages from disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@private</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> loadFromFile</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> data</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> fs.</span><span style=\"color:#B392F0\">readFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistenceFile, </span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> parsed</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.messages </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(Object.</span><span style=\"color:#B392F0\">entries</span><span style=\"color:#E1E4E8\">(parsed.messages </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> {}));</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.nextMessageId </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parsed.nextMessageId </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Loaded ${</span><span style=\"color:#E1E4E8\">Array</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">from</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">messages</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">values</span><span style=\"color:#9ECBFF\">()).</span><span style=\"color:#B392F0\">flat</span><span style=\"color:#9ECBFF\">().</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#9ECBFF\">} messages from disk`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (err.code </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'ENOENT'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        throw</span><span style=\"color:#E1E4E8\"> err; </span><span style=\"color:#6A737D\">// Re-throw if it's not \"file not found\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Cleanup old messages (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> cutoffDate</span><span style=\"color:#6A737D\"> - ISO timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;number>}</span><span style=\"color:#6A737D\"> - Number of messages deleted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> deleteMessagesOlderThan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cutoffDate</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    let</span><span style=\"color:#E1E4E8\"> totalDeleted </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> cutoff</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">(cutoffDate);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">messages</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">of</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">entries</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> originalLength</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> messages.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> filtered</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> messages.</span><span style=\"color:#B392F0\">filter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> =></span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">(msg.timestamp) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> cutoff);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (filtered.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#F97583\"> !==</span><span style=\"color:#E1E4E8\"> originalLength) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.messages.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(roomId, filtered);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        totalDeleted </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> (originalLength </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> filtered.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> totalDeleted;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Graceful shutdown - persist before exiting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> shutdown</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    clearInterval</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.persistenceInterval);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">persistToFile</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Export a singleton instance</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> InMemoryMessageStore</span><span style=\"color:#E1E4E8\">();</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-authentication-service\">D. Core Logic Skeleton: Authentication Service</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/auth-service.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> bcrypt</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'bcrypt'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#FFAB70\">v4</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">uuidv4</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'uuid'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">User</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./models'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Authentication Service responsible for user registration, login,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and session management.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuthenticationService</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In-memory stores for learning purposes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.users </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// username -> User object</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.sessions </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// sessionToken -> { userId, createdAt, lastActivity }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.sessionTTL </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 24</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 60</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 24 hours in milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.saltRounds </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// For bcrypt hashing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize with a test user for development</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">initializeTestUser</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Authenticate a user during WebSocket upgrade</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {http.IncomingMessage}</span><span style=\"color:#E1E4E8\"> request</span><span style=\"color:#6A737D\"> - HTTP upgrade request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Object}</span><span style=\"color:#6A737D\"> { success: boolean, user: User|null, error: string|null }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  authenticateConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract authentication token from request headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look for 'Authorization' header with format 'Bearer &#x3C;token>'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // or check cookies if using cookie-based auth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If no token found, return { success: false, user: null, error: 'No credentials provided' }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate the session token using this.validateSession(token)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If session is valid, retrieve the User object from this.users</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update session's lastActivity timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return { success: true, user: userObject, error: null }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: If any step fails, return appropriate error message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Register a new user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> username</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> plainPassword</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;Object>}</span><span style=\"color:#6A737D\"> { success: boolean, user: User|null, error: string|null }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> registerUser</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">username</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">plainPassword</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate username (length, characters, uniqueness)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if username already exists in this.users</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate password strength (minimum length, complexity if desired)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Hash the password using bcrypt.hash(plainPassword, this.saltRounds)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create new User object with username, passwordHash, createdAt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store in this.users map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return success with user object (EXCLUDE passwordHash from returned object)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle errors (duplicate username, hashing failure, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Login existing user and create session</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> username</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> plainPassword</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;Object>}</span><span style=\"color:#6A737D\"> { success: boolean, sessionToken: string|null, error: string|null }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> loginUser</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">username</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">plainPassword</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find user by username in this.users</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If user not found, return { success: false, sessionToken: null, error: 'Invalid credentials' }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare provided password with stored hash using bcrypt.compare()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If password doesn't match, return same error as step 2 (security: don't reveal if user exists)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Generate a new session token (use uuidv4())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store session in this.sessions with userId, createdAt, lastActivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return { success: true, sessionToken: token, error: null }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Validate an existing session token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> sessionToken</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;Object>}</span><span style=\"color:#6A737D\"> { valid: boolean, user: User|null }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> validateSession</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sessionToken</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up session in this.sessions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If session not found, return { valid: false, user: null }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if session has expired (compare lastActivity + TTL to current time)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If expired, remove from this.sessions and return { valid: false, user: null }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If valid, update lastActivity timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Retrieve user from this.users and return { valid: true, user: userObject }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Create a session for an already-authenticated user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> userId</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {Object}</span><span style=\"color:#E1E4E8\"> connectionInfo</span><span style=\"color:#6A737D\"> - { ip: string, userAgent: string }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;string>}</span><span style=\"color:#6A737D\"> sessionToken</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> createSession</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">connectionInfo</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate new session token (uuidv4)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create session object with userId, createdAt, lastActivity, connectionInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store in this.sessions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return the session token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Invalidate (logout) a session</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> sessionToken</span><span style=\"color:#6A737D\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;boolean>}</span><span style=\"color:#6A737D\"> true if session was found and removed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> invalidateSession</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sessionToken</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if session exists in this.sessions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If exists, delete it and return true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If not found, return false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Clean up expired sessions (should be called periodically)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {number}</span><span style=\"color:#6A737D\"> count of sessions cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  cleanupExpiredSessions</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through this.sessions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each session, check if lastActivity + TTL &#x3C; current time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Delete expired sessions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return count of deleted sessions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Initialize with a test user for development</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@private</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> initializeTestUser</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> testUsername</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'testuser'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> testPassword</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'password123'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.users.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(testUsername)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> passwordHash</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> bcrypt.</span><span style=\"color:#B392F0\">hash</span><span style=\"color:#E1E4E8\">(testPassword, </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.saltRounds);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.users.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(testUsername, {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          username: testUsername,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          passwordHash,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          createdAt: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Test user created: ${</span><span style=\"color:#E1E4E8\">testUsername</span><span style=\"color:#9ECBFF\">} / ${</span><span style=\"color:#E1E4E8\">testPassword</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to create test user:'</span><span style=\"color:#E1E4E8\">, err);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Export a singleton instance</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> AuthenticationService</span><span style=\"color:#E1E4E8\">();</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-javascriptnodejs\">E. Language-Specific Hints (JavaScript/Node.js)</h4>\n<ul>\n<li><p><strong>Password Hashing</strong>: Use the <code>bcrypt</code> npm package. Install with <code>npm install bcrypt</code>. Always use <code>async/await</code> with bcrypt as the hashing is CPU-intensive and blocking the event loop would hurt performance.</p>\n</li>\n<li><p><strong>Session Tokens</strong>: Use <code>uuid</code> package for generating secure random tokens: <code>npm install uuid</code>. Version 4 (random) UUIDs are sufficient for learning. In production, consider signed tokens (JWT) for stateless validation.</p>\n</li>\n<li><p><strong>HTTP Header Parsing</strong>: In the <code>authenticateConnection</code> method, access headers via <code>request.headers[&#39;authorization&#39;]</code>. Remember header names are lowercase in Node.js&#39;s parsed headers object.</p>\n</li>\n<li><p><strong>Memory Management</strong>: The in-memory stores will grow indefinitely. For a learning project, this is acceptable, but add a <code>/debug</code> endpoint that shows memory usage and allows manual cleanup.</p>\n</li>\n<li><p><strong>Error Handling</strong>: Always use <code>try/catch</code> around async operations with bcrypt and file I/O. Return user-friendly error messages but log detailed errors server-side.</p>\n</li>\n</ul>\n<h4 id=\"f-integration-with-websocket-server\">F. Integration with WebSocket Server</h4>\n<p>Update your WebSocket server from Milestone 1 to integrate authentication:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In your main server file (server/index.js)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> authService</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./auth-service'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> http</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'http'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> server</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">createServer</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> wss</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">({ noServer: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">server.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'upgrade'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">request</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">head</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Authenticate before upgrading to WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> authResult</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> authService.</span><span style=\"color:#B392F0\">authenticateConnection</span><span style=\"color:#E1E4E8\">(request);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">authResult.success) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    socket.</span><span style=\"color:#B392F0\">write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'HTTP/1.1 401 Unauthorized</span><span style=\"color:#79B8FF\">\\r\\n\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    socket.</span><span style=\"color:#B392F0\">destroy</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Proceed with WebSocket upgrade for authenticated users</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  wss.</span><span style=\"color:#B392F0\">handleUpgrade</span><span style=\"color:#E1E4E8\">(request, socket, head, (</span><span style=\"color:#FFAB70\">ws</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create ClientSession linking ws to authenticated user</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> clientSession</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> createClientSession</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      ws, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      authResult.user.username,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      request.socket.remoteAddress,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      request.headers[</span><span style=\"color:#9ECBFF\">'user-agent'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    );</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Store in ConnectionManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connectionManager.</span><span style=\"color:#B392F0\">addClient</span><span style=\"color:#E1E4E8\">(clientSession);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send welcome message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ws.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      type: </span><span style=\"color:#9ECBFF\">'connection_established'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      payload: { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        user: authResult.user.username,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre></div>\n\n<h4 id=\"g-milestone-checkpoint-for-authentication-amp-persistence\">G. Milestone Checkpoint for Authentication &amp; Persistence</h4>\n<p>After implementing this component, verify your system works correctly:</p>\n<ol>\n<li><strong>Start the server</strong>: <code>node server/index.js</code></li>\n<li><strong>Test registration</strong> (via a simple curl or test client):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:3000/register</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"username\":\"alice\",\"password\":\"secure123\"}'</span></span></code></pre></div>\n<p>   Should return: <code>{&quot;success&quot;:true,&quot;user&quot;:{&quot;username&quot;:&quot;alice&quot;,&quot;createdAt&quot;:&quot;...&quot;}}</code></p>\n<ol start=\"3\">\n<li><strong>Test login</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:3000/login</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">     -d</span><span style=\"color:#9ECBFF\"> '{\"username\":\"alice\",\"password\":\"secure123\"}'</span></span></code></pre></div>\n<p>   Should return a session token.</p>\n<ol start=\"4\">\n<li><p><strong>Connect with WebSocket using authentication</strong>:</p>\n<ul>\n<li>Modify your client code to include the session token in WebSocket connection headers</li>\n<li>Verify connection succeeds with authenticated user</li>\n<li>Verify connection fails with invalid/no token</li>\n</ul>\n</li>\n<li><p><strong>Test message persistence</strong>:</p>\n<ul>\n<li>Send a chat message in a room</li>\n<li>Disconnect and reconnect</li>\n<li>Verify previous messages load when rejoining the room</li>\n<li>Check that only recent messages load (not entire history)</li>\n</ul>\n</li>\n<li><p><strong>Verify session cleanup</strong>:</p>\n<ul>\n<li>Connect and authenticate</li>\n<li>Disconnect client</li>\n<li>Wait for session TTL + grace period</li>\n<li>Try to reconnect with old token (should fail)</li>\n</ul>\n</li>\n</ol>\n<p><strong>Expected Behavior</strong>: Users can register, login, establish authenticated WebSocket connections, and see message history when joining rooms. Sessions expire appropriately, and passwords are securely hashed.</p>\n<p><strong>Troubleshooting</strong>:</p>\n<ul>\n<li>&quot;Registration fails with duplicate username&quot;: Check <code>users</code> Map for existing username</li>\n<li>&quot;Login fails even with correct password&quot;: Verify bcrypt.compare() is working (hashes must match exactly)</li>\n<li>&quot;Messages not loading on rejoin&quot;: Check <code>message-store.js</code> persistence file location and permissions</li>\n<li>&quot;Session valid after disconnect&quot;: Ensure <code>connectionManager.removeClient()</code> calls session cleanup</li>\n</ul>\n<hr>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Message Broadcasting), Milestone 3 (Chat Rooms), Milestone 4 (User Authentication &amp; Persistence) - for history loading and authentication</p>\n</blockquote>\n<p>This section traces the concrete journeys through our chat system. Understanding these flows—the precise sequence of events, data transformations, and component interactions—is crucial for building a mental model of how the system behaves under real conditions. We&#39;ll follow two fundamental user stories: sending a message to a room, and joining a room to participate in conversation.</p>\n<h3 id=\"sequence-sending-and-receiving-a-message\">Sequence: Sending and Receiving a Message</h3>\n<p><strong>Mental Model: The Party Conversation</strong>\nImagine a lively party where people gather in different rooms. When someone speaks in a room, their voice doesn&#39;t magically appear in everyone&#39;s ears—it travels through the air, is heard by others in the same room, and is also recorded in the party&#39;s official transcript. The chat system operates similarly: a message originates from one user, travels through the server infrastructure, reaches other users in the same room, and is permanently archived for later reference.</p>\n<p>The following diagram illustrates this journey:\n<img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fseq-send-message.svg\" alt=\"Sequence: Broadcasting a Chat Message\"></p>\n<h4 id=\"step-by-step-journey-of-a-chat-message\">Step-by-Step Journey of a Chat Message</h4>\n<ol>\n<li><p><strong>User Input and Client Preparation</strong></p>\n<ul>\n<li>Alice types &quot;Hello everyone!&quot; into her chat interface and presses Enter.</li>\n<li>The client application (browser) creates a structured <code>ChatMessage</code> object containing:<ul>\n<li><code>sender</code>: &quot;alice&quot; (her authenticated username)</li>\n<li><code>content</code>: &quot;Hello everyone!&quot; (validated for length ≤ <code>MAX_MESSAGE_LENGTH</code>)</li>\n<li><code>roomId</code>: &quot;general&quot; (the current room she&#39;s viewing)</li>\n<li><code>id</code>: 0 (temporary client-side ID, will be replaced by server)</li>\n<li><code>timestamp</code>: (initially empty, will be set by server)</li>\n</ul>\n</li>\n<li>The client wraps this <code>ChatMessage</code> in a <code>WebSocketMessage</code> with:<ul>\n<li><code>type</code>: <code>EVENT_CHAT_MESSAGE</code> (&quot;chat_message&quot;)</li>\n<li><code>payload</code>: The <code>ChatMessage</code> object</li>\n<li><code>timestamp</code>: Current client ISO timestamp (for debugging, not trusted)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>WebSocket Transmission</strong></p>\n<ul>\n<li>The client&#39;s WebSocket connection (already established and authenticated) calls <code>socket.send()</code> with the JSON-stringified <code>WebSocketMessage</code>.</li>\n<li>The message travels over the persistent TCP connection established during the initial handshake, avoiding the overhead of HTTP headers and connection setup.</li>\n</ul>\n</li>\n<li><p><strong>Server Reception and Validation</strong></p>\n<ul>\n<li>The WebSocket server receives the raw message string on Alice&#39;s specific socket.</li>\n<li><code>ConnectionManager.handleMessage(socket, rawMessage)</code> is invoked:<ul>\n<li><strong>Parsing</strong>: <code>parseAndValidateWebSocketMessage(rawMessage)</code> attempts to parse the JSON. If parsing fails (malformed JSON), the server sends an error response to Alice&#39;s connection only and stops processing.</li>\n<li><strong>Validation</strong>: The method validates the message has required fields (<code>type</code>, <code>payload</code>) and that <code>type</code> equals <code>EVENT_CHAT_MESSAGE</code>.</li>\n<li><strong>Authentication Check</strong>: The server looks up Alice&#39;s <code>ClientSession</code> using the socket connection ID, confirming she&#39;s authenticated and currently in the &quot;general&quot; room (matching the <code>roomId</code> in the payload).</li>\n<li><strong>Payload Validation</strong>: <code>validateChatMessagePayload(payload)</code> checks the <code>ChatMessage</code> structure: <code>content</code> length, <code>sender</code> matches authenticated user (preventing impersonation), and <code>roomId</code> exists.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Message Processing and Storage</strong></p>\n<ul>\n<li>The server calls <code>createChatMessage(sender, content, roomId)</code> to create a canonical message:<ul>\n<li>Generates a server-assigned unique ID (sequential or UUID)</li>\n<li>Sets the authoritative <code>timestamp</code> to <code>new Date().toISOString()</code> (server time, preventing clock skew issues)</li>\n<li>Uses the validated <code>sender</code> and <code>content</code></li>\n</ul>\n</li>\n<li>The Room Manager receives the processed message and calls <code>storeMessage(message)</code>:<ul>\n<li>The Persistence Service stores the complete <code>ChatMessage</code> (with server-set ID and timestamp) in the database.</li>\n<li>Storage happens synchronously before broadcasting to ensure no message is lost if the server crashes immediately after broadcasting.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Recipient Determination and Broadcast</strong></p>\n<ul>\n<li><code>RoomManager.broadcastToRoom(roomId, message, excludeConnectionId)</code> is called with:<ul>\n<li><code>roomId</code>: &quot;general&quot;</li>\n<li><code>message</code>: The server-created <code>ChatMessage</code></li>\n<li><code>excludeConnectionId</code>: Alice&#39;s connection ID (so she doesn&#39;t receive her own message echo)</li>\n</ul>\n</li>\n<li>The Room Manager retrieves the <code>memberIds</code> Set for room &quot;general&quot;.</li>\n<li>For each member ID except Alice&#39;s:<ul>\n<li>The Room Manager calls <code>ConnectionManager.sendToClient(connectionId, message)</code></li>\n<li>The Connection Manager looks up the WebSocket for that connection ID</li>\n<li>It checks the socket&#39;s <code>readyState</code> (must be <code>OPEN</code>). If closed, it silently skips this recipient (user may have disconnected mid-broadcast).</li>\n<li>It wraps the <code>ChatMessage</code> in a server <code>WebSocketMessage</code> using <code>createServerMessage(EVENT_CHAT_MESSAGE, chatMessage)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Network Delivery to Recipients</strong></p>\n<ul>\n<li>For each active recipient (e.g., Bob, Charlie), the server sends the JSON message through their individual WebSocket connections.</li>\n<li>The messages travel asynchronously and may arrive at slightly different times due to network conditions, but all contain the same server timestamp for consistent ordering.</li>\n</ul>\n</li>\n<li><p><strong>Client Reception and Rendering</strong></p>\n<ul>\n<li>Bob&#39;s browser receives the WebSocket message via the <code>onmessage</code> event.</li>\n<li>His client parses the JSON, validates the structure, and extracts the <code>ChatMessage</code>.</li>\n<li>The UI updates to display:<ul>\n<li>Sender name: &quot;alice&quot; (styled according to user preferences)</li>\n<li>Message content: &quot;Hello everyone!&quot;</li>\n<li>Timestamp: Formatted locally (e.g., &quot;2:30 PM&quot;) from the ISO timestamp</li>\n<li>Visual indication that this is a new message (highlight, notification sound if room is active)</li>\n</ul>\n</li>\n<li>The client may store the message in local memory for the current session but relies on server history for persistence.</li>\n</ul>\n</li>\n<li><p><strong>Completion and Cleanup</strong></p>\n<ul>\n<li>The server logs the message delivery (optional, for debugging).</li>\n<li>All resources (database connections, memory objects) are released.</li>\n<li>The system is ready for the next message.</li>\n</ul>\n</li>\n</ol>\n<p><strong>Critical Design Insight:</strong></p>\n<blockquote>\n<p>The server acts as the <strong>single source of truth</strong> for message identity and timing. By generating the final ID and timestamp server-side, we prevent conflicts that could arise from multiple clients generating IDs independently. This also prevents malicious clients from backdating messages or forging sender identities.</p>\n</blockquote>\n<p><strong>Common Variations and Edge Cases:</strong></p>\n<ul>\n<li><strong>Empty Room</strong>: If Alice is alone in the room, <code>memberIds</code> contains only her ID, so after excluding her, broadcast sends to zero recipients. The message is still stored for history.</li>\n<li><strong>Partial Delivery</strong>: If Bob&#39;s connection drops during transmission, his socket won&#39;t be in <code>OPEN</code> state, so he misses the real-time message but can retrieve it later via message history.</li>\n<li><strong>High Volume</strong>: Under heavy load, the store-broadcast sequence remains atomic per message but multiple messages may be processed concurrently, potentially delivering messages slightly out of order (though timestamps provide correct ordering for display).</li>\n</ul>\n<h3 id=\"sequence-joining-a-room-and-loading-history\">Sequence: Joining a Room and Loading History</h3>\n<p><strong>Mental Model: Entering a Conference Hall</strong>\nImagine arriving at a large conference center. You first check in at the registration desk (authentication), receive your badge (session), then find the specific breakout room you want to join. As you enter, the ongoing conversation pauses briefly—the moderator announces your arrival, provides you with the last few minutes of discussion notes (message history), and adds you to the attendee list. Other participants now see you as present and can direct messages to you.</p>\n<p>The following diagram illustrates this process:\n<img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fseq-join-room.svg\" alt=\"Sequence: User Joining a Room\"></p>\n<h4 id=\"step-by-step-room-joining-process\">Step-by-Step Room Joining Process</h4>\n<ol>\n<li><p><strong>User Interface Action</strong></p>\n<ul>\n<li>Bob, already authenticated and connected via WebSocket, clicks &quot;Join General Chat&quot; in the room browser interface.</li>\n<li>The client application sends a <code>WebSocketMessage</code> with:<ul>\n<li><code>type</code>: &quot;join_room&quot;</li>\n<li><code>payload</code>: <code>{ roomId: &quot;general&quot; }</code></li>\n<li>(Optional) <code>timestamp</code>: Client current time</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Server Authentication and Validation</strong></p>\n<ul>\n<li>The WebSocket server receives the message and routes it to <code>ConnectionManager.handleMessage</code>.</li>\n<li>The server validates:<ul>\n<li>Bob has an active <code>ClientSession</code> (authenticated during connection upgrade)</li>\n<li>His session isn&#39;t expired (checked against <code>sessionTTL</code>)</li>\n<li>He has permission to join the room (in this basic implementation, all public rooms are joinable)</li>\n</ul>\n</li>\n<li>The server extracts Bob&#39;s current <code>roomId</code> from his <code>ClientSession</code> (may be <code>null</code> if he&#39;s in no room, or a previous room if he&#39;s switching).</li>\n</ul>\n</li>\n<li><p><strong>Room Transition Management</strong></p>\n<ul>\n<li>If Bob is currently in another room (e.g., &quot;random&quot;):<ul>\n<li>The server calls <code>RoomManager.leaveRoom(connectionId, previousRoomId)</code></li>\n<li>This removes Bob&#39;s <code>connectionId</code> from the <code>memberIds</code> Set of &quot;random&quot;</li>\n<li>Broadcasts <code>EVENT_USER_LEFT</code> to remaining members of &quot;random&quot;</li>\n<li>Updates Bob&#39;s <code>ClientSession.roomId</code> to <code>null</code></li>\n</ul>\n</li>\n<li>The server now processes the join request by calling <code>RoomManager.joinRoom(connectionId, &quot;general&quot;, userId)</code></li>\n</ul>\n</li>\n<li><p><strong>Room Membership Update</strong></p>\n<ul>\n<li>The Room Manager retrieves or creates room &quot;general&quot;:<ul>\n<li>If the room doesn&#39;t exist, <code>createRoom(&quot;general&quot;)</code> is called, initializing an empty <code>memberIds</code> Set.</li>\n</ul>\n</li>\n<li>Bob&#39;s <code>connectionId</code> is added to the room&#39;s <code>memberIds</code> Set.</li>\n<li>Bob&#39;s <code>ClientSession.roomId</code> is updated to &quot;general&quot;.</li>\n<li>The Room Manager retrieves the list of current member user IDs (excluding Bob) for later notification.</li>\n</ul>\n</li>\n<li><p><strong>History Retrieval</strong></p>\n<ul>\n<li>The Room Manager calls <code>getRecentMessagesForRoom(&quot;general&quot;, limit)</code> where <code>limit</code> is configurable (e.g., 50 messages).</li>\n<li>The Persistence Service queries the database for messages where <code>roomId = &quot;general&quot;</code>, ordered by <code>timestamp</code> descending, limited to 50.</li>\n<li>Results are returned as an array of complete <code>ChatMessage</code> objects with server-generated IDs and timestamps.</li>\n<li>The messages are sorted ascending (oldest first) for logical presentation to the user.</li>\n</ul>\n</li>\n<li><p><strong>Presence Notification to Existing Members</strong></p>\n<ul>\n<li>The Room Manager creates a <code>user_joined</code> notification containing:<ul>\n<li><code>userId</code>: Bob&#39;s username</li>\n<li><code>roomId</code>: &quot;general&quot;</li>\n<li><code>timestamp</code>: Current server time</li>\n<li>(Optional) <code>userCount</code>: Updated member count</li>\n</ul>\n</li>\n<li><code>RoomManager.broadcastToRoom(&quot;general&quot;, notification, excludeConnectionId)</code> is called where <code>excludeConnectionId</code> is Bob&#39;s connection ID (he doesn&#39;t need to notify himself).</li>\n<li>All existing room members receive the <code>EVENT_USER_JOINED</code> message and update their UI to show Bob as present (add to member list, possibly show &quot;Bob joined&quot; system message).</li>\n</ul>\n</li>\n<li><p><strong>Join Success Response to Joining User</strong></p>\n<ul>\n<li>The server prepares a comprehensive &quot;room_joined&quot; success response containing:<ul>\n<li><code>room</code>: Room details (name, ID, member count)</li>\n<li><code>members</code>: Array of current member usernames (for populating the sidebar)</li>\n<li><code>history</code>: The retrieved message history array</li>\n<li><code>timestamp</code>: Server time of join completion</li>\n</ul>\n</li>\n<li><code>ConnectionManager.sendToClient</code> delivers this specifically to Bob&#39;s connection.</li>\n</ul>\n</li>\n<li><p><strong>Client-Side State Synchronization</strong></p>\n<ul>\n<li>Bob&#39;s client receives the &quot;room_joined&quot; response and:<ul>\n<li>Updates the current room view to show &quot;general&quot; as active</li>\n<li>Populates the message history area with the 50 historical messages (oldest at top, newest at bottom)</li>\n<li>Updates the member sidebar with the list of current members</li>\n<li>(Optional) Marks any unread indicators for this room as read</li>\n</ul>\n</li>\n<li>The client may now enable the message input box (previously disabled if not in a room).</li>\n</ul>\n</li>\n<li><p><strong>Post-Join Cleanup and Optimization</strong></p>\n<ul>\n<li>The server may perform maintenance:<ul>\n<li>Clean up empty rooms if all members have left (configurable policy)</li>\n<li>Update room activity timestamp for &quot;least recently used&quot; tracking</li>\n<li>Log the join event for analytics (optional)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Critical Design Insight:</strong></p>\n<blockquote>\n<p>The join operation is <strong>atomic from the user&#39;s perspective</strong> but involves multiple non-atomic steps internally. We carefully sequence operations to ensure Bob receives history before any new messages sent after his join, preventing race conditions where he might miss messages sent during his join process.</p>\n</blockquote>\n<p><strong>Data Flow Table: Room Join Operations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Component Involved</th>\n<th>Data Transformed</th>\n<th>State Change</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. Client request</td>\n<td>Client Application</td>\n<td>UI event → <code>WebSocketMessage</code></td>\n<td>Client marks room as &quot;joining&quot; (disables UI)</td>\n</tr>\n<tr>\n<td>2. Auth validation</td>\n<td>Connection Manager</td>\n<td>Validates session against <code>ClientSession</code> store</td>\n<td>None (verification only)</td>\n</tr>\n<tr>\n<td>3. Leave previous room</td>\n<td>Room Manager</td>\n<td>Removes <code>connectionId</code> from previous room&#39;s <code>memberIds</code></td>\n<td>Previous room member count decreases</td>\n</tr>\n<tr>\n<td>4. Join new room</td>\n<td>Room Manager</td>\n<td>Adds <code>connectionId</code> to new room&#39;s <code>memberIds</code></td>\n<td>New room member count increases</td>\n</tr>\n<tr>\n<td>5. History retrieval</td>\n<td>Persistence Service</td>\n<td>Database query → <code>ChatMessage[]</code></td>\n<td>None (read-only)</td>\n</tr>\n<tr>\n<td>6. Notify existing members</td>\n<td>Room Manager → Connection Manager</td>\n<td>Creates <code>user_joined</code> event, broadcasts</td>\n<td>Other clients update their member lists</td>\n</tr>\n<tr>\n<td>7. Send success response</td>\n<td>Connection Manager → Client</td>\n<td>Packages room data, members, history</td>\n<td>Client updates full UI state</td>\n</tr>\n<tr>\n<td>8. UI update</td>\n<td>Client Application</td>\n<td>Renders history, updates room context</td>\n<td>User can now participate</td>\n</tr>\n</tbody></table>\n<p><strong>Common Edge Cases and Handling:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>System Response</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Room doesn&#39;t exist</strong></td>\n<td>Room Manager creates it with Bob as first member</td>\n<td>Lazy room creation simplifies UX; rooms exist only when needed</td>\n</tr>\n<tr>\n<td><strong>User already in room</strong></td>\n<td>Server sends current room state without re-joining</td>\n<td>Idempotent operation prevents duplicate notifications</td>\n</tr>\n<tr>\n<td><strong>History too large</strong></td>\n<td>Pagination: only recent messages sent initially</td>\n<td>Prevents overwhelming client with thousands of messages</td>\n</tr>\n<tr>\n<td><strong>Network timeout during join</strong></td>\n<td>Client may retry with idempotent join request</td>\n<td>Join operation designed to be safely repeatable</td>\n</tr>\n<tr>\n<td><strong>User banned from room</strong></td>\n<td>Server rejects join with error message (future enhancement)</td>\n<td>Basic implementation allows all joins; permission system would intercept here</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning Focus)</th>\n<th>Advanced Option (Production Ready)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Validation</td>\n<td>Manual field-by-field checks in JavaScript</td>\n<td>JSON Schema validation with libraries like <code>ajv</code></td>\n</tr>\n<tr>\n<td>History Pagination</td>\n<td>Fixed <code>LIMIT</code> clause in SQL query</td>\n<td>Cursor-based pagination with timestamp offsets</td>\n</tr>\n<tr>\n<td>Member List Sync</td>\n<td>Send full list on each join/leave</td>\n<td>Differential updates using patch operations</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Simple retry with exponential backoff</td>\n<td>Circuit breaker pattern with fallback responses</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── server/\n│   ├── index.js                    # Main server entry point\n│   ├── connection/\n│   │   ├── manager.js              # ConnectionManager class\n│   │   ├── lifecycle.js            # Connection event handlers\n│   │   └── validation.js           # parseAndValidateWebSocketMessage, etc.\n│   ├── rooms/\n│   │   ├── manager.js              # RoomManager class (implements broadcast, join, leave)\n│   │   ├── presence.js             # Typing indicators, online status\n│   │   └── history.js              # Message history retrieval logic\n│   ├── auth/\n│   │   ├── service.js              # Authentication service (login, register)\n│   │   ├── sessions.js             # Session management (create, validate, invalidate)\n│   │   └── middleware.js           # WebSocket upgrade authentication\n│   └── persistence/\n│       ├── messageStore.js         # storeMessage, getMessagesForRoom\n│       ├── userStore.js            # User CRUD operations\n│       └── database.js             # Database connection setup\n├── client/\n│   ├── public/\n│   │   ├── index.html              # Main HTML file\n│   │   ├── app.js                  # Main client application logic\n│   │   ├── ui.js                   # DOM manipulation and rendering\n│   │   └── ws-client.js            # WebSocket connection management\n│   └── package.json                # Client dependencies (if using build tools)\n└── package.json                    # Server dependencies</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (Complete Validation Utilities):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/connection/validation.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Parses and validates a raw WebSocket message string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> rawMessage</span><span style=\"color:#6A737D\"> - Raw string received from WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#6A737D\"> Parsed and validated message object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {Error}</span><span style=\"color:#6A737D\"> If message is invalid JSON or missing required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> parseAndValidateWebSocketMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">typeof</span><span style=\"color:#E1E4E8\"> rawMessage </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must be a string'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  let</span><span style=\"color:#E1E4E8\"> parsed;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(rawMessage);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Invalid JSON: ${</span><span style=\"color:#E1E4E8\">err</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">parsed.type </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> parsed.type </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must have a string \"type\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (parsed.payload </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> undefined</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message must have a \"payload\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Optional timestamp validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (parsed.timestamp </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isValidISODate</span><span style=\"color:#E1E4E8\">(parsed.timestamp)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Invalid timestamp format, expected ISO string'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type: parsed.type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload: parsed.payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: parsed.timestamp </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validates a ChatMessage payload structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - The payload to validate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#6A737D\"> Validated chat message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {Error}</span><span style=\"color:#6A737D\"> If payload doesn't match ChatMessage structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> validateChatMessagePayload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">payload </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> payload </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'object'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Payload must be an object'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">payload.sender </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> payload.sender </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Payload must have a string \"sender\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">payload.content </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> payload.content </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Payload must have a string \"content\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">payload.roomId </span><span style=\"color:#F97583\">||</span><span style=\"color:#F97583\"> typeof</span><span style=\"color:#E1E4E8\"> payload.roomId </span><span style=\"color:#F97583\">!==</span><span style=\"color:#9ECBFF\"> 'string'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Payload must have a string \"roomId\" field'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (payload.content.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#F97583\"> ></span><span style=\"color:#79B8FF\"> MAX_MESSAGE_LENGTH</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Message content exceeds maximum length of ${</span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#9ECBFF\">} characters`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Allow client to send ID and timestamp, but they will be overwritten by server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sender: payload.sender,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: payload.content.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#6A737D\">// Trim whitespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roomId: payload.roomId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    id: payload.id </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Temporary, will be replaced</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: payload.timestamp </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#6A737D\"> // Will be replaced by server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a properly formatted server-originated WebSocket message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> type</span><span style=\"color:#6A737D\"> - Message type (use EVENT_* constants)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {any}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - The payload to send</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#6A737D\"> Formatted message ready for JSON.stringify</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createServerMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Creates a new ChatMessage with server-generated ID and timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> sender</span><span style=\"color:#6A737D\"> - Username of sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> content</span><span style=\"color:#6A737D\"> - Message content (already validated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - Room identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#6A737D\"> Complete chat message object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> createChatMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sender</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">content</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    id: </span><span style=\"color:#B392F0\">generateMessageId</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#6A737D\">// Implement this (could be sequential or UUID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sender,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: content.</span><span style=\"color:#B392F0\">trim</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roomId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function for ID generation (simple sequential for learning)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> messageIdCounter </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> generateMessageId</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> messageIdCounter</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function for ISO date validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> isValidISODate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">dateString</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isNaN</span><span style=\"color:#E1E4E8\">(Date.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(dateString));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  parseAndValidateWebSocketMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  validateChatMessagePayload,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createServerMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  createChatMessage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  MAX_MESSAGE_LENGTH: </span><span style=\"color:#79B8FF\">1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/rooms/manager.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RoomManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">messageStore</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">connectionManager</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.rooms </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// roomId -> Room object</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageStore </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> messageStore;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connectionManager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> connectionManager;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Adds a user to a room, fetches history, and notifies other members</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - The WebSocket connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - Room identifier to join</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> userId</span><span style=\"color:#6A737D\"> - Authenticated user ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;Room>}</span><span style=\"color:#6A737D\"> The joined room object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> joinRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate parameters (non-empty strings)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get or create the room (check this.rooms Map, create if missing using createRoom)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if user is already in room (optional optimization)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add connectionId to room.memberIds Set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Fetch recent message history (call this.messageStore.getRecentMessagesForRoom)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Get list of current member user IDs (excluding the joining user)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Create user_joined notification using createServerMessage(EVENT_USER_JOINED, ...)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Broadcast notification to all other room members using this.broadcastToRoom</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Prepare success response with room info, members list, and history</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return room object for further processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Sends a message to all members of a room, optionally excluding sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - Target room identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#E1E4E8\"> message</span><span style=\"color:#6A737D\"> - The chat message to broadcast</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> [excludeConnectionId]</span><span style=\"color:#6A737D\"> - Optional connection ID to exclude (usually sender)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {void}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  broadcastToRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">excludeConnectionId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate roomId exists in this.rooms Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get the room object and its memberIds Set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Convert memberIds Set to array for iteration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each connectionId in memberIds:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   a. Skip if connectionId === excludeConnectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   b. Get WebSocket via this.connectionManager.getSocket(connectionId)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   c. Check socket is open (readyState === WebSocket.OPEN)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   d. Create formatted message using createServerMessage(EVENT_CHAT_MESSAGE, message)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   e. Send via this.connectionManager.sendToClient(connectionId, formattedMessage)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log broadcast statistics (optional)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Removes a user from a room and notifies remaining members</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - The WebSocket connection ID to remove</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - Room identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {void}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  leaveRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate room exists in this.rooms Map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove connectionId from room.memberIds Set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If room is now empty, consider cleanup (optional: delete room or mark inactive)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create user_left notification using createServerMessage(EVENT_USER_LEFT, ...)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Broadcast notification to remaining room members</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update connection's session to reflect leaving room (via connectionManager)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Updates and broadcasts a user's typing status in a room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - The WebSocket connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> roomId</span><span style=\"color:#6A737D\"> - Room identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {boolean}</span><span style=\"color:#E1E4E8\"> isTyping</span><span style=\"color:#6A737D\"> - Whether user is currently typing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {void}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  setUserTyping</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">isTyping</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate user is actually in the specified room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create typing notification with user info and isTyping flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Broadcast to room members excluding the typing user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: (Advanced) Implement debouncing to prevent spam - only send if state changed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: (Advanced) Set timeout to automatically send \"stopped typing\" after inactivity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> RoomManager;</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/connection/manager.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// connectionId -> ClientSession</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Main entry point for handling incoming WebSocket messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - The connection ID (from socket)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> rawMessage</span><span style=\"color:#6A737D\"> - Raw WebSocket message string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {void}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  handleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up ClientSession from this.connections using connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse and validate raw message using parseAndValidateWebSocketMessage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate user session is still active (check lastActivity against sessionTTL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Route message based on type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type === 'chat_message': validate payload, create chat message, store, broadcast</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type === 'join_room': extract roomId, call roomManager.joinRoom</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - If type === 'typing': extract roomId and isTyping, call roomManager.setUserTyping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Unknown type: send error response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update lastActivity timestamp in ClientSession</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle any errors: send appropriate error message to client, log error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Sends a message to a specific client if their socket is open</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - Target connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#E1E4E8\"> message</span><span style=\"color:#6A737D\"> - Message to send</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {boolean}</span><span style=\"color:#6A737D\"> True if message was sent, false if socket not open</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  sendToClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up ClientSession from this.connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get WebSocket from ClientSession.socket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check socket.readyState === WebSocket.OPEN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If open: socket.send(JSON.stringify(message)), return true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If not open: return false (connection will be cleaned up by heartbeat check)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Wrap in try-catch for network errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> ConnectionManager;</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints (JavaScript/Node.js):</strong></p>\n<ol>\n<li><p><strong>WebSocket State Checking</strong>: Always check <code>socket.readyState === WebSocket.OPEN</code> before sending. The WebSocket protocol has states: CONNECTING (0), OPEN (1), CLOSING (2), CLOSED (3).</p>\n</li>\n<li><p><strong>Error Handling in Async Flow</strong>: Use try-catch blocks around database operations and JSON parsing. Send descriptive error messages to clients for debugging but log full errors server-side.</p>\n</li>\n<li><p><strong>Set Operations for Membership</strong>: JavaScript&#39;s <code>Set</code> is ideal for <code>memberIds</code> because it ensures uniqueness and has O(1) add/delete/has operations. Convert to array only when needed for iteration.</p>\n</li>\n<li><p><strong>Timestamp Consistency</strong>: Use <code>new Date().toISOString()</code> for all server-generated timestamps. This produces UTC time in a standard format that&#39;s easily sortable and timezone-agnostic.</p>\n</li>\n<li><p><strong>Connection Cleanup</strong>: Implement periodic cleanup (every 30 seconds) to remove stale connections by checking <code>ClientSession.lastActivity</code> against current time.</p>\n</li>\n</ol>\n<p><strong>F. Milestone Checkpoint for Message Flow:</strong></p>\n<p><strong>After implementing Milestone 2 (Message Broadcasting):</strong></p>\n<ol>\n<li><strong>Start the server</strong>: <code>node server/index.js</code></li>\n<li><strong>Open two browser tabs</strong> to <code>http://localhost:3000</code></li>\n<li><strong>Log in with different usernames</strong> in each tab</li>\n<li><strong>Send a message from Tab 1</strong> and verify:<ul>\n<li>Message appears in Tab 1&#39;s chat window (echo from server optional)</li>\n<li>Message appears in Tab 2&#39;s chat window within ~100ms</li>\n<li>Message shows correct sender name and timestamp</li>\n<li>Console logs show no validation errors</li>\n</ul>\n</li>\n<li><strong>Test edge cases</strong>:<ul>\n<li>Send empty message → should be rejected</li>\n<li>Send message &gt; 1000 characters → should be rejected</li>\n<li>Disconnect Tab 2 network → message should fail to deliver but not crash server</li>\n<li>Reconnect Tab 2 → should see message in history when rejoining room</li>\n</ul>\n</li>\n</ol>\n<p><strong>G. Debugging Tips for Data Flow Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Messages appear only for sender</strong></td>\n<td><code>broadcastToRoom</code> is excluding everyone</td>\n<td>Log <code>memberIds</code> size before and after exclusion</td>\n<td>Check <code>excludeConnectionId</code> logic; verify room membership</td>\n</tr>\n<tr>\n<td><strong>History loads but real-time messages don&#39;t appear</strong></td>\n<td>Client not handling <code>EVENT_CHAT_MESSAGE</code> events</td>\n<td>Check client WebSocket <code>onmessage</code> handler</td>\n<td>Add handler for <code>type === &#39;chat_message&#39;</code></td>\n</tr>\n<tr>\n<td><strong>User count wrong after join/leave</strong></td>\n<td>Race condition in member tracking</td>\n<td>Add debug logs to <code>joinRoom</code> and <code>leaveRoom</code></td>\n<td>Ensure atomic operations or add mutex for room updates</td>\n</tr>\n<tr>\n<td><strong>Messages appear out of order</strong></td>\n<td>Multiple messages processed concurrently</td>\n<td>Log server timestamps vs arrival order</td>\n<td>Sort by timestamp on client side before display</td>\n</tr>\n<tr>\n<td><strong>Join takes long time</strong></td>\n<td>History query is slow with many messages</td>\n<td>Profile database query time</td>\n<td>Add index on <code>(roomId, timestamp)</code> columns</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4). Robust error handling and edge case management are critical for the stability and reliability of the real-time chat system, ensuring graceful degradation when things go wrong rather than catastrophic failure.</p>\n</blockquote>\n<p>Imagine a busy office building where the telephone system suddenly fails—calls drop mid-conversation, some lines get crossed, and occasionally wrong numbers slip through. A well-designed system has contingency plans: operators who can reconnect calls, verification procedures to prevent wrong connections, and capacity limits to avoid overload. Similarly, our chat application must anticipate and handle failures gracefully because real-time systems operate in an inherently unreliable environment—networks fail, servers crash, users send invalid data, and edge cases emerge under load. This section details how the system detects, responds to, and recovers from expected failures and unexpected conditions.</p>\n<h3 id=\"common-failure-modes-and-recovery\">Common Failure Modes and Recovery</h3>\n<p>The chat system faces several predictable failure modes. Proactively designing for these scenarios prevents cascading failures and maintains user experience. Our approach follows the principle of <strong>defensive programming</strong>: validate everything, assume nothing, and always have a recovery path.</p>\n<h4 id=\"network-drops-and-unclean-disconnections\">Network Drops and Unclean Disconnections</h4>\n<p><strong>Mental Model: The Frayed Telephone Cord</strong><br>Think of WebSocket connections as physical telephone cords that can be accidentally unplugged or fray over time. The server needs to detect when a cord is cut (connection lost) and clean up the call (user session) to avoid &quot;ghost users&quot; lingering in rooms.</p>\n<p>Network failures are the most common issue in distributed systems. Clients may lose connectivity due to Wi-Fi drops, mobile network switching, or firewall timeouts without sending a proper WebSocket close frame.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Silent Connection Death</strong> (client disappears without <code>onclose</code>)</td>\n<td>Heartbeat (ping/pong) mechanism: Server sends periodic ping; if no pong received within timeout, marks connection dead</td>\n<td>Server proactively cleans up connection state via <code>ConnectionManager.removeConnection()</code>; broadcasts <code>EVENT_USER_LEFT</code> to affected rooms</td>\n<td>Prevents memory leaks and ensures presence accuracy without relying on TCP timeouts (which can be minutes)</td>\n</tr>\n<tr>\n<td><strong>Intermittent Network Flakiness</strong> (brief packet loss)</td>\n<td>Multiple missed heartbeats or repeated WebSocket frame errors</td>\n<td>Client implements exponential backoff reconnection logic; server maintains session briefly during short outages (30-60 seconds)</td>\n<td>Balances quick recovery with avoiding churn for temporary issues; exponential backoff prevents overwhelming server during network restoration</td>\n</tr>\n<tr>\n<td><strong>Asymmetric Connectivity</strong> (client can receive but not send)</td>\n<td>Client-side heartbeat: client sends periodic &quot;alive&quot; messages; server notices missing messages</td>\n<td>Server eventually treats as dead connection after timeout; client detects send failures and initiates reconnection</td>\n<td>Detects one-way failures that server ping might miss (since pings require round-trip)</td>\n</tr>\n</tbody></table>\n<p><strong>Architecture Decision Record: Implementing Heartbeat vs. Relying on TCP Keepalive</strong></p>\n<blockquote>\n<p><strong>Decision: Application-Level Heartbeat Over TCP Keepalive</strong></p>\n<ul>\n<li><strong>Context</strong>: WebSocket connections can appear open at TCP level while the application is stuck (browser tab frozen, mobile app backgrounded). We need to detect actual application liveliness, not just TCP connectivity.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Rely solely on TCP keepalive</strong>: Use operating system TCP keepalive packets (default 2 hours idle timeout).</li>\n<li><strong>WebSocket protocol ping/pong</strong>: Use built-in WebSocket control frames (RFC 6455 Section 5.5.2).</li>\n<li><strong>Application-level heartbeat messages</strong>: Custom <code>{type: &quot;heartbeat&quot;}</code> messages in the chat protocol.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use WebSocket protocol ping/pong frames for connection health, supplemented with application-level activity tracking.</li>\n<li><strong>Rationale</strong>: WebSocket ping/pong is standardized, doesn&#39;t clutter application message protocol, and works across all WebSocket implementations. Application-level activity tracking (last message timestamp) helps distinguish idle from dead connections. TCP keepalive is too slow (hours vs seconds).</li>\n<li><strong>Consequences</strong>: Requires WebSocket library that exposes ping/pong API; adds periodic server workload; ensures connections are cleaned within 30-60 seconds of failure.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TCP Keepalive</td>\n<td>No application code, operating system handles it</td>\n<td>Extremely slow detection (default 2+ hours), not configurable per-connection</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>WebSocket Ping/Pong</td>\n<td>Standardized, efficient (control frames), most libraries support</td>\n<td>Some browser WebSocket APIs don&#39;t expose ping/pong to JavaScript</td>\n<td>✅ Primary</td>\n</tr>\n<tr>\n<td>Application Heartbeat</td>\n<td>Full control, works everywhere, can carry metadata</td>\n<td>Adds to message count, requires protocol design, redundant with ping/pong</td>\n<td>✅ Supplementary</td>\n</tr>\n</tbody></table>\n<p><strong>Implementation Strategy</strong>:</p>\n<ol>\n<li>Server sends ping every 25 seconds to each connection</li>\n<li>If no pong received within 30 seconds, mark connection as stale</li>\n<li>After 60 seconds total (two missed cycles), forcibly close connection and clean up</li>\n<li>Track <code>lastActivity</code> timestamp in <code>ClientSession</code> updated on any message receive</li>\n<li>Background cleaner runs every minute to remove sessions inactive &gt; 60 seconds</li>\n</ol>\n<h4 id=\"server-crashes-and-restarts\">Server Crashes and Restarts</h4>\n<p><strong>Mental Model: The Office Power Outage</strong><br>When the power goes out in an office building, everything stops instantly. When power returns, systems need to reboot, restore essential services, and notify people that there was an interruption.</p>\n<p>Server crashes (unhandled exceptions, OOM killer, deployment restarts) terminate all in-memory state. The recovery focus is on data persistence and graceful client reconnection.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Process Crash</strong> (Node.js uncaught exception)</td>\n<td>Process exits; process manager (PM2, systemd) detects exit</td>\n<td>Process manager restarts server; server reloads persistent data (rooms, messages); clients automatically reconnect</td>\n<td>Minimizes downtime; stateless WebSocket connections require full client reconnection</td>\n</tr>\n<tr>\n<td><strong>Memory Exhaustion</strong> (OOM)</td>\n<td>Monitoring memory usage approaching limits</td>\n<td>Implement connection limits (<code>maxConnections</code>), message size limits, and aggressive cleanup of idle connections</td>\n<td>Prevents catastrophic failure; allows server to reject new connections rather than crash</td>\n</tr>\n<tr>\n<td><strong>Dependency Failure</strong> (database connection lost)</td>\n<td>Database client library emits error events</td>\n<td>Continue serving existing connections with degraded functionality (no history queries); queue or drop persistence operations</td>\n<td>Graceful degradation maintains real-time chat while persistence is temporarily unavailable</td>\n</tr>\n</tbody></table>\n<p><strong>Recovery Procedure on Server Startup</strong>:</p>\n<ol>\n<li>Load recent messages from database for active rooms (cached in memory)</li>\n<li>Recreate room structures from persisted room definitions (if stored)</li>\n<li>Initialize empty connection maps (all clients must reconnect)</li>\n<li>Begin accepting new WebSocket connections</li>\n<li>Optional: Broadcast &quot;server was restarted&quot; to reconnected clients</li>\n</ol>\n<blockquote>\n<p><strong>Key Insight</strong>: The system is designed to be <strong>mostly stateless at the connection layer</strong>. All essential state (messages, user accounts, room definitions) persists to storage, while ephemeral state (who&#39;s currently connected, typing status) rebuilds as clients reconnect. This aligns with the <strong>Twelve-Factor App</strong> principle of disposable processes.</p>\n</blockquote>\n<h4 id=\"malformed-and-malicious-messages\">Malformed and Malicious Messages</h4>\n<p><strong>Mental Model: The Mailroom Screening Process</strong><br>Every incoming package passes through security screening: checking for hazardous materials, verifying sender identity, and ensuring proper addressing. Similarly, every WebSocket message undergoes validation before processing.</p>\n<p>Malformed messages (invalid JSON, missing fields) and malicious payloads (injection attempts, enormous strings) can crash the server or exploit vulnerabilities if not properly handled.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Invalid JSON Syntax</strong></td>\n<td><code>JSON.parse()</code> throws SyntaxError in <code>parseAndValidateWebSocketMessage()</code></td>\n<td>Catch exception, send error response <code>{type: &quot;error&quot;, payload: {code: &quot;INVALID_JSON&quot;}}</code> to client, keep connection open</td>\n<td>Prevents server crash; informs client of protocol violation without disconnecting</td>\n</tr>\n<tr>\n<td><strong>Schema Violation</strong> (missing required fields, wrong types)</td>\n<td><code>validateChatMessagePayload()</code> checks structure against expected schema</td>\n<td>Reject message with descriptive error, log for monitoring, continue processing other messages</td>\n<td>Maintains protocol consistency; helps developers debug client implementation</td>\n</tr>\n<tr>\n<td><strong>Message Too Large</strong> (exceeds <code>MAX_MESSAGE_LENGTH</code>)</td>\n<td>Check <code>payload.content.length</code> before validation</td>\n<td>Immediately reject without full parsing, send error, optionally disconnect abusive clients</td>\n<td>Protects against memory exhaustion attacks and network congestion</td>\n</tr>\n<tr>\n<td><strong>Injection Attempts</strong> (JavaScript, HTML in messages)</td>\n<td>Client-side sanitization preferred; server validation for critical fields</td>\n<td>Store raw content but escape before sending to other clients; log suspicious patterns</td>\n<td>Allows flexibility in client rendering while preventing XSS in web clients</td>\n</tr>\n</tbody></table>\n<p><strong>Message Validation Pipeline</strong> (referencing <img src=\"/api/project/chat-app/architecture-doc/asset?path=diagrams%2Fflowchart-message-handling.svg\" alt=\"Flowchart: Server Message Handling\">):</p>\n<ol>\n<li><strong>Raw Message Reception</strong>: <code>ConnectionManager.handleMessage()</code> receives string</li>\n<li><strong>Syntax Validation</strong>: <code>parseAndValidateWebSocketMessage()</code> attempts JSON parsing<ul>\n<li>Failure → Send error response, stop processing</li>\n</ul>\n</li>\n<li><strong>Structure Validation</strong>: Verify <code>WebSocketMessage</code> has <code>type</code> and <code>payload</code> fields<ul>\n<li>Missing → Send error, stop</li>\n</ul>\n</li>\n<li><strong>Type-Specific Validation</strong>: Route to appropriate validator based on <code>type</code><ul>\n<li><code>EVENT_CHAT_MESSAGE</code> → <code>validateChatMessagePayload()</code> checks sender, content length, roomId</li>\n<li><code>EVENT_USER_TYPING</code> → Validate boolean flag and room membership</li>\n</ul>\n</li>\n<li><strong>Business Logic Validation</strong>: Check application state (is user in room? authenticated?)</li>\n<li><strong>Processing</strong>: Only after all validation passes, execute handler</li>\n</ol>\n<p><strong>Error Response Format</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Server sends this when message validation fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  payload</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    code</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"VALIDATION_ERROR\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// or \"NOT_IN_ROOM\", \"UNAUTHENTICATED\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    message</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"Content exceeds maximum length of 1000 characters\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    originalType</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"chat_message\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// The failed message type</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    timestamp</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2023-10-05T14:30:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"resource-exhaustion-memory-cpu-file-descriptors\">Resource Exhaustion (Memory, CPU, File Descriptors)</h4>\n<p><strong>Mental Model: The Concert Venue Capacity Manager</strong><br>A venue has maximum capacity for safety. When full, new attendees wait in line. Staff monitor crowd density and may ask overly rowdy patrons to leave. Similarly, the server must enforce limits to remain stable.</p>\n<p>Node.js has single-threaded event loop and memory constraints. Resource exhaustion can degrade performance for all users or cause complete failure.</p>\n<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th>Monitoring</th>\n<th>Protection Strategy</th>\n<th>Mitigation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Memory</strong></td>\n<td><code>process.memoryUsage()</code>, monitor RSS</td>\n<td>Limit concurrent connections; implement message size limits; use efficient data structures (<code>Map</code> over <code>Object</code>, <code>Set</code> for member lists)</td>\n<td>Connection rejection when near limit; aggressive garbage collection by clearing message history caches</td>\n</tr>\n<tr>\n<td><strong>CPU</strong></td>\n<td>Event loop lag measurement; profiling</td>\n<td>Rate limiting per connection (messages/second); offload expensive operations (password hashing) to worker threads</td>\n<td>Shed load by rejecting new connections; use efficient algorithms (O(1) lookups in connection maps)</td>\n</tr>\n<tr>\n<td><strong>File Descriptors</strong></td>\n<td><code>ulimit</code> monitoring; connection count tracking</td>\n<td>Set <code>maxConnections</code> below system limit (typically 65% of <code>ulimit -n</code>)</td>\n<td>Graceful degradation: &quot;Server busy&quot; response during HTTP upgrade</td>\n</tr>\n<tr>\n<td><strong>Database Connections</strong></td>\n<td>Connection pool metrics</td>\n<td>Implement connection pooling with reasonable max; queue operations when pool exhausted</td>\n<td>Return partial functionality (real-time works, history may fail)</td>\n</tr>\n</tbody></table>\n<p><strong>Architecture Decision Record: In-Memory State vs. External Storage for Active Connections</strong></p>\n<blockquote>\n<p><strong>Decision: In-Memory Connection State with Single-Server Simplicity</strong></p>\n<ul>\n<li><strong>Context</strong>: The learning-focused chat application runs as a single Node.js process. We need to track all active WebSocket connections, their room memberships, and typing status.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Pure in-memory</strong>: Store everything in process memory using <code>Map</code> and <code>Set</code> collections.</li>\n<li><strong>Shared Redis</strong>: Store connection state in Redis for potential multi-server scaling.</li>\n<li><strong>Hybrid approach</strong>: Critical state (room membership) in Redis, ephemeral state (typing) in memory.</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Pure in-memory state for all connection data.</li>\n<li><strong>Rationale</strong>: For the learning context and single-server deployment, in-memory is simpler with zero external dependencies, faster (no network latency), and sufficient for hundreds to thousands of concurrent connections. The complexity of distributed state management outweighs benefits at this scale.</li>\n<li><strong>Consequences</strong>: Server restart loses all connection state (users must reconnect); vertical scaling only (single server); cannot scale horizontally without redesign.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure In-Memory</td>\n<td>Simplest, fastest, no external dependencies</td>\n<td>Lost on server restart, doesn&#39;t scale horizontally</td>\n<td>✅ For learning context</td>\n</tr>\n<tr>\n<td>Shared Redis</td>\n<td>Survives server restarts, enables horizontal scaling</td>\n<td>Additional infrastructure, network latency, complexity</td>\n<td>❌ Over-engineering</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Balances performance and durability</td>\n<td>Increased complexity, consistency challenges</td>\n<td>❌ Intermediate complexity not justified</td>\n</tr>\n</tbody></table>\n<h3 id=\"edge-case-analysis\">Edge Case Analysis</h3>\n<p>Edge cases are unusual but valid scenarios that test the boundaries of the system design. Proper handling distinguishes a robust system from a fragile one.</p>\n<h4 id=\"duplicate-usernames-and-connection-conflicts\">Duplicate Usernames and Connection Conflicts</h4>\n<p><strong>Scenario</strong>: Two users register with the same username &quot;Alice&quot;, or the same user logs in from two devices (browser and phone).</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Registration Duplicate</strong></td>\n<td>Two users with identical <code>username</code> in database</td>\n<td>Unique constraint on <code>username</code> field in database; <code>registerUser()</code> returns error &quot;Username taken&quot;</td>\n</tr>\n<tr>\n<td><strong>Simultaneous Connections</strong> Same user from multiple devices</td>\n<td>Both connections receive messages; typing indicators conflict; presence shows as single user</td>\n<td>Treat each connection independently: separate <code>ClientSession</code> objects, both receive broadcasts, typing status from either device shows as &quot;Alice is typing&quot;</td>\n</tr>\n<tr>\n<td><strong>Same Username in Same Room</strong></td>\n<td>Confusion about which user sent a message</td>\n<td>Use unique internal <code>userId</code> (database ID) for all routing; display username but include <code>userId</code> in message metadata for disambiguation</td>\n</tr>\n<tr>\n<td><strong>Username Change While Connected</strong></td>\n<td>Other users see old username in cached messages</td>\n<td>Store <code>userId</code> in <code>ChatMessage</code>, not username; fetch current username from database when displaying historical messages</td>\n</tr>\n</tbody></table>\n<p><strong>Handling Algorithm for Multiple Connections</strong>:</p>\n<ol>\n<li>When user authenticates, create new <code>ClientSession</code> with unique <code>connectionId</code></li>\n<li>Both sessions have same <code>userId</code> but different <code>connectionId</code></li>\n<li><code>RoomManager.broadcastToRoom()</code> sends to all connections in room</li>\n<li>Typing indicator: <code>setUserTyping()</code> updates status per <code>connectionId</code>, broadcasts to room</li>\n<li>User leaves: only remove specific <code>connectionId</code> from room; user remains in room if other connections exist</li>\n<li>All connections close: <code>leaveAllRooms()</code> called for each, user fully removed</li>\n</ol>\n<h4 id=\"message-size-and-rate-extremes\">Message Size and Rate Extremes</h4>\n<p><strong>Scenario</strong>: A user pastes a 10MB text file, or a bot sends 1000 messages per second.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Extremely Long Message</strong> (&gt; <code>MAX_MESSAGE_LENGTH</code>)</td>\n<td>Network congestion, database bloat, UI rendering issues</td>\n<td>Server enforces <code>MAX_MESSAGE_LENGTH</code> (1000 chars) in <code>validateChatMessagePayload()</code>; client also validates before sending</td>\n</tr>\n<tr>\n<td><strong>Rapid Message Flood</strong> from single connection</td>\n<td>Event loop blocking, other users overwhelmed with notifications</td>\n<td>Rate limiting: track messages per second per connection; delay or drop excess messages with error &quot;Rate limit exceeded&quot;</td>\n</tr>\n<tr>\n<td><strong>Empty Messages</strong> (zero-length or whitespace-only)</td>\n<td>Spam, confusing UI display</td>\n<td>Validation requires <code>content.trim().length &gt; 0</code>; reject with descriptive error</td>\n</tr>\n<tr>\n<td><strong>Special Character Bomb</strong> (emojis, Unicode)</td>\n<td>Encoding issues, storage size mismatch (UTF-8 vs byte length)</td>\n<td>Count Unicode code points, not bytes, for length limit; normalize encoding before storage</td>\n</tr>\n</tbody></table>\n<p><strong>Rate Limiting Implementation</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In ConnectionManager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> messageCounts</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// connectionId -> {count, resetTime}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> checkRateLimit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> now</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  let</span><span style=\"color:#E1E4E8\"> record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> messageCounts.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(connectionId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">record </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> record.resetTime </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 60000</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // New minute window</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { count: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, resetTime: now };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageCounts.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(connectionId, record);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  record.count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> record.count </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 100 messages per minute limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"rapid-joinleave-churn\">Rapid Join/Leave Churn</h4>\n<p><strong>Scenario</strong>: A user rapidly joins and leaves a room, or a script creates/destroys rooms quickly.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Join-Leave Loop</strong> (user spamming enter/exit)</td>\n<td>Notification storms for other users; unnecessary database queries for history</td>\n<td>Debounce join operations: ignore repeated <code>joinRoom</code> calls within 1 second for same user+room</td>\n</tr>\n<tr>\n<td><strong>Room Creation Flood</strong></td>\n<td>Exhaustion of resources, polluted room lists</td>\n<td>Limit room creation rate per user; require unique room names; auto-cleanup empty rooms after timeout</td>\n</tr>\n<tr>\n<td><strong>Concurrent Join from Multiple Devices</strong></td>\n<td>Race conditions in member list updates</td>\n<td>Use atomic operations: <code>Room.memberIds</code> as <code>Set</code> with <code>add()</code>/<code>delete()</code>; broadcast only after successful addition</td>\n</tr>\n<tr>\n<td><strong>Leave During Join</strong> (user leaves while history is loading)</td>\n<td>Orphaned operations, inconsistent state</td>\n<td>Cancel pending history fetch if connection closes; verify user still in room before broadcasting join notification</td>\n</tr>\n</tbody></table>\n<p><strong>Debouncing Algorithm for Room Operations</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// In RoomManager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> lastJoinTime</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// userId+roomId -> timestamp</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> joinRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> key</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> `${</span><span style=\"color:#E1E4E8\">userId</span><span style=\"color:#9ECBFF\">}:${</span><span style=\"color:#E1E4E8\">roomId</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> now</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> lastTime</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> lastJoinTime.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(key) </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  if</span><span style=\"color:#E1E4E8\"> (now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> lastTime </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#6A737D\">// 1 second debounce</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Please wait before rejoining'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  lastJoinTime.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(key, now);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ... rest of join logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"clock-skew-and-message-ordering\">Clock Skew and Message Ordering</h4>\n<p><strong>Scenario</strong>: Client and server clocks differ by minutes, or messages arrive out of order due to network latency.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Client Clock Wrong</strong> (behind/ahead)</td>\n<td>Message timestamps inconsistent across users</td>\n<td>Always use server-assigned timestamp (<code>Date.now()</code> on server) in <code>createChatMessage()</code>; ignore client-provided timestamps</td>\n</tr>\n<tr>\n<td><strong>Network Reordering</strong> (later message arrives first)</td>\n<td>Chat history shows messages out of logical order</td>\n<td>Use monotonic increasing message IDs (database sequence) for ordering; timestamp for display only</td>\n</tr>\n<tr>\n<td><strong>Daylight Saving Time Changes</strong></td>\n<td>Displayed times jump forward/backward</td>\n<td>Store all timestamps in UTC ISO format; convert to local time only at display layer (client-side)</td>\n</tr>\n<tr>\n<td><strong>High-Precision Timing</strong> (multiple messages in same millisecond)</td>\n<td>Indistinguishable ordering at millisecond level</td>\n<td>Use composite key: <code>timestamp + sequence</code> or database auto-increment ID</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: <strong>Server-generated timestamps</strong> are non-negotiable for consistency. The server acts as the &quot;single source of truth&quot; for temporal ordering. Clients may display relative times (&quot;2 minutes ago&quot;) to mask small synchronization issues.</p>\n</blockquote>\n<h4 id=\"empty-rooms-and-zombie-connections\">Empty Rooms and Zombie Connections</h4>\n<p><strong>Scenario</strong>: All users leave a room but it persists in memory, or connections remain in lists after network failure.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Empty Room Accumulation</strong></td>\n<td>Memory leak, polluted room listing</td>\n<td>Background job removes rooms with <code>memberIds.size === 0</code> after 24 hours (or shorter for temporary rooms)</td>\n</tr>\n<tr>\n<td><strong>Zombie Connections</strong> in member lists</td>\n<td>Users appear present but cannot receive messages</td>\n<td><code>RoomManager</code> validates connection existence before broadcasting; periodic cleanup removes dead connections from all rooms</td>\n</tr>\n<tr>\n<td><strong>Room Name Collisions</strong> (case sensitivity)</td>\n<td>&quot;General&quot; vs &quot;general&quot; treated as different rooms</td>\n<td>Normalize room names: lowercase, trim before storage; case-insensitive matching for joins</td>\n</tr>\n<tr>\n<td><strong>Special Character Room Names</strong></td>\n<td>Injection, URL encoding issues</td>\n<td>Sanitize room names: allow alphanumeric, hyphens, underscores; reject special characters</td>\n</tr>\n</tbody></table>\n<p><strong>Room Cleanup Algorithm</strong>:</p>\n<ol>\n<li>Every hour, scan all rooms in <code>RoomManager</code></li>\n<li>For rooms with <code>memberIds.size === 0</code>:<ul>\n<li>If room created &gt; 24 hours ago, delete it</li>\n<li>If temporary room (prefixed with &quot;temp-&quot;), delete immediately</li>\n</ul>\n</li>\n<li>For rooms with members, verify each <code>connectionId</code> still exists in <code>ConnectionManager</code></li>\n<li>Remove invalid connections from room membership</li>\n</ol>\n<h4 id=\"authentication-and-session-edge-cases\">Authentication and Session Edge Cases</h4>\n<p><strong>Scenario</strong>: User logs out on one device while active on another, or session expires mid-conversation.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Problem</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Session Expiry During Connection</strong></td>\n<td>User suddenly unauthenticated; messages fail</td>\n<td>Periodic session validation in heartbeat; on expiration, send <code>{type: &quot;session_expired&quot;}</code> and close WebSocket</td>\n</tr>\n<tr>\n<td><strong>Concurrent Logout from Another Device</strong></td>\n<td>Race condition: which session wins?</td>\n<td>Session invalidation removes all sessions for user; all connections receive logout notification</td>\n</tr>\n<tr>\n<td><strong>Reused Session Token</strong> (theft/replay)</td>\n<td>Unauthorized access</td>\n<td>Store sessions in database with expiry; one-time use tokens or token rotation on sensitive operations</td>\n</tr>\n<tr>\n<td><strong>Password Change with Active Sessions</strong></td>\n<td>Old sessions remain valid (security risk)</td>\n<td>Invalidate all sessions on password change; require re-authentication on all devices</td>\n</tr>\n</tbody></table>\n<p><strong>Session Validation in Message Flow</strong>:</p>\n<ol>\n<li>Each incoming message includes session token (in WebSocket upgrade or first message)</li>\n<li><code>ConnectionManager</code> validates token via <code>validateSession()</code> before routing</li>\n<li>If invalid/expired: send error, close connection with code 4001 (custom: &quot;Session expired&quot;)</li>\n<li>Background job <code>cleanupExpiredSessions()</code> runs hourly to purge old sessions</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations-for-error-handling\">Technology Recommendations for Error Handling</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning)</th>\n<th>Production-Ready Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Connection Heartbeat</td>\n<td>Manual ping/pong using <code>setInterval</code> and WebSocket <code>.ping()</code></td>\n<td><code>ws</code> library built-in heartbeat with configurable intervals</td>\n</tr>\n<tr>\n<td>Rate Limiting</td>\n<td>In-memory counter with fixed window</td>\n<td>Redis-based sliding window with <code>redis-cell</code> or token bucket algorithm</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Manual <code>if</code> statements checking each field</td>\n<td>JSON Schema validation with <code>ajv</code> or <code>zod</code> for TypeScript</td>\n</tr>\n<tr>\n<td>Error Tracking</td>\n<td>Console logging</td>\n<td>Structured logging with <code>winston</code>/<code>pino</code> + error aggregation (Sentry)</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td>Manual <code>node server.js</code></td>\n<td>Process manager (PM2, systemd) with auto-restart and monitoring</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-error-handling-module-structure\">Recommended Error Handling Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    server/\n      connection-manager.js       ← Heartbeat, rate limiting, validation\n      room-manager.js            ← Room cleanup, debouncing logic\n      auth-service.js            ← Session validation, cleanup\n      persistence/               ← Database error handling\n        message-store.js\n        session-store.js\n      middleware/                ← Validation middleware\n        validate-message.js\n        rate-limiter.js\n      errors/                    ← Custom error classes\n        chat-errors.js\n        validation-errors.js\n      utils/\n        logger.js                ← Structured logging</code></pre></div>\n\n<h4 id=\"core-error-handling-skeleton-code\">Core Error Handling Skeleton Code</h4>\n<p><strong>Complete Starter: Custom Error Classes</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/errors/chat-errors.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Base class for all chat application errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">statusCode</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 400</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">constructor</span><span style=\"color:#E1E4E8\">.name;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> code; </span><span style=\"color:#6A737D\">// Machine-readable error code</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.statusCode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statusCode; </span><span style=\"color:#6A737D\">// HTTP-like status for WebSocket close</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Error.</span><span style=\"color:#B392F0\">captureStackTrace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">constructor</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thrown when message validation fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">field</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#9ECBFF\">'VALIDATION_ERROR'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">400</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.field </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field; </span><span style=\"color:#6A737D\">// Which field failed validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thrown when user is not authenticated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuthenticationError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Authentication required'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#9ECBFF\">'UNAUTHENTICATED'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">401</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thrown when user lacks permission for an operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AuthorizationError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'Permission denied'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#9ECBFF\">'FORBIDDEN'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">403</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thrown when resource not found (room, user, message)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NotFoundError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">resourceType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`${</span><span style=\"color:#E1E4E8\">resourceType</span><span style=\"color:#9ECBFF\">} \"${</span><span style=\"color:#E1E4E8\">id</span><span style=\"color:#9ECBFF\">}\" not found`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'NOT_FOUND'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">404</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.resourceType </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> resourceType;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.resourceId </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> id;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Thrown when rate limit exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RateLimitError</span><span style=\"color:#F97583\"> extends</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">retryAfterSeconds</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    super</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Rate limit exceeded'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'RATE_LIMITED'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">429</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.retryAfter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> retryAfterSeconds;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ChatError,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ValidationError,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  AuthenticationError,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  AuthorizationError,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  NotFoundError,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  RateLimitError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span></code></pre></div>\n\n<p><strong>Complete Starter: Structured Logger</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/utils/logger.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> winston</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'winston'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> logger</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> winston.</span><span style=\"color:#B392F0\">createLogger</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  level: process.env.</span><span style=\"color:#79B8FF\">LOG_LEVEL</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#9ECBFF\"> 'info'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  format: winston.format.</span><span style=\"color:#B392F0\">combine</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    winston.format.</span><span style=\"color:#B392F0\">timestamp</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    winston.format.</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#E1E4E8\">({ stack: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\"> }),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    winston.format.</span><span style=\"color:#B392F0\">json</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  transports: [</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    new</span><span style=\"color:#E1E4E8\"> winston.transports.</span><span style=\"color:#B392F0\">Console</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      format: winston.format.</span><span style=\"color:#B392F0\">combine</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        winston.format.</span><span style=\"color:#B392F0\">colorize</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        winston.format.</span><span style=\"color:#B392F0\">simple</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    new</span><span style=\"color:#E1E4E8\"> winston.transports.</span><span style=\"color:#B392F0\">File</span><span style=\"color:#E1E4E8\">({ </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      filename: </span><span style=\"color:#9ECBFF\">'logs/error.log'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      level: </span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      maxsize: </span><span style=\"color:#79B8FF\">5242880</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// 5MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      maxFiles: </span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }),</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    new</span><span style=\"color:#E1E4E8\"> winston.transports.</span><span style=\"color:#B392F0\">File</span><span style=\"color:#E1E4E8\">({ </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      filename: </span><span style=\"color:#9ECBFF\">'logs/combined.log'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      maxsize: </span><span style=\"color:#79B8FF\">5242880</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      maxFiles: </span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper for logging WebSocket events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger.</span><span style=\"color:#B392F0\">connection</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">event</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">details</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  logger.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type: </span><span style=\"color:#9ECBFF\">'connection'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connectionId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ...</span><span style=\"color:#E1E4E8\">details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper for logging chat events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">logger.</span><span style=\"color:#B392F0\">chat</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">event</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">details</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  logger.</span><span style=\"color:#B392F0\">info</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    type: </span><span style=\"color:#9ECBFF\">'chat'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    roomId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ...</span><span style=\"color:#E1E4E8\">details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> logger;</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton: Enhanced Message Validation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/middleware/validate-message.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">ValidationError</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../errors/chat-errors'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">MAX_MESSAGE_LENGTH</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../constants'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Parse and validate raw WebSocket message string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> rawMessage</span><span style=\"color:#6A737D\"> - Raw message from WebSocket</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {WebSocketMessage}</span><span style=\"color:#6A737D\"> - Parsed and validated message object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {ValidationError}</span><span style=\"color:#6A737D\"> - If message fails validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> parseAndValidateWebSocketMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 1: Check if rawMessage is a string, throw ValidationError if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 2: Trim the message and check if empty, throw if empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 3: Try to parse JSON using JSON.parse, catch SyntaxError and throw ValidationError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 4: Validate parsed object has required fields: type (string) and payload (object)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 5: Validate type is one of allowed events (EVENT_CHAT_MESSAGE, EVENT_USER_JOINED, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 6: Return the validated WebSocketMessage object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Validate chat message payload structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {object}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - The payload from chat_message event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {ChatMessage}</span><span style=\"color:#6A737D\"> - Validated chat message data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@throws</span><span style=\"color:#B392F0\"> {ValidationError}</span><span style=\"color:#6A737D\"> - If payload fails validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> validateChatMessagePayload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 1: Check payload is an object, throw if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 2: Validate required fields exist: sender (string), content (string), roomId (string)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 3: Validate content length &#x3C;= MAX_MESSAGE_LENGTH, throw if too long</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 4: Validate content is not just whitespace (trim().length > 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 5: Validate sender is not empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 6: Validate roomId matches pattern (alphanumeric, hyphens, underscores)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // TODO 7: Return the validated payload (will be used to create ChatMessage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Enhanced message handler with comprehensive error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - The connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> rawMessage</span><span style=\"color:#6A737D\"> - Raw WebSocket message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {void}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> handleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse and validate the message using parseAndValidateWebSocketMessage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check rate limit for this connection, throw RateLimitError if exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate user session (call validateSession with token from connection)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Route to appropriate handler based on message.type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Catch any errors thrown during handler execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log the error with appropriate level (warn for client errors, error for server errors)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: If error is a ChatError, send formatted error response to client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: If error is unexpected (TypeError, etc.), log with stack trace and send generic error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: For certain errors (AuthenticationError), close the WebSocket connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton: Connection Heartbeat Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/server/connection-manager.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connections </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// connectionId -> ClientSession</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.heartbeatInterval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 25000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 25 seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.heartbeatTimeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 30 seconds timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.cleanupInterval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Cleanup every minute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Start heartbeat for a connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> connectionId</span><span style=\"color:#6A737D\"> - The connection ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {WebSocket}</span><span style=\"color:#E1E4E8\"> socket</span><span style=\"color:#6A737D\"> - The WebSocket instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  startHeartbeat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">socket</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create a ping interval that sends WebSocket ping every heartbeatInterval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Track last pong time in ClientSession (update on 'pong' event)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up timeout checker that verifies last pong was within heartbeatTimeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If timeout exceeded, call this.removeConnection(connectionId, 'heartbeat_timeout')</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Periodic cleanup of stale connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  startCleanupJob</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setInterval</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> now</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">session</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">of</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.connections) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 1: Check if session.lastActivity older than 60 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Check if heartbeat timeout exceeded (last pong too old)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 3: If stale, remove connection with reason 'inactive'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.cleanupInterval);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-javascriptnodejs\">Language-Specific Hints for JavaScript/Node.js</h4>\n<ol>\n<li><strong>WebSocket Ping/Pong</strong>: Use <code>ws</code> library&#39;s built-in support:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   const</span><span style=\"color:#79B8FF\"> wss</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">({ clientTracking: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   wss.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'connection'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">ws</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ws.isAlive </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'pong'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ws.isAlive </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Heartbeat interval</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> interval</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> setInterval</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> (ws.isAlive </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">         return</span><span style=\"color:#E1E4E8\"> ws.</span><span style=\"color:#B392F0\">terminate</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ws.isAlive </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       ws.</span><span style=\"color:#B392F0\">ping</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }, </span><span style=\"color:#79B8FF\">30000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'close'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       clearInterval</span><span style=\"color:#E1E4E8\">(interval);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   });</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Error Propagation</strong>: Use async/await with try/catch:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> handleJoinRoom</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       const</span><span style=\"color:#79B8FF\"> room</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> roomManager.</span><span style=\"color:#B392F0\">joinRoom</span><span style=\"color:#E1E4E8\">(connectionId, roomId);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">       sendToClient</span><span style=\"color:#E1E4E8\">(connectionId, { type: </span><span style=\"color:#9ECBFF\">'room_joined'</span><span style=\"color:#E1E4E8\">, payload: room });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       if</span><span style=\"color:#E1E4E8\"> (error </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#B392F0\"> ChatError</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         // Expected error, send to client</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">         sendToClient</span><span style=\"color:#E1E4E8\">(connectionId, </span><span style=\"color:#B392F0\">createServerMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           code: error.code,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           message: error.message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">         // Unexpected, log and send generic error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         logger.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Unexpected error in joinRoom'</span><span style=\"color:#E1E4E8\">, { error, connectionId });</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">         sendToClient</span><span style=\"color:#E1E4E8\">(connectionId, </span><span style=\"color:#B392F0\">createServerMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           code: </span><span style=\"color:#9ECBFF\">'INTERNAL_ERROR'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           message: </span><span style=\"color:#9ECBFF\">'Something went wrong'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">         }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">       }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Rate Limiting with Redis</strong> (advanced):</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   const</span><span style=\"color:#79B8FF\"> redis</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'redis'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   const</span><span style=\"color:#79B8FF\"> client</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> redis.</span><span style=\"color:#B392F0\">createClient</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">   async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> rateLimit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limit</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">windowMs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 60000</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> key</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> `rate_limit:${</span><span style=\"color:#E1E4E8\">connectionId</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> now</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> windowStart</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> windowMs;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Remove old timestamps</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     await</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">zremrangebyscore</span><span style=\"color:#E1E4E8\">(key, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, windowStart);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Count requests in current window</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> requestCount</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">zcard</span><span style=\"color:#E1E4E8\">(key);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     if</span><span style=\"color:#E1E4E8\"> (requestCount </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> limit) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">       throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> RateLimitError</span><span style=\"color:#E1E4E8\">(Math.</span><span style=\"color:#B392F0\">ceil</span><span style=\"color:#E1E4E8\">(windowMs </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Add current request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     await</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">zadd</span><span style=\"color:#E1E4E8\">(key, now, now);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     await</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">expire</span><span style=\"color:#E1E4E8\">(key, Math.</span><span style=\"color:#B392F0\">ceil</span><span style=\"color:#E1E4E8\">(windowMs </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">     return</span><span style=\"color:#E1E4E8\"> { remaining: limit </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> requestCount </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   }</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips-for-error-scenarios\">Debugging Tips for Error Scenarios</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Messages not appearing for some users</strong></td>\n<td>User not in room member list; connection dead but not cleaned</td>\n<td>Check <code>Room.memberIds</code> contains connectionId; verify <code>lastActivity</code> timestamp</td>\n<td>Ensure <code>joinRoom</code> updates member list; implement heartbeat cleanup</td>\n</tr>\n<tr>\n<td><strong>User count wrong (shows offline users)</strong></td>\n<td>Connection cleanup not running; zombie connections in member list</td>\n<td>Log when connections are removed; check heartbeat is working</td>\n<td>Implement periodic cleanup job; verify ping/pong events firing</td>\n</tr>\n<tr>\n<td><strong>Server crashes on malformed message</strong></td>\n<td>No try/catch in message handler; JSON.parse without validation</td>\n<td>Add error handling wrapper; validate before parsing</td>\n<td>Implement <code>parseAndValidateWebSocketMessage</code> with try/catch</td>\n</tr>\n<tr>\n<td><strong>Memory usage grows indefinitely</strong></td>\n<td>Connections not cleaned up; message history not paginated</td>\n<td>Monitor connection count; check room cleanup job</td>\n<td>Implement connection limits; paginate history queries</td>\n</tr>\n<tr>\n<td><strong>Users receive own messages</strong></td>\n<td><code>broadcastToRoom</code> not excluding sender</td>\n<td>Check <code>excludeConnectionId</code> parameter is passed correctly</td>\n<td>Verify broadcast logic excludes sender connection</td>\n</tr>\n<tr>\n<td><strong>Typing indicator never disappears</strong></td>\n<td>Timeout not cleared; client not sending stop event</td>\n<td>Log typing events; check timer cleanup on disconnect</td>\n<td>Implement debouncing with clearTimeout; handle disconnect cleanup</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-checkpoint-for-error-handling\">Milestone Checkpoint for Error Handling</h4>\n<p>After implementing error handling, verify by:</p>\n<ol>\n<li><strong>Test Network Failure Simulation</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Start server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   npm</span><span style=\"color:#9ECBFF\"> start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # In browser, open chat and send messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Then simulate network drop (turn off Wi-Fi, or use browser DevTools to go offline)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Wait 30+ seconds, then restore network</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: Server should clean up user after ~60 seconds; user should auto-reconnect</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Test Malformed Messages</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Use WebSocket CLI tool or browser console</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   const</span><span style=\"color:#9ECBFF\"> ws</span><span style=\"color:#9ECBFF\"> =</span><span style=\"color:#9ECBFF\"> new</span><span style=\"color:#9ECBFF\"> WebSocket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">'ws://localhost:3000'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ws.onopen</span><span style=\"color:#9ECBFF\"> =</span><span style=\"color:#E1E4E8\"> () => {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">     ws.send(</span><span style=\"color:#B392F0\">'not json'</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">//</span><span style=\"color:#9ECBFF\"> Should</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> error</span><span style=\"color:#9ECBFF\"> response</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">     ws.send(</span><span style=\"color:#B392F0\">'{\"type\":\"chat_message\",\"payload\":{}}'</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#B392F0\">//</span><span style=\"color:#9ECBFF\"> Missing</span><span style=\"color:#9ECBFF\"> fields</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">     ws.send(</span><span style=\"color:#B392F0\">'A'</span><span style=\"color:#B392F0\">.repeat(2000</span><span style=\"color:#E1E4E8\">)); </span><span style=\"color:#B392F0\">//</span><span style=\"color:#9ECBFF\"> Too</span><span style=\"color:#9ECBFF\"> long</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: Server responds with error messages, doesn't crash</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Verify Rate Limiting</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Script to send 200 messages quickly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: After ~100 messages, get rate limit error</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Check Memory Usage</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Monitor Node.js process</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   node</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"setInterval(() => console.log(process.memoryUsage()), 1000)\"</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Connect many clients, send messages, disconnect</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Expected: Memory returns to baseline after connections close</span></span></code></pre></div>\n\n<p>Signs of correct implementation:</p>\n<ul>\n<li>Server remains running despite invalid inputs</li>\n<li>Error messages are descriptive and help debug</li>\n<li>Connections are cleaned up automatically</li>\n<li>Memory usage stabilizes over time</li>\n</ul>\n<hr>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4). Testing is an integral part of building a reliable real-time chat system. This section provides a practical, learning-focused approach to verifying your implementation works correctly, with emphasis on integration testing and manual verification checkpoints aligned with each milestone.</p>\n</blockquote>\n<p>Testing a real-time WebSocket application presents unique challenges compared to traditional HTTP APIs. Connections are stateful, events occur asynchronously, and timing issues can create subtle bugs. This testing strategy balances rigor with practicality for learners, focusing on <strong>integration testing</strong> (verifying components work together) and <strong>manual verification</strong> (observing system behavior) while providing a foundation for more advanced testing patterns.</p>\n<h3 id=\"testing-approach-and-property-verification\">Testing Approach and Property Verification</h3>\n<p><strong>Mental Model: The Airport Control Tower and Flight Simulator</strong>\nThink of testing this chat system like operating an airport control tower. <strong>Unit tests</strong> are like checking individual aircraft systems in isolation (fuel gauge, landing gear). <strong>Integration tests</strong> are like simulating takeoff and landing procedures with multiple systems interacting. <strong>Manual verification</strong> is like the control tower operator watching actual flights move on radar, confirming the whole system works as expected. For learning, we prioritize the control tower view (integration) while ensuring critical individual systems (units) function correctly.</p>\n<h4 id=\"testing-layers-and-focus-areas\">Testing Layers and Focus Areas</h4>\n<p>Our testing pyramid for this project has three layers with increasing realism but decreasing automation:</p>\n<table>\n<thead>\n<tr>\n<th>Layer</th>\n<th>What It Tests</th>\n<th>How We&#39;ll Implement</th>\n<th>Primary Goal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Unit Tests</strong></td>\n<td>Individual functions and classes in isolation</td>\n<td>Jest/Node.js test files mocking dependencies</td>\n<td>Verify core logic (message parsing, validation, business rules)</td>\n</tr>\n<tr>\n<td><strong>Integration Tests</strong></td>\n<td>Components working together (e.g., ConnectionManager + RoomManager)</td>\n<td>Test server with in-memory WebSocket clients</td>\n<td>Verify event flow and state synchronization</td>\n</tr>\n<tr>\n<td><strong>Manual Verification</strong></td>\n<td>End-to-end system behavior with real browsers</td>\n<td>Multiple browser tabs connecting to your running server</td>\n<td>Build intuition and catch UI/experience issues</td>\n</tr>\n</tbody></table>\n<p>For this learning project, we emphasize <strong>integration testing</strong> because WebSocket systems derive most bugs from component interactions rather than isolated logic. However, we&#39;ll write unit tests for critical validation and transformation functions.</p>\n<h4 id=\"key-properties-to-verify\">Key Properties to Verify</h4>\n<p>These are the fundamental guarantees your system must maintain. Each property can be tested through specific scenarios:</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Why It Matters</th>\n<th>How to Test</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Message Ordering</strong></td>\n<td>Users expect messages to appear in the order they were sent, not delivery order</td>\n<td>Send messages M1, M2, M3 from same client; verify receivers see same sequence</td>\n</tr>\n<tr>\n<td><strong>At-Most-Once Delivery</strong></td>\n<td>Messages shouldn&#39;t duplicate, causing confusing repeated messages</td>\n<td>Send same message rapidly multiple times; verify only one appears</td>\n</tr>\n<tr>\n<td><strong>User Removal on Disconnect</strong></td>\n<td>Prevent &quot;ghost users&quot; who appear online but disconnected</td>\n<td>Connect user, verify in member list, disconnect, verify removed within 5 seconds</td>\n</tr>\n<tr>\n<td><strong>Room Isolation</strong></td>\n<td>Messages in Room A must not leak to Room B</td>\n<td>Create two rooms, send message in Room A, verify users in Room B don&#39;t receive it</td>\n</tr>\n<tr>\n<td><strong>History Integrity</strong></td>\n<td>New users should see accurate past conversation</td>\n<td>Send messages, disconnect all users, new user joins, should see same messages</td>\n</tr>\n<tr>\n<td><strong>Presence Accuracy</strong></td>\n<td>Typing indicators and online status must reflect current reality</td>\n<td>User starts typing, indicator appears; stops typing for 3 seconds, indicator disappears</td>\n</tr>\n<tr>\n<td><strong>Authentication Enforcement</strong></td>\n<td>Unauthenticated users cannot send/receive messages</td>\n<td>Try to send message without valid session; connection should be rejected or ignored</td>\n</tr>\n<tr>\n<td><strong>Connection Resilience</strong></td>\n<td>Network drops shouldn&#39;t break application state</td>\n<td>Disconnect network for 10 seconds, reconnect, verify automatic rejoin and state recovery</td>\n</tr>\n</tbody></table>\n<h4 id=\"integration-testing-strategy\">Integration Testing Strategy</h4>\n<p>For integration tests, we&#39;ll simulate the complete system with these components:</p>\n<ol>\n<li><strong>Test Server Instance</strong>: A real WebSocket server running on a test port</li>\n<li><strong>Mock Clients</strong>: Programmatic WebSocket clients that can send/receive messages</li>\n<li><strong>Test Orchestrator</strong>: Code that coordinates scenarios and asserts outcomes</li>\n</ol>\n<p>The test pattern follows this sequence:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. Start test server with clean state\n2. Connect mock Client A and Client B via WebSocket\n3. Authenticate both clients (simulate login)\n4. Have both clients join the same room\n5. Client A sends a chat message\n6. Verify Client B receives the message with correct fields\n7. Clean up connections and server</code></pre></div>\n\n<blockquote>\n<p><strong>Design Insight</strong>: Integration tests for WebSocket systems are inherently stateful and asynchronous. Use explicit timeouts and await patterns rather than fixed sleeps. Each test should clean up completely to prevent test pollution.</p>\n</blockquote>\n<h4 id=\"adr-choosing-integration-tests-over-unit-tests-for-core-components\">ADR: Choosing Integration Tests Over Unit Tests for Core Components</h4>\n<blockquote>\n<p><strong>Decision: Prioritize Integration Testing for Component Interactions</strong></p>\n<ul>\n<li><strong>Context</strong>: WebSocket chat systems involve complex interactions between connection management, room membership, and message routing. Bugs often emerge at component boundaries rather than within isolated functions.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><strong>Primarily unit tests</strong> with extensive mocking of WebSocket and database dependencies</li>\n<li><strong>Balanced approach</strong> with unit tests for pure functions and integration tests for components</li>\n<li><strong>Primarily integration tests</strong> with real WebSocket connections and in-memory stores</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Option 3 (primarily integration tests) for core components, with unit tests only for pure validation/utility functions</li>\n<li><strong>Rationale</strong>: <ul>\n<li>Integration tests verify the actual event flow and message passing that unit tests with mocks might miss</li>\n<li>Real WebSocket behavior (connection drops, buffering) is difficult to mock accurately</li>\n<li>For learning, seeing the whole system work builds better intuition than passing unit tests with mocked dependencies</li>\n<li>The relatively small codebase makes integration test execution fast enough</li>\n</ul>\n</li>\n<li><strong>Consequences</strong>:<ul>\n<li>Tests are more realistic but potentially more brittle to timing issues</li>\n<li>Test setup/teardown is more complex (requires starting actual server)</li>\n<li>Encourages designing components with clear interfaces for testability</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Why Not Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Primarily unit tests</td>\n<td>Fast execution, isolated failures</td>\n<td>Misses integration issues, complex mocks</td>\n<td>Doesn&#39;t test real WebSocket behavior</td>\n</tr>\n<tr>\n<td>Balanced approach</td>\n<td>Tests both logic and integration</td>\n<td>More test code to maintain, context switching</td>\n<td>Good but heavier for learning focus</td>\n</tr>\n<tr>\n<td><strong>Primarily integration tests</strong></td>\n<td><strong>Tests real interactions, builds system intuition</strong></td>\n<td><strong>Slower, timing-sensitive</strong></td>\n<td><strong>Chosen: Best for learning real-time system behavior</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-implementation-checkpoints\">Milestone Implementation Checkpoints</h3>\n<p>Each milestone has clear acceptance criteria. These checkpoints help you verify your implementation meets them before moving forward. Think of these as <strong>flight checks</strong> before taking off to the next milestone.</p>\n<h4 id=\"milestone-1-websocket-server-setup-checkpoint\">Milestone 1: WebSocket Server Setup Checkpoint</h4>\n<p><strong>Expected Behavior</strong>: Your server accepts WebSocket connections, tracks active clients, handles disconnections, and doesn&#39;t crash on malformed messages.</p>\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><strong>Start the server</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   node</span><span style=\"color:#9ECBFF\"> server.js</span></span></code></pre></div>\n<p>   Expected output: &quot;WebSocket server listening on port 8080&quot; (or your chosen port)</p>\n<ol start=\"2\">\n<li><strong>Test basic connection</strong> using browser DevTools:<ul>\n<li>Open Chrome/Firefox, press F12, go to Console tab</li>\n<li>Create WebSocket connection:</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">     const</span><span style=\"color:#79B8FF\"> ws</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws://localhost:8080'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">onopen</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Connected!'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">onmessage</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Received:'</span><span style=\"color:#E1E4E8\">, event.data);</span></span></code></pre></div>\n<ul>\n<li>Expected: &quot;Connected!&quot; appears in console</li>\n<li>Check server logs: Should show &quot;New connection from [IP]&quot;</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Verify connection tracking</strong>:<ul>\n<li>Open 3 browser tabs, run connection code in each</li>\n<li>Send a test message from one client:</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({type: </span><span style=\"color:#9ECBFF\">'ping'</span><span style=\"color:#E1E4E8\">, payload: </span><span style=\"color:#9ECBFF\">'test'</span><span style=\"color:#E1E4E8\">}));</span></span></code></pre></div>\n<ul>\n<li>Check server logs: Should show message received and handled</li>\n<li>Close one tab, check server logs within 2 seconds: Should show &quot;Connection closed&quot; or similar</li>\n</ul>\n<ol start=\"4\">\n<li><strong>Test error resilience</strong>:<ul>\n<li>With a client connected, send invalid JSON:</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'{ malformed json }'</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<ul>\n<li>Expected: Server doesn&#39;t crash, may send error response or close connection gracefully</li>\n<li>Send extremely long message (&gt;1MB):</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">     ws.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'x'</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">repeat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000000</span><span style=\"color:#E1E4E8\">));</span></span></code></pre></div>\n<ul>\n<li>Expected: Server rejects or handles without memory issues</li>\n</ul>\n<p><strong>Success Indicators</strong>:</p>\n<ul>\n<li>✅ Server starts without errors</li>\n<li>✅ Multiple clients can connect simultaneously</li>\n<li>✅ Server logs show connect/disconnect events</li>\n<li>✅ Invalid messages don&#39;t crash server</li>\n<li>✅ All connections cleaned up when tabs close</li>\n</ul>\n<p><strong>Common Pitfalls at This Stage</strong>:</p>\n<ul>\n<li>⚠️ <strong>Port already in use</strong>: Change port or kill previous process</li>\n<li>⚠️ <strong>No server logs for connections</strong>: Check WebSocket upgrade handling in HTTP server</li>\n<li>⚠️ <strong>Connections never show as closed</strong>: Ensure <code>socket.on(&#39;close&#39;)</code> handler removes from connection tracking</li>\n</ul>\n<h4 id=\"milestone-2-message-broadcasting-checkpoint\">Milestone 2: Message Broadcasting Checkpoint</h4>\n<p><strong>Expected Behavior</strong>: Messages broadcast to all room members, include proper metadata (sender, timestamp), and typing indicators work.</p>\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><p><strong>Set up test scenario</strong> with three browser tabs (User A, User B, Observer):</p>\n<ul>\n<li>Each tab connects and joins the same default room (implement simple join for now)</li>\n<li>Use different usernames in each tab&#39;s connection</li>\n</ul>\n</li>\n<li><p><strong>Test message broadcasting</strong>:</p>\n<ul>\n<li>User A sends: <code>{&quot;type&quot;: &quot;chat_message&quot;, &quot;payload&quot;: {&quot;content&quot;: &quot;Hello everyone&quot;}}</code></li>\n<li>Expected: User B and Observer receive message with:<ul>\n<li>Correct content</li>\n<li>Sender field showing User A&#39;s username</li>\n<li>Recent timestamp (within last second)</li>\n<li>User A should NOT receive their own message back</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Test typing indicators</strong>:</p>\n<ul>\n<li>User A sends: <code>{&quot;type&quot;: &quot;typing_start&quot;, &quot;payload&quot;: {&quot;roomId&quot;: &quot;default&quot;}}</code></li>\n<li>Expected: User B and Observer receive typing indicator with User A&#39;s username</li>\n<li>Wait 3 seconds: User B and Observer should receive <code>typing_stop</code> automatically</li>\n<li>Alternative: User A sends <code>typing_stop</code> manually after 1 second</li>\n</ul>\n</li>\n<li><p><strong>Test join/leave notifications</strong>:</p>\n<ul>\n<li>Open fourth tab (User D), join room</li>\n<li>Expected: Users A, B, Observer receive <code>user_joined</code> notification</li>\n<li>User D leaves (close tab or send leave message)</li>\n<li>Expected: Remaining users receive <code>user_left</code> within 5 seconds</li>\n</ul>\n</li>\n</ol>\n<p><strong>Success Indicators</strong>:</p>\n<ul>\n<li>✅ Messages appear in all other clients but not sender</li>\n<li>✅ Each message has sender, content, and ISO timestamp</li>\n<li>✅ Typing indicators appear and clear automatically</li>\n<li>✅ Join/leave events trigger notifications</li>\n<li>✅ Server logs show broadcast counts (e.g., &quot;Broadcasting to 2 clients&quot;)</li>\n</ul>\n<p><strong>Advanced Verification Script</strong>:\nCreate a simple Node.js test script that automates this verification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test-broadcast.js - Basic verification script</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Implementation details would go here</span></span></code></pre></div>\n\n<h4 id=\"milestone-3-chat-rooms-checkpoint\">Milestone 3: Chat Rooms Checkpoint</h4>\n<p><strong>Expected Behavior</strong>: Users can create/join rooms, messages are room-scoped, member lists update correctly, and room listing works.</p>\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><p><strong>Test room creation and joining</strong>:</p>\n<ul>\n<li>User A sends: <code>{&quot;type&quot;: &quot;join_room&quot;, &quot;payload&quot;: {&quot;roomName&quot;: &quot;gaming&quot;}}</code></li>\n<li>Expected: Server creates &quot;gaming&quot; room, User A receives <code>room_joined</code> confirmation</li>\n<li>User B sends join request for same room</li>\n<li>Expected: User B joins, User A receives <code>user_joined</code> notification for User B</li>\n</ul>\n</li>\n<li><p><strong>Verify room isolation</strong>:</p>\n<ul>\n<li>User A in &quot;gaming&quot; room sends message</li>\n<li>User C in &quot;general&quot; room (different room) should NOT receive it</li>\n<li>User B in &quot;gaming&quot; room SHOULD receive it</li>\n</ul>\n</li>\n<li><p><strong>Test member list accuracy</strong>:</p>\n<ul>\n<li>User D joins &quot;gaming&quot; room</li>\n<li>User A requests member list: <code>{&quot;type&quot;: &quot;get_members&quot;, &quot;payload&quot;: {&quot;roomId&quot;: &quot;gaming&quot;}}</code></li>\n<li>Expected: Response includes User A, B, D (all current members)</li>\n<li>User B leaves room</li>\n<li>User A requests member list again within 5 seconds: Should NOT include User B</li>\n</ul>\n</li>\n<li><p><strong>Test room listing</strong>:</p>\n<ul>\n<li>Create rooms &quot;gaming&quot;, &quot;music&quot;, &quot;random&quot;</li>\n<li>Request room list: <code>{&quot;type&quot;: &quot;get_rooms&quot;, &quot;payload&quot;: {}}</code></li>\n<li>Expected: All three rooms listed with correct member counts</li>\n<li>Empty room after all users leave should either be removed or show 0 members</li>\n</ul>\n</li>\n<li><p><strong>Test message history</strong>:</p>\n<ul>\n<li>Send 5 messages in &quot;gaming&quot; room</li>\n<li>New user joins &quot;gaming&quot; room</li>\n<li>Expected: New user receives last 3-5 messages (configurable) immediately after joining</li>\n</ul>\n</li>\n</ol>\n<p><strong>Success Indicators</strong>:</p>\n<ul>\n<li>✅ Room-specific messaging works (no cross-room leakage)</li>\n<li>✅ Member lists accurately reflect current occupants</li>\n<li>✅ Room listing shows all active rooms with counts</li>\n<li>✅ New room members receive recent message history</li>\n<li>✅ Empty rooms don&#39;t accumulate or are cleaned up</li>\n</ul>\n<h4 id=\"milestone-4-user-authentication-amp-persistence-checkpoint\">Milestone 4: User Authentication &amp; Persistence Checkpoint</h4>\n<p><strong>Expected Behavior</strong>: Users authenticate before chatting, messages persist to database, history loads with pagination, and presence works across reconnections.</p>\n<p><strong>Verification Steps</strong>:</p>\n<ol>\n<li><p><strong>Test authentication requirement</strong>:</p>\n<ul>\n<li>Try to connect WebSocket without valid session token</li>\n<li>Expected: Connection rejected during HTTP upgrade or immediately closed with error</li>\n<li>Properly authenticate via HTTP login first, then connect with session token</li>\n</ul>\n</li>\n<li><p><strong>Verify message persistence</strong>:</p>\n<ul>\n<li>Send 10 messages in a room</li>\n<li>Restart the server completely (simulating crash)</li>\n<li>Reconnect clients, rejoin room</li>\n<li>Expected: Previous 10 messages still available via history</li>\n<li>New messages should continue with new IDs/timestamps</li>\n</ul>\n</li>\n<li><p><strong>Test history pagination</strong>:</p>\n<ul>\n<li>Send 25 messages to a room</li>\n<li>New user joins, requests history with limit=10</li>\n<li>Expected: Receives most recent 10 messages, not first 10</li>\n<li>Request older messages with <code>beforeId</code> parameter</li>\n<li>Expected: Next 10 older messages</li>\n</ul>\n</li>\n<li><p><strong>Verify presence across sessions</strong>:</p>\n<ul>\n<li>User A logs in on Browser Tab 1 (shows as online)</li>\n<li>Same user logs in on Browser Tab 2</li>\n<li>Expected: Other users see User A as online (single user, multiple connections)</li>\n<li>Close Tab 1, User A should remain online (Tab 2 still active)</li>\n<li>Close Tab 2, within 10 seconds User A shows as offline</li>\n</ul>\n</li>\n<li><p><strong>Test typing indicator persistence</strong>:</p>\n<ul>\n<li>User A starts typing in room</li>\n<li>User B joins room mid-typing</li>\n<li>Expected: User B immediately sees User A&#39;s typing indicator</li>\n<li>User A stops typing, both User B and new user see indicator clear</li>\n</ul>\n</li>\n</ol>\n<p><strong>Success Indicators</strong>:</p>\n<ul>\n<li>✅ Unauthenticated connections rejected</li>\n<li>✅ Messages survive server restart</li>\n<li>✅ History pagination works (most recent first)</li>\n<li>✅ User presence accurate across multiple devices/sessions</li>\n<li>✅ Typing indicators synchronized correctly</li>\n</ul>\n<blockquote>\n<p><strong>Testing Pro Tip</strong>: Create a <strong>test harness</strong> with these exact verification steps as commented code. As you implement each milestone, uncomment and run the corresponding test block. This builds your test suite incrementally while ensuring backward compatibility.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This guidance provides practical code structures and test utilities to implement the testing strategy.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Learning)</th>\n<th>Advanced Option (Production)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Runner</td>\n<td>Node.js built-in <code>assert</code> + manual scripts</td>\n<td>Jest testing framework</td>\n</tr>\n<tr>\n<td>WebSocket Client for Tests</td>\n<td><code>ws</code> npm package (same as server)</td>\n<td>Puppeteer for browser automation</td>\n</tr>\n<tr>\n<td>Mock/Stub Library</td>\n<td>Manual mock objects</td>\n<td>Jest auto-mocking or Sinon.js</td>\n</tr>\n<tr>\n<td>Test Coverage</td>\n<td>Manual verification checkpoints</td>\n<td>Istanbul/NYC for coverage reports</td>\n</tr>\n<tr>\n<td>Continuous Testing</td>\n<td>Manual re-running of tests</td>\n<td>GitHub Actions with automated test suite</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>real-time-chat/\n├── src/\n│   ├── server.js                    # Main server entry point\n│   ├── connection-manager.js        # Milestone 1 component\n│   ├── room-manager.js              # Milestone 2-3 component  \n│   ├── auth-service.js              # Milestone 4 component\n│   └── message-store.js             # Milestone 4 persistence\n├── tests/\n│   ├── integration/                  # Integration tests\n│   │   ├── connection-manager.test.js\n│   │   ├── room-manager.test.js\n│   │   └── auth-integration.test.js\n│   ├── unit/                        # Unit tests for pure functions\n│   │   ├── validation.test.js\n│   │   ├── message-format.test.js\n│   │   └── crypto-utils.test.js\n│   └── utils/\n│       ├── test-client.js           # Reusable WebSocket test client\n│       └── test-server.js           # Test server setup/teardown\n├── scripts/\n│   ├── test-milestone1.js           # Manual verification scripts\n│   ├── test-milestone2.js\n│   └── benchmark-connections.js     # Optional load testing\n└── package.json</code></pre></div>\n\n<h4 id=\"c-test-infrastructure-starter-code\">C. Test Infrastructure Starter Code</h4>\n<p>Here&#39;s a complete, reusable test client utility for integration tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/utils/test-client.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * TestWebSocketClient - Programmatic client for integration testing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Wraps WebSocket with promise-based methods for easier testing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">url</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.url </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> url;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageQueue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageHandlers </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connectPromise </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Connect to the server with optional authentication token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  connect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> url</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> `${</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">url</span><span style=\"color:#9ECBFF\">}?token=${</span><span style=\"color:#E1E4E8\">token</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.url;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#E1E4E8\">(url);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connectPromise </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#79B8FF\"> Promise</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">resolve</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reject</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'open'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Test client connected to ${</span><span style=\"color:#E1E4E8\">url</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        resolve</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        reject</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Connection failed: ${</span><span style=\"color:#E1E4E8\">error</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">message</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">rawData</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          const</span><span style=\"color:#79B8FF\"> message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(rawData.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">          this</span><span style=\"color:#E1E4E8\">.messageQueue.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">          // Call any registered handlers for this message type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          const</span><span style=\"color:#79B8FF\"> handlers</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(message.type) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          handlers.</span><span style=\"color:#B392F0\">forEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">handler</span><span style=\"color:#F97583\"> =></span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#E1E4E8\">(message));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to parse message:'</span><span style=\"color:#E1E4E8\">, rawData.</span><span style=\"color:#B392F0\">toString</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.connectPromise;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Send a JSON message to the server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.socket.readyState </span><span style=\"color:#F97583\">!==</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'WebSocket not connected'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { type, payload, timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">() };</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(message));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> message;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Wait for a specific message type with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  waitForMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">messageType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeoutMs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5000</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#79B8FF\"> Promise</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">resolve</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reject</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Check if message already in queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> existing</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageQueue.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> m.type </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> messageType);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (existing) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        resolve</span><span style=\"color:#E1E4E8\">(existing);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Set up handler for future message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (message.type </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> messageType) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">          clearTimeout</span><span style=\"color:#E1E4E8\">(timeoutId);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">          resolve</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Add to handlers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(messageType)) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(messageType, []);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(messageType).</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(handler);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Set timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> timeoutId</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> handlers</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(messageType) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#79B8FF\"> index</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> handlers.</span><span style=\"color:#B392F0\">indexOf</span><span style=\"color:#E1E4E8\">(handler);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (index </span><span style=\"color:#F97583\">></span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) handlers.</span><span style=\"color:#B392F0\">splice</span><span style=\"color:#E1E4E8\">(index, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        reject</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Timeout waiting for message type: ${</span><span style=\"color:#E1E4E8\">messageType</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }, timeoutMs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Get all received messages of a specific type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getMessagesOfType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">messageType</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageQueue.</span><span style=\"color:#B392F0\">filter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> m.type </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> messageType);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Clear the message queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  clearQueue</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageQueue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Close the connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  close</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.socket) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> TestWebSocketClient;</span></span></code></pre></div>\n\n<h4 id=\"d-core-test-skeleton-code\">D. Core Test Skeleton Code</h4>\n<p>Here are test skeletons for key integration scenarios:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// tests/integration/room-manager.test.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> TestWebSocketClient</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../utils/test-client'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">startTestServer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">stopTestServer</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../utils/test-server'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">describe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Room Manager Integration Tests'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  let</span><span style=\"color:#E1E4E8\"> server;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  let</span><span style=\"color:#E1E4E8\"> clientA, clientB, clientC;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> TEST_PORT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8081</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  beforeAll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start test server on separate port</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#B392F0\"> startTestServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">TEST_PORT</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  afterAll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#B392F0\"> stopTestServer</span><span style=\"color:#E1E4E8\">(server);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  beforeEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create fresh clients for each test</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clientA </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`ws://localhost:${</span><span style=\"color:#79B8FF\">TEST_PORT</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clientB </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`ws://localhost:${</span><span style=\"color:#79B8FF\">TEST_PORT</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clientC </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`ws://localhost:${</span><span style=\"color:#79B8FF\">TEST_PORT</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Connect all clients with valid authentication tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up default usernames for each client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  afterEach</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean up clients</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (clientA) clientA.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (clientB) clientB.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (clientC) clientC.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Messages broadcast to all room members except sender'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Have clientA and clientB join the same room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Have clientC join a different room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: ClientA sends a chat message to the room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify clientB receives the message with correct content and sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify clientC does NOT receive the message (different room)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify clientA does NOT receive its own message back</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'User join/leave notifications work correctly'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: ClientA joins \"test-room\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: ClientB joins \"test-room\" </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 11: Verify clientA receives user_joined notification for clientB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 12: ClientB leaves the room</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 13: Verify clientA receives user_left notification for clientB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  test</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Message history loads when joining room'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 14: ClientA joins \"history-room\" and sends 5 messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 15: ClientB joins \"history-room\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 16: Verify clientB receives the 5 historical messages (or configured limit)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 17: Verify messages are in correct chronological order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints-javascriptnodejs\">E. Language-Specific Hints (JavaScript/Node.js)</h4>\n<ul>\n<li><strong>Async Testing</strong>: Use <code>async/await</code> with proper timeouts. Jest supports async tests natively.</li>\n<li><strong>WebSocket Testing</strong>: The <code>ws</code> package works in both server and test environments. Remember that WebSocket events are asynchronous.</li>\n<li><strong>Mocking</strong>: For unit tests, create simple factory functions that return mock objects:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#B392F0\"> createMockSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> ({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    send: jest.</span><span style=\"color:#B392F0\">fn</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    close: jest.</span><span style=\"color:#B392F0\">fn</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readyState: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// OPEN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    on: jest.</span><span style=\"color:#B392F0\">fn</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  });</span></span></code></pre></div>\n<ul>\n<li><strong>Cleaning Up</strong>: Always close WebSocket connections after tests to avoid port exhaustion.</li>\n</ul>\n<h4 id=\"f-milestone-checkpoint-verification-scripts\">F. Milestone Checkpoint Verification Scripts</h4>\n<p>Create these scripts to manually verify each milestone:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// scripts/test-milestone1.js - Basic connection verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> readline</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'readline'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> rl</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> readline.</span><span style=\"color:#B392F0\">createInterface</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  input: process.stdin,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  output: process.stdout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'=== Milestone 1: WebSocket Server Verification ===</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> ws</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws://localhost:8080'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'open'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'✅ Connected to server'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'1. Connection established'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Test message sending</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ws.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">({ type: </span><span style=\"color:#9ECBFF\">'ping'</span><span style=\"color:#E1E4E8\">, payload: </span><span style=\"color:#9ECBFF\">'test'</span><span style=\"color:#E1E4E8\"> }));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'2. Sent test message'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Wait for any response</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'3. Connection active for 3 seconds'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rl.</span><span style=\"color:#B392F0\">question</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Press Enter to close connection and verify server cleanup...'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      ws.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Connection closed. Check server logs for cleanup message.'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">✅ Milestone 1 Verification Complete'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Checklist:'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'  - Server accepted connection'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'  - Messages can be sent'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'  - Server handles disconnection'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      rl.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }, </span><span style=\"color:#79B8FF\">3000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> incoming</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`📨 Received: ${</span><span style=\"color:#E1E4E8\">data</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'❌ Connection error:'</span><span style=\"color:#E1E4E8\">, err.message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  rl.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ws.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'close'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> close</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'🔌 Connection closed by server or client'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span></code></pre></div>\n\n<h4 id=\"g-debugging-tips-for-testing\">G. Debugging Tips for Testing</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Messages not appearing</strong></td>\n<td>Room membership incorrect or broadcast logic flawed</td>\n<td>1. Check server logs for broadcast count<br>2. Verify receiver is in same room as sender<br>3. Check message payload structure</td>\n<td>Ensure <code>RoomManager.broadcastToRoom</code> excludes sender and sends to correct member list</td>\n</tr>\n<tr>\n<td><strong>User count wrong after disconnect</strong></td>\n<td>Connection not removed from room membership on disconnect</td>\n<td>1. Check if <code>ConnectionManager.removeConnection</code> calls <code>RoomManager.leaveAllRooms</code><br>2. Verify disconnection detection timing</td>\n<td>Add explicit cleanup in connection close handler</td>\n</tr>\n<tr>\n<td><strong>Server crashes on invalid JSON</strong></td>\n<td>Missing try-catch in message parsing</td>\n<td>1. Look for unhandled exception in logs<br>2. Check <code>parseAndValidateWebSocketMessage</code> error handling</td>\n<td>Wrap JSON.parse in try-catch, send error response instead of crashing</td>\n</tr>\n<tr>\n<td><strong>Typing indicators never clear</strong></td>\n<td>Missing timeout or stop event not sent</td>\n<td>1. Check if <code>setUserTyping</code> sets/resets timers<br>2. Verify client sends <code>typing_stop</code> on blur</td>\n<td>Implement server-side timeout (3 seconds) as backup to client events</td>\n</tr>\n<tr>\n<td><strong>History loads wrong messages</strong></td>\n<td>Database query order incorrect or pagination flawed</td>\n<td>1. Check <code>getMessagesForRoom</code> ORDER BY clause<br>2. Verify limit and offset calculations</td>\n<td>Sort by timestamp DESC for most recent first, use cursor-based pagination</td>\n</tr>\n<tr>\n<td><strong>Authentication bypass possible</strong></td>\n<td>WebSocket upgrade doesn&#39;t validate session</td>\n<td>1. Try connecting without token<br>2. Check <code>authenticateConnection</code> logic</td>\n<td>Validate session during HTTP upgrade before accepting WebSocket connection</td>\n</tr>\n</tbody></table>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4)</p>\n</blockquote>\n<p>Even the most carefully designed systems encounter bugs during implementation. This section provides a practical handbook for diagnosing and fixing the most common issues learners face when building this real-time chat system. Think of debugging as detective work: you observe symptoms, form hypotheses about causes, gather evidence through testing, and apply fixes based on your understanding of the system architecture.</p>\n<p>When building WebSocket applications, bugs often manifest in subtle ways because of the asynchronous, stateful nature of persistent connections. A bug in connection cleanup might not appear until hours of operation, when memory usage balloons. A race condition in room membership might only surface when two users join simultaneously. This guide helps you recognize these patterns early and provides systematic approaches to isolate and fix them.</p>\n<h3 id=\"common-bugs-symptom-cause-fix\">Common Bugs: Symptom → Cause → Fix</h3>\n<p>The following table catalogs the most frequent issues learners encounter, organized by symptom area. Each entry includes the observable symptom, the likely underlying cause, and step-by-step diagnosis steps leading to a fix.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Messages not appearing for other users</strong> (but sender sees their own)</td>\n<td>The <code>broadcastToRoom</code> method is including the sender in the broadcast, or the room membership tracking has incorrect data.</td>\n<td>1. Check the <code>RoomManager.broadcastToRoom</code> implementation - is it using <code>excludeConnectionId</code> parameter?<br>2. Log the list of connection IDs in the room before broadcasting.<br>3. Verify the sender&#39;s connection ID matches their actual connection ID in the room&#39;s member set.</td>\n<td>Ensure <code>broadcastToRoom</code> iterates through <code>room.memberIds</code> and skips the <code>excludeConnectionId</code>. Verify room membership is updated correctly on join/leave.</td>\n</tr>\n<tr>\n<td><strong>User count wrong in room listing</strong> (shows offline users or misses online ones)</td>\n<td>Connection cleanup not removing users from rooms on disconnect, or race condition between join/leave events.</td>\n<td>1. Add logging to <code>ConnectionManager.removeConnection</code> to see when it&#39;s called.<br>2. Verify <code>RoomManager.leaveAllRooms(connectionId)</code> is called in disconnect handler.<br>3. Check for duplicate connection IDs or users joining multiple times.</td>\n<td>Implement <code>ConnectionManager.removeConnection</code> that calls <code>RoomManager.leaveAllRooms</code>. Add connection ID uniqueness validation.</td>\n</tr>\n<tr>\n<td><strong>Server crashes when client disconnects</strong></td>\n<td>Trying to send to or access a socket that has already closed, missing error handlers on WebSocket operations.</td>\n<td>1. Look for <code>socket.send()</code> calls without checking <code>socket.readyState === WebSocket.OPEN</code>.<br>2. Check if event listeners on closed sockets still fire.<br>3. Look for null/undefined socket references in connection tracking map.</td>\n<td>Wrap all <code>socket.send()</code> calls with <code>if (socket.readyState === WebSocket.OPEN)</code>. Implement <code>ConnectionManager.sendToClient</code> with this check.</td>\n</tr>\n<tr>\n<td><strong>Typing indicators never disappear</strong></td>\n<td>No timeout to clear typing status, or timeout not triggering due to event loop issues.</td>\n<td>1. Check <code>RoomManager.setUserTyping</code> implementation - is there a <code>setTimeout</code> to clear?<br>2. Verify the timeout function has access to current connection ID and room ID.<br>3. Check if multiple timeouts are created without clearing previous ones.</td>\n<td>Implement debouncing: store timeout ID per user, clear previous timeout before setting new one. Use <code>clearTimeout()</code> in <code>setUserTyping</code>.</td>\n</tr>\n<tr>\n<td><strong>Old messages appear multiple times when rejoining room</strong></td>\n<td>Message history loading logic doesn&#39;t account for messages already loaded, or pagination cursor logic flawed.</td>\n<td>1. Check <code>getRecentMessagesForRoom</code> - is it always returning same N messages?<br>2. Verify client isn&#39;t storing and re-displaying old messages.<br>3. Check if message IDs are duplicated in database.</td>\n<td>Implement message pagination with <code>lastMessageId</code> parameter. Client should track highest message ID received.</td>\n</tr>\n<tr>\n<td><strong>Can&#39;t join room with special characters in name</strong></td>\n<td>Room name not sanitized, causing issues with room ID generation or storage key creation.</td>\n<td>1. Check <code>createRoom</code> function - how does it generate room ID from name?<br>2. Look for URL-unsafe characters in WebSocket event payloads.<br>3. Test with room names containing spaces, slashes, or Unicode.</td>\n<td>Sanitize room names: convert to lowercase, replace spaces with hyphens, remove special characters. Use a separate generated ID for internal storage.</td>\n</tr>\n<tr>\n<td><strong>Memory usage grows continuously</strong></td>\n<td>Connection objects not cleaned up on disconnect, or message history accumulating without bounds.</td>\n<td>1. Monitor <code>ConnectionManager.connections</code> map size over time.<br>2. Check if <code>Room.memberIds</code> sets grow without removal.<br>3. Verify message store cleanup (<code>deleteMessagesOlderThan</code>) is called.</td>\n<td>Implement periodic cleanup of orphaned rooms. Add connection timeout for inactive sockets. Ensure all remove/disconnect paths clean up state.</td>\n</tr>\n<tr>\n<td><strong>Authentication fails even with correct credentials</strong></td>\n<td>Password hash comparison failing (timing attack protection), or session token not being properly attached to WebSocket upgrade.</td>\n<td>1. Verify password hashing uses same salt rounds and algorithm.<br>2. Check if authentication token is included in WebSocket upgrade URL.<br>3. Test with a known password hash to isolate hashing issue.</td>\n<td>Use constant-time comparison for password hashes. Ensure token is passed in <code>Sec-WebSocket-Protocol</code> header or query parameter.</td>\n</tr>\n<tr>\n<td><strong>Messages arrive out of order</strong></td>\n<td>No timestamp or sequence number in message protocol, asynchronous broadcasting causing race conditions.</td>\n<td>1. Check if <code>ChatMessage.timestamp</code> uses client time instead of server time.<br>2. Look for parallel <code>socket.send()</code> operations without queuing.<br>3. Verify messages are stored with monotonic increasing IDs.</td>\n<td>Assign server-side timestamps in <code>createChatMessage</code>. Use database auto-increment ID for ordering. Implement client-side message queue.</td>\n</tr>\n<tr>\n<td><strong>Rapid clicking causes duplicate messages</strong></td>\n<td>No client-side debouncing on send button, and no idempotency token in message protocol.</td>\n<td>1. Observe network traffic in browser dev tools - are duplicate WebSocket frames sent?<br>2. Check if UI disables send button during transmission.<br>3. Verify server doesn&#39;t process same message ID twice.</td>\n<td>Add client-side debouncing (disable button for 500ms). Include unique message ID in payload, reject duplicates on server.</td>\n</tr>\n<tr>\n<td><strong>Server becomes unresponsive after many connections</strong></td>\n<td>No connection limits, no heartbeat to detect dead connections, synchronous operations blocking event loop.</td>\n<td>1. Monitor CPU and memory usage during load test.<br>2. Check for synchronous file I/O or JSON parsing of large messages.<br>3. Verify heartbeat (ping/pong) is implemented and timing out dead connections.</td>\n<td>Implement WebSocket ping/pong. Add connection limit per IP. Use asynchronous JSON parsing with try-catch.</td>\n</tr>\n<tr>\n<td><strong>Users see other users&#39; messages from wrong rooms</strong></td>\n<td>Message routing bug - messages sent to all rooms or wrong room ID in broadcast.</td>\n<td>1. Check <code>ChatMessage.roomId</code> matches intended room.<br>2. Verify <code>RoomManager.broadcastToRoom</code> is called with correct roomId.<br>3. Look for global broadcast instead of room-specific broadcast.</td>\n<td>Double-check room assignment in message handler. Add validation that sender is in the room they&#39;re messaging.</td>\n</tr>\n<tr>\n<td><strong>&quot;Welcome&quot; messages appear for users already in room</strong></td>\n<td>Join notification being sent to the joining user themselves, not just other members.</td>\n<td>1. Check <code>EVENT_USER_JOINED</code> broadcast logic - is sender excluded?<br>2. Verify separate welcome message isn&#39;t being sent to new user.<br>3. Test with two clients - who receives the join notification?</td>\n<td>Ensure <code>broadcastToRoom</code> for join notifications uses <code>excludeConnectionId</code> parameter. Send separate <code>room_joined</code> event to new user.</td>\n</tr>\n<tr>\n<td><strong>Browser tab duplication causes ghost users</strong></td>\n<td>Same session token used in multiple tabs, causing duplicate presence entries.</td>\n<td>1. Open two tabs with same login - do both appear as separate users?<br>2. Check if session validation allows multiple connections.<br>3. Look for user ID to connection ID mapping issues.</td>\n<td>Implement one-session-per-connection model. On new connection, disconnect previous connection with same user ID.</td>\n</tr>\n<tr>\n<td><strong>Server crashes on malformed JSON message</strong></td>\n<td>No try-catch in <code>parseAndValidateWebSocketMessage</code>, raw message parsing throws exception.</td>\n<td>1. Send invalid JSON via WebSocket client and observe crash.<br>2. Check if error propagates to connection error handler.<br>3. Look for missing validation in message type and payload.</td>\n<td>Wrap JSON.parse in try-catch, send error message to client, keep connection alive. Validate all required fields exist and are correct type.</td>\n</tr>\n<tr>\n<td><strong>Clock shows different times for same message</strong></td>\n<td>Using client-provided timestamps instead of server-assigned timestamps.</td>\n<td>1. Compare <code>ChatMessage.timestamp</code> in database vs. what client displays.<br>2. Check if client is overriding server timestamp with local time.<br>3. Verify all clients use same timezone display.</td>\n<td>Always use server-generated ISO timestamps in <code>createChatMessage</code>. Client should display relative time (&quot;2 minutes ago&quot;) rather than absolute.</td>\n</tr>\n<tr>\n<td><strong>Typing indicator shows for disconnected users</strong></td>\n<td>No cleanup of typing status when user disconnects or leaves room.</td>\n<td>1. Disconnect while typing indicator is active - does it persist?<br>2. Check <code>RoomManager.leaveRoom</code> - does it clear typing status?<br>3. Verify timeout clears typing status even if disconnect happens first.</td>\n<td>Call <code>setUserTyping(connectionId, roomId, false)</code> in <code>leaveRoom</code> and <code>leaveAllRooms</code>. Store typing status per connection, not per user.</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-techniques-and-tools\">Debugging Techniques and Tools</h3>\n<p>Effective debugging requires both systematic thinking and the right tools. Below are techniques specifically valuable for WebSocket-based real-time systems.</p>\n<h4 id=\"strategic-logging-the-time-traveling-observer\">Strategic Logging: The Time-Traveling Observer</h4>\n<blockquote>\n<p>Add logs as if you&#39;re creating a flight recorder for your application. Each log entry should include: timestamp, connection ID, user ID (if known), room ID (if relevant), and the action being performed.</p>\n</blockquote>\n<p>Create a logging helper that wraps key operations:</p>\n<ol>\n<li><strong>Connection lifecycle logging</strong>: Log when connections open, authenticate, join rooms, send messages, and close. Include the reason for closure (normal, error, timeout).</li>\n<li><strong>State dumps</strong>: Periodically log the size of connection maps, room member counts, and memory usage. This helps identify leaks.</li>\n<li><strong>Message flow tracing</strong>: Assign each message a unique correlation ID and log it at each processing stage (receive, validate, route, store, broadcast).</li>\n</ol>\n<p>Example logging strategy table:</p>\n<table>\n<thead>\n<tr>\n<th>When to Log</th>\n<th>What to Include</th>\n<th>Why It Helps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>On WebSocket upgrade</td>\n<td><code>connectionId</code>, client IP, userAgent</td>\n<td>Track connection origins and identify problematic clients</td>\n</tr>\n<tr>\n<td>Before/after <code>broadcastToRoom</code></td>\n<td><code>roomId</code>, <code>messageId</code>, recipient count</td>\n<td>Verify messages reach intended recipients</td>\n</tr>\n<tr>\n<td>On room join/leave</td>\n<td><code>connectionId</code>, <code>userId</code>, <code>roomId</code>, member count before/after</td>\n<td>Debug room membership issues</td>\n</tr>\n<tr>\n<td>On heartbeat timeout</td>\n<td><code>connectionId</code>, last activity timestamp</td>\n<td>Identify zombie connections</td>\n</tr>\n<tr>\n<td>On error in message handler</td>\n<td><code>connectionId</code>, raw message, error stack</td>\n<td>Catch malformed messages before they crash server</td>\n</tr>\n</tbody></table>\n<h4 id=\"browser-websocket-inspector-the-conversation-eavesdropper\">Browser WebSocket Inspector: The Conversation Eavesdropper</h4>\n<p>Modern browser developer tools include WebSocket inspectors that let you observe the raw messages flowing between client and server.</p>\n<p><strong>Using Chrome DevTools:</strong></p>\n<ol>\n<li>Open DevTools (F12) → Network tab</li>\n<li>Refresh page to establish WebSocket connection</li>\n<li>Click the WebSocket request (ws:// or wss://)</li>\n<li>View &quot;Messages&quot; tab to see frames in real-time</li>\n<li>Filter by message type or search content</li>\n</ol>\n<p><strong>What to look for:</strong></p>\n<ul>\n<li>Are messages being sent when you expect them?</li>\n<li>Are the message formats correct (valid JSON)?</li>\n<li>Is the server responding with expected acknowledgments?</li>\n<li>Are there error messages from the server?</li>\n<li>Is the connection closing unexpectedly?</li>\n</ul>\n<p><strong>Pro tip:</strong> You can manually send WebSocket messages from the Console in some browsers using <code>ws.send(JSON.stringify(...))</code> to test server responses.</p>\n<h4 id=\"network-failure-simulation-the-chaos-engineer\">Network Failure Simulation: The Chaos Engineer</h4>\n<p>Many bugs only appear under network instability. Simulate these conditions systematically:</p>\n<table>\n<thead>\n<tr>\n<th>Technique</th>\n<th>How to Simulate</th>\n<th>What Bugs It Reveals</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Network delay</strong></td>\n<td>Use browser DevTools &quot;Network Throttling&quot; or a proxy like Charles</td>\n<td>Timeout handling, message ordering issues</td>\n</tr>\n<tr>\n<td><strong>Packet loss</strong></td>\n<td>Use <code>tc</code> command on Linux: <code>tc qdisc add dev eth0 root netem loss 10%</code></td>\n<td>Message loss, retry logic, heartbeat failures</td>\n</tr>\n<tr>\n<td><strong>Connection interruption</strong></td>\n<td>Temporarily disable WiFi or use browser&#39;s &quot;Offline&quot; mode</td>\n<td>Reconnection logic, state recovery</td>\n</tr>\n<tr>\n<td><strong>Server restart</strong></td>\n<td>Kill and restart server while clients connected</td>\n<td>Session recovery, message persistence</td>\n</tr>\n</tbody></table>\n<p><strong>Systematic testing approach:</strong></p>\n<ol>\n<li>Establish normal chat session with 2-3 clients</li>\n<li>Apply network degradation</li>\n<li>Observe behavior (do messages queue? do connections recover?)</li>\n<li>Restore network</li>\n<li>Verify system returns to normal state</li>\n</ol>\n<h4 id=\"the-rubber-duck-debugging-variant-explain-your-architecture\">The Rubber Duck Debugging Variant: Explain Your Architecture</h4>\n<p>When stuck, explain your implementation out loud or in writing, focusing on data flow:</p>\n<ol>\n<li>&quot;When Alice sends a message to room &#39;general&#39;:&quot;</li>\n<li>&quot;Her browser calls <code>ws.send()</code> with this JSON structure...&quot;</li>\n<li>&quot;The server receives it in <code>ConnectionManager.handleMessage()</code>...&quot;</li>\n<li>&quot;It validates using <code>parseAndValidateWebSocketMessage()</code>...&quot;</li>\n<li>&quot;Then calls <code>RoomManager.broadcastToRoom()</code> with these parameters...&quot;</li>\n<li>&quot;Which retrieves the member set from the Room object...&quot;</li>\n<li>&quot;And for each member except Alice, calls <code>ConnectionManager.sendToClient()</code>...&quot;</li>\n<li>&quot;Which checks <code>socket.readyState</code> before sending...&quot;</li>\n</ol>\n<p>Often, the act of verbalizing the expected flow reveals where your implementation diverges.</p>\n<h4 id=\"state-visualization-the-whiteboard-method\">State Visualization: The Whiteboard Method</h4>\n<p>Draw the current state of your system on a whiteboard or paper:</p>\n<ol>\n<li><strong>Connection map</strong>: Draw boxes for each connection ID, with arrows to user IDs and room IDs</li>\n<li><strong>Room membership</strong>: Create a table with rooms as columns and member connections as rows</li>\n<li><strong>Message flow</strong>: Trace a specific message through the system with timestamps</li>\n</ol>\n<p>This is especially helpful for:</p>\n<ul>\n<li>Understanding why a particular user didn&#39;t receive a message</li>\n<li>Identifying memory leak sources (connections that should have been cleaned up)</li>\n<li>Visualizing race conditions in join/leave sequences</li>\n</ul>\n<h4 id=\"differential-debugging-the-comparison-technique\">Differential Debugging: The Comparison Technique</h4>\n<p>When something works in one scenario but not another, systematically compare:</p>\n<ol>\n<li><strong>Working vs. failing case</strong>: What&#39;s different? Different room? Different user? Different message content?</li>\n<li><strong>Before vs. after a change</strong>: What code changed between when it worked and now?</li>\n<li><strong>Local vs. production</strong>: Environment differences (timeouts, memory limits, network config)</li>\n</ol>\n<p>Create a checklist of comparison points:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Connection parameters (authentication token present?)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Room state (does room exist? correct member set?)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Message format (all required fields present?)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Server logs (any errors in one case but not the other?)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Client state (any JavaScript errors in console?)</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides concrete code and techniques to implement the debugging approaches described above.</p>\n<h4 id=\"a-technology-recommendations-table\">A. Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Debugging Need</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td><code>console.log</code> with timestamps</td>\n<td>Winston or Pino with structured JSON logging</td>\n</tr>\n<tr>\n<td>Network Inspection</td>\n<td>Browser DevTools</td>\n<td>Wireshark or <code>ws</code> library packet logger</td>\n</tr>\n<tr>\n<td>Memory Profiling</td>\n<td>Node.js <code>--inspect</code> flag + Chrome DevTools</td>\n<td>Clinic.js or New Relic</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Manual testing with multiple browser tabs</td>\n<td>Artillery or k6 for WebSocket load testing</td>\n</tr>\n<tr>\n<td>State Visualization</td>\n<td>Manual drawing on whiteboard</td>\n<td>Custom admin dashboard showing real-time connections</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-debug-helper-module-structure\">B. Debug Helper Module Structure</h4>\n<p>Create a dedicated debug module to keep instrumentation code organized:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    server/\n      connection-manager.ts    # Main WebSocket server logic\n      room-manager.ts          # Room and presence management\n      debug/                   # Debugging utilities\n        logger.ts              # Structured logging helper\n        state-inspector.ts     # Functions to dump current state\n        test-client.ts         # Programmatic test WebSocket client\n      index.ts                # Server entry point</code></pre></div>\n\n<h4 id=\"c-complete-debug-logger-implementation\">C. Complete Debug Logger Implementation</h4>\n<p>Here&#39;s a complete, ready-to-use structured logger:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/server/debug/logger.js</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Structured logger for debugging WebSocket chat application</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Usage: logger.log('connect', { connectionId, userId, ip })</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DebugLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">enableConsole</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">enableFile</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.enableConsole </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enableConsole;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.enableFile </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enableFile;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.logFile </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enableFile </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> 'chat-debug.log'</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Main logging method with structured format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> event</span><span style=\"color:#6A737D\"> - Event type (connect, message, disconnect, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {Object}</span><span style=\"color:#E1E4E8\"> data</span><span style=\"color:#6A737D\"> - Structured data about the event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> level</span><span style=\"color:#6A737D\"> - Log level (info, warn, error, debug)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">event</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {}, </span><span style=\"color:#FFAB70\">level</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'info'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> timestamp</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> logEntry</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      timestamp,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      event,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      level,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      pid: process.pid,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      ...</span><span style=\"color:#E1E4E8\">data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Console output (colored for readability)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.enableConsole) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> color</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">_getColorForLevel</span><span style=\"color:#E1E4E8\">(level);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> reset</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\x1b</span><span style=\"color:#9ECBFF\">[0m'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`${</span><span style=\"color:#E1E4E8\">color</span><span style=\"color:#9ECBFF\">}[${</span><span style=\"color:#E1E4E8\">timestamp</span><span style=\"color:#9ECBFF\">}] ${</span><span style=\"color:#E1E4E8\">event</span><span style=\"color:#9ECBFF\">}: ${</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#E1E4E8\">data</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#9ECBFF\">}${</span><span style=\"color:#E1E4E8\">reset</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // File output (append)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.enableFile </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.logFile) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> fs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'fs'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      fs.</span><span style=\"color:#B392F0\">appendFileSync</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.logFile, </span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(logEntry) </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Helper to get console color for log level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  _getColorForLevel</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">level</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> (level) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      case</span><span style=\"color:#9ECBFF\"> 'error'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\x1b</span><span style=\"color:#9ECBFF\">[31m'</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Red</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      case</span><span style=\"color:#9ECBFF\"> 'warn'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\x1b</span><span style=\"color:#9ECBFF\">[33m'</span><span style=\"color:#E1E4E8\">;  </span><span style=\"color:#6A737D\">// Yellow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      case</span><span style=\"color:#9ECBFF\"> 'debug'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\x1b</span><span style=\"color:#9ECBFF\">[36m'</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Cyan</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      default</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\x1b</span><span style=\"color:#9ECBFF\">[32m'</span><span style=\"color:#E1E4E8\">;      </span><span style=\"color:#6A737D\">// Green (info)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Convenience methods for common events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  connectionOpened</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ip</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userAgent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'connection_opened'</span><span style=\"color:#E1E4E8\">, { connectionId, ip, userAgent });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  connectionClosed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'connection_closed'</span><span style=\"color:#E1E4E8\">, { connectionId, reason, code });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  messageReceived</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">messageType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message_received'</span><span style=\"color:#E1E4E8\">, { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      connectionId, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      messageType, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      messageLength: rawMessage?.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#9ECBFF\">'debug'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  messageBroadcast</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">messageId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recipientCount</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">excludeConnectionId</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message_broadcast'</span><span style=\"color:#E1E4E8\">, { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      roomId, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      messageId, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      recipientCount, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      excludeConnectionId </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  roomJoined</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">memberCount</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'room_joined'</span><span style=\"color:#E1E4E8\">, { connectionId, userId, roomId, memberCount });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  roomLeft</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">memberCount</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'room_left'</span><span style=\"color:#E1E4E8\">, { connectionId, userId, roomId, memberCount });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Dump current server state for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {ConnectionManager}</span><span style=\"color:#E1E4E8\"> connectionManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {RoomManager}</span><span style=\"color:#E1E4E8\"> roomManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  dumpState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roomManager</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> state</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      connections: connectionManager?.connections?.size </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      rooms: roomManager?.rooms?.size </span><span style=\"color:#F97583\">||</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      memoryUsage: process.</span><span style=\"color:#B392F0\">memoryUsage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'state_dump'</span><span style=\"color:#E1E4E8\">, state, </span><span style=\"color:#9ECBFF\">'debug'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Singleton instance for easy import</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> DebugLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h4 id=\"d-test-websocket-client-skeleton\">D. Test WebSocket Client Skeleton</h4>\n<p>Create a programmatic test client to simulate users and automate testing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// src/server/debug/test-client.js</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Programmatic WebSocket client for testing server behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> WebSocket</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Create a new test client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> url</span><span style=\"color:#6A737D\"> - WebSocket server URL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">url</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.url </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> url;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageQueue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [];  </span><span style=\"color:#6A737D\">// Stores received messages</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageHandlers </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">();  </span><span style=\"color:#6A737D\">// Type -> handler function</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.connectPromise </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Connect to the server with optional authentication token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> token</span><span style=\"color:#6A737D\"> - Optional authentication token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;void>}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> connect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#79B8FF\"> Promise</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">resolve</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reject</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> urlWithToken</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> token </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> `${</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">url</span><span style=\"color:#9ECBFF\">}?token=${</span><span style=\"color:#E1E4E8\">token</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.url;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WebSocket</span><span style=\"color:#E1E4E8\">(urlWithToken);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'open'</span><span style=\"color:#E1E4E8\">, () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Test client connected to ${</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">url</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        resolve</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'message'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">rawMessage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          const</span><span style=\"color:#79B8FF\"> message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">parse</span><span style=\"color:#E1E4E8\">(rawMessage);</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">          this</span><span style=\"color:#E1E4E8\">.messageQueue.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">          // Call any registered handler for this message type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          const</span><span style=\"color:#79B8FF\"> handler</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(message.type);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          if</span><span style=\"color:#E1E4E8\"> (handler) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            handler</span><span style=\"color:#E1E4E8\">(message.payload);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Failed to parse message:'</span><span style=\"color:#E1E4E8\">, rawMessage);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        reject</span><span style=\"color:#E1E4E8\">(error);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'close'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">code</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Test client disconnected: ${</span><span style=\"color:#E1E4E8\">code</span><span style=\"color:#9ECBFF\">} - ${</span><span style=\"color:#E1E4E8\">reason</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Send a JSON message to the server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> type</span><span style=\"color:#6A737D\"> - Message type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {Object}</span><span style=\"color:#E1E4E8\"> payload</span><span style=\"color:#6A737D\"> - Message payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.socket.readyState </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> message</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { type, payload, timestamp: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">() };</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">JSON</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">stringify</span><span style=\"color:#E1E4E8\">(message));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      return</span><span style=\"color:#E1E4E8\"> message;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      throw</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'WebSocket not connected'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Wait for a specific message type with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> messageType</span><span style=\"color:#6A737D\"> - Type to wait for</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {number}</span><span style=\"color:#E1E4E8\"> timeoutMs</span><span style=\"color:#6A737D\"> - Timeout in milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Promise&#x3C;Object>}</span><span style=\"color:#6A737D\"> - The received message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  waitForMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">messageType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeoutMs</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5000</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> new</span><span style=\"color:#79B8FF\"> Promise</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">resolve</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reject</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> timeout</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> setTimeout</span><span style=\"color:#E1E4E8\">(() </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        reject</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Timeout waiting for ${</span><span style=\"color:#E1E4E8\">messageType</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }, timeoutMs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Check existing messages first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#79B8FF\"> existing</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageQueue.</span><span style=\"color:#B392F0\">find</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> m.type </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> messageType);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (existing) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        clearTimeout</span><span style=\"color:#E1E4E8\">(timeout);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        resolve</span><span style=\"color:#E1E4E8\">(existing);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Set up handler for future messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      const</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">payload</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        clearTimeout</span><span style=\"color:#E1E4E8\">(timeout);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        resolve</span><span style=\"color:#E1E4E8\">({ type: messageType, payload });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">set</span><span style=\"color:#E1E4E8\">(messageType, handler);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Get all received messages of a specific type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@param</span><span style=\"color:#B392F0\"> {string}</span><span style=\"color:#E1E4E8\"> messageType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Array}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getMessagesOfType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">messageType</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.messageQueue.</span><span style=\"color:#B392F0\">filter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">m</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> m.type </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> messageType);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Disconnect from server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  disconnect</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.socket) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket.</span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">      this</span><span style=\"color:#E1E4E8\">.socket </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> null</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Clear message queue and handlers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  clear</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageQueue </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.messageHandlers.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">module</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">exports</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> TestWebSocketClient;</span></span></code></pre></div>\n\n<h4 id=\"e-state-inspector-implementation\">E. State Inspector Implementation</h4>\n<p>Add this to your ConnectionManager to help debug state issues:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Add to src/server/connection-manager.js</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ... existing code ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Debug method: Get current connection state for inspection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Object}</span><span style=\"color:#6A737D\"> - Structured state information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getDebugState</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> connections</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">session</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">of</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.connections) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      connections.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connectionId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        userId: session.userId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        roomId: session.roomId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ip: session.ip,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        connectedAt: session.joinedAt,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastActivity: session.lastActivity,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        readyState: session.socket?.readyState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      totalConnections: </span><span style=\"color:#79B8FF\">this</span><span style=\"color:#E1E4E8\">.connections.size,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      connections,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      serverTime: </span><span style=\"color:#F97583\">new</span><span style=\"color:#B392F0\"> Date</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">toISOString</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      memory: process.</span><span style=\"color:#B392F0\">memoryUsage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Debug method: Find connections with issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * </span><span style=\"color:#F97583\">@returns</span><span style=\"color:#B392F0\"> {Array}</span><span style=\"color:#6A737D\"> - List of problematic connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  findProblematicConnections</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> now</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Date.</span><span style=\"color:#B392F0\">now</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> problematic</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">connectionId</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">session</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">of</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.connections) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Check for zombie connections (no activity for > 30 seconds)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> session.lastActivity </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 30000</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> session.socket.readyState </span><span style=\"color:#F97583\">===</span><span style=\"color:#E1E4E8\"> WebSocket.</span><span style=\"color:#79B8FF\">OPEN</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        problematic.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          connectionId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          issue: </span><span style=\"color:#9ECBFF\">'zombie_connection'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          lastActivity: session.lastActivity,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          idleSeconds: Math.</span><span style=\"color:#B392F0\">floor</span><span style=\"color:#E1E4E8\">((now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> session.lastActivity) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Check for connections without users (shouldn't happen after auth)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">session.userId) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        problematic.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          connectionId,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          issue: </span><span style=\"color:#9ECBFF\">'no_user_id'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          joinedAt: session.joinedAt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> problematic;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"f-debugging-test-scenarios\">F. Debugging Test Scenarios</h4>\n<p>Create automated test scenarios to verify fixes work:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/debug-scenarios.js</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> TestWebSocketClient</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'../src/server/debug/test-client'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">wait</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> require</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'./test-utils'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> testMessageBroadcast</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'=== Testing Message Broadcast ==='</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> client1</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws://localhost:8080'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> client2</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws://localhost:8080'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Connect both clients</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client1.</span><span style=\"color:#B392F0\">connect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'user1_token'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client2.</span><span style=\"color:#B392F0\">connect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'user2_token'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Both join same room</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client1.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'join_room'</span><span style=\"color:#E1E4E8\">, { roomId: </span><span style=\"color:#9ECBFF\">'test-room'</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client2.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'join_room'</span><span style=\"color:#E1E4E8\">, { roomId: </span><span style=\"color:#9ECBFF\">'test-room'</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for join confirmations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client1.</span><span style=\"color:#B392F0\">waitForMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'room_joined'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client2.</span><span style=\"color:#B392F0\">waitForMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'room_joined'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Client1 sends message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> sentMessage</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> client1.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'chat_message'</span><span style=\"color:#E1E4E8\">, {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      content: </span><span style=\"color:#9ECBFF\">'Hello from client1'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      roomId: </span><span style=\"color:#9ECBFF\">'test-room'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Client2 should receive it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> received</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> client2.</span><span style=\"color:#B392F0\">waitForMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'chat_message'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (received.payload.content </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> 'Hello from client1'</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'✅ Message broadcast test PASSED'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'❌ Message broadcast test FAILED'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'❌ Message broadcast test FAILED with error:'</span><span style=\"color:#E1E4E8\">, error.message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">finally</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client1.</span><span style=\"color:#B392F0\">disconnect</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client2.</span><span style=\"color:#B392F0\">disconnect</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> testConnectionCleanup</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'=== Testing Connection Cleanup ==='</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> client</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> TestWebSocketClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'ws://localhost:8080'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">connect</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'test_token'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">send</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'join_room'</span><span style=\"color:#E1E4E8\">, { roomId: </span><span style=\"color:#9ECBFF\">'test-room'</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get initial connection count from server debug endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> initialCount</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#B392F0\"> getConnectionCount</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Disconnect abruptly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client.socket.</span><span style=\"color:#B392F0\">terminate</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// Forceful disconnect</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Wait for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    await</span><span style=\"color:#B392F0\"> wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#79B8FF\"> finalCount</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#B392F0\"> getConnectionCount</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (finalCount </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> initialCount) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'✅ Connection cleanup test PASSED'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'❌ Connection cleanup test FAILED - count:'</span><span style=\"color:#E1E4E8\">, initialCount, </span><span style=\"color:#9ECBFF\">'->'</span><span style=\"color:#E1E4E8\">, finalCount);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'❌ Connection cleanup test FAILED with error:'</span><span style=\"color:#E1E4E8\">, error.message);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Run all debug tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> runAllDebugTests</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Starting debug test suite...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  await</span><span style=\"color:#B392F0\"> testMessageBroadcast</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  await</span><span style=\"color:#B392F0\"> testConnectionCleanup</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Debug test suite completed'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper to get connection count from server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">async</span><span style=\"color:#F97583\"> function</span><span style=\"color:#B392F0\"> getConnectionCount</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Assuming you have a debug HTTP endpoint</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> response</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#B392F0\"> fetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'http://localhost:8080/debug/connections'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> data</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> response.</span><span style=\"color:#B392F0\">json</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> data.totalConnections;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Run if this file is executed directly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (require.main </span><span style=\"color:#F97583\">===</span><span style=\"color:#79B8FF\"> module</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  runAllDebugTests</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"g-language-specific-debugging-hints-javascriptnodejs\">G. Language-Specific Debugging Hints (JavaScript/Node.js)</h4>\n<ol>\n<li><p><strong>WebSocket readyState values:</strong></p>\n<ul>\n<li><code>0</code> (CONNECTING): Socket has been created but connection not yet open</li>\n<li><code>1</code> (OPEN): Connection is open and ready to communicate</li>\n<li><code>2</code> (CLOSING): Connection is in the process of closing</li>\n<li><code>3</code> (CLOSED): Connection is closed or couldn&#39;t be opened</li>\n</ul>\n</li>\n<li><p><strong>Use Node.js inspector:</strong> Run server with <code>node --inspect server.js</code>, then open <code>chrome://inspect</code> in Chrome to debug with breakpoints.</p>\n</li>\n<li><p><strong>Memory leak detection:</strong> Use <code>node --inspect --trace-gc server.js</code> and monitor garbage collection in Chrome DevTools Memory tab.</p>\n</li>\n<li><p><strong>Event loop monitoring:</strong> Use <code>node --trace-event-categories node.perf server.js</code> to generate timeline trace.</p>\n</li>\n<li><p><strong>Handle uncaught exceptions:</strong> Always add:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   process.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'uncaughtException'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Uncaught exception:'</span><span style=\"color:#E1E4E8\">, error);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">     // Don't exit - WebSocket servers should try to recover</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   process.</span><span style=\"color:#B392F0\">on</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'unhandledRejection'</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">promise</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">     console.</span><span style=\"color:#B392F0\">error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'Unhandled rejection at:'</span><span style=\"color:#E1E4E8\">, promise, </span><span style=\"color:#9ECBFF\">'reason:'</span><span style=\"color:#E1E4E8\">, reason);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   });</span></span></code></pre></div>\n\n<h4 id=\"h-milestone-debugging-checkpoints\">H. Milestone Debugging Checkpoints</h4>\n<p>After completing each milestone, run these verification tests:</p>\n<p><strong>Milestone 1: WebSocket Server Setup</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Command: node server.js\nTest: Open browser console, run: ws = new WebSocket('ws://localhost:8080')\nExpected: Server logs &quot;connection_opened&quot;, browser shows readyState changes to 1\nDebug: If connection fails, check server is listening, firewall, and CORS headers</code></pre></div>\n\n<p><strong>Milestone 2: Message Broadcasting</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Command: Open two browser tabs to your chat page\nTest: Send message from Tab 1\nExpected: Message appears in Tab 2 (but not duplicated in Tab 1)\nDebug: Use browser Network tab → WS → Messages to see frames</code></pre></div>\n\n<p><strong>Milestone 3: Chat Rooms</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Command: Join different rooms in different tabs\nTest: Send message in Room A (Tab 1), check Room B (Tab 2)\nExpected: Message only appears in same room tab\nDebug: Check room IDs in message payloads and member sets</code></pre></div>\n\n<p><strong>Milestone 4: Authentication &amp; Persistence</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Command: Restart server, reload chat page\nTest: Send messages, restart server, reload page, rejoin room\nExpected: Previous messages loaded from history\nDebug: Check database queries, message timestamps, pagination limits</code></pre></div>\n\n\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section explores enhancements that build upon all four milestones, showing how the foundational architecture can evolve to support more sophisticated features and scale.</p>\n</blockquote>\n<p>The current architecture provides a solid foundation for a real-time chat application that meets the project&#39;s learning objectives. However, real-world chat systems often include additional features and face scaling requirements that exceed the initial scope. This section explores potential enhancements, analyzing how the current design accommodates them and what modifications would be necessary. Understanding these extension points helps illustrate how the principles learned—stateful connections, room-based messaging, presence, and persistence—form the basis for more complex systems.</p>\n<h3 id=\"potential-features-and-scaling-paths\">Potential Features and Scaling Paths</h3>\n<p>The journey from a learning project to a production-ready chat system involves adding user-facing features and addressing scalability limitations. The following enhancements are organized by their impact on the architecture: from simple feature additions that fit within the current component boundaries, to significant architectural changes required for horizontal scaling.</p>\n<h4 id=\"feature-enhancements-within-current-architecture\">Feature Enhancements Within Current Architecture</h4>\n<p>Several valuable chat features can be implemented with minimal changes to the core architecture, primarily by extending existing components and adding new message types to the wire protocol.</p>\n<p><strong>Direct (Private) Messaging</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Post Office&#39;s Registered Mail</p>\n<p>While room-based messaging is like broadcasting announcements in a town square, direct messaging is like sending a sealed letter to a specific individual. The postal system (our architecture) already knows how to route messages and track user locations (presence); we just need to add addressing rules that deliver to a single recipient rather than a room&#39;s subscriber list.</p>\n</blockquote>\n<p>Direct messaging enables users to send private messages to other users regardless of which rooms they&#39;re currently in. This feature requires:</p>\n<ol>\n<li><strong>New Message Type:</strong> Add <code>EVENT_DIRECT_MESSAGE</code> to the protocol.</li>\n<li><strong>Recipient Routing:</strong> Extend the <code>RoomManager.broadcastToRoom</code> method or create a new <code>sendToUser</code> method that looks up the recipient&#39;s current <code>ClientSession</code> via their <code>userId</code>.</li>\n<li><strong>Presence Check:</strong> Verify the recipient is online before sending, with optional offline message queuing.</li>\n<li><strong>Privacy Controls:</strong> Allow users to block messages from specific users.</li>\n</ol>\n<p>The current data model already supports this: <code>ClientSession</code> links a <code>userId</code> to a specific connection. The main architectural addition is a user-to-connection lookup index in the <code>ConnectionManager</code> or <code>RoomManager</code>.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Component</strong></th>\n<th><strong>Changes Required</strong></th>\n<th><strong>Data Flow Impact</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Wire Protocol</strong></td>\n<td>Add <code>EVENT_DIRECT_MESSAGE</code> type with <code>recipientId</code> field</td>\n<td>New message flow: Client → Server → Specific Client</td>\n</tr>\n<tr>\n<td><strong>ConnectionManager</strong></td>\n<td>Maintain <code>userId</code> → <code>connectionId</code> lookup map</td>\n<td>Enables direct routing without room context</td>\n</tr>\n<tr>\n<td><strong>RoomManager</strong></td>\n<td>Add <code>sendToUser(userId, message)</code> method</td>\n<td>Uses ConnectionManager&#39;s lookup to deliver</td>\n</tr>\n<tr>\n<td><strong>Client Application</strong></td>\n<td>Add UI for user list and private chat windows</td>\n<td>New subscription to direct message events</td>\n</tr>\n</tbody></table>\n<p><strong>Message Reactions and Threads</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> Marginal Notes and Conversation Threads</p>\n<p>Reactions are like scribbling an emoji in the margin of a printed chat transcript—a lightweight annotation attached to a specific message. Threads are like starting a sidebar conversation linked to a particular comment in a meeting minutes document.</p>\n</blockquote>\n<p>Reactions (e.g., 👍, ❤️) allow users to respond to specific messages without creating new chat messages. Threads enable nested conversations about specific messages. Both features require:</p>\n<ol>\n<li><strong>Message References:</strong> Extend <code>ChatMessage</code> with optional <code>parentMessageId</code> and <code>reactions</code> field (a map of emoji→userIds).</li>\n<li><strong>New Event Types:</strong> <code>EVENT_REACTION_ADDED</code>, <code>EVENT_THREAD_REPLY</code>.</li>\n<li><strong>Persistence Updates:</strong> Modify <code>storeMessage</code> to handle parent relationships and update reactions atomically.</li>\n<li><strong>Efficient Broadcast:</strong> When a reaction is added, broadcast only the reaction delta, not the entire message history.</li>\n</ol>\n<p>The current <code>ChatMessage</code> structure can be extended with additional fields. The <code>RoomManager</code> would need logic to validate that referenced messages exist in the same room.</p>\n<p><strong>Read Receipts</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> Certified Mail with Return Receipt</p>\n<p>Read receipts provide sender confirmation that their message was seen by the recipient, similar to certified mail that requires a signature upon delivery. The system must track which users have &quot;seen&quot; each message.</p>\n</blockquote>\n<p>Read receipts show when messages have been viewed by recipients. Implementation requires:</p>\n<ol>\n<li><strong>Client-Side Visibility Tracking:</strong> The client must detect when a message becomes visible in the viewport and send a <code>EVENT_MESSAGE_READ</code> event.</li>\n<li><strong>Server-Side State Management:</strong> The server must track which users have read which messages (a <code>messageId</code> → <code>Set&lt;userId&gt;</code> mapping).</li>\n<li><strong>Efficient Updates:</strong> When a user reads multiple messages (e.g., scrolling through history), batch updates are preferable to individual events.</li>\n<li><strong>Broadcast Updates:</strong> Notify the message sender when their messages are read (optional).</li>\n</ol>\n<p>This feature adds significant state management complexity. A separate <code>ReadReceiptService</code> component might be warranted to avoid bloating the <code>RoomManager</code>.</p>\n<p><strong>Rich Media and File Sharing</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Package Delivery Service</p>\n<p>While text messages are like postcards (small, simple), file sharing is like shipping packages. We need a separate handling process: receiving the large payload, storing it in a warehouse (object storage), and providing a delivery receipt (URL) that recipients can use to retrieve it.</p>\n</blockquote>\n<p>Allowing users to share images, documents, and other files requires:</p>\n<ol>\n<li><strong>Separate Upload Pathway:</strong> Large files shouldn&#39;t go through WebSocket binary messages. Implement HTTP POST endpoints for file upload.</li>\n<li><strong>Object Storage Integration:</strong> Store files in cloud storage (S3, GCS) or a local filesystem with access controls.</li>\n<li><strong>Message with Metadata:</strong> Send chat messages containing file metadata (URL, filename, size, MIME type) via WebSocket.</li>\n<li><strong>Security Considerations:</strong> Validate file types, scan for malware, implement access tokens for private files.</li>\n</ol>\n<p>The current architecture&#39;s separation between WebSocket messaging and HTTP services (for authentication) provides a pattern for adding additional HTTP endpoints.</p>\n<p><strong>Bot Integrations and Webhooks</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Conference Call Interpreter</p>\n<p>Bots are like interpreters joining a conference call—they listen to conversations, can be addressed directly with commands, and can inject their own messages. Webhooks are like setting up a microphone in the room that streams the conversation to external services.</p>\n</blockquote>\n<p>Bots are automated users that respond to commands or patterns. Webhooks allow external services to receive room events. Both require:</p>\n<ol>\n<li><strong>Programmatic Client API:</strong> A simplified client SDK for bots to connect and interact.</li>\n<li><strong>Command Parsing:</strong> Middleware to detect bot commands (e.g., <code>/giphy cats</code>).</li>\n<li><strong>Rate Limiting:</strong> Prevent bots from spamming rooms.</li>\n<li><strong>Webhook Delivery:</strong> HTTP callback system to POST room events to external URLs.</li>\n</ol>\n<p>The current <code>RoomManager.broadcastToRoom</code> method already delivers messages to all connections; bots would simply be additional connections with special processing logic.</p>\n<p><strong>Advanced Presence States</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Office Status Light</p>\n<p>Beyond simple online/offline, users can have statuses like &quot;away,&quot; &quot;do not disturb,&quot; or &quot;in a meeting&quot;—similar to an office door having a light that shows availability for interruptions.</p>\n</blockquote>\n<p>Extend the basic presence system to show user availability states:</p>\n<ol>\n<li><strong>State Transitions:</strong> Define states (<code>online</code>, <code>away</code>, <code>busy</code>, <code>offline</code>) with automatic transitions (e.g., <code>away</code> after keyboard inactivity).</li>\n<li><strong>Client Heartbeat Enhancement:</strong> Extend the heartbeat mechanism to include user activity state.</li>\n<li><strong>Status Broadcast:</strong> Update <code>EVENT_USER_PRESENCE</code> to include detailed status and optional custom message.</li>\n<li><strong>Privacy Controls:</strong> Allow users to hide detailed presence from certain users.</li>\n</ol>\n<p>The <code>ClientSession</code> already has <code>lastActivity</code>; this can be extended with <code>presenceState</code> and <code>statusMessage</code> fields.</p>\n<h4 id=\"scaling-beyond-a-single-server\">Scaling Beyond a Single Server</h4>\n<p>The current architecture assumes a single Node.js process handling all connections. While this can support thousands of concurrent users (depending on message volume), true horizontal scaling requires significant architectural changes.</p>\n<p><strong>Decision: Scaling WebSocket Connections Across Multiple Servers</strong></p>\n<ul>\n<li><strong>Context:</strong> The single-server architecture faces limits on concurrent connections (memory, CPU, file descriptor limits). To support tens or hundreds of thousands of users, connections must be distributed across multiple servers.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Load Balancer with IP Hashing:</strong> A TCP load balancer (L4) distributes connections based on client IP, keeping each user&#39;s connection on the same server.</li>\n<li><strong>WebSocket-Aware Load Balancer:</strong> A layer 7 load balancer that understands WebSocket protocol and can route based on cookies or custom headers.</li>\n<li><strong>Connection Routing Service:</strong> A dedicated service that assigns clients to specific backend servers and handles re-routing.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Use a WebSocket-aware load balancer (option 2) for simplicity, combined with a shared persistence layer.</li>\n<li><strong>Rationale:</strong> Layer 7 load balancers (like Nginx with WebSocket support) are mature, require minimal application changes, and can handle SSL termination. IP hashing (option 1) breaks when users change networks or use load-balanced mobile networks.</li>\n<li><strong>Consequences:</strong> Requires all servers to have access to shared room state and message history. The in-memory room state becomes invalid; we must move to external storage.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>Option</strong></th>\n<th><strong>Pros</strong></th>\n<th><strong>Cons</strong></th>\n<th><strong>Viability</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>IP Hashing Load Balancer</strong></td>\n<td>Simple, works at TCP layer, minimal configuration</td>\n<td>Same user from different IPs may connect to different servers, breaking state</td>\n<td>Poor - breaks user experience</td>\n</tr>\n<tr>\n<td><strong>WebSocket-Aware Load Balancer</strong></td>\n<td>Can use cookies/sessions for sticky routing, handles WebSocket upgrade</td>\n<td>More complex configuration, requires session affinity</td>\n<td><strong>Good</strong> - balances simplicity and functionality</td>\n</tr>\n<tr>\n<td><strong>Connection Routing Service</strong></td>\n<td>Maximum flexibility, can implement custom routing logic</td>\n<td>Additional service to build and maintain, new failure point</td>\n<td>Overkill for most applications</td>\n</tr>\n</tbody></table>\n<p><strong>Shared State with Redis or Database</strong>\nWhen moving to multiple servers, the in-memory room and presence state must be externalized to a shared data store. Redis is ideal for this due to its low-latency data structures and publish/subscribe capabilities.</p>\n<table>\n<thead>\n<tr>\n<th><strong>Current Component</strong></th>\n<th><strong>Multi-Server Adaptation</strong></th>\n<th><strong>Redis Data Structures</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>ConnectionManager.activeConnections</strong></td>\n<td>Each server maintains only its local connections</td>\n<td>Not shared; ephemeral connection state remains local</td>\n</tr>\n<tr>\n<td><strong>RoomManager.rooms</strong> (member lists)</td>\n<td>Store in Redis Sorted Sets or Hashes</td>\n<td><code>room:members:{roomId}</code> → Set of <code>userId</code>s</td>\n</tr>\n<tr>\n<td><strong>User Presence Status</strong></td>\n<td>Store in Redis with TTL</td>\n<td><code>user:presence:{userId}</code> → Hash with status, lastSeen</td>\n</tr>\n<tr>\n<td><strong>Typing Indicators</strong></td>\n<td>Store in Redis with short TTL</td>\n<td><code>room:typing:{roomId}</code> → Hash of <code>userId</code> → timestamp</td>\n</tr>\n<tr>\n<td><strong>Message Routing</strong></td>\n<td>Use Redis Pub/Sub for cross-server broadcasts</td>\n<td>Publish to channel <code>room:{roomId}</code>; all servers subscribe</td>\n</tr>\n</tbody></table>\n<p><strong>Stateless WebSocket Servers with External Message Queue</strong>\nFor maximum scalability, the WebSocket servers can become stateless connection handlers that delegate all business logic to external services via message queues.</p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Airport Gate Agents vs. Air Traffic Control</p>\n<p>In this model, WebSocket servers are like gate agents—they manage the direct interaction with passengers (clients) but don&#39;t make routing decisions. A central &quot;air traffic control&quot; (message queue + worker services) coordinates all flights (messages) between gates.</p>\n</blockquote>\n<ol>\n<li><strong>WebSocket Servers</strong> only handle connection lifecycle and raw message I/O.</li>\n<li><strong>All business logic</strong> (room joins, message validation, presence updates) moves to separate worker services.</li>\n<li><strong>A message queue</strong> (like RabbitMQ, Kafka, or Redis Streams) routes events between components.</li>\n<li><strong>Connection routing layer</strong> tracks which server hosts each user&#39;s connection.</li>\n</ol>\n<p>This is a significant architectural shift that introduces complexity but enables independent scaling of connection handling versus business logic processing.</p>\n<p><strong>ADR: When to Consider Multi-Server Architecture</strong></p>\n<ul>\n<li><strong>Context:</strong> Determining when the single-server architecture becomes inadequate and requires the complexity of distributed systems.</li>\n<li><strong>Options Considered:</strong><ol>\n<li><strong>Scale from Day One:</strong> Implement multi-server architecture even for the learning project.</li>\n<li><strong>Scale When Needed:</strong> Start with single-server, refactor when hitting limits.</li>\n<li><strong>Hybrid Approach:</strong> Design with extension points for distribution but implement single-server first.</li>\n</ol>\n</li>\n<li><strong>Decision:</strong> Hybrid approach (option 3)—design clean interfaces between components so they can be distributed later without rewriting application logic.</li>\n<li><strong>Rationale:</strong> Premature optimization distracts from learning core concepts. However, anticipating future scaling informs better interface design today (e.g., abstracting storage behind interfaces).</li>\n<li><strong>Consequences:</strong> Some refactoring will still be needed when scaling, but the core application logic remains largely unchanged.</li>\n</ul>\n<h4 id=\"security-and-moderation-enhancements\">Security and Moderation Enhancements</h4>\n<p>Production chat systems require robust security and moderation features that go beyond basic authentication.</p>\n<p><strong>End-to-End Encryption</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Diplomatic Pouch</p>\n<p>End-to-end encryption ensures only the intended recipients can read messages, like diplomatic documents sealed in a tamper-proof pouch that only the sender and recipient have keys to open.</p>\n</blockquote>\n<p>Implementing true end-to-end encryption (where the server cannot decrypt messages) requires:</p>\n<ol>\n<li><strong>Key Exchange:</strong> Clients must exchange public keys (via the server as an untrusted channel).</li>\n<li><strong>Client-Side Encryption:</strong> Messages are encrypted/decrypted in the client application using WebCrypto API.</li>\n<li><strong>Server as Message Relay:</strong> The server stores and forwards encrypted blobs without understanding content.</li>\n<li><strong>Key Management:</strong> Handle key loss, device addition, and group chats (which require more complex encryption schemes).</li>\n</ol>\n<p>This fundamentally changes the server&#39;s role from message processor to blind router and significantly increases client complexity.</p>\n<p><strong>Content Moderation and Filtering</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Editor&#39;s Red Pen</p>\n<p>Automated moderation scans messages for inappropriate content before or after they&#39;re sent, similar to an editor reviewing articles before publication.</p>\n</blockquote>\n<p>Moderation features include:</p>\n<ol>\n<li><strong>Automated Keyword Filtering:</strong> Scan messages for banned words/phrases.</li>\n<li><strong>Image Analysis:</strong> Use AI services to detect inappropriate images.</li>\n<li><strong>Report System:</strong> Allow users to report offensive messages.</li>\n<li><strong>Moderator Dashboard:</strong> Interface for human moderators to review reports and take action.</li>\n</ol>\n<p>Implementation requires message processing pipeline extensions—potentially asynchronous processing where messages are queued for moderation review before being broadcast.</p>\n<p><strong>Rate Limiting and Anti-Spam</strong></p>\n<blockquote>\n<p><strong>Mental Model:</strong> The Conversation Pacekeeper</p>\n<p>Rate limiting prevents users from overwhelming the system with too many messages too quickly, like a moderator ensuring everyone gets a turn to speak.</p>\n</blockquote>\n<p>Protect the system from abuse by:</p>\n<ol>\n<li><strong>Connection-Level Rate Limiting:</strong> Limit message frequency per connection.</li>\n<li><strong>User-Level Rate Limiting:</strong> Track message counts per user across all connections.</li>\n<li><strong>Content-Based Rules:</strong> Detect and block spam patterns (repeated messages, excessive mentions).</li>\n<li><strong>Graduated Response:</strong> Start with warnings, then temporary mutes, then bans.</li>\n</ol>\n<p>The <code>ConnectionManager</code> would need to track message timestamps per connection/user and implement sliding window algorithms.</p>\n<h4 id=\"performance-optimizations\">Performance Optimizations</h4>\n<p>As user count and message volume grow, performance optimizations become necessary.</p>\n<p><strong>Message Compression</strong>\nWebSocket messages can be compressed using permessage-deflate extension (built into most WebSocket libraries). For text-heavy chat, compression can reduce bandwidth by 70-90%.</p>\n<p><strong>Client-Side Message Caching and Delta Updates</strong>\nInstead of sending full message history each time a user joins a room, clients can cache messages locally and request only updates since their last view. This requires:</p>\n<ol>\n<li><strong>Client Storage:</strong> Use IndexedDB or localStorage to cache messages per room.</li>\n<li><strong>Sync Tokens:</strong> Server provides synchronization tokens representing state versions.</li>\n<li><strong>Delta Calculations:</strong> Server computes differences between client cache and current state.</li>\n</ol>\n<p><strong>Efficient Presence Broadcasts</strong>\nBroadcasting presence updates for large rooms (1000+ users) can create significant load. Optimizations include:</p>\n<ol>\n<li><strong>Throttling Updates:</strong> Batch presence changes and send less frequently.</li>\n<li><strong>Lazy Loading:</strong> Only load presence for users currently visible in the client viewport.</li>\n<li><strong>Presence Channels:</strong> Separate presence updates from chat messages, allowing clients to opt-in based on interest.</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The following guidance provides practical steps for implementing some of the simpler extensions while maintaining the current architecture.</p>\n<h4 id=\"technology-recommendations-for-extensions\">Technology Recommendations for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th><strong>Feature</strong></th>\n<th><strong>Simple Option (Learning Focus)</strong></th>\n<th><strong>Production-Ready Option</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Direct Messaging</strong></td>\n<td>Extend <code>RoomManager</code> with user lookup map</td>\n<td>Implement with dedicated messaging service</td>\n</tr>\n<tr>\n<td><strong>File Sharing</strong></td>\n<td>Local filesystem storage with size limits</td>\n<td>Cloud object storage (S3) with CDN</td>\n</tr>\n<tr>\n<td><strong>Bot Framework</strong></td>\n<td>Simple command parser in <code>RoomManager</code></td>\n<td>Bot SDK with middleware pipeline</td>\n</tr>\n<tr>\n<td><strong>Multi-Server Scaling</strong></td>\n<td>Sticky sessions with Redis for shared state</td>\n<td>Full microservices with message queue</td>\n</tr>\n<tr>\n<td><strong>End-to-End Encryption</strong></td>\n<td>Basic symmetric encryption demo</td>\n<td>Proper key management with Signal Protocol</td>\n</tr>\n<tr>\n<td><strong>Moderation</strong></td>\n<td>Keyword filter middleware</td>\n<td>AI content moderation API integration</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-for-extensions\">File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>chat-project/\n├── server/\n│   ├── src/\n│   │   ├── core/                    # Existing core components\n│   │   │   ├── ConnectionManager.ts\n│   │   │   ├── RoomManager.ts\n│   │   │   └── AuthService.ts\n│   │   ├── extensions/              # New extensions directory\n│   │   │   ├── DirectMessaging.ts   # Direct message handler\n│   │   │   ├── FileService.ts       # File upload/download\n│   │   │   ├── BotFramework.ts      # Bot command processing\n│   │   │   ├── Moderation.ts        # Content filtering\n│   │   │   └── RateLimiter.ts       # Rate limiting middleware\n│   │   ├── shared/                  # Shared utilities\n│   │   │   ├── redis.ts            # Redis client for shared state\n│   │   │   └── encryption.ts       # Encryption helpers\n│   │   └── main.ts                 # Updated to load extensions\n│   └── uploads/                    # Local file storage (if used)\n└── client/\n    └── src/\n        ├── extensions/              # Client-side extension code\n        │   ├── DirectMessageUI.tsx  # Private chat UI component\n        │   └── FileUploader.tsx     # File upload component\n        └── crypto/                  # Client-side encryption (if needed)</code></pre></div>\n\n<h4 id=\"starter-code-for-direct-messaging-extension\">Starter Code for Direct Messaging Extension</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/src/extensions/DirectMessaging.ts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { ConnectionManager } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> '../core/ConnectionManager'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { RoomManager } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> '../core/RoomManager'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { createServerMessage } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> '../shared/protocol'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// New event type constant</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> EVENT_DIRECT_MESSAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'direct_message'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> EVENT_DIRECT_MESSAGE_DELIVERED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'direct_message_delivered'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> EVENT_DIRECT_MESSAGE_ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'direct_message_error'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Direct Messaging Extension</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This extension adds private messaging between users.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * It maintains a map of userId -> connectionId for online users</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and routes direct messages to the appropriate recipient.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> DirectMessaging</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> userConnections</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// userId -> connectionId</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> connectionUsers</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// connectionId -> userId</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> connectionManager</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> ConnectionManager</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    private</span><span style=\"color:#FFAB70\"> roomManager</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> RoomManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Listen for user authentication events</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">setupEventHandlers</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Register a user's current connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  registerUserConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Update userConnections map with userId -> connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update connectionUsers map with connectionId -> userId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Clean up old mapping if user had previous connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Remove a user's connection mapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  unregisterUserConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">connectionId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get userId from connectionUsers map using connectionId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove entry from connectionUsers map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove entry from userConnections map if it maps to this connectionId</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Handle incoming direct message from a client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> handleDirectMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">senderConnectionId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">messagePayload</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Promise</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#79B8FF\">void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Extract recipientId and content from messagePayload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate recipientId exists and is not the sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Look up recipient's connectionId from userConnections map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If recipient is online, forward message using connectionManager.sendToClient</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send delivery confirmation to sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If recipient is offline, store message for later delivery (optional)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle errors (invalid recipient, message too long, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Check if a user is currently online</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  isUserOnline</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> boolean</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if userId exists in userConnections map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.userConnections.</span><span style=\"color:#B392F0\">has</span><span style=\"color:#E1E4E8\">(userId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Get the connection ID for an online user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getConnectionForUser</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">userId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> undefined</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return connectionId from userConnections map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.userConnections.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(userId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#B392F0\"> setupEventHandlers</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> void</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Listen for user authentication events from RoomManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Listen for connection disconnect events from ConnectionManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register message handler for EVENT_DIRECT_MESSAGE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"starter-code-for-file-service-extension\">Starter Code for File Service Extension</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// server/src/extensions/FileService.ts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> fs </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'fs/promises'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'path'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { v4 </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> uuidv4 } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'uuid'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Constants for file handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> MAX_FILE_SIZE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// 10MB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> ALLOWED_MIME_TYPES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  'image/jpeg'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  'image/png'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  'image/gif'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  'application/pdf'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  'text/plain'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> UPLOAD_DIR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> './uploads'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * File Service for handling file uploads and downloads</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * This service provides HTTP endpoints for file upload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * and manages file metadata for inclusion in chat messages.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#F97583\"> class</span><span style=\"color:#B392F0\"> FileService</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#FFAB70\"> fileMetadata</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> Map</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// fileId -> { filename, mimeType, size, uploader, uploadDate }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  constructor</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    this</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ensureUploadDirectory</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Ensure upload directory exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  private</span><span style=\"color:#F97583\"> async</span><span style=\"color:#B392F0\"> ensureUploadDirectory</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Promise</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#79B8FF\">void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      await</span><span style=\"color:#E1E4E8\"> fs.</span><span style=\"color:#B392F0\">access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">UPLOAD_DIR</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      await</span><span style=\"color:#E1E4E8\"> fs.</span><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">UPLOAD_DIR</span><span style=\"color:#E1E4E8\">, { recursive: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Handle file upload from HTTP request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> handleUpload</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fileData</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">mimeType</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">uploaderId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Promise</span><span style=\"color:#E1E4E8\">&#x3C;{ </span><span style=\"color:#FFAB70\">fileId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">url</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\"> }> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate file size against MAX_FILE_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate mimeType against ALLOWED_MIME_TYPES</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate unique fileId using uuidv4()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create safe filename (prevent path traversal)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Write file to disk in UPLOAD_DIR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store metadata in fileMetadata map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return fileId and URL for client access</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Get file metadata by ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  getFileMetadata</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fileId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return metadata from fileMetadata map</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> this</span><span style=\"color:#E1E4E8\">.fileMetadata.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(fileId);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Serve file for download</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> serveFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fileId</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> string</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Promise</span><span style=\"color:#E1E4E8\">&#x3C;{ </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">metadata</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\"> }> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up metadata by fileId</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read file from disk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return file data and metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  /**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   * Clean up old files (cron job)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  async</span><span style=\"color:#B392F0\"> cleanupOldFiles</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">maxAgeDays</span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> number</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">:</span><span style=\"color:#B392F0\"> Promise</span><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#79B8FF\">void</span><span style=\"color:#E1E4E8\">> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through fileMetadata map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check uploadDate for each file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Delete files older than maxAgeDays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove entries from fileMetadata map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-javascripttypescript\">Language-Specific Hints for JavaScript/TypeScript</h4>\n<ul>\n<li><strong>Direct Messaging:</strong> Use <code>Map</code> for <code>userId → connectionId</code> lookups for O(1) access. Remember to clean up mappings when connections close to prevent memory leaks.</li>\n<li><strong>File Uploads:</strong> For production, use streams (<code>fs.createWriteStream</code>) instead of writing entire buffers to handle large files efficiently.</li>\n<li><strong>Redis Integration:</strong> Use the <code>ioredis</code> library for Redis connections with connection pooling and automatic reconnection.</li>\n<li><strong>Rate Limiting:</strong> Implement sliding window algorithm using Redis sorted sets for distributed rate limiting across multiple servers.</li>\n<li><strong>Bot Framework:</strong> Create a middleware pipeline pattern where messages pass through bot handlers sequentially until one consumes the message.</li>\n</ul>\n<h4 id=\"milestone-extension-checkpoints\">Milestone Extension Checkpoints</h4>\n<p><strong>Direct Messaging Implementation Check:</strong></p>\n<ol>\n<li>Start the server and connect two authenticated clients (Alice and Bob).</li>\n<li>Alice sends a direct message to Bob using the new message type.</li>\n<li>Verify Bob receives the message immediately.</li>\n<li>Verify Alice receives a delivery confirmation.</li>\n<li>Test offline case: disconnect Bob, send message from Alice, then reconnect Bob—message should not be delivered unless you implemented offline queueing.</li>\n</ol>\n<p><strong>File Sharing Implementation Check:</strong></p>\n<ol>\n<li>Start server with file upload endpoint.</li>\n<li>Use curl or Postman to POST a file to <code>/api/upload</code>.</li>\n<li>Verify server returns a <code>fileId</code> and URL.</li>\n<li>Send a chat message containing the file metadata.</li>\n<li>Other clients should see the file message and be able to download it via the provided URL.</li>\n</ol>\n<p><strong>Multi-Server Scaling Check (Advanced):</strong></p>\n<ol>\n<li>Start two server instances on different ports.</li>\n<li>Configure a load balancer (nginx) with sticky sessions.</li>\n<li>Connect multiple clients, ensuring they distribute across servers.</li>\n<li>Using Redis, verify that room membership and presence updates propagate across servers.</li>\n<li>Send a message in a room with users connected to different servers—all should receive it.</li>\n</ol>\n<h4 id=\"debugging-tips-for-extensions\">Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th><strong>Symptom</strong></th>\n<th><strong>Likely Cause</strong></th>\n<th><strong>How to Diagnose</strong></th>\n<th><strong>Fix</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Direct messages not delivered</strong></td>\n<td>User connection mapping not updated</td>\n<td>Check <code>userConnections</code> map after login</td>\n<td>Ensure <code>registerUserConnection</code> is called on authentication</td>\n</tr>\n<tr>\n<td><strong>File uploads failing silently</strong></td>\n<td>Upload directory permissions</td>\n<td>Check server logs for EACCES errors</td>\n<td>Ensure upload directory exists and is writable</td>\n</tr>\n<tr>\n<td><strong>Presence not syncing across servers</strong></td>\n<td>Redis connection issues</td>\n<td>Check Redis connectivity and Pub/Sub subscriptions</td>\n<td>Verify Redis URL and ensure all servers subscribe to same channels</td>\n</tr>\n<tr>\n<td><strong>Rate limiting blocking legitimate users</strong></td>\n<td>Algorithm too aggressive</td>\n<td>Log rate limit counters and timestamps</td>\n<td>Adjust time window or increase limit thresholds</td>\n</tr>\n<tr>\n<td><strong>Bots not responding to commands</strong></td>\n<td>Command prefix mismatch</td>\n<td>Log raw messages entering bot handler</td>\n<td>Ensure command parsing logic matches client sending format</td>\n</tr>\n</tbody></table>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4). This glossary defines key terms and concepts used throughout the design document, providing a common vocabulary for understanding the real-time chat application architecture.</p>\n</blockquote>\n<h3 id=\"terms-and-definitions\">Terms and Definitions</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authentication</strong></td>\n<td>The process of verifying a user&#39;s identity before granting access to the system, typically by validating credentials (username and password) during the WebSocket connection upgrade or through a custom protocol message. In this system, authentication occurs during the HTTP upgrade to WebSocket, creating a secure link between a user identity and their WebSocket connection.</td>\n</tr>\n<tr>\n<td><strong>bcrypt</strong></td>\n<td>A password hashing algorithm specifically designed to be computationally expensive and resistant to brute-force attacks through built-in salting and configurable work factors. The system uses bcrypt with <code>saltRounds: 10</code> to securely hash user passwords before storage, ensuring plaintext passwords are never persisted in the database.</td>\n</tr>\n<tr>\n<td><strong>Broadcast</strong></td>\n<td>The action of sending a message to all connected clients in a specific group or room, excluding the original sender by default. Implemented through <code>RoomManager.broadcastToRoom()</code>, this pattern enables one-to-many communication essential for chat rooms where a single message must reach multiple recipients simultaneously.</td>\n</tr>\n<tr>\n<td><strong>ChatMessage</strong></td>\n<td>The core data structure representing an individual chat message, containing fields for <code>sender</code> (username), <code>content</code> (text), <code>timestamp</code> (ISO string), <code>roomId</code> (target room), and <code>id</code> (unique identifier). This structure flows from client to server, gets enriched with metadata, stored in persistence, and broadcast to room members.</td>\n</tr>\n<tr>\n<td><strong>ClientSession</strong></td>\n<td>A server-side data structure tracking an authenticated user&#39;s active WebSocket connection, containing fields like <code>connectionId</code> (unique socket identifier), <code>socket</code> (raw WebSocket object), <code>userId</code> (linked user), <code>ip</code> (client IP address), <code>userAgent</code> (browser info), <code>joinedAt</code> (connection timestamp), <code>lastActivity</code> (for timeout detection), and <code>roomId</code> (current room). This object represents the stateful link between user identity and network connection.</td>\n</tr>\n<tr>\n<td><strong>Clock Skew</strong></td>\n<td>The difference in system time between client and server machines, which can cause inconsistencies in message timestamps and presence indicators. The system mitigates this by having the server assign all timestamps (<code>ChatMessage.timestamp</code>) using its own clock, ensuring consistent ordering and time-based operations across all clients.</td>\n</tr>\n<tr>\n<td><strong>Connection Lifecycle</strong></td>\n<td>The complete sequence of states a WebSocket connection passes through: initial HTTP handshake (upgrade), connected (open), messaging (data exchange), and disconnection (close/error). The <code>ConnectionManager</code> tracks this lifecycle through events (connect, message, disconnect) and maintains corresponding state in <code>ClientSession</code> objects.</td>\n</tr>\n<tr>\n<td><strong>ConnectionManager</strong></td>\n<td>The server component responsible for accepting WebSocket upgrade requests, managing active connections, routing messages to appropriate handlers, and cleaning up disconnected clients. This component acts as the system&#39;s entry point for all real-time traffic and maintains the <code>ClientSession</code> Map tracking all active connections.</td>\n</tr>\n<tr>\n<td><strong>Debouncing</strong></td>\n<td>A programming technique that delays execution of a function until after a specified wait time has elapsed since the last time it was invoked, used in this system to prevent excessive <code>EVENT_USER_TYPING</code> notifications. When a user types, the client waits for a pause (e.g., 500ms) before sending the typing indicator, and sends a &quot;stopped typing&quot; message after a timeout.</td>\n</tr>\n<tr>\n<td><strong>DebugLogger</strong></td>\n<td>A utility component with fields <code>enableConsole</code>, <code>enableFile</code>, and <code>logFile</code> that provides structured logging for system events at different severity levels. Used throughout the server to record connection events, message handling errors, and system state for troubleshooting, implementing the non-functional goal of debuggability.</td>\n</tr>\n<tr>\n<td><strong>Defensive Programming</strong></td>\n<td>A coding philosophy that anticipates and gracefully handles potential errors before they cause system failures. In this chat system, this manifests as validating all incoming messages (<code>parseAndValidateWebSocketMessage</code>), checking socket <code>readyState</code> before sending, implementing comprehensive error handlers, and using try-catch blocks around all message processing.</td>\n</tr>\n<tr>\n<td><strong>Direct Messaging</strong></td>\n<td>Private, one-to-one communication between individual users outside of chat rooms, implemented as a future extension. The <code>DirectMessaging</code> component would manage user-to-connection mappings and route private messages using the <code>EVENT_DIRECT_MESSAGE</code> event type while maintaining the same underlying WebSocket connections.</td>\n</tr>\n<tr>\n<td><strong>End-to-End Encryption</strong></td>\n<td>An encryption model where messages are encrypted on the sender&#39;s device and only decrypted on the recipient&#39;s device, preventing even the server from reading message contents. This represents a potential future extension beyond the current system&#39;s scope, which currently encrypts data only in transit (TLS) and at rest (database).</td>\n</tr>\n<tr>\n<td><strong>Event-Driven Architecture</strong></td>\n<td>A software design pattern where system components emit and respond to events (messages signaling state changes) rather than using direct method calls. The chat system employs this pattern extensively: the WebSocket server emits connection events, clients send message events (<code>EVENT_CHAT_MESSAGE</code>, <code>EVENT_USER_TYPING</code>), and the server broadcasts notification events to clients.</td>\n</tr>\n<tr>\n<td><strong>Exponential Backoff</strong></td>\n<td>A retry strategy where the delay between retry attempts increases exponentially (e.g., 1s, 2s, 4s, 8s), used by clients when attempting to reconnect after losing WebSocket connection. This prevents overwhelming the server with reconnection attempts during outages while ensuring eventual reconnection when the server becomes available.</td>\n</tr>\n<tr>\n<td><strong>Graceful Degradation</strong></td>\n<td>The property of a system to continue operating with reduced functionality when parts fail, rather than failing completely. In this chat application, if the persistence layer fails, the system continues to allow real-time messaging (using in-memory state) but displays an error when users try to load message history, maintaining core functionality while indicating the degraded state.</td>\n</tr>\n<tr>\n<td><strong>Heartbeat</strong></td>\n<td>Periodic ping/pong messages exchanged between client and server to detect if a connection is still alive, even if no application messages are being sent. Implemented as a timer in the <code>ConnectionManager</code> that sends WebSocket protocol ping frames and disconnects clients that don&#39;t respond with pong frames within a timeout period, preventing &quot;zombie connections.&quot;</td>\n</tr>\n<tr>\n<td><strong>Horizontal Scaling</strong></td>\n<td>Adding more servers to handle increased load, as opposed to vertical scaling (upgrading hardware on a single server). While not implemented in the current design (a non-goal), the architecture could be extended for horizontal scaling using Redis Pub/Sub for cross-server communication and sticky sessions for load balancing.</td>\n</tr>\n<tr>\n<td><strong>Integration Tests</strong></td>\n<td>Tests that verify multiple system components work together correctly, such as testing the full flow from client WebSocket connection through message broadcasting to other clients. In this project, integration tests would verify that messages sent to a room are received by all members, and that user join notifications work properly.</td>\n</tr>\n<tr>\n<td><strong>JWT (JSON Web Token)</strong></td>\n<td>A compact, URL-safe token format for representing claims between two parties, often used for authentication. While the current system uses session tokens stored server-side, JWTs could be implemented as a future extension to enable stateless authentication, containing encrypted user identity and expiration information.</td>\n</tr>\n<tr>\n<td><strong>Long Polling</strong></td>\n<td>A technique where the client sends a request to the server that remains open until the server has new data to send, at which point the server responds and the client immediately sends another request. This is an alternative to WebSockets for real-time communication but introduces higher latency and server overhead compared to the persistent WebSocket connections used in this system.</td>\n</tr>\n<tr>\n<td><strong>Message Broker</strong></td>\n<td>A component that routes messages to appropriate recipients based on rules or subscriptions. In this system, the <code>RoomManager</code> acts as a message broker, receiving messages from the <code>ConnectionManager</code> and delivering them to all members of the specified room, implementing the publish-subscribe pattern for room-based communication.</td>\n</tr>\n<tr>\n<td><strong>Message Queue</strong></td>\n<td>In the context of testing, a collection (array) of received messages in the <code>TestWebSocketClient</code> that allows test code to inspect messages sent by the server. The client&#39;s <code>messageQueue</code> field stores all incoming messages, and helper methods like <code>getMessagesOfType()</code> filter this queue for specific message types during test verification.</td>\n</tr>\n<tr>\n<td><strong>Middleware Pipeline</strong></td>\n<td>A pattern where incoming messages pass through a series of processing functions (middleware) before reaching the main handler. While not explicitly implemented in the current design, the architecture could be extended with middleware for logging, rate limiting, message transformation, or authentication validation before messages reach the main <code>ConnectionManager.handleMessage()</code> method.</td>\n</tr>\n<tr>\n<td><strong>Pagination</strong></td>\n<td>The technique of retrieving data in manageable chunks (pages) rather than loading entire datasets at once. Implemented in <code>getMessagesForRoom()</code> with <code>limit</code> and <code>offset</code> parameters, this prevents overwhelming clients and servers when loading message history from rooms with thousands of messages, a critical consideration for the non-functional goal of performance.</td>\n</tr>\n<tr>\n<td><strong>Password Hashing</strong></td>\n<td>The cryptographic transformation of passwords into irreversible hash values before storage, preventing exposure of plaintext passwords even if the database is compromised. The system uses bcrypt hashing in the <code>AuthService.registerUser()</code> and <code>AuthService.loginUser()</code> methods, ensuring passwords are never stored or transmitted in plain text.</td>\n</tr>\n<tr>\n<td><strong>Polling</strong></td>\n<td>A technique where the client repeatedly requests updates from the server at regular intervals (e.g., every 2 seconds). This naive approach to real-time communication is inefficient compared to WebSockets, as it creates constant HTTP request overhead even when no new data is available, and introduces latency equal to the polling interval.</td>\n</tr>\n<tr>\n<td><strong>Presence</strong></td>\n<td>Real-time status information about users, including whether they are online/offline, which room they&#39;re in, and whether they&#39;re currently typing. The <code>RoomManager</code> tracks presence through room membership (<code>Room.memberIds</code>) and typing status via <code>setUserTyping()</code>, broadcasting updates to room members when presence states change.</td>\n</tr>\n<tr>\n<td><strong>Rate Limiting</strong></td>\n<td>Controlling the frequency of messages a user can send to prevent abuse and protect server resources. While not implemented in the basic system, this could be added as a future extension using algorithms like the sliding window algorithm to count requests over a moving time window and reject excessive messages.</td>\n</tr>\n<tr>\n<td><strong>Redis Pub/Sub</strong></td>\n<td>Redis Publish/Subscribe pattern that enables cross-server communication through a shared message bus, allowing multiple chat servers to coordinate room membership and message broadcasting in a horizontally scaled deployment. This represents an advanced extension path beyond the current single-server, in-memory design.</td>\n</tr>\n<tr>\n<td><strong>Room</strong></td>\n<td>A data structure representing a chat channel or conversation space, containing fields <code>id</code> (unique identifier), <code>name</code> (human-readable name), <code>createdAt</code> (timestamp), and <code>memberIds</code> (Set of user IDs currently in the room). Rooms enable segmented conversations where messages are only delivered to members of that specific room.</td>\n</tr>\n<tr>\n<td><strong>Room Manager</strong></td>\n<td>The server component that manages chat rooms, membership, message broadcasting within rooms, and presence tracking. This component implements methods like <code>joinRoom()</code>, <code>leaveRoom()</code>, <code>broadcastToRoom()</code>, and <code>getRoomList()</code>, forming the core business logic for Milestones 2 and 3.</td>\n</tr>\n<tr>\n<td><strong>Server-Sent Events (SSE)</strong></td>\n<td>An HTTP-based technology for server-to-client event streaming over a single, long-lived connection where the server can push events to the client but the client cannot send messages back (unidirectional). While simpler than WebSockets, SSE is insufficient for this chat application&#39;s requirement for bidirectional communication (client-to-server messaging).</td>\n</tr>\n<tr>\n<td><strong>Session</strong></td>\n<td>Temporary authentication state for a user connection, represented server-side by <code>ClientSession</code> objects and client-side by session tokens. Sessions have a Time-To-Live (<code>sessionTTL</code> of 24 hours) after which they expire, requiring re-authentication. The <code>AuthService</code> creates, validates, and invalidates sessions.</td>\n</tr>\n<tr>\n<td><strong>Sliding Window Algorithm</strong></td>\n<td>A rate limiting algorithm that counts requests over a moving time window (e.g., last 60 seconds) rather than fixed intervals, providing more accurate and smooth limiting. This represents a potential implementation approach for adding rate limiting as a future extension to prevent spam and abuse.</td>\n</tr>\n<tr>\n<td><strong>Stateful Message Router</strong></td>\n<td>A server component that maintains active connections and routes messages between them based on application state. The <code>ConnectionManager</code> combined with the <code>RoomManager</code> forms a stateful message router, as it must know which connections belong to which users, which rooms those users are in, and route messages accordingly.</td>\n</tr>\n<tr>\n<td><strong>Sticky Sessions</strong></td>\n<td>A load balancing technique that routes all requests from a particular user to the same server, necessary for maintaining WebSocket connection state in horizontally scaled deployments. This would be required if extending the system to multiple servers, ensuring a user&#39;s WebSocket connection and session state remain on a single server.</td>\n</tr>\n<tr>\n<td><strong>TestWebSocketClient</strong></td>\n<td>A testing utility that simulates a chat client for automated testing, containing fields like <code>url</code>, <code>socket</code>, <code>messageQueue</code>, <code>messageHandlers</code>, and <code>connectPromise</code>. This client connects to the server, sends messages, and provides methods like <code>waitForMessage()</code> to verify server responses in integration tests.</td>\n</tr>\n<tr>\n<td><strong>TTL (Time-To-Live)</strong></td>\n<td>The duration after which data expires and should be cleaned up. In this system, sessions have a TTL of 24 hours (stored in <code>sessionTTL</code>), and the <code>cleanupExpiredSessions()</code> method periodically removes expired sessions. Message history could also implement TTL for automatic cleanup of old messages.</td>\n</tr>\n<tr>\n<td><strong>Unicode Normalization</strong></td>\n<td>The process of converting text to a standard form for consistent processing, ensuring that visually identical strings (e.g., &quot;café&quot; composed differently) are treated as identical. While not explicitly implemented, this would be important for proper handling of usernames and message content containing international characters.</td>\n</tr>\n<tr>\n<td><strong>Unit Tests</strong></td>\n<td>Tests that verify individual functions in isolation, such as testing <code>parseAndValidateWebSocketMessage()</code> without requiring a running server or network connections. These tests focus on specific edge cases and error conditions for single components or functions.</td>\n</tr>\n<tr>\n<td><strong>User</strong></td>\n<td>A data structure representing an authenticated chat user, containing <code>username</code> (unique identifier), <code>passwordHash</code> (bcrypt-hashed password), and <code>createdAt</code> (registration timestamp). Users are created during registration and authenticated during login, with their identity linked to WebSocket connections via <code>ClientSession</code> objects.</td>\n</tr>\n<tr>\n<td><strong>WebSocket</strong></td>\n<td>A communication protocol providing full-duplex (bidirectional) communication channels over a single TCP connection, enabling persistent, low-latency communication between client and server. This protocol forms the foundation of the entire chat system, replacing the request-response model of HTTP with continuous two-way communication.</td>\n</tr>\n<tr>\n<td><strong>WebSocketMessage</strong></td>\n<td>The standardized message format for all client-server communication, containing fields <code>type</code> (event type like <code>EVENT_CHAT_MESSAGE</code>), <code>payload</code> (event-specific data), and optional <code>timestamp</code>. All messages, whether from client to server or server to client, follow this envelope format for consistent parsing and routing.</td>\n</tr>\n<tr>\n<td><strong>Zombie Connection</strong></td>\n<td>A WebSocket connection that appears open in the server&#39;s tracking but is actually dead or unresponsive, often due to network failures where the TCP connection closed without proper WebSocket close handshake. The system prevents zombie connections through heartbeat (ping/pong) mechanisms that detect and clean up dead connections.</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"Real-time Chat Application: Design Document","id":"real-time-chat-application-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Telephone vs. The Mailbox","id":"mental-model-the-telephone-vs-the-mailbox"},{"level":3,"text":"The Core Problem: Stateful Connections at Scale","id":"the-core-problem-stateful-connections-at-scale"},{"level":3,"text":"Existing Approaches and Trade-offs","id":"existing-approaches-and-trade-offs"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals (What it MUST do)","id":"functional-goals-what-it-must-do"},{"level":3,"text":"Non-Functional Goals (How it should behave)","id":"non-functional-goals-how-it-should-behave"},{"level":3,"text":"Explicit Non-Goals (What it does NOT do)","id":"explicit-non-goals-what-it-does-not-do"},{"level":3,"text":"Implementation Guidance (Layer 2)","id":"implementation-guidance-layer-2"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview and Responsibilities","id":"component-overview-and-responsibilities"},{"level":4,"text":"Core Components and Their Responsibilities","id":"core-components-and-their-responsibilities"},{"level":4,"text":"Detailed Component Descriptions","id":"detailed-component-descriptions"},{"level":4,"text":"Component Interaction Patterns","id":"component-interaction-patterns"},{"level":4,"text":"Data Flow Between Components","id":"data-flow-between-components"},{"level":3,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Key Structural Decisions","id":"key-structural-decisions"},{"level":4,"text":"Module Dependencies and Import Flow","id":"module-dependencies-and-import-flow"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Starter Project Structure Setup","id":"starter-project-structure-setup"},{"level":4,"text":"Basic TypeScript Configuration","id":"basic-typescript-configuration"},{"level":4,"text":"Core Infrastructure Starter Code","id":"core-infrastructure-starter-code"},{"level":4,"text":"Development Scripts","id":"development-scripts"},{"level":4,"text":"Next Steps for Implementation","id":"next-steps-for-implementation"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Core Types and Structures","id":"core-types-and-structures"},{"level":4,"text":"ChatMessage","id":"chatmessage"},{"level":4,"text":"User","id":"user"},{"level":4,"text":"Room","id":"room"},{"level":4,"text":"ClientSession","id":"clientsession"},{"level":3,"text":"Wire Format and Event Protocol","id":"wire-format-and-event-protocol"},{"level":4,"text":"WebSocketMessage Envelope","id":"websocketmessage-envelope"},{"level":4,"text":"Event Catalog","id":"event-catalog"},{"level":4,"text":"Architecture Decision: Structured Events vs. Ad-Hoc Messages","id":"architecture-decision-structured-events-vs-ad-hoc-messages"},{"level":4,"text":"Common Pitfalls: Protocol Design Mistakes","id":"common-pitfalls-protocol-design-mistakes"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Component Design: WebSocket Server &amp; Connection Manager","id":"component-design-websocket-server-amp-connection-manager"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: The Telephone Switchboard Operator","id":"mental-model-the-telephone-switchboard-operator"},{"level":3,"text":"Interface and Connection Lifecycle","id":"interface-and-connection-lifecycle"},{"level":4,"text":"Connection State Machine","id":"connection-state-machine"},{"level":4,"text":"Core Interface Methods","id":"core-interface-methods"},{"level":4,"text":"Event Handlers (Internal Interface)","id":"event-handlers-internal-interface"},{"level":3,"text":"ADR: Managing Active Connections","id":"adr-managing-active-connections"},{"level":3,"text":"Common Pitfalls: Memory Leaks and Silent Failures","id":"common-pitfalls-memory-leaks-and-silent-failures"},{"level":4,"text":"⚠️ Pitfall 1: Zombie Connections - Not Cleaning Up on Disconnect","id":"-pitfall-1-zombie-connections-not-cleaning-up-on-disconnect"},{"level":4,"text":"⚠️ Pitfall 2: The Silent Swallow - Missing Error Handlers","id":"-pitfall-2-the-silent-swallow-missing-error-handlers"},{"level":4,"text":"⚠️ Pitfall 3: The Forgotten Heartbeat - No Liveness Detection","id":"-pitfall-3-the-forgotten-heartbeat-no-liveness-detection"},{"level":4,"text":"⚠️ Pitfall 4: Ready State Race Condition - Sending to Closing Sockets","id":"-pitfall-4-ready-state-race-condition-sending-to-closing-sockets"},{"level":4,"text":"⚠️ Pitfall 5: Unbounded Message Queue - No Backpressure Handling","id":"-pitfall-5-unbounded-message-queue-no-backpressure-handling"},{"level":4,"text":"⚠️ Pitfall 6: The Shared Mutability Trap - Concurrent Modification","id":"-pitfall-6-the-shared-mutability-trap-concurrent-modification"},{"level":3,"text":"Implementation Guidance (Layer 2)","id":"implementation-guidance-layer-2"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (JavaScript/Node.js)","id":"e-language-specific-hints-javascriptnodejs"},{"level":4,"text":"F. Milestone Checkpoint: WebSocket Server Setup","id":"f-milestone-checkpoint-websocket-server-setup"},{"level":2,"text":"Component Design: Message Broker &amp; Room Manager","id":"component-design-message-broker-amp-room-manager"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: The Publishing House and Subscribers","id":"mental-model-the-publishing-house-and-subscribers"},{"level":3,"text":"Interface: Core Methods and Events","id":"interface-core-methods-and-events"},{"level":3,"text":"ADR: In-Memory vs. External Room State","id":"adr-in-memory-vs-external-room-state"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoint","id":"f-milestone-checkpoint"},{"level":2,"text":"Component Design: Persistence &amp; Authentication Service","id":"component-design-persistence-amp-authentication-service"},{"level":3,"text":"Responsibility and Scope","id":"responsibility-and-scope"},{"level":3,"text":"Mental Model: The Library Archivist and Security Guard","id":"mental-model-the-library-archivist-and-security-guard"},{"level":3,"text":"ADR: When to Authenticate - HTTP vs. WebSocket","id":"adr-when-to-authenticate-http-vs-websocket"},{"level":3,"text":"Common Pitfalls: Unbounded History and Session Leaks","id":"common-pitfalls-unbounded-history-and-session-leaks"},{"level":3,"text":"Interface: Core Methods and Events","id":"interface-core-methods-and-events"},{"level":4,"text":"Authentication Service Interface","id":"authentication-service-interface"},{"level":4,"text":"Message Persistence Store Interface","id":"message-persistence-store-interface"},{"level":3,"text":"Data Flow: Authentication During Connection Establishment","id":"data-flow-authentication-during-connection-establishment"},{"level":3,"text":"Data Flow: Message Persistence","id":"data-flow-message-persistence"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code: Simple In-Memory Message Store","id":"c-infrastructure-starter-code-simple-in-memory-message-store"},{"level":4,"text":"D. Core Logic Skeleton: Authentication Service","id":"d-core-logic-skeleton-authentication-service"},{"level":4,"text":"E. Language-Specific Hints (JavaScript/Node.js)","id":"e-language-specific-hints-javascriptnodejs"},{"level":4,"text":"F. Integration with WebSocket Server","id":"f-integration-with-websocket-server"},{"level":4,"text":"G. Milestone Checkpoint for Authentication &amp; Persistence","id":"g-milestone-checkpoint-for-authentication-amp-persistence"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Sequence: Sending and Receiving a Message","id":"sequence-sending-and-receiving-a-message"},{"level":4,"text":"Step-by-Step Journey of a Chat Message","id":"step-by-step-journey-of-a-chat-message"},{"level":3,"text":"Sequence: Joining a Room and Loading History","id":"sequence-joining-a-room-and-loading-history"},{"level":4,"text":"Step-by-Step Room Joining Process","id":"step-by-step-room-joining-process"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Common Failure Modes and Recovery","id":"common-failure-modes-and-recovery"},{"level":4,"text":"Network Drops and Unclean Disconnections","id":"network-drops-and-unclean-disconnections"},{"level":4,"text":"Server Crashes and Restarts","id":"server-crashes-and-restarts"},{"level":4,"text":"Malformed and Malicious Messages","id":"malformed-and-malicious-messages"},{"level":4,"text":"Resource Exhaustion (Memory, CPU, File Descriptors)","id":"resource-exhaustion-memory-cpu-file-descriptors"},{"level":3,"text":"Edge Case Analysis","id":"edge-case-analysis"},{"level":4,"text":"Duplicate Usernames and Connection Conflicts","id":"duplicate-usernames-and-connection-conflicts"},{"level":4,"text":"Message Size and Rate Extremes","id":"message-size-and-rate-extremes"},{"level":4,"text":"Rapid Join/Leave Churn","id":"rapid-joinleave-churn"},{"level":4,"text":"Clock Skew and Message Ordering","id":"clock-skew-and-message-ordering"},{"level":4,"text":"Empty Rooms and Zombie Connections","id":"empty-rooms-and-zombie-connections"},{"level":4,"text":"Authentication and Session Edge Cases","id":"authentication-and-session-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Error Handling","id":"technology-recommendations-for-error-handling"},{"level":4,"text":"Recommended Error Handling Module Structure","id":"recommended-error-handling-module-structure"},{"level":4,"text":"Core Error Handling Skeleton Code","id":"core-error-handling-skeleton-code"},{"level":4,"text":"Language-Specific Hints for JavaScript/Node.js","id":"language-specific-hints-for-javascriptnodejs"},{"level":4,"text":"Debugging Tips for Error Scenarios","id":"debugging-tips-for-error-scenarios"},{"level":4,"text":"Milestone Checkpoint for Error Handling","id":"milestone-checkpoint-for-error-handling"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Testing Approach and Property Verification","id":"testing-approach-and-property-verification"},{"level":4,"text":"Testing Layers and Focus Areas","id":"testing-layers-and-focus-areas"},{"level":4,"text":"Key Properties to Verify","id":"key-properties-to-verify"},{"level":4,"text":"Integration Testing Strategy","id":"integration-testing-strategy"},{"level":4,"text":"ADR: Choosing Integration Tests Over Unit Tests for Core Components","id":"adr-choosing-integration-tests-over-unit-tests-for-core-components"},{"level":3,"text":"Milestone Implementation Checkpoints","id":"milestone-implementation-checkpoints"},{"level":4,"text":"Milestone 1: WebSocket Server Setup Checkpoint","id":"milestone-1-websocket-server-setup-checkpoint"},{"level":4,"text":"Milestone 2: Message Broadcasting Checkpoint","id":"milestone-2-message-broadcasting-checkpoint"},{"level":4,"text":"Milestone 3: Chat Rooms Checkpoint","id":"milestone-3-chat-rooms-checkpoint"},{"level":4,"text":"Milestone 4: User Authentication &amp; Persistence Checkpoint","id":"milestone-4-user-authentication-amp-persistence-checkpoint"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Test Infrastructure Starter Code","id":"c-test-infrastructure-starter-code"},{"level":4,"text":"D. Core Test Skeleton Code","id":"d-core-test-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints (JavaScript/Node.js)","id":"e-language-specific-hints-javascriptnodejs"},{"level":4,"text":"F. Milestone Checkpoint Verification Scripts","id":"f-milestone-checkpoint-verification-scripts"},{"level":4,"text":"G. Debugging Tips for Testing","id":"g-debugging-tips-for-testing"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Common Bugs: Symptom → Cause → Fix","id":"common-bugs-symptom-cause-fix"},{"level":3,"text":"Debugging Techniques and Tools","id":"debugging-techniques-and-tools"},{"level":4,"text":"Strategic Logging: The Time-Traveling Observer","id":"strategic-logging-the-time-traveling-observer"},{"level":4,"text":"Browser WebSocket Inspector: The Conversation Eavesdropper","id":"browser-websocket-inspector-the-conversation-eavesdropper"},{"level":4,"text":"Network Failure Simulation: The Chaos Engineer","id":"network-failure-simulation-the-chaos-engineer"},{"level":4,"text":"The Rubber Duck Debugging Variant: Explain Your Architecture","id":"the-rubber-duck-debugging-variant-explain-your-architecture"},{"level":4,"text":"State Visualization: The Whiteboard Method","id":"state-visualization-the-whiteboard-method"},{"level":4,"text":"Differential Debugging: The Comparison Technique","id":"differential-debugging-the-comparison-technique"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations Table","id":"a-technology-recommendations-table"},{"level":4,"text":"B. Debug Helper Module Structure","id":"b-debug-helper-module-structure"},{"level":4,"text":"C. Complete Debug Logger Implementation","id":"c-complete-debug-logger-implementation"},{"level":4,"text":"D. Test WebSocket Client Skeleton","id":"d-test-websocket-client-skeleton"},{"level":4,"text":"E. State Inspector Implementation","id":"e-state-inspector-implementation"},{"level":4,"text":"F. Debugging Test Scenarios","id":"f-debugging-test-scenarios"},{"level":4,"text":"G. Language-Specific Debugging Hints (JavaScript/Node.js)","id":"g-language-specific-debugging-hints-javascriptnodejs"},{"level":4,"text":"H. Milestone Debugging Checkpoints","id":"h-milestone-debugging-checkpoints"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Potential Features and Scaling Paths","id":"potential-features-and-scaling-paths"},{"level":4,"text":"Feature Enhancements Within Current Architecture","id":"feature-enhancements-within-current-architecture"},{"level":4,"text":"Scaling Beyond a Single Server","id":"scaling-beyond-a-single-server"},{"level":4,"text":"Security and Moderation Enhancements","id":"security-and-moderation-enhancements"},{"level":4,"text":"Performance Optimizations","id":"performance-optimizations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Extensions","id":"technology-recommendations-for-extensions"},{"level":4,"text":"File Structure for Extensions","id":"file-structure-for-extensions"},{"level":4,"text":"Starter Code for Direct Messaging Extension","id":"starter-code-for-direct-messaging-extension"},{"level":4,"text":"Starter Code for File Service Extension","id":"starter-code-for-file-service-extension"},{"level":4,"text":"Language-Specific Hints for JavaScript/TypeScript","id":"language-specific-hints-for-javascripttypescript"},{"level":4,"text":"Milestone Extension Checkpoints","id":"milestone-extension-checkpoints"},{"level":4,"text":"Debugging Tips for Extensions","id":"debugging-tips-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Terms and Definitions","id":"terms-and-definitions"}],"title":"Real-time Chat Application: Design Document","markdown":"# Real-time Chat Application: Design Document\n\n\n## Overview\n\nThis document outlines the architecture for a real-time chat application using WebSockets. It solves the key architectural challenge of maintaining persistent, bi-directional communication channels between a server and multiple web clients, enabling instant message delivery, user presence, and conversation history. The design balances simplicity for learning with scalable patterns used in production systems.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n> **Milestone(s):** This foundational context applies to all milestones, establishing the core communication paradigm and technical challenges the entire system must address.\n\nAt the heart of any real-time chat application lies a fundamental challenge: how can a web server instantly notify connected clients when something happens—like a new message being sent—without waiting for the client to ask first? This section explores this challenge by contrasting the traditional request-response model of the web with the persistent, bi-directional connection model of WebSockets. We will establish the mental models, define the core technical problems of managing stateful connections at scale, and evaluate the trade-offs between different real-time communication approaches.\n\n### Mental Model: The Telephone vs. The Mailbox\n\nTo understand the shift required for real-time communication, consider two everyday communication systems:\n\n1.  **The Mailbox (HTTP Request-Response):** Imagine you want to know if your friend has sent you a letter. Under the Hypertext Transfer Protocol (HTTP) that powers most of the web, you must walk to your mailbox, open it, and check for new letters. If there's nothing, you close it and return to your house. To get the next update, you must walk back to the mailbox and check again. This is the **polling** model: the client (you) must repeatedly initiate a request to the server (the mailbox) to ask for new data. The server cannot proactively deliver information; it can only respond when asked. This is efficient for infrequent updates but becomes wasteful and slow when you need to know the instant a letter arrives. You would be making constant, unnecessary trips to the mailbox.\n\n2.  **The Telephone Call (WebSocket Persistent Connection):** Now, imagine you and your friend have an open telephone line. Once the call is connected, either of you can speak at any time. When your friend has something to say, they just say it, and you hear it immediately. There's no need for you to repeatedly ask, \"Do you have anything new to say?\" This is the **WebSocket** model: after an initial handshake (dialing the number), a persistent, two-way communication channel is established. The server can \"push\" data to the client the moment it becomes available, and the client can send data to the server just as freely. This enables true real-time interactivity but comes with the overhead of maintaining an open connection for each client.\n\nThis mental model highlights the paradigm shift. Traditional web development is built around stateless, transactional interactions (the mailbox). Real-time chat requires a stateful, session-oriented, and continuous flow of information (the telephone call). Our design must therefore manage not just individual requests, but long-lived **connections** that become first-class citizens in our system's architecture.\n\n### The Core Problem: Stateful Connections at Scale\n\nBuilding a system that maintains a \"telephone call\" with every user introduces a set of interconnected technical hurdles that define the core problem space for our chat application.\n\n1.  **Managing Thousands of Concurrent, Stateful Connections:** Unlike a stateless HTTP request that is processed and forgotten, each WebSocket connection is a long-lived object in server memory. It holds resources like file descriptors, buffers, and—critically—application state (e.g., which user it represents, which room they are in). The server must track all active connections, associate them with users, and efficiently route messages to the correct subset. As user count grows, the management overhead (memory, CPU for housekeeping) grows linearly. The system must be designed to handle this growth gracefully, typically using efficient data structures (like `Map`s keyed by user ID) and non-blocking, event-driven I/O.\n\n2.  **Handling Disconnections Gracefully and Reliably:** Network connections are inherently unreliable. A user's Wi-Fi may drop, their laptop may go to sleep, or they may close the browser tab. The server must detect when a connection is lost and perform necessary cleanup: removing the user from room member lists, broadcasting \"user left\" notifications, and freeing up allocated resources. Failure to do so creates **\"ghost users\"** (users who appear online but aren't) and memory leaks. This requires implementing a **connection lifecycle** with explicit events (`connect`, `disconnect`, `error`) and often a **heartbeat** mechanism (periodic ping/pong messages) to distinguish a slow connection from a dead one.\n\n3.  **Synchronizing State Across Clients in Real-Time:** When User A sends a message to \"General\" room, all other users in that room must see it nearly simultaneously. This is a state synchronization problem. The server acts as the single source of truth. It must:\n    *   **Receive** the message from User A's connection.\n    *   **Validate & Persist** it (check permissions, store to database if required).\n    *   **Determine Recipients** (find all connections currently in the \"General\" room, excluding User A).\n    *   **Transmit** the message to each recipient's connection.\n    Any delay or failure in this pipeline breaks the illusion of a shared, synchronous space. The design must ensure this pipeline is fast, atomic where needed (e.g., persisting before broadcasting to ensure no message is lost if the server crashes mid-send), and resilient to partial failures of individual clients.\n\n4.  **Securing a Long-Lived, Bi-Directional Channel:** An open connection is a larger attack surface than a series of short requests. The server must authenticate the user when the connection is established (or very soon after) and then authorize every subsequent action (e.g., \"can this user post to this room?\"). This is distinct from HTTP, where each request can carry authentication headers. We must also guard against abuse via the persistent channel, such as a malicious client flooding the server with high-volume messages.\n\n> The critical insight is that a WebSocket server is fundamentally a **stateful message router**. It maintains a live mapping of `{User Identity -> Network Connection -> Room Membership}` and uses this map to fan out messages from any single point to many others. This is a different architectural pattern than the stateless request-processing of a typical REST API.\n\n### Existing Approaches and Trade-offs\n\nBefore settling on WebSockets, it's essential to understand the landscape of techniques for achieving real-time communication on the web. Each has different capabilities, browser support, and trade-offs. The following table compares the most common approaches.\n\n| Approach | How It Works | Pros | Cons | Best For |\n| :--- | :--- | :--- | :--- | :--- |\n| **Naive Polling** | Client repeatedly sends HTTP requests (e.g., every 2 seconds) asking \"Any new messages?\" | Extremely simple to implement. Works with any HTTP server. | High latency (up to poll interval). High server/network overhead (many empty requests). Inefficient. | Simple prototypes where real-time is not critical and load is negligible. |\n| **Long Polling** | Client sends a request; server holds it open until new data is available or a timeout occurs. Client immediately re-connects after receiving a response. | Reduces empty requests. Lower latency than naive polling. Still uses standard HTTP. | Complex server-side connection management. Head-of-line blocking (a hanging request can delay others). Still has HTTP overhead per message. | Systems where WebSockets are not available and moderate latency is acceptable. |\n| **Server-Sent Events (SSE)** | Client opens a persistent HTTP connection; server can send \"events\" as text streams. **One-way (server → client only)**. | Standardized, automatic reconnection. Simple protocol (plain text). Efficient for server-push scenarios. | **No bi-directional communication** (client cannot send data over the same channel). Limited to text data. Not supported in older IE/Edge. | Live news feeds, stock tickers, notifications—any update stream where the client only listens. |\n| **WebSockets** | Full-duplex, persistent connection established after an HTTP \"Upgrade\" handshake. Data flows both ways independently over the same TCP socket. | **True real-time, bi-directional communication**. Low overhead per message (light framing, no HTTP headers). Efficient for high-frequency updates. | More complex protocol to implement directly (though libraries abstract this). Requires stateful connection management on the server. | **Interactive applications: chat, collaborative editing, live gaming, trading terminals.** |\n\n> **Decision: Use WebSockets as the Core Transport**\n> *   **Context**: Our functional goal is a bi-directional, low-latency chat application where clients both send (messages, typing indicators) and receive (messages, presence updates) data in real-time.\n> *   **Options Considered**:\n>     1.  **Long Polling**: Could simulate real-time but introduces higher latency and complexity in request handling.\n>     2.  **Server-Sent Events (SSE)**: Excellent for server-to-client push, but would require a separate channel (e.g., standard HTTP POST) for client-to-server messages, complicating the architecture.\n>     3.  **WebSockets**: Provides a single, unified, bi-directional channel ideal for conversational data flow.\n> *   **Decision**: Implement the real-time data plane using the WebSocket protocol.\n> *   **Rationale**: WebSockets are the industry standard for full-duplex web communication. They provide the lowest latency and most efficient use of network resources for our use case, where events flow constantly in both directions. While they require managing stateful connections, this complexity is inherent to the problem and is a valuable learning objective.\n> *   **Consequences**: We must implement a WebSocket server capable of handling the connection lifecycle, message framing, and error handling. We will rely on the `ws` library (for Node.js) to handle the low-level protocol details, allowing us to focus on the application logic.\n\nThe choice of WebSockets sets the stage for our component design. In the following sections, we will decompose the problem of building a stateful message router into discrete, manageable components: the **Connection Manager** (Milestone 1), the **Message Broker & Room Manager** (Milestones 2 & 3), and the **Persistence & Authentication Service** (Milestone 4).\n\n---\n\n\n## Goals and Non-Goals\n> **Milestone(s):** All milestones (1-4). This section defines the fundamental requirements and constraints that guide the entire system's architecture and implementation, providing clear boundaries for what will and won't be built.\n\n### Functional Goals (What it MUST do)\nThese are the core capabilities the system must deliver—the features users will directly interact with and depend upon. Think of these as the **contract with the end user**: if any of these are missing, the application fails to fulfill its basic purpose.\n\n| Feature | Description | Why It Matters | Milestone |\n|---------|-------------|----------------|-----------|\n| **Real-time Messaging** | Messages typed by one user must appear on other users' screens with minimal perceptible delay (typically < 200ms). This includes text content, sender identification, and accurate timestamps. | This is the fundamental value proposition of a chat application. Without real-time delivery, it becomes email. The experience should feel immediate and conversational. | 2 |\n| **Multiple Chat Rooms** | Users must be able to create, join, and leave distinct conversation spaces (rooms/channels). Messages sent to a room must only be delivered to users currently in that room. | This organizes conversations by topic, project, or team, preventing a single chaotic stream. It's a foundational pattern for scaling conversations beyond direct messaging. | 3 |\n| **User Presence** | The system must indicate which users are currently online/connected and which rooms they are actively participating in. Other users should see when someone joins or leaves a room or the entire application. | Presence transforms a messaging tool from a passive mailbox into an active social space. It provides critical context about who is available for conversation. | 2, 4 |\n| **Message History** | When a user joins a room, they must see a configurable number of recent messages that were sent before they arrived. Messages must be persisted to survive server restarts. | Conversation continuity is essential. Users shouldn't lose context when they reconnect, and need to catch up on what they missed. | 4 |\n| **Typing Indicators** | When a user begins composing a message, a visual indicator (e.g., \"Alice is typing...\") must be broadcast to other users in the same room. The indicator must clear after a timeout or when the message is sent. | This provides crucial feedback about the cadence of a conversation, reducing interruptions and signaling engagement. | 2 |\n| **User Authentication** | Users must provide credentials (username/password) to establish their identity before participating in chats. The server must validate this identity for each WebSocket connection. | Authentication prevents impersonation, enables personalization, and is a prerequisite for proper message attribution and authorization. | 4 |\n| **Connection Resilience** | The application must automatically attempt to re-establish the WebSocket connection if it is dropped due to network instability. In-flight messages should be queued and delivered upon reconnection. | Real-world networks are unreliable. A chat app that breaks on a spotty Wi-Fi signal is unusable. This goal is about graceful degradation. | 1, 2 |\n\n> **Key Insight:** These functional goals are **interdependent**. Presence relies on real-time connections. Message history requires persistence. Room-based messaging necessitates user authentication for proper attribution. The architecture must be designed holistically to support these interactions.\n\n**Detailed Breakdown of Core Features:**\n\n1.  **Real-time Messaging Protocol:** Beyond simple delivery, the system must define a structured message format. Every message must include:\n    *   `sender`: The authenticated username of the originator.\n    *   `content`: The plain-text message body (with length limits).\n    *   `timestamp`: A server-assigned UTC timestamp (not client-provided, to prevent clock-skew issues).\n    *   `roomId`: The identifier of the destination room.\n    This structured data is the lifeblood of the system, flowing from client to server to other clients.\n\n2.  **Room Management Logic:** The system must maintain a **room directory**. Key operations include:\n    *   **Creation:** A user can request a new room with a unique name. The server must sanitize the name (removing special characters) and check for conflicts.\n    *   **Joining:** A user can request to join an existing room. The server must add the user to the room's member list and notify existing members.\n    *   **Listing:** An endpoint (HTTP or via WebSocket) must provide a list of available rooms, including metadata like member count and activity timestamp.\n    *   **Cleanup:** The system should implement logic to archive or delete empty rooms after a period of inactivity to prevent resource leaks.\n\n3.  **Presence System Components:** Presence is more than just \"online.\" It has multiple states:\n    *   **Global Online Status:** The user has an active WebSocket connection to the server.\n    *   **Room Membership:** The user is actively joined to one or more specific rooms.\n    *   **Typing Activity:** The user is currently composing a message in a specific room.\n    The system must track these states and broadcast relevant state changes (e.g., `user_joined`, `user_left`, `user_typing`) to affected room members.\n\n### Non-Functional Goals (How it should behave)\nThese goals define the **quality attributes** of the system—how well it performs its functions. They are often constraints on the design and implementation. Think of these as the **contract with the system operator** (the developer running the server) and the **implied contract with the user regarding experience quality**.\n\n| Attribute | Target / Requirement | Architectural Implications |\n|-----------|----------------------|----------------------------|\n| **Low Latency** | Message delivery from sender to receiver should typically be under 200 milliseconds on a stable network. The 95th percentile (P95) latency should not exceed 500ms. | Demands efficient message routing (O(1) room member lookups), non-blocking I/O, and minimal serialization/deserialization overhead. In-memory data structures for active sessions are essential. |\n| **Connection Resilience** | The client must automatically attempt to reconnect after a disconnection, with exponential backoff (e.g., 1s, 2s, 4s, 8s... max 30s). Pending messages should be queued locally and sent upon reconnection. | Requires a stable client-side connection state machine and a server that can handle reconnections gracefully (re-associating the new socket with the existing user session). |\n| **Basic Security** | 1. **Authentication:** Credentials must be validated; passwords must be hashed (e.g., with bcrypt) before storage.<br>2. **Authorization:** Users can only send messages to rooms they have joined.<br>3. **Input Validation:** All incoming messages must be validated for type, size, and content (sanitize HTML).<br>4. **Transport:** Use WSS (WebSocket Secure) in production to encrypt traffic. | Influences the connection setup flow (authenticate *before* upgrading to WebSocket), adds validation layers in message handlers, and requires secure session management. |\n| **Debuggability & Operability** | The system must produce structured logs for key events: connection lifecycle, message broadcasts, room operations, and errors. Logs should include relevant IDs (userId, roomId, socketId). | Dictates the use of a logging library and the careful instrumentation of core components. Logs are the primary window into the running system for developers. |\n| **Resource Efficiency** | A single server instance should comfortably support thousands of concurrent connections on modest hardware. Memory usage should scale linearly with active connections and rooms. | Requires careful management of in-memory state (leak-free cleanup), efficient broadcast algorithms (avoiding O(N²) operations), and the use of event-driven, non-blocking APIs. |\n| **Functional Correctness** | The system must guarantee: 1) **Message Ordering:** Messages from a single user to a single room are delivered to all others in the order they were sent. 2) **At-Least-Once Delivery:** A message sent is delivered to all intended online recipients, barring catastrophic failure. 3) **No Cross-Talk:** Messages are never delivered to users outside the intended room. | These are **system invariants**. They guide the design of the message broker and necessitate idempotent message handling where possible. |\n\n> **Architectural Principle:** Non-functional goals often involve **trade-offs**. For example, achieving low latency might involve keeping more data in memory (trading memory for speed). Our design prioritizes latency and simplicity for the learning context, accepting that this limits horizontal scalability—a conscious trade-off captured in our Non-Goals.\n\n**The \"Why\" Behind Non-Functional Goals:**\n\n*   **Low Latency** is non-negotiable for conversational flow. Studies show delays over 200ms become perceptible and disruptive to turn-taking in dialogue.\n*   **Connection Resilience** acknowledges the reality of mobile networks and Wi-Fi handoffs. A chat app that doesn't handle this feels brittle and unreliable.\n*   **Basic Security** is the minimum bar for any application handling user-generated content and identities. While not implementing enterprise-grade security, we must avoid obvious vulnerabilities like plain-text passwords or SQL injection.\n*   **Debuggability** is critical for a learning project. When things go wrong (and they will), clear logs are the fastest path to understanding. This also teaches good operational practices.\n*   **Resource Efficiency** ensures the project remains runnable on a learner's laptop and demonstrates awareness of server-side constraints.\n\n### Explicit Non-Goals (What it does NOT do)\nDefining what is **out of scope** is as important as defining what's in scope. It prevents scope creep, focuses effort on core learning objectives, and makes explicit the limitations of the current design. This is the **anti-contract**—a clear statement of what users and developers should not expect.\n\n| Feature / Capability | Reason for Exclusion | Implication / Workaround |\n|----------------------|----------------------|---------------------------|\n| **Video/Voice Chat** | Significantly increases complexity (codecs, streaming, NAT traversal) and is a separate domain from real-time text messaging. | Users must rely on external tools (e.g., Zoom, Discord) for voice/video communication. |\n| **File Sharing / Rich Media** | Introduces concerns around storage, bandwidth, virus scanning, and content moderation. Moves focus from message routing to file handling. | Users can share links to files stored elsewhere (e.g., Google Drive). The chat remains text-centric. |\n| **Advanced Moderation Tools** | Tools like automated profanity filters, user banning, message deletion, or admin panels require a complex permissions system and content policy. | Room creators have no special powers. All users in a room are equal peers. |\n| **Horizontal Scaling (Multi-Server)** | Distributing WebSocket connections and real-time state across multiple servers introduces massive complexity (sticky sessions, shared state via Redis/PubSub, distributed consensus). | The application is designed to run on a **single server process**. To scale, you would vertically scale (bigger machine) until this becomes limiting, then require a significant architectural rewrite. |\n| **Permanent Message Archive & Search** | Full-text search across all historical messages requires dedicated search infrastructure (like Elasticsearch) and complex pagination/querying. | History is limited to a recent, configurable window (e.g., last 1000 messages per room). Searching is manual (Ctrl+F in the client). |\n| **Direct/Private Messaging (DMs)** | While related to rooms, DMs require a different addressing scheme (user-to-user), privacy guarantees, and potentially a separate inbox model. It expands the core room-based mental model. | Users can create a private room named for two people, but there is no first-class \"DM\" concept or privacy enforcement. |\n| **Read Receipts** (\"Seen\" indicators) | Requires tracking which messages have been *rendered* by each recipient, which is a client-side event that must be reported back to the server and stored. Adds significant state complexity. | Users only know a message was *delivered* (recipient was online and in the room), not necessarily *read*. |\n| **Message Editing or Deletion** | Allowing edits/deletes after broadcast requires tracking message versions, propagating updates, and handling the \"temporal consistency\" problem (what if someone saw the original?). | Messages are immutable once sent. To \"correct\" a message, a user must send a new one. |\n| **Offline Message Queue & Push Notifications** | Storing messages for offline users and delivering them via mobile push (APNS/FCM) requires a separate queueing system, device token management, and a significant service integration. | Messages are only delivered to users who are **currently online and joined to the room**. If you're offline, you miss the conversation until you reconnect and load history. |\n| **End-to-End Encryption (E2EE)** | E2EE requires key exchange and management (e.g., Signal protocol), client-side encryption, and prevents the server from reading messages. This is a deep specialization in cryptographic engineering. | All messages are visible to the server (necessary for broadcasting and persistence). Transport is encrypted (WSS), but server operators can technically view all content. |\n\n> **Design Philosophy:** The choices in this table are guided by a **pedagogical focus**. We are building a **learning vehicle** for WebSockets, real-time state management, and basic full-stack architecture. Adding video chat or horizontal scaling would obscure these core lessons with ancillary complexity. This system is a **foundation**—a complete, working prototype that demonstrates the essential patterns. The \"Future Extensions\" section will discuss how one might evolve this foundation to support some of these excluded features.\n\n**The Consequences of Our Non-Goals:**\nBy explicitly rejecting horizontal scaling, we are free to use simple, in-memory data structures (`Map` and `Set`) for tracking connections and rooms. This makes the code dramatically easier to understand and debug. By rejecting offline messaging, we avoid building a persistent queue system. By rejecting file sharing, we don't need to integrate with object storage or handle multipart uploads. **These exclusions are liberating constraints that allow us to build a clean, understandable system focused on the core learning objectives.**\n\n### Implementation Guidance (Layer 2)\nThis section bridges the design concepts to concrete implementation choices and starter code.\n\n**A. Technology Recommendations Table:**\n| Component | Simple Option (Learning Focus) | Advanced Option (Production Ready) |\n|-----------|--------------------------------|------------------------------------|\n| **WebSocket Library** | `ws` (minimal, follows standard WebSocket API) | `Socket.IO` (built-in reconnection, rooms, fallback to polling) |\n| **Server Framework** | Native Node.js `http`/`https` modules | `Express.js` with middleware for HTTP routes |\n| **Authentication Storage** | In-memory `Map` (for simplicity) or a simple JSON file | `SQLite` or `PostgreSQL` with a proper `users` table |\n| **Message Persistence** | In-memory array per room (volatile) or append to a JSONL (JSON Lines) file | `SQLite`/`PostgreSQL` with a `messages` table and indexes on `roomId` and `timestamp` |\n| **Client Library** | Native `WebSocket` API | `Socket.IO` client for automatic reconnection |\n\n> **Recommendation for Learners:** Start with the **Simple Options** (`ws`, native `http`, in-memory storage). They have fewer abstractions, making it easier to see how the underlying protocols work. You can graduate to the advanced options as a later exercise.\n\n**B. Recommended File/Module Structure:**\nOrganizing code from the start prevents a monolithic `server.js` file. Here's a suggested structure aligning with our components.\n\n```\nreal-time-chat/\n├── package.json\n├── server/\n│   ├── index.js                      # Main entry point, creates HTTP server\n│   ├── connectionManager/            # Milestone 1: WebSocket Server & Connection Manager\n│   │   ├── index.js                  # Exports the ConnectionManager class\n│   │   └── heartbeat.js              # Ping/pong heartbeat logic\n│   ├── roomManager/                  # Milestones 2 & 3: Message Broker & Room Manager\n│   │   ├── index.js                  # Exports the RoomManager class\n│   │   └── typingIndicator.js        # Logic for managing typing timeouts\n│   ├── persistence/                  # Milestone 4: Persistence & Authentication\n│   │   ├── authService.js            # User registration, login, session validation\n│   │   ├── messageStore.js           # Save and load messages from storage\n│   │   └── simpleStore.js            # In-memory or file-based store (starter)\n│   └── utils/\n│       ├── logger.js                 # Structured logging utility\n│       ├── validation.js             # Input validation helpers\n│       └── constants.js              # Shared constants (event names, limits)\n└── client/\n    ├── public/\n    │   ├── index.html                # Main chat UI\n    │   ├── style.css                 # Styles\n    │   └── app.js                    # Client-side WebSocket & UI logic\n```\n\n**C. Infrastructure Starter Code (Simple In-Memory Store):**\nThis is a complete, working `simpleStore.js` you can use for early milestones before adding a database. It provides a basic key-value interface.\n\n```javascript\n// server/persistence/simpleStore.js\n/**\n * A simple, in-memory key-value store with optional file persistence.\n * NOT for production use - data is lost on server restart unless saveToFile is used.\n */\nclass SimpleStore {\n  constructor(persistFile = null) {\n    this.data = new Map(); // key -> value\n    this.persistFile = persistFile;\n    this.loadFromFile();\n  }\n\n  // Load initial data from a JSON file\n  loadFromFile() {\n    if (!this.persistFile) return;\n    try {\n      const fs = require('fs');\n      if (fs.existsSync(this.persistFile)) {\n        const raw = fs.readFileSync(this.persistFile, 'utf8');\n        const entries = JSON.parse(raw);\n        this.data = new Map(entries);\n        console.log(`Loaded ${this.data.size} entries from ${this.persistFile}`);\n      }\n    } catch (err) {\n      console.error('Failed to load persistent store:', err);\n    }\n  }\n\n  // Save current state to a JSON file\n  saveToFile() {\n    if (!this.persistFile) return;\n    try {\n      const fs = require('fs');\n      const entries = Array.from(this.data.entries());\n      const raw = JSON.stringify(entries, null, 2);\n      fs.writeFileSync(this.persistFile, raw, 'utf8');\n    } catch (err) {\n      console.error('Failed to save persistent store:', err);\n    }\n  }\n\n  // Core CRUD operations\n  set(key, value) {\n    this.data.set(key, value);\n    this.saveToFile();\n    return true;\n  }\n\n  get(key) {\n    return this.data.get(key);\n  }\n\n  has(key) {\n    return this.data.has(key);\n  }\n\n  delete(key) {\n    const result = this.data.delete(key);\n    this.saveToFile();\n    return result;\n  }\n\n  // Find all keys where the value matches a predicate\n  find(predicate) {\n    const results = [];\n    for (const [key, value] of this.data.entries()) {\n      if (predicate(value, key)) {\n        results.push({ key, value });\n      }\n    }\n    return results;\n  }\n\n  // Get all entries as an array\n  getAll() {\n    return Array.from(this.data.entries());\n  }\n}\n\nmodule.exports = SimpleStore;\n```\n\n**D. Core Logic Skeleton Code (Connection Manager):**\nHere is the skeleton for the main `ConnectionManager` class. Fill in the TODOs based on the algorithm steps described in the Component Design section.\n\n```javascript\n// server/connectionManager/index.js\nconst WebSocket = require('ws');\nconst logger = require('../utils/logger');\nconst { validateMessage } = require('../utils/validation');\n\nclass ConnectionManager {\n  constructor(server) {\n    // ADR: Using Map for direct socket access by a unique connectionId\n    this.clients = new Map(); // connectionId -> { socket, userId, ... }\n    this.wss = new WebSocket.Server({ server });\n\n    this.setupEventHandlers();\n    this.startCleanupInterval();\n  }\n\n  setupEventHandlers() {\n    this.wss.on('connection', (socket, request) => {\n      // TODO 1: Generate a unique connectionId (e.g., uuid or timestamp+random)\n      // TODO 2: Create a client object with socket, connectionId, and metadata (ip, userAgent)\n      // TODO 3: Store client in this.clients Map\n      // TODO 4: Attach message, close, and error event handlers to the socket\n      // TODO 5: Log the connection event\n      // TODO 6: Optional: Implement immediate authentication check here (see Milestone 4 ADR)\n    });\n  }\n\n  // Handle an incoming message from a client\n  handleMessage(socket, rawMessage) {\n    // TODO 1: Try to parse rawMessage as JSON, catch error and send error response\n    // TODO 2: Validate the parsed message has required fields (type, payload)\n    // TODO 3: Look up the client object associated with this socket\n    // TODO 4: Route the message to the appropriate handler (e.g., roomManager.broadcast)\n    // TODO 5: Wrap in try/catch - log any handler error and send error response to client\n  }\n\n  // Handle client disconnection\n  handleClose(socket, code, reason) {\n    // TODO 1: Find the client object for this socket\n    // TODO 2: If found, notify the roomManager that this user left all rooms\n    // TODO 3: Remove the client from this.clients Map\n    // TODO 4: Log the disconnection event\n  }\n\n  // Send a message to a specific client socket\n  sendToClient(connectionId, message) {\n    // TODO 1: Look up client by connectionId\n    // TODO 2: Check if client.socket.readyState === WebSocket.OPEN\n    // TODO 3: If open, stringify message and send via client.socket.send()\n    // TODO 4: If not open, log a warning and optionally clean up the client\n  }\n\n  // Broadcast a message to multiple clients\n  broadcastToClients(connectionIds, message) {\n    // TODO 1: Iterate over connectionIds array\n    // TODO 2: For each id, call this.sendToClient(id, message)\n    // TODO 3: Consider batching or using Promise.all if performance becomes an issue\n  }\n\n  // Periodic cleanup of dead connections (fail-safe)\n  startCleanupInterval() {\n    setInterval(() => {\n      // TODO 1: Iterate over this.clients\n      // TODO 2: For each client, check if socket.readyState is CLOSED or CLOSING\n      // TODO 3: If so, call this.handleClose for that socket\n    }, 30000); // Run every 30 seconds\n  }\n\n  // Get statistics (for debugging/admin)\n  getStats() {\n    return {\n      totalConnections: this.clients.size,\n      // TODO: Add more stats like connections per user, etc.\n    };\n  }\n}\n\nmodule.exports = ConnectionManager;\n```\n\n**E. Language-Specific Hints (JavaScript/Node.js):**\n- **Use `ws` library:** Install via `npm install ws`. It's the most standard WebSocket server implementation for Node.js.\n- **Connection IDs:** Use `crypto.randomUUID()` (Node 15+) or the `uuid` package to generate unique connection identifiers.\n- **Heartbeats:** Implement using `socket.ping()` and `socket.pong()` listeners. Set a timer; if no pong is received within a timeout, terminate the connection.\n- **Error Handling:** Always attach an `'error'` listener to the WebSocket socket. Unhandled socket errors can crash the Node.js process.\n- **Logging:** Use a simple wrapper around `console.log` that prefixes with timestamps and log levels (INFO, ERROR). This dramatically improves debuggability.\n\n**F. Milestone Checkpoint (End of Milestone 1):**\nAfter implementing the Connection Manager skeleton:\n1.  **Run the server:** `node server/index.js`\n2.  **Test connection:** Open `client/public/index.html` in a browser (or use a WebSocket testing tool like `wscat`). You should see \"Connected to server\" in your server logs.\n3.  **Test multiple clients:** Open a second browser tab. Both should connect independently.\n4.  **Test disconnection:** Close one tab. Within a few seconds, you should see a \"Client disconnected\" log.\n5.  **Verify cleanup:** Check that your `this.clients.size` decreases after a disconnection (you can add a temporary log or admin endpoint).\n6.  **Expected Signs of Trouble:**\n    - **Server crashes on connect/disconnect:** Likely an unhandled error event on the socket. Add error listeners everywhere.\n    - **Client count keeps increasing:** You are not removing clients on disconnect. Check your `handleClose` logic and cleanup interval.\n    - **No logs appear:** Ensure your logger is called at each lifecycle event.\n\n---\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This architectural overview provides the foundation for all four milestones, outlining the major components and their interactions that will be built and integrated throughout the project.\n\nThe high-level architecture visualizes the system as four collaborating pillars, each with distinct responsibilities but working together to deliver the chat experience. This decomposition follows the **separation of concerns** principle: each component handles one core aspect of the system, making the codebase easier to understand, test, and maintain.\n\n### Component Overview and Responsibilities\n\nThink of the chat system as a **modern conference center**:\n- **The WebSocket Server** is the reception desk and switchboard, greeting visitors and connecting their calls\n- **The Room & Presence Manager** is the conference coordinator, tracking who's in which meeting room and what they're doing\n- **The Client Application** is the attendee's smartphone app, providing the interface to participate\n- **The Persistence Layer** is the archives and security office, storing historical records and verifying identities\n\nThis mental model helps visualize how responsibilities are divided while maintaining clear communication channels between components.\n\nThe following diagram illustrates the component architecture and their primary interactions:\n\n![System Component Overview](./diagrams/sys-component-diagram.svg)\n\n#### Core Components and Their Responsibilities\n\n| Component | Primary Responsibility | Key Data Owned | Critical Operations | Interfaces With |\n|-----------|----------------------|---------------|-------------------|-----------------|\n| **WebSocket Server & Connection Manager** | Manages the lifecycle of real-time connections | Set of active `ClientSession` objects, socket state | Accept connections, route messages, handle disconnections | Client browsers (via WebSocket), Room Manager, Auth Service |\n| **Room & Presence Manager** | Orchestrates room-based messaging and user presence | Collection of `Room` objects with member lists, typing status | Add/remove users from rooms, broadcast messages, track presence | WebSocket Server (for message delivery), Persistence Layer (for history) |\n| **Persistence & Authentication Service** | Stores message history and manages user identity | `User` records, `ChatMessage` history in database | User registration/login, message storage/retrieval, session validation | WebSocket Server (for auth), Room Manager (for history) |\n| **Client Application** | Provides the user interface for chat interaction | Local message cache, UI state, connection status | Render messages, capture user input, manage WebSocket connection | WebSocket Server (via WebSocket protocol) |\n\n#### Detailed Component Descriptions\n\n**WebSocket Server & Connection Manager**\nThis component serves as the **system's entry point** for all real-time communication. It's responsible for the low-level WebSocket protocol handling: accepting HTTP upgrade requests, establishing persistent connections, managing connection state, and providing a clean interface for other components to send messages to clients. It maintains a live registry of all connected clients as `ClientSession` objects, each representing a single WebSocket connection with associated metadata (user ID, IP address, user agent). The server implements **heartbeat mechanisms** (ping/pong) to detect stale connections and ensures proper cleanup when clients disconnect.\n\n**Room & Presence Manager**\nOperating as the **application's business logic layer**, this component implements the chat-specific functionality. It manages the concept of rooms (chat channels), tracks which users are in which rooms, handles message broadcasting with appropriate exclusions, and maintains presence information (online/offline status, typing indicators). When a message arrives from a client, the Room Manager determines which room it belongs to, retrieves the list of members in that room (excluding the sender), and instructs the WebSocket Server to deliver the message to each member's socket. It also handles room lifecycle—creating rooms when the first user joins and cleaning up empty rooms if configured to do so.\n\n**Persistence & Authentication Service**\nThis dual-purpose component provides **data durability and security**. The authentication portion handles user registration, login credential verification, and session management. When a WebSocket connection attempt occurs, this service validates the provided credentials (typically via token or cookie) before allowing the upgrade. The persistence portion stores all chat messages in a database with proper indexing by room and timestamp, enabling historical message retrieval. It also manages user profiles and, in more advanced implementations, could handle read receipts or message editing history.\n\n**Client Application**\nThe client is a **stateful web application** running in the user's browser. It establishes and maintains the WebSocket connection to the server, handles connection retries with exponential backoff, renders the chat interface, and manages local UI state (current room, message draft, unread counts). The client implements the event protocol defined by the server, sending properly formatted JSON messages for chat events and handling incoming messages to update the UI in real-time.\n\n#### Component Interaction Patterns\n\nThe components interact through three primary patterns:\n\n1. **Request-Response over WebSocket**: The client sends a message (like `join_room`), the server processes it through the appropriate handlers, and sends back a response (like `room_joined` with message history).\n\n2. **Event Notification**: When something happens that other clients should know about (like a user joining a room), the Room Manager instructs the WebSocket Server to broadcast an event (like `EVENT_USER_JOINED`) to all relevant clients.\n\n3. **Data Access**: The Room Manager queries the Persistence Layer for message history when a user joins a room, and writes new messages to it after validation.\n\n> **Key Design Insight:** The WebSocket Server acts as a **message transport layer**, while the Room Manager contains the **application logic**. This separation allows the transport mechanism to potentially be swapped (e.g., for a different real-time protocol) without rewriting the core chat functionality.\n\n#### Data Flow Between Components\n\nWhen a user sends a chat message, the data flows through the system as follows:\n\n1. **Client → WebSocket Server**: Raw WebSocket frame containing JSON\n2. **WebSocket Server → Room Manager**: Parsed message object with sender metadata\n3. **Room Manager → Persistence Layer**: Message stored to database\n4. **Room Manager → WebSocket Server**: List of recipient connection IDs and formatted message\n5. **WebSocket Server → Multiple Clients**: Individual WebSocket frames to each recipient\n\nThis flow ensures that business logic (room membership, message formatting) remains separate from transport concerns (socket management, connection state).\n\n### Recommended File/Module Structure\n\nOrganizing the codebase with a clear structure from the beginning prevents the common \"everything in one file\" antipattern that makes projects difficult to maintain. The recommended structure follows the **component boundaries** established in the architecture, with clear separation between transport logic, business logic, persistence, and client code.\n\n```\nreal-time-chat/\n├── server/                          # Server-side code\n│   ├── src/                         # TypeScript source\n│   │   ├── core/                    # Foundational utilities\n│   │   │   ├── logger.ts            # Structured logging\n│   │   │   ├── config.ts            # Configuration management\n│   │   │   └── errors.ts            # Custom error classes\n│   │   ├── transport/               # WebSocket Server component\n│   │   │   ├── websocket-server.ts  # Main WebSocket server class\n│   │   │   ├── connection-manager.ts # Manages ClientSession objects\n│   │   │   ├── protocol/            # Message protocol definitions\n│   │   │   │   ├── message-types.ts # Constants like EVENT_CHAT_MESSAGE\n│   │   │   │   ├── validators.ts    # Message validation functions\n│   │   │   │   └── serializers.ts   # Message formatting utilities\n│   │   │   └── middleware/          # WebSocket middleware\n│   │   │       ├── auth-middleware.ts # Authentication on upgrade\n│   │   │       └── heartbeat-middleware.ts # Ping/pong handling\n│   │   ├── rooms/                   # Room & Presence Manager component\n│   │   │   ├── room-manager.ts      # Main room management class\n│   │   │   ├── presence-tracker.ts  # Tracks online/typing status\n│   │   │   ├── room.ts              # Room class definition\n│   │   │   └── types.ts             # TypeScript interfaces for rooms\n│   │   ├── persistence/             # Persistence & Auth component\n│   │   │   ├── auth/                # Authentication subsystem\n│   │   │   │   ├── auth-service.ts  # User registration/login\n│   │   │   │   ├── session-store.ts # Manages active sessions\n│   │   │   │   └── password-utils.ts # Password hashing/verification\n│   │   │   ├── database/            # Database abstraction\n│   │   │   │   ├── message-store.ts # ChatMessage CRUD operations\n│   │   │   │   ├── user-store.ts    # User profile management\n│   │   │   │   └── base-repository.ts # Shared database logic\n│   │   │   └── models/              # Data model definitions\n│   │   │       ├── chat-message.ts  # ChatMessage type/interface\n│   │   │       ├── user.ts          # User type/interface\n│   │   │       └── client-session.ts # ClientSession type/interface\n│   │   └── main.ts                  # Application entry point\n│   ├── tests/                       # Server-side tests\n│   │   ├── unit/                    # Unit tests by component\n│   │   └── integration/             # Integration tests\n│   ├── package.json                 # Node.js dependencies\n│   └── tsconfig.json                # TypeScript configuration\n├── client/                          # Web client application\n│   ├── src/                         # Client source code\n│   │   ├── lib/                     # Client-side libraries\n│   │   │   └── websocket-client.ts  # WebSocket connection wrapper\n│   │   ├── ui/                      # User interface components\n│   │   │   ├── chat-room.ts         # Main chat room component\n│   │   │   ├── message-list.ts      # Message display component\n│   │   │   ├── user-list.ts         # Online users component\n│   │   │   └── message-input.ts     # Message composition component\n│   │   ├── state/                   # Client-side state management\n│   │   │   ├── connection-store.ts  # WebSocket connection state\n│   │   │   ├── message-store.ts     # Local message cache\n│   │   │   └── user-store.ts        # Local user/profile state\n│   │   ├── utils/                   # Client utilities\n│   │   │   └── message-formatter.ts # Format messages for display\n│   │   └── main.ts                  # Client application entry point\n│   ├── public/                      # Static assets\n│   │   └── index.html               # Main HTML file\n│   └── package.json                 # Client dependencies\n├── shared/                          # Code shared between client and server\n│   └── types/                       # Shared TypeScript definitions\n│       └── protocol.ts              # Common message type definitions\n└── docker-compose.yml               # Local development with database\n```\n\n#### Key Structural Decisions\n\n**Decision: Separating Transport from Business Logic**\n- **Context**: The system needs to handle both the low-level WebSocket protocol and high-level chat semantics\n- **Options Considered**: \n  1. Combined transport and business logic in one module\n  2. Separate transport layer with clean interface to business logic\n- **Decision**: Separate transport (`transport/`) from business logic (`rooms/`)\n- **Rationale**: This separation allows each to evolve independently—the transport could switch to a different protocol (like Socket.IO or raw TCP) without affecting room management logic. It also enables cleaner testing, as the room logic can be tested without actual WebSocket connections.\n- **Consequences**: Requires well-defined interfaces between layers, slightly more code organization overhead, but yields more maintainable and testable code.\n\n**Decision: Client-Server Shared Types**\n- **Context**: Both client and server need to agree on message formats and data structures\n- **Options Considered**:\n  1. Duplicate type definitions in both codebases\n  2. Shared TypeScript definitions in a common directory\n- **Decision**: Shared type definitions in `shared/types/`\n- **Rationale**: This ensures type safety across the entire stack—if a message format changes, TypeScript will catch inconsistencies at compile time rather than runtime. It's particularly valuable for the event protocol where client and server must agree exactly on field names and types.\n- **Consequences**: Requires build configuration to include shared directory in both client and server TypeScript compilation, but prevents a whole class of protocol mismatch bugs.\n\n**Decision: Database Abstraction Layer**\n- **Context**: The system needs to store messages and user data, but the specific database technology might evolve\n- **Options Considered**:\n  1. Direct database calls throughout the codebase\n  2. Repository pattern with clean interfaces\n- **Decision**: Repository pattern in `persistence/database/`\n- **Rationale**: This abstraction allows switching database technologies (from SQLite for development to PostgreSQL for production) with minimal code changes. It also centralizes database queries, making optimization and debugging easier.\n- **Consequences**: Adds an extra layer of abstraction but significantly improves long-term maintainability and testability (via mocking).\n\n> **Implementation Note:** For simplicity in early milestones, you may start with in-memory storage in the Room Manager and add persistence later. The architecture supports this progression—the Room Manager interface to the persistence layer remains the same whether it's talking to an in-memory store or a real database.\n\n#### Module Dependencies and Import Flow\n\nThe dependency flow follows a **unidirectional architecture**:\n\n```\nmain.ts → websocket-server.ts → connection-manager.ts\n                                ↗\nroom-manager.ts ← persistence/ (auth-service, message-store)\n```\n\nKey dependency rules:\n1. **High-level components depend on low-level ones**, not vice versa\n2. **The `transport/` layer knows about `rooms/` and `persistence/`** for message routing\n3. **The `rooms/` layer knows about `persistence/`** for data access\n4. **The `persistence/` layer has no dependencies** on other business logic components\n5. **Shared types have no dependencies** and are imported by both client and server\n\nThis structure prevents circular dependencies and makes the system easier to reason about.\n\n### Implementation Guidance\n\n> **Technology Note:** For this JavaScript/TypeScript project, we recommend starting with Node.js and the `ws` library for WebSocket support, as it provides a minimal, standards-compliant implementation without the additional abstractions of Socket.IO. This approach gives you direct exposure to the WebSocket protocol fundamentals.\n\n#### Technology Recommendations\n\n| Component | Simple Option (Learning Focus) | Advanced Option (Production Ready) |\n|-----------|-------------------------------|-----------------------------------|\n| **WebSocket Server** | Node.js + `ws` library | Node.js + `ws` with connection pooling |\n| **Room Management** | In-memory JavaScript objects | Redis for distributed room state |\n| **Persistence** | SQLite with `better-sqlite3` | PostgreSQL with connection pooling |\n| **Authentication** | JWT tokens stored in memory | OAuth2.0 with persistent session store |\n| **Client Framework** | Vanilla JavaScript + DOM API | React/Vue.js with state management |\n\n#### Starter Project Structure Setup\n\nCreate the basic project structure with these commands:\n\n```bash\n# Create project root\nmkdir real-time-chat\ncd real-time-chat\n\n# Initialize server\nmkdir -p server/src/{core,transport/{protocol,middleware},rooms,persistence/{auth,database,models}}\nmkdir server/tests/{unit,integration}\ncd server\nnpm init -y\nnpm install ws typescript @types/node @types/ws\nnpm install -D ts-node nodemon jest @types/jest\n\n# Initialize client\ncd ..\nmkdir -p client/src/{lib,ui,state,utils}\nmkdir client/public\ncd client\nnpm init -y\nnpm install typescript\n\n# Create shared types directory\ncd ..\nmkdir -p shared/types\n\n# Create TypeScript configurations\n# (Details in next section)\n```\n\n#### Basic TypeScript Configuration\n\nCreate `server/tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"types\": [\"node\", \"jest\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\nCreate `client/tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n#### Core Infrastructure Starter Code\n\n**Shared Protocol Types (`shared/types/protocol.ts`)**:\n```typescript\n// Shared type definitions between client and server\nexport interface ChatMessage {\n  sender: string;\n  content: string;\n  timestamp: string; // ISO format\n  roomId: string;\n}\n\nexport interface User {\n  username: string;\n  passwordHash: string;\n  createdAt: Date;\n}\n\nexport interface ClientSession {\n  connectionId: string;\n  socket: WebSocket; // Note: WebSocket type differs client vs server\n  userId: string;\n  ip: string;\n  userAgent: string;\n}\n\n// Event type constants\nexport const EVENT_CHAT_MESSAGE = 'chat_message';\nexport const EVENT_USER_JOINED = 'user_joined';\nexport const EVENT_USER_TYPING = 'user_typing';\nexport const MAX_MESSAGE_LENGTH = 1000;\n\n// Message envelope for WebSocket communication\nexport interface WebSocketMessage {\n  type: string;\n  payload: any;\n  timestamp?: string;\n}\n```\n\n**Server Core Utilities (`server/src/core/logger.ts`)**:\n```typescript\n// Simple structured logger for development\nexport class Logger {\n  static info(message: string, metadata: any = {}) {\n    console.log(JSON.stringify({\n      level: 'INFO',\n      timestamp: new Date().toISOString(),\n      message,\n      ...metadata\n    }));\n  }\n\n  static error(message: string, error: any = {}, metadata: any = {}) {\n    console.error(JSON.stringify({\n      level: 'ERROR',\n      timestamp: new Date().toISOString(),\n      message,\n      error: error.message || String(error),\n      stack: error.stack,\n      ...metadata\n    }));\n  }\n\n  static warn(message: string, metadata: any = {}) {\n    console.warn(JSON.stringify({\n      level: 'WARN',\n      timestamp: new Date().toISOString(),\n      message,\n      ...metadata\n    }));\n  }\n}\n```\n\n**Server Entry Point Skeleton (`server/src/main.ts`)**:\n```typescript\nimport { WebSocketServer } from './transport/websocket-server';\nimport { Logger } from './core/logger';\n\nconst PORT = process.env.PORT || 8080;\n\nasync function main() {\n  Logger.info('Starting real-time chat server', { port: PORT });\n\n  // TODO: Initialize database connection if using persistence\n  \n  // Create and start WebSocket server\n  const server = new WebSocketServer({\n    port: Number(PORT),\n    // TODO: Pass configuration for room manager, auth service, etc.\n  });\n\n  server.start();\n\n  // Graceful shutdown handling\n  process.on('SIGTERM', () => {\n    Logger.info('Received SIGTERM, shutting down gracefully');\n    server.stop();\n    process.exit(0);\n  });\n\n  process.on('SIGINT', () => {\n    Logger.info('Received SIGINT, shutting down gracefully');\n    server.stop();\n    process.exit(0);\n  });\n}\n\nmain().catch((error) => {\n  Logger.error('Failed to start server', error);\n  process.exit(1);\n});\n```\n\n**Client WebSocket Wrapper Skeleton (`client/src/lib/websocket-client.ts`)**:\n```typescript\nimport { WebSocketMessage } from '../../../shared/types/protocol';\n\nexport class WebSocketClient {\n  private socket: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n\n  constructor(private url: string) {}\n\n  connect(): void {\n    // TODO 1: Create new WebSocket connection to this.url\n    // TODO 2: Set up event handlers for open, message, close, error\n    // TODO 3: Implement exponential backoff for reconnection\n    // TODO 4: Store connection state for UI feedback\n  }\n\n  send(message: WebSocketMessage): void {\n    // TODO 1: Check if socket is in OPEN state (readyState === 1)\n    // TODO 2: Stringify message to JSON\n    // TODO 3: Send via socket.send()\n    // TODO 4: Handle errors (queue for retry or notify UI)\n  }\n\n  disconnect(): void {\n    // TODO 1: Close WebSocket connection gracefully\n    // TODO 2: Clean up event listeners\n    // TODO 3: Reset reconnect state\n  }\n\n  // TODO: Add methods for specific message types (sendChatMessage, joinRoom, etc.)\n}\n```\n\n#### Development Scripts\n\nAdd these scripts to `server/package.json`:\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/main.js\",\n    \"dev\": \"nodemon --exec ts-node src/main.ts\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\"\n  }\n}\n```\n\n#### Next Steps for Implementation\n\nWith this architecture in place, you'll implement the system component by component:\n\n1. **Start with the WebSocket Server** (Milestone 1): Implement the connection lifecycle in `transport/`\n2. **Add Room Management** (Milestones 2-3): Build the room logic in `rooms/` \n3. **Implement Persistence** (Milestone 4): Add database storage in `persistence/`\n4. **Build the Client** (Parallel development): Create the UI in `client/`\n\nThe clear separation between components allows you to work on one layer at a time, testing each in isolation before integrating them into the complete system.\n\n---\n\n\n## Data Model\n\n> **Milestone(s):** All milestones (1-4). This section defines the foundational data structures and communication protocol that enable real-time messaging, room management, user presence, and message persistence across the entire system. The data model serves as the contract between components and clients.\n\n### Core Types and Structures\n\nThink of the data model as the **DNA of your chat application**—it encodes all the information needed to represent users, conversations, and interactions. Just as DNA has four nucleotide bases (A, T, C, G) that combine in specific patterns to create genetic instructions, your chat system has four core data types (`ChatMessage`, `User`, `Room`, and `ClientSession`) that combine to represent the complete state of the application. These structures flow through your system like genetic information flows through a biological organism, providing the blueprint for all functionality.\n\nThe following tables define each core type with exact field specifications. Note that these are **in-memory representations** used within the server—the wire format for transmitting this data to clients may differ slightly (e.g., using ISO string timestamps instead of Date objects).\n\n#### ChatMessage\nA `ChatMessage` represents a single unit of communication between users. It's the atomic building block of conversation—like a sentence in a dialogue. Each message is immutable once created and serves as a historical record of what was said, by whom, when, and where.\n\n| Field Name | Type | Description & Constraints |\n|------------|------|---------------------------|\n| `sender` | `string` | The username of the user who sent this message. This must match an existing user's username in the system. Cannot be empty or contain only whitespace. |\n| `content` | `string` | The textual content of the message. Maximum length is defined by `MAX_MESSAGE_LENGTH` (1000 characters). Must be validated for length and sanitized for potentially malicious content (e.g., HTML tags) before storage or transmission. |\n| `timestamp` | `string` (ISO 8601) | The UTC date and time when the server received and processed the message, expressed in ISO 8601 format (e.g., `\"2024-01-15T10:30:45.123Z\"`). Using a string format ensures consistent parsing across different clients and languages. The server assigns this timestamp, not the client, to prevent clock skew issues. |\n| `roomId` | `string` | The unique identifier of the room where this message was sent. This must correspond to an existing room's `id` field. Messages are always scoped to a specific room—they cannot exist outside of a room context. |\n\n> **Design Insight:** The `timestamp` field uses ISO 8601 string format rather than a numeric Unix timestamp for better human readability during debugging and compatibility with JavaScript's `Date.parse()` and `toISOString()` methods. However, this comes with a slight storage overhead compared to storing milliseconds as a number.\n\n#### User\nA `User` represents a registered person who can participate in chat rooms. Think of it as a **citizen of your chat universe**—they have an identity (`username`), proof of citizenship (`passwordHash`), and a record of when they joined the community (`createdAt`). The `User` object contains authentication credentials and metadata, but note that it does NOT contain connection state—that's tracked separately in `ClientSession`.\n\n| Field Name | Type | Description & Constraints |\n|------------|------|---------------------------|\n| `username` | `string` | Unique identifier for the user across the system. Typically 3-20 characters, alphanumeric with optional underscores or hyphens. Case-sensitive for simplicity (though you could normalize to lowercase). |\n| `passwordHash` | `string` | Hashed representation of the user's password using a secure one-way hash function (e.g., bcrypt, Argon2). Never store passwords in plain text. The hash should include a salt to prevent rainbow table attacks. |\n| `createdAt` | `Date` | The date and time when the user account was created. Used for administrative purposes and potentially for displaying \"member since\" information. Stored as a Date object server-side but serialized to ISO string when transmitted. |\n\n> **Design Insight:** The `User` object is separate from connection state (`ClientSession`) because a single user can be connected from multiple devices simultaneously (e.g., phone and laptop). This separation enables features like \"last seen\" timestamps and multi-device message synchronization in more advanced implementations.\n\n#### Room\nA `Room` represents a named conversation space where users gather to exchange messages. Imagine it as a **virtual conference room** with a door, a nameplate, and a list of who's currently inside. Rooms are dynamic containers that hold both members (via `memberIds`) and the history of their conversation (via associated `ChatMessage` records in the database).\n\n| Field Name | Type | Description & Constraints |\n|------------|------|---------------------------|\n| `id` | `string` | Unique identifier for the room, typically generated as a UUID or a URL-safe version of the room name. Used as a stable reference in URLs and message routing. |\n| `name` | `string` | Human-readable room name (e.g., \"general\", \"random\", \"project-discussion\"). Displayed in room lists and UI headers. Should be sanitized to prevent injection attacks. |\n| `createdAt` | `Date` | When the room was created. Useful for administrative cleanup of old, inactive rooms. |\n| `memberIds` | `Set<string>` | A collection of user IDs (usernames) who are currently present in the room. Using a `Set` ensures each user appears only once and provides O(1) membership tests. This set is updated in real-time as users join and leave. |\n\n> **Design Insight:** The `memberIds` field uses a `Set` rather than an `Array` for efficient membership testing (`Set.has()` is O(1) vs `Array.includes()` which is O(n)). This performance difference becomes critical when broadcasting messages to rooms with hundreds of members.\n\n#### ClientSession\nA `ClientSession` represents an **active WebSocket connection** from a specific user on a specific device. Think of it as a **telephone handset**—it's the physical connection through which a user participates in conversations. Each `ClientSession` links a low-level WebSocket object to a specific user identity (`userId`) and contains metadata about the connection itself.\n\n| Field Name | Type | Description & Constraints |\n|------------|------|---------------------------|\n| `connectionId` | `string` | Unique identifier for this specific WebSocket connection. Generated when the connection is established (e.g., using a UUID). Used to reference this specific session in message routing and disconnection handling. |\n| `socket` | `WebSocket` | The actual WebSocket object provided by your WebSocket library (e.g., `ws` in Node.js). This is the raw communication channel for sending and receiving data. The `readyState` property indicates if the connection is open, closing, or closed. |\n| `userId` | `string` | The username of the authenticated user associated with this connection. References the `User.username` field. A single user may have multiple `ClientSession` objects if connected from multiple devices. |\n| `ip` | `string` | The IP address of the client connection. Useful for logging, rate limiting, and security monitoring. Captured during the initial HTTP upgrade request. |\n| `userAgent` | `string` | The User-Agent header from the client's initial HTTP request. Helps identify client types (browser, mobile app, bot) for debugging and analytics. |\n\n> **Design Insight:** Storing the raw `WebSocket` object directly in the `ClientSession` is a pragmatic choice for this learning-focused implementation. In production systems, you might wrap the socket with additional abstractions to handle reconnections, message batching, and protocol upgrades, but for clarity and simplicity, we keep the direct reference.\n\nThe relationship between these core types is visualized in the following diagram, which shows how users connect via sessions, join rooms, and send messages:\n\n![Core Data Relationships](./diagrams/data-model-diagram.svg)\n\n### Wire Format and Event Protocol\n\nIf the core types are the DNA, the wire format is the **language spoken between clients and servers**. All communication over WebSocket connections follows a consistent JSON-based protocol where clients and servers exchange structured \"events\" with typed payloads. This protocol defines the vocabulary and grammar of your chat application—what can be said, how it's structured, and what responses are expected.\n\n> **Mental Model:** Think of the WebSocket connection as a two-way radio channel. Clients and servers don't just send raw text back and forth—they send structured \"radio messages\" with a standard format: \"This is Unit A to Base, message type: STATUS_REPORT, payload: {battery: 85%, location: grid B7}\". The message type tells the receiver how to interpret the payload, and both sides agree on the meaning of each message type beforehand.\n\n#### WebSocketMessage Envelope\nEvery message sent over the WebSocket connection, regardless of direction (client→server or server→client), is wrapped in a standard envelope structure called `WebSocketMessage`. This envelope provides metadata about the message content and enables extensibility for future message types.\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `type` | `string` | Yes | Identifies the kind of event or action this message represents. Must be one of the predefined `EVENT_*` constants (e.g., `EVENT_CHAT_MESSAGE`, `EVENT_USER_JOINED`). This field tells the receiver which handler to invoke and how to parse the payload. |\n| `payload` | `any` (JSON-serializable) | Yes | The data content specific to this message type. Structure varies by message type—see the Event Catalog below. Must be valid JSON (objects, arrays, strings, numbers, booleans, null). |\n| `timestamp` | `string` (ISO 8601) | No (optional) | When the sender created this message. For server-originated messages, this is always populated. For client messages, the server will typically ignore client-provided timestamps and assign its own upon receipt to maintain a single source of truth. |\n\n**Example Wire Format:**\n```json\n{\n  \"type\": \"chat_message\",\n  \"payload\": {\n    \"sender\": \"alice\",\n    \"content\": \"Hello everyone!\",\n    \"roomId\": \"general\"\n  },\n  \"timestamp\": \"2024-01-15T10:30:45.123Z\"\n}\n```\n\n> **Design Insight:** Using a consistent envelope format (`type` + `payload`) rather than free-form JSON messages makes the protocol self-describing and extensible. New message types can be added without breaking existing clients (as long as they ignore unknown types), and the type field enables efficient routing to appropriate handler functions.\n\n#### Event Catalog\nThe following table catalogues the standard event types that form the complete vocabulary of the chat protocol. These constants should be defined in your codebase and used consistently by both client and server implementations.\n\n| Event Constant | Value | Direction | Purpose & Payload Structure |\n|----------------|-------|-----------|-----------------------------|\n| `EVENT_CHAT_MESSAGE` | `\"chat_message\"` | Bidirectional | **Client→Server:** Sends a new chat message to a room. Payload: `{sender: string, content: string, roomId: string}`.<br>**Server→Client:** Broadcasts a received message to all room members (excluding sender). Payload: A complete `ChatMessage` object with server-assigned `timestamp`. |\n| `EVENT_USER_JOINED` | `\"user_joined\"` | Server→Client | Notifies existing room members that a new user has entered. Payload: `{username: string, roomId: string, timestamp: string}`. Typically sent after successful room join. |\n| `EVENT_USER_LEFT` | `\"user_left\"` | Server→Client | Notifies room members that a user has left the room (either voluntarily or via disconnect). Payload: `{username: string, roomId: string, timestamp: string}`. |\n| `EVENT_USER_TYPING` | `\"user_typing\"` | Bidirectional | **Client→Server:** Indicates the user has started typing in a room. Payload: `{username: string, roomId: string, isTyping: boolean}` (where `isTyping` is `true` for start, `false` for stop).<br>**Server→Client:** Broadcasts typing status to other room members. Payload same as client→server. |\n| `EVENT_JOIN_ROOM` | `\"join_room\"` | Client→Server | Requests to join a specific chat room. Payload: `{roomId: string, username: string}`. Server validates authentication and room existence before granting access. |\n| `EVENT_JOIN_ROOM_SUCCESS` | `\"join_room_success\"` | Server→Client | Response confirming successful room entry. Payload: `{roomId: string, roomName: string, members: string[], history: ChatMessage[]}`. Includes current member list and recent message history. |\n| `EVENT_JOIN_ROOM_ERROR` | `\"join_room_error\"` | Server→Client | Response indicating room join failed. Payload: `{roomId: string, error: string}` with human-readable error message. |\n| `EVENT_ROOM_LIST` | `\"room_list\"` | Server→Client | Response to room listing request. Payload: `{rooms: Array<{id: string, name: string, memberCount: number}>}`. |\n| `EVENT_PRESENCE_UPDATE` | `\"presence_update\"` | Server→Client | Broadcasts changes in user online/offline status across the system (not room-specific). Payload: `{username: string, isOnline: boolean, lastSeen: string}`. |\n| `EVENT_ERROR` | `\"error\"` | Server→Client | Generic error response for malformed messages, authentication failures, or server errors. Payload: `{code: string, message: string, originalEventType: string}`. |\n| `EVENT_HEARTBEAT` | `\"heartbeat\"` | Bidirectional | Periodic ping/pong messages to keep connection alive and detect disconnections. Payload: `{sequence: number}` (monotonically increasing number). |\n\n#### Architecture Decision: Structured Events vs. Ad-Hoc Messages\n\n> **Decision: Use Typed JSON Event Protocol**\n> - **Context:** We need a communication protocol between client and server over WebSocket that supports multiple message types (chat, presence, typing indicators, etc.) with varying payload structures. The protocol must be easy to implement, debug, and extend.\n> - **Options Considered:**\n>   1. **Free-form JSON with implicit type:** Send JSON objects with varying structures and infer meaning from field presence (e.g., `{text: \"hello\"}` is a chat message, `{typing: true}` is a typing indicator).\n>   2. **String prefix protocol:** Send messages as strings with a type prefix and delimiter (e.g., `\"CHAT|alice|Hello\"` or `\"TYPING|alice|true\"`).\n>   3. **Structured JSON with explicit type field:** Send JSON objects with a `type` field identifying the message type and a `payload` field containing type-specific data.\n> - **Decision:** Option 3—structured JSON with explicit type field.\n> - **Rationale:** \n>   - **Self-documenting:** The `type` field makes messages immediately understandable during debugging.\n>   - **Extensible:** New message types can be added without breaking existing parsing logic.\n>   - **Type-safe:** On TypeScript clients, we can define discriminated unions based on the `type` field for compile-time validation.\n>   - **Consistent with industry patterns:** Similar to Redux actions, Socket.io events, and other event-driven architectures developers may encounter.\n> - **Consequences:**\n>   - Slightly larger payload size due to the additional `type` field and nested `payload` structure.\n>   - Requires proper validation of the `type` field against allowed values.\n>   - Encourages a clean separation between message routing logic and message handling logic.\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| Free-form JSON | Minimal overhead, simple to create | Hard to extend, difficult to debug, ambiguous parsing | Too fragile—adding new message types requires modifying parsing logic |\n| String prefix | Very compact, fast parsing | Not self-describing, hard to nest complex data | Poor developer experience, error-prone string manipulation |\n| **Structured JSON** | **Self-documenting, extensible, type-safe** | **Slightly larger payloads** | **CHOSEN: Best balance of clarity and practicality** |\n\n#### Common Pitfalls: Protocol Design Mistakes\n\n⚠️ **Pitfall: Inconsistent Payload Structures**\n- **Description:** Using different field names or structures for the same event type in different parts of the codebase (e.g., sending `user` in some places but `username` in others for `EVENT_USER_JOINED`).\n- **Why it's wrong:** Clients break because they expect consistent payloads. Debugging becomes difficult as you need to trace where each variant originates.\n- **Fix:** Define payload interfaces/types for each event and reuse them everywhere. Consider creating factory functions that generate properly structured events.\n\n⚠️ **Pitfall: Missing Timestamps on Server-Originated Events**\n- **Description:** Forgetting to include the `timestamp` field in messages sent from server to client.\n- **Why it's wrong:** Clients cannot properly order messages from different sources or display \"time ago\" indicators. Message history becomes ambiguous.\n- **Fix:** Always add a `timestamp` field with `new Date().toISOString()` for server-originated messages. Create a helper function `createServerMessage(type, payload)` that automatically adds the timestamp.\n\n⚠️ **Pitfall: Not Validating Client-Provided Payloads**\n- **Description:** Trusting that clients will always send valid, well-formed payloads according to the expected schema.\n- **Why it's wrong:** Malicious clients or buggy implementations can send malformed data that crashes the server or causes undefined behavior.\n- **Fix:** Validate every incoming message against a schema (using libraries like `joi`, `zod`, or manual checks). Check required fields, data types, string lengths, and value ranges before processing.\n\n⚠️ **Pitfall: Ignoring Unknown Message Types**\n- **Description:** When receiving a message with an unrecognized `type` field, throwing an error or crashing.\n- **Why it's wrong:** Prevents forward compatibility—if you deploy a server with new message types, older clients will crash when they receive messages they don't understand.\n- **Fix:** Log a warning for unknown message types but don't crash. Silently ignore or send a generic \"unsupported message type\" error response.\n\n### Implementation Guidance\n\n> **Target Language:** JavaScript/Node.js (with TypeScript types for clarity where helpful)\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Learning Focus) | Advanced Option (Production Ready) |\n|-----------|-------------------------------|-----------------------------------|\n| **Message Serialization** | Native `JSON.parse()` and `JSON.stringify()` | Schema validation with `zod` or `joi` before parsing |\n| **Type Safety** | Manual type checking with `typeof` and `Array.isArray()` | TypeScript with strict mode and discriminated unions |\n| **Date Handling** | JavaScript `Date` objects and `toISOString()` | `date-fns` or `luxon` for robust date manipulation |\n| **Unique IDs** | `crypto.randomUUID()` (Node.js 15+) or `uuid` package | ULID or NanoID for time-ordered, URL-safe IDs |\n\n#### B. Recommended File/Module Structure\n\nPlace data model definitions and protocol constants in a dedicated module for easy import throughout your codebase:\n\n```\nreal-time-chat/\n├── package.json\n├── src/\n│   ├── server/\n│   │   ├── index.js              # Server entry point\n│   │   ├── connectionManager.js  # Component Design: WebSocket Server\n│   │   ├── roomManager.js        # Component Design: Message Broker & Room Manager\n│   │   ├── authService.js        # Component Design: Persistence & Authentication\n│   │   └── models/               # DATA MODEL FILES GO HERE\n│   │       ├── types.js          # Core type definitions (ChatMessage, User, etc.)\n│   │       ├── protocol.js       # Event constants and wire format utilities\n│   │       └── validation.js     # Schema validation for incoming messages\n│   ├── client/\n│   │   └── public/               # HTML/JS client files\n│   └── shared/                   # Code shared between client and server\n│       └── protocol.js           # Shared event constants (if using module bundler)\n└── tests/\n    └── unit/\n        └── models/               # Tests for data model validation\n```\n\n#### C. Infrastructure Starter Code\n\nCreate a complete, reusable module for message validation and serialization. This code handles the boilerplate of parsing JSON, validating structure, and ensuring type safety:\n\n**File: `src/server/models/validation.js`**\n```javascript\n/**\n * Validation utilities for WebSocket messages and data models\n */\n\nconst MAX_MESSAGE_LENGTH = 1000;\n\n/**\n * Validates a raw WebSocket message string as a valid WebSocketMessage envelope\n * @param {string} rawMessage - Raw string received from WebSocket\n * @returns {{type: string, payload: any, timestamp?: string} | null}\n * @throws {Error} If message is not valid JSON or lacks required fields\n */\nfunction parseAndValidateWebSocketMessage(rawMessage) {\n  try {\n    const parsed = JSON.parse(rawMessage);\n    \n    // Validate required fields\n    if (typeof parsed.type !== 'string' || parsed.type.trim() === '') {\n      throw new Error('Message must have a non-empty string \"type\" field');\n    }\n    \n    if (parsed.payload === undefined) {\n      throw new Error('Message must have a \"payload\" field');\n    }\n    \n    // Optional timestamp validation if present\n    if (parsed.timestamp !== undefined) {\n      if (typeof parsed.timestamp !== 'string') {\n        throw new Error('Timestamp must be a string if provided');\n      }\n      // Validate ISO format (basic check)\n      if (!/\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(parsed.timestamp)) {\n        throw new Error('Timestamp must be in ISO 8601 format');\n      }\n    }\n    \n    return {\n      type: parsed.type.trim(),\n      payload: parsed.payload,\n      timestamp: parsed.timestamp\n    };\n  } catch (error) {\n    // Enhance error message for JSON parsing errors\n    if (error instanceof SyntaxError) {\n      throw new Error(`Invalid JSON: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Validates a ChatMessage payload structure\n * @param {any} payload - The payload to validate\n * @returns {{sender: string, content: string, roomId: string, timestamp: string}}\n * @throws {Error} If payload does not match ChatMessage structure\n */\nfunction validateChatMessagePayload(payload) {\n  if (typeof payload !== 'object' || payload === null) {\n    throw new Error('Chat message payload must be an object');\n  }\n  \n  const { sender, content, roomId, timestamp } = payload;\n  \n  if (typeof sender !== 'string' || sender.trim() === '') {\n    throw new Error('Chat message must have a non-empty sender field');\n  }\n  \n  if (typeof content !== 'string') {\n    throw new Error('Chat message must have a string content field');\n  }\n  \n  if (content.length > MAX_MESSAGE_LENGTH) {\n    throw new Error(`Message content exceeds maximum length of ${MAX_MESSAGE_LENGTH} characters`);\n  }\n  \n  if (typeof roomId !== 'string' || roomId.trim() === '') {\n    throw new Error('Chat message must have a non-empty roomId field');\n  }\n  \n  // Server should assign timestamp, but validate if provided\n  if (timestamp !== undefined && typeof timestamp !== 'string') {\n    throw new Error('Chat message timestamp must be a string if provided');\n  }\n  \n  return {\n    sender: sender.trim(),\n    content: content.trim(),\n    roomId: roomId.trim(),\n    timestamp: timestamp || new Date().toISOString()\n  };\n}\n\n/**\n * Creates a properly formatted WebSocketMessage for server-originated events\n * @param {string} type - Event type (use protocol constants)\n * @param {any} payload - Event-specific payload\n * @returns {string} JSON string ready to send over WebSocket\n */\nfunction createServerMessage(type, payload) {\n  const message = {\n    type,\n    payload,\n    timestamp: new Date().toISOString()\n  };\n  return JSON.stringify(message);\n}\n\nmodule.exports = {\n  parseAndValidateWebSocketMessage,\n  validateChatMessagePayload,\n  createServerMessage,\n  MAX_MESSAGE_LENGTH\n};\n```\n\n#### D. Core Logic Skeleton Code\n\nHere are the skeleton implementations for the key data model handling functions that you'll need to implement:\n\n**File: `src/server/models/types.js`**\n```javascript\n/**\n * Core type definitions and factory functions\n */\n\n// Event constants - must match exactly with NAMING CONVENTIONS\nconst EVENT_CHAT_MESSAGE = 'chat_message';\nconst EVENT_USER_JOINED = 'user_joined';\nconst EVENT_USER_TYPING = 'user_typing';\n// Add other event constants from the Event Catalog here...\n\n/**\n * Creates a new ChatMessage object with server-assigned timestamp\n * @param {string} sender - Username of the sender\n * @param {string} content - Message content\n * @param {string} roomId - Room identifier\n * @returns {ChatMessage} A complete ChatMessage object\n */\nfunction createChatMessage(sender, content, roomId) {\n  // TODO 1: Validate that sender is a non-empty string\n  // TODO 2: Validate that content is a string and doesn't exceed MAX_MESSAGE_LENGTH\n  // TODO 3: Validate that roomId is a non-empty string\n  // TODO 4: Generate a timestamp using new Date().toISOString()\n  // TODO 5: Return an object with fields: sender, content, timestamp, roomId\n  // TODO 6: Ensure all string fields are trimmed of surrounding whitespace\n}\n\n/**\n * Creates a new Room object with initial empty member set\n * @param {string} name - Human-readable room name\n * @returns {Room} A new Room object with generated id and creation timestamp\n */\nfunction createRoom(name) {\n  // TODO 1: Validate that name is a non-empty string\n  // TODO 2: Generate a unique room ID (consider using crypto.randomUUID() or a URL-safe slug)\n  // TODO 3: Create a new empty Set for memberIds\n  // TODO 4: Record current timestamp as createdAt (Date object)\n  // TODO 5: Return an object with fields: id, name, createdAt, memberIds\n  // TODO 6: Sanitize room name to prevent injection attacks (remove special chars)\n}\n\n/**\n * Creates a ClientSession object linking a WebSocket to a user\n * @param {WebSocket} socket - The WebSocket connection object\n * @param {string} userId - Authenticated username\n * @param {string} ip - Client IP address\n * @param {string} userAgent - Client User-Agent header\n * @returns {ClientSession} A new ClientSession object\n */\nfunction createClientSession(socket, userId, ip, userAgent) {\n  // TODO 1: Validate that socket is a valid WebSocket object\n  // TODO 2: Validate that userId is a non-empty string\n  // TODO 3: Generate a unique connectionId (consider using crypto.randomUUID())\n  // TODO 4: Return an object with fields: connectionId, socket, userId, ip, userAgent\n  // TODO 5: Store the IP and UserAgent as provided (no need to validate format)\n}\n\nmodule.exports = {\n  EVENT_CHAT_MESSAGE,\n  EVENT_USER_JOINED,\n  EVENT_USER_TYPING,\n  createChatMessage,\n  createRoom,\n  createClientSession\n};\n```\n\n#### E. Language-Specific Hints\n\n1. **Use `Map` for Connection Tracking:** When storing `ClientSession` objects by `connectionId`, use a `Map` instead of a plain object for better performance with frequent additions/deletions and built-in iteration methods.\n\n2. **Validate Early and Often:** Always validate incoming WebSocket messages immediately after parsing. Don't trust client data. Use the validation utilities provided above.\n\n3. **ISO Timestamps for Consistency:** Always use `new Date().toISOString()` for timestamps in wire format. This ensures UTC timezone and consistent format across all clients.\n\n4. **Trim User Input:** Always call `.trim()` on string fields from clients (usernames, room names, message content) to remove accidental leading/trailing whitespace.\n\n5. **Use Sets for Membership:** When tracking room members, use JavaScript's `Set` object for O(1) membership tests and automatic deduplication.\n\n6. **Weak References for Large Data:** Consider using `WeakMap` or `WeakSet` if you need to associate metadata with WebSocket objects without preventing garbage collection, though for this learning project, a regular `Map` is fine.\n\n#### F. Milestone Checkpoint\n\nAfter implementing the data model and protocol:\n\n1. **Start your server** and open the browser console on your client page.\n\n2. **Manually test the WebSocket connection** by creating a raw WebSocket message in the console:\n   ```javascript\n   // Assuming your WebSocket is stored in a variable named `ws`\n   const testMessage = {\n     type: 'chat_message',\n     payload: {\n       sender: 'testuser',\n       content: 'Hello world!',\n       roomId: 'general'\n     }\n   };\n   ws.send(JSON.stringify(testMessage));\n   ```\n\n3. **Expected behavior:**\n   - Server should log the parsed message with type and payload\n   - Server should validate the message structure\n   - Server should reject malformed JSON with an error response\n   - Server should reject messages missing required fields\n\n4. **Signs something is wrong:**\n   - **Server crashes on message:** Check your JSON parsing error handling\n   - **Message ignored silently:** Verify you're calling your message handlers\n   - **Validation not working:** Test with intentionally bad data to ensure validation catches it\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Messages appear with wrong timestamp\" | Client is sending timestamps and server is using them instead of assigning its own | Check server logs to see if incoming messages have timestamp fields | Always overwrite timestamp with server time in `createChatMessage` |\n| \"Duplicate users in room member list\" | Using array instead of Set for `memberIds`, or not checking if user already exists before adding | Log room members before/after join operations | Use `Set` for `memberIds` and check `Set.has()` before adding |\n| \"Server crashes when receiving malformed JSON\" | No try-catch around `JSON.parse()` | Send a non-JSON string like \"invalid\" to the WebSocket | Wrap `JSON.parse()` in try-catch and send error response |\n| \"Event types are case-sensitive mismatches\" | Using different casing for constants in client vs server (e.g., 'chat_message' vs 'CHAT_MESSAGE') | Compare the `type` field values in server logs with your constant definitions | Use exactly the same string constants in both client and server code |\n| \"Very long messages crash the server\" | Not validating message length before processing | Send a 10,000 character message | Add length check in `validateChatMessagePayload` against `MAX_MESSAGE_LENGTH` |\n\n\n## Component Design: WebSocket Server & Connection Manager\n\n> **Milestone(s):** Milestone 1 (WebSocket Server Setup). This component forms the foundational communication layer of the entire system, responsible for establishing and maintaining persistent connections with all clients.\n\n### Responsibility and Scope\n\nThe **WebSocket Server & Connection Manager** is the gateway and traffic controller for all real-time communication in the chat application. It sits at the network boundary and has three core responsibilities:\n\n1. **Protocol Handling**: Manages the low-level WebSocket protocol, including accepting HTTP upgrade requests, establishing persistent connections, and handling the raw binary/text frames defined by RFC 6455.\n2. **Connection State Management**: Maintains a real-time inventory of all active client connections, tracking their lifecycle from establishment through normal operation to termination (whether graceful or abrupt).\n3. **Message Routing Foundation**: Acts as the initial entry point for all incoming real-time traffic, performing basic validation and routing messages to the appropriate higher-level business logic components (like the Room Manager).\n\nThis component **owns** the following:\n- The raw WebSocket connection objects for each client\n- The mapping between connection identifiers and their underlying sockets\n- Basic connection metadata (IP address, user agent, connection timestamp)\n- The heartbeat/ping-pong mechanism for detecting dead connections\n\nThis component **does NOT own**:\n- User authentication state (delegated to Auth Service)\n- Room membership information (delegated to Room Manager)\n- Message persistence (delegated to Persistence Service)\n- Business logic for chat operations (delegated to appropriate handlers)\n\nThe scope is deliberately narrow: think of this component as the telephone company's switching hardware—it ensures calls can be connected and stay connected, but doesn't understand the content of the conversations or who should be talking to whom.\n\n### Mental Model: The Telephone Switchboard Operator\n\nImagine a bustling hotel in the 1950s. Guests (clients) arrive and want to make phone calls to other guests' rooms. The **switchboard operator** (our WebSocket Server) has a physical panel with:\n- **Jacks (sockets)**: One for each guest room that wants phone service\n- **Cords (connections)**: Physical wires connecting callers\n- **Indicator lights (heartbeats)**: Showing which lines are still active\n\nWhen a new guest checks in (client connects), the operator plugs a jack into their room's socket. When the guest picks up the phone and says \"Connect me to Room 237\" (client sends a `join` message), the operator doesn't just blindly connect wires—they check if Room 237 exists (room validation), verify the guest is allowed to call there (authentication), then physically connect the cords (routing).\n\nThe operator maintains a **switchboard directory** (connection map) showing which jack corresponds to which room. If a light goes out (connection drops), the operator immediately removes that jack from the board and notifies anyone who might be trying to call that room (cleanup and notification).\n\nThis mental model captures several key concepts:\n- **Persistent connections** = physical jacks plugged in\n- **Message routing** = operator connecting the right cords\n- **Connection tracking** = the switchboard directory\n- **Heartbeat detection** = indicator lights showing line activity\n- **Graceful degradation** = operator can still work if some lights fail\n\n> **Design Insight**: The WebSocket Server is infrastructure, not business logic. Its job is to move bytes reliably, not understand what those bytes mean. This separation allows the business logic (rooms, messages, users) to evolve independently of the communication layer.\n\n### Interface and Connection Lifecycle\n\nEvery WebSocket connection follows a predictable lifecycle with distinct states and events. The server must handle each transition appropriately.\n\n#### Connection State Machine\n\nThe following table describes the complete state machine for a client connection. Reference the state diagram: ![WebSocket Connection State Machine](./diagrams/conn-state-machine.svg)\n\n| Current State | Event Trigger | Next State | Actions Taken |\n|---------------|---------------|------------|---------------|\n| *None* | HTTP Upgrade request received | `Connecting` | 1. Validate HTTP headers 2. Check authentication token (if required) 3. Generate unique `connectionId` 4. Send 101 Switching Protocols response |\n| `Connecting` | WebSocket handshake completes successfully | `Connected` | 1. Create `ClientSession` object 2. Add to connection tracking map 3. Start heartbeat timer (ping/pong) 4. Log connection event 5. Send `connection_established` event to client |\n| `Connected` | Client sends valid `join_room` message | `Joined` | 1. Validate room exists/user can join 2. Register with Room Manager 3. Update session with `roomId` 4. Send `room_joined` confirmation with history |\n| `Joined` | Client sends `leave_room` message | `Connected` | 1. Unregister from Room Manager 2. Clear session `roomId` 3. Send `room_left` confirmation |\n| `Connected` or `Joined` | Client sends `chat_message` | *Same state* | 1. Parse and validate message 2. Forward to Room Manager for broadcasting 3. Acknowledge receipt to sender |\n| `Connected` or `Joined` | Ping timeout (no pong received) | `Disconnected` | 1. Mark connection as dead 2. Clean up from all tracking structures 3. Notify Room Manager of user departure |\n| `Connected` or `Joined` | Socket `close` event received | `Disconnected` | 1. Remove from connection map 2. Clear heartbeat timer 3. Notify Room Manager (if joined) |\n| `Connected` or `Joined` | Socket `error` event | `Disconnected` | 1. Log error details 2. Force socket closure 3. Perform same cleanup as `close` event |\n| `Disconnected` | Cleanup completed | *None* | Memory released, no further actions |\n\n#### Core Interface Methods\n\nThe Connection Manager exposes the following public API to other components:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `startServer` | `port: number`, `options: Object` | `Promise<void>` | Binds to specified port, starts listening for HTTP/WebSocket connections |\n| `handleUpgrade` | `request: HTTPRequest`, `socket: NetSocket`, `head: Buffer` | `void` | Processes HTTP upgrade request, validates, establishes WebSocket connection |\n| `handleMessage` | `socket: WebSocket`, `rawMessage: string | Buffer` | `void` | Entry point for all incoming messages: parses, validates, routes to appropriate handler |\n| `sendToClient` | `connectionId: string`, `message: WebSocketMessage` | `boolean` | Sends formatted message to specific client if socket is open; returns success/failure |\n| `broadcastToAll` | `message: WebSocketMessage`, `excludeConnectionId?: string` | `void` | Sends message to all connected clients (rarely used directly) |\n| `getActiveConnections` | - | `Map<string, ClientSession>` | Returns copy of current connection map for monitoring/debugging |\n| `closeConnection` | `connectionId: string`, `code: number`, `reason: string` | `boolean` | Gracefully closes specified connection with WebSocket close frame |\n| `getConnectionStats` | - | `{ total: number, byState: Object }` | Returns statistics about current connections |\n\n#### Event Handlers (Internal Interface)\n\nThe component reacts to these WebSocket-native events:\n\n| Event | Handler Method | Typical Actions |\n|-------|----------------|-----------------|\n| `connection` | `onConnection(socket, request)` | Create `ClientSession`, start heartbeat, log connection |\n| `message` | `onMessage(socket, data)` | Call `handleMessage()`, validate, route to business logic |\n| `close` | `onClose(socket, code, reason)` | Clean up connection state, notify Room Manager, log disconnection |\n| `error` | `onError(socket, error)` | Log error, force closure, clean up (treat as disconnect) |\n| `pong` | `onPong(socket, data)` | Update last activity timestamp, mark connection as alive |\n\n### ADR: Managing Active Connections\n\n> **Decision: Use Map<string, ClientSession> for Connection Tracking**\n> - **Context**: The server needs to maintain real-time awareness of all connected clients to route messages efficiently and perform cleanup. Each connection must be uniquely identifiable and quickly accessible.\n> - **Options Considered**:\n>   1. **Set of WebSocket objects**: Simple collection of raw socket objects\n>   2. **Array of connection objects**: Sequential storage with manual ID management\n>   3. **Map<string, ClientSession>**: Key-value store with connection ID as key\n> - **Decision**: Use `Map<string, ClientSession>` where key is a unique `connectionId` and value is a `ClientSession` object containing the socket and metadata.\n> - **Rationale**: \n>   - **Direct Access**: `Map.get(connectionId)` is O(1) for targeted message sending\n>   - **Built-in Iteration**: `Map.forEach()` efficiently broadcasts to all connections\n>   - **Automatic Cleanup**: Deleting entries is explicit and clear (`Map.delete()`)\n>   - **Metadata Association**: `ClientSession` struct can hold user ID, IP, room ID, etc., alongside the raw socket\n>   - **Memory Safety**: Unlike Sets with object references, string keys prevent memory leaks from object resurrection\n> - **Consequences**:\n>   - Adds slight memory overhead for the `ClientSession` wrapper\n>   - Requires generating and managing unique connection IDs\n>   - Provides excellent foundation for future features like direct messaging and connection monitoring\n\nThe following comparison table illustrates the trade-offs:\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| **Set of WebSocket objects** | Simple, no ID management, native WebSocket API | No metadata storage, O(n) lookup for specific connections, harder to debug | Insufficient for routing needs; can't associate user ID with socket |\n| **Array of connection objects** | Maintains order, simple iteration | O(n) lookup, manual ID management, inefficient removals | Performance degrades with hundreds of connections |\n| **Map<string, ClientSession>** | O(1) lookup, clean metadata association, easy iteration | Requires ID generation, wrapper object overhead | **CHOSEN**: Best balance of performance, functionality, and clarity |\n\n### Common Pitfalls: Memory Leaks and Silent Failures\n\nBuilding a WebSocket server involves several subtle traps that can cause gradual degradation or sudden failure. Here are the most common pitfalls and how to avoid them:\n\n#### ⚠️ **Pitfall 1: Zombie Connections - Not Cleaning Up on Disconnect**\n**The Mistake**: Only removing connections on explicit `close` events, ignoring error conditions, timeouts, or network interruptions that don't trigger proper close frames.\n**Why It's Wrong**: Dead connections accumulate in the tracking map, causing memory leaks. The server continues trying to send messages to dead sockets, wasting CPU and potentially crashing when buffers fill.\n**How to Fix**: Implement a **defense-in-depth cleanup strategy**:\n1. Always remove from tracking in BOTH `close` and `error` handlers\n2. Implement heartbeat (ping/pong) with timeout detection\n3. Add periodic sanity checks that iterate through connections and verify socket state\n4. Use weak references or finalizers if available (though JavaScript lacks these)\n\n#### ⚠️ **Pitfall 2: The Silent Swallow - Missing Error Handlers**\n**The Mistake**: Not attaching error handlers to WebSocket objects, assuming connections will always close gracefully.\n```javascript\n// BAD: Socket errors become unhandled exceptions\nsocket.on('message', (data) => { /* process */ });\n\n// GOOD: Explicit error handling\nsocket.on('error', (err) => {\n  console.error(`Socket error for ${connectionId}:`, err);\n  this.closeConnection(connectionId, 1011, 'Internal error');\n});\n```\n**Why It's Wrong**: Unhandled socket errors can crash the entire Node.js process. Even if they don't crash, failures become invisible, making debugging nearly impossible.\n**How to Fix**: Attach error handlers to EVERY socket, EVERY EventEmitter, and wrap ALL asynchronous operations in try/catch. Log errors with context (connectionId, user ID) for debugging.\n\n#### ⚠️ **Pitfall 3: The Forgotten Heartbeat - No Liveness Detection**\n**The Mistake**: Assuming connections remain alive because the TCP socket is open, ignoring \"half-open\" connections where the client disappeared without closing.\n**Why It's Wrong**: Network issues, client crashes, or NAT timeouts can leave sockets in a \"zombie\" state—technically open but unable to send/receive data. The server thinks users are online when they're not.\n**How to Fix**: Implement **RFC 6455 ping/pong frames**:\n1. Periodically send ping frames to each connection (every 30-60 seconds)\n2. Set a timer expecting a pong response within 10-15 seconds\n3. Close connections that miss too many pongs (typically 2-3 consecutive failures)\n4. Update `lastActive` timestamp on any received message (including pong)\n\n#### ⚠️ **Pitfall 4: Ready State Race Condition - Sending to Closing Sockets**\n**The Mistake**: Not checking `socket.readyState` before sending, causing \"Cannot send after socket closed\" errors.\n**Why It's Wrong**: Between checking if a connection exists and actually sending, the socket could close (especially under load). This throws unhandled exceptions.\n**How to Fix**: Always verify ready state AND catch send errors:\n```javascript\nsendToClient(connectionId, message) {\n  const session = this.connections.get(connectionId);\n  if (!session) return false;\n  \n  // Check state before sending\n  if (session.socket.readyState !== WebSocket.OPEN) {\n    this.cleanupConnection(connectionId);\n    return false;\n  }\n  \n  try {\n    session.socket.send(JSON.stringify(message));\n    return true;\n  } catch (err) {\n    // Socket closed between check and send\n    this.cleanupConnection(connectionId);\n    return false;\n  }\n}\n```\n\n#### ⚠️ **Pitfall 5: Unbounded Message Queue - No Backpressure Handling**\n**The Mistake**: Accepting and queuing unlimited messages from clients without considering server capacity.\n**Why It's Wrong**: A malicious or buggy client could flood the server with messages, consuming memory and CPU, eventually causing out-of-memory crashes.\n**How to Fix**: Implement **per-connection backpressure**:\n1. Track number of unprocessed messages per connection\n2. Pause socket reception when backlog exceeds threshold (using `socket.pause()`)\n3. Resume when backlog clears\n4. Implement maximum message size validation (enforce `MAX_MESSAGE_LENGTH`)\n5. Close connections that consistently exceed limits\n\n#### ⚠️ **Pitfall 6: The Shared Mutability Trap - Concurrent Modification**\n**The Mistake**: Iterating over the connections Map while other code modifies it (adding/removing connections).\n**Why It's Wrong**: In Node.js's single-threaded event loop, this seems safe, but asynchronous callbacks can interleave, causing modification during iteration errors or skipped connections.\n**How to Fix**: Use defensive copying or proper locking:\n```javascript\n// SAFE: Create copy before iterating\nbroadcastToAll(message, excludeConnectionId) {\n  const connectionsCopy = new Map(this.connections);\n  connectionsCopy.forEach((session, connectionId) => {\n    if (connectionId !== excludeConnectionId) {\n      this.sendToClient(connectionId, message);\n    }\n  });\n}\n```\n\n### Implementation Guidance (Layer 2)\n\nThis section provides concrete implementation guidance for building the WebSocket Server & Connection Manager in JavaScript/Node.js, focusing on the `ws` library (the most popular WebSocket implementation for Node.js).\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Learning) | Production-Ready Option |\n|-----------|--------------------------|-------------------------|\n| **WebSocket Library** | `ws` (minimal, RFC-compliant) | `ws` with extensions (`permessage-deflate` for compression) |\n| **HTTP Server** | Node.js built-in `http` or `https` | Express.js + `express-ws` for API co-existence |\n| **Connection Tracking** | In-memory `Map<string, ClientSession>` | Redis for distributed tracking (multi-server) |\n| **Heartbeat Mechanism** | Manual ping/pong with `setInterval` | `ws` built-in ping/pong with configurable interval |\n| **Logging** | `console.log` with timestamps | Structured logging (Winston, Pino) with connection context |\n\n#### B. Recommended File/Module Structure\n\n```\nreal-time-chat/\n├── package.json\n├── tsconfig.json (if using TypeScript)\n├── src/\n│   ├── server.ts (or server.js)          # Main entry point\n│   ├── core/\n│   │   ├── ConnectionManager.ts          # THIS COMPONENT (primary file)\n│   │   ├── types.ts                      # Shared type definitions\n│   │   └── constants.ts                  `EVENT_*`, `MAX_MESSAGE_LENGTH`, etc.\n│   ├── services/\n│   │   ├── RoomManager.ts                # Milestone 2-3 component\n│   │   └── AuthService.ts                # Milestone 4 component\n│   ├── persistence/\n│   │   └── MessageStore.ts               # Milestone 4 persistence\n│   └── client/\n│       └── index.html                    # Basic web client\n└── tests/\n    └── ConnectionManager.test.ts\n```\n\n#### C. Infrastructure Starter Code\n\n**Complete WebSocket Server Setup with HTTP Upgrade Handling**\n\n```javascript\n// File: src/server.js\nconst http = require('http');\nconst WebSocket = require('ws');\nconst { ConnectionManager } = require('./core/ConnectionManager');\nconst { parseAndValidateWebSocketMessage } = require('./core/messageUtils');\n\n// Create HTTP server (could be Express in more advanced setups)\nconst server = http.createServer((req, res) => {\n  // Handle regular HTTP requests (health checks, static files, API)\n  if (req.url === '/health') {\n    res.writeHead(200, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({ status: 'ok', connections: connectionManager.getConnectionStats() }));\n    return;\n  }\n  \n  // Default 404 for other HTTP requests\n  res.writeHead(404);\n  res.end();\n});\n\n// Create WebSocket server attached to HTTP server\nconst wss = new WebSocket.Server({ \n  server,\n  clientTracking: false, // We'll handle tracking ourselves\n  maxPayload: 1024 * 1024, // 1MB max message size\n});\n\n// Initialize connection manager\nconst connectionManager = new ConnectionManager();\n\n// Handle WebSocket connections\nwss.on('connection', (socket, request) => {\n  // Extract connection info from request\n  const ip = request.headers['x-forwarded-for'] || request.socket.remoteAddress;\n  const userAgent = request.headers['user-agent'] || 'unknown';\n  \n  // Generate unique connection ID\n  const connectionId = generateConnectionId();\n  \n  // Create client session (user ID will be added after authentication in Milestone 4)\n  const session = {\n    connectionId,\n    socket,\n    userId: null, // Will be set after auth\n    ip,\n    userAgent,\n    joinedAt: new Date().toISOString(),\n    lastActivity: Date.now(),\n    roomId: null, // Current room, if any\n  };\n  \n  // Add to connection tracking\n  connectionManager.addConnection(connectionId, session);\n  \n  console.log(`[${new Date().toISOString()}] Connection established: ${connectionId} from ${ip}`);\n  \n  // Send welcome message\n  socket.send(JSON.stringify({\n    type: 'connection_established',\n    payload: { connectionId, serverTime: new Date().toISOString() },\n  }));\n  \n  // Set up message handler\n  socket.on('message', (rawData) => {\n    try {\n      // Update activity timestamp\n      session.lastActivity = Date.now();\n      \n      // Parse and validate message\n      const message = parseAndValidateWebSocketMessage(rawData.toString());\n      \n      // Route to appropriate handler\n      connectionManager.handleMessage(connectionId, message);\n    } catch (error) {\n      console.error(`Error processing message from ${connectionId}:`, error);\n      \n      // Send error back to client\n      socket.send(JSON.stringify({\n        type: 'error',\n        payload: { message: 'Invalid message format', details: error.message },\n      }));\n    }\n  });\n  \n  // Set up close handler\n  socket.on('close', (code, reason) => {\n    console.log(`[${new Date().toISOString()}] Connection closed: ${connectionId}, code: ${code}, reason: ${reason}`);\n    connectionManager.removeConnection(connectionId);\n  });\n  \n  // Set up error handler\n  socket.on('error', (error) => {\n    console.error(`[${new Date().toISOString()}] Socket error for ${connectionId}:`, error);\n    connectionManager.removeConnection(connectionId);\n    socket.terminate(); // Force close\n  });\n  \n  // Set up pong handler for heartbeat\n  socket.on('pong', () => {\n    session.lastActivity = Date.now();\n  });\n});\n\n// Start heartbeat mechanism\nsetInterval(() => {\n  connectionManager.checkHeartbeats();\n}, 30000); // Check every 30 seconds\n\n// Start server\nconst PORT = process.env.PORT || 8080;\nserver.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}`);\n  console.log(`WebSocket endpoint: ws://localhost:${PORT}`);\n});\n\n// Helper function to generate connection IDs\nfunction generateConnectionId() {\n  return `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n```\n\n**Complete Message Validation Utilities**\n\n```javascript\n// File: src/core/messageUtils.js\nconst constants = require('./constants');\n\n/**\n * Parses and validates raw WebSocket message string\n * @param {string} rawMessage - Raw message from WebSocket\n * @returns {WebSocketMessage} - Parsed and validated message object\n * @throws {Error} - If message is invalid JSON or missing required fields\n */\nfunction parseAndValidateWebSocketMessage(rawMessage) {\n  // Check message length\n  if (rawMessage.length > constants.MAX_MESSAGE_LENGTH) {\n    throw new Error(`Message exceeds maximum length of ${constants.MAX_MESSAGE_LENGTH} characters`);\n  }\n  \n  let parsed;\n  try {\n    parsed = JSON.parse(rawMessage);\n  } catch (error) {\n    throw new Error('Invalid JSON format');\n  }\n  \n  // Validate required fields\n  if (typeof parsed.type !== 'string' || parsed.type.trim() === '') {\n    throw new Error('Message must have a non-empty \"type\" field');\n  }\n  \n  if (parsed.payload === undefined) {\n    throw new Error('Message must have a \"payload\" field');\n  }\n  \n  // Add timestamp if not present\n  if (!parsed.timestamp) {\n    parsed.timestamp = new Date().toISOString();\n  }\n  \n  return {\n    type: parsed.type,\n    payload: parsed.payload,\n    timestamp: parsed.timestamp,\n  };\n}\n\n/**\n * Validates ChatMessage payload structure\n * @param {any} payload - The payload to validate\n * @returns {boolean} - True if valid\n * @throws {Error} - If validation fails\n */\nfunction validateChatMessagePayload(payload) {\n  if (typeof payload !== 'object' || payload === null) {\n    throw new Error('Payload must be an object');\n  }\n  \n  if (typeof payload.content !== 'string' || payload.content.trim() === '') {\n    throw new Error('Message content must be a non-empty string');\n  }\n  \n  if (payload.content.length > constants.MAX_MESSAGE_LENGTH) {\n    throw new Error(`Message content exceeds ${constants.MAX_MESSAGE_LENGTH} characters`);\n  }\n  \n  if (payload.roomId && typeof payload.roomId !== 'string') {\n    throw new Error('roomId must be a string if provided');\n  }\n  \n  if (payload.sender && typeof payload.sender !== 'string') {\n    throw new Error('sender must be a string if provided');\n  }\n  \n  return true;\n}\n\n/**\n * Creates properly formatted WebSocketMessage for server-originated events\n * @param {string} type - Event type (use constants.EVENT_*)\n * @param {any} payload - Message payload\n * @returns {WebSocketMessage} - Formatted message\n */\nfunction createServerMessage(type, payload) {\n  return {\n    type,\n    payload,\n    timestamp: new Date().toISOString(),\n  };\n}\n\nmodule.exports = {\n  parseAndValidateWebSocketMessage,\n  validateChatMessagePayload,\n  createServerMessage,\n};\n```\n\n#### D. Core Logic Skeleton Code\n\n**Connection Manager Class with TODOs**\n\n```javascript\n// File: src/core/ConnectionManager.js\nconst WebSocket = require('ws');\nconst { createServerMessage } = require('./messageUtils');\nconst constants = require('./constants');\n\nclass ConnectionManager {\n  constructor() {\n    // ADR Decision: Using Map for connection tracking\n    this.connections = new Map(); // connectionId -> ClientSession\n    \n    // In a real app, these would be injected dependencies\n    this.roomManager = null; // Will be set after RoomManager is created\n    this.authService = null; // Will be set in Milestone 4\n    \n    // Heartbeat configuration\n    this.heartbeatInterval = 30000; // 30 seconds\n    this.heartbeatTimeout = 10000; // 10 seconds timeout for pong\n  }\n  \n  /**\n   * Adds a new connection to tracking\n   * @param {string} connectionId - Unique connection identifier\n   * @param {ClientSession} session - Session object with socket and metadata\n   */\n  addConnection(connectionId, session) {\n    // TODO 1: Validate parameters (connectionId must be string, session must have socket)\n    // TODO 2: Check if connectionId already exists (log warning if it does)\n    // TODO 3: Add to connections Map\n    // TODO 4: Set up initial heartbeat timer\n    // TODO 5: Log connection addition for debugging\n  }\n  \n  /**\n   * Removes a connection from tracking and cleans up resources\n   * @param {string} connectionId - Connection to remove\n   * @param {number} closeCode - WebSocket close code (optional)\n   * @param {string} closeReason - Human-readable close reason (optional)\n   */\n  removeConnection(connectionId, closeCode, closeReason) {\n    // TODO 1: Look up connection in Map\n    // TODO 2: If connection was in a room, notify RoomManager to remove from room\n    // TODO 3: If socket is still open, send close frame with provided code/reason\n    // TODO 4: Clear any heartbeat timers for this connection\n    // TODO 5: Remove from connections Map\n    // TODO 6: Log removal with connectionId and reason\n  }\n  \n  /**\n   * Main entry point for handling incoming WebSocket messages\n   * Reference flowchart: ./diagrams/flowchart-message-handling.svg\n   * @param {string} connectionId - Which connection sent the message\n   * @param {WebSocketMessage} message - Parsed and validated message\n   */\n  handleMessage(connectionId, message) {\n    // TODO 1: Look up connection in connections Map\n    // TODO 2: Update lastActivity timestamp on the session\n    // TODO 3: Route message based on type:\n    //   - If type is 'join_room': call handleJoinRoom(connectionId, message.payload)\n    //   - If type is 'leave_room': call handleLeaveRoom(connectionId, message.payload)\n    //   - If type is 'chat_message': call handleChatMessage(connectionId, message.payload)\n    //   - If type is 'typing_indicator': call handleTypingIndicator(connectionId, message.payload)\n    //   - If type is 'ping': send 'pong' response immediately\n    //   - Unknown type: send error response back to client\n    // TODO 4: Catch any errors during processing and send appropriate error response\n  }\n  \n  /**\n   * Handles join room request from client\n   * @param {string} connectionId - Connection wanting to join\n   * @param {object} payload - Should contain roomId or roomName\n   */\n  handleJoinRoom(connectionId, payload) {\n    // TODO 1: Get connection from connections Map\n    // TODO 2: Validate payload has roomId or roomName\n    // TODO 3: If user is already in a room, call handleLeaveRoom first\n    // TODO 4: Call roomManager.joinRoom(connectionId, payload.roomId, payload.roomName)\n    // TODO 5: On success, update session.roomId\n    // TODO 6: Send success response to client with room info and message history\n    // TODO 7: On error, send error response to client\n  }\n  \n  /**\n   * Handles chat message from client\n   * @param {string} connectionId - Connection that sent the message\n   * @param {object} payload - Should contain content and optionally roomId\n   */\n  handleChatMessage(connectionId, payload) {\n    // TODO 1: Get connection from connections Map\n    // TODO 2: Validate payload.content is non-empty string and within length limits\n    // TODO 3: If payload.roomId is provided, use it; otherwise use session.roomId\n    // TODO 4: Create ChatMessage object with sender from session.userId\n    // TODO 5: Call roomManager.broadcastToRoom(roomId, chatMessage, excludeConnectionId)\n    // TODO 6: Send acknowledgment back to sender\n    // TODO 7: On error (e.g., not in a room), send error response\n  }\n  \n  /**\n   * Sends a message to a specific client\n   * @param {string} connectionId - Target connection\n   * @param {WebSocketMessage} message - Message to send\n   * @returns {boolean} - True if sent successfully, false if failed\n   */\n  sendToClient(connectionId, message) {\n    // TODO 1: Look up connection in connections Map\n    // TODO 2: If not found, return false\n    // TODO 3: Check socket.readyState === WebSocket.OPEN\n    // TODO 4: If not open, call removeConnection and return false\n    // TODO 5: Try to send message with JSON.stringify\n    // TODO 6: Catch any send errors, call removeConnection, return false\n    // TODO 7: On success, return true\n  }\n  \n  /**\n   * Broadcasts message to all connected clients\n   * @param {WebSocketMessage} message - Message to broadcast\n   * @param {string} excludeConnectionId - Optional connection to exclude (e.g., sender)\n   */\n  broadcastToAll(message, excludeConnectionId) {\n    // TODO 1: Create a copy of connections Map to avoid modification during iteration\n    // TODO 2: For each connection in the copy:\n    //   - If connectionId !== excludeConnectionId, call sendToClient\n    // TODO 3: Log broadcast statistics (how many sent, how many failed)\n  }\n  \n  /**\n   * Checks heartbeats for all connections and removes dead ones\n   */\n  checkHeartbeats() {\n    const now = Date.now();\n    const deadConnections = [];\n    \n    // TODO 1: Iterate through connections Map\n    // TODO 2: For each connection, calculate time since lastActivity\n    // TODO 3: If time > heartbeatInterval + heartbeatTimeout, mark as dead\n    // TODO 4: Send ping to connections that haven't been pinged recently\n    // TODO 5: For dead connections, add to deadConnections array\n    \n    // Clean up dead connections\n    deadConnections.forEach(connectionId => {\n      console.warn(`Connection ${connectionId} heartbeat failed, removing`);\n      this.removeConnection(connectionId, 1001, 'Heartbeat timeout');\n    });\n    \n    // TODO 6: Log heartbeat check results\n  }\n  \n  /**\n   * Gets connection statistics for monitoring\n   * @returns {object} - Statistics about current connections\n   */\n  getConnectionStats() {\n    // TODO 1: Initialize stats object with total count and by-state breakdown\n    // TODO 2: Iterate through connections Map to collect:\n    //   - Total connections\n    //   - Connections with userId set (authenticated)\n    //   - Connections with roomId set (in a room)\n    //   - Connections grouped by userAgent (browser types)\n    // TODO 3: Return statistics object\n  }\n}\n\nmodule.exports = { ConnectionManager };\n```\n\n#### E. Language-Specific Hints (JavaScript/Node.js)\n\n1. **WebSocket Library Choice**: Use `ws` (npm install ws). It's the most battle-tested WebSocket library for Node.js and implements the full RFC 6455 specification.\n\n2. **Connection ID Generation**: Use a combination of timestamp and random string to avoid collisions:\n   ```javascript\n   function generateId() {\n     return `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n   }\n   ```\n\n3. **Handling Large Numbers of Connections**: Node.js can handle thousands of concurrent WebSocket connections, but you need to:\n   - Increase the `ulimit` on Linux/Mac: `ulimit -n 10000`\n   - Use `socket.setTimeout()` to detect stalled connections\n   - Consider using the `cluster` module to utilize multiple CPU cores\n\n4. **Memory Management**: \n   - Regularly check `process.memoryUsage()` in production\n   - Remove all references to sockets when connections close\n   - Consider using `WeakMap` for auxiliary data if you don't need to iterate over it\n\n5. **Error Handling Best Practices**:\n   ```javascript\n   // Always attach error handlers\n   socket.on('error', (error) => {\n     // Don't throw, log and clean up\n     console.error('Socket error:', error);\n     this.cleanupConnection(connectionId);\n   });\n   \n   // Handle async errors in message processing\n   try {\n     await someAsyncOperation();\n   } catch (error) {\n     // Send error to client instead of crashing\n     socket.send(JSON.stringify({ type: 'error', payload: { message: error.message } }));\n   }\n   ```\n\n6. **Testing WebSocket Servers**: Use `ws` client in tests:\n   ```javascript\n   const WebSocket = require('ws');\n   \n   test('server accepts connections', async () => {\n     const ws = new WebSocket('ws://localhost:8080');\n     \n     await new Promise((resolve) => {\n       ws.on('open', resolve);\n     });\n     \n     expect(ws.readyState).toBe(WebSocket.OPEN);\n     ws.close();\n   });\n   ```\n\n#### F. Milestone Checkpoint: WebSocket Server Setup\n\nAfter implementing the Connection Manager:\n\n**Expected Behavior**:\n1. Start the server: `node src/server.js`\n2. Open browser console at `http://localhost:8080` (you'll need a basic HTML file)\n3. Connect via WebSocket: `new WebSocket('ws://localhost:8080')`\n4. See connection established message in browser console\n5. See connection log in server terminal\n\n**Verification Steps**:\n1. **Multiple Connections**: Open multiple browser tabs, verify each gets unique connection ID\n2. **Heartbeat Detection**: Wait 45+ seconds without sending messages, verify connections stay alive (pings sent)\n3. **Clean Disconnect**: Close a browser tab, verify server logs the disconnect and removes from tracking\n4. **Error Handling**: Send malformed JSON message, verify server sends error response instead of crashing\n5. **Memory Check**: Connect/disconnect 10+ times rapidly, verify connection count returns to zero\n\n**Signs of Problems**:\n- **\"Too many open files\" error**: Need to increase system ulimit\n- **Memory keeps growing**: Connections aren't being cleaned up properly\n- **Server crashes on message send**: Missing `readyState` check or error handler\n- **\"Cannot send after socket closed\"**: Race condition between check and send\n\n**Debugging Commands**:\n```bash\n# Check active connections\ncurl http://localhost:8080/health\n\n# Monitor memory usage\nnode -e \"setInterval(() => console.log(process.memoryUsage()), 5000)\" &\n\n# Test WebSocket connection manually (install wscat)\nnpm install -g wscat\nwscat -c ws://localhost:8080\n```\n\n---\n\n\n## Component Design: Message Broker & Room Manager\n\n> **Milestone(s):** Milestone 2 (Message Broadcasting), Milestone 3 (Chat Rooms)\n\nThis component is the heart of the chat application's business logic. While the WebSocket Server & Connection Manager handles the low-level plumbing of persistent connections, the Message Broker & Room Manager orchestrates the meaningful interactions within those connections: who can talk to whom, where messages should go, and who is currently active. It transforms raw WebSocket connections into a structured chat system with rooms, presence, and targeted message delivery.\n\n### Responsibility and Scope\n\nThe **Message Broker & Room Manager** (hereafter \"Room Manager\") is a stateful server-side component that sits atop the connection layer. Its core responsibilities are:\n\n1.  **Room Management:** Creating, tracking, and destroying logical chat rooms (`Room` objects). A room is a named channel where messages are broadcast to all members.\n2.  **Membership Management:** Maintaining, for each room, the set of active users (represented by their `connectionId`s). It adds users when they join and removes them when they leave or disconnect.\n3.  **Message Routing:** Receiving incoming `ChatMessage` events and delivering them to all current members of the relevant room, excluding the original sender (unless specified otherwise). This is the \"broadcast\" pattern.\n4.  **Presence Tracking:** Maintaining and broadcasting real-time status information about users. This includes:\n    *   **Online/Offline:** Tracking which users are connected to the server.\n    *   **Room Membership:** Knowing which users are in which rooms.\n    *   **Typing Indicators:** Temporarily tracking and broadcasting when a user is actively composing a message in a specific room.\n5.  **State Querying:** Providing answers to questions like \"What rooms exist?\", \"How many users are in room 'general'?\", and \"What are the last 20 messages in room 'lobby'?\" (the latter via the Persistence layer).\n\nIts scope ends at the boundary of the `ClientSession` and the `WebSocket`. It does not handle the raw WebSocket protocol, HTTP upgrades, or individual socket events. Instead, it operates on logical constructs (`connectionId`, `roomId`, `userId`) provided by the Connection Manager. It also defers permanent storage of messages and user credentials to the Persistence & Authentication Service, with which it collaborates.\n\n### Mental Model: The Publishing House and Subscribers\n\nA helpful analogy for understanding this component is a **Publishing House (or Magazine)** and its **Subscribers**.\n\n*   **Each Chat Room is a distinct Magazine** (e.g., \"Tech News\", \"Sports Talk\"). The magazine has a title (`roomId`) and a list of current subscribers.\n*   **Users are Subscribers.** When a user joins a room, they subscribe to that magazine. They will receive every new issue (message) published to it.\n*   **Sending a Message is Publishing an Issue.** When a user sends a chat message to a room, they are publishing a new article to that magazine. The publishing house (Room Manager) immediately prints and mails a copy to every current subscriber of that magazine.\n*   **Typing Indicators are \"Writer at Work\" Signs.** If a subscriber starts drafting a letter to the editor (typing a message), the publishing house can put up a small sign in the magazine's office window: \"John is writing...\". This sign is visible to all other subscribers of that magazine.\n*   **The Connection Manager is the Postal Service.** It doesn't care about the content of the magazines; its job is to reliably deliver envelopes (WebSocket frames) between the publishing house and the individual subscribers' mailboxes (client browsers).\n\nThis model clarifies the decoupling: the Room Manager decides *what* to send and *to whom*, while the Connection Manager handles the *how* of the actual delivery.\n\n### Interface: Core Methods and Events\n\nThe Room Manager exposes a programmatic interface used primarily by the Connection Manager's message handlers. The following table details its key methods.\n\n| Method | Parameters | Returns | Description & Side Effects |\n| :--- | :--- | :--- | :--- |\n| `joinRoom` | `connectionId: string`, `roomId: string`, `userId: string` | `Promise<Room>` | Adds the user's `connectionId` to the room's `memberIds` set. Fetches recent message history from persistence. Broadcasts an `EVENT_USER_JOINED` message to all other members of the room. Returns the updated `Room` object. |\n| `leaveRoom` | `connectionId: string`, `roomId: string` | `void` | Removes the `connectionId` from the room's `memberIds` set. If the room becomes empty, it may be scheduled for cleanup (see ADR). Broadcasts an `EVENT_USER_LEFT` message to the remaining members. |\n| `leaveAllRooms` | `connectionId: string` | `void` | Removes the given `connectionId` from every room's membership. Typically called during connection cleanup (user disconnect). |\n| `broadcastToRoom` | `roomId: string`, `message: WebSocketMessage`, `excludeConnectionId?: string` | `void` | Retrieves the set of `memberIds` for the given `roomId`. Iterates through each `connectionId`, and for each one that is not the `excludeConnectionId`, calls `ConnectionManager.sendToClient(connectionId, message)`. |\n| `getRoomList` | - | `Array<{id: string, name: string, memberCount: number}>` | Returns a snapshot of all active rooms and their current member counts. Used for room listing UI. |\n| `setUserTyping` | `connectionId: string`, `roomId: string`, `isTyping: boolean` | `void` | Updates an internal map tracking which users are typing in which rooms. Broadcasts an `EVENT_USER_TYPING` message to all other members of the room with the user's status. Manages a timeout to automatically clear the typing state after inactivity (e.g., 3 seconds). |\n| `getRoomMembers` | `roomId: string` | `Set<string>` (connectionIds) | Returns the current set of `connectionId`s for a given room. Used for targeted operations and presence updates. |\n\n**Key Internal Events:** The Room Manager also listens for events from the Connection Manager, primarily `connectionClosed(connectionId)`. Upon receiving this, it must call `leaveAllRooms(connectionId)` to ensure state consistency.\n\n### ADR: In-Memory vs. External Room State\n\n> **Decision: Store Room and Membership State In-Memory**\n>\n> - **Context:** The Room Manager needs fast, low-latency access to room membership data to route messages and track presence. This data is highly volatile (changes with every join/leave) and is only relevant to the currently running server instance. We must choose where to store this operational state.\n> - **Options Considered:**\n>     1.  **In-Memory Data Structures:** Store `Room` objects (with `memberIds` sets) in a plain JavaScript `Map` within the Room Manager's process memory.\n>     2.  **External Shared Database:** Store room membership in a fast, external data store like Redis (key: `room:<id>:members`, value: set of `userId` or `connectionId`).\n> - **Decision:** Use **In-Memory Data Structures** for the learning implementation.\n> - **Rationale:** This project has **intermediate** difficulty and focuses on learning WebSocket patterns, not distributed systems. Using in-memory structures drastically simplifies the code, eliminates network latency for membership checks, and requires no additional infrastructure (Redis). The primary con—lack of shared state across multiple servers—is acceptable because the non-goals explicitly exclude horizontal scaling for this version. It allows learners to focus on the core algorithms of room management without the complexity of distributed state synchronization.\n> - **Consequences:**\n>     - **Positive:** Maximum performance for read/write operations, simple implementation, no external dependencies.\n>     - **Negative:** State is lost on server restart. All rooms and membership information vanish. This is acceptable for a learning project, as clients will reconnect and re-join rooms. It also means the system cannot run in a multi-server (load-balanced) configuration without a major redesign.\n\n| Option | Pros | Cons | Chosen? |\n| :--- | :--- | :--- | :--- |\n| **In-Memory** | 1. **Extremely low latency** (no network calls).<br>2. **Simple implementation** (native `Map` and `Set`).<br>3. **No external dependencies** to set up or manage. | 1. **State is ephemeral** (lost on server crash/restart).<br>2. **Does not scale** beyond a single server process.<br>3. Harder to inspect/debug state externally. | **Yes** – Aligns with project's learning focus and non-goals. |\n| **External DB (e.g., Redis)** | 1. **State survives server restarts.**<br>2. **Enables horizontal scaling** (multiple chat servers can share state).<br>3. State can be inspected with external tools. | 1. **Adds complexity** (requires Redis setup, connection pooling, serialization).<br>2. **Introduces network latency** for every membership operation.<br>3. **New failure modes** (Redis downtime, network partitions). | No – Overcomplicates the core learning objectives. |\n\n### Common Pitfalls\n\nThis component has several subtle traps that can lead to confusing bugs.\n\n⚠️ **Pitfall 1: Accidental Broadcast to Sender (Echo)**\n*   **Description:** When `broadcastToRoom` is called without providing the `excludeConnectionId` parameter, the user who sent the message receives their own message back via the WebSocket. This creates a confusing \"echo\" in their own client and often leads to duplicate message display.\n*   **Why it's wrong:** It wastes bandwidth and processing, and violates the typical user expectation in a chat app (you see your own message in the UI because your client rendered it optimistically on send, not because the server echoed it back).\n*   **Fix:** **Always pass the sender's `connectionId` as the `excludeConnectionId` argument** when broadcasting a message they originated. The `broadcastToRoom` method must explicitly skip this connection.\n\n⚠️ **Pitfall 2: Zombie Rooms (Memory Leak)**\n*   **Description:** When the last user leaves a room, the `Room` object and its `memberIds` Set remain in the server's memory indefinitely. If users dynamically create many rooms (e.g., `project-abc`, `temp-meeting`), the server's memory will slowly fill with empty, unused rooms.\n*   **Why it's wrong:** It causes a memory leak, which can eventually crash the server under sustained use.\n*   **Fix:** Implement a cleanup mechanism. The `leaveRoom` method should check if the room's `memberIds` set is empty after removal. If it is, start a **configurable timeout** (e.g., 5 minutes). If no one joins the room before the timeout elapses, delete the `Room` object from the in-memory map. This allows for temporary empty rooms without permanent accumulation.\n\n⚠️ **Pitfall 3: Unsanitized Room Names**\n*   **Description:** Accepting arbitrary user input (the desired room name) as a room identifier without validation can lead to security and stability issues. A user could create a room named `../../../etc/passwd` or `</script><script>alert('xss')</script>`.\n*   **Why it's wrong:** If the room name is used in file paths, database queries, or reflected in client HTML, it could enable path traversal, injection attacks, or cross-site scripting (XSS).\n*   **Fix:** **Sanitize and normalize room names.** Convert to a safe internal `roomId`. For example:\n    1.  Trim whitespace.\n    2.  Convert to lowercase.\n    3.  Replace any non-alphanumeric characters (except hyphens/underscores) with a hyphen.\n    4.  Enforce a reasonable length limit (e.g., 50 characters).\n    5.  Use this normalized string as the internal `roomId`. The original `name` can be stored for display but never used for logic.\n\n⚠️ **Pitfall 4: Race Condition in Typing Indicators**\n*   **Description:** When a user stops typing, the client sends a `typing: false` event. If the user quickly starts typing again, the server might process the events out of order (due to network latency) resulting in the final state being `false` even though the user is actively typing.\n*   **Why it's wrong:** The typing indicator for that user disappears prematurely, confusing other chat participants.\n*   **Fix:** Use a **last-write-wins approach with a sequence number or timestamp.** Attach a monotonic increasing number or the client's timestamp to each typing event. The server only updates the typing state if the incoming event's number is greater than the one currently stored for that user/room. Alternatively, use a **debounce pattern on the server:** each `typing: true` event resets a user-specific timeout. The `typing: false` broadcast is only sent when that timeout fires without being reset.\n\n⚠️ **Pitfall 5: Not Validating Membership Before Broadcast**\n*   **Description:** The `broadcastToRoom` method blindly retrieves a list of `connectionId`s and attempts to send to each. If a user has just disconnected, their `connectionId` may still be in the set, causing `ConnectionManager.sendToClient` to fail or log an error.\n*   **Why it's wrong:** It creates unnecessary error noise and wasted cycles. The room membership state (`memberIds`) becomes slightly stale.\n*   **Fix:** **The Connection Manager must be the source of truth for active connections.** When `leaveAllRooms` is called (during disconnect cleanup), it removes the `connectionId` from all room sets. This ensures the membership set is accurate before the next broadcast cycle. The `broadcastToRoom` method can then iterate with confidence. Implement this as a synchronous call from the Connection Manager's `connectionClosed` handler to the Room Manager's `leaveAllRooms`.\n\n### Implementation Guidance\n\nThis guidance provides the skeletal structure for the Room Manager component in JavaScript (Node.js), following the design outlined above.\n\n#### A. Technology Recommendations\n| Component | Simple Option (Learning) | Advanced Option (Production) |\n| :--- | :--- | :--- |\n| **In-Memory Store** | JavaScript `Map` and `Set` | Redis with Pub/Sub for distributed state & messaging |\n| **Message Routing** | Iterative loop over connection IDs | Topic-based Pub/Sub (Redis, NATS, Kafka) |\n| **Presence Tracking** | In-memory maps with timeouts | Redis Sorted Sets with heartbeats |\n\n#### B. Recommended File/Module Structure\n```\nreal-time-chat/\n├── server/\n│   ├── index.js                      # Main server entry point\n│   ├── connectionManager.js          # From Milestone 1\n│   ├── roomManager.js                # This component (NEW)\n│   ├── authService.js                # For Milestone 4\n│   ├── messageStore.js               # For Milestone 4\n│   └── utils/\n│       ├── validation.js             # parseAndValidateWebSocketMessage, etc.\n│       └── messageFactory.js         # createServerMessage, createChatMessage\n└── client/                           # Frontend HTML/CSS/JS\n```\n\n#### C. Infrastructure Starter Code\nThe following is a complete, usable utility for creating standardized server messages. Place this in `server/utils/messageFactory.js`.\n\n```javascript\n// server/utils/messageFactory.js\n\n/**\n * Creates a properly formatted WebSocketMessage for server-originated events.\n * @param {string} type - The event type (e.g., EVENT_CHAT_MESSAGE).\n * @param {any} payload - The data payload for the event.\n * @returns {WebSocketMessage} A structured message object ready for JSON.stringify.\n */\nfunction createServerMessage(type, payload) {\n    return {\n        type,\n        payload,\n        timestamp: new Date().toISOString() // Server's authoritative timestamp\n    };\n}\n\n/**\n * Creates a new ChatMessage object with a server-assigned timestamp.\n * @param {string} sender - The username of the sender.\n * @param {string} content - The text content of the message.\n * @param {string} roomId - The ID of the room where the message was sent.\n * @returns {ChatMessage} A new ChatMessage object.\n */\nfunction createChatMessage(sender, content, roomId) {\n    return {\n        sender,\n        content,\n        timestamp: new Date().toISOString(),\n        roomId\n    };\n}\n\n/**\n * Creates a new Room object.\n * @param {string} name - The display name of the room.\n * @returns {Room} A new Room object with a generated ID.\n */\nfunction createRoom(name) {\n    // Simple ID generation: sanitize name and add random suffix for uniqueness\n    const baseId = name.toLowerCase().trim().replace(/[^a-z0-9-_]/g, '-');\n    const randomSuffix = Math.random().toString(36).substring(2, 8);\n    const id = `${baseId}-${randomSuffix}`;\n\n    return {\n        id,\n        name,\n        createdAt: new Date(),\n        memberIds: new Set() // Tracks connectionIds, not userIds\n    };\n}\n\nmodule.exports = {\n    createServerMessage,\n    createChatMessage,\n    createRoom\n};\n```\n\n#### D. Core Logic Skeleton Code\nThe main Room Manager class skeleton. Place this in `server/roomManager.js`. The TODO comments map directly to the algorithmic steps described in the design.\n\n```javascript\n// server/roomManager.js\nconst { createServerMessage } = require('./utils/messageFactory');\nconst { EVENT_USER_JOINED, EVENT_USER_LEFT, EVENT_USER_TYPING } = require('./constants');\n\nclass RoomManager {\n    constructor(connectionManager, messageStore) {\n        // In-memory store: Map<roomId, Room>\n        this.rooms = new Map();\n        // In-memory store: Map<connectionId, Set<roomId>> (reverse lookup)\n        this.connectionRooms = new Map();\n        // Typing state: Map<roomId, Map<userId, {isTyping: boolean, timeoutId: NodeJS.Timeout}>>\n        this.typingState = new Map();\n\n        // Dependencies\n        this.connectionManager = connectionManager; // To send messages to clients\n        this.messageStore = messageStore; // To fetch history (optional for Milestone 3, required for 4)\n    }\n\n    /**\n     * Adds a connection to a room, fetches history, and notifies others.\n     * @param {string} connectionId\n     * @param {string} roomId\n     * @param {string} userId\n     * @returns {Promise<Room>} The joined room object.\n     */\n    async joinRoom(connectionId, roomId, userId) {\n        // TODO 1: Check if the room exists. If not, create it using createRoom(roomId).\n        // TODO 2: Retrieve the Room object from this.rooms.\n        // TODO 3: Check if the user (connectionId) is already a member. If so, you may want to return early or handle re-join.\n        // TODO 4: Add the connectionId to the room's memberIds Set.\n        // TODO 5: Update the reverse lookup (this.connectionRooms): add this roomId to the set for this connectionId.\n        // TODO 6: [For Milestone 4] Fetch recent message history for this room from this.messageStore (e.g., last 50 messages).\n        // TODO 7: Broadcast an EVENT_USER_JOINED message to all OTHER members of the room.\n        //         Use createServerMessage(EVENT_USER_JOINED, { userId, roomId }) and broadcastToRoom (excluding the new joiner).\n        // TODO 8: Return the Room object (and optionally the message history to be sent directly to the joiner).\n    }\n\n    /**\n     * Removes a connection from a specific room and notifies others.\n     * @param {string} connectionId\n     * @param {string} roomId\n     */\n    leaveRoom(connectionId, roomId) {\n        // TODO 1: Retrieve the Room object from this.rooms. If room doesn't exist, return.\n        // TODO 2: Remove the connectionId from the room's memberIds Set.\n        // TODO 3: Update the reverse lookup: remove this roomId from the set for this connectionId.\n        // TODO 4: Broadcast an EVENT_USER_LEFT message to the REMAINING members of the room.\n        // TODO 5: Check if the room's memberIds set is now empty. If yes, schedule this room for cleanup (start a timer to delete it after X minutes).\n    }\n\n    /**\n     * Removes a connection from all rooms it belongs to.\n     * Called when a WebSocket connection is closed.\n     * @param {string} connectionId\n     */\n    leaveAllRooms(connectionId) {\n        // TODO 1: Get the set of roomIds this connection is in from this.connectionRooms. If empty, return.\n        // TODO 2: For each roomId in the set, call this.leaveRoom(connectionId, roomId).\n        // TODO 3: Delete the entry for this connectionId from this.connectionRooms.\n        // TODO 4: Clear any typing indicators for this connection/user across all rooms.\n    }\n\n    /**\n     * Sends a message to all members of a room, excluding an optional connection.\n     * @param {string} roomId\n     * @param {WebSocketMessage} message\n     * @param {string} [excludeConnectionId] - The connectionId to exclude (usually the sender).\n     */\n    broadcastToRoom(roomId, message, excludeConnectionId) {\n        // TODO 1: Retrieve the Room object. If room doesn't exist, log a warning and return.\n        // TODO 2: Iterate over the room.memberIds Set.\n        // TODO 3: For each memberConnectionId, if it is NOT equal to excludeConnectionId, call this.connectionManager.sendToClient(memberConnectionId, message).\n        //         Hint: Check the connection manager's method signature.\n    }\n\n    /**\n     * Updates and broadcasts a user's typing status in a room.\n     * @param {string} connectionId\n     * @param {string} roomId\n     * @param {boolean} isTyping\n     */\n    setUserTyping(connectionId, roomId, isTyping) {\n        // TODO 1: Retrieve the userId for this connectionId from the connectionManager (you may need to expose a getSession method).\n        // TODO 2: Get or create the typing state map for this room (from this.typingState).\n        // TODO 3: Clear any existing timeout for this user in this room to prevent premature \"stopped typing\" messages.\n        // TODO 4: If isTyping is true:\n        //          a. Store the new state (isTyping: true) and set a new timeout for 3000ms.\n        //          b. When the timeout fires, automatically call setUserTyping again with isTyping: false for this user/room.\n        //          c. Broadcast an EVENT_USER_TYPING message to all OTHER room members with { userId, roomId, isTyping: true }.\n        // TODO 5: If isTyping is false:\n        //          a. Clear the timeout and remove the user's state from the room's map.\n        //          b. If the room's map becomes empty, you can delete it from this.typingState.\n        //          c. Broadcast an EVENT_USER_TYPING message with isTyping: false.\n    }\n\n    /**\n     * Returns a list of all active rooms with their member counts.\n     * @returns {Array<{id: string, name: string, memberCount: number}>}\n     */\n    getRoomList() {\n        // TODO 1: Initialize an empty array `roomList`.\n        // TODO 2: Iterate over this.rooms.values().\n        // TODO 3: For each Room object, push an object with id, name, and memberCount (room.memberIds.size) to roomList.\n        // TODO 4: Return roomList.\n    }\n}\n\nmodule.exports = RoomManager;\n```\n\n#### E. Language-Specific Hints\n*   **Use `Set` for Membership:** The `Room.memberIds` should be a JavaScript `Set` for O(1) addition, deletion, and lookup.\n*   **Maps for Fast Lookup:** Use `Map` for `this.rooms` (keyed by `roomId`) and `this.connectionRooms` (keyed by `connectionId`). They preserve insertion order and are more efficient than plain objects for frequent additions/deletions.\n*   **Cleaning Timeouts:** Always store the `timeoutId` returned by `setTimeout` when scheduling room cleanup or typing indicator expiration. Clear it with `clearTimeout(timeoutId)` if the room becomes non-empty again or the user starts typing again to prevent memory leaks.\n*   **Error Handling in Broadcast:** Wrap the `this.connectionManager.sendToClient` call in a try-catch block or ensure the connection manager handles closed sockets gracefully and doesn't throw.\n\n#### F. Milestone Checkpoint\nAfter implementing the Room Manager and integrating it with the Connection Manager from Milestone 1, you should be able to test core chat functionality.\n\n**Expected Behavior (Milestone 2 & 3):**\n1.  Start your server (`node server/index.js`).\n2.  Open two different browser tabs to your client page.\n3.  In Tab 1, join a room (e.g., \"general\"). You should see a system message confirming your join.\n4.  In Tab 2, join the same room \"general\". Tab 1 should now receive a \"user joined\" notification.\n5.  Type a message in Tab 2 and send it. The message should appear in Tab 1's chat log, but **not** a second time in Tab 2 (no echo). The message should have a timestamp, sender name, and content.\n6.  Start typing in Tab 1. After a brief delay, Tab 2 should show a \"User is typing...\" indicator, which disappears when you send the message or stop typing for a few seconds.\n7.  In a third tab, join a different room (e.g., \"random\"). Messages sent in \"general\" should **not** appear in this tab, demonstrating room isolation.\n\n**Commands to Verify:**\n*   Observe server logs. You should see log entries for `joinRoom`, `broadcastToRoom`, and `leaveRoom` operations.\n*   Check that the number of active connections and room counts are logged correctly.\n\n**Signs of Trouble:**\n*   **Messages appear duplicated in sender's tab:** You are not excluding the sender in `broadcastToRoom`.\n*   **\"User joined\" message appears for the user themselves:** The `EVENT_USER_JOINED` broadcast is not excluding the new joiner.\n*   **Typing indicator never disappears:** The timeout logic in `setUserTyping` is not correctly clearing or setting the state to false.\n*   **Server memory usage grows indefinitely as rooms are created/left:** The \"zombie room\" cleanup in `leaveRoom` is not implemented.\n\n\n## Component Design: Persistence & Authentication Service\n\n> **Milestone(s):** Milestone 4 (User Authentication & Persistence)\n\nThis component provides the foundational services for **user identity management** and **message persistence**—two critical requirements for any production chat application. While the WebSocket Server and Room Manager handle real-time interactions, the Persistence & Authentication Service ensures that user identities are verified, conversations are preserved, and historical context is available when users reconnect or join rooms.\n\n### Responsibility and Scope\n\nThe Persistence & Authentication Service operates as two logically separate but closely collaborating subsystems:\n\n| Subsystem | Primary Responsibilities | Key Data Managed |\n|-----------|--------------------------|------------------|\n| **Authentication Service** | 1. User registration and credential storage<br>2. Session creation and validation during WebSocket connection establishment<br>3. User profile management (username, status)<br>4. Session cleanup (expired/inactive sessions) | - `User` records (username, password hash)<br>- Session tokens or cookies<br>- Authentication state per connection |\n| **Message Persistence Store** | 1. Storing `ChatMessage` objects with metadata (sender, room, timestamp)<br>2. Retrieving message history with pagination support<br>3. Room message count and statistics<br>4. Optional message archival/cleanup policies | - `ChatMessage` objects indexed by room and timestamp<br>- Message ID sequencing<br>- Pagination cursors |\n\nThe service interfaces with the **WebSocket Server** during connection establishment (for authentication) and with the **Room Manager** when messages need to be stored or retrieved. Its scope is deliberately bounded to identity and persistence concerns, leaving real-time routing and room state management to the Room Manager.\n\n### Mental Model: The Library Archivist and Security Guard\n\nTo build intuition, imagine this service as two roles in a physical library:\n\n> **The Security Guard (Authentication Service)** stands at the entrance, checking library cards (sessions) before allowing anyone inside. They maintain a registry of valid members (`User` records) and issue temporary passes (sessions) that expire after a period of inactivity. When someone presents an expired or forged pass, the guard denies entry and logs the attempt.\n\n> **The Library Archivist (Message Persistence Store)** works in the stacks, meticulously cataloging every conversation that occurs in the library's reading rooms. They organize messages by room (like books by shelf), maintain a chronological index, and can retrieve specific conversations when patrons request them. The archivist doesn't participate in the conversations but ensures they're preserved for future reference.\n\nThis mental model clarifies the separation of concerns: authentication is a **gatekeeping** function performed at entry points, while persistence is a **record-keeping** function that operates continuously in the background.\n\n### ADR: When to Authenticate - HTTP vs. WebSocket\n\n> **Decision: Authenticate During HTTP Upgrade, Not Via WebSocket Messages**\n> \n> **Context**: WebSocket connections begin as HTTP requests that \"upgrade\" to the WebSocket protocol. We need to verify user identity before allowing them to establish a persistent connection and access chat features, but we have multiple timing options for performing this verification.\n> \n> **Options Considered**:\n> 1. **HTTP Upgrade Authentication**: Validate credentials/session during the initial HTTP upgrade request before establishing the WebSocket connection.\n> 2. **Custom WebSocket Authentication Message**: Accept all WebSocket connections, then require clients to send a special authentication message as their first action.\n> 3. **Hybrid Approach**: Use HTTP for initial handshake with tokens, then allow reauthentication via WebSocket messages for session renewal.\n> \n> **Decision**: We chose Option 1 (HTTP Upgrade Authentication) as the primary authentication mechanism.\n> \n> **Rationale**:\n> - **Security**: Rejecting unauthenticated connections at the HTTP layer prevents resource consumption by unauthorized clients. The WebSocket connection is never established if authentication fails.\n> - **Simplicity**: The authentication logic runs once at connection time, simplifying subsequent message handling (no need to check auth state on every message).\n> - **Established Pattern**: This aligns with how production WebSocket services (like Socket.IO with middleware) typically handle authentication using HTTP cookies or tokens.\n> - **Early Failure**: Clients receive immediate feedback (HTTP 401/403) rather than establishing a connection only to be disconnected later.\n> \n> **Consequences**:\n> - **Positive**: Reduced server load from unauthorized connections, cleaner client code (auth handled during connection setup), immediate user feedback on auth failures.\n> - **Negative**: Requires session management via HTTP cookies or tokens, cannot easily change user identity without reconnecting, slightly more complex upgrade handler implementation.\n> - **Mitigation**: We'll implement a simple token-based system where clients pass an authentication token in the upgrade request headers.\n\n| Option | Pros | Cons | Why Chosen? |\n|--------|------|------|-------------|\n| **HTTP Upgrade Authentication** | - Early rejection saves resources<br>- Single authentication point<br>- Aligns with security best practices | - Requires token/cookie management<br>- Cannot reauthenticate without reconnecting | **CHOSEN**: Provides security and simplicity for learning context |\n| **WebSocket Message Authentication** | - Flexible reauthentication<br>- Can support multiple auth methods | - Unauthenticated connections consume resources<br>- Must validate auth on every message initially<br>- Complex state management | Rejected due to security concerns and complexity |\n| **Hybrid Approach** | - Best of both worlds<br>- Supports session renewal | - Most complex implementation<br>- Overkill for learning context | Rejected as overly complex for our needs |\n\n### Common Pitfalls: Unbounded History and Session Leaks\n\n⚠️ **Pitfall: Loading Entire Message History Without Pagination**\n\n**Description**: When a user joins a room, the server attempts to load all historical messages from the database, which could be thousands or millions of records.\n\n**Why It's Wrong**: This causes severe performance issues:\n- High memory consumption on both server and client\n- Long loading times blocking other operations\n- Potential denial of service if many users join simultaneously\n- Network bandwidth exhaustion sending massive payloads\n\n**How to Fix**: Implement **pagination** with a reasonable default limit (e.g., 50 most recent messages). Use cursor-based pagination where the client can request older messages on demand. Store only the necessary fields in memory, not entire message objects.\n\n---\n\n⚠️ **Pitfall: Never Expiring Sessions or Cleaning Up Stale Data**\n\n**Description**: Sessions (`ClientSession` objects) remain in memory indefinitely after users disconnect, and old messages accumulate in the database without cleanup.\n\n**Why It's Wrong**: This leads to resource exhaustion and stale state:\n- Memory leaks as disconnected sessions accumulate\n- Database bloat affecting query performance\n- Security risk from indefinitely valid session tokens\n- Incorrect presence information if stale sessions aren't cleaned\n\n**How to Fix**: Implement **TTL (Time-To-Live)** policies:\n1. Sessions: Remove `ClientSession` after WebSocket disconnection + short grace period\n2. Authentication tokens: Set expiration times (e.g., 24 hours)\n3. Messages: Consider archival or deletion policies for very old messages\n4. Use heartbeat mechanisms to detect and clean up \"zombie\" connections\n\n---\n\n⚠️ **Pitfall: Storing Passwords in Plain Text**\n\n**Description**: User passwords are stored as plain text strings in the database rather than as cryptographic hashes.\n\n**Why It's Wrong**: This creates catastrophic security vulnerabilities:\n- Database compromise exposes all user passwords\n- Users who reuse passwords across sites are at risk\n- Violates security best practices and potentially regulations\n\n**How to Fix**: Always hash passwords using a **key derivation function** like bcrypt, scrypt, or Argon2. Store only the hash, never the plaintext. During authentication, hash the provided password and compare it to the stored hash.\n\n---\n\n⚠️ **Pitfall: No Validation or Sanitization of Persistent Data**\n\n**Description**: User-generated content (messages, room names, usernames) is stored directly without validation, sanitization, or encoding.\n\n**Why It's Wrong**: This enables multiple attack vectors:\n- **XSS (Cross-Site Scripting)**: Malicious scripts in messages execute in other users' browsers\n- **SQL/NoSQL Injection**: If using string concatenation for queries\n- **Data corruption**: Invalid data breaks application logic\n- **Storage abuse**: Extremely large messages consume excessive resources\n\n**How to Fix**: Implement **layered validation**:\n1. **Client-side**: Basic validation for user experience\n2. **Server-side before storage**: \n   - Length limits (enforce `MAX_MESSAGE_LENGTH`)\n   - Character encoding/escaping\n   - Content type validation\n   - Sanitize HTML/script tags from messages\n3. **Database layer**: Use parameterized queries to prevent injection\n\n### Interface: Core Methods and Events\n\nThe Authentication Service and Message Store expose the following interfaces to other components:\n\n#### Authentication Service Interface\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `authenticateConnection(request)` | `request`: HTTP Upgrade request object | `{ success: boolean, user: User \\| null, error: string \\| null }` | Validates credentials/token from HTTP upgrade headers. Returns authenticated `User` object or error. |\n| `registerUser(username, password)` | `username`: string, `password`: string | `Promise<{ success: boolean, user: User \\| null, error: string \\| null }>` | Creates new user with hashed password. Validates uniqueness, password strength. |\n| `validateSession(sessionToken)` | `sessionToken`: string | `Promise<{ valid: boolean, user: User \\| null }>` | Validates existing session token without creating new connection. Used for reconnection. |\n| `createSession(userId, connectionInfo)` | `userId`: string, `connectionInfo`: { ip, userAgent } | `Promise<string>` (sessionToken) | Creates a new session for an authenticated user, returning a token for future validation. |\n| `invalidateSession(sessionToken)` | `sessionToken`: string | `Promise<boolean>` | Removes session, effectively logging out the user from that device/connection. |\n\n#### Message Persistence Store Interface\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `storeMessage(message)` | `message`: `ChatMessage` object | `Promise<ChatMessage>` (with assigned ID) | Stores a chat message with timestamp, assigns unique ID, indexes by room and timestamp. |\n| `getMessagesForRoom(roomId, options)` | `roomId`: string, `options`: { limit: number, before: timestamp \\| null } | `Promise<ChatMessage[]>` | Retrieves messages for a room with pagination. `before` parameter enables fetching older messages. |\n| `getRecentMessagesForRoom(roomId, limit)` | `roomId`: string, `limit`: number (default: 50) | `Promise<ChatMessage[]>` | Convenience method for getting most recent messages when joining a room. |\n| `getMessageCountForRoom(roomId)` | `roomId`: string | `Promise<number>` | Returns total message count in a room (for statistics or UI indicators). |\n| `deleteMessagesOlderThan(timestamp)` | `timestamp`: ISO date string | `Promise<number>` (deleted count) | Cleanup method for removing very old messages (optional, for maintenance). |\n\n### Data Flow: Authentication During Connection Establishment\n\nThe authentication process integrates with the WebSocket connection lifecycle described in previous sections:\n\n1. **Client initiates connection**: Browser JavaScript attempts to establish WebSocket connection with server endpoint.\n\n2. **HTTP Upgrade request**: The WebSocket handshake begins as an HTTP GET request with `Upgrade: websocket` header.\n\n3. **Authentication interceptor**: The WebSocket Server's HTTP upgrade handler extracts authentication credentials (typically from `Authorization` header or cookie).\n\n4. **Credential validation**: The Authentication Service validates the token/session:\n   - **Valid session**: Proceeds to step 5\n   - **Invalid/expired session**: Returns HTTP 401 Unauthorized, connection fails\n   - **No credentials**: Returns HTTP 403 Forbidden, connection fails\n\n5. **User lookup**: If credentials are valid, the Authentication Service retrieves the corresponding `User` object.\n\n6. **Session creation**: A new `ClientSession` is created linking the WebSocket connection to the authenticated user.\n\n7. **WebSocket connection established**: HTTP 101 Switching Protocols is sent, WebSocket protocol begins.\n\n8. **Initialization message**: Server sends `connection_established` event with user info and available rooms.\n\nThis flow ensures that **every active WebSocket connection has an associated authenticated user**, simplifying subsequent authorization checks (e.g., \"does this user have permission to post in this room?\").\n\n### Data Flow: Message Persistence\n\nWhen a chat message flows through the system (as shown in ![Sequence: Broadcasting a Chat Message](./diagrams/seq-send-message.svg)), persistence occurs at a specific point:\n\n1. **Message reception**: `ConnectionManager.handleMessage()` receives a `chat_message` event from a client.\n\n2. **Validation and processing**: The message is validated, a `ChatMessage` object is created with server timestamp.\n\n3. **Storage before broadcast**: Before broadcasting to room members, the Room Manager calls `MessageStore.storeMessage(message)` to persist it.\n\n4. **Synchronous storage**: The message is written to the database. In our learning implementation, we'll wait for confirmation before proceeding.\n\n5. **Broadcast**: Once storage is confirmed, the message is broadcast to room members.\n\n> **Design Insight**: We store **before** broadcasting to ensure no message is delivered to users without being persisted. This guarantees that if the server crashes between broadcast and storage, the message won't be lost entirely (it won't have been seen by anyone). This is a **safety-first** approach suitable for chat applications where message loss is more critical than minimal latency.\n\n### Implementation Guidance\n\n#### A. Technology Recommendations\n\n| Component | Simple Option (Learning) | Advanced Option (Production) |\n|-----------|--------------------------|------------------------------|\n| **Authentication Storage** | In-memory JavaScript Map | Redis (sessions) + PostgreSQL (users) |\n| **Message Storage** | In-memory array with periodic file dump | PostgreSQL with JSONB or dedicated message DB |\n| **Password Hashing** | bcrypt library (npm `bcrypt`) | bcrypt with appropriate work factor |\n| **Session Tokens** | JSON Web Tokens (JWT) | JWT with refresh token rotation |\n\n#### B. Recommended File/Module Structure\n\n```\nreal-time-chat/\n├── server/\n│   ├── index.js                    # Main server entry point\n│   ├── connection-manager.js       # From Milestone 1\n│   ├── room-manager.js             # From Milestones 2-3\n│   ├── auth-service.js             # THIS COMPONENT: Authentication logic\n│   ├── message-store.js            # THIS COMPONENT: Message persistence\n│   ├── models.js                   # Shared type definitions (User, ChatMessage, etc.)\n│   └── utils.js                    # Helper functions (hashing, validation)\n├── client/\n│   └── public/                     # HTML, CSS, client JavaScript\n└── package.json\n```\n\n#### C. Infrastructure Starter Code: Simple In-Memory Message Store\n\nHere's a complete, working in-memory message store suitable for learning and development. This implements the `MessageStore` interface with basic pagination:\n\n```javascript\n// server/message-store.js\n/**\n * Simple in-memory message store with periodic persistence to file.\n * For learning purposes only - not suitable for production.\n */\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass InMemoryMessageStore {\n  constructor(persistenceFile = './message-store.json', persistIntervalMs = 30000) {\n    this.messages = new Map(); // roomId -> Array<ChatMessage>\n    this.persistenceFile = persistenceFile;\n    this.persistIntervalMs = persistIntervalMs;\n    this.nextMessageId = 1;\n    \n    // Load existing messages from file if it exists\n    this.loadFromFile().catch(err => {\n      console.warn('Could not load message store from file:', err.message);\n    });\n    \n    // Set up periodic persistence\n    this.persistenceInterval = setInterval(() => {\n      this.persistToFile().catch(err => {\n        console.error('Failed to persist messages:', err);\n      });\n    }, this.persistIntervalMs);\n  }\n\n  /**\n   * Store a chat message\n   * @param {ChatMessage} message - Must have roomId, sender, content, timestamp\n   * @returns {Promise<ChatMessage>} - Message with assigned id\n   */\n  async storeMessage(message) {\n    // Validate required fields\n    if (!message.roomId || !message.sender || !message.content || !message.timestamp) {\n      throw new Error('Message missing required fields');\n    }\n    \n    // Assign unique ID\n    const messageWithId = {\n      ...message,\n      id: this.nextMessageId++,\n    };\n    \n    // Initialize room array if needed\n    if (!this.messages.has(message.roomId)) {\n      this.messages.set(message.roomId, []);\n    }\n    \n    // Add to room's messages\n    this.messages.get(message.roomId).push(messageWithId);\n    \n    return messageWithId;\n  }\n\n  /**\n   * Get messages for a room with pagination\n   * @param {string} roomId \n   * @param {Object} options\n   * @param {number} options.limit - Maximum messages to return\n   * @param {string|null} options.before - ISO timestamp: return messages before this time\n   * @returns {Promise<ChatMessage[]>}\n   */\n  async getMessagesForRoom(roomId, options = {}) {\n    const { limit = 50, before = null } = options;\n    \n    if (!this.messages.has(roomId)) {\n      return [];\n    }\n    \n    let roomMessages = this.messages.get(roomId);\n    \n    // Filter by 'before' timestamp if provided\n    if (before) {\n      roomMessages = roomMessages.filter(msg => msg.timestamp < before);\n    }\n    \n    // Sort by timestamp descending (newest first) and take limit\n    return roomMessages\n      .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))\n      .slice(0, limit);\n  }\n\n  /**\n   * Convenience method for getting recent messages\n   * @param {string} roomId \n   * @param {number} limit \n   * @returns {Promise<ChatMessage[]>}\n   */\n  async getRecentMessagesForRoom(roomId, limit = 50) {\n    return this.getMessagesForRoom(roomId, { limit });\n  }\n\n  /**\n   * Get message count for a room\n   * @param {string} roomId \n   * @returns {Promise<number>}\n   */\n  async getMessageCountForRoom(roomId) {\n    return this.messages.has(roomId) ? this.messages.get(roomId).length : 0;\n  }\n\n  /**\n   * Save messages to disk\n   * @private\n   */\n  async persistToFile() {\n    const data = {\n      messages: Object.fromEntries(this.messages),\n      nextMessageId: this.nextMessageId,\n      persistedAt: new Date().toISOString(),\n    };\n    \n    await fs.writeFile(\n      this.persistenceFile,\n      JSON.stringify(data, null, 2),\n      'utf-8'\n    );\n  }\n\n  /**\n   * Load messages from disk\n   * @private\n   */\n  async loadFromFile() {\n    try {\n      const data = await fs.readFile(this.persistenceFile, 'utf-8');\n      const parsed = JSON.parse(data);\n      \n      this.messages = new Map(Object.entries(parsed.messages || {}));\n      this.nextMessageId = parsed.nextMessageId || 1;\n      \n      console.log(`Loaded ${Array.from(this.messages.values()).flat().length} messages from disk`);\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err; // Re-throw if it's not \"file not found\"\n      }\n    }\n  }\n\n  /**\n   * Cleanup old messages (optional)\n   * @param {string} cutoffDate - ISO timestamp\n   * @returns {Promise<number>} - Number of messages deleted\n   */\n  async deleteMessagesOlderThan(cutoffDate) {\n    let totalDeleted = 0;\n    const cutoff = new Date(cutoffDate);\n    \n    for (const [roomId, messages] of this.messages.entries()) {\n      const originalLength = messages.length;\n      const filtered = messages.filter(msg => new Date(msg.timestamp) >= cutoff);\n      \n      if (filtered.length !== originalLength) {\n        this.messages.set(roomId, filtered);\n        totalDeleted += (originalLength - filtered.length);\n      }\n    }\n    \n    return totalDeleted;\n  }\n\n  /**\n   * Graceful shutdown - persist before exiting\n   */\n  async shutdown() {\n    clearInterval(this.persistenceInterval);\n    await this.persistToFile();\n  }\n}\n\n// Export a singleton instance\nmodule.exports = new InMemoryMessageStore();\n```\n\n#### D. Core Logic Skeleton: Authentication Service\n\n```javascript\n// server/auth-service.js\nconst bcrypt = require('bcrypt');\nconst { v4: uuidv4 } = require('uuid');\nconst { User } = require('./models');\n\n/**\n * Authentication Service responsible for user registration, login,\n * and session management.\n */\nclass AuthenticationService {\n  constructor() {\n    // In-memory stores for learning purposes\n    this.users = new Map(); // username -> User object\n    this.sessions = new Map(); // sessionToken -> { userId, createdAt, lastActivity }\n    \n    // Configuration\n    this.sessionTTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n    this.saltRounds = 10; // For bcrypt hashing\n    \n    // Initialize with a test user for development\n    this.initializeTestUser();\n  }\n\n  /**\n   * Authenticate a user during WebSocket upgrade\n   * @param {http.IncomingMessage} request - HTTP upgrade request\n   * @returns {Object} { success: boolean, user: User|null, error: string|null }\n   */\n  authenticateConnection(request) {\n    // TODO 1: Extract authentication token from request headers\n    // Look for 'Authorization' header with format 'Bearer <token>'\n    // or check cookies if using cookie-based auth\n    \n    // TODO 2: If no token found, return { success: false, user: null, error: 'No credentials provided' }\n    \n    // TODO 3: Validate the session token using this.validateSession(token)\n    \n    // TODO 4: If session is valid, retrieve the User object from this.users\n    \n    // TODO 5: Update session's lastActivity timestamp\n    \n    // TODO 6: Return { success: true, user: userObject, error: null }\n    \n    // TODO 7: If any step fails, return appropriate error message\n  }\n\n  /**\n   * Register a new user\n   * @param {string} username \n   * @param {string} plainPassword \n   * @returns {Promise<Object>} { success: boolean, user: User|null, error: string|null }\n   */\n  async registerUser(username, plainPassword) {\n    // TODO 1: Validate username (length, characters, uniqueness)\n    // Check if username already exists in this.users\n    \n    // TODO 2: Validate password strength (minimum length, complexity if desired)\n    \n    // TODO 3: Hash the password using bcrypt.hash(plainPassword, this.saltRounds)\n    \n    // TODO 4: Create new User object with username, passwordHash, createdAt\n    \n    // TODO 5: Store in this.users map\n    \n    // TODO 6: Return success with user object (EXCLUDE passwordHash from returned object)\n    \n    // TODO 7: Handle errors (duplicate username, hashing failure, etc.)\n  }\n\n  /**\n   * Login existing user and create session\n   * @param {string} username \n   * @param {string} plainPassword \n   * @returns {Promise<Object>} { success: boolean, sessionToken: string|null, error: string|null }\n   */\n  async loginUser(username, plainPassword) {\n    // TODO 1: Find user by username in this.users\n    \n    // TODO 2: If user not found, return { success: false, sessionToken: null, error: 'Invalid credentials' }\n    \n    // TODO 3: Compare provided password with stored hash using bcrypt.compare()\n    \n    // TODO 4: If password doesn't match, return same error as step 2 (security: don't reveal if user exists)\n    \n    // TODO 5: Generate a new session token (use uuidv4())\n    \n    // TODO 6: Store session in this.sessions with userId, createdAt, lastActivity\n    \n    // TODO 7: Return { success: true, sessionToken: token, error: null }\n  }\n\n  /**\n   * Validate an existing session token\n   * @param {string} sessionToken \n   * @returns {Promise<Object>} { valid: boolean, user: User|null }\n   */\n  async validateSession(sessionToken) {\n    // TODO 1: Look up session in this.sessions\n    \n    // TODO 2: If session not found, return { valid: false, user: null }\n    \n    // TODO 3: Check if session has expired (compare lastActivity + TTL to current time)\n    \n    // TODO 4: If expired, remove from this.sessions and return { valid: false, user: null }\n    \n    // TODO 5: If valid, update lastActivity timestamp\n    \n    // TODO 6: Retrieve user from this.users and return { valid: true, user: userObject }\n  }\n\n  /**\n   * Create a session for an already-authenticated user\n   * @param {string} userId \n   * @param {Object} connectionInfo - { ip: string, userAgent: string }\n   * @returns {Promise<string>} sessionToken\n   */\n  async createSession(userId, connectionInfo) {\n    // TODO 1: Generate new session token (uuidv4)\n    \n    // TODO 2: Create session object with userId, createdAt, lastActivity, connectionInfo\n    \n    // TODO 3: Store in this.sessions\n    \n    // TODO 4: Return the session token\n  }\n\n  /**\n   * Invalidate (logout) a session\n   * @param {string} sessionToken \n   * @returns {Promise<boolean>} true if session was found and removed\n   */\n  async invalidateSession(sessionToken) {\n    // TODO 1: Check if session exists in this.sessions\n    \n    // TODO 2: If exists, delete it and return true\n    \n    // TODO 3: If not found, return false\n  }\n\n  /**\n   * Clean up expired sessions (should be called periodically)\n   * @returns {number} count of sessions cleaned up\n   */\n  cleanupExpiredSessions() {\n    // TODO 1: Get current timestamp\n    \n    // TODO 2: Iterate through this.sessions\n    \n    // TODO 3: For each session, check if lastActivity + TTL < current time\n    \n    // TODO 4: Delete expired sessions\n    \n    // TODO 5: Return count of deleted sessions\n  }\n\n  /**\n   * Initialize with a test user for development\n   * @private\n   */\n  async initializeTestUser() {\n    const testUsername = 'testuser';\n    const testPassword = 'password123';\n    \n    if (!this.users.has(testUsername)) {\n      try {\n        const passwordHash = await bcrypt.hash(testPassword, this.saltRounds);\n        this.users.set(testUsername, {\n          username: testUsername,\n          passwordHash,\n          createdAt: new Date().toISOString(),\n        });\n        console.log(`Test user created: ${testUsername} / ${testPassword}`);\n      } catch (err) {\n        console.error('Failed to create test user:', err);\n      }\n    }\n  }\n}\n\n// Export a singleton instance\nmodule.exports = new AuthenticationService();\n```\n\n#### E. Language-Specific Hints (JavaScript/Node.js)\n\n- **Password Hashing**: Use the `bcrypt` npm package. Install with `npm install bcrypt`. Always use `async/await` with bcrypt as the hashing is CPU-intensive and blocking the event loop would hurt performance.\n\n- **Session Tokens**: Use `uuid` package for generating secure random tokens: `npm install uuid`. Version 4 (random) UUIDs are sufficient for learning. In production, consider signed tokens (JWT) for stateless validation.\n\n- **HTTP Header Parsing**: In the `authenticateConnection` method, access headers via `request.headers['authorization']`. Remember header names are lowercase in Node.js's parsed headers object.\n\n- **Memory Management**: The in-memory stores will grow indefinitely. For a learning project, this is acceptable, but add a `/debug` endpoint that shows memory usage and allows manual cleanup.\n\n- **Error Handling**: Always use `try/catch` around async operations with bcrypt and file I/O. Return user-friendly error messages but log detailed errors server-side.\n\n#### F. Integration with WebSocket Server\n\nUpdate your WebSocket server from Milestone 1 to integrate authentication:\n\n```javascript\n// In your main server file (server/index.js)\nconst authService = require('./auth-service');\nconst http = require('http');\n\nconst server = http.createServer();\nconst wss = new WebSocket.Server({ noServer: true });\n\nserver.on('upgrade', (request, socket, head) => {\n  // Authenticate before upgrading to WebSocket\n  const authResult = authService.authenticateConnection(request);\n  \n  if (!authResult.success) {\n    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n  \n  // Proceed with WebSocket upgrade for authenticated users\n  wss.handleUpgrade(request, socket, head, (ws) => {\n    // Create ClientSession linking ws to authenticated user\n    const clientSession = createClientSession(\n      ws, \n      authResult.user.username,\n      request.socket.remoteAddress,\n      request.headers['user-agent']\n    );\n    \n    // Store in ConnectionManager\n    connectionManager.addClient(clientSession);\n    \n    // Send welcome message\n    ws.send(JSON.stringify({\n      type: 'connection_established',\n      payload: { \n        user: authResult.user.username,\n        timestamp: new Date().toISOString()\n      }\n    }));\n  });\n});\n```\n\n#### G. Milestone Checkpoint for Authentication & Persistence\n\nAfter implementing this component, verify your system works correctly:\n\n1. **Start the server**: `node server/index.js`\n2. **Test registration** (via a simple curl or test client):\n   ```bash\n   curl -X POST http://localhost:3000/register \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"username\":\"alice\",\"password\":\"secure123\"}'\n   ```\n   Should return: `{\"success\":true,\"user\":{\"username\":\"alice\",\"createdAt\":\"...\"}}`\n\n3. **Test login**:\n   ```bash\n   curl -X POST http://localhost:3000/login \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"username\":\"alice\",\"password\":\"secure123\"}'\n   ```\n   Should return a session token.\n\n4. **Connect with WebSocket using authentication**:\n   - Modify your client code to include the session token in WebSocket connection headers\n   - Verify connection succeeds with authenticated user\n   - Verify connection fails with invalid/no token\n\n5. **Test message persistence**:\n   - Send a chat message in a room\n   - Disconnect and reconnect\n   - Verify previous messages load when rejoining the room\n   - Check that only recent messages load (not entire history)\n\n6. **Verify session cleanup**:\n   - Connect and authenticate\n   - Disconnect client\n   - Wait for session TTL + grace period\n   - Try to reconnect with old token (should fail)\n\n**Expected Behavior**: Users can register, login, establish authenticated WebSocket connections, and see message history when joining rooms. Sessions expire appropriately, and passwords are securely hashed.\n\n**Troubleshooting**:\n- \"Registration fails with duplicate username\": Check `users` Map for existing username\n- \"Login fails even with correct password\": Verify bcrypt.compare() is working (hashes must match exactly)\n- \"Messages not loading on rejoin\": Check `message-store.js` persistence file location and permissions\n- \"Session valid after disconnect\": Ensure `connectionManager.removeClient()` calls session cleanup\n\n---\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** Milestone 2 (Message Broadcasting), Milestone 3 (Chat Rooms), Milestone 4 (User Authentication & Persistence) - for history loading and authentication\n\nThis section traces the concrete journeys through our chat system. Understanding these flows—the precise sequence of events, data transformations, and component interactions—is crucial for building a mental model of how the system behaves under real conditions. We'll follow two fundamental user stories: sending a message to a room, and joining a room to participate in conversation.\n\n### Sequence: Sending and Receiving a Message\n\n**Mental Model: The Party Conversation**\nImagine a lively party where people gather in different rooms. When someone speaks in a room, their voice doesn't magically appear in everyone's ears—it travels through the air, is heard by others in the same room, and is also recorded in the party's official transcript. The chat system operates similarly: a message originates from one user, travels through the server infrastructure, reaches other users in the same room, and is permanently archived for later reference.\n\nThe following diagram illustrates this journey:\n![Sequence: Broadcasting a Chat Message](./diagrams/seq-send-message.svg)\n\n#### Step-by-Step Journey of a Chat Message\n\n1. **User Input and Client Preparation**\n   - Alice types \"Hello everyone!\" into her chat interface and presses Enter.\n   - The client application (browser) creates a structured `ChatMessage` object containing:\n     - `sender`: \"alice\" (her authenticated username)\n     - `content`: \"Hello everyone!\" (validated for length ≤ `MAX_MESSAGE_LENGTH`)\n     - `roomId`: \"general\" (the current room she's viewing)\n     - `id`: 0 (temporary client-side ID, will be replaced by server)\n     - `timestamp`: (initially empty, will be set by server)\n   - The client wraps this `ChatMessage` in a `WebSocketMessage` with:\n     - `type`: `EVENT_CHAT_MESSAGE` (\"chat_message\")\n     - `payload`: The `ChatMessage` object\n     - `timestamp`: Current client ISO timestamp (for debugging, not trusted)\n\n2. **WebSocket Transmission**\n   - The client's WebSocket connection (already established and authenticated) calls `socket.send()` with the JSON-stringified `WebSocketMessage`.\n   - The message travels over the persistent TCP connection established during the initial handshake, avoiding the overhead of HTTP headers and connection setup.\n\n3. **Server Reception and Validation**\n   - The WebSocket server receives the raw message string on Alice's specific socket.\n   - `ConnectionManager.handleMessage(socket, rawMessage)` is invoked:\n     - **Parsing**: `parseAndValidateWebSocketMessage(rawMessage)` attempts to parse the JSON. If parsing fails (malformed JSON), the server sends an error response to Alice's connection only and stops processing.\n     - **Validation**: The method validates the message has required fields (`type`, `payload`) and that `type` equals `EVENT_CHAT_MESSAGE`.\n     - **Authentication Check**: The server looks up Alice's `ClientSession` using the socket connection ID, confirming she's authenticated and currently in the \"general\" room (matching the `roomId` in the payload).\n     - **Payload Validation**: `validateChatMessagePayload(payload)` checks the `ChatMessage` structure: `content` length, `sender` matches authenticated user (preventing impersonation), and `roomId` exists.\n\n4. **Message Processing and Storage**\n   - The server calls `createChatMessage(sender, content, roomId)` to create a canonical message:\n     - Generates a server-assigned unique ID (sequential or UUID)\n     - Sets the authoritative `timestamp` to `new Date().toISOString()` (server time, preventing clock skew issues)\n     - Uses the validated `sender` and `content`\n   - The Room Manager receives the processed message and calls `storeMessage(message)`:\n     - The Persistence Service stores the complete `ChatMessage` (with server-set ID and timestamp) in the database.\n     - Storage happens synchronously before broadcasting to ensure no message is lost if the server crashes immediately after broadcasting.\n\n5. **Recipient Determination and Broadcast**\n   - `RoomManager.broadcastToRoom(roomId, message, excludeConnectionId)` is called with:\n     - `roomId`: \"general\"\n     - `message`: The server-created `ChatMessage`\n     - `excludeConnectionId`: Alice's connection ID (so she doesn't receive her own message echo)\n   - The Room Manager retrieves the `memberIds` Set for room \"general\".\n   - For each member ID except Alice's:\n     - The Room Manager calls `ConnectionManager.sendToClient(connectionId, message)`\n     - The Connection Manager looks up the WebSocket for that connection ID\n     - It checks the socket's `readyState` (must be `OPEN`). If closed, it silently skips this recipient (user may have disconnected mid-broadcast).\n     - It wraps the `ChatMessage` in a server `WebSocketMessage` using `createServerMessage(EVENT_CHAT_MESSAGE, chatMessage)`\n\n6. **Network Delivery to Recipients**\n   - For each active recipient (e.g., Bob, Charlie), the server sends the JSON message through their individual WebSocket connections.\n   - The messages travel asynchronously and may arrive at slightly different times due to network conditions, but all contain the same server timestamp for consistent ordering.\n\n7. **Client Reception and Rendering**\n   - Bob's browser receives the WebSocket message via the `onmessage` event.\n   - His client parses the JSON, validates the structure, and extracts the `ChatMessage`.\n   - The UI updates to display:\n     - Sender name: \"alice\" (styled according to user preferences)\n     - Message content: \"Hello everyone!\"\n     - Timestamp: Formatted locally (e.g., \"2:30 PM\") from the ISO timestamp\n     - Visual indication that this is a new message (highlight, notification sound if room is active)\n   - The client may store the message in local memory for the current session but relies on server history for persistence.\n\n8. **Completion and Cleanup**\n   - The server logs the message delivery (optional, for debugging).\n   - All resources (database connections, memory objects) are released.\n   - The system is ready for the next message.\n\n**Critical Design Insight:**\n> The server acts as the **single source of truth** for message identity and timing. By generating the final ID and timestamp server-side, we prevent conflicts that could arise from multiple clients generating IDs independently. This also prevents malicious clients from backdating messages or forging sender identities.\n\n**Common Variations and Edge Cases:**\n- **Empty Room**: If Alice is alone in the room, `memberIds` contains only her ID, so after excluding her, broadcast sends to zero recipients. The message is still stored for history.\n- **Partial Delivery**: If Bob's connection drops during transmission, his socket won't be in `OPEN` state, so he misses the real-time message but can retrieve it later via message history.\n- **High Volume**: Under heavy load, the store-broadcast sequence remains atomic per message but multiple messages may be processed concurrently, potentially delivering messages slightly out of order (though timestamps provide correct ordering for display).\n\n### Sequence: Joining a Room and Loading History\n\n**Mental Model: Entering a Conference Hall**\nImagine arriving at a large conference center. You first check in at the registration desk (authentication), receive your badge (session), then find the specific breakout room you want to join. As you enter, the ongoing conversation pauses briefly—the moderator announces your arrival, provides you with the last few minutes of discussion notes (message history), and adds you to the attendee list. Other participants now see you as present and can direct messages to you.\n\nThe following diagram illustrates this process:\n![Sequence: User Joining a Room](./diagrams/seq-join-room.svg)\n\n#### Step-by-Step Room Joining Process\n\n1. **User Interface Action**\n   - Bob, already authenticated and connected via WebSocket, clicks \"Join General Chat\" in the room browser interface.\n   - The client application sends a `WebSocketMessage` with:\n     - `type`: \"join_room\"\n     - `payload`: `{ roomId: \"general\" }`\n     - (Optional) `timestamp`: Client current time\n\n2. **Server Authentication and Validation**\n   - The WebSocket server receives the message and routes it to `ConnectionManager.handleMessage`.\n   - The server validates:\n     - Bob has an active `ClientSession` (authenticated during connection upgrade)\n     - His session isn't expired (checked against `sessionTTL`)\n     - He has permission to join the room (in this basic implementation, all public rooms are joinable)\n   - The server extracts Bob's current `roomId` from his `ClientSession` (may be `null` if he's in no room, or a previous room if he's switching).\n\n3. **Room Transition Management**\n   - If Bob is currently in another room (e.g., \"random\"):\n     - The server calls `RoomManager.leaveRoom(connectionId, previousRoomId)`\n     - This removes Bob's `connectionId` from the `memberIds` Set of \"random\"\n     - Broadcasts `EVENT_USER_LEFT` to remaining members of \"random\"\n     - Updates Bob's `ClientSession.roomId` to `null`\n   - The server now processes the join request by calling `RoomManager.joinRoom(connectionId, \"general\", userId)`\n\n4. **Room Membership Update**\n   - The Room Manager retrieves or creates room \"general\":\n     - If the room doesn't exist, `createRoom(\"general\")` is called, initializing an empty `memberIds` Set.\n   - Bob's `connectionId` is added to the room's `memberIds` Set.\n   - Bob's `ClientSession.roomId` is updated to \"general\".\n   - The Room Manager retrieves the list of current member user IDs (excluding Bob) for later notification.\n\n5. **History Retrieval**\n   - The Room Manager calls `getRecentMessagesForRoom(\"general\", limit)` where `limit` is configurable (e.g., 50 messages).\n   - The Persistence Service queries the database for messages where `roomId = \"general\"`, ordered by `timestamp` descending, limited to 50.\n   - Results are returned as an array of complete `ChatMessage` objects with server-generated IDs and timestamps.\n   - The messages are sorted ascending (oldest first) for logical presentation to the user.\n\n6. **Presence Notification to Existing Members**\n   - The Room Manager creates a `user_joined` notification containing:\n     - `userId`: Bob's username\n     - `roomId`: \"general\"\n     - `timestamp`: Current server time\n     - (Optional) `userCount`: Updated member count\n   - `RoomManager.broadcastToRoom(\"general\", notification, excludeConnectionId)` is called where `excludeConnectionId` is Bob's connection ID (he doesn't need to notify himself).\n   - All existing room members receive the `EVENT_USER_JOINED` message and update their UI to show Bob as present (add to member list, possibly show \"Bob joined\" system message).\n\n7. **Join Success Response to Joining User**\n   - The server prepares a comprehensive \"room_joined\" success response containing:\n     - `room`: Room details (name, ID, member count)\n     - `members`: Array of current member usernames (for populating the sidebar)\n     - `history`: The retrieved message history array\n     - `timestamp`: Server time of join completion\n   - `ConnectionManager.sendToClient` delivers this specifically to Bob's connection.\n\n8. **Client-Side State Synchronization**\n   - Bob's client receives the \"room_joined\" response and:\n     - Updates the current room view to show \"general\" as active\n     - Populates the message history area with the 50 historical messages (oldest at top, newest at bottom)\n     - Updates the member sidebar with the list of current members\n     - (Optional) Marks any unread indicators for this room as read\n   - The client may now enable the message input box (previously disabled if not in a room).\n\n9. **Post-Join Cleanup and Optimization**\n   - The server may perform maintenance:\n     - Clean up empty rooms if all members have left (configurable policy)\n     - Update room activity timestamp for \"least recently used\" tracking\n     - Log the join event for analytics (optional)\n\n**Critical Design Insight:**\n> The join operation is **atomic from the user's perspective** but involves multiple non-atomic steps internally. We carefully sequence operations to ensure Bob receives history before any new messages sent after his join, preventing race conditions where he might miss messages sent during his join process.\n\n**Data Flow Table: Room Join Operations**\n\n| Step | Component Involved | Data Transformed | State Change |\n|------|-------------------|------------------|--------------|\n| 1. Client request | Client Application | UI event → `WebSocketMessage` | Client marks room as \"joining\" (disables UI) |\n| 2. Auth validation | Connection Manager | Validates session against `ClientSession` store | None (verification only) |\n| 3. Leave previous room | Room Manager | Removes `connectionId` from previous room's `memberIds` | Previous room member count decreases |\n| 4. Join new room | Room Manager | Adds `connectionId` to new room's `memberIds` | New room member count increases |\n| 5. History retrieval | Persistence Service | Database query → `ChatMessage[]` | None (read-only) |\n| 6. Notify existing members | Room Manager → Connection Manager | Creates `user_joined` event, broadcasts | Other clients update their member lists |\n| 7. Send success response | Connection Manager → Client | Packages room data, members, history | Client updates full UI state |\n| 8. UI update | Client Application | Renders history, updates room context | User can now participate |\n\n**Common Edge Cases and Handling:**\n\n| Scenario | System Response | Rationale |\n|----------|----------------|-----------|\n| **Room doesn't exist** | Room Manager creates it with Bob as first member | Lazy room creation simplifies UX; rooms exist only when needed |\n| **User already in room** | Server sends current room state without re-joining | Idempotent operation prevents duplicate notifications |\n| **History too large** | Pagination: only recent messages sent initially | Prevents overwhelming client with thousands of messages |\n| **Network timeout during join** | Client may retry with idempotent join request | Join operation designed to be safely repeatable |\n| **User banned from room** | Server rejects join with error message (future enhancement) | Basic implementation allows all joins; permission system would intercept here |\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option (Learning Focus) | Advanced Option (Production Ready) |\n|-----------|-------------------------------|-----------------------------------|\n| Message Validation | Manual field-by-field checks in JavaScript | JSON Schema validation with libraries like `ajv` |\n| History Pagination | Fixed `LIMIT` clause in SQL query | Cursor-based pagination with timestamp offsets |\n| Member List Sync | Send full list on each join/leave | Differential updates using patch operations |\n| Error Recovery | Simple retry with exponential backoff | Circuit breaker pattern with fallback responses |\n\n**B. Recommended File Structure:**\n\n```\nreal-time-chat/\n├── server/\n│   ├── index.js                    # Main server entry point\n│   ├── connection/\n│   │   ├── manager.js              # ConnectionManager class\n│   │   ├── lifecycle.js            # Connection event handlers\n│   │   └── validation.js           # parseAndValidateWebSocketMessage, etc.\n│   ├── rooms/\n│   │   ├── manager.js              # RoomManager class (implements broadcast, join, leave)\n│   │   ├── presence.js             # Typing indicators, online status\n│   │   └── history.js              # Message history retrieval logic\n│   ├── auth/\n│   │   ├── service.js              # Authentication service (login, register)\n│   │   ├── sessions.js             # Session management (create, validate, invalidate)\n│   │   └── middleware.js           # WebSocket upgrade authentication\n│   └── persistence/\n│       ├── messageStore.js         # storeMessage, getMessagesForRoom\n│       ├── userStore.js            # User CRUD operations\n│       └── database.js             # Database connection setup\n├── client/\n│   ├── public/\n│   │   ├── index.html              # Main HTML file\n│   │   ├── app.js                  # Main client application logic\n│   │   ├── ui.js                   # DOM manipulation and rendering\n│   │   └── ws-client.js            # WebSocket connection management\n│   └── package.json                # Client dependencies (if using build tools)\n└── package.json                    # Server dependencies\n```\n\n**C. Infrastructure Starter Code (Complete Validation Utilities):**\n\n```javascript\n// server/connection/validation.js\n\n/**\n * Parses and validates a raw WebSocket message string\n * @param {string} rawMessage - Raw string received from WebSocket\n * @returns {WebSocketMessage} Parsed and validated message object\n * @throws {Error} If message is invalid JSON or missing required fields\n */\nfunction parseAndValidateWebSocketMessage(rawMessage) {\n  if (typeof rawMessage !== 'string') {\n    throw new Error('Message must be a string');\n  }\n\n  let parsed;\n  try {\n    parsed = JSON.parse(rawMessage);\n  } catch (err) {\n    throw new Error(`Invalid JSON: ${err.message}`);\n  }\n\n  if (!parsed.type || typeof parsed.type !== 'string') {\n    throw new Error('Message must have a string \"type\" field');\n  }\n\n  if (parsed.payload === undefined) {\n    throw new Error('Message must have a \"payload\" field');\n  }\n\n  // Optional timestamp validation\n  if (parsed.timestamp && !isValidISODate(parsed.timestamp)) {\n    throw new Error('Invalid timestamp format, expected ISO string');\n  }\n\n  return {\n    type: parsed.type,\n    payload: parsed.payload,\n    timestamp: parsed.timestamp || new Date().toISOString()\n  };\n}\n\n/**\n * Validates a ChatMessage payload structure\n * @param {any} payload - The payload to validate\n * @returns {ChatMessage} Validated chat message\n * @throws {Error} If payload doesn't match ChatMessage structure\n */\nfunction validateChatMessagePayload(payload) {\n  if (!payload || typeof payload !== 'object') {\n    throw new Error('Payload must be an object');\n  }\n\n  if (!payload.sender || typeof payload.sender !== 'string') {\n    throw new Error('Payload must have a string \"sender\" field');\n  }\n\n  if (!payload.content || typeof payload.content !== 'string') {\n    throw new Error('Payload must have a string \"content\" field');\n  }\n\n  if (!payload.roomId || typeof payload.roomId !== 'string') {\n    throw new Error('Payload must have a string \"roomId\" field');\n  }\n\n  if (payload.content.length > MAX_MESSAGE_LENGTH) {\n    throw new Error(`Message content exceeds maximum length of ${MAX_MESSAGE_LENGTH} characters`);\n  }\n\n  // Allow client to send ID and timestamp, but they will be overwritten by server\n  return {\n    sender: payload.sender,\n    content: payload.content.trim(), // Trim whitespace\n    roomId: payload.roomId,\n    id: payload.id || 0, // Temporary, will be replaced\n    timestamp: payload.timestamp || null // Will be replaced by server\n  };\n}\n\n/**\n * Creates a properly formatted server-originated WebSocket message\n * @param {string} type - Message type (use EVENT_* constants)\n * @param {any} payload - The payload to send\n * @returns {WebSocketMessage} Formatted message ready for JSON.stringify\n */\nfunction createServerMessage(type, payload) {\n  return {\n    type,\n    payload,\n    timestamp: new Date().toISOString()\n  };\n}\n\n/**\n * Creates a new ChatMessage with server-generated ID and timestamp\n * @param {string} sender - Username of sender\n * @param {string} content - Message content (already validated)\n * @param {string} roomId - Room identifier\n * @returns {ChatMessage} Complete chat message object\n */\nfunction createChatMessage(sender, content, roomId) {\n  return {\n    id: generateMessageId(), // Implement this (could be sequential or UUID)\n    sender,\n    content: content.trim(),\n    roomId,\n    timestamp: new Date().toISOString()\n  };\n}\n\n// Helper function for ID generation (simple sequential for learning)\nlet messageIdCounter = 1;\nfunction generateMessageId() {\n  return messageIdCounter++;\n}\n\n// Helper function for ISO date validation\nfunction isValidISODate(dateString) {\n  return !isNaN(Date.parse(dateString));\n}\n\nmodule.exports = {\n  parseAndValidateWebSocketMessage,\n  validateChatMessagePayload,\n  createServerMessage,\n  createChatMessage,\n  MAX_MESSAGE_LENGTH: 1000\n};\n```\n\n**D. Core Logic Skeleton Code:**\n\n```javascript\n// server/rooms/manager.js\n\nclass RoomManager {\n  constructor(messageStore, connectionManager) {\n    this.rooms = new Map(); // roomId -> Room object\n    this.messageStore = messageStore;\n    this.connectionManager = connectionManager;\n  }\n\n  /**\n   * Adds a user to a room, fetches history, and notifies other members\n   * @param {string} connectionId - The WebSocket connection ID\n   * @param {string} roomId - Room identifier to join\n   * @param {string} userId - Authenticated user ID\n   * @returns {Promise<Room>} The joined room object\n   */\n  async joinRoom(connectionId, roomId, userId) {\n    // TODO 1: Validate parameters (non-empty strings)\n    // TODO 2: Get or create the room (check this.rooms Map, create if missing using createRoom)\n    // TODO 3: Check if user is already in room (optional optimization)\n    // TODO 4: Add connectionId to room.memberIds Set\n    // TODO 5: Fetch recent message history (call this.messageStore.getRecentMessagesForRoom)\n    // TODO 6: Get list of current member user IDs (excluding the joining user)\n    // TODO 7: Create user_joined notification using createServerMessage(EVENT_USER_JOINED, ...)\n    // TODO 8: Broadcast notification to all other room members using this.broadcastToRoom\n    // TODO 9: Prepare success response with room info, members list, and history\n    // TODO 10: Return room object for further processing\n  }\n\n  /**\n   * Sends a message to all members of a room, optionally excluding sender\n   * @param {string} roomId - Target room identifier\n   * @param {ChatMessage} message - The chat message to broadcast\n   * @param {string} [excludeConnectionId] - Optional connection ID to exclude (usually sender)\n   * @returns {void}\n   */\n  broadcastToRoom(roomId, message, excludeConnectionId) {\n    // TODO 1: Validate roomId exists in this.rooms Map\n    // TODO 2: Get the room object and its memberIds Set\n    // TODO 3: Convert memberIds Set to array for iteration\n    // TODO 4: For each connectionId in memberIds:\n    //   a. Skip if connectionId === excludeConnectionId\n    //   b. Get WebSocket via this.connectionManager.getSocket(connectionId)\n    //   c. Check socket is open (readyState === WebSocket.OPEN)\n    //   d. Create formatted message using createServerMessage(EVENT_CHAT_MESSAGE, message)\n    //   e. Send via this.connectionManager.sendToClient(connectionId, formattedMessage)\n    // TODO 5: Log broadcast statistics (optional)\n  }\n\n  /**\n   * Removes a user from a room and notifies remaining members\n   * @param {string} connectionId - The WebSocket connection ID to remove\n   * @param {string} roomId - Room identifier\n   * @returns {void}\n   */\n  leaveRoom(connectionId, roomId) {\n    // TODO 1: Validate room exists in this.rooms Map\n    // TODO 2: Remove connectionId from room.memberIds Set\n    // TODO 3: If room is now empty, consider cleanup (optional: delete room or mark inactive)\n    // TODO 4: Create user_left notification using createServerMessage(EVENT_USER_LEFT, ...)\n    // TODO 5: Broadcast notification to remaining room members\n    // TODO 6: Update connection's session to reflect leaving room (via connectionManager)\n  }\n\n  /**\n   * Updates and broadcasts a user's typing status in a room\n   * @param {string} connectionId - The WebSocket connection ID\n   * @param {string} roomId - Room identifier\n   * @param {boolean} isTyping - Whether user is currently typing\n   * @returns {void}\n   */\n  setUserTyping(connectionId, roomId, isTyping) {\n    // TODO 1: Validate user is actually in the specified room\n    // TODO 2: Create typing notification with user info and isTyping flag\n    // TODO 3: Broadcast to room members excluding the typing user\n    // TODO 4: (Advanced) Implement debouncing to prevent spam - only send if state changed\n    // TODO 5: (Advanced) Set timeout to automatically send \"stopped typing\" after inactivity\n  }\n}\n\nmodule.exports = RoomManager;\n```\n\n```javascript\n// server/connection/manager.js\n\nclass ConnectionManager {\n  constructor() {\n    this.connections = new Map(); // connectionId -> ClientSession\n  }\n\n  /**\n   * Main entry point for handling incoming WebSocket messages\n   * @param {string} connectionId - The connection ID (from socket)\n   * @param {string} rawMessage - Raw WebSocket message string\n   * @returns {void}\n   */\n  handleMessage(connectionId, rawMessage) {\n    // TODO 1: Look up ClientSession from this.connections using connectionId\n    // TODO 2: Parse and validate raw message using parseAndValidateWebSocketMessage\n    // TODO 3: Validate user session is still active (check lastActivity against sessionTTL)\n    // TODO 4: Route message based on type:\n    //   - If type === 'chat_message': validate payload, create chat message, store, broadcast\n    //   - If type === 'join_room': extract roomId, call roomManager.joinRoom\n    //   - If type === 'typing': extract roomId and isTyping, call roomManager.setUserTyping\n    //   - Unknown type: send error response\n    // TODO 5: Update lastActivity timestamp in ClientSession\n    // TODO 6: Handle any errors: send appropriate error message to client, log error\n  }\n\n  /**\n   * Sends a message to a specific client if their socket is open\n   * @param {string} connectionId - Target connection ID\n   * @param {WebSocketMessage} message - Message to send\n   * @returns {boolean} True if message was sent, false if socket not open\n   */\n  sendToClient(connectionId, message) {\n    // TODO 1: Look up ClientSession from this.connections\n    // TODO 2: Get WebSocket from ClientSession.socket\n    // TODO 3: Check socket.readyState === WebSocket.OPEN\n    // TODO 4: If open: socket.send(JSON.stringify(message)), return true\n    // TODO 5: If not open: return false (connection will be cleaned up by heartbeat check)\n    // TODO 6: Wrap in try-catch for network errors\n  }\n}\n\nmodule.exports = ConnectionManager;\n```\n\n**E. Language-Specific Hints (JavaScript/Node.js):**\n\n1. **WebSocket State Checking**: Always check `socket.readyState === WebSocket.OPEN` before sending. The WebSocket protocol has states: CONNECTING (0), OPEN (1), CLOSING (2), CLOSED (3).\n\n2. **Error Handling in Async Flow**: Use try-catch blocks around database operations and JSON parsing. Send descriptive error messages to clients for debugging but log full errors server-side.\n\n3. **Set Operations for Membership**: JavaScript's `Set` is ideal for `memberIds` because it ensures uniqueness and has O(1) add/delete/has operations. Convert to array only when needed for iteration.\n\n4. **Timestamp Consistency**: Use `new Date().toISOString()` for all server-generated timestamps. This produces UTC time in a standard format that's easily sortable and timezone-agnostic.\n\n5. **Connection Cleanup**: Implement periodic cleanup (every 30 seconds) to remove stale connections by checking `ClientSession.lastActivity` against current time.\n\n**F. Milestone Checkpoint for Message Flow:**\n\n**After implementing Milestone 2 (Message Broadcasting):**\n\n1. **Start the server**: `node server/index.js`\n2. **Open two browser tabs** to `http://localhost:3000`\n3. **Log in with different usernames** in each tab\n4. **Send a message from Tab 1** and verify:\n   - Message appears in Tab 1's chat window (echo from server optional)\n   - Message appears in Tab 2's chat window within ~100ms\n   - Message shows correct sender name and timestamp\n   - Console logs show no validation errors\n5. **Test edge cases**:\n   - Send empty message → should be rejected\n   - Send message > 1000 characters → should be rejected\n   - Disconnect Tab 2 network → message should fail to deliver but not crash server\n   - Reconnect Tab 2 → should see message in history when rejoining room\n\n**G. Debugging Tips for Data Flow Issues:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Messages appear only for sender** | `broadcastToRoom` is excluding everyone | Log `memberIds` size before and after exclusion | Check `excludeConnectionId` logic; verify room membership |\n| **History loads but real-time messages don't appear** | Client not handling `EVENT_CHAT_MESSAGE` events | Check client WebSocket `onmessage` handler | Add handler for `type === 'chat_message'` |\n| **User count wrong after join/leave** | Race condition in member tracking | Add debug logs to `joinRoom` and `leaveRoom` | Ensure atomic operations or add mutex for room updates |\n| **Messages appear out of order** | Multiple messages processed concurrently | Log server timestamps vs arrival order | Sort by timestamp on client side before display |\n| **Join takes long time** | History query is slow with many messages | Profile database query time | Add index on `(roomId, timestamp)` columns |\n\n---\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (1-4). Robust error handling and edge case management are critical for the stability and reliability of the real-time chat system, ensuring graceful degradation when things go wrong rather than catastrophic failure.\n\nImagine a busy office building where the telephone system suddenly fails—calls drop mid-conversation, some lines get crossed, and occasionally wrong numbers slip through. A well-designed system has contingency plans: operators who can reconnect calls, verification procedures to prevent wrong connections, and capacity limits to avoid overload. Similarly, our chat application must anticipate and handle failures gracefully because real-time systems operate in an inherently unreliable environment—networks fail, servers crash, users send invalid data, and edge cases emerge under load. This section details how the system detects, responds to, and recovers from expected failures and unexpected conditions.\n\n### Common Failure Modes and Recovery\n\nThe chat system faces several predictable failure modes. Proactively designing for these scenarios prevents cascading failures and maintains user experience. Our approach follows the principle of **defensive programming**: validate everything, assume nothing, and always have a recovery path.\n\n#### Network Drops and Unclean Disconnections\n\n**Mental Model: The Frayed Telephone Cord**  \nThink of WebSocket connections as physical telephone cords that can be accidentally unplugged or fray over time. The server needs to detect when a cord is cut (connection lost) and clean up the call (user session) to avoid \"ghost users\" lingering in rooms.\n\nNetwork failures are the most common issue in distributed systems. Clients may lose connectivity due to Wi-Fi drops, mobile network switching, or firewall timeouts without sending a proper WebSocket close frame.\n\n| Failure Mode | Detection Method | Recovery Strategy | Rationale |\n|--------------|------------------|-------------------|-----------|\n| **Silent Connection Death** (client disappears without `onclose`) | Heartbeat (ping/pong) mechanism: Server sends periodic ping; if no pong received within timeout, marks connection dead | Server proactively cleans up connection state via `ConnectionManager.removeConnection()`; broadcasts `EVENT_USER_LEFT` to affected rooms | Prevents memory leaks and ensures presence accuracy without relying on TCP timeouts (which can be minutes) |\n| **Intermittent Network Flakiness** (brief packet loss) | Multiple missed heartbeats or repeated WebSocket frame errors | Client implements exponential backoff reconnection logic; server maintains session briefly during short outages (30-60 seconds) | Balances quick recovery with avoiding churn for temporary issues; exponential backoff prevents overwhelming server during network restoration |\n| **Asymmetric Connectivity** (client can receive but not send) | Client-side heartbeat: client sends periodic \"alive\" messages; server notices missing messages | Server eventually treats as dead connection after timeout; client detects send failures and initiates reconnection | Detects one-way failures that server ping might miss (since pings require round-trip) |\n\n**Architecture Decision Record: Implementing Heartbeat vs. Relying on TCP Keepalive**\n\n> **Decision: Application-Level Heartbeat Over TCP Keepalive**\n> - **Context**: WebSocket connections can appear open at TCP level while the application is stuck (browser tab frozen, mobile app backgrounded). We need to detect actual application liveliness, not just TCP connectivity.\n> - **Options Considered**:\n>   1. **Rely solely on TCP keepalive**: Use operating system TCP keepalive packets (default 2 hours idle timeout).\n>   2. **WebSocket protocol ping/pong**: Use built-in WebSocket control frames (RFC 6455 Section 5.5.2).\n>   3. **Application-level heartbeat messages**: Custom `{type: \"heartbeat\"}` messages in the chat protocol.\n> - **Decision**: Use WebSocket protocol ping/pong frames for connection health, supplemented with application-level activity tracking.\n> - **Rationale**: WebSocket ping/pong is standardized, doesn't clutter application message protocol, and works across all WebSocket implementations. Application-level activity tracking (last message timestamp) helps distinguish idle from dead connections. TCP keepalive is too slow (hours vs seconds).\n> - **Consequences**: Requires WebSocket library that exposes ping/pong API; adds periodic server workload; ensures connections are cleaned within 30-60 seconds of failure.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| TCP Keepalive | No application code, operating system handles it | Extremely slow detection (default 2+ hours), not configurable per-connection | ❌ |\n| WebSocket Ping/Pong | Standardized, efficient (control frames), most libraries support | Some browser WebSocket APIs don't expose ping/pong to JavaScript | ✅ Primary |\n| Application Heartbeat | Full control, works everywhere, can carry metadata | Adds to message count, requires protocol design, redundant with ping/pong | ✅ Supplementary |\n\n**Implementation Strategy**:\n1. Server sends ping every 25 seconds to each connection\n2. If no pong received within 30 seconds, mark connection as stale\n3. After 60 seconds total (two missed cycles), forcibly close connection and clean up\n4. Track `lastActivity` timestamp in `ClientSession` updated on any message receive\n5. Background cleaner runs every minute to remove sessions inactive > 60 seconds\n\n#### Server Crashes and Restarts\n\n**Mental Model: The Office Power Outage**  \nWhen the power goes out in an office building, everything stops instantly. When power returns, systems need to reboot, restore essential services, and notify people that there was an interruption.\n\nServer crashes (unhandled exceptions, OOM killer, deployment restarts) terminate all in-memory state. The recovery focus is on data persistence and graceful client reconnection.\n\n| Failure Mode | Detection Method | Recovery Strategy | Rationale |\n|--------------|------------------|-------------------|-----------|\n| **Process Crash** (Node.js uncaught exception) | Process exits; process manager (PM2, systemd) detects exit | Process manager restarts server; server reloads persistent data (rooms, messages); clients automatically reconnect | Minimizes downtime; stateless WebSocket connections require full client reconnection |\n| **Memory Exhaustion** (OOM) | Monitoring memory usage approaching limits | Implement connection limits (`maxConnections`), message size limits, and aggressive cleanup of idle connections | Prevents catastrophic failure; allows server to reject new connections rather than crash |\n| **Dependency Failure** (database connection lost) | Database client library emits error events | Continue serving existing connections with degraded functionality (no history queries); queue or drop persistence operations | Graceful degradation maintains real-time chat while persistence is temporarily unavailable |\n\n**Recovery Procedure on Server Startup**:\n1. Load recent messages from database for active rooms (cached in memory)\n2. Recreate room structures from persisted room definitions (if stored)\n3. Initialize empty connection maps (all clients must reconnect)\n4. Begin accepting new WebSocket connections\n5. Optional: Broadcast \"server was restarted\" to reconnected clients\n\n> **Key Insight**: The system is designed to be **mostly stateless at the connection layer**. All essential state (messages, user accounts, room definitions) persists to storage, while ephemeral state (who's currently connected, typing status) rebuilds as clients reconnect. This aligns with the **Twelve-Factor App** principle of disposable processes.\n\n#### Malformed and Malicious Messages\n\n**Mental Model: The Mailroom Screening Process**  \nEvery incoming package passes through security screening: checking for hazardous materials, verifying sender identity, and ensuring proper addressing. Similarly, every WebSocket message undergoes validation before processing.\n\nMalformed messages (invalid JSON, missing fields) and malicious payloads (injection attempts, enormous strings) can crash the server or exploit vulnerabilities if not properly handled.\n\n| Failure Mode | Detection Method | Recovery Strategy | Rationale |\n|--------------|------------------|-------------------|-----------|\n| **Invalid JSON Syntax** | `JSON.parse()` throws SyntaxError in `parseAndValidateWebSocketMessage()` | Catch exception, send error response `{type: \"error\", payload: {code: \"INVALID_JSON\"}}` to client, keep connection open | Prevents server crash; informs client of protocol violation without disconnecting |\n| **Schema Violation** (missing required fields, wrong types) | `validateChatMessagePayload()` checks structure against expected schema | Reject message with descriptive error, log for monitoring, continue processing other messages | Maintains protocol consistency; helps developers debug client implementation |\n| **Message Too Large** (exceeds `MAX_MESSAGE_LENGTH`) | Check `payload.content.length` before validation | Immediately reject without full parsing, send error, optionally disconnect abusive clients | Protects against memory exhaustion attacks and network congestion |\n| **Injection Attempts** (JavaScript, HTML in messages) | Client-side sanitization preferred; server validation for critical fields | Store raw content but escape before sending to other clients; log suspicious patterns | Allows flexibility in client rendering while preventing XSS in web clients |\n\n**Message Validation Pipeline** (referencing ![Flowchart: Server Message Handling](./diagrams/flowchart-message-handling.svg)):\n\n1. **Raw Message Reception**: `ConnectionManager.handleMessage()` receives string\n2. **Syntax Validation**: `parseAndValidateWebSocketMessage()` attempts JSON parsing\n   - Failure → Send error response, stop processing\n3. **Structure Validation**: Verify `WebSocketMessage` has `type` and `payload` fields\n   - Missing → Send error, stop\n4. **Type-Specific Validation**: Route to appropriate validator based on `type`\n   - `EVENT_CHAT_MESSAGE` → `validateChatMessagePayload()` checks sender, content length, roomId\n   - `EVENT_USER_TYPING` → Validate boolean flag and room membership\n5. **Business Logic Validation**: Check application state (is user in room? authenticated?)\n6. **Processing**: Only after all validation passes, execute handler\n\n**Error Response Format**:\n```javascript\n// Server sends this when message validation fails\n{\n  type: \"error\",\n  payload: {\n    code: \"VALIDATION_ERROR\", // or \"NOT_IN_ROOM\", \"UNAUTHENTICATED\"\n    message: \"Content exceeds maximum length of 1000 characters\",\n    originalType: \"chat_message\", // The failed message type\n    timestamp: \"2023-10-05T14:30:00Z\"\n  }\n}\n```\n\n#### Resource Exhaustion (Memory, CPU, File Descriptors)\n\n**Mental Model: The Concert Venue Capacity Manager**  \nA venue has maximum capacity for safety. When full, new attendees wait in line. Staff monitor crowd density and may ask overly rowdy patrons to leave. Similarly, the server must enforce limits to remain stable.\n\nNode.js has single-threaded event loop and memory constraints. Resource exhaustion can degrade performance for all users or cause complete failure.\n\n| Resource | Monitoring | Protection Strategy | Mitigation |\n|----------|------------|-------------------|------------|\n| **Memory** | `process.memoryUsage()`, monitor RSS | Limit concurrent connections; implement message size limits; use efficient data structures (`Map` over `Object`, `Set` for member lists) | Connection rejection when near limit; aggressive garbage collection by clearing message history caches |\n| **CPU** | Event loop lag measurement; profiling | Rate limiting per connection (messages/second); offload expensive operations (password hashing) to worker threads | Shed load by rejecting new connections; use efficient algorithms (O(1) lookups in connection maps) |\n| **File Descriptors** | `ulimit` monitoring; connection count tracking | Set `maxConnections` below system limit (typically 65% of `ulimit -n`) | Graceful degradation: \"Server busy\" response during HTTP upgrade |\n| **Database Connections** | Connection pool metrics | Implement connection pooling with reasonable max; queue operations when pool exhausted | Return partial functionality (real-time works, history may fail) |\n\n**Architecture Decision Record: In-Memory State vs. External Storage for Active Connections**\n\n> **Decision: In-Memory Connection State with Single-Server Simplicity**\n> - **Context**: The learning-focused chat application runs as a single Node.js process. We need to track all active WebSocket connections, their room memberships, and typing status.\n> - **Options Considered**:\n>   1. **Pure in-memory**: Store everything in process memory using `Map` and `Set` collections.\n>   2. **Shared Redis**: Store connection state in Redis for potential multi-server scaling.\n>   3. **Hybrid approach**: Critical state (room membership) in Redis, ephemeral state (typing) in memory.\n> - **Decision**: Pure in-memory state for all connection data.\n> - **Rationale**: For the learning context and single-server deployment, in-memory is simpler with zero external dependencies, faster (no network latency), and sufficient for hundreds to thousands of concurrent connections. The complexity of distributed state management outweighs benefits at this scale.\n> - **Consequences**: Server restart loses all connection state (users must reconnect); vertical scaling only (single server); cannot scale horizontally without redesign.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Pure In-Memory | Simplest, fastest, no external dependencies | Lost on server restart, doesn't scale horizontally | ✅ For learning context |\n| Shared Redis | Survives server restarts, enables horizontal scaling | Additional infrastructure, network latency, complexity | ❌ Over-engineering |\n| Hybrid | Balances performance and durability | Increased complexity, consistency challenges | ❌ Intermediate complexity not justified |\n\n### Edge Case Analysis\n\nEdge cases are unusual but valid scenarios that test the boundaries of the system design. Proper handling distinguishes a robust system from a fragile one.\n\n#### Duplicate Usernames and Connection Conflicts\n\n**Scenario**: Two users register with the same username \"Alice\", or the same user logs in from two devices (browser and phone).\n\n| Edge Case | Problem | Solution |\n|-----------|---------|----------|\n| **Registration Duplicate** | Two users with identical `username` in database | Unique constraint on `username` field in database; `registerUser()` returns error \"Username taken\" |\n| **Simultaneous Connections** Same user from multiple devices | Both connections receive messages; typing indicators conflict; presence shows as single user | Treat each connection independently: separate `ClientSession` objects, both receive broadcasts, typing status from either device shows as \"Alice is typing\" |\n| **Same Username in Same Room** | Confusion about which user sent a message | Use unique internal `userId` (database ID) for all routing; display username but include `userId` in message metadata for disambiguation |\n| **Username Change While Connected** | Other users see old username in cached messages | Store `userId` in `ChatMessage`, not username; fetch current username from database when displaying historical messages |\n\n**Handling Algorithm for Multiple Connections**:\n1. When user authenticates, create new `ClientSession` with unique `connectionId`\n2. Both sessions have same `userId` but different `connectionId`\n3. `RoomManager.broadcastToRoom()` sends to all connections in room\n4. Typing indicator: `setUserTyping()` updates status per `connectionId`, broadcasts to room\n5. User leaves: only remove specific `connectionId` from room; user remains in room if other connections exist\n6. All connections close: `leaveAllRooms()` called for each, user fully removed\n\n#### Message Size and Rate Extremes\n\n**Scenario**: A user pastes a 10MB text file, or a bot sends 1000 messages per second.\n\n| Edge Case | Problem | Solution |\n|-----------|---------|----------|\n| **Extremely Long Message** (> `MAX_MESSAGE_LENGTH`) | Network congestion, database bloat, UI rendering issues | Server enforces `MAX_MESSAGE_LENGTH` (1000 chars) in `validateChatMessagePayload()`; client also validates before sending |\n| **Rapid Message Flood** from single connection | Event loop blocking, other users overwhelmed with notifications | Rate limiting: track messages per second per connection; delay or drop excess messages with error \"Rate limit exceeded\" |\n| **Empty Messages** (zero-length or whitespace-only) | Spam, confusing UI display | Validation requires `content.trim().length > 0`; reject with descriptive error |\n| **Special Character Bomb** (emojis, Unicode) | Encoding issues, storage size mismatch (UTF-8 vs byte length) | Count Unicode code points, not bytes, for length limit; normalize encoding before storage |\n\n**Rate Limiting Implementation**:\n```javascript\n// In ConnectionManager\nconst messageCounts = new Map(); // connectionId -> {count, resetTime}\n\nfunction checkRateLimit(connectionId) {\n  const now = Date.now();\n  let record = messageCounts.get(connectionId);\n  \n  if (!record || now > record.resetTime + 60000) {\n    // New minute window\n    record = { count: 0, resetTime: now };\n    messageCounts.set(connectionId, record);\n  }\n  \n  record.count++;\n  return record.count <= 100; // 100 messages per minute limit\n}\n```\n\n#### Rapid Join/Leave Churn\n\n**Scenario**: A user rapidly joins and leaves a room, or a script creates/destroys rooms quickly.\n\n| Edge Case | Problem | Solution |\n|-----------|---------|----------|\n| **Join-Leave Loop** (user spamming enter/exit) | Notification storms for other users; unnecessary database queries for history | Debounce join operations: ignore repeated `joinRoom` calls within 1 second for same user+room |\n| **Room Creation Flood** | Exhaustion of resources, polluted room lists | Limit room creation rate per user; require unique room names; auto-cleanup empty rooms after timeout |\n| **Concurrent Join from Multiple Devices** | Race conditions in member list updates | Use atomic operations: `Room.memberIds` as `Set` with `add()`/`delete()`; broadcast only after successful addition |\n| **Leave During Join** (user leaves while history is loading) | Orphaned operations, inconsistent state | Cancel pending history fetch if connection closes; verify user still in room before broadcasting join notification |\n\n**Debouncing Algorithm for Room Operations**:\n```javascript\n// In RoomManager\nconst lastJoinTime = new Map(); // userId+roomId -> timestamp\n\nasync function joinRoom(connectionId, roomId, userId) {\n  const key = `${userId}:${roomId}`;\n  const now = Date.now();\n  const lastTime = lastJoinTime.get(key) || 0;\n  \n  if (now - lastTime < 1000) { // 1 second debounce\n    throw new Error('Please wait before rejoining');\n  }\n  \n  lastJoinTime.set(key, now);\n  // ... rest of join logic\n}\n```\n\n#### Clock Skew and Message Ordering\n\n**Scenario**: Client and server clocks differ by minutes, or messages arrive out of order due to network latency.\n\n| Edge Case | Problem | Solution |\n|-----------|---------|----------|\n| **Client Clock Wrong** (behind/ahead) | Message timestamps inconsistent across users | Always use server-assigned timestamp (`Date.now()` on server) in `createChatMessage()`; ignore client-provided timestamps |\n| **Network Reordering** (later message arrives first) | Chat history shows messages out of logical order | Use monotonic increasing message IDs (database sequence) for ordering; timestamp for display only |\n| **Daylight Saving Time Changes** | Displayed times jump forward/backward | Store all timestamps in UTC ISO format; convert to local time only at display layer (client-side) |\n| **High-Precision Timing** (multiple messages in same millisecond) | Indistinguishable ordering at millisecond level | Use composite key: `timestamp + sequence` or database auto-increment ID |\n\n> **Key Insight**: **Server-generated timestamps** are non-negotiable for consistency. The server acts as the \"single source of truth\" for temporal ordering. Clients may display relative times (\"2 minutes ago\") to mask small synchronization issues.\n\n#### Empty Rooms and Zombie Connections\n\n**Scenario**: All users leave a room but it persists in memory, or connections remain in lists after network failure.\n\n| Edge Case | Problem | Solution |\n|-----------|---------|----------|\n| **Empty Room Accumulation** | Memory leak, polluted room listing | Background job removes rooms with `memberIds.size === 0` after 24 hours (or shorter for temporary rooms) |\n| **Zombie Connections** in member lists | Users appear present but cannot receive messages | `RoomManager` validates connection existence before broadcasting; periodic cleanup removes dead connections from all rooms |\n| **Room Name Collisions** (case sensitivity) | \"General\" vs \"general\" treated as different rooms | Normalize room names: lowercase, trim before storage; case-insensitive matching for joins |\n| **Special Character Room Names** | Injection, URL encoding issues | Sanitize room names: allow alphanumeric, hyphens, underscores; reject special characters |\n\n**Room Cleanup Algorithm**:\n1. Every hour, scan all rooms in `RoomManager`\n2. For rooms with `memberIds.size === 0`:\n   - If room created > 24 hours ago, delete it\n   - If temporary room (prefixed with \"temp-\"), delete immediately\n3. For rooms with members, verify each `connectionId` still exists in `ConnectionManager`\n4. Remove invalid connections from room membership\n\n#### Authentication and Session Edge Cases\n\n**Scenario**: User logs out on one device while active on another, or session expires mid-conversation.\n\n| Edge Case | Problem | Solution |\n|-----------|---------|----------|\n| **Session Expiry During Connection** | User suddenly unauthenticated; messages fail | Periodic session validation in heartbeat; on expiration, send `{type: \"session_expired\"}` and close WebSocket |\n| **Concurrent Logout from Another Device** | Race condition: which session wins? | Session invalidation removes all sessions for user; all connections receive logout notification |\n| **Reused Session Token** (theft/replay) | Unauthorized access | Store sessions in database with expiry; one-time use tokens or token rotation on sensitive operations |\n| **Password Change with Active Sessions** | Old sessions remain valid (security risk) | Invalidate all sessions on password change; require re-authentication on all devices |\n\n**Session Validation in Message Flow**:\n1. Each incoming message includes session token (in WebSocket upgrade or first message)\n2. `ConnectionManager` validates token via `validateSession()` before routing\n3. If invalid/expired: send error, close connection with code 4001 (custom: \"Session expired\")\n4. Background job `cleanupExpiredSessions()` runs hourly to purge old sessions\n\n### Implementation Guidance\n\n#### Technology Recommendations for Error Handling\n\n| Component | Simple Option (Learning) | Production-Ready Option |\n|-----------|--------------------------|-------------------------|\n| Connection Heartbeat | Manual ping/pong using `setInterval` and WebSocket `.ping()` | `ws` library built-in heartbeat with configurable intervals |\n| Rate Limiting | In-memory counter with fixed window | Redis-based sliding window with `redis-cell` or token bucket algorithm |\n| Validation | Manual `if` statements checking each field | JSON Schema validation with `ajv` or `zod` for TypeScript |\n| Error Tracking | Console logging | Structured logging with `winston`/`pino` + error aggregation (Sentry) |\n| Process Management | Manual `node server.js` | Process manager (PM2, systemd) with auto-restart and monitoring |\n\n#### Recommended Error Handling Module Structure\n\n```\nproject-root/\n  src/\n    server/\n      connection-manager.js       ← Heartbeat, rate limiting, validation\n      room-manager.js            ← Room cleanup, debouncing logic\n      auth-service.js            ← Session validation, cleanup\n      persistence/               ← Database error handling\n        message-store.js\n        session-store.js\n      middleware/                ← Validation middleware\n        validate-message.js\n        rate-limiter.js\n      errors/                    ← Custom error classes\n        chat-errors.js\n        validation-errors.js\n      utils/\n        logger.js                ← Structured logging\n```\n\n#### Core Error Handling Skeleton Code\n\n**Complete Starter: Custom Error Classes**\n\n```javascript\n// src/errors/chat-errors.js\n\n/**\n * Base class for all chat application errors\n */\nclass ChatError extends Error {\n  constructor(message, code, statusCode = 400) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code; // Machine-readable error code\n    this.statusCode = statusCode; // HTTP-like status for WebSocket close\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n/**\n * Thrown when message validation fails\n */\nclass ValidationError extends ChatError {\n  constructor(message, field) {\n    super(message, 'VALIDATION_ERROR', 400);\n    this.field = field; // Which field failed validation\n  }\n}\n\n/**\n * Thrown when user is not authenticated\n */\nclass AuthenticationError extends ChatError {\n  constructor(message = 'Authentication required') {\n    super(message, 'UNAUTHENTICATED', 401);\n  }\n}\n\n/**\n * Thrown when user lacks permission for an operation\n */\nclass AuthorizationError extends ChatError {\n  constructor(message = 'Permission denied') {\n    super(message, 'FORBIDDEN', 403);\n  }\n}\n\n/**\n * Thrown when resource not found (room, user, message)\n */\nclass NotFoundError extends ChatError {\n  constructor(resourceType, id) {\n    super(`${resourceType} \"${id}\" not found`, 'NOT_FOUND', 404);\n    this.resourceType = resourceType;\n    this.resourceId = id;\n  }\n}\n\n/**\n * Thrown when rate limit exceeded\n */\nclass RateLimitError extends ChatError {\n  constructor(retryAfterSeconds) {\n    super('Rate limit exceeded', 'RATE_LIMITED', 429);\n    this.retryAfter = retryAfterSeconds;\n  }\n}\n\nmodule.exports = {\n  ChatError,\n  ValidationError,\n  AuthenticationError,\n  AuthorizationError,\n  NotFoundError,\n  RateLimitError\n};\n```\n\n**Complete Starter: Structured Logger**\n\n```javascript\n// src/utils/logger.js\n\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.Console({\n      format: winston.format.combine(\n        winston.format.colorize(),\n        winston.format.simple()\n      )\n    }),\n    new winston.transports.File({ \n      filename: 'logs/error.log', \n      level: 'error',\n      maxsize: 5242880, // 5MB\n      maxFiles: 5\n    }),\n    new winston.transports.File({ \n      filename: 'logs/combined.log',\n      maxsize: 5242880,\n      maxFiles: 5\n    })\n  ]\n});\n\n// Helper for logging WebSocket events\nlogger.connection = (connectionId, event, details = {}) => {\n  logger.info({\n    type: 'connection',\n    connectionId,\n    event,\n    ...details\n  });\n};\n\n// Helper for logging chat events\nlogger.chat = (roomId, event, details = {}) => {\n  logger.info({\n    type: 'chat',\n    roomId,\n    event,\n    ...details\n  });\n};\n\nmodule.exports = logger;\n```\n\n**Core Logic Skeleton: Enhanced Message Validation**\n\n```javascript\n// src/middleware/validate-message.js\n\nconst { ValidationError } = require('../errors/chat-errors');\nconst { MAX_MESSAGE_LENGTH } = require('../constants');\n\n/**\n * Parse and validate raw WebSocket message string\n * @param {string} rawMessage - Raw message from WebSocket\n * @returns {WebSocketMessage} - Parsed and validated message object\n * @throws {ValidationError} - If message fails validation\n */\nfunction parseAndValidateWebSocketMessage(rawMessage) {\n  // TODO 1: Check if rawMessage is a string, throw ValidationError if not\n  // TODO 2: Trim the message and check if empty, throw if empty\n  // TODO 3: Try to parse JSON using JSON.parse, catch SyntaxError and throw ValidationError\n  // TODO 4: Validate parsed object has required fields: type (string) and payload (object)\n  // TODO 5: Validate type is one of allowed events (EVENT_CHAT_MESSAGE, EVENT_USER_JOINED, etc.)\n  // TODO 6: Return the validated WebSocketMessage object\n}\n\n/**\n * Validate chat message payload structure\n * @param {object} payload - The payload from chat_message event\n * @returns {ChatMessage} - Validated chat message data\n * @throws {ValidationError} - If payload fails validation\n */\nfunction validateChatMessagePayload(payload) {\n  // TODO 1: Check payload is an object, throw if not\n  // TODO 2: Validate required fields exist: sender (string), content (string), roomId (string)\n  // TODO 3: Validate content length <= MAX_MESSAGE_LENGTH, throw if too long\n  // TODO 4: Validate content is not just whitespace (trim().length > 0)\n  // TODO 5: Validate sender is not empty string\n  // TODO 6: Validate roomId matches pattern (alphanumeric, hyphens, underscores)\n  // TODO 7: Return the validated payload (will be used to create ChatMessage)\n}\n\n/**\n * Enhanced message handler with comprehensive error handling\n * @param {string} connectionId - The connection ID\n * @param {string} rawMessage - Raw WebSocket message\n * @returns {void}\n */\nfunction handleMessage(connectionId, rawMessage) {\n  try {\n    // TODO 1: Parse and validate the message using parseAndValidateWebSocketMessage\n    // TODO 2: Check rate limit for this connection, throw RateLimitError if exceeded\n    // TODO 3: Validate user session (call validateSession with token from connection)\n    // TODO 4: Route to appropriate handler based on message.type\n    // TODO 5: Catch any errors thrown during handler execution\n  } catch (error) {\n    // TODO 6: Log the error with appropriate level (warn for client errors, error for server errors)\n    // TODO 7: If error is a ChatError, send formatted error response to client\n    // TODO 8: If error is unexpected (TypeError, etc.), log with stack trace and send generic error\n    // TODO 9: For certain errors (AuthenticationError), close the WebSocket connection\n  }\n}\n```\n\n**Core Logic Skeleton: Connection Heartbeat Implementation**\n\n```javascript\n// src/server/connection-manager.js\n\nclass ConnectionManager {\n  constructor() {\n    this.connections = new Map(); // connectionId -> ClientSession\n    this.heartbeatInterval = 25000; // 25 seconds\n    this.heartbeatTimeout = 30000; // 30 seconds timeout\n    this.cleanupInterval = 60000; // Cleanup every minute\n  }\n\n  /**\n   * Start heartbeat for a connection\n   * @param {string} connectionId - The connection ID\n   * @param {WebSocket} socket - The WebSocket instance\n   */\n  startHeartbeat(connectionId, socket) {\n    // TODO 1: Create a ping interval that sends WebSocket ping every heartbeatInterval\n    // TODO 2: Track last pong time in ClientSession (update on 'pong' event)\n    // TODO 3: Set up timeout checker that verifies last pong was within heartbeatTimeout\n    // TODO 4: If timeout exceeded, call this.removeConnection(connectionId, 'heartbeat_timeout')\n  }\n\n  /**\n   * Periodic cleanup of stale connections\n   */\n  startCleanupJob() {\n    setInterval(() => {\n      const now = Date.now();\n      for (const [connectionId, session] of this.connections) {\n        // TODO 1: Check if session.lastActivity older than 60 seconds\n        // TODO 2: Check if heartbeat timeout exceeded (last pong too old)\n        // TODO 3: If stale, remove connection with reason 'inactive'\n      }\n    }, this.cleanupInterval);\n  }\n}\n```\n\n#### Language-Specific Hints for JavaScript/Node.js\n\n1. **WebSocket Ping/Pong**: Use `ws` library's built-in support:\n   ```javascript\n   const WebSocket = require('ws');\n   const wss = new WebSocket.Server({ clientTracking: true });\n   \n   wss.on('connection', (ws) => {\n     ws.isAlive = true;\n     \n     ws.on('pong', () => {\n       ws.isAlive = true;\n     });\n     \n     // Heartbeat interval\n     const interval = setInterval(() => {\n       if (ws.isAlive === false) {\n         return ws.terminate();\n       }\n       ws.isAlive = false;\n       ws.ping();\n     }, 30000);\n     \n     ws.on('close', () => {\n       clearInterval(interval);\n     });\n   });\n   ```\n\n2. **Error Propagation**: Use async/await with try/catch:\n   ```javascript\n   async function handleJoinRoom(connectionId, roomId) {\n     try {\n       const room = await roomManager.joinRoom(connectionId, roomId);\n       sendToClient(connectionId, { type: 'room_joined', payload: room });\n     } catch (error) {\n       if (error instanceof ChatError) {\n         // Expected error, send to client\n         sendToClient(connectionId, createServerMessage('error', {\n           code: error.code,\n           message: error.message\n         }));\n       } else {\n         // Unexpected, log and send generic error\n         logger.error('Unexpected error in joinRoom', { error, connectionId });\n         sendToClient(connectionId, createServerMessage('error', {\n           code: 'INTERNAL_ERROR',\n           message: 'Something went wrong'\n         }));\n       }\n     }\n   }\n   ```\n\n3. **Rate Limiting with Redis** (advanced):\n   ```javascript\n   const redis = require('redis');\n   const client = redis.createClient();\n   \n   async function rateLimit(connectionId, limit = 100, windowMs = 60000) {\n     const key = `rate_limit:${connectionId}`;\n     const now = Date.now();\n     const windowStart = now - windowMs;\n     \n     // Remove old timestamps\n     await client.zremrangebyscore(key, 0, windowStart);\n     \n     // Count requests in current window\n     const requestCount = await client.zcard(key);\n     \n     if (requestCount >= limit) {\n       throw new RateLimitError(Math.ceil(windowMs / 1000));\n     }\n     \n     // Add current request\n     await client.zadd(key, now, now);\n     await client.expire(key, Math.ceil(windowMs / 1000));\n     \n     return { remaining: limit - requestCount - 1 };\n   }\n   ```\n\n#### Debugging Tips for Error Scenarios\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Messages not appearing for some users** | User not in room member list; connection dead but not cleaned | Check `Room.memberIds` contains connectionId; verify `lastActivity` timestamp | Ensure `joinRoom` updates member list; implement heartbeat cleanup |\n| **User count wrong (shows offline users)** | Connection cleanup not running; zombie connections in member list | Log when connections are removed; check heartbeat is working | Implement periodic cleanup job; verify ping/pong events firing |\n| **Server crashes on malformed message** | No try/catch in message handler; JSON.parse without validation | Add error handling wrapper; validate before parsing | Implement `parseAndValidateWebSocketMessage` with try/catch |\n| **Memory usage grows indefinitely** | Connections not cleaned up; message history not paginated | Monitor connection count; check room cleanup job | Implement connection limits; paginate history queries |\n| **Users receive own messages** | `broadcastToRoom` not excluding sender | Check `excludeConnectionId` parameter is passed correctly | Verify broadcast logic excludes sender connection |\n| **Typing indicator never disappears** | Timeout not cleared; client not sending stop event | Log typing events; check timer cleanup on disconnect | Implement debouncing with clearTimeout; handle disconnect cleanup |\n\n#### Milestone Checkpoint for Error Handling\n\nAfter implementing error handling, verify by:\n\n1. **Test Network Failure Simulation**:\n   ```bash\n   # Start server\n   npm start\n   \n   # In browser, open chat and send messages\n   # Then simulate network drop (turn off Wi-Fi, or use browser DevTools to go offline)\n   # Wait 30+ seconds, then restore network\n   # Expected: Server should clean up user after ~60 seconds; user should auto-reconnect\n   ```\n\n2. **Test Malformed Messages**:\n   ```bash\n   # Use WebSocket CLI tool or browser console\n   const ws = new WebSocket('ws://localhost:3000');\n   ws.onopen = () => {\n     ws.send('not json'); // Should get error response\n     ws.send('{\"type\":\"chat_message\",\"payload\":{}}'); // Missing fields\n     ws.send('A'.repeat(2000)); // Too long\n   };\n   # Expected: Server responds with error messages, doesn't crash\n   ```\n\n3. **Verify Rate Limiting**:\n   ```bash\n   # Script to send 200 messages quickly\n   # Expected: After ~100 messages, get rate limit error\n   ```\n\n4. **Check Memory Usage**:\n   ```bash\n   # Monitor Node.js process\n   node -e \"setInterval(() => console.log(process.memoryUsage()), 1000)\" &\n   # Connect many clients, send messages, disconnect\n   # Expected: Memory returns to baseline after connections close\n   ```\n\nSigns of correct implementation:\n- Server remains running despite invalid inputs\n- Error messages are descriptive and help debug\n- Connections are cleaned up automatically\n- Memory usage stabilizes over time\n\n---\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (1-4). Testing is an integral part of building a reliable real-time chat system. This section provides a practical, learning-focused approach to verifying your implementation works correctly, with emphasis on integration testing and manual verification checkpoints aligned with each milestone.\n\nTesting a real-time WebSocket application presents unique challenges compared to traditional HTTP APIs. Connections are stateful, events occur asynchronously, and timing issues can create subtle bugs. This testing strategy balances rigor with practicality for learners, focusing on **integration testing** (verifying components work together) and **manual verification** (observing system behavior) while providing a foundation for more advanced testing patterns.\n\n### Testing Approach and Property Verification\n\n**Mental Model: The Airport Control Tower and Flight Simulator**\nThink of testing this chat system like operating an airport control tower. **Unit tests** are like checking individual aircraft systems in isolation (fuel gauge, landing gear). **Integration tests** are like simulating takeoff and landing procedures with multiple systems interacting. **Manual verification** is like the control tower operator watching actual flights move on radar, confirming the whole system works as expected. For learning, we prioritize the control tower view (integration) while ensuring critical individual systems (units) function correctly.\n\n#### Testing Layers and Focus Areas\n\nOur testing pyramid for this project has three layers with increasing realism but decreasing automation:\n\n| Layer | What It Tests | How We'll Implement | Primary Goal |\n|-------|---------------|---------------------|--------------|\n| **Unit Tests** | Individual functions and classes in isolation | Jest/Node.js test files mocking dependencies | Verify core logic (message parsing, validation, business rules) |\n| **Integration Tests** | Components working together (e.g., ConnectionManager + RoomManager) | Test server with in-memory WebSocket clients | Verify event flow and state synchronization |\n| **Manual Verification** | End-to-end system behavior with real browsers | Multiple browser tabs connecting to your running server | Build intuition and catch UI/experience issues |\n\nFor this learning project, we emphasize **integration testing** because WebSocket systems derive most bugs from component interactions rather than isolated logic. However, we'll write unit tests for critical validation and transformation functions.\n\n#### Key Properties to Verify\n\nThese are the fundamental guarantees your system must maintain. Each property can be tested through specific scenarios:\n\n| Property | Why It Matters | How to Test |\n|----------|----------------|-------------|\n| **Message Ordering** | Users expect messages to appear in the order they were sent, not delivery order | Send messages M1, M2, M3 from same client; verify receivers see same sequence |\n| **At-Most-Once Delivery** | Messages shouldn't duplicate, causing confusing repeated messages | Send same message rapidly multiple times; verify only one appears |\n| **User Removal on Disconnect** | Prevent \"ghost users\" who appear online but disconnected | Connect user, verify in member list, disconnect, verify removed within 5 seconds |\n| **Room Isolation** | Messages in Room A must not leak to Room B | Create two rooms, send message in Room A, verify users in Room B don't receive it |\n| **History Integrity** | New users should see accurate past conversation | Send messages, disconnect all users, new user joins, should see same messages |\n| **Presence Accuracy** | Typing indicators and online status must reflect current reality | User starts typing, indicator appears; stops typing for 3 seconds, indicator disappears |\n| **Authentication Enforcement** | Unauthenticated users cannot send/receive messages | Try to send message without valid session; connection should be rejected or ignored |\n| **Connection Resilience** | Network drops shouldn't break application state | Disconnect network for 10 seconds, reconnect, verify automatic rejoin and state recovery |\n\n#### Integration Testing Strategy\n\nFor integration tests, we'll simulate the complete system with these components:\n\n1. **Test Server Instance**: A real WebSocket server running on a test port\n2. **Mock Clients**: Programmatic WebSocket clients that can send/receive messages\n3. **Test Orchestrator**: Code that coordinates scenarios and asserts outcomes\n\nThe test pattern follows this sequence:\n\n```\n1. Start test server with clean state\n2. Connect mock Client A and Client B via WebSocket\n3. Authenticate both clients (simulate login)\n4. Have both clients join the same room\n5. Client A sends a chat message\n6. Verify Client B receives the message with correct fields\n7. Clean up connections and server\n```\n\n> **Design Insight**: Integration tests for WebSocket systems are inherently stateful and asynchronous. Use explicit timeouts and await patterns rather than fixed sleeps. Each test should clean up completely to prevent test pollution.\n\n#### ADR: Choosing Integration Tests Over Unit Tests for Core Components\n\n> **Decision: Prioritize Integration Testing for Component Interactions**\n> - **Context**: WebSocket chat systems involve complex interactions between connection management, room membership, and message routing. Bugs often emerge at component boundaries rather than within isolated functions.\n> - **Options Considered**:\n>   1. **Primarily unit tests** with extensive mocking of WebSocket and database dependencies\n>   2. **Balanced approach** with unit tests for pure functions and integration tests for components\n>   3. **Primarily integration tests** with real WebSocket connections and in-memory stores\n> - **Decision**: Option 3 (primarily integration tests) for core components, with unit tests only for pure validation/utility functions\n> - **Rationale**: \n>   - Integration tests verify the actual event flow and message passing that unit tests with mocks might miss\n>   - Real WebSocket behavior (connection drops, buffering) is difficult to mock accurately\n>   - For learning, seeing the whole system work builds better intuition than passing unit tests with mocked dependencies\n>   - The relatively small codebase makes integration test execution fast enough\n> - **Consequences**:\n>   - Tests are more realistic but potentially more brittle to timing issues\n>   - Test setup/teardown is more complex (requires starting actual server)\n>   - Encourages designing components with clear interfaces for testability\n\n| Option | Pros | Cons | Why Not Chosen |\n|--------|------|------|----------------|\n| Primarily unit tests | Fast execution, isolated failures | Misses integration issues, complex mocks | Doesn't test real WebSocket behavior |\n| Balanced approach | Tests both logic and integration | More test code to maintain, context switching | Good but heavier for learning focus |\n| **Primarily integration tests** | **Tests real interactions, builds system intuition** | **Slower, timing-sensitive** | **Chosen: Best for learning real-time system behavior** |\n\n### Milestone Implementation Checkpoints\n\nEach milestone has clear acceptance criteria. These checkpoints help you verify your implementation meets them before moving forward. Think of these as **flight checks** before taking off to the next milestone.\n\n#### Milestone 1: WebSocket Server Setup Checkpoint\n\n**Expected Behavior**: Your server accepts WebSocket connections, tracks active clients, handles disconnections, and doesn't crash on malformed messages.\n\n**Verification Steps**:\n\n1. **Start the server**:\n   ```bash\n   node server.js\n   ```\n   Expected output: \"WebSocket server listening on port 8080\" (or your chosen port)\n\n2. **Test basic connection** using browser DevTools:\n   - Open Chrome/Firefox, press F12, go to Console tab\n   - Create WebSocket connection:\n     ```javascript\n     const ws = new WebSocket('ws://localhost:8080');\n     ws.onopen = () => console.log('Connected!');\n     ws.onmessage = (event) => console.log('Received:', event.data);\n     ```\n   - Expected: \"Connected!\" appears in console\n   - Check server logs: Should show \"New connection from [IP]\"\n\n3. **Verify connection tracking**:\n   - Open 3 browser tabs, run connection code in each\n   - Send a test message from one client:\n     ```javascript\n     ws.send(JSON.stringify({type: 'ping', payload: 'test'}));\n     ```\n   - Check server logs: Should show message received and handled\n   - Close one tab, check server logs within 2 seconds: Should show \"Connection closed\" or similar\n\n4. **Test error resilience**:\n   - With a client connected, send invalid JSON:\n     ```javascript\n     ws.send('{ malformed json }');\n     ```\n   - Expected: Server doesn't crash, may send error response or close connection gracefully\n   - Send extremely long message (>1MB):\n     ```javascript\n     ws.send('x'.repeat(1000000));\n     ```\n   - Expected: Server rejects or handles without memory issues\n\n**Success Indicators**:\n- ✅ Server starts without errors\n- ✅ Multiple clients can connect simultaneously\n- ✅ Server logs show connect/disconnect events\n- ✅ Invalid messages don't crash server\n- ✅ All connections cleaned up when tabs close\n\n**Common Pitfalls at This Stage**:\n- ⚠️ **Port already in use**: Change port or kill previous process\n- ⚠️ **No server logs for connections**: Check WebSocket upgrade handling in HTTP server\n- ⚠️ **Connections never show as closed**: Ensure `socket.on('close')` handler removes from connection tracking\n\n#### Milestone 2: Message Broadcasting Checkpoint\n\n**Expected Behavior**: Messages broadcast to all room members, include proper metadata (sender, timestamp), and typing indicators work.\n\n**Verification Steps**:\n\n1. **Set up test scenario** with three browser tabs (User A, User B, Observer):\n   - Each tab connects and joins the same default room (implement simple join for now)\n   - Use different usernames in each tab's connection\n\n2. **Test message broadcasting**:\n   - User A sends: `{\"type\": \"chat_message\", \"payload\": {\"content\": \"Hello everyone\"}}`\n   - Expected: User B and Observer receive message with:\n     - Correct content\n     - Sender field showing User A's username\n     - Recent timestamp (within last second)\n     - User A should NOT receive their own message back\n\n3. **Test typing indicators**:\n   - User A sends: `{\"type\": \"typing_start\", \"payload\": {\"roomId\": \"default\"}}`\n   - Expected: User B and Observer receive typing indicator with User A's username\n   - Wait 3 seconds: User B and Observer should receive `typing_stop` automatically\n   - Alternative: User A sends `typing_stop` manually after 1 second\n\n4. **Test join/leave notifications**:\n   - Open fourth tab (User D), join room\n   - Expected: Users A, B, Observer receive `user_joined` notification\n   - User D leaves (close tab or send leave message)\n   - Expected: Remaining users receive `user_left` within 5 seconds\n\n**Success Indicators**:\n- ✅ Messages appear in all other clients but not sender\n- ✅ Each message has sender, content, and ISO timestamp\n- ✅ Typing indicators appear and clear automatically\n- ✅ Join/leave events trigger notifications\n- ✅ Server logs show broadcast counts (e.g., \"Broadcasting to 2 clients\")\n\n**Advanced Verification Script**:\nCreate a simple Node.js test script that automates this verification:\n\n```javascript\n// test-broadcast.js - Basic verification script\nconst WebSocket = require('ws');\n// Implementation details would go here\n```\n\n#### Milestone 3: Chat Rooms Checkpoint\n\n**Expected Behavior**: Users can create/join rooms, messages are room-scoped, member lists update correctly, and room listing works.\n\n**Verification Steps**:\n\n1. **Test room creation and joining**:\n   - User A sends: `{\"type\": \"join_room\", \"payload\": {\"roomName\": \"gaming\"}}`\n   - Expected: Server creates \"gaming\" room, User A receives `room_joined` confirmation\n   - User B sends join request for same room\n   - Expected: User B joins, User A receives `user_joined` notification for User B\n\n2. **Verify room isolation**:\n   - User A in \"gaming\" room sends message\n   - User C in \"general\" room (different room) should NOT receive it\n   - User B in \"gaming\" room SHOULD receive it\n\n3. **Test member list accuracy**:\n   - User D joins \"gaming\" room\n   - User A requests member list: `{\"type\": \"get_members\", \"payload\": {\"roomId\": \"gaming\"}}`\n   - Expected: Response includes User A, B, D (all current members)\n   - User B leaves room\n   - User A requests member list again within 5 seconds: Should NOT include User B\n\n4. **Test room listing**:\n   - Create rooms \"gaming\", \"music\", \"random\"\n   - Request room list: `{\"type\": \"get_rooms\", \"payload\": {}}`\n   - Expected: All three rooms listed with correct member counts\n   - Empty room after all users leave should either be removed or show 0 members\n\n5. **Test message history**:\n   - Send 5 messages in \"gaming\" room\n   - New user joins \"gaming\" room\n   - Expected: New user receives last 3-5 messages (configurable) immediately after joining\n\n**Success Indicators**:\n- ✅ Room-specific messaging works (no cross-room leakage)\n- ✅ Member lists accurately reflect current occupants\n- ✅ Room listing shows all active rooms with counts\n- ✅ New room members receive recent message history\n- ✅ Empty rooms don't accumulate or are cleaned up\n\n#### Milestone 4: User Authentication & Persistence Checkpoint\n\n**Expected Behavior**: Users authenticate before chatting, messages persist to database, history loads with pagination, and presence works across reconnections.\n\n**Verification Steps**:\n\n1. **Test authentication requirement**:\n   - Try to connect WebSocket without valid session token\n   - Expected: Connection rejected during HTTP upgrade or immediately closed with error\n   - Properly authenticate via HTTP login first, then connect with session token\n\n2. **Verify message persistence**:\n   - Send 10 messages in a room\n   - Restart the server completely (simulating crash)\n   - Reconnect clients, rejoin room\n   - Expected: Previous 10 messages still available via history\n   - New messages should continue with new IDs/timestamps\n\n3. **Test history pagination**:\n   - Send 25 messages to a room\n   - New user joins, requests history with limit=10\n   - Expected: Receives most recent 10 messages, not first 10\n   - Request older messages with `beforeId` parameter\n   - Expected: Next 10 older messages\n\n4. **Verify presence across sessions**:\n   - User A logs in on Browser Tab 1 (shows as online)\n   - Same user logs in on Browser Tab 2\n   - Expected: Other users see User A as online (single user, multiple connections)\n   - Close Tab 1, User A should remain online (Tab 2 still active)\n   - Close Tab 2, within 10 seconds User A shows as offline\n\n5. **Test typing indicator persistence**:\n   - User A starts typing in room\n   - User B joins room mid-typing\n   - Expected: User B immediately sees User A's typing indicator\n   - User A stops typing, both User B and new user see indicator clear\n\n**Success Indicators**:\n- ✅ Unauthenticated connections rejected\n- ✅ Messages survive server restart\n- ✅ History pagination works (most recent first)\n- ✅ User presence accurate across multiple devices/sessions\n- ✅ Typing indicators synchronized correctly\n\n> **Testing Pro Tip**: Create a **test harness** with these exact verification steps as commented code. As you implement each milestone, uncomment and run the corresponding test block. This builds your test suite incrementally while ensuring backward compatibility.\n\n### Implementation Guidance\n\nThis guidance provides practical code structures and test utilities to implement the testing strategy.\n\n#### A. Technology Recommendations Table\n\n| Component | Simple Option (Learning) | Advanced Option (Production) |\n|-----------|--------------------------|------------------------------|\n| Test Runner | Node.js built-in `assert` + manual scripts | Jest testing framework |\n| WebSocket Client for Tests | `ws` npm package (same as server) | Puppeteer for browser automation |\n| Mock/Stub Library | Manual mock objects | Jest auto-mocking or Sinon.js |\n| Test Coverage | Manual verification checkpoints | Istanbul/NYC for coverage reports |\n| Continuous Testing | Manual re-running of tests | GitHub Actions with automated test suite |\n\n#### B. Recommended File/Module Structure\n\n```\nreal-time-chat/\n├── src/\n│   ├── server.js                    # Main server entry point\n│   ├── connection-manager.js        # Milestone 1 component\n│   ├── room-manager.js              # Milestone 2-3 component  \n│   ├── auth-service.js              # Milestone 4 component\n│   └── message-store.js             # Milestone 4 persistence\n├── tests/\n│   ├── integration/                  # Integration tests\n│   │   ├── connection-manager.test.js\n│   │   ├── room-manager.test.js\n│   │   └── auth-integration.test.js\n│   ├── unit/                        # Unit tests for pure functions\n│   │   ├── validation.test.js\n│   │   ├── message-format.test.js\n│   │   └── crypto-utils.test.js\n│   └── utils/\n│       ├── test-client.js           # Reusable WebSocket test client\n│       └── test-server.js           # Test server setup/teardown\n├── scripts/\n│   ├── test-milestone1.js           # Manual verification scripts\n│   ├── test-milestone2.js\n│   └── benchmark-connections.js     # Optional load testing\n└── package.json\n```\n\n#### C. Test Infrastructure Starter Code\n\nHere's a complete, reusable test client utility for integration tests:\n\n```javascript\n// tests/utils/test-client.js\nconst WebSocket = require('ws');\n\n/**\n * TestWebSocketClient - Programmatic client for integration testing\n * Wraps WebSocket with promise-based methods for easier testing\n */\nclass TestWebSocketClient {\n  constructor(url) {\n    this.url = url;\n    this.socket = null;\n    this.messageQueue = [];\n    this.messageHandlers = new Map();\n    this.connectPromise = null;\n  }\n\n  /**\n   * Connect to the server with optional authentication token\n   */\n  connect(token = null) {\n    const url = token ? `${this.url}?token=${token}` : this.url;\n    this.socket = new WebSocket(url);\n    \n    this.connectPromise = new Promise((resolve, reject) => {\n      this.socket.on('open', () => {\n        console.log(`Test client connected to ${url}`);\n        resolve();\n      });\n      \n      this.socket.on('error', (error) => {\n        reject(new Error(`Connection failed: ${error.message}`));\n      });\n      \n      this.socket.on('message', (rawData) => {\n        try {\n          const message = JSON.parse(rawData.toString());\n          this.messageQueue.push(message);\n          \n          // Call any registered handlers for this message type\n          const handlers = this.messageHandlers.get(message.type) || [];\n          handlers.forEach(handler => handler(message));\n        } catch (error) {\n          console.error('Failed to parse message:', rawData.toString());\n        }\n      });\n    });\n    \n    return this.connectPromise;\n  }\n\n  /**\n   * Send a JSON message to the server\n   */\n  send(type, payload) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket not connected');\n    }\n    \n    const message = { type, payload, timestamp: new Date().toISOString() };\n    this.socket.send(JSON.stringify(message));\n    return message;\n  }\n\n  /**\n   * Wait for a specific message type with timeout\n   */\n  waitForMessage(messageType, timeoutMs = 5000) {\n    return new Promise((resolve, reject) => {\n      // Check if message already in queue\n      const existing = this.messageQueue.find(m => m.type === messageType);\n      if (existing) {\n        resolve(existing);\n        return;\n      }\n      \n      // Set up handler for future message\n      const handler = (message) => {\n        if (message.type === messageType) {\n          clearTimeout(timeoutId);\n          resolve(message);\n        }\n      };\n      \n      // Add to handlers\n      if (!this.messageHandlers.has(messageType)) {\n        this.messageHandlers.set(messageType, []);\n      }\n      this.messageHandlers.get(messageType).push(handler);\n      \n      // Set timeout\n      const timeoutId = setTimeout(() => {\n        const handlers = this.messageHandlers.get(messageType) || [];\n        const index = handlers.indexOf(handler);\n        if (index > -1) handlers.splice(index, 1);\n        reject(new Error(`Timeout waiting for message type: ${messageType}`));\n      }, timeoutMs);\n    });\n  }\n\n  /**\n   * Get all received messages of a specific type\n   */\n  getMessagesOfType(messageType) {\n    return this.messageQueue.filter(m => m.type === messageType);\n  }\n\n  /**\n   * Clear the message queue\n   */\n  clearQueue() {\n    this.messageQueue = [];\n  }\n\n  /**\n   * Close the connection\n   */\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.messageHandlers.clear();\n  }\n}\n\nmodule.exports = TestWebSocketClient;\n```\n\n#### D. Core Test Skeleton Code\n\nHere are test skeletons for key integration scenarios:\n\n```javascript\n// tests/integration/room-manager.test.js\nconst TestWebSocketClient = require('../utils/test-client');\nconst { startTestServer, stopTestServer } = require('../utils/test-server');\n\ndescribe('Room Manager Integration Tests', () => {\n  let server;\n  let clientA, clientB, clientC;\n  const TEST_PORT = 8081;\n\n  beforeAll(async () => {\n    // Start test server on separate port\n    server = await startTestServer(TEST_PORT);\n  });\n\n  afterAll(async () => {\n    await stopTestServer(server);\n  });\n\n  beforeEach(async () => {\n    // Create fresh clients for each test\n    clientA = new TestWebSocketClient(`ws://localhost:${TEST_PORT}`);\n    clientB = new TestWebSocketClient(`ws://localhost:${TEST_PORT}`);\n    clientC = new TestWebSocketClient(`ws://localhost:${TEST_PORT}`);\n    \n    // TODO 1: Connect all clients with valid authentication tokens\n    // TODO 2: Set up default usernames for each client\n  });\n\n  afterEach(() => {\n    // Clean up clients\n    if (clientA) clientA.close();\n    if (clientB) clientB.close();\n    if (clientC) clientC.close();\n  });\n\n  test('Messages broadcast to all room members except sender', async () => {\n    // TODO 3: Have clientA and clientB join the same room\n    // TODO 4: Have clientC join a different room\n    // TODO 5: ClientA sends a chat message to the room\n    // TODO 6: Verify clientB receives the message with correct content and sender\n    // TODO 7: Verify clientC does NOT receive the message (different room)\n    // TODO 8: Verify clientA does NOT receive its own message back\n  });\n\n  test('User join/leave notifications work correctly', async () => {\n    // TODO 9: ClientA joins \"test-room\"\n    // TODO 10: ClientB joins \"test-room\" \n    // TODO 11: Verify clientA receives user_joined notification for clientB\n    // TODO 12: ClientB leaves the room\n    // TODO 13: Verify clientA receives user_left notification for clientB\n  });\n\n  test('Message history loads when joining room', async () => {\n    // TODO 14: ClientA joins \"history-room\" and sends 5 messages\n    // TODO 15: ClientB joins \"history-room\"\n    // TODO 16: Verify clientB receives the 5 historical messages (or configured limit)\n    // TODO 17: Verify messages are in correct chronological order\n  });\n});\n```\n\n#### E. Language-Specific Hints (JavaScript/Node.js)\n\n- **Async Testing**: Use `async/await` with proper timeouts. Jest supports async tests natively.\n- **WebSocket Testing**: The `ws` package works in both server and test environments. Remember that WebSocket events are asynchronous.\n- **Mocking**: For unit tests, create simple factory functions that return mock objects:\n  ```javascript\n  const createMockSocket = () => ({\n    send: jest.fn(),\n    close: jest.fn(),\n    readyState: 1, // OPEN\n    on: jest.fn()\n  });\n  ```\n- **Cleaning Up**: Always close WebSocket connections after tests to avoid port exhaustion.\n\n#### F. Milestone Checkpoint Verification Scripts\n\nCreate these scripts to manually verify each milestone:\n\n```javascript\n// scripts/test-milestone1.js - Basic connection verification\nconst WebSocket = require('ws');\nconst readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconsole.log('=== Milestone 1: WebSocket Server Verification ===\\n');\n\nconst ws = new WebSocket('ws://localhost:8080');\n\nws.on('open', function open() {\n  console.log('✅ Connected to server');\n  console.log('1. Connection established');\n  \n  // Test message sending\n  ws.send(JSON.stringify({ type: 'ping', payload: 'test' }));\n  console.log('2. Sent test message');\n  \n  // Wait for any response\n  setTimeout(() => {\n    console.log('3. Connection active for 3 seconds');\n    \n    rl.question('\\nPress Enter to close connection and verify server cleanup...', () => {\n      ws.close();\n      console.log('Connection closed. Check server logs for cleanup message.');\n      console.log('\\n✅ Milestone 1 Verification Complete');\n      console.log('Checklist:');\n      console.log('  - Server accepted connection');\n      console.log('  - Messages can be sent');\n      console.log('  - Server handles disconnection');\n      rl.close();\n    });\n  }, 3000);\n});\n\nws.on('message', function incoming(data) {\n  console.log(`📨 Received: ${data}`);\n});\n\nws.on('error', function error(err) {\n  console.error('❌ Connection error:', err.message);\n  rl.close();\n});\n\nws.on('close', function close() {\n  console.log('🔌 Connection closed by server or client');\n});\n```\n\n#### G. Debugging Tips for Testing\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| **Messages not appearing** | Room membership incorrect or broadcast logic flawed | 1. Check server logs for broadcast count<br>2. Verify receiver is in same room as sender<br>3. Check message payload structure | Ensure `RoomManager.broadcastToRoom` excludes sender and sends to correct member list |\n| **User count wrong after disconnect** | Connection not removed from room membership on disconnect | 1. Check if `ConnectionManager.removeConnection` calls `RoomManager.leaveAllRooms`<br>2. Verify disconnection detection timing | Add explicit cleanup in connection close handler |\n| **Server crashes on invalid JSON** | Missing try-catch in message parsing | 1. Look for unhandled exception in logs<br>2. Check `parseAndValidateWebSocketMessage` error handling | Wrap JSON.parse in try-catch, send error response instead of crashing |\n| **Typing indicators never clear** | Missing timeout or stop event not sent | 1. Check if `setUserTyping` sets/resets timers<br>2. Verify client sends `typing_stop` on blur | Implement server-side timeout (3 seconds) as backup to client events |\n| **History loads wrong messages** | Database query order incorrect or pagination flawed | 1. Check `getMessagesForRoom` ORDER BY clause<br>2. Verify limit and offset calculations | Sort by timestamp DESC for most recent first, use cursor-based pagination |\n| **Authentication bypass possible** | WebSocket upgrade doesn't validate session | 1. Try connecting without token<br>2. Check `authenticateConnection` logic | Validate session during HTTP upgrade before accepting WebSocket connection |\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (1-4)\n\nEven the most carefully designed systems encounter bugs during implementation. This section provides a practical handbook for diagnosing and fixing the most common issues learners face when building this real-time chat system. Think of debugging as detective work: you observe symptoms, form hypotheses about causes, gather evidence through testing, and apply fixes based on your understanding of the system architecture.\n\nWhen building WebSocket applications, bugs often manifest in subtle ways because of the asynchronous, stateful nature of persistent connections. A bug in connection cleanup might not appear until hours of operation, when memory usage balloons. A race condition in room membership might only surface when two users join simultaneously. This guide helps you recognize these patterns early and provides systematic approaches to isolate and fix them.\n\n### Common Bugs: Symptom → Cause → Fix\n\nThe following table catalogs the most frequent issues learners encounter, organized by symptom area. Each entry includes the observable symptom, the likely underlying cause, and step-by-step diagnosis steps leading to a fix.\n\n| Symptom | Likely Cause | Diagnosis Steps | Fix |\n|---------|--------------|-----------------|-----|\n| **Messages not appearing for other users** (but sender sees their own) | The `broadcastToRoom` method is including the sender in the broadcast, or the room membership tracking has incorrect data. | 1. Check the `RoomManager.broadcastToRoom` implementation - is it using `excludeConnectionId` parameter?<br>2. Log the list of connection IDs in the room before broadcasting.<br>3. Verify the sender's connection ID matches their actual connection ID in the room's member set. | Ensure `broadcastToRoom` iterates through `room.memberIds` and skips the `excludeConnectionId`. Verify room membership is updated correctly on join/leave. |\n| **User count wrong in room listing** (shows offline users or misses online ones) | Connection cleanup not removing users from rooms on disconnect, or race condition between join/leave events. | 1. Add logging to `ConnectionManager.removeConnection` to see when it's called.<br>2. Verify `RoomManager.leaveAllRooms(connectionId)` is called in disconnect handler.<br>3. Check for duplicate connection IDs or users joining multiple times. | Implement `ConnectionManager.removeConnection` that calls `RoomManager.leaveAllRooms`. Add connection ID uniqueness validation. |\n| **Server crashes when client disconnects** | Trying to send to or access a socket that has already closed, missing error handlers on WebSocket operations. | 1. Look for `socket.send()` calls without checking `socket.readyState === WebSocket.OPEN`.<br>2. Check if event listeners on closed sockets still fire.<br>3. Look for null/undefined socket references in connection tracking map. | Wrap all `socket.send()` calls with `if (socket.readyState === WebSocket.OPEN)`. Implement `ConnectionManager.sendToClient` with this check. |\n| **Typing indicators never disappear** | No timeout to clear typing status, or timeout not triggering due to event loop issues. | 1. Check `RoomManager.setUserTyping` implementation - is there a `setTimeout` to clear?<br>2. Verify the timeout function has access to current connection ID and room ID.<br>3. Check if multiple timeouts are created without clearing previous ones. | Implement debouncing: store timeout ID per user, clear previous timeout before setting new one. Use `clearTimeout()` in `setUserTyping`. |\n| **Old messages appear multiple times when rejoining room** | Message history loading logic doesn't account for messages already loaded, or pagination cursor logic flawed. | 1. Check `getRecentMessagesForRoom` - is it always returning same N messages?<br>2. Verify client isn't storing and re-displaying old messages.<br>3. Check if message IDs are duplicated in database. | Implement message pagination with `lastMessageId` parameter. Client should track highest message ID received. |\n| **Can't join room with special characters in name** | Room name not sanitized, causing issues with room ID generation or storage key creation. | 1. Check `createRoom` function - how does it generate room ID from name?<br>2. Look for URL-unsafe characters in WebSocket event payloads.<br>3. Test with room names containing spaces, slashes, or Unicode. | Sanitize room names: convert to lowercase, replace spaces with hyphens, remove special characters. Use a separate generated ID for internal storage. |\n| **Memory usage grows continuously** | Connection objects not cleaned up on disconnect, or message history accumulating without bounds. | 1. Monitor `ConnectionManager.connections` map size over time.<br>2. Check if `Room.memberIds` sets grow without removal.<br>3. Verify message store cleanup (`deleteMessagesOlderThan`) is called. | Implement periodic cleanup of orphaned rooms. Add connection timeout for inactive sockets. Ensure all remove/disconnect paths clean up state. |\n| **Authentication fails even with correct credentials** | Password hash comparison failing (timing attack protection), or session token not being properly attached to WebSocket upgrade. | 1. Verify password hashing uses same salt rounds and algorithm.<br>2. Check if authentication token is included in WebSocket upgrade URL.<br>3. Test with a known password hash to isolate hashing issue. | Use constant-time comparison for password hashes. Ensure token is passed in `Sec-WebSocket-Protocol` header or query parameter. |\n| **Messages arrive out of order** | No timestamp or sequence number in message protocol, asynchronous broadcasting causing race conditions. | 1. Check if `ChatMessage.timestamp` uses client time instead of server time.<br>2. Look for parallel `socket.send()` operations without queuing.<br>3. Verify messages are stored with monotonic increasing IDs. | Assign server-side timestamps in `createChatMessage`. Use database auto-increment ID for ordering. Implement client-side message queue. |\n| **Rapid clicking causes duplicate messages** | No client-side debouncing on send button, and no idempotency token in message protocol. | 1. Observe network traffic in browser dev tools - are duplicate WebSocket frames sent?<br>2. Check if UI disables send button during transmission.<br>3. Verify server doesn't process same message ID twice. | Add client-side debouncing (disable button for 500ms). Include unique message ID in payload, reject duplicates on server. |\n| **Server becomes unresponsive after many connections** | No connection limits, no heartbeat to detect dead connections, synchronous operations blocking event loop. | 1. Monitor CPU and memory usage during load test.<br>2. Check for synchronous file I/O or JSON parsing of large messages.<br>3. Verify heartbeat (ping/pong) is implemented and timing out dead connections. | Implement WebSocket ping/pong. Add connection limit per IP. Use asynchronous JSON parsing with try-catch. |\n| **Users see other users' messages from wrong rooms** | Message routing bug - messages sent to all rooms or wrong room ID in broadcast. | 1. Check `ChatMessage.roomId` matches intended room.<br>2. Verify `RoomManager.broadcastToRoom` is called with correct roomId.<br>3. Look for global broadcast instead of room-specific broadcast. | Double-check room assignment in message handler. Add validation that sender is in the room they're messaging. |\n| **\"Welcome\" messages appear for users already in room** | Join notification being sent to the joining user themselves, not just other members. | 1. Check `EVENT_USER_JOINED` broadcast logic - is sender excluded?<br>2. Verify separate welcome message isn't being sent to new user.<br>3. Test with two clients - who receives the join notification? | Ensure `broadcastToRoom` for join notifications uses `excludeConnectionId` parameter. Send separate `room_joined` event to new user. |\n| **Browser tab duplication causes ghost users** | Same session token used in multiple tabs, causing duplicate presence entries. | 1. Open two tabs with same login - do both appear as separate users?<br>2. Check if session validation allows multiple connections.<br>3. Look for user ID to connection ID mapping issues. | Implement one-session-per-connection model. On new connection, disconnect previous connection with same user ID. |\n| **Server crashes on malformed JSON message** | No try-catch in `parseAndValidateWebSocketMessage`, raw message parsing throws exception. | 1. Send invalid JSON via WebSocket client and observe crash.<br>2. Check if error propagates to connection error handler.<br>3. Look for missing validation in message type and payload. | Wrap JSON.parse in try-catch, send error message to client, keep connection alive. Validate all required fields exist and are correct type. |\n| **Clock shows different times for same message** | Using client-provided timestamps instead of server-assigned timestamps. | 1. Compare `ChatMessage.timestamp` in database vs. what client displays.<br>2. Check if client is overriding server timestamp with local time.<br>3. Verify all clients use same timezone display. | Always use server-generated ISO timestamps in `createChatMessage`. Client should display relative time (\"2 minutes ago\") rather than absolute. |\n| **Typing indicator shows for disconnected users** | No cleanup of typing status when user disconnects or leaves room. | 1. Disconnect while typing indicator is active - does it persist?<br>2. Check `RoomManager.leaveRoom` - does it clear typing status?<br>3. Verify timeout clears typing status even if disconnect happens first. | Call `setUserTyping(connectionId, roomId, false)` in `leaveRoom` and `leaveAllRooms`. Store typing status per connection, not per user. |\n\n### Debugging Techniques and Tools\n\nEffective debugging requires both systematic thinking and the right tools. Below are techniques specifically valuable for WebSocket-based real-time systems.\n\n#### Strategic Logging: The Time-Traveling Observer\n\n> Add logs as if you're creating a flight recorder for your application. Each log entry should include: timestamp, connection ID, user ID (if known), room ID (if relevant), and the action being performed.\n\nCreate a logging helper that wraps key operations:\n\n1. **Connection lifecycle logging**: Log when connections open, authenticate, join rooms, send messages, and close. Include the reason for closure (normal, error, timeout).\n2. **State dumps**: Periodically log the size of connection maps, room member counts, and memory usage. This helps identify leaks.\n3. **Message flow tracing**: Assign each message a unique correlation ID and log it at each processing stage (receive, validate, route, store, broadcast).\n\nExample logging strategy table:\n\n| When to Log | What to Include | Why It Helps |\n|-------------|-----------------|--------------|\n| On WebSocket upgrade | `connectionId`, client IP, userAgent | Track connection origins and identify problematic clients |\n| Before/after `broadcastToRoom` | `roomId`, `messageId`, recipient count | Verify messages reach intended recipients |\n| On room join/leave | `connectionId`, `userId`, `roomId`, member count before/after | Debug room membership issues |\n| On heartbeat timeout | `connectionId`, last activity timestamp | Identify zombie connections |\n| On error in message handler | `connectionId`, raw message, error stack | Catch malformed messages before they crash server |\n\n#### Browser WebSocket Inspector: The Conversation Eavesdropper\n\nModern browser developer tools include WebSocket inspectors that let you observe the raw messages flowing between client and server.\n\n**Using Chrome DevTools:**\n1. Open DevTools (F12) → Network tab\n2. Refresh page to establish WebSocket connection\n3. Click the WebSocket request (ws:// or wss://)\n4. View \"Messages\" tab to see frames in real-time\n5. Filter by message type or search content\n\n**What to look for:**\n- Are messages being sent when you expect them?\n- Are the message formats correct (valid JSON)?\n- Is the server responding with expected acknowledgments?\n- Are there error messages from the server?\n- Is the connection closing unexpectedly?\n\n**Pro tip:** You can manually send WebSocket messages from the Console in some browsers using `ws.send(JSON.stringify(...))` to test server responses.\n\n#### Network Failure Simulation: The Chaos Engineer\n\nMany bugs only appear under network instability. Simulate these conditions systematically:\n\n| Technique | How to Simulate | What Bugs It Reveals |\n|-----------|-----------------|----------------------|\n| **Network delay** | Use browser DevTools \"Network Throttling\" or a proxy like Charles | Timeout handling, message ordering issues |\n| **Packet loss** | Use `tc` command on Linux: `tc qdisc add dev eth0 root netem loss 10%` | Message loss, retry logic, heartbeat failures |\n| **Connection interruption** | Temporarily disable WiFi or use browser's \"Offline\" mode | Reconnection logic, state recovery |\n| **Server restart** | Kill and restart server while clients connected | Session recovery, message persistence |\n\n**Systematic testing approach:**\n1. Establish normal chat session with 2-3 clients\n2. Apply network degradation\n3. Observe behavior (do messages queue? do connections recover?)\n4. Restore network\n5. Verify system returns to normal state\n\n#### The Rubber Duck Debugging Variant: Explain Your Architecture\n\nWhen stuck, explain your implementation out loud or in writing, focusing on data flow:\n\n1. \"When Alice sends a message to room 'general':\"\n2. \"Her browser calls `ws.send()` with this JSON structure...\"\n3. \"The server receives it in `ConnectionManager.handleMessage()`...\"\n4. \"It validates using `parseAndValidateWebSocketMessage()`...\"\n5. \"Then calls `RoomManager.broadcastToRoom()` with these parameters...\"\n6. \"Which retrieves the member set from the Room object...\"\n7. \"And for each member except Alice, calls `ConnectionManager.sendToClient()`...\"\n8. \"Which checks `socket.readyState` before sending...\"\n\nOften, the act of verbalizing the expected flow reveals where your implementation diverges.\n\n#### State Visualization: The Whiteboard Method\n\nDraw the current state of your system on a whiteboard or paper:\n\n1. **Connection map**: Draw boxes for each connection ID, with arrows to user IDs and room IDs\n2. **Room membership**: Create a table with rooms as columns and member connections as rows\n3. **Message flow**: Trace a specific message through the system with timestamps\n\nThis is especially helpful for:\n- Understanding why a particular user didn't receive a message\n- Identifying memory leak sources (connections that should have been cleaned up)\n- Visualizing race conditions in join/leave sequences\n\n#### Differential Debugging: The Comparison Technique\n\nWhen something works in one scenario but not another, systematically compare:\n\n1. **Working vs. failing case**: What's different? Different room? Different user? Different message content?\n2. **Before vs. after a change**: What code changed between when it worked and now?\n3. **Local vs. production**: Environment differences (timeouts, memory limits, network config)\n\nCreate a checklist of comparison points:\n- [ ] Connection parameters (authentication token present?)\n- [ ] Room state (does room exist? correct member set?)\n- [ ] Message format (all required fields present?)\n- [ ] Server logs (any errors in one case but not the other?)\n- [ ] Client state (any JavaScript errors in console?)\n\n### Implementation Guidance\n\nThis implementation guidance provides concrete code and techniques to implement the debugging approaches described above.\n\n#### A. Technology Recommendations Table\n\n| Debugging Need | Simple Option | Advanced Option |\n|----------------|---------------|-----------------|\n| Logging | `console.log` with timestamps | Winston or Pino with structured JSON logging |\n| Network Inspection | Browser DevTools | Wireshark or `ws` library packet logger |\n| Memory Profiling | Node.js `--inspect` flag + Chrome DevTools | Clinic.js or New Relic |\n| Load Testing | Manual testing with multiple browser tabs | Artillery or k6 for WebSocket load testing |\n| State Visualization | Manual drawing on whiteboard | Custom admin dashboard showing real-time connections |\n\n#### B. Debug Helper Module Structure\n\nCreate a dedicated debug module to keep instrumentation code organized:\n\n```\nproject-root/\n  src/\n    server/\n      connection-manager.ts    # Main WebSocket server logic\n      room-manager.ts          # Room and presence management\n      debug/                   # Debugging utilities\n        logger.ts              # Structured logging helper\n        state-inspector.ts     # Functions to dump current state\n        test-client.ts         # Programmatic test WebSocket client\n      index.ts                # Server entry point\n```\n\n#### C. Complete Debug Logger Implementation\n\nHere's a complete, ready-to-use structured logger:\n\n```javascript\n// src/server/debug/logger.js\n/**\n * Structured logger for debugging WebSocket chat application\n * Usage: logger.log('connect', { connectionId, userId, ip })\n */\n\nclass DebugLogger {\n  constructor(enableConsole = true, enableFile = false) {\n    this.enableConsole = enableConsole;\n    this.enableFile = enableFile;\n    this.logFile = enableFile ? 'chat-debug.log' : null;\n  }\n\n  /**\n   * Main logging method with structured format\n   * @param {string} event - Event type (connect, message, disconnect, etc.)\n   * @param {Object} data - Structured data about the event\n   * @param {string} level - Log level (info, warn, error, debug)\n   */\n  log(event, data = {}, level = 'info') {\n    const timestamp = new Date().toISOString();\n    const logEntry = {\n      timestamp,\n      event,\n      level,\n      pid: process.pid,\n      ...data\n    };\n\n    // Console output (colored for readability)\n    if (this.enableConsole) {\n      const color = this._getColorForLevel(level);\n      const reset = '\\x1b[0m';\n      console.log(`${color}[${timestamp}] ${event}: ${JSON.stringify(data)}${reset}`);\n    }\n\n    // File output (append)\n    if (this.enableFile && this.logFile) {\n      const fs = require('fs');\n      fs.appendFileSync(this.logFile, JSON.stringify(logEntry) + '\\n');\n    }\n  }\n\n  /**\n   * Helper to get console color for log level\n   */\n  _getColorForLevel(level) {\n    switch (level) {\n      case 'error': return '\\x1b[31m'; // Red\n      case 'warn': return '\\x1b[33m';  // Yellow\n      case 'debug': return '\\x1b[36m'; // Cyan\n      default: return '\\x1b[32m';      // Green (info)\n    }\n  }\n\n  /**\n   * Convenience methods for common events\n   */\n  connectionOpened(connectionId, ip, userAgent) {\n    this.log('connection_opened', { connectionId, ip, userAgent });\n  }\n\n  connectionClosed(connectionId, reason, code) {\n    this.log('connection_closed', { connectionId, reason, code });\n  }\n\n  messageReceived(connectionId, messageType, rawMessage) {\n    this.log('message_received', { \n      connectionId, \n      messageType, \n      messageLength: rawMessage?.length \n    }, 'debug');\n  }\n\n  messageBroadcast(roomId, messageId, recipientCount, excludeConnectionId) {\n    this.log('message_broadcast', { \n      roomId, \n      messageId, \n      recipientCount, \n      excludeConnectionId \n    });\n  }\n\n  roomJoined(connectionId, userId, roomId, memberCount) {\n    this.log('room_joined', { connectionId, userId, roomId, memberCount });\n  }\n\n  roomLeft(connectionId, userId, roomId, memberCount) {\n    this.log('room_left', { connectionId, userId, roomId, memberCount });\n  }\n\n  /**\n   * Dump current server state for debugging\n   * @param {ConnectionManager} connectionManager\n   * @param {RoomManager} roomManager\n   */\n  dumpState(connectionManager, roomManager) {\n    const state = {\n      timestamp: new Date().toISOString(),\n      connections: connectionManager?.connections?.size || 0,\n      rooms: roomManager?.rooms?.size || 0,\n      memoryUsage: process.memoryUsage()\n    };\n    this.log('state_dump', state, 'debug');\n  }\n}\n\n// Singleton instance for easy import\nmodule.exports = new DebugLogger(true, false);\n```\n\n#### D. Test WebSocket Client Skeleton\n\nCreate a programmatic test client to simulate users and automate testing:\n\n```javascript\n// src/server/debug/test-client.js\n/**\n * Programmatic WebSocket client for testing server behavior\n */\n\nconst WebSocket = require('ws');\n\nclass TestWebSocketClient {\n  /**\n   * Create a new test client\n   * @param {string} url - WebSocket server URL\n   */\n  constructor(url) {\n    this.url = url;\n    this.socket = null;\n    this.messageQueue = [];  // Stores received messages\n    this.messageHandlers = new Map();  // Type -> handler function\n    this.connectPromise = null;\n  }\n\n  /**\n   * Connect to the server with optional authentication token\n   * @param {string} token - Optional authentication token\n   * @returns {Promise<void>}\n   */\n  async connect(token = null) {\n    return new Promise((resolve, reject) => {\n      const urlWithToken = token ? `${this.url}?token=${token}` : this.url;\n      this.socket = new WebSocket(urlWithToken);\n      \n      this.socket.on('open', () => {\n        console.log(`Test client connected to ${this.url}`);\n        resolve();\n      });\n      \n      this.socket.on('message', (rawMessage) => {\n        try {\n          const message = JSON.parse(rawMessage);\n          this.messageQueue.push(message);\n          \n          // Call any registered handler for this message type\n          const handler = this.messageHandlers.get(message.type);\n          if (handler) {\n            handler(message.payload);\n          }\n        } catch (error) {\n          console.error('Failed to parse message:', rawMessage);\n        }\n      });\n      \n      this.socket.on('error', (error) => {\n        reject(error);\n      });\n      \n      this.socket.on('close', (code, reason) => {\n        console.log(`Test client disconnected: ${code} - ${reason}`);\n      });\n    });\n  }\n\n  /**\n   * Send a JSON message to the server\n   * @param {string} type - Message type\n   * @param {Object} payload - Message payload\n   */\n  send(type, payload) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      const message = { type, payload, timestamp: new Date().toISOString() };\n      this.socket.send(JSON.stringify(message));\n      return message;\n    } else {\n      throw new Error('WebSocket not connected');\n    }\n  }\n\n  /**\n   * Wait for a specific message type with timeout\n   * @param {string} messageType - Type to wait for\n   * @param {number} timeoutMs - Timeout in milliseconds\n   * @returns {Promise<Object>} - The received message\n   */\n  waitForMessage(messageType, timeoutMs = 5000) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error(`Timeout waiting for ${messageType}`));\n      }, timeoutMs);\n      \n      // Check existing messages first\n      const existing = this.messageQueue.find(m => m.type === messageType);\n      if (existing) {\n        clearTimeout(timeout);\n        resolve(existing);\n        return;\n      }\n      \n      // Set up handler for future messages\n      const handler = (payload) => {\n        clearTimeout(timeout);\n        resolve({ type: messageType, payload });\n      };\n      \n      this.messageHandlers.set(messageType, handler);\n    });\n  }\n\n  /**\n   * Get all received messages of a specific type\n   * @param {string} messageType\n   * @returns {Array}\n   */\n  getMessagesOfType(messageType) {\n    return this.messageQueue.filter(m => m.type === messageType);\n  }\n\n  /**\n   * Disconnect from server\n   */\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  /**\n   * Clear message queue and handlers\n   */\n  clear() {\n    this.messageQueue = [];\n    this.messageHandlers.clear();\n  }\n}\n\nmodule.exports = TestWebSocketClient;\n```\n\n#### E. State Inspector Implementation\n\nAdd this to your ConnectionManager to help debug state issues:\n\n```javascript\n// Add to src/server/connection-manager.js\n\nclass ConnectionManager {\n  // ... existing code ...\n\n  /**\n   * Debug method: Get current connection state for inspection\n   * @returns {Object} - Structured state information\n   */\n  getDebugState() {\n    const connections = [];\n    \n    for (const [connectionId, session] of this.connections) {\n      connections.push({\n        connectionId,\n        userId: session.userId,\n        roomId: session.roomId,\n        ip: session.ip,\n        connectedAt: session.joinedAt,\n        lastActivity: session.lastActivity,\n        readyState: session.socket?.readyState\n      });\n    }\n    \n    return {\n      totalConnections: this.connections.size,\n      connections,\n      serverTime: new Date().toISOString(),\n      memory: process.memoryUsage()\n    };\n  }\n\n  /**\n   * Debug method: Find connections with issues\n   * @returns {Array} - List of problematic connections\n   */\n  findProblematicConnections() {\n    const now = Date.now();\n    const problematic = [];\n    \n    for (const [connectionId, session] of this.connections) {\n      // Check for zombie connections (no activity for > 30 seconds)\n      if (now - session.lastActivity > 30000 && session.socket.readyState === WebSocket.OPEN) {\n        problematic.push({\n          connectionId,\n          issue: 'zombie_connection',\n          lastActivity: session.lastActivity,\n          idleSeconds: Math.floor((now - session.lastActivity) / 1000)\n        });\n      }\n      \n      // Check for connections without users (shouldn't happen after auth)\n      if (!session.userId) {\n        problematic.push({\n          connectionId,\n          issue: 'no_user_id',\n          joinedAt: session.joinedAt\n        });\n      }\n    }\n    \n    return problematic;\n  }\n}\n```\n\n#### F. Debugging Test Scenarios\n\nCreate automated test scenarios to verify fixes work:\n\n```javascript\n// test/debug-scenarios.js\nconst TestWebSocketClient = require('../src/server/debug/test-client');\nconst { wait } = require('./test-utils');\n\nasync function testMessageBroadcast() {\n  console.log('=== Testing Message Broadcast ===');\n  \n  const client1 = new TestWebSocketClient('ws://localhost:8080');\n  const client2 = new TestWebSocketClient('ws://localhost:8080');\n  \n  try {\n    // Connect both clients\n    await client1.connect('user1_token');\n    await client2.connect('user2_token');\n    \n    // Both join same room\n    await client1.send('join_room', { roomId: 'test-room' });\n    await client2.send('join_room', { roomId: 'test-room' });\n    \n    // Wait for join confirmations\n    await client1.waitForMessage('room_joined');\n    await client2.waitForMessage('room_joined');\n    \n    // Client1 sends message\n    const sentMessage = client1.send('chat_message', {\n      content: 'Hello from client1',\n      roomId: 'test-room'\n    });\n    \n    // Client2 should receive it\n    const received = await client2.waitForMessage('chat_message', 2000);\n    \n    if (received.payload.content === 'Hello from client1') {\n      console.log('✅ Message broadcast test PASSED');\n    } else {\n      console.log('❌ Message broadcast test FAILED');\n    }\n    \n  } catch (error) {\n    console.log('❌ Message broadcast test FAILED with error:', error.message);\n  } finally {\n    client1.disconnect();\n    client2.disconnect();\n  }\n}\n\nasync function testConnectionCleanup() {\n  console.log('=== Testing Connection Cleanup ===');\n  \n  const client = new TestWebSocketClient('ws://localhost:8080');\n  \n  try {\n    await client.connect('test_token');\n    await client.send('join_room', { roomId: 'test-room' });\n    \n    // Get initial connection count from server debug endpoint\n    const initialCount = await getConnectionCount();\n    \n    // Disconnect abruptly\n    client.socket.terminate(); // Forceful disconnect\n    \n    // Wait for cleanup\n    await wait(1000);\n    \n    const finalCount = await getConnectionCount();\n    \n    if (finalCount < initialCount) {\n      console.log('✅ Connection cleanup test PASSED');\n    } else {\n      console.log('❌ Connection cleanup test FAILED - count:', initialCount, '->', finalCount);\n    }\n    \n  } catch (error) {\n    console.log('❌ Connection cleanup test FAILED with error:', error.message);\n  }\n}\n\n// Run all debug tests\nasync function runAllDebugTests() {\n  console.log('Starting debug test suite...\\n');\n  \n  await testMessageBroadcast();\n  console.log();\n  await testConnectionCleanup();\n  \n  console.log('\\nDebug test suite completed');\n}\n\n// Helper to get connection count from server\nasync function getConnectionCount() {\n  // Assuming you have a debug HTTP endpoint\n  const response = await fetch('http://localhost:8080/debug/connections');\n  const data = await response.json();\n  return data.totalConnections;\n}\n\n// Run if this file is executed directly\nif (require.main === module) {\n  runAllDebugTests();\n}\n```\n\n#### G. Language-Specific Debugging Hints (JavaScript/Node.js)\n\n1. **WebSocket readyState values:**\n   - `0` (CONNECTING): Socket has been created but connection not yet open\n   - `1` (OPEN): Connection is open and ready to communicate\n   - `2` (CLOSING): Connection is in the process of closing\n   - `3` (CLOSED): Connection is closed or couldn't be opened\n\n2. **Use Node.js inspector:** Run server with `node --inspect server.js`, then open `chrome://inspect` in Chrome to debug with breakpoints.\n\n3. **Memory leak detection:** Use `node --inspect --trace-gc server.js` and monitor garbage collection in Chrome DevTools Memory tab.\n\n4. **Event loop monitoring:** Use `node --trace-event-categories node.perf server.js` to generate timeline trace.\n\n5. **Handle uncaught exceptions:** Always add:\n   ```javascript\n   process.on('uncaughtException', (error) => {\n     console.error('Uncaught exception:', error);\n     // Don't exit - WebSocket servers should try to recover\n   });\n   \n   process.on('unhandledRejection', (reason, promise) => {\n     console.error('Unhandled rejection at:', promise, 'reason:', reason);\n   });\n   ```\n\n#### H. Milestone Debugging Checkpoints\n\nAfter completing each milestone, run these verification tests:\n\n**Milestone 1: WebSocket Server Setup**\n```\nCommand: node server.js\nTest: Open browser console, run: ws = new WebSocket('ws://localhost:8080')\nExpected: Server logs \"connection_opened\", browser shows readyState changes to 1\nDebug: If connection fails, check server is listening, firewall, and CORS headers\n```\n\n**Milestone 2: Message Broadcasting**\n```\nCommand: Open two browser tabs to your chat page\nTest: Send message from Tab 1\nExpected: Message appears in Tab 2 (but not duplicated in Tab 1)\nDebug: Use browser Network tab → WS → Messages to see frames\n```\n\n**Milestone 3: Chat Rooms**\n```\nCommand: Join different rooms in different tabs\nTest: Send message in Room A (Tab 1), check Room B (Tab 2)\nExpected: Message only appears in same room tab\nDebug: Check room IDs in message payloads and member sets\n```\n\n**Milestone 4: Authentication & Persistence**\n```\nCommand: Restart server, reload chat page\nTest: Send messages, restart server, reload page, rejoin room\nExpected: Previous messages loaded from history\nDebug: Check database queries, message timestamps, pagination limits\n\n```\n\n\n## Future Extensions\n> **Milestone(s):** This section explores enhancements that build upon all four milestones, showing how the foundational architecture can evolve to support more sophisticated features and scale.\n\nThe current architecture provides a solid foundation for a real-time chat application that meets the project's learning objectives. However, real-world chat systems often include additional features and face scaling requirements that exceed the initial scope. This section explores potential enhancements, analyzing how the current design accommodates them and what modifications would be necessary. Understanding these extension points helps illustrate how the principles learned—stateful connections, room-based messaging, presence, and persistence—form the basis for more complex systems.\n\n### Potential Features and Scaling Paths\n\nThe journey from a learning project to a production-ready chat system involves adding user-facing features and addressing scalability limitations. The following enhancements are organized by their impact on the architecture: from simple feature additions that fit within the current component boundaries, to significant architectural changes required for horizontal scaling.\n\n#### Feature Enhancements Within Current Architecture\n\nSeveral valuable chat features can be implemented with minimal changes to the core architecture, primarily by extending existing components and adding new message types to the wire protocol.\n\n**Direct (Private) Messaging**\n> **Mental Model:** The Post Office's Registered Mail\n> \n> While room-based messaging is like broadcasting announcements in a town square, direct messaging is like sending a sealed letter to a specific individual. The postal system (our architecture) already knows how to route messages and track user locations (presence); we just need to add addressing rules that deliver to a single recipient rather than a room's subscriber list.\n\nDirect messaging enables users to send private messages to other users regardless of which rooms they're currently in. This feature requires:\n1. **New Message Type:** Add `EVENT_DIRECT_MESSAGE` to the protocol.\n2. **Recipient Routing:** Extend the `RoomManager.broadcastToRoom` method or create a new `sendToUser` method that looks up the recipient's current `ClientSession` via their `userId`.\n3. **Presence Check:** Verify the recipient is online before sending, with optional offline message queuing.\n4. **Privacy Controls:** Allow users to block messages from specific users.\n\nThe current data model already supports this: `ClientSession` links a `userId` to a specific connection. The main architectural addition is a user-to-connection lookup index in the `ConnectionManager` or `RoomManager`.\n\n| **Component** | **Changes Required** | **Data Flow Impact** |\n|---------------|----------------------|----------------------|\n| **Wire Protocol** | Add `EVENT_DIRECT_MESSAGE` type with `recipientId` field | New message flow: Client → Server → Specific Client |\n| **ConnectionManager** | Maintain `userId` → `connectionId` lookup map | Enables direct routing without room context |\n| **RoomManager** | Add `sendToUser(userId, message)` method | Uses ConnectionManager's lookup to deliver |\n| **Client Application** | Add UI for user list and private chat windows | New subscription to direct message events |\n\n**Message Reactions and Threads**\n> **Mental Model:** Marginal Notes and Conversation Threads\n> \n> Reactions are like scribbling an emoji in the margin of a printed chat transcript—a lightweight annotation attached to a specific message. Threads are like starting a sidebar conversation linked to a particular comment in a meeting minutes document.\n\nReactions (e.g., 👍, ❤️) allow users to respond to specific messages without creating new chat messages. Threads enable nested conversations about specific messages. Both features require:\n1. **Message References:** Extend `ChatMessage` with optional `parentMessageId` and `reactions` field (a map of emoji→userIds).\n2. **New Event Types:** `EVENT_REACTION_ADDED`, `EVENT_THREAD_REPLY`.\n3. **Persistence Updates:** Modify `storeMessage` to handle parent relationships and update reactions atomically.\n4. **Efficient Broadcast:** When a reaction is added, broadcast only the reaction delta, not the entire message history.\n\nThe current `ChatMessage` structure can be extended with additional fields. The `RoomManager` would need logic to validate that referenced messages exist in the same room.\n\n**Read Receipts**\n> **Mental Model:** Certified Mail with Return Receipt\n> \n> Read receipts provide sender confirmation that their message was seen by the recipient, similar to certified mail that requires a signature upon delivery. The system must track which users have \"seen\" each message.\n\nRead receipts show when messages have been viewed by recipients. Implementation requires:\n1. **Client-Side Visibility Tracking:** The client must detect when a message becomes visible in the viewport and send a `EVENT_MESSAGE_READ` event.\n2. **Server-Side State Management:** The server must track which users have read which messages (a `messageId` → `Set<userId>` mapping).\n3. **Efficient Updates:** When a user reads multiple messages (e.g., scrolling through history), batch updates are preferable to individual events.\n4. **Broadcast Updates:** Notify the message sender when their messages are read (optional).\n\nThis feature adds significant state management complexity. A separate `ReadReceiptService` component might be warranted to avoid bloating the `RoomManager`.\n\n**Rich Media and File Sharing**\n> **Mental Model:** The Package Delivery Service\n> \n> While text messages are like postcards (small, simple), file sharing is like shipping packages. We need a separate handling process: receiving the large payload, storing it in a warehouse (object storage), and providing a delivery receipt (URL) that recipients can use to retrieve it.\n\nAllowing users to share images, documents, and other files requires:\n1. **Separate Upload Pathway:** Large files shouldn't go through WebSocket binary messages. Implement HTTP POST endpoints for file upload.\n2. **Object Storage Integration:** Store files in cloud storage (S3, GCS) or a local filesystem with access controls.\n3. **Message with Metadata:** Send chat messages containing file metadata (URL, filename, size, MIME type) via WebSocket.\n4. **Security Considerations:** Validate file types, scan for malware, implement access tokens for private files.\n\nThe current architecture's separation between WebSocket messaging and HTTP services (for authentication) provides a pattern for adding additional HTTP endpoints.\n\n**Bot Integrations and Webhooks**\n> **Mental Model:** The Conference Call Interpreter\n> \n> Bots are like interpreters joining a conference call—they listen to conversations, can be addressed directly with commands, and can inject their own messages. Webhooks are like setting up a microphone in the room that streams the conversation to external services.\n\nBots are automated users that respond to commands or patterns. Webhooks allow external services to receive room events. Both require:\n1. **Programmatic Client API:** A simplified client SDK for bots to connect and interact.\n2. **Command Parsing:** Middleware to detect bot commands (e.g., `/giphy cats`).\n3. **Rate Limiting:** Prevent bots from spamming rooms.\n4. **Webhook Delivery:** HTTP callback system to POST room events to external URLs.\n\nThe current `RoomManager.broadcastToRoom` method already delivers messages to all connections; bots would simply be additional connections with special processing logic.\n\n**Advanced Presence States**\n> **Mental Model:** The Office Status Light\n> \n> Beyond simple online/offline, users can have statuses like \"away,\" \"do not disturb,\" or \"in a meeting\"—similar to an office door having a light that shows availability for interruptions.\n\nExtend the basic presence system to show user availability states:\n1. **State Transitions:** Define states (`online`, `away`, `busy`, `offline`) with automatic transitions (e.g., `away` after keyboard inactivity).\n2. **Client Heartbeat Enhancement:** Extend the heartbeat mechanism to include user activity state.\n3. **Status Broadcast:** Update `EVENT_USER_PRESENCE` to include detailed status and optional custom message.\n4. **Privacy Controls:** Allow users to hide detailed presence from certain users.\n\nThe `ClientSession` already has `lastActivity`; this can be extended with `presenceState` and `statusMessage` fields.\n\n#### Scaling Beyond a Single Server\n\nThe current architecture assumes a single Node.js process handling all connections. While this can support thousands of concurrent users (depending on message volume), true horizontal scaling requires significant architectural changes.\n\n**Decision: Scaling WebSocket Connections Across Multiple Servers**\n- **Context:** The single-server architecture faces limits on concurrent connections (memory, CPU, file descriptor limits). To support tens or hundreds of thousands of users, connections must be distributed across multiple servers.\n- **Options Considered:**\n  1. **Load Balancer with IP Hashing:** A TCP load balancer (L4) distributes connections based on client IP, keeping each user's connection on the same server.\n  2. **WebSocket-Aware Load Balancer:** A layer 7 load balancer that understands WebSocket protocol and can route based on cookies or custom headers.\n  3. **Connection Routing Service:** A dedicated service that assigns clients to specific backend servers and handles re-routing.\n- **Decision:** Use a WebSocket-aware load balancer (option 2) for simplicity, combined with a shared persistence layer.\n- **Rationale:** Layer 7 load balancers (like Nginx with WebSocket support) are mature, require minimal application changes, and can handle SSL termination. IP hashing (option 1) breaks when users change networks or use load-balanced mobile networks.\n- **Consequences:** Requires all servers to have access to shared room state and message history. The in-memory room state becomes invalid; we must move to external storage.\n\n| **Option** | **Pros** | **Cons** | **Viability** |\n|------------|----------|----------|---------------|\n| **IP Hashing Load Balancer** | Simple, works at TCP layer, minimal configuration | Same user from different IPs may connect to different servers, breaking state | Poor - breaks user experience |\n| **WebSocket-Aware Load Balancer** | Can use cookies/sessions for sticky routing, handles WebSocket upgrade | More complex configuration, requires session affinity | **Good** - balances simplicity and functionality |\n| **Connection Routing Service** | Maximum flexibility, can implement custom routing logic | Additional service to build and maintain, new failure point | Overkill for most applications |\n\n**Shared State with Redis or Database**\nWhen moving to multiple servers, the in-memory room and presence state must be externalized to a shared data store. Redis is ideal for this due to its low-latency data structures and publish/subscribe capabilities.\n\n| **Current Component** | **Multi-Server Adaptation** | **Redis Data Structures** |\n|-----------------------|-----------------------------|---------------------------|\n| **ConnectionManager.activeConnections** | Each server maintains only its local connections | Not shared; ephemeral connection state remains local |\n| **RoomManager.rooms** (member lists) | Store in Redis Sorted Sets or Hashes | `room:members:{roomId}` → Set of `userId`s |\n| **User Presence Status** | Store in Redis with TTL | `user:presence:{userId}` → Hash with status, lastSeen |\n| **Typing Indicators** | Store in Redis with short TTL | `room:typing:{roomId}` → Hash of `userId` → timestamp |\n| **Message Routing** | Use Redis Pub/Sub for cross-server broadcasts | Publish to channel `room:{roomId}`; all servers subscribe |\n\n**Stateless WebSocket Servers with External Message Queue**\nFor maximum scalability, the WebSocket servers can become stateless connection handlers that delegate all business logic to external services via message queues.\n\n> **Mental Model:** The Airport Gate Agents vs. Air Traffic Control\n> \n> In this model, WebSocket servers are like gate agents—they manage the direct interaction with passengers (clients) but don't make routing decisions. A central \"air traffic control\" (message queue + worker services) coordinates all flights (messages) between gates.\n\n1. **WebSocket Servers** only handle connection lifecycle and raw message I/O.\n2. **All business logic** (room joins, message validation, presence updates) moves to separate worker services.\n3. **A message queue** (like RabbitMQ, Kafka, or Redis Streams) routes events between components.\n4. **Connection routing layer** tracks which server hosts each user's connection.\n\nThis is a significant architectural shift that introduces complexity but enables independent scaling of connection handling versus business logic processing.\n\n**ADR: When to Consider Multi-Server Architecture**\n- **Context:** Determining when the single-server architecture becomes inadequate and requires the complexity of distributed systems.\n- **Options Considered:**\n  1. **Scale from Day One:** Implement multi-server architecture even for the learning project.\n  2. **Scale When Needed:** Start with single-server, refactor when hitting limits.\n  3. **Hybrid Approach:** Design with extension points for distribution but implement single-server first.\n- **Decision:** Hybrid approach (option 3)—design clean interfaces between components so they can be distributed later without rewriting application logic.\n- **Rationale:** Premature optimization distracts from learning core concepts. However, anticipating future scaling informs better interface design today (e.g., abstracting storage behind interfaces).\n- **Consequences:** Some refactoring will still be needed when scaling, but the core application logic remains largely unchanged.\n\n#### Security and Moderation Enhancements\n\nProduction chat systems require robust security and moderation features that go beyond basic authentication.\n\n**End-to-End Encryption**\n> **Mental Model:** The Diplomatic Pouch\n> \n> End-to-end encryption ensures only the intended recipients can read messages, like diplomatic documents sealed in a tamper-proof pouch that only the sender and recipient have keys to open.\n\nImplementing true end-to-end encryption (where the server cannot decrypt messages) requires:\n1. **Key Exchange:** Clients must exchange public keys (via the server as an untrusted channel).\n2. **Client-Side Encryption:** Messages are encrypted/decrypted in the client application using WebCrypto API.\n3. **Server as Message Relay:** The server stores and forwards encrypted blobs without understanding content.\n4. **Key Management:** Handle key loss, device addition, and group chats (which require more complex encryption schemes).\n\nThis fundamentally changes the server's role from message processor to blind router and significantly increases client complexity.\n\n**Content Moderation and Filtering**\n> **Mental Model:** The Editor's Red Pen\n> \n> Automated moderation scans messages for inappropriate content before or after they're sent, similar to an editor reviewing articles before publication.\n\nModeration features include:\n1. **Automated Keyword Filtering:** Scan messages for banned words/phrases.\n2. **Image Analysis:** Use AI services to detect inappropriate images.\n3. **Report System:** Allow users to report offensive messages.\n4. **Moderator Dashboard:** Interface for human moderators to review reports and take action.\n\nImplementation requires message processing pipeline extensions—potentially asynchronous processing where messages are queued for moderation review before being broadcast.\n\n**Rate Limiting and Anti-Spam**\n> **Mental Model:** The Conversation Pacekeeper\n> \n> Rate limiting prevents users from overwhelming the system with too many messages too quickly, like a moderator ensuring everyone gets a turn to speak.\n\nProtect the system from abuse by:\n1. **Connection-Level Rate Limiting:** Limit message frequency per connection.\n2. **User-Level Rate Limiting:** Track message counts per user across all connections.\n3. **Content-Based Rules:** Detect and block spam patterns (repeated messages, excessive mentions).\n4. **Graduated Response:** Start with warnings, then temporary mutes, then bans.\n\nThe `ConnectionManager` would need to track message timestamps per connection/user and implement sliding window algorithms.\n\n#### Performance Optimizations\n\nAs user count and message volume grow, performance optimizations become necessary.\n\n**Message Compression**\nWebSocket messages can be compressed using permessage-deflate extension (built into most WebSocket libraries). For text-heavy chat, compression can reduce bandwidth by 70-90%.\n\n**Client-Side Message Caching and Delta Updates**\nInstead of sending full message history each time a user joins a room, clients can cache messages locally and request only updates since their last view. This requires:\n1. **Client Storage:** Use IndexedDB or localStorage to cache messages per room.\n2. **Sync Tokens:** Server provides synchronization tokens representing state versions.\n3. **Delta Calculations:** Server computes differences between client cache and current state.\n\n**Efficient Presence Broadcasts**\nBroadcasting presence updates for large rooms (1000+ users) can create significant load. Optimizations include:\n1. **Throttling Updates:** Batch presence changes and send less frequently.\n2. **Lazy Loading:** Only load presence for users currently visible in the client viewport.\n3. **Presence Channels:** Separate presence updates from chat messages, allowing clients to opt-in based on interest.\n\n### Implementation Guidance\n\nThe following guidance provides practical steps for implementing some of the simpler extensions while maintaining the current architecture.\n\n#### Technology Recommendations for Extensions\n\n| **Feature** | **Simple Option (Learning Focus)** | **Production-Ready Option** |\n|-------------|-----------------------------------|----------------------------|\n| **Direct Messaging** | Extend `RoomManager` with user lookup map | Implement with dedicated messaging service |\n| **File Sharing** | Local filesystem storage with size limits | Cloud object storage (S3) with CDN |\n| **Bot Framework** | Simple command parser in `RoomManager` | Bot SDK with middleware pipeline |\n| **Multi-Server Scaling** | Sticky sessions with Redis for shared state | Full microservices with message queue |\n| **End-to-End Encryption** | Basic symmetric encryption demo | Proper key management with Signal Protocol |\n| **Moderation** | Keyword filter middleware | AI content moderation API integration |\n\n#### File Structure for Extensions\n\n```\nchat-project/\n├── server/\n│   ├── src/\n│   │   ├── core/                    # Existing core components\n│   │   │   ├── ConnectionManager.ts\n│   │   │   ├── RoomManager.ts\n│   │   │   └── AuthService.ts\n│   │   ├── extensions/              # New extensions directory\n│   │   │   ├── DirectMessaging.ts   # Direct message handler\n│   │   │   ├── FileService.ts       # File upload/download\n│   │   │   ├── BotFramework.ts      # Bot command processing\n│   │   │   ├── Moderation.ts        # Content filtering\n│   │   │   └── RateLimiter.ts       # Rate limiting middleware\n│   │   ├── shared/                  # Shared utilities\n│   │   │   ├── redis.ts            # Redis client for shared state\n│   │   │   └── encryption.ts       # Encryption helpers\n│   │   └── main.ts                 # Updated to load extensions\n│   └── uploads/                    # Local file storage (if used)\n└── client/\n    └── src/\n        ├── extensions/              # Client-side extension code\n        │   ├── DirectMessageUI.tsx  # Private chat UI component\n        │   └── FileUploader.tsx     # File upload component\n        └── crypto/                  # Client-side encryption (if needed)\n```\n\n#### Starter Code for Direct Messaging Extension\n\n```javascript\n// server/src/extensions/DirectMessaging.ts\nimport { ConnectionManager } from '../core/ConnectionManager';\nimport { RoomManager } from '../core/RoomManager';\nimport { createServerMessage } from '../shared/protocol';\n\n// New event type constant\nconst EVENT_DIRECT_MESSAGE = 'direct_message';\nconst EVENT_DIRECT_MESSAGE_DELIVERED = 'direct_message_delivered';\nconst EVENT_DIRECT_MESSAGE_ERROR = 'direct_message_error';\n\n/**\n * Direct Messaging Extension\n * \n * This extension adds private messaging between users.\n * It maintains a map of userId -> connectionId for online users\n * and routes direct messages to the appropriate recipient.\n */\nexport class DirectMessaging {\n  private userConnections = new Map(); // userId -> connectionId\n  private connectionUsers = new Map(); // connectionId -> userId\n  \n  constructor(\n    private connectionManager: ConnectionManager,\n    private roomManager: RoomManager\n  ) {\n    // Listen for user authentication events\n    this.setupEventHandlers();\n  }\n  \n  /**\n   * Register a user's current connection\n   */\n  registerUserConnection(userId: string, connectionId: string): void {\n    // TODO 1: Update userConnections map with userId -> connectionId\n    // TODO 2: Update connectionUsers map with connectionId -> userId\n    // TODO 3: Clean up old mapping if user had previous connection\n  }\n  \n  /**\n   * Remove a user's connection mapping\n   */\n  unregisterUserConnection(connectionId: string): void {\n    // TODO 1: Get userId from connectionUsers map using connectionId\n    // TODO 2: Remove entry from connectionUsers map\n    // TODO 3: Remove entry from userConnections map if it maps to this connectionId\n  }\n  \n  /**\n   * Handle incoming direct message from a client\n   */\n  async handleDirectMessage(senderConnectionId: string, messagePayload: any): Promise<void> {\n    // TODO 1: Extract recipientId and content from messagePayload\n    // TODO 2: Validate recipientId exists and is not the sender\n    // TODO 3: Look up recipient's connectionId from userConnections map\n    // TODO 4: If recipient is online, forward message using connectionManager.sendToClient\n    // TODO 5: Send delivery confirmation to sender\n    // TODO 6: If recipient is offline, store message for later delivery (optional)\n    // TODO 7: Handle errors (invalid recipient, message too long, etc.)\n  }\n  \n  /**\n   * Check if a user is currently online\n   */\n  isUserOnline(userId: string): boolean {\n    // TODO: Check if userId exists in userConnections map\n    return this.userConnections.has(userId);\n  }\n  \n  /**\n   * Get the connection ID for an online user\n   */\n  getConnectionForUser(userId: string): string | undefined {\n    // TODO: Return connectionId from userConnections map\n    return this.userConnections.get(userId);\n  }\n  \n  private setupEventHandlers(): void {\n    // TODO: Listen for user authentication events from RoomManager\n    // TODO: Listen for connection disconnect events from ConnectionManager\n    // TODO: Register message handler for EVENT_DIRECT_MESSAGE\n  }\n}\n```\n\n#### Starter Code for File Service Extension\n\n```javascript\n// server/src/extensions/FileService.ts\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Constants for file handling\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\nconst ALLOWED_MIME_TYPES = [\n  'image/jpeg',\n  'image/png',\n  'image/gif',\n  'application/pdf',\n  'text/plain'\n];\nconst UPLOAD_DIR = './uploads';\n\n/**\n * File Service for handling file uploads and downloads\n * \n * This service provides HTTP endpoints for file upload\n * and manages file metadata for inclusion in chat messages.\n */\nexport class FileService {\n  private fileMetadata = new Map(); // fileId -> { filename, mimeType, size, uploader, uploadDate }\n  \n  constructor() {\n    this.ensureUploadDirectory();\n  }\n  \n  /**\n   * Ensure upload directory exists\n   */\n  private async ensureUploadDirectory(): Promise<void> {\n    try {\n      await fs.access(UPLOAD_DIR);\n    } catch {\n      await fs.mkdir(UPLOAD_DIR, { recursive: true });\n    }\n  }\n  \n  /**\n   * Handle file upload from HTTP request\n   */\n  async handleUpload(fileData: Buffer, filename: string, mimeType: string, uploaderId: string): Promise<{ fileId: string, url: string }> {\n    // TODO 1: Validate file size against MAX_FILE_SIZE\n    // TODO 2: Validate mimeType against ALLOWED_MIME_TYPES\n    // TODO 3: Generate unique fileId using uuidv4()\n    // TODO 4: Create safe filename (prevent path traversal)\n    // TODO 5: Write file to disk in UPLOAD_DIR\n    // TODO 6: Store metadata in fileMetadata map\n    // TODO 7: Return fileId and URL for client access\n  }\n  \n  /**\n   * Get file metadata by ID\n   */\n  getFileMetadata(fileId: string): any {\n    // TODO: Return metadata from fileMetadata map\n    return this.fileMetadata.get(fileId);\n  }\n  \n  /**\n   * Serve file for download\n   */\n  async serveFile(fileId: string): Promise<{ data: Buffer, metadata: any }> {\n    // TODO 1: Look up metadata by fileId\n    // TODO 2: Read file from disk\n    // TODO 3: Return file data and metadata\n  }\n  \n  /**\n   * Clean up old files (cron job)\n   */\n  async cleanupOldFiles(maxAgeDays: number = 30): Promise<void> {\n    // TODO 1: Iterate through fileMetadata map\n    // TODO 2: Check uploadDate for each file\n    // TODO 3: Delete files older than maxAgeDays\n    // TODO 4: Remove entries from fileMetadata map\n  }\n}\n```\n\n#### Language-Specific Hints for JavaScript/TypeScript\n\n- **Direct Messaging:** Use `Map` for `userId → connectionId` lookups for O(1) access. Remember to clean up mappings when connections close to prevent memory leaks.\n- **File Uploads:** For production, use streams (`fs.createWriteStream`) instead of writing entire buffers to handle large files efficiently.\n- **Redis Integration:** Use the `ioredis` library for Redis connections with connection pooling and automatic reconnection.\n- **Rate Limiting:** Implement sliding window algorithm using Redis sorted sets for distributed rate limiting across multiple servers.\n- **Bot Framework:** Create a middleware pipeline pattern where messages pass through bot handlers sequentially until one consumes the message.\n\n#### Milestone Extension Checkpoints\n\n**Direct Messaging Implementation Check:**\n1. Start the server and connect two authenticated clients (Alice and Bob).\n2. Alice sends a direct message to Bob using the new message type.\n3. Verify Bob receives the message immediately.\n4. Verify Alice receives a delivery confirmation.\n5. Test offline case: disconnect Bob, send message from Alice, then reconnect Bob—message should not be delivered unless you implemented offline queueing.\n\n**File Sharing Implementation Check:**\n1. Start server with file upload endpoint.\n2. Use curl or Postman to POST a file to `/api/upload`.\n3. Verify server returns a `fileId` and URL.\n4. Send a chat message containing the file metadata.\n5. Other clients should see the file message and be able to download it via the provided URL.\n\n**Multi-Server Scaling Check (Advanced):**\n1. Start two server instances on different ports.\n2. Configure a load balancer (nginx) with sticky sessions.\n3. Connect multiple clients, ensuring they distribute across servers.\n4. Using Redis, verify that room membership and presence updates propagate across servers.\n5. Send a message in a room with users connected to different servers—all should receive it.\n\n#### Debugging Tips for Extensions\n\n| **Symptom** | **Likely Cause** | **How to Diagnose** | **Fix** |\n|-------------|------------------|----------------------|---------|\n| **Direct messages not delivered** | User connection mapping not updated | Check `userConnections` map after login | Ensure `registerUserConnection` is called on authentication |\n| **File uploads failing silently** | Upload directory permissions | Check server logs for EACCES errors | Ensure upload directory exists and is writable |\n| **Presence not syncing across servers** | Redis connection issues | Check Redis connectivity and Pub/Sub subscriptions | Verify Redis URL and ensure all servers subscribe to same channels |\n| **Rate limiting blocking legitimate users** | Algorithm too aggressive | Log rate limit counters and timestamps | Adjust time window or increase limit thresholds |\n| **Bots not responding to commands** | Command prefix mismatch | Log raw messages entering bot handler | Ensure command parsing logic matches client sending format |\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (1-4). This glossary defines key terms and concepts used throughout the design document, providing a common vocabulary for understanding the real-time chat application architecture.\n\n### Terms and Definitions\n\n| Term | Definition |\n|------|------------|\n| **Authentication** | The process of verifying a user's identity before granting access to the system, typically by validating credentials (username and password) during the WebSocket connection upgrade or through a custom protocol message. In this system, authentication occurs during the HTTP upgrade to WebSocket, creating a secure link between a user identity and their WebSocket connection. |\n| **bcrypt** | A password hashing algorithm specifically designed to be computationally expensive and resistant to brute-force attacks through built-in salting and configurable work factors. The system uses bcrypt with `saltRounds: 10` to securely hash user passwords before storage, ensuring plaintext passwords are never persisted in the database. |\n| **Broadcast** | The action of sending a message to all connected clients in a specific group or room, excluding the original sender by default. Implemented through `RoomManager.broadcastToRoom()`, this pattern enables one-to-many communication essential for chat rooms where a single message must reach multiple recipients simultaneously. |\n| **ChatMessage** | The core data structure representing an individual chat message, containing fields for `sender` (username), `content` (text), `timestamp` (ISO string), `roomId` (target room), and `id` (unique identifier). This structure flows from client to server, gets enriched with metadata, stored in persistence, and broadcast to room members. |\n| **ClientSession** | A server-side data structure tracking an authenticated user's active WebSocket connection, containing fields like `connectionId` (unique socket identifier), `socket` (raw WebSocket object), `userId` (linked user), `ip` (client IP address), `userAgent` (browser info), `joinedAt` (connection timestamp), `lastActivity` (for timeout detection), and `roomId` (current room). This object represents the stateful link between user identity and network connection. |\n| **Clock Skew** | The difference in system time between client and server machines, which can cause inconsistencies in message timestamps and presence indicators. The system mitigates this by having the server assign all timestamps (`ChatMessage.timestamp`) using its own clock, ensuring consistent ordering and time-based operations across all clients. |\n| **Connection Lifecycle** | The complete sequence of states a WebSocket connection passes through: initial HTTP handshake (upgrade), connected (open), messaging (data exchange), and disconnection (close/error). The `ConnectionManager` tracks this lifecycle through events (connect, message, disconnect) and maintains corresponding state in `ClientSession` objects. |\n| **ConnectionManager** | The server component responsible for accepting WebSocket upgrade requests, managing active connections, routing messages to appropriate handlers, and cleaning up disconnected clients. This component acts as the system's entry point for all real-time traffic and maintains the `ClientSession` Map tracking all active connections. |\n| **Debouncing** | A programming technique that delays execution of a function until after a specified wait time has elapsed since the last time it was invoked, used in this system to prevent excessive `EVENT_USER_TYPING` notifications. When a user types, the client waits for a pause (e.g., 500ms) before sending the typing indicator, and sends a \"stopped typing\" message after a timeout. |\n| **DebugLogger** | A utility component with fields `enableConsole`, `enableFile`, and `logFile` that provides structured logging for system events at different severity levels. Used throughout the server to record connection events, message handling errors, and system state for troubleshooting, implementing the non-functional goal of debuggability. |\n| **Defensive Programming** | A coding philosophy that anticipates and gracefully handles potential errors before they cause system failures. In this chat system, this manifests as validating all incoming messages (`parseAndValidateWebSocketMessage`), checking socket `readyState` before sending, implementing comprehensive error handlers, and using try-catch blocks around all message processing. |\n| **Direct Messaging** | Private, one-to-one communication between individual users outside of chat rooms, implemented as a future extension. The `DirectMessaging` component would manage user-to-connection mappings and route private messages using the `EVENT_DIRECT_MESSAGE` event type while maintaining the same underlying WebSocket connections. |\n| **End-to-End Encryption** | An encryption model where messages are encrypted on the sender's device and only decrypted on the recipient's device, preventing even the server from reading message contents. This represents a potential future extension beyond the current system's scope, which currently encrypts data only in transit (TLS) and at rest (database). |\n| **Event-Driven Architecture** | A software design pattern where system components emit and respond to events (messages signaling state changes) rather than using direct method calls. The chat system employs this pattern extensively: the WebSocket server emits connection events, clients send message events (`EVENT_CHAT_MESSAGE`, `EVENT_USER_TYPING`), and the server broadcasts notification events to clients. |\n| **Exponential Backoff** | A retry strategy where the delay between retry attempts increases exponentially (e.g., 1s, 2s, 4s, 8s), used by clients when attempting to reconnect after losing WebSocket connection. This prevents overwhelming the server with reconnection attempts during outages while ensuring eventual reconnection when the server becomes available. |\n| **Graceful Degradation** | The property of a system to continue operating with reduced functionality when parts fail, rather than failing completely. In this chat application, if the persistence layer fails, the system continues to allow real-time messaging (using in-memory state) but displays an error when users try to load message history, maintaining core functionality while indicating the degraded state. |\n| **Heartbeat** | Periodic ping/pong messages exchanged between client and server to detect if a connection is still alive, even if no application messages are being sent. Implemented as a timer in the `ConnectionManager` that sends WebSocket protocol ping frames and disconnects clients that don't respond with pong frames within a timeout period, preventing \"zombie connections.\" |\n| **Horizontal Scaling** | Adding more servers to handle increased load, as opposed to vertical scaling (upgrading hardware on a single server). While not implemented in the current design (a non-goal), the architecture could be extended for horizontal scaling using Redis Pub/Sub for cross-server communication and sticky sessions for load balancing. |\n| **Integration Tests** | Tests that verify multiple system components work together correctly, such as testing the full flow from client WebSocket connection through message broadcasting to other clients. In this project, integration tests would verify that messages sent to a room are received by all members, and that user join notifications work properly. |\n| **JWT (JSON Web Token)** | A compact, URL-safe token format for representing claims between two parties, often used for authentication. While the current system uses session tokens stored server-side, JWTs could be implemented as a future extension to enable stateless authentication, containing encrypted user identity and expiration information. |\n| **Long Polling** | A technique where the client sends a request to the server that remains open until the server has new data to send, at which point the server responds and the client immediately sends another request. This is an alternative to WebSockets for real-time communication but introduces higher latency and server overhead compared to the persistent WebSocket connections used in this system. |\n| **Message Broker** | A component that routes messages to appropriate recipients based on rules or subscriptions. In this system, the `RoomManager` acts as a message broker, receiving messages from the `ConnectionManager` and delivering them to all members of the specified room, implementing the publish-subscribe pattern for room-based communication. |\n| **Message Queue** | In the context of testing, a collection (array) of received messages in the `TestWebSocketClient` that allows test code to inspect messages sent by the server. The client's `messageQueue` field stores all incoming messages, and helper methods like `getMessagesOfType()` filter this queue for specific message types during test verification. |\n| **Middleware Pipeline** | A pattern where incoming messages pass through a series of processing functions (middleware) before reaching the main handler. While not explicitly implemented in the current design, the architecture could be extended with middleware for logging, rate limiting, message transformation, or authentication validation before messages reach the main `ConnectionManager.handleMessage()` method. |\n| **Pagination** | The technique of retrieving data in manageable chunks (pages) rather than loading entire datasets at once. Implemented in `getMessagesForRoom()` with `limit` and `offset` parameters, this prevents overwhelming clients and servers when loading message history from rooms with thousands of messages, a critical consideration for the non-functional goal of performance. |\n| **Password Hashing** | The cryptographic transformation of passwords into irreversible hash values before storage, preventing exposure of plaintext passwords even if the database is compromised. The system uses bcrypt hashing in the `AuthService.registerUser()` and `AuthService.loginUser()` methods, ensuring passwords are never stored or transmitted in plain text. |\n| **Polling** | A technique where the client repeatedly requests updates from the server at regular intervals (e.g., every 2 seconds). This naive approach to real-time communication is inefficient compared to WebSockets, as it creates constant HTTP request overhead even when no new data is available, and introduces latency equal to the polling interval. |\n| **Presence** | Real-time status information about users, including whether they are online/offline, which room they're in, and whether they're currently typing. The `RoomManager` tracks presence through room membership (`Room.memberIds`) and typing status via `setUserTyping()`, broadcasting updates to room members when presence states change. |\n| **Rate Limiting** | Controlling the frequency of messages a user can send to prevent abuse and protect server resources. While not implemented in the basic system, this could be added as a future extension using algorithms like the sliding window algorithm to count requests over a moving time window and reject excessive messages. |\n| **Redis Pub/Sub** | Redis Publish/Subscribe pattern that enables cross-server communication through a shared message bus, allowing multiple chat servers to coordinate room membership and message broadcasting in a horizontally scaled deployment. This represents an advanced extension path beyond the current single-server, in-memory design. |\n| **Room** | A data structure representing a chat channel or conversation space, containing fields `id` (unique identifier), `name` (human-readable name), `createdAt` (timestamp), and `memberIds` (Set of user IDs currently in the room). Rooms enable segmented conversations where messages are only delivered to members of that specific room. |\n| **Room Manager** | The server component that manages chat rooms, membership, message broadcasting within rooms, and presence tracking. This component implements methods like `joinRoom()`, `leaveRoom()`, `broadcastToRoom()`, and `getRoomList()`, forming the core business logic for Milestones 2 and 3. |\n| **Server-Sent Events (SSE)** | An HTTP-based technology for server-to-client event streaming over a single, long-lived connection where the server can push events to the client but the client cannot send messages back (unidirectional). While simpler than WebSockets, SSE is insufficient for this chat application's requirement for bidirectional communication (client-to-server messaging). |\n| **Session** | Temporary authentication state for a user connection, represented server-side by `ClientSession` objects and client-side by session tokens. Sessions have a Time-To-Live (`sessionTTL` of 24 hours) after which they expire, requiring re-authentication. The `AuthService` creates, validates, and invalidates sessions. |\n| **Sliding Window Algorithm** | A rate limiting algorithm that counts requests over a moving time window (e.g., last 60 seconds) rather than fixed intervals, providing more accurate and smooth limiting. This represents a potential implementation approach for adding rate limiting as a future extension to prevent spam and abuse. |\n| **Stateful Message Router** | A server component that maintains active connections and routes messages between them based on application state. The `ConnectionManager` combined with the `RoomManager` forms a stateful message router, as it must know which connections belong to which users, which rooms those users are in, and route messages accordingly. |\n| **Sticky Sessions** | A load balancing technique that routes all requests from a particular user to the same server, necessary for maintaining WebSocket connection state in horizontally scaled deployments. This would be required if extending the system to multiple servers, ensuring a user's WebSocket connection and session state remain on a single server. |\n| **TestWebSocketClient** | A testing utility that simulates a chat client for automated testing, containing fields like `url`, `socket`, `messageQueue`, `messageHandlers`, and `connectPromise`. This client connects to the server, sends messages, and provides methods like `waitForMessage()` to verify server responses in integration tests. |\n| **TTL (Time-To-Live)** | The duration after which data expires and should be cleaned up. In this system, sessions have a TTL of 24 hours (stored in `sessionTTL`), and the `cleanupExpiredSessions()` method periodically removes expired sessions. Message history could also implement TTL for automatic cleanup of old messages. |\n| **Unicode Normalization** | The process of converting text to a standard form for consistent processing, ensuring that visually identical strings (e.g., \"café\" composed differently) are treated as identical. While not explicitly implemented, this would be important for proper handling of usernames and message content containing international characters. |\n| **Unit Tests** | Tests that verify individual functions in isolation, such as testing `parseAndValidateWebSocketMessage()` without requiring a running server or network connections. These tests focus on specific edge cases and error conditions for single components or functions. |\n| **User** | A data structure representing an authenticated chat user, containing `username` (unique identifier), `passwordHash` (bcrypt-hashed password), and `createdAt` (registration timestamp). Users are created during registration and authenticated during login, with their identity linked to WebSocket connections via `ClientSession` objects. |\n| **WebSocket** | A communication protocol providing full-duplex (bidirectional) communication channels over a single TCP connection, enabling persistent, low-latency communication between client and server. This protocol forms the foundation of the entire chat system, replacing the request-response model of HTTP with continuous two-way communication. |\n| **WebSocketMessage** | The standardized message format for all client-server communication, containing fields `type` (event type like `EVENT_CHAT_MESSAGE`), `payload` (event-specific data), and optional `timestamp`. All messages, whether from client to server or server to client, follow this envelope format for consistent parsing and routing. |\n| **Zombie Connection** | A WebSocket connection that appears open in the server's tracking but is actually dead or unresponsive, often due to network failures where the TCP connection closed without proper WebSocket close handshake. The system prevents zombie connections through heartbeat (ping/pong) mechanisms that detect and clean up dead connections. |\n"}