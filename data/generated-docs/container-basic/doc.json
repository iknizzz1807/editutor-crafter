{"html":"<h1 id=\"container-basic-design-document\">Container (Basic): Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a basic container runtime using Linux namespaces and cgroups to achieve process isolation. The key architectural challenge is coordinating multiple kernel isolation mechanisms (PID, mount, network namespaces) with resource controls while handling the subtle timing and lifecycle management issues that arise from namespace interactions.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides foundational context for all milestones (1-4), establishing why process isolation is necessary before implementing PID, mount, network namespaces, and cgroups.</p>\n</blockquote>\n<p>Modern computing environments face a fundamental challenge: how can multiple processes, applications, or users safely share the same physical machine without interfering with each other? This problem becomes particularly acute when running untrusted code, deploying applications with conflicting dependencies, or managing multi-tenant systems where isolation and resource fairness are critical.</p>\n<p>The core issue stems from the traditional Unix process model, where all processes share the same global namespace for process IDs, filesystem mounts, network interfaces, and system resources. While Unix permissions provide some level of access control, they don&#39;t address the deeper problems of resource contention, dependency conflicts, and the blast radius of misbehaving applications. A runaway process can consume all available CPU or memory, affecting every other process on the system. Applications with conflicting library versions cannot coexist peacefully. Network services can interfere with each other by binding to the same ports.</p>\n<p><strong>Process isolation</strong> addresses these challenges by creating controlled boundaries around groups of processes, giving each group its own view of system resources while maintaining efficient resource sharing at the kernel level. Unlike full machine virtualization, process isolation operates at a much finer granularity, allowing for lightweight separation that scales to hundreds or thousands of isolated environments on a single host.</p>\n<p>This design document explores the implementation of a basic container runtime that leverages Linux kernel features—specifically namespaces and cgroups—to achieve robust process isolation. The system we&#39;ll build demonstrates how these kernel primitives can be orchestrated to create secure, resource-controlled execution environments that are both lighter weight than virtual machines and more secure than traditional process separation.</p>\n<h3 id=\"mental-model-apartment-building\">Mental Model: Apartment Building</h3>\n<p>Think of a computer system as a large apartment building, and processes as the various tenants living in it. In the traditional Unix model, it&#39;s as if all tenants share one massive communal space with no private rooms, no individual mailboxes, and no separate utility meters. Everyone can see everyone else&#39;s belongings (process tree), use anyone&#39;s phone line (network interfaces), rearrange the shared furniture (filesystem mounts), and there&#39;s no way to prevent one tenant from using all the electricity (CPU and memory resources).</p>\n<p>This communal arrangement creates obvious problems. If one tenant decides to play loud music at 3 AM (a CPU-intensive process), everyone suffers. If someone rearranges all the furniture (modifies global filesystem mounts), it affects everyone&#39;s daily routine. When the mail arrives, anyone can read anyone else&#39;s letters (no process isolation). And if someone leaves the water running (memory leak), the entire building&#39;s utilities suffer.</p>\n<p><strong>Containers provide each tenant with their own private apartment within the same building.</strong> Each apartment has:</p>\n<ul>\n<li><p><strong>Private room numbering</strong> (PID namespace): Inside apartment 3B, the rooms might be numbered 1, 2, 3, but these numbers are completely independent from apartment 4A&#39;s room numbering. A tenant in 3B who thinks they&#39;re in &quot;room 1&quot; might actually be in the building&#39;s room 847 from the building manager&#39;s perspective.</p>\n</li>\n<li><p><strong>Individual interior layouts</strong> (mount namespace): Each apartment can arrange their furniture, hang pictures, and organize their space completely independently. One tenant might prefer a minimalist setup while another fills every corner. These choices don&#39;t affect neighboring apartments.</p>\n</li>\n<li><p><strong>Separate phone/internet lines</strong> (network namespace): Each apartment gets its own phone number and internet connection. Tenants can&#39;t accidentally answer each other&#39;s phones or interfere with each other&#39;s network traffic.</p>\n</li>\n<li><p><strong>Individual utility budgets</strong> (cgroups): The building manager allocates specific amounts of electricity, water, and heating to each apartment. If one tenant tries to run too many appliances, their circuit breaker trips, but other apartments continue running normally.</p>\n</li>\n</ul>\n<p>The building manager (kernel) maintains the overall infrastructure—the structural walls, main electrical system, water mains, and building-wide policies. But within each apartment&#39;s boundaries, tenants operate independently. They can&#39;t see into other apartments, can&#39;t consume more than their allocated resources, and can&#39;t break things in ways that affect their neighbors.</p>\n<p>This apartment model captures the essential insight of containerization: <strong>strong isolation boundaries within shared infrastructure</strong>. The kernel provides the &quot;building&quot; (hardware resources, core services), while containers provide the &quot;apartments&quot; (isolated process environments with controlled resource access).</p>\n<p>Just as apartment buildings are more efficient than giving each tenant their own house (virtual machines), containers are more efficient than full virtualization while still providing the isolation benefits tenants need.</p>\n<h3 id=\"existing-isolation-approaches\">Existing Isolation Approaches</h3>\n<p>Before diving into container implementation, it&#39;s important to understand the landscape of existing isolation approaches and why containers occupy a unique position in the design space. Each approach represents different trade-offs between isolation strength, resource efficiency, and operational complexity.</p>\n<h4 id=\"virtual-machines-maximum-isolation-maximum-overhead\">Virtual Machines: Maximum Isolation, Maximum Overhead</h4>\n<p>Virtual machines provide the strongest isolation by running complete, separate operating system instances on virtualized hardware. Each VM gets its own kernel, its own device drivers, and its own complete view of virtualized hardware resources.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Isolation Boundary</strong></td>\n<td>Hardware virtualization layer</td>\n<td>Complete OS-level separation</td>\n</tr>\n<tr>\n<td><strong>Resource Overhead</strong></td>\n<td>Full OS + kernel per instance</td>\n<td>512MB-2GB+ memory per VM</td>\n</tr>\n<tr>\n<td><strong>Startup Time</strong></td>\n<td>Full OS boot sequence</td>\n<td>30+ seconds typical</td>\n</tr>\n<tr>\n<td><strong>Resource Efficiency</strong></td>\n<td>Poor - duplicate kernels, drivers</td>\n<td>10-50 VMs per host typical</td>\n</tr>\n<tr>\n<td><strong>Security Model</strong></td>\n<td>Hypervisor-enforced boundaries</td>\n<td>Very strong - different kernels</td>\n</tr>\n<tr>\n<td><strong>Failure Blast Radius</strong></td>\n<td>Contained to single VM</td>\n<td>Hypervisor bugs affect all VMs</td>\n</tr>\n</tbody></table>\n<p>Virtual machines excel when you need to run different operating systems, when you require maximum security isolation (different kernels can&#39;t interfere), or when you need to emulate specific hardware configurations. However, their resource overhead makes them impractical for microservice architectures where you might want to run hundreds of small, specialized services.</p>\n<h4 id=\"chroot-jails-filesystem-isolation-only\">Chroot Jails: Filesystem Isolation Only</h4>\n<p>The <code>chroot</code> system call, introduced in Unix Version 7, provides a much lighter-weight isolation mechanism by changing a process&#39;s view of the filesystem root. A process running in a chroot jail cannot access files outside its designated directory tree.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Isolation Boundary</strong></td>\n<td>Filesystem namespace only</td>\n<td>No process, network, or resource isolation</td>\n</tr>\n<tr>\n<td><strong>Resource Overhead</strong></td>\n<td>Minimal - shared kernel</td>\n<td>Nearly zero overhead</td>\n</tr>\n<tr>\n<td><strong>Startup Time</strong></td>\n<td>Near-instantaneous</td>\n<td>Milliseconds</td>\n</tr>\n<tr>\n<td><strong>Resource Efficiency</strong></td>\n<td>Excellent for filesystem isolation</td>\n<td>Hundreds per host easily</td>\n</tr>\n<tr>\n<td><strong>Security Model</strong></td>\n<td>Filesystem access control only</td>\n<td>Weak - shared PID space, network</td>\n</tr>\n<tr>\n<td><strong>Failure Blast Radius</strong></td>\n<td>Processes can still interfere</td>\n<td>No resource or process boundaries</td>\n</tr>\n</tbody></table>\n<p>Chroot jails are useful for specific scenarios like FTP servers or build environments where you primarily need filesystem isolation. However, they provide no protection against resource exhaustion attacks, processes can still see and potentially interfere with each other, and network resources remain completely shared. A process in a chroot jail can still consume all system memory or CPU, affecting every other process on the host.</p>\n<h4 id=\"containers-balanced-isolation-and-efficiency\">Containers: Balanced Isolation and Efficiency</h4>\n<p>Containers represent a middle ground that combines multiple Linux kernel isolation primitives to create process-level isolation boundaries that are much stronger than chroot but lighter weight than full virtualization.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Isolation Boundary</strong></td>\n<td>Multiple namespace types + cgroups</td>\n<td>Process, filesystem, network, resource isolation</td>\n</tr>\n<tr>\n<td><strong>Resource Overhead</strong></td>\n<td>Shared kernel, isolated userspace</td>\n<td>10-50MB typical per container</td>\n</tr>\n<tr>\n<td><strong>Startup Time</strong></td>\n<td>Process startup time</td>\n<td>Milliseconds to seconds</td>\n</tr>\n<tr>\n<td><strong>Resource Efficiency</strong></td>\n<td>Very good - shared kernel</td>\n<td>100s-1000s per host</td>\n</tr>\n<tr>\n<td><strong>Security Model</strong></td>\n<td>Kernel-enforced namespace boundaries</td>\n<td>Strong within same kernel</td>\n</tr>\n<tr>\n<td><strong>Failure Blast Radius</strong></td>\n<td>Isolated by namespace and cgroups</td>\n<td>Kernel vulnerabilities affect all</td>\n</tr>\n</tbody></table>\n<p><strong>The key insight that makes containers practical</strong> is that most application isolation requirements don&#39;t actually need separate kernels. Applications typically need:</p>\n<ul>\n<li>Their own process tree (PID namespace)</li>\n<li>Their own filesystem view (mount namespace) </li>\n<li>Their own network stack (network namespace)</li>\n<li>Controlled resource allocation (cgroups)</li>\n</ul>\n<p>But they can safely share the same kernel, device drivers, and core system services. This sharing dramatically reduces memory overhead—instead of 500MB+ per virtual machine, containers might use 10-50MB each.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Containers optimize for the common case where applications need isolation from each other but not from the underlying operating system. This allows much higher density while maintaining practical isolation boundaries.</p>\n</blockquote>\n<h4 id=\"comparison-summary\">Comparison Summary</h4>\n<table>\n<thead>\n<tr>\n<th>Criteria</th>\n<th>Virtual Machines</th>\n<th>Chroot Jails</th>\n<th>Containers</th>\n<th>Best Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Isolation Strength</strong></td>\n<td>Maximum</td>\n<td>Minimal</td>\n<td>Strong</td>\n<td>VMs for different OSes</td>\n</tr>\n<tr>\n<td><strong>Resource Efficiency</strong></td>\n<td>Poor</td>\n<td>Excellent</td>\n<td>Very Good</td>\n<td>Containers for microservices</td>\n</tr>\n<tr>\n<td><strong>Operational Complexity</strong></td>\n<td>High</td>\n<td>Low</td>\n<td>Medium</td>\n<td>Chroot for simple filesystem isolation</td>\n</tr>\n<tr>\n<td><strong>Security Boundaries</strong></td>\n<td>Hypervisor</td>\n<td>Filesystem only</td>\n<td>Multiple namespaces</td>\n<td>VMs for untrusted multi-tenant</td>\n</tr>\n<tr>\n<td><strong>Density</strong></td>\n<td>10-50/host</td>\n<td>1000s/host</td>\n<td>100s-1000s/host</td>\n<td>Containers for application packaging</td>\n</tr>\n<tr>\n<td><strong>Startup Performance</strong></td>\n<td>Slow</td>\n<td>Instant</td>\n<td>Fast</td>\n<td>Containers for elastic scaling</td>\n</tr>\n</tbody></table>\n<p>The fundamental architectural decision in our container implementation is to leverage this balanced approach: <strong>strong enough isolation for most application security and interference requirements, while maintaining the resource efficiency needed for modern microservice architectures</strong>.</p>\n<p>Our basic container runtime will demonstrate how to coordinate Linux namespaces (PID, mount, network) with cgroups (resource limits) to achieve this balance. The system provides process-level isolation that prevents applications from interfering with each other while allowing efficient resource sharing through a common kernel.</p>\n<p>This approach makes containers particularly well-suited for:</p>\n<ul>\n<li><strong>Microservice architectures</strong> where you need many small, isolated services</li>\n<li><strong>CI/CD pipelines</strong> where you need fast, clean build environments</li>\n<li><strong>Development environments</strong> where you need consistent, reproducible setups</li>\n<li><strong>Multi-tenant applications</strong> where you need fair resource sharing</li>\n</ul>\n<p>The trade-off is that all containers share the same kernel, so kernel-level vulnerabilities or crashes can affect all containers on a host. For scenarios requiring maximum security isolation, virtual machines remain the better choice. But for the vast majority of application deployment scenarios, containers provide an excellent balance of isolation, efficiency, and operational simplicity.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The theoretical understanding of isolation approaches provides the foundation for practical container implementation. This section bridges the gap between understanding why containers are useful and actually building one using Linux kernel primitives.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Language</strong></td>\n<td>C with basic syscalls</td>\n<td>Go with advanced libraries</td>\n<td>C - direct kernel interaction</td>\n</tr>\n<tr>\n<td><strong>Namespace Creation</strong></td>\n<td><code>clone()</code> system call</td>\n<td><code>unshare()</code> + <code>fork()</code></td>\n<td>Start with <code>clone()</code> - single step</td>\n</tr>\n<tr>\n<td><strong>Process Management</strong></td>\n<td>Basic <code>wait()</code> loops</td>\n<td>Signalfd + epoll</td>\n<td>Basic <code>wait()</code> - easier debugging</td>\n</tr>\n<tr>\n<td><strong>Network Setup</strong></td>\n<td>Shell commands via <code>system()</code></td>\n<td>Netlink sockets</td>\n<td>Shell commands - fewer dependencies</td>\n</tr>\n<tr>\n<td><strong>Cgroups Interface</strong></td>\n<td>Direct filesystem writes</td>\n<td>libcgroup or systemd</td>\n<td>Direct filesystem - clearer understanding</td>\n</tr>\n<tr>\n<td><strong>Error Handling</strong></td>\n<td>Simple errno checking</td>\n<td>Structured error types</td>\n<td>errno checking - matches kernel interface</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Understanding the isolation concepts leads naturally to a modular code organization that mirrors the conceptual separation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">container</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">basic</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── src</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── main.c                    ← Entry point and command parsing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── container.h               ← Main container API definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── container.c               ← Container lifecycle orchestration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── namespace</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── namespace.h           ← Common namespace utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── pid_namespace.c       ← PID </span><span style=\"color:#B392F0\">isolation</span><span style=\"color:#E1E4E8\"> (Milestone </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── mount_namespace.c     ← Filesystem </span><span style=\"color:#B392F0\">isolation</span><span style=\"color:#E1E4E8\"> (Milestone </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── network_namespace.c   ← Network </span><span style=\"color:#B392F0\">isolation</span><span style=\"color:#E1E4E8\"> (Milestone </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── cgroups</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── cgroups.h             ← Resource limit interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   ├── cgroups.c             ← Cgroups </span><span style=\"color:#B392F0\">management</span><span style=\"color:#E1E4E8\"> (Milestone </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   │   └── limits.c              ← Specific limit controllers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── utils</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── error.h               ← Error handling utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       ├── error.c               ← Error reporting and cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│       └── syscall_wrappers.c    ← Safe syscall wrapper functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── test_pid_namespace.c      ← PID isolation verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── test_mount_namespace.c    ← Filesystem isolation tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── test_network_namespace.c  ← Network isolation tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── test_cgroups.c           ← Resource limit tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">├── examples</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   ├── simple_container.c        ← Basic usage example</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">│   └── isolated_shell.c         ← Interactive container demo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">└── Makefile                      ← Build configuration</span></span></code></pre></div>\n\n<p>This structure reflects the apartment building model: the main <code>container.c</code> file acts as the building manager, coordinating between different isolation mechanisms (the namespace/ modules) and resource management (the cgroups/ module).</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Since the focus is on learning namespace and cgroups coordination, here&#39;s complete starter code for error handling and utility functions:</p>\n<p><strong>src/utils/error.h</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> ERROR_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ERROR_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error reporting macros that preserve errno and provide context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"ERROR [</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">]: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            __FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, (msg), </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> LOG_INFO</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"INFO: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (msg)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> HANDLE_ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (condition) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        LOG_ERROR</span><span style=\"color:#E1E4E8\">(msg); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup helper for partial failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cleanup_list {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup_func)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register cleanup function to call on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute all registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* ERROR_H */</span></span></code></pre></div>\n\n<p><strong>src/utils/syscall_wrappers.c</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/syscall.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"error.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe wrapper for clone() syscall with error checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#B392F0\"> safe_clone</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fn)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">stack</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate stack pointer (common mistake)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">stack) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack, flags, arg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        LOG_ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clone() failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe wrapper for mount() with detailed error reporting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> safe_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">filesystemtype</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> mountflags</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(source, target, filesystemtype, mountflags, data);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> error_msg</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(error_msg, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(error_msg), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"mount(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">) failed\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                source </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> source </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                target </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                filesystemtype </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> filesystemtype </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        LOG_ERROR</span><span style=\"color:#E1E4E8\">(error_msg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create directory with parent directories, ignore if exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> ensure_directory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(cmd, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cmd), </span><span style=\"color:#9ECBFF\">\"mkdir -p </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> system</span><span style=\"color:#E1E4E8\">(cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        LOG_ERROR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create directory\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton\">Core Logic Skeleton</h4>\n<p>The learner implements the main coordination logic that orchestrates namespace creation and cgroup setup. This skeleton maps directly to the conceptual understanding from the apartment building model:</p>\n<p><strong>src/container.h</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> CONTAINER_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container configuration - the \"apartment lease agreement\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> container_config {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">rootfs_path;</span><span style=\"color:#6A737D\">           // Path to container filesystem root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">hostname;</span><span style=\"color:#6A737D\">              // Container hostname (UTS namespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource limits (cgroups configuration)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> memory_limit_bytes;</span><span style=\"color:#6A737D\">   // Memory limit (0 = unlimited)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cpu_percent;</span><span style=\"color:#6A737D\">             // CPU percentage (0-100, 0 = unlimited)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_processes;</span><span style=\"color:#6A737D\">           // Maximum number of processes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Network configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bridge_name;</span><span style=\"color:#6A737D\">           // Host bridge to connect to</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">container_ip;</span><span style=\"color:#6A737D\">          // IP address for container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Command to run inside container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span><span style=\"color:#6A737D\">                 // Command and arguments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">envp;</span><span style=\"color:#6A737D\">                 // Environment variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container instance - tracks the \"apartment tenant\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> container_instance {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child_pid;</span><span style=\"color:#6A737D\">             // Main process PID in container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> namespace_fds</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">        // File descriptors for namespaces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cgroup_path;</span><span style=\"color:#6A737D\">           // Path to container's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cleanup;</span><span style=\"color:#6A737D\">     // Cleanup functions for failure recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main container lifecycle functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> /* CONTAINER_H */</span></span></code></pre></div>\n\n<p><strong>src/container.c</strong> (skeleton for learner implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"container.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"namespace/namespace.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cgroups/cgroups.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"utils/error.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Child process entry point - runs inside all namespaces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> container_child_main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set up mount namespace and pivot to new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call mount_namespace_setup(config->rootfs_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This gives the container its own filesystem view</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up network namespace networking  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call network_namespace_setup(config->container_ip)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This configures the container's network interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set hostname in UTS namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use sethostname(config->hostname, strlen(config->hostname))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up minimal /proc and /sys filesystems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: mount(\"proc\", \"/proc\", \"proc\", 0, NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //       mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Drop privileges if running as root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This is a good place to switch to non-root user</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Execute the target command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: execve(config->argv[0], config->argv, config->envp)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This should never return on success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Should never reach here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child_pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create cgroups and set resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call cgroups_create_and_configure(config, &#x26;container->cgroup_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This must happen before clone() so child can be added to cgroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate stack for clone() call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use malloc(STACK_SIZE) and adjust for stack growth direction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remember: stacks grow downward on most architectures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call clone() with appropriate namespace flags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: flags = CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUTS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use safe_clone() wrapper to create child in new namespaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add child process to cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call cgroups_add_process(container->cgroup_path, child_pid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This enforces resource limits on the container process tree</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set up network connectivity from host side</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call network_setup_host_side(child_pid, config->bridge_name)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This creates veth pair and configures bridge connection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store namespace file descriptors for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Open /proc/child_pid/ns/* files and store in container->namespace_fds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // These allow cleanup even if child process exits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    container->child_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> child_pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Wait for container process to exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use waitpid(container->child_pid, &#x26;status, 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This blocks until the container's main process terminates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle zombie process reaping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Container may have spawned child processes that need reaping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for additional processes in the PID namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return exit status from container process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use WEXITSTATUS(status) if WIFEXITED(status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Terminate container process if still running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Send SIGTERM, wait briefly, then SIGKILL if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Clean up network interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Remove veth pair and bridge configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove cgroup and clean up hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call cgroups_destroy(container->cgroup_path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Close namespace file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Close all fds in container->namespace_fds array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Execute any registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: execute_cleanup(&#x26;container->cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-notes\">Language-Specific Implementation Notes</h4>\n<p>Working with Linux namespaces and cgroups in C requires attention to several system-specific details:</p>\n<p><strong>Stack Management for clone():</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1MB stack</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate stack growing downward (most architectures)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span><span style=\"color:#6A737D\">  // Point to high address</span></span></code></pre></div>\n\n<p><strong>Namespace Flags Reference:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Common namespace combinations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_NS_FLAGS</span><span style=\"color:#E1E4E8\"> (CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNET </span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWIPC)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// For testing individual namespaces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> PID_ONLY_FLAGS</span><span style=\"color:#E1E4E8\"> CLONE_NEWPID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MOUNT_ONLY_FLAGS</span><span style=\"color:#E1E4E8\"> CLONE_NEWNS</span></span></code></pre></div>\n\n<p><strong>Cgroups Filesystem Paths:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Check which cgroups version is available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROUPS_V1_PATH</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROUPS_V2_PATH</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup/unified\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container-specific cgroup naming</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_CGROUP_PREFIX</span><span style=\"color:#9ECBFF\"> \"container-basic\"</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each milestone, verify the isolation is working correctly:</p>\n<p><strong>Milestone 1 - PID Namespace Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">./container-basic</span><span style=\"color:#9ECBFF\"> /bin/bash</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container, check process isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#6A737D\">                    # Should only see processes in container</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $$</span><span style=\"color:#6A737D\">                   # Should show PID 1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/sys/kernel/pid_max</span><span style=\"color:#6A737D\">  # Should work (need /proc mounted)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Outside container (different terminal)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> container-basic</span><span style=\"color:#6A737D\">  # Should see real host PID</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong> Container process sees itself as PID 1 and can only see processes within its PID namespace. Host can see the container process with its real PID.</p>\n<p><strong>Milestone 2 - Mount Namespace Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run container with custom rootfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container-basic</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> ./test-rootfs</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#6A737D\">                      # Should see only container filesystem</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> proc</span><span style=\"color:#6A737D\">         # Should show container's /proc mount</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">touch</span><span style=\"color:#9ECBFF\"> /test-file</span><span style=\"color:#6A737D\">          # Should not appear on host filesystem</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Outside container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /</span><span style=\"color:#6A737D\">                      # Should see normal host filesystem  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> ./test-rootfs/</span><span style=\"color:#6A737D\">         # Should see test-file if bind-mounted</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong> Container has completely different filesystem view. Changes inside container don&#39;t affect host filesystem unless explicitly bind-mounted.</p>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li>Container sees host filesystem: Mount namespace not created properly</li>\n<li>Container can&#39;t access /proc: Forgot to mount proc filesystem inside container</li>\n<li>pivot_root fails: Check that new root has old_root directory and is on different filesystem</li>\n</ul>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section defines the scope for all milestones (1-4), establishing clear boundaries for what our basic container runtime will implement versus advanced features left for future development.</p>\n</blockquote>\n<h3 id=\"mental-model-building-a-safe-playground\">Mental Model: Building a Safe Playground</h3>\n<p>Think of our container system like designing a safe playground for children. We need to provide essential safety features - fences to keep kids in the right area (process isolation), separate sandboxes so they don&#39;t interfere with each other (namespaces), and rules about how many swings each child can use (resource limits). However, we&#39;re not building a full amusement park with roller coasters, water slides, and gift shops (advanced orchestration features). Our goal is a functional, safe playground that demonstrates the core safety mechanisms, not a commercial-grade entertainment complex.</p>\n<p>Just as a playground designer must decide which safety features are essential versus which amenities can be added later, we must clearly define what isolation primitives are fundamental to container functionality versus what advanced features would distract from learning the core concepts. This section establishes those boundaries to keep our implementation focused and educational.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>Our basic container runtime must provide the four fundamental pillars of container technology: process isolation, filesystem isolation, network isolation, and resource control. These represent the minimum viable container implementation that demonstrates how modern container runtimes like Docker and containerd work under the hood.</p>\n<h4 id=\"core-isolation-capabilities\">Core Isolation Capabilities</h4>\n<p>The primary functional goal is implementing <strong>process isolation</strong> through Linux namespaces. Our container must create isolated views of system resources so that processes inside the container cannot interfere with or observe processes on the host system or in other containers. This isolation forms the security boundary that makes containers useful for running untrusted code safely.</p>\n<table>\n<thead>\n<tr>\n<th>Isolation Type</th>\n<th>Namespace</th>\n<th>Goal Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process Tree</td>\n<td>PID</td>\n<td>Container processes see isolated PID numbering starting from PID 1</td>\n</tr>\n<tr>\n<td>Filesystem</td>\n<td>Mount</td>\n<td>Container has private filesystem root with essential system directories</td>\n</tr>\n<tr>\n<td>Network Stack</td>\n<td>Network</td>\n<td>Container has isolated network interfaces and routing tables</td>\n</tr>\n<tr>\n<td>System Identity</td>\n<td>UTS</td>\n<td>Container can have different hostname without affecting host</td>\n</tr>\n<tr>\n<td>Inter-Process Communication</td>\n<td>IPC</td>\n<td>Container has private message queues and shared memory segments</td>\n</tr>\n</tbody></table>\n<p>The <strong>PID namespace</strong> isolation must ensure that the container&#39;s init process appears as PID 1 within the container while the host sees the real process ID. This creates the fundamental process boundary that prevents container processes from sending signals to host processes or observing the full system process tree. The container&#39;s init process must properly handle zombie reaping responsibilities that normally belong to the system&#39;s init process.</p>\n<p><strong>Filesystem isolation</strong> through mount namespaces must provide a private filesystem view where the container can mount and unmount filesystems without affecting the host. Our implementation must use <code>pivot_root</code> to switch the container to a new filesystem root, mount essential filesystems like <code>/proc</code> and <code>/sys</code> inside the container, and ensure that mount operations inside the container don&#39;t propagate to the host system.</p>\n<p><strong>Network isolation</strong> through network namespaces must give the container its own network stack with private interfaces, routing tables, and firewall rules. The container should be able to bind to any port without conflicting with host services, and we must implement connectivity between the container and host using veth pairs connected to a bridge network.</p>\n<h4 id=\"resource-control-requirements\">Resource Control Requirements</h4>\n<p>The second pillar is <strong>resource limitation</strong> through Linux cgroups. Our container must prevent runaway processes from consuming all system resources and affecting other containers or host processes. This implements the &quot;noisy neighbor&quot; protection essential for multi-tenant systems.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Control Mechanism</th>\n<th>Goal Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory</td>\n<td>Memory Controller</td>\n<td>Hard limit on RAM usage with OOM killing when exceeded</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>CPU Controller</td>\n<td>Proportional CPU time allocation using quota and period</td>\n</tr>\n<tr>\n<td>Processes</td>\n<td>PIDs Controller</td>\n<td>Maximum number of processes to prevent fork bombs</td>\n</tr>\n<tr>\n<td>File Descriptors</td>\n<td>Files Controller</td>\n<td>Limit open file handles to prevent descriptor exhaustion</td>\n</tr>\n</tbody></table>\n<p>The memory controller must enforce hard limits where processes are killed by the Out-of-Memory (OOM) killer when they exceed their allocation. This prevents memory leaks or memory-intensive applications from consuming all system RAM. Our implementation must demonstrate both setting the limit and observing the enforcement behavior when limits are exceeded.</p>\n<p>CPU control must implement proportional sharing using the CPU quota and period mechanism. Rather than hard CPU limits (which can cause performance issues), our container should receive a guaranteed minimum CPU allocation while being able to burst above that allocation when CPU is available. This provides predictable performance isolation without wasting resources.</p>\n<h4 id=\"configuration-and-lifecycle-management\">Configuration and Lifecycle Management</h4>\n<p>Our container runtime must provide a clean configuration interface and proper lifecycle management. The configuration should be declarative, specifying desired resource limits and networking parameters without requiring users to understand the underlying namespace and cgroup implementation details.</p>\n<table>\n<thead>\n<tr>\n<th>Lifecycle Phase</th>\n<th>Required Capabilities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Creation</td>\n<td>Parse configuration, validate parameters, prepare filesystem</td>\n</tr>\n<tr>\n<td>Startup</td>\n<td>Create namespaces, setup cgroups, fork container process</td>\n</tr>\n<tr>\n<td>Running</td>\n<td>Monitor container process, handle signals, maintain isolation</td>\n</tr>\n<tr>\n<td>Cleanup</td>\n<td>Destroy namespaces, remove cgroups, cleanup filesystem mounts</td>\n</tr>\n</tbody></table>\n<p>The container creation process must validate that all specified parameters are achievable (sufficient memory available, valid network configuration, accessible root filesystem) before beginning namespace creation. This prevents partial container creation that leaves system resources in an inconsistent state.</p>\n<p>Container cleanup must be robust and handle partial failure scenarios. If namespace creation fails partway through, the cleanup process must remove any successfully created namespaces and cgroups. This prevents resource leaks that could accumulate over time and affect system stability.</p>\n<h4 id=\"error-handling-and-recovery\">Error Handling and Recovery</h4>\n<p>Our container runtime must gracefully handle common failure scenarios and provide meaningful error messages that help users diagnose configuration problems. The most common failures involve insufficient privileges, missing kernel features, and resource exhaustion.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Category</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Insufficient Privileges</td>\n<td>Check for CAP_SYS_ADMIN before namespace creation</td>\n<td>Provide clear error about required capabilities</td>\n</tr>\n<tr>\n<td>Missing Kernel Features</td>\n<td>Test namespace creation with CLONE_* flags</td>\n<td>Report which namespaces are unsupported</td>\n</tr>\n<tr>\n<td>Resource Exhaustion</td>\n<td>Monitor cgroup creation and process limits</td>\n<td>Fail fast with resource availability information</td>\n</tr>\n<tr>\n<td>Configuration Errors</td>\n<td>Validate filesystem paths and network parameters</td>\n<td>Report specific configuration problems</td>\n</tr>\n</tbody></table>\n<p>The error handling must distinguish between temporary failures (resource exhaustion) and permanent failures (missing kernel features). Temporary failures should be retryable, while permanent failures should provide guidance on system requirements or configuration changes needed.</p>\n<h3 id=\"non-goals\">Non-Goals</h3>\n<p>Clearly defining what we will NOT implement is equally important as defining our goals. These non-goals keep our implementation focused on learning core container isolation primitives rather than building a production container runtime with enterprise features.</p>\n<h4 id=\"container-image-management\">Container Image Management</h4>\n<p>We will NOT implement container image formats, image layers, or image registries. Our container will work with a simple directory containing a root filesystem, not with Docker images, OCI images, or layered filesystems. This means no support for:</p>\n<ul>\n<li>Image pulling from registries like Docker Hub</li>\n<li>Image layer caching and deduplication</li>\n<li>Dockerfile parsing and image building</li>\n<li>Image vulnerability scanning</li>\n<li>Multi-architecture image support</li>\n</ul>\n<p>The rationale is that image management is a separate concern from process isolation. Understanding how to create namespaces and cgroups is independent of understanding how to manage layered filesystems. Implementing image support would require overlay filesystems, cryptographic hash validation, and network protocols that would distract from the core learning objectives.</p>\n<p>Users will need to prepare their own root filesystem directory containing the files and directory structure needed for their containerized application. This could be created by extracting an existing Docker image or by manually assembling the required files.</p>\n<h4 id=\"container-orchestration-and-clustering\">Container Orchestration and Clustering</h4>\n<p>We will NOT implement multi-container coordination, service discovery, or container orchestration features. Our runtime will manage single containers in isolation without any knowledge of other containers or cluster-wide policies. This excludes:</p>\n<ul>\n<li>Container scheduling across multiple hosts</li>\n<li>Service mesh and load balancing between containers</li>\n<li>Container health checks and automatic restart policies</li>\n<li>Volume management and persistent storage</li>\n<li>Secrets management and configuration distribution</li>\n<li>Rolling updates and blue-green deployment strategies</li>\n</ul>\n<p>These features belong to container orchestration platforms like Kubernetes, Docker Swarm, or Nomad. Our basic container runtime serves as the foundation that orchestrators build upon, but implementing orchestration features would require distributed systems concepts (consensus, leader election, cluster membership) that are beyond our scope.</p>\n<h4 id=\"advanced-security-features\">Advanced Security Features</h4>\n<p>We will NOT implement advanced security isolation beyond basic namespaces. Our security model relies on namespace isolation and assumes containers run with appropriate user privileges. We will not provide:</p>\n<ul>\n<li>User namespace mapping for rootless containers  </li>\n<li>SELinux or AppArmor integration for mandatory access control</li>\n<li>Seccomp filtering to restrict system call access</li>\n<li>Container image signing and signature verification</li>\n<li>Runtime security monitoring and anomaly detection</li>\n<li>Network policy enforcement and micro-segmentation</li>\n</ul>\n<p>While these features are important for production container security, they require deep knowledge of Linux security modules and cryptographic systems. Our basic implementation demonstrates the fundamental isolation mechanisms that these advanced features build upon.</p>\n<h4 id=\"performance-optimization-and-enterprise-features\">Performance Optimization and Enterprise Features</h4>\n<p>We will NOT implement performance optimizations or enterprise-grade reliability features. Our focus is on correctness and educational value, not on production performance or scalability. This means no:</p>\n<ul>\n<li>Container startup time optimization through pre-warming or caching</li>\n<li>Resource usage monitoring and metrics collection  </li>\n<li>Log aggregation and centralized logging infrastructure</li>\n<li>Backup and disaster recovery for container data</li>\n<li>High availability and failover mechanisms</li>\n<li>Performance profiling and resource usage analytics</li>\n</ul>\n<p>These features would require sophisticated monitoring infrastructure, storage systems, and distributed computing concepts that would obscure the core container isolation mechanisms we&#39;re trying to understand.</p>\n<blockquote>\n<p><strong>Key Design Principle</strong>: We prioritize understanding over features. Every component we implement must clearly demonstrate a core container isolation concept. Any feature that doesn&#39;t directly contribute to understanding namespaces, cgroups, or basic container lifecycle is explicitly out of scope.</p>\n</blockquote>\n<h4 id=\"network-policy-and-advanced-networking\">Network Policy and Advanced Networking</h4>\n<p>While we implement basic container networking through veth pairs and bridge networking, we will NOT implement advanced networking features that production container platforms provide:</p>\n<ul>\n<li>Network policies and firewall rule management</li>\n<li>Service mesh integration with encrypted inter-container communication</li>\n<li>Load balancing and traffic routing between containers</li>\n<li>Network address translation (NAT) with port forwarding rules</li>\n<li>VLAN tagging and advanced network topologies</li>\n<li>Container network interface (CNI) plugin architecture</li>\n</ul>\n<p>Our networking implementation demonstrates how containers achieve network isolation and basic connectivity. Advanced networking features require understanding of network protocols, traffic engineering, and distributed networking concepts that are separate from the core isolation mechanisms.</p>\n<h4 id=\"storage-and-filesystem-features\">Storage and Filesystem Features</h4>\n<p>Beyond basic mount namespace isolation, we will NOT implement advanced storage features:</p>\n<ul>\n<li>Volume mounting with different filesystem types</li>\n<li>Container data persistence across container restarts</li>\n<li>Filesystem encryption and secure data handling</li>\n<li>Storage quotas and disk usage monitoring</li>\n<li>Snapshot and backup functionality for container filesystems</li>\n<li>Distributed storage integration</li>\n</ul>\n<p>Our filesystem isolation demonstrates how containers achieve private filesystem views using mount namespaces and <code>pivot_root</code>. Storage management involves understanding filesystem drivers, storage protocols, and data durability concepts that would distract from namespace learning objectives.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete technical recommendations for implementing the goals defined above while avoiding the complexity of features marked as non-goals.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace Creation</td>\n<td><code>clone()</code> system call with <code>CLONE_NEW*</code> flags</td>\n<td><code>unshare()</code> with separate process creation</td>\n</tr>\n<tr>\n<td>Mount Management</td>\n<td>Direct <code>mount()</code> and <code>pivot_root()</code> calls</td>\n<td><code>libmount</code> library for complex mount operations</td>\n</tr>\n<tr>\n<td>Network Setup</td>\n<td>Manual veth and bridge creation via netlink</td>\n<td>CNI (Container Network Interface) plugins</td>\n</tr>\n<tr>\n<td>Cgroups Interface</td>\n<td>Direct filesystem writes to <code>/sys/fs/cgroup</code></td>\n<td><code>libcgroup</code> library for abstraction</td>\n</tr>\n<tr>\n<td>Configuration Format</td>\n<td>Simple key-value text file or command line args</td>\n<td>YAML/JSON with schema validation</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td><code>errno</code> values with <code>perror()</code> messages</td>\n<td>Structured error codes with detailed context</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, choose the simple options to understand the underlying mechanisms directly. Advanced options abstract away the details we want to understand.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Organize the codebase to separate concerns and make testing easier:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n├── src/\n│   ├── main.c                    ← CLI entry point and argument parsing\n│   ├── container.c               ← Core container lifecycle (create/wait/destroy)\n│   ├── container.h               ← Public API and data structure definitions\n│   ├── namespaces.c              ← Namespace creation and management\n│   ├── mounts.c                  ← Filesystem mounting and pivot_root\n│   ├── network.c                 ← Network namespace and veth setup\n│   ├── cgroups.c                 ← Resource limit configuration\n│   ├── cleanup.c                 ← Error recovery and resource cleanup\n│   └── utils.c                   ← Helper functions and system call wrappers\n├── tests/\n│   ├── test_isolation.c          ← Verify namespace isolation works\n│   ├── test_resources.c          ← Verify cgroup limits are enforced\n│   └── test_networking.c         ← Verify container networking\n├── rootfs/                       ← Sample root filesystem for testing\n│   ├── bin/\n│   ├── etc/\n│   └── proc/                     ← Will be mounted inside container\n└── Makefile                      ← Build system with test targets</code></pre></div>\n\n<h4 id=\"core-data-structure-implementation\">Core Data Structure Implementation</h4>\n<p>Implement the configuration and instance structures to match our naming conventions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// container.h - Core data structures</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_NS_FLAGS</span><span style=\"color:#E1E4E8\"> (CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNET </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWIPC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROUPS_V1_PATH</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROUPS_V2_PATH</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup/unified\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_CGROUP_PREFIX</span><span style=\"color:#9ECBFF\"> \"container-basic\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container configuration - what the user specifies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">rootfs_path;</span><span style=\"color:#6A737D\">           // Path to container root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">hostname;</span><span style=\"color:#6A737D\">              // Container hostname (UTS namespace)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> memory_limit_bytes;</span><span style=\"color:#6A737D\">   // Memory limit in bytes (0 = no limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cpu_percent;</span><span style=\"color:#6A737D\">             // CPU percentage (0-100, 0 = no limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_processes;</span><span style=\"color:#6A737D\">           // Maximum process count (0 = no limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bridge_name;</span><span style=\"color:#6A737D\">           // Host bridge name for networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">container_ip;</span><span style=\"color:#6A737D\">          // IP address for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span><span style=\"color:#6A737D\">                 // Command and arguments to run</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">envp;</span><span style=\"color:#6A737D\">                 // Environment variables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container instance - runtime state and cleanup handles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child_pid;</span><span style=\"color:#6A737D\">             // PID of container init process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> namespace_fds</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">        // File descriptors for namespaces (PID, mount, net, UTS, IPC, user)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cgroup_path;</span><span style=\"color:#6A737D\">           // Path to container's cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup;</span><span style=\"color:#6A737D\"> // Linked list of cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup function registration for error recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cleanup_list {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup_func)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // Function to call for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data;</span><span style=\"color:#6A737D\">                   // Data to pass to cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span><span style=\"color:#6A737D\">    // Next cleanup function in list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">;</span></span></code></pre></div>\n\n<h4 id=\"core-api-skeleton\">Core API Skeleton</h4>\n<p>Implement the main container API functions with detailed TODOs mapping to the milestone requirements:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// container.c - Main container lifecycle implementation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * container_create - Create and start a new container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@config:</span><span style=\"color:#6A737D\"> Container configuration specifying resources and command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@container:</span><span style=\"color:#6A737D\"> Output parameter filled with container instance data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns: 0 on success, -1 on failure (check errno for details)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate configuration parameters (rootfs_path exists, memory_limit reasonable, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize cleanup list for error recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create cgroup hierarchy and set resource limits (Milestone 4)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Prepare container root filesystem and create necessary directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Allocate stack for clone() call (use STACK_SIZE constant)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Call safe_clone() with CONTAINER_NS_FLAGS and container init function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: In parent: store child PID and namespace file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: In parent: setup networking (create veth pair, configure bridge) (Milestone 3)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: In parent: move container process into cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return success, container instance now contains cleanup handles</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Error handling: call execute_cleanup() if any step fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * container_wait - Wait for container process to exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@container:</span><span style=\"color:#6A737D\"> Container instance to wait for</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns: Exit status of container process, -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Use waitpid() to wait for child_pid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle SIGCHLD signals appropriately  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return WEXITSTATUS() for normal exit, WTERMSIG() for signals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use WIFEXITED() and WIFSIGNALED() to distinguish exit types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * container_destroy - Clean up all container resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span><span style=\"color:#F97583\">@container:</span><span style=\"color:#6A737D\"> Container instance to destroy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * Returns: 0 on success, -1 if some cleanup failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Send SIGTERM to container process if still running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for graceful shutdown, then SIGKILL if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute all registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Close namespace file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove cgroup directory and all files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Free allocated memory in container instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: Continue cleanup even if some steps fail, return overall status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"system-call-wrapper-functions\">System Call Wrapper Functions</h4>\n<p>Implement safe wrappers for system calls that provide better error reporting:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// utils.c - System call wrappers with error handling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * safe_clone - Wrapper for clone() with error checking and logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#B392F0\"> safe_clone</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fn)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">stack</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate stack top address (stack grows down on most architectures)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call clone() with provided parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for -1 return value and log specific error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For EPERM errors, suggest checking capabilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For EINVAL errors, check which CLONE_ flags are unsupported</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strerror(errno) for human-readable error messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * safe_mount - Wrapper for mount() with detailed error reporting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> safe_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">filesystemtype</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> mountflags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that target directory exists before mounting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call mount() with provided parameters  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: On failure, log source, target, and filesystem type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For EACCES, suggest checking permissions or capabilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For ENODEV, suggest checking if filesystem type is supported</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Print mount command equivalent for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * register_cleanup - Add cleanup function to be called on error or exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate new cleanup_list_t node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set function pointer and data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Insert at head of linked list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle malloc() failure gracefully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">/**</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> * execute_cleanup - Call all registered cleanup functions in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> */</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Traverse linked list and call each cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Pass stored data pointer to each function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Continue even if cleanup functions fail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Free cleanup_list_t nodes after calling functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log any errors but don't propagate them</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each milestone, verify the functionality with these specific tests:</p>\n<p><strong>Milestone 1 (PID Namespace):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run basic PID namespace test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_pid_namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_pid_namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container process reports PID 1 when running `echo $$`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Host can see real PID (e.g., 12345) in process table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container cannot see host processes in `ps` output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container init properly reaps zombie child processes</span></span></code></pre></div>\n\n<p><strong>Milestone 2 (Mount Namespace):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test filesystem isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_mount_namespace</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_mount_namespace</span><span style=\"color:#9ECBFF\"> /tmp/test_rootfs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container sees different root filesystem than host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container can mount /proc and see only container processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Mount operations inside container don't affect host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container cannot access host filesystem outside mounted volumes</span></span></code></pre></div>\n\n<p><strong>Milestone 3 (Network Namespace):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test network isolation and connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_network_namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_network_namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container has different network interfaces than host (ip addr show)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container can ping its own IP address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container can reach external networks through host bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Host can communicate with container through veth pair</span></span></code></pre></div>\n\n<p><strong>Milestone 4 (Cgroups):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test resource limits enforcement</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_cgroups</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_cgroups</span><span style=\"color:#79B8FF\"> --memory-limit=100M</span><span style=\"color:#79B8FF\"> --cpu-percent=50</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Memory-intensive process gets OOM killed at 100MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - CPU usage stays around 50% under sustained load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Process count limited to configured maximum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Cgroup files show current resource usage</span></span></code></pre></div>\n\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<p>When container creation fails, use these debugging techniques:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>clone() returns EPERM</td>\n<td>Missing CAP_SYS_ADMIN</td>\n<td>Run <code>getcap /path/to/binary</code> or check <code>id</code></td>\n<td>Run as root or add capabilities</td>\n</tr>\n<tr>\n<td>mount() fails with EACCES</td>\n<td>SELinux or permission issue</td>\n<td>Check <code>dmesg</code> and <code>/var/log/audit/audit.log</code></td>\n<td>Disable SELinux or fix context</td>\n</tr>\n<tr>\n<td>Container sees host processes</td>\n<td>PID namespace not created</td>\n<td>Check <code>/proc/self/ns/pid</code> in container</td>\n<td>Verify CLONE_NEWPID flag</td>\n</tr>\n<tr>\n<td>Network unreachable</td>\n<td>veth pair misconfigured</td>\n<td>Run <code>ip addr</code> and <code>ip route</code> in container</td>\n<td>Check bridge and routing setup</td>\n</tr>\n<tr>\n<td>Process killed immediately</td>\n<td>Memory limit too low</td>\n<td>Check <code>dmesg</code> for OOM killer messages</td>\n<td>Increase memory limit or check usage</td>\n</tr>\n<tr>\n<td>Cgroup creation fails</td>\n<td>cgroups v2 vs v1 mismatch</td>\n<td>Check <code>/proc/filesystems</code> for cgroup2</td>\n<td>Use correct cgroup path and API</td>\n</tr>\n</tbody></table>\n<p>Use these inspection commands during debugging:</p>\n<ul>\n<li><code>lsns</code> - List all namespaces and their processes</li>\n<li><code>nsenter -t &lt;pid&gt; -p -n -m &lt;command&gt;</code> - Enter container namespaces</li>\n<li><code>cat /proc/&lt;pid&gt;/cgroup</code> - Show process cgroup membership</li>\n<li><code>cat /sys/fs/cgroup/memory/&lt;cgroup&gt;/memory.usage_in_bytes</code> - Check memory usage</li>\n</ul>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides architectural foundation for all milestones (1-4), establishing the component structure and relationships needed to implement PID namespaces, mount namespaces, network namespaces, and cgroups resource management.</p>\n</blockquote>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>Think of our container runtime as a <strong>theater production company</strong> that needs to set up completely isolated stages for different performances. Just as a theater company has specialized departments—set design (mount namespace), lighting and sound (network), casting and direction (process management), and budget control (resource limits)—our container runtime has specialized managers that coordinate to create perfect isolation for each &quot;performance&quot; (container).</p>\n<p>Our container runtime architecture centers around four core managers that work together to create process isolation. Each manager has a specific responsibility and operates semi-independently, but they must coordinate carefully during container startup and cleanup to avoid timing issues and resource leaks.</p>\n<p>The <strong>namespace managers</strong> handle different aspects of process isolation. The PID namespace manager creates isolated process trees where the container&#39;s init process appears as PID 1. The mount namespace manager creates isolated filesystem views and handles the complex pivot_root operation to switch the container&#39;s root directory. The network namespace manager creates isolated network stacks and sets up connectivity through virtual ethernet pairs.</p>\n<p>The <strong>cgroup manager</strong> operates orthogonally to the namespace managers, focusing purely on resource limits rather than isolation. It creates cgroup hierarchies and assigns the container process to appropriate cgroups with memory, CPU, and process limits configured.</p>\n<p>These managers are coordinated by a <strong>container orchestrator</strong> that handles the precise sequencing required during container creation. This orchestration is critical because namespace creation must happen in a specific order, and cgroup assignment must occur at exactly the right moment in the process lifecycle.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"Container System Component Overview\"></p>\n<p>The following table describes each major component and its primary responsibilities:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Key Operations</th>\n<th>Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container Orchestrator</td>\n<td>Coordinates startup/cleanup sequence</td>\n<td><code>container_create()</code>, <code>container_wait()</code>, <code>container_destroy()</code></td>\n<td>All managers</td>\n</tr>\n<tr>\n<td>PID Namespace Manager</td>\n<td>Process isolation and PID 1 duties</td>\n<td><code>clone()</code> with <code>CLONE_NEWPID</code>, zombie reaping</td>\n<td>None</td>\n</tr>\n<tr>\n<td>Mount Namespace Manager</td>\n<td>Filesystem isolation</td>\n<td><code>unshare(CLONE_NEWNS)</code>, <code>pivot_root()</code>, essential mounts</td>\n<td>PID namespace</td>\n</tr>\n<tr>\n<td>Network Namespace Manager</td>\n<td>Network stack isolation</td>\n<td><code>unshare(CLONE_NEWNET)</code>, veth pair setup, bridge config</td>\n<td>Mount namespace</td>\n</tr>\n<tr>\n<td>Cgroup Manager</td>\n<td>Resource limit enforcement</td>\n<td>Cgroup creation, process assignment, limit configuration</td>\n<td>PID namespace</td>\n</tr>\n<tr>\n<td>Cleanup Manager</td>\n<td>Resource cleanup and error recovery</td>\n<td>Cleanup function registration and execution</td>\n<td>All managers</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: The key architectural challenge is that Linux kernel namespaces and cgroups were designed as independent mechanisms, but containers require them to work together seamlessly. Our architecture acknowledges this by keeping the managers loosely coupled but providing strong coordination through the orchestrator and cleanup system.</p>\n</blockquote>\n<h4 id=\"container-orchestrator-responsibilities\">Container Orchestrator Responsibilities</h4>\n<p>The container orchestrator serves as the main entry point and coordination layer. It maintains the <code>container_instance_t</code> structure that tracks all active resources associated with a container. During startup, it sequences the manager operations to avoid race conditions—for example, ensuring the PID namespace exists before attempting cgroup assignment, or ensuring mount namespace isolation before setting up network connectivity.</p>\n<p>The orchestrator also implements the <strong>cleanup registration pattern</strong>. Each manager registers cleanup functions as it creates resources, building a cleanup chain that can be executed in reverse order during normal shutdown or error recovery. This approach ensures that even if container creation fails halfway through, all successfully created resources get properly cleaned up.</p>\n<h4 id=\"namespace-manager-coordination\">Namespace Manager Coordination</h4>\n<p>The three namespace managers must coordinate carefully because kernel namespace operations have subtle ordering dependencies. The PID namespace manager always runs first because it fundamentally changes how process creation works—subsequent operations need to account for the new PID space. The mount namespace manager runs second because filesystem isolation affects where network configuration tools can find their resources. The network namespace manager runs last because it often needs to access files and execute commands that depend on the filesystem isolation being in place.</p>\n<p>Each namespace manager maintains file descriptors to the created namespaces in the <code>namespace_fds</code> array. These descriptors serve dual purposes: they keep the namespaces alive even if the initial process exits, and they provide handles for external tools like debuggers to enter the namespaces for inspection.</p>\n<h4 id=\"cgroup-manager-integration\">Cgroup Manager Integration</h4>\n<p>The cgroup manager operates differently from the namespace managers because cgroups work through filesystem operations rather than system calls. It creates directories in the cgroup filesystem hierarchy, writes configuration files to set limits, and assigns process IDs to the appropriate cgroup. Unlike namespaces, cgroups can be modified after container startup, allowing for dynamic resource limit adjustments.</p>\n<p>The cgroup manager must handle both cgroups v1 and v2 hierarchies because different Linux distributions use different defaults. It detects the available cgroup version at startup and adapts its filesystem paths and configuration syntax accordingly.</p>\n<blockquote>\n<p><strong>Architecture Decision Record: Component Separation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to organize namespace and resource management code that involves complex kernel interactions and precise timing</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Monolithic container creation function with all operations inline</li>\n<li>Separate managers with loose coupling and shared state</li>\n<li>Separate managers with strict interfaces and no shared state</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate managers with loose coupling through shared <code>container_instance_t</code> structure</li>\n<li><strong>Rationale</strong>: Each type of isolation (PID, mount, network, cgroups) has distinct kernel APIs and failure modes that benefit from specialized handling, but they need to coordinate timing and share cleanup responsibilities</li>\n<li><strong>Consequences</strong>: More complex orchestration logic but much better testability, debugging, and maintainability of individual isolation mechanisms</li>\n</ul>\n</blockquote>\n<p>The following table compares the architectural options:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Monolithic Function</td>\n<td>Simple control flow, no coordination complexity</td>\n<td>Impossible to test individual mechanisms, difficult to debug failures</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Loose Coupling</td>\n<td>Easy coordination, shared cleanup, simple interfaces</td>\n<td>Some shared state complexity</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Strict Separation</td>\n<td>Perfect isolation, no shared state</td>\n<td>Complex coordination, duplicate cleanup logic, rigid interfaces</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>Organizing the codebase properly from the beginning prevents the common mistake of putting all container logic in a single massive file. Our file structure reflects the component architecture and makes it easy to test individual managers in isolation while maintaining clear dependencies.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n├── src/\n│   ├── main.c                    ← Entry point, argument parsing, basic container operations\n│   ├── container.h               ← Main public API and shared data structures\n│   ├── container.c               ← Container orchestrator implementation\n│   ├── namespaces/\n│   │   ├── pid_namespace.h       ← PID namespace manager interface\n│   │   ├── pid_namespace.c       ← PID namespace implementation, zombie reaping\n│   │   ├── mount_namespace.h     ← Mount namespace manager interface  \n│   │   ├── mount_namespace.c     ← Mount namespace, pivot_root, essential mounts\n│   │   ├── network_namespace.h   ← Network namespace manager interface\n│   │   └── network_namespace.c   ← Network namespace, veth pairs, bridge setup\n│   ├── cgroups/\n│   │   ├── cgroup_manager.h      ← Cgroup manager interface\n│   │   ├── cgroup_manager.c      ← Cgroup creation, limits, process assignment\n│   │   ├── cgroup_v1.c          ← Cgroups v1 specific implementation\n│   │   └── cgroup_v2.c          ← Cgroups v2 specific implementation\n│   ├── utils/\n│   │   ├── cleanup.h            ← Cleanup registration and execution\n│   │   ├── cleanup.c            ← Cleanup manager implementation\n│   │   ├── syscall_wrappers.h   ← Safe syscall wrappers with error handling\n│   │   ├── syscall_wrappers.c   ← Implementation of safe_clone, safe_mount, etc.\n│   │   └── logging.h            ← Logging utilities for debugging\n│   └── logging.c                ← Logging implementation\n├── tests/\n│   ├── test_container.c         ← Integration tests for full container lifecycle\n│   ├── test_pid_namespace.c     ← Unit tests for PID isolation\n│   ├── test_mount_namespace.c   ← Unit tests for filesystem isolation\n│   ├── test_network_namespace.c ← Unit tests for network isolation\n│   ├── test_cgroups.c           ← Unit tests for resource limits\n│   └── test_utils.c             ← Unit tests for utility functions\n├── examples/\n│   ├── simple_container.c       ← Basic usage example\n│   ├── resource_limited.c       ← Example with cgroup limits\n│   └── networked_container.c    ← Example with network connectivity\n├── rootfs/                      ← Example root filesystem for testing\n│   ├── bin/                     ← Basic utilities (busybox, etc.)\n│   ├── etc/                     ← Configuration files\n│   └── proc/                    ← Empty directory for /proc mount\n├── Makefile                     ← Build configuration\n└── README.md                    ← Build and usage instructions</code></pre></div>\n\n<h4 id=\"header-file-organization\">Header File Organization</h4>\n<p>The header file structure follows a clear dependency hierarchy. The main <code>container.h</code> defines the core data structures (<code>container_config_t</code>, <code>container_instance_t</code>) and orchestrator functions. Individual manager headers define only their specific interfaces and can be included independently for unit testing.</p>\n<p>Each manager header includes comprehensive documentation comments describing the expected call sequences and error conditions. For example, <code>pid_namespace.h</code> documents that PID namespace creation must happen before any other namespace operations because it affects subsequent <code>clone()</code> calls.</p>\n<h4 id=\"source-file-responsibilities\">Source File Responsibilities</h4>\n<p>Each source file has a single, well-defined responsibility. The <code>container.c</code> file implements only the orchestration logic—sequencing manager operations and coordinating cleanup. Individual manager files implement only their specific kernel interactions without knowledge of other managers.</p>\n<p>The <code>utils/</code> directory contains all the infrastructure code that handles error-prone system calls. The <code>syscall_wrappers.c</code> file implements safe versions of <code>clone()</code>, <code>mount()</code>, <code>unshare()</code>, and other system calls with comprehensive error checking and logging. This centralization makes it easier to handle the subtle differences in error codes and failure modes across different Linux kernel versions.</p>\n<blockquote>\n<p><strong>Architecture Decision Record: File Organization Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Container implementation involves multiple complex kernel APIs that need to work together but should be testable in isolation</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single file with all container logic</li>\n<li>Separate files by namespace type with shared utilities</li>\n<li>Layered architecture with clear abstraction boundaries</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate files by namespace type with centralized utilities and clear interfaces</li>\n<li><strong>Rationale</strong>: Each namespace type has distinct kernel APIs and testing requirements, but they share common patterns for error handling and cleanup that benefit from centralization</li>\n<li><strong>Consequences</strong>: More files to manage but much better testability, easier debugging of specific namespace issues, and cleaner separation of concerns</li>\n</ul>\n</blockquote>\n<p>The following table compares the file organization approaches:</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Maintainability</th>\n<th>Testability</th>\n<th>Learning Curve</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single File</td>\n<td>Low - everything mixed together</td>\n<td>Very low - can&#39;t test parts</td>\n<td>Easy - everything in one place</td>\n<td>No</td>\n</tr>\n<tr>\n<td>By Namespace</td>\n<td>High - clear separation</td>\n<td>High - isolated testing</td>\n<td>Moderate - need to understand structure</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Layered</td>\n<td>Highest - strict abstractions</td>\n<td>Moderate - complex mocking</td>\n<td>Hard - many abstraction layers</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"build-and-test-organization\">Build and Test Organization</h4>\n<p>The <code>Makefile</code> supports building individual components for testing, which is crucial during development. For example, <code>make test-pid</code> builds and runs only the PID namespace tests, allowing rapid iteration on that specific component without waiting for the full test suite.</p>\n<p>The test directory mirrors the source structure, with unit tests for each manager and integration tests for the full container lifecycle. Each test file includes both positive tests (verifying correct behavior) and negative tests (verifying proper error handling for various failure scenarios).</p>\n<p>⚠️ <strong>Pitfall: Circular Dependencies</strong>\nA common mistake is creating circular dependencies between managers. For example, having the mount namespace manager call cgroup functions, which then call mount functions. Our architecture prevents this by having all coordination flow through the container orchestrator, with managers only calling utility functions and never calling each other directly.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Error Propagation</strong>\nAnother common issue is not properly propagating error information up through the component layers. Each manager must translate low-level system call errors into meaningful error messages that include context about what operation was being attempted. The utility functions help with this by providing detailed error logging, but each manager must add its own contextual information.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The container implementation requires careful coordination of several Linux kernel features, each with their own complexity and failure modes. This guidance provides concrete starting points and file organization to help you build a maintainable implementation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Build System</td>\n<td>Simple Makefile with basic targets</td>\n<td>Autotools or CMake with feature detection</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>errno checking with perror()</td>\n<td>Custom error types with detailed context</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>printf to stderr</td>\n<td>Structured logging with levels and timestamps</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Basic assert() macros</td>\n<td>Full unit test framework like Check or Unity</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td>Direct clone() syscalls</td>\n<td>Higher-level process spawning library</td>\n</tr>\n<tr>\n<td>Filesystem Operations</td>\n<td>Direct mount() syscalls</td>\n<td>libmount for mount table management</td>\n</tr>\n<tr>\n<td>Network Configuration</td>\n<td>Direct netlink socket operations</td>\n<td>libnl for network namespace management</td>\n</tr>\n</tbody></table>\n<h4 id=\"essential-data-structures\">Essential Data Structures</h4>\n<p>Here are the complete type definitions that all components will use:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// container.h - Core data structures and API</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stddef.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_NS_FLAGS</span><span style=\"color:#E1E4E8\"> (CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNET </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWIPC)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROUPS_V1_PATH</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROUPS_V2_PATH</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup/unified\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_CGROUP_PREFIX</span><span style=\"color:#9ECBFF\"> \"container-basic\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container configuration - all parameters needed to create a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">rootfs_path;</span><span style=\"color:#6A737D\">           // Path to root filesystem directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">hostname;</span><span style=\"color:#6A737D\">              // Hostname to set inside container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> memory_limit_bytes;</span><span style=\"color:#6A737D\">   // Memory limit in bytes (0 for no limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cpu_percent;</span><span style=\"color:#6A737D\">             // CPU percentage limit (0-100, 0 for no limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_processes;</span><span style=\"color:#6A737D\">           // Maximum number of processes (0 for no limit)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">bridge_name;</span><span style=\"color:#6A737D\">           // Host bridge name for networking (NULL for no networking)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">container_ip;</span><span style=\"color:#6A737D\">          // IP address to assign to container (NULL for auto)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span><span style=\"color:#6A737D\">                 // Command and arguments to run in container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">envp;</span><span style=\"color:#6A737D\">                 // Environment variables for container process</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Active container instance - tracks all resources that need cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child_pid;</span><span style=\"color:#6A737D\">             // PID of container init process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> namespace_fds</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">        // File descriptors for each namespace type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cgroup_path;</span><span style=\"color:#6A737D\">           // Full path to container's cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup;</span><span style=\"color:#6A737D\"> // Registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup function registration for error recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cleanup_list {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup_func)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main container API</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h4 id=\"utility-functions-implementation\">Utility Functions Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// utils/syscall_wrappers.c - Safe syscall wrappers with comprehensive error handling</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe wrapper for clone() syscall with proper error checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#B392F0\"> safe_clone</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fn)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">stack</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack, flags, arg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"clone() failed: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> (flags=0x</span><span style=\"color:#79B8FF\">%x</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno), flags);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Common clone failures and their meanings:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EINVAL: Invalid flags combination or stack pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EPERM: Insufficient privileges for namespace creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ENOSPC: Kernel ran out of PIDs or namespace resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EUSERS: Too many nested namespaces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Safe wrapper for mount() syscall with detailed error reporting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> safe_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(source, target, type, flags, data) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"mount('</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">', 0x</span><span style=\"color:#79B8FF\">%lx</span><span style=\"color:#9ECBFF\">) failed: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                source </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> source </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                target </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                type </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> type </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"NULL\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                flags, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Common mount failures:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ENOENT: Source or target path doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EPERM: Insufficient privileges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EBUSY: Target is busy (already mounted or in use)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // EINVAL: Invalid filesystem type or flags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize cleanup list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_list_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register cleanup function (called in reverse order during cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">entry) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry->cleanup_func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry->data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute all registered cleanup functions in reverse registration order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current->cleanup_func) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current-></span><span style=\"color:#B392F0\">cleanup_func</span><span style=\"color:#E1E4E8\">(current->data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(current);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"container-orchestrator-skeleton\">Container Orchestrator Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// container.c - Main orchestrator implementation skeleton</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"container.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"namespaces/pid_namespace.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"namespaces/mount_namespace.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"namespaces/network_namespace.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cgroups/cgroup_manager.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"utils/cleanup.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize container instance structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set all fields to safe defaults (child_pid = 0, namespace_fds = -1, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Initialize cleanup list for error recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Validate config parameters (rootfs_path exists, limits are reasonable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create PID namespace and fork container init process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call pid_namespace_create() to set up PID isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store child PID in container->child_pid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Register PID cleanup function for process termination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Handle clone() failures and provide meaningful error messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up cgroups for resource limits (parent process context)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call cgroup_create() with memory, CPU, and process limits from config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Assign child process to cgroup using container->child_pid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store cgroup path in container->cgroup_path for later cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Register cgroup cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for child process to signal setup completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use pipe or other IPC mechanism to synchronize with child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Child will set up mount and network namespaces, then signal ready</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Handle case where child fails during setup (read error status)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store namespace file descriptors for external access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Open /proc/[child_pid]/ns/* files to keep namespaces alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Store FDs in container->namespace_fds array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Register FD cleanup functions to close on container destruction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Success - container is running</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Check that container->child_pid is valid (> 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Return error if container is not in running state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for container process to exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use waitpid() to wait for container->child_pid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Handle EINTR (interrupted system call) by retrying</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Extract exit status and return to caller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update container state to reflect process exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set container->child_pid = 0 to indicate process is gone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Keep other resources (namespaces, cgroups) for potential inspection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Return exit status of container process</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Terminate container process if still running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Send SIGTERM to container->child_pid if > 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Wait briefly for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Send SIGKILL if process doesn't exit cleanly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute all registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Call execute_cleanup() to run cleanup chain in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - This handles cgroup removal, namespace FD closing, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Continue cleanup even if individual steps fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Reset container instance to safe state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Set all fields back to defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Free any dynamically allocated strings (cgroup_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Clear namespace_fds array</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Success - all resources cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"file-organization-implementation\">File Organization Implementation</h4>\n<p>Create the directory structure shown above, starting with these essential files:</p>\n<p><strong>Makefile:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">makefile</span><pre class=\"arch-pre shiki-highlighted\"><code>CC = gcc\nCFLAGS = -Wall -Wextra -std=c99 -D_GNU_SOURCE\nSRCDIR = src\nTESTDIR = tests\nOBJDIR = obj\n\n# Core source files\nSOURCES = $(SRCDIR)/container.c \\\n          $(SRCDIR)/namespaces/pid_namespace.c \\\n          $(SRCDIR)/namespaces/mount_namespace.c \\\n          $(SRCDIR)/namespaces/network_namespace.c \\\n          $(SRCDIR)/cgroups/cgroup_manager.c \\\n          $(SRCDIR)/utils/cleanup.c \\\n          $(SRCDIR)/utils/syscall_wrappers.c\n\nOBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)\nTARGET = container-basic\n\nall: $(TARGET)\n\n$(TARGET): $(OBJECTS) $(SRCDIR)/main.c\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Individual component tests\ntest-pid: $(TESTDIR)/test_pid_namespace.c $(SRCDIR)/namespaces/pid_namespace.c\n\t$(CC) $(CFLAGS) -o test_pid $^ &amp;&amp; ./test_pid\n\ntest-mount: $(TESTDIR)/test_mount_namespace.c $(SRCDIR)/namespaces/mount_namespace.c\n\t$(CC) $(CFLAGS) -o test_mount $^ &amp;&amp; ./test_mount\n\nclean:\n\trm -rf $(OBJDIR) $(TARGET) test_*\n\n.PHONY: all clean test-pid test-mount</code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing the basic architecture structure, verify these behaviors:</p>\n<ol>\n<li><p><strong>File Structure Checkpoint</strong>: All header files compile without errors when included individually. Run <code>gcc -c src/container.h</code> and similar commands for each header.</p>\n</li>\n<li><p><strong>Data Structure Checkpoint</strong>: Create a simple test program that initializes <code>container_config_t</code> and <code>container_instance_t</code> structures. Verify all fields are accessible and have expected types.</p>\n</li>\n<li><p><strong>Utility Functions Checkpoint</strong>: Test the syscall wrappers with simple operations like creating a directory and mounting tmpfs. Verify error messages are helpful and cleanup functions execute properly.</p>\n</li>\n<li><p><strong>Build System Checkpoint</strong>: The Makefile should build the project without warnings. Individual component tests should compile (but may not pass until components are implemented).</p>\n</li>\n</ol>\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Header Include Guards</strong>\nEach header file must have proper include guards to prevent multiple inclusion problems. Use the pattern:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> CONTAINER_COMPONENT_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_COMPONENT_H</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... header content ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Memory Management in Error Paths</strong>\nThe cleanup system only handles resources that were successfully registered. If allocation fails during container creation, you may leak partially created resources. Always check allocation results and register cleanup functions immediately after successful resource creation.</p>\n<p>⚠️ <strong>Pitfall: File Descriptor Leaks</strong>\nNamespace file descriptors and other FDs must be properly closed during cleanup. Initialize the <code>namespace_fds</code> array to -1 values and check for valid FDs before closing in cleanup functions.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Error Codes</strong>\nDifferent components should use consistent error code conventions. Consider defining an enum of container-specific error codes rather than returning raw errno values, which can be ambiguous.</p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides the foundational data structures for all milestones (1-4), establishing how container configuration, namespace handles, and resource limits are represented and managed throughout the container lifecycle.</p>\n</blockquote>\n<p>The data model forms the backbone of our container runtime, defining how we represent container configurations, track active namespaces, and manage resource limits. Think of the data model as the <strong>blueprint and inventory system</strong> for a construction project - just as a builder needs detailed blueprints specifying what to build and an inventory system tracking materials and tools, our container runtime needs structured data representing what isolation to create and tracking mechanisms for the resources we allocate.</p>\n<p>The data model addresses several critical challenges in container management. First, we need a comprehensive <strong>configuration structure</strong> that captures all the parameters required to create a container - from filesystem paths and resource limits to network configuration and process arguments. Second, we need <strong>runtime tracking structures</strong> that maintain handles to active namespaces, cgroup hierarchies, and cleanup responsibilities. Finally, we need <strong>error recovery mechanisms</strong> that ensure proper cleanup even when container creation partially fails.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"Container System Component Overview\"></p>\n<p>The key insight driving our data model design is the <strong>separation between intent and state</strong>. The configuration structures represent what we want to create (intent), while the instance structures track what we have actually created (state). This separation enables robust error handling - if namespace creation fails halfway through, we know exactly what resources need cleanup by examining the instance state, regardless of what the original configuration requested.</p>\n<h3 id=\"container-configuration\">Container Configuration</h3>\n<p>The <code>container_config_t</code> structure serves as the <strong>master specification</strong> for container creation, analogous to an architect&#39;s detailed building plans that specify every aspect of construction before work begins. This structure captures all user intentions about how the container should be configured, from filesystem isolation to resource limits to network connectivity.</p>\n<p>Think of container configuration as a <strong>restaurant order</strong> - it specifies exactly what the customer wants (filesystem location, memory limits, network setup) without containing any information about kitchen state (which pots are being used, which burners are occupied). The configuration is pure intent, completely separate from the runtime state needed to fulfill that intent.</p>\n<p>The configuration structure addresses the <strong>complexity of container parameterization</strong> by providing a single, comprehensive data structure that components can reference throughout the container lifecycle. Rather than passing dozens of individual parameters between functions, we pass a single configuration reference that contains everything needed for namespace creation, resource limit setup, and process execution.</p>\n<blockquote>\n<p><strong>Design Principle: Configuration Immutability</strong>\nOnce created, configuration structures should never be modified. This immutability enables safe sharing between threads and processes during container creation, and ensures that all components operate on consistent parameters even if creation takes significant time.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>rootfs_path</code></td>\n<td><code>char*</code></td>\n<td>Absolute path to container&#39;s root filesystem directory; used as new root after pivot_root operation</td>\n</tr>\n<tr>\n<td><code>hostname</code></td>\n<td><code>char*</code></td>\n<td>Container hostname visible inside UTS namespace; appears in /proc/sys/kernel/hostname within container</td>\n</tr>\n<tr>\n<td><code>memory_limit_bytes</code></td>\n<td><code>size_t</code></td>\n<td>Maximum memory consumption in bytes; enforced through memory cgroup controller</td>\n</tr>\n<tr>\n<td><code>cpu_percent</code></td>\n<td><code>int</code></td>\n<td>CPU usage limit as percentage (0-100); translated to cgroup cpu.cfs_quota_us and cpu.cfs_period_us</td>\n</tr>\n<tr>\n<td><code>max_processes</code></td>\n<td><code>int</code></td>\n<td>Maximum number of processes/threads; enforced through pids cgroup controller</td>\n</tr>\n<tr>\n<td><code>bridge_name</code></td>\n<td><code>char*</code></td>\n<td>Host bridge name for container networking; veth pair connects container to this bridge</td>\n</tr>\n<tr>\n<td><code>container_ip</code></td>\n<td><code>char*</code></td>\n<td>IP address assigned to container&#39;s network interface; must be within bridge subnet range</td>\n</tr>\n<tr>\n<td><code>argv</code></td>\n<td><code>char**</code></td>\n<td>Null-terminated array of command-line arguments for container&#39;s main process; argv[0] is executable path</td>\n</tr>\n<tr>\n<td><code>envp</code></td>\n<td><code>char**</code></td>\n<td>Null-terminated array of environment variables in &quot;KEY=value&quot; format; defines container process environment</td>\n</tr>\n</tbody></table>\n<p>The <strong>filesystem configuration</strong> through <code>rootfs_path</code> represents one of the most critical container parameters. This path must point to a complete filesystem hierarchy containing all binaries, libraries, and configuration files needed by the container process. The path serves as the target for the pivot_root operation that switches the container&#39;s view of the filesystem root.</p>\n<blockquote>\n<p><strong>Critical Requirement: Rootfs Completeness</strong>\nThe <code>rootfs_path</code> directory must contain a complete, bootable filesystem including essential directories (/bin, /lib, /etc, /proc, /sys) and all dependencies for the target executable. Missing libraries or incorrect permissions will cause container startup failures that are difficult to debug.</p>\n</blockquote>\n<p>The <strong>resource limit fields</strong> (<code>memory_limit_bytes</code>, <code>cpu_percent</code>, <code>max_processes</code>) translate directly into cgroup controller configurations. The memory limit becomes a hard boundary enforced by the kernel - processes exceeding this limit trigger OOM (Out of Memory) killer behavior. The CPU percentage translates into a quota system where the container receives the specified percentage of CPU time over each scheduling period.</p>\n<p>The <strong>networking configuration</strong> (<code>bridge_name</code>, <code>container_ip</code>) defines how the container connects to the host network. The bridge name must reference an existing host bridge interface, and the container IP must fall within the bridge&#39;s subnet range. These parameters drive the creation of veth pair interfaces that connect the container&#39;s network namespace to the host bridge.</p>\n<blockquote>\n<p><strong>Architecture Decision: Static vs Dynamic IP Assignment</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers need IP addresses for network communication, but we must choose between static assignment (user specifies IP) and dynamic assignment (runtime allocates from pool)</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Static IP specification in configuration</li>\n<li>Dynamic allocation from subnet pool</li>\n<li>DHCP-based assignment within namespace</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Static IP specification in configuration</li>\n<li><strong>Rationale</strong>: Simplifies implementation by avoiding IP allocation logic and subnet management. Users have full control over network topology. Reduces startup complexity and potential IP conflicts.</li>\n<li><strong>Consequences</strong>: Users must manage IP assignment manually. Risk of IP conflicts if multiple containers specify same address. No automatic network planning capabilities.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Configuration Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Static IP Assignment</td>\n<td>Simple implementation, predictable addresses, user control</td>\n<td>Manual IP management, potential conflicts</td>\n</tr>\n<tr>\n<td>Dynamic Pool Allocation</td>\n<td>Automatic conflict avoidance, easier multi-container setup</td>\n<td>Complex allocation logic, subnet management</td>\n</tr>\n<tr>\n<td>DHCP Integration</td>\n<td>Industry standard, flexible configuration</td>\n<td>Requires DHCP server, network complexity</td>\n</tr>\n</tbody></table>\n<p>The <strong>process execution parameters</strong> (<code>argv</code>, <code>envp</code>) define what actually runs inside the container once all namespaces are created. The argv array follows standard Unix conventions where argv[0] contains the executable path and subsequent elements contain command-line arguments. The envp array provides the process environment, allowing injection of configuration through environment variables.</p>\n<h3 id=\"namespace-handles\">Namespace Handles</h3>\n<p>The <code>container_instance_t</code> structure represents the <strong>runtime state</strong> of an active container, analogous to a construction site&#39;s status board that tracks which workers are active, which equipment is deployed, and what cleanup tasks remain. While configuration represents intent, the instance structure represents reality - the actual kernel objects, file descriptors, and process IDs that implement container isolation.</p>\n<p>Think of namespace handles as <strong>safety deposit box keys</strong> - each handle provides access to a specific kernel resource (namespace, cgroup, process) that must be carefully tracked and eventually returned. Losing a handle means losing the ability to properly clean up that resource, leading to kernel object leaks that accumulate over time.</p>\n<p>The instance structure addresses the <strong>complexity of partial failure recovery</strong> by maintaining explicit references to every kernel object created during container setup. If container creation fails after successfully creating PID and mount namespaces but before network setup completes, the instance structure contains exactly the information needed to clean up the successfully created resources.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>child_pid</code></td>\n<td><code>pid_t</code></td>\n<td>Process ID of container&#39;s main process; used for signaling and wait operations</td>\n</tr>\n<tr>\n<td><code>namespace_fds</code></td>\n<td><code>int[6]</code></td>\n<td>File descriptors for namespace handles; indexed by namespace type for cleanup access</td>\n</tr>\n<tr>\n<td><code>cgroup_path</code></td>\n<td><code>char*</code></td>\n<td>Absolute path to container&#39;s cgroup directory; used for resource limit cleanup</td>\n</tr>\n<tr>\n<td><code>cleanup</code></td>\n<td><code>cleanup_list_t*</code></td>\n<td>Linked list of cleanup functions; executed in reverse order during container destruction</td>\n</tr>\n</tbody></table>\n<p>The <strong>child process tracking</strong> through <code>child_pid</code> provides the primary handle for container lifecycle management. This PID allows the parent process to send signals to the container (for graceful shutdown), wait for container exit, and retrieve exit status information. The PID also serves as the primary identifier for associating kernel resources with the specific container instance.</p>\n<blockquote>\n<p><strong>Critical Timing Issue: PID Reuse</strong>\nProcess IDs can be reused by the kernel after process exit. Always verify that the PID still refers to the expected process before performing operations. Use additional validation like checking /proc/[PID]/comm or process start time to ensure PID validity.</p>\n</blockquote>\n<p>The <strong>namespace file descriptor array</strong> (<code>namespace_fds</code>) maintains handles to each namespace created for the container. The array indexes correspond to namespace types: PID (0), mount (1), network (2), UTS (3), IPC (4), and user (5). These file descriptors enable namespace operations like entering the namespace from other processes or querying namespace properties through /proc filesystem interfaces.</p>\n<table>\n<thead>\n<tr>\n<th>Namespace Index</th>\n<th>Type</th>\n<th>File Descriptor Source</th>\n<th>Cleanup Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>PID</td>\n<td><code>/proc/[PID]/ns/pid</code></td>\n<td>Close FD; namespace dies with process</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Mount</td>\n<td><code>/proc/[PID]/ns/mnt</code></td>\n<td>Close FD; unmount private mounts</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Network</td>\n<td><code>/proc/[PID]/ns/net</code></td>\n<td>Close FD; delete veth interfaces</td>\n</tr>\n<tr>\n<td>3</td>\n<td>UTS</td>\n<td><code>/proc/[PID]/ns/uts</code></td>\n<td>Close FD; no additional cleanup</td>\n</tr>\n<tr>\n<td>4</td>\n<td>IPC</td>\n<td><code>/proc/[PID]/ns/ipc</code></td>\n<td>Close FD; IPC objects cleaned by kernel</td>\n</tr>\n<tr>\n<td>5</td>\n<td>User</td>\n<td><code>/proc/[PID]/ns/user</code></td>\n<td>Close FD; no additional cleanup</td>\n</tr>\n</tbody></table>\n<p>The <strong>cgroup path tracking</strong> (<code>cgroup_path</code>) maintains the filesystem location of the container&#39;s cgroup hierarchy. This path serves multiple purposes: writing resource limits to controller files, adding processes to the cgroup, and removing the cgroup directory during cleanup. The path typically follows the pattern <code>/sys/fs/cgroup/[controller]/container-basic-[container-id]</code>.</p>\n<blockquote>\n<p><strong>Architecture Decision: Cleanup List vs Individual Cleanup Functions</strong></p>\n<ul>\n<li><strong>Context</strong>: Container creation involves many kernel objects that require cleanup in specific order. We need a mechanism to ensure proper cleanup even during partial failures.</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Individual cleanup functions called manually</li>\n<li>Cleanup list with automatic execution</li>\n<li>Resource Acquisition Is Initialization (RAII) pattern</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Cleanup list with automatic execution</li>\n<li><strong>Rationale</strong>: Provides guaranteed cleanup even during error conditions. Enables registration of cleanup functions as resources are created. Supports proper cleanup ordering through list reversal.</li>\n<li><strong>Consequences</strong>: Additional complexity in data structures. Memory overhead for cleanup list nodes. Clear separation between success and failure paths.</li>\n</ul>\n</blockquote>\n<p>The <strong>cleanup list mechanism</strong> (<code>cleanup</code>) implements a sophisticated error recovery system that ensures proper resource cleanup regardless of where container creation fails. Each successful resource allocation registers a cleanup function that knows how to properly release that specific resource. During container destruction or error recovery, the cleanup list executes in reverse order, ensuring that dependencies are respected during teardown.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Registration Order: Create PID namespace -&gt; Create mount namespace -&gt; Create network -&gt; Setup cgroups\nCleanup Order: Remove cgroups -&gt; Cleanup network -&gt; Cleanup mount -&gt; Cleanup PID (automatic)</code></pre></div>\n\n<table>\n<thead>\n<tr>\n<th>Cleanup Function Type</th>\n<th>Registration Trigger</th>\n<th>Cleanup Action</th>\n<th>Failure Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cleanup_cgroup_fn</code></td>\n<td>Cgroup directory creation</td>\n<td>Remove cgroup hierarchy</td>\n<td>Cgroup directory leak</td>\n</tr>\n<tr>\n<td><code>cleanup_network_fn</code></td>\n<td>Veth pair creation</td>\n<td>Delete veth interfaces</td>\n<td>Interface leak</td>\n</tr>\n<tr>\n<td><code>cleanup_mount_fn</code></td>\n<td>Mount namespace setup</td>\n<td>Unmount private mounts</td>\n<td>Mount table pollution</td>\n</tr>\n<tr>\n<td><code>cleanup_namespace_fd_fn</code></td>\n<td>Namespace FD opening</td>\n<td>Close namespace file descriptors</td>\n<td>File descriptor leak</td>\n</tr>\n</tbody></table>\n<p>The cleanup list structure enables <strong>composable error handling</strong> where each component registers its own cleanup requirements without needing knowledge of other components&#39; cleanup needs. This separation of concerns ensures that adding new isolation mechanisms (like additional namespaces or cgroup controllers) doesn&#39;t require modifying existing cleanup logic.</p>\n<h3 id=\"cleanup-list-management\">Cleanup List Management</h3>\n<p>The <code>cleanup_list_t</code> structure implements a <strong>reverse-order cleanup system</strong> that ensures proper resource deallocation during both successful container shutdown and error recovery. Think of the cleanup list as a <strong>stack of undo operations</strong> - each time we successfully create a resource, we push an &quot;undo&quot; operation onto the stack. When cleanup time comes, we pop and execute each undo operation in reverse order.</p>\n<p>This design pattern addresses the <strong>dependency ordering problem</strong> inherent in container resource management. Network interfaces must be cleaned up before network namespaces are destroyed. Cgroups must be emptied before directories can be removed. Mount points must be unmounted before mount namespaces exit. The cleanup list automatically handles these ordering requirements by executing cleanup functions in the reverse of their registration order.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cleanup_func</code></td>\n<td><code>void(*)(void*)</code></td>\n<td>Function pointer to cleanup implementation; receives <code>data</code> parameter for resource-specific cleanup</td>\n</tr>\n<tr>\n<td><code>data</code></td>\n<td><code>void*</code></td>\n<td>Opaque pointer to cleanup context; typically points to resource handles or configuration needed for cleanup</td>\n</tr>\n<tr>\n<td><code>next</code></td>\n<td><code>struct cleanup_list*</code></td>\n<td>Pointer to next cleanup node; forms singly-linked list for traversal during execution</td>\n</tr>\n</tbody></table>\n<p>The <strong>function pointer design</strong> (<code>cleanup_func</code>) enables type-safe cleanup while maintaining flexibility for different resource types. Each cleanup function receives a generic data pointer that it casts to the appropriate type for its specific resource. This design avoids the need for complex union types or switch statements in the cleanup execution logic.</p>\n<blockquote>\n<p><strong>Memory Management Principle: Cleanup Data Ownership</strong>\nThe cleanup list takes ownership of the <code>data</code> pointers passed during registration. Cleanup functions are responsible for freeing both their resource-specific data and any dynamically allocated structures referenced by that data. This ownership transfer ensures memory cleanup even during error conditions.</p>\n</blockquote>\n<p><strong>Common cleanup function patterns</strong> follow a consistent structure: validate the data pointer, cast to the appropriate type, perform the resource-specific cleanup operation, and free any associated memory. The function should be idempotent - calling it multiple times should be safe, as error conditions may cause partial cleanup list execution.</p>\n<p>The <strong>linked list traversal</strong> during cleanup execution walks the list from head to tail, executing each cleanup function and freeing the list node itself. This traversal pattern ensures that cleanup functions execute in reverse registration order while also cleaning up the list structure memory.</p>\n<p>⚠️ <strong>Pitfall: Cleanup Function Failures</strong>\nCleanup functions should never fail in ways that prevent subsequent cleanup operations. If a cleanup function encounters an error (like failing to delete a network interface), it should log the error but continue execution. Throwing exceptions or calling exit() from cleanup functions prevents other resources from being properly cleaned up, leading to resource leaks.</p>\n<p>⚠️ <strong>Pitfall: Circular Cleanup Dependencies</strong> \nAvoid registering cleanup functions that depend on resources cleaned up by functions registered later. For example, don&#39;t register a mount namespace cleanup that requires network access if network cleanup is registered after mount cleanup. The reverse-order execution means network cleanup runs first, potentially breaking mount cleanup.</p>\n<p>⚠️ <strong>Pitfall: Double-Cleanup Registration</strong>\nNever register cleanup functions for the same resource multiple times. This leads to double-free errors or resource cleanup conflicts. Use the instance structure&#39;s tracking fields to determine whether a resource has already been created and cleanup registered.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This data model implementation provides the foundation for all container runtime operations, from initial configuration parsing through namespace creation to final resource cleanup. The structures bridge the gap between user intent and kernel resource management, providing type safety and error recovery throughout the container lifecycle.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Configuration Parsing</td>\n<td><code>getopt()</code> + manual struct filling</td>\n<td><code>libconfig</code> or YAML parser with validation</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Manual <code>malloc()/free()</code> with cleanup lists</td>\n<td><code>talloc</code> hierarchical memory management</td>\n</tr>\n<tr>\n<td>String Handling</td>\n<td>Standard C string functions with length checking</td>\n<td><code>bstring</code> library for safe string operations</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td><code>errno</code> + <code>perror()</code> with custom error codes</td>\n<td>Structured error codes with detailed context</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n├── src/\n│   ├── container.h              ← Public API and main data structures\n│   ├── container.c              ← Main container lifecycle functions\n│   ├── config/\n│   │   ├── config.h            ← Configuration parsing and validation\n│   │   ├── config.c            ← Container configuration management\n│   │   └── config_test.c       ← Configuration parsing tests\n│   ├── cleanup/\n│   │   ├── cleanup.h           ← Cleanup list management\n│   │   ├── cleanup.c           ← Cleanup execution and registration\n│   │   └── cleanup_test.c      ← Cleanup mechanism tests\n│   └── utils/\n│       ├── utils.h             ← Common utilities and error handling\n│       └── utils.c             ← Helper functions and error reporting\n├── include/\n│   └── container_types.h       ← Type definitions and constants\n└── tests/\n    ├── test_data_model.c       ← Data structure validation tests\n    └── integration/\n        └── test_container_lifecycle.c  ← End-to-end container tests</code></pre></div>\n\n<h4 id=\"core-data-structure-definitions\">Core Data Structure Definitions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container configuration structure - immutable after creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> rootfs_path;</span><span style=\"color:#6A737D\">           // Path to container root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> hostname;</span><span style=\"color:#6A737D\">              // Container hostname for UTS namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> memory_limit_bytes;</span><span style=\"color:#6A737D\">   // Memory limit for memory cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cpu_percent;</span><span style=\"color:#6A737D\">             // CPU limit percentage (0-100)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_processes;</span><span style=\"color:#6A737D\">           // Process limit for pids cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> bridge_name;</span><span style=\"color:#6A737D\">           // Host bridge for container networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> container_ip;</span><span style=\"color:#6A737D\">          // IP address for container interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char**</span><span style=\"color:#E1E4E8\"> argv;</span><span style=\"color:#6A737D\">                 // Command arguments for container process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char**</span><span style=\"color:#E1E4E8\"> envp;</span><span style=\"color:#6A737D\">                 // Environment variables for container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup list node for resource management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cleanup_list {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup_func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Cleanup function pointer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> data;</span><span style=\"color:#6A737D\">                   // Data for cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">    // Next cleanup item</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container runtime instance - tracks active resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child_pid;</span><span style=\"color:#6A737D\">             // Container process PID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> namespace_fds</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">        // File descriptors for namespaces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> cgroup_path;</span><span style=\"color:#6A737D\">           // Path to container cgroup</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_list_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cleanup;</span><span style=\"color:#6A737D\">     // Cleanup function list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container creation and management functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup list management functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<h4 id=\"configuration-management-implementation\">Configuration Management Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// config/config.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> CONFIG_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONFIG_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"container_types.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configuration validation and creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> config_create_default</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> config_validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> config_parse_args</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char**</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> config_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configuration validation helpers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_rootfs_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_ip_address</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> ip</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> validate_bridge_exists</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> bridge</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<h4 id=\"cleanup-system-implementation\">Cleanup System Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cleanup/cleanup.c</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cleanup.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register cleanup function in reverse order for proper teardown</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Allocate new cleanup_list_t node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set cleanup_func to provided function pointer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set data to provided data pointer  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set next to current list head (*list)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update list head to point to new node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: This creates a stack (LIFO) for reverse-order execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute all cleanup functions in reverse registration order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Walk the linked list from head to tail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: For each node, call cleanup_func(data)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Free the current node before moving to next</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set list head to NULL after cleanup complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Handle NULL function pointers gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Continue cleanup even if individual functions fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup function for closing namespace file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_namespace_fds</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Cast data to int* (namespace_fds array)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Iterate through all 6 namespace types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Close any valid file descriptors (>= 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set closed descriptors to -1 to prevent double-close</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup function for removing cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_cgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Cast data to char* (cgroup_path)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove cgroup directory using rmdir()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Free the cgroup_path string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Log errors but don't fail - other cleanup must continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"instance-management-skeleton\">Instance Management Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// container.c - Core lifecycle management</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize container instance structure to safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_instance_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> instance</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set child_pid to -1 (invalid PID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize all namespace_fds entries to -1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set cgroup_path to NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set cleanup list to NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return 0 for success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create container with all namespaces and resource limits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize container instance to safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate configuration before starting creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create PID namespace with clone() or unshare()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register cleanup for PID namespace resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create mount namespace and setup filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register cleanup for mount namespace resources  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create network namespace and veth pair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register cleanup for network resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Setup cgroups and apply resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register cleanup for cgroup resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute container process in new namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Use cleanup list for error recovery if any step fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Store all resource handles in container instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Clean up all container resources using registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send SIGTERM to child process if still running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Wait brief period for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send SIGKILL if process still exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute complete cleanup list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Reset container instance to safe defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HINT: Always execute cleanup even if process operations fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Configuration Implementation:</strong></p>\n<ul>\n<li>Create a simple test program that parses command-line arguments into <code>container_config_t</code></li>\n<li>Verify that configuration validation catches invalid rootfs paths and IP addresses</li>\n<li>Test that configuration cleanup properly frees all allocated strings</li>\n<li>Expected output: Configuration parsing succeeds with valid inputs, fails gracefully with invalid inputs</li>\n</ul>\n<p><strong>After Cleanup System Implementation:</strong></p>\n<ul>\n<li>Write unit tests that register multiple cleanup functions and verify reverse-order execution</li>\n<li>Test cleanup execution with some functions that intentionally fail</li>\n<li>Verify that cleanup list properly frees all allocated nodes</li>\n<li>Expected behavior: Cleanup functions execute in reverse registration order, failures don&#39;t prevent subsequent cleanup</li>\n</ul>\n<p><strong>After Instance Management:</strong></p>\n<ul>\n<li>Create container instances and verify proper initialization</li>\n<li>Test partial container creation with cleanup verification</li>\n<li>Use <code>lsof</code> to verify no file descriptor leaks after container destruction</li>\n<li>Expected result: Clean creation and destruction with no resource leaks visible in <code>/proc</code> filesystem</li>\n</ul>\n<h4 id=\"debugging-data-structure-issues\">Debugging Data Structure Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Segfault during config access</td>\n<td>Uninitialized config pointer</td>\n<td>Check if config_create was called</td>\n<td>Always initialize structures before use</td>\n</tr>\n<tr>\n<td>Memory leak after container destroy</td>\n<td>Missing cleanup registration</td>\n<td>Use valgrind to identify leaked allocations</td>\n<td>Register cleanup for every resource allocation</td>\n</tr>\n<tr>\n<td>Container creation hangs</td>\n<td>Blocking operation without error handling</td>\n<td>Check for infinite waits in clone/mount</td>\n<td>Add timeouts and error checking to all syscalls</td>\n</tr>\n<tr>\n<td>Cleanup functions crash</td>\n<td>Invalid data pointers in cleanup list</td>\n<td>Verify data pointers before casting</td>\n<td>Validate data != NULL in cleanup functions</td>\n</tr>\n<tr>\n<td>Double-free errors</td>\n<td>Multiple cleanup registrations</td>\n<td>Check cleanup list for duplicate entries</td>\n<td>Track registration state in instance structure</td>\n</tr>\n</tbody></table>\n<h2 id=\"pid-namespace-component\">PID Namespace Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 1 (Process Namespace), which implements process isolation using PID namespaces and establishes the foundation for container process management.</p>\n</blockquote>\n<h3 id=\"mental-model-hotel-room-numbers\">Mental Model: Hotel Room Numbers</h3>\n<p>Think of PID namespaces like the room numbering systems in different buildings of a large hotel chain. Each hotel building has its own room numbering scheme - Building A has rooms 101, 102, 103, while Building B also has rooms 101, 102, 103. From inside Building A, you only see the room numbers for that building. Room 101 in Building A is completely different from Room 101 in Building B, even though they share the same number within their respective buildings.</p>\n<p>Similarly, PID namespaces create isolated process numbering systems. The host system (like the hotel management office) can see all processes across all namespaces with their &quot;real&quot; PIDs, but processes inside a PID namespace only see the processes within their own namespace, numbered starting from PID 1. When a container process thinks it&#39;s PID 1, the host might see it as PID 15432 - just like how the guest in room 101 of Building A doesn&#39;t know that the hotel management system tracks their room as &quot;A-101&quot;.</p>\n<p>The critical insight is that PID 1 in a namespace has special responsibilities, just like how the manager of Building A is responsible for that building&#39;s operations. PID 1 must handle &quot;orphaned&quot; processes (zombie reaping) within its namespace, similar to how a building manager must handle abandoned rooms and maintenance issues within their building.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The PID namespace component must handle the dual nature of process identity - maintaining the illusion of isolation within the namespace while coordinating with the host system for actual process management. This duality drives many of the implementation complexities around process creation, signal handling, and cleanup.</p>\n</blockquote>\n<h3 id=\"pid-namespace-interface\">PID Namespace Interface</h3>\n<p>The PID namespace interface provides functions for creating isolated process environments and managing the complex lifecycle of processes within those environments. The design centers around the <code>safe_clone</code> function and supporting infrastructure for handling the unique requirements of becoming PID 1 within a namespace.</p>\n<table>\n<thead>\n<tr>\n<th>Function Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_pid_namespace</code></td>\n<td><code>container_config_t* config, container_instance_t* container</code></td>\n<td><code>int</code></td>\n<td>Creates new PID namespace using clone() with CLONE_NEWPID flag</td>\n</tr>\n<tr>\n<td><code>safe_clone</code></td>\n<td><code>int (*fn)(void*), void* stack, int flags, void* arg</code></td>\n<td><code>pid_t</code></td>\n<td>Wrapper for clone() syscall with comprehensive error checking and stack validation</td>\n</tr>\n<tr>\n<td><code>container_init_process</code></td>\n<td><code>void* arg</code></td>\n<td><code>int</code></td>\n<td>Entry point function for container process, handles PID 1 initialization and exec</td>\n</tr>\n<tr>\n<td><code>setup_init_signals</code></td>\n<td><code>void</code></td>\n<td><code>int</code></td>\n<td>Configures signal handlers for zombie reaping and graceful shutdown</td>\n</tr>\n<tr>\n<td><code>reap_zombies</code></td>\n<td><code>void</code></td>\n<td><code>void</code></td>\n<td>Signal handler that reaps zombie child processes using waitpid()</td>\n</tr>\n<tr>\n<td><code>exec_container_command</code></td>\n<td><code>char** argv, char** envp</code></td>\n<td><code>int</code></td>\n<td>Replaces init process with user-specified command via execve()</td>\n</tr>\n</tbody></table>\n<p>The PID namespace creation process involves careful coordination between the parent (host) process and the child (container) process. The parent process calls <code>safe_clone</code> with the <code>CLONE_NEWPID</code> flag, which causes the child process to be created in a new PID namespace where it becomes PID 1. This transition is fundamental to container isolation but introduces significant complexity around process initialization and signal handling.</p>\n<p>The <code>safe_clone</code> function serves as a critical abstraction over the raw <code>clone()</code> system call, handling the numerous error conditions and edge cases that arise from namespace creation. It validates the stack pointer direction (growing up vs. down on different architectures), checks for sufficient privileges to create namespaces, and provides detailed error reporting for common failure modes like ENOSPC (no space in PID namespace) or EPERM (insufficient privileges).</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: The container init process must be prepared to handle all the responsibilities of PID 1, including zombie reaping and signal forwarding, before executing the user&#39;s intended command. Failing to properly initialize can lead to zombie process accumulation and signal delivery problems within the container.</p>\n</blockquote>\n<p>The <code>container_init_process</code> function represents the entry point for the container process after namespace creation. This function runs as PID 1 within the new namespace and must establish the proper runtime environment before transitioning to the user&#39;s intended command. It configures signal handlers, sets up minimal process state, and then uses <code>execve()</code> to replace itself with the actual container workload.</p>\n<table>\n<thead>\n<tr>\n<th>Process State</th>\n<th>PID (Host View)</th>\n<th>PID (Container View)</th>\n<th>Responsibilities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Host Process</td>\n<td>Variable</td>\n<td>N/A</td>\n<td>Creates namespaces, monitors container</td>\n</tr>\n<tr>\n<td>Container Init</td>\n<td>Variable (e.g. 15432)</td>\n<td>1</td>\n<td>Zombie reaping, signal handling, exec user command</td>\n</tr>\n<tr>\n<td>Container Children</td>\n<td>Variable</td>\n<td>2, 3, 4...</td>\n<td>User workloads, inherit namespace</td>\n</tr>\n</tbody></table>\n<p>The signal handling configuration is particularly critical because PID 1 in a namespace has special signal semantics. Unlike regular processes, PID 1 can only be killed by signals it has explicitly configured handlers for. This means the container init process must explicitly handle signals like SIGTERM and SIGINT to enable graceful shutdown, and must handle SIGCHLD to perform zombie reaping.</p>\n<h3 id=\"init-process-responsibilities\">Init Process Responsibilities</h3>\n<p>The init process within a PID namespace carries the fundamental responsibility of being the root of the process tree and the ultimate parent for all orphaned processes. When any process within the namespace exits, if its parent has already terminated, that process becomes a child of PID 1 (the init process). This creates an obligation for the init process to continuously reap zombie processes to prevent resource exhaustion.</p>\n<p>The zombie reaping mechanism operates through the SIGCHLD signal handler, which is delivered whenever a child process changes state (typically when it exits). The signal handler must call <code>waitpid()</code> in a loop with the WNOHANG flag to reap all available zombie processes without blocking. This is critical because multiple children might exit simultaneously, but only one SIGCHLD signal might be delivered due to signal coalescing.</p>\n<table>\n<thead>\n<tr>\n<th>Signal</th>\n<th>Purpose</th>\n<th>Handler Action</th>\n<th>Criticality</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIGCHLD</td>\n<td>Child process exit</td>\n<td>Call waitpid() in loop to reap zombies</td>\n<td>Critical - prevents resource leaks</td>\n</tr>\n<tr>\n<td>SIGTERM</td>\n<td>Graceful shutdown request</td>\n<td>Forward to child processes, then exit</td>\n<td>High - enables clean container stop</td>\n</tr>\n<tr>\n<td>SIGINT</td>\n<td>Interrupt (Ctrl+C)</td>\n<td>Forward to child processes, then exit</td>\n<td>High - enables interactive termination</td>\n</tr>\n<tr>\n<td>SIGUSR1</td>\n<td>Custom container signal</td>\n<td>Forward to main container process</td>\n<td>Medium - application-specific</td>\n</tr>\n<tr>\n<td>SIGKILL</td>\n<td>Force termination</td>\n<td>Cannot be caught - handled by kernel</td>\n<td>N/A - immediate termination</td>\n</tr>\n</tbody></table>\n<p>The signal forwarding mechanism ensures that signals sent to the container (via docker kill or similar commands) reach the actual application process rather than being handled solely by the init wrapper. This requires maintaining a reference to the main container process PID and forwarding appropriate signals while still handling init-specific signals locally.</p>\n<p>Here&#39;s the step-by-step process for handling init responsibilities:</p>\n<ol>\n<li><p><strong>Signal Handler Installation</strong>: The init process configures signal handlers for SIGCHLD, SIGTERM, and SIGINT before doing anything else. This ensures zombie reaping capability is established immediately.</p>\n</li>\n<li><p><strong>Initial Process Setup</strong>: The init process may spawn the main container application as a child process, or it may exec directly into the application after setting up signal forwarding.</p>\n</li>\n<li><p><strong>Zombie Reaping Loop</strong>: When SIGCHLD is received, the handler enters a loop calling <code>waitpid(-1, &amp;status, WNOHANG)</code> until no more zombie children are available. The WNOHANG flag prevents blocking if no zombies are present.</p>\n</li>\n<li><p><strong>Signal Forwarding</strong>: When SIGTERM or SIGINT is received, the init process forwards these signals to its child processes (if any) and then waits a reasonable timeout before exiting itself.</p>\n</li>\n<li><p><strong>Graceful Shutdown</strong>: The init process coordinates an orderly shutdown by signaling children, waiting for them to exit, reaping their zombie processes, and finally exiting itself.</p>\n</li>\n<li><p><strong>Emergency Cleanup</strong>: If children don&#39;t respond to graceful signals within the timeout period, the init process may send SIGKILL to force termination before exiting.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Critical Implementation Detail</strong>: The zombie reaping must handle the case where the main application process exits but has spawned daemon processes that become orphaned. These daemons become children of the container init process and must be properly reaped when they eventually exit.</p>\n</blockquote>\n<p>The exec transition from init process to application process is an important optimization for containers that run a single primary application. Instead of maintaining the init process as a separate parent, the init process can configure signal handlers and then exec directly into the application. However, this approach sacrifices the ability to reap orphaned processes that might be created by the application.</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Persistent Init</td>\n<td>Handles zombies, signal forwarding</td>\n<td>Extra memory overhead, complexity</td>\n<td>Multi-process applications</td>\n</tr>\n<tr>\n<td>Exec Replacement</td>\n<td>Minimal overhead, direct execution</td>\n<td>No zombie reaping, limited signal handling</td>\n<td>Single-process applications</td>\n</tr>\n<tr>\n<td>Hybrid (Setup then Exec)</td>\n<td>Good signal setup, minimal runtime overhead</td>\n<td>Limited zombie handling for orphans</td>\n<td>Simple applications with known behavior</td>\n</tr>\n</tbody></table>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<blockquote>\n<p><strong>Decision: Clone() vs Unshare() for PID Namespace Creation</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to create a new PID namespace for container process isolation. Linux provides two system calls: <code>clone()</code> which creates a new process in a new namespace, and <code>unshare()</code> which moves the current process into a new namespace.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Use <code>clone()</code> with CLONE_NEWPID to create child in new namespace</li>\n<li>Use <code>unshare()</code> to move current process into new namespace</li>\n<li>Hybrid approach using both calls</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>clone()</code> with CLONE_NEWPID for PID namespace creation</li>\n<li><strong>Rationale</strong>: PID namespaces have a special restriction - when a process calls <code>unshare(CLONE_NEWPID)</code>, the process itself remains in the original namespace, and only its children enter the new namespace. This creates confusion about which process is actually isolated. Using <code>clone()</code> ensures the child process is immediately in the new namespace as PID 1, providing clear semantics and avoiding the need for additional process spawning.</li>\n<li><strong>Consequences</strong>: We must handle the complexity of inter-process communication between parent and child, manage stack allocation for clone(), and handle the timing of namespace setup. However, we get predictable PID namespace semantics and avoid the confusion of mixed namespace membership.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>clone() with CLONE_NEWPID</td>\n<td>Child immediately becomes PID 1, clear namespace boundaries</td>\n<td>Complex stack management, IPC needed</td>\n</tr>\n<tr>\n<td>unshare() then fork</td>\n<td>Simpler control flow, no stack allocation</td>\n<td>Process calling unshare stays in old namespace</td>\n</tr>\n<tr>\n<td>Hybrid approach</td>\n<td>Flexibility in namespace transition</td>\n<td>Increased complexity, harder to debug</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Stack Direction Handling in safe_clone()</strong></p>\n<ul>\n<li><strong>Context</strong>: The <code>clone()</code> system call requires a stack pointer, but different CPU architectures have different stack growth directions (up vs down). ARM typically grows up, x86 grows down.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Assume downward growing stack (x86-style) and use (stack + STACK_SIZE)</li>\n<li>Use architecture-specific preprocessor directives to handle both directions</li>\n<li>Probe stack direction at runtime and adjust accordingly</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use architecture-specific preprocessor directives with fallback to downward growth</li>\n<li><strong>Rationale</strong>: Stack direction is determined at compile time based on the target architecture. Runtime probing adds unnecessary complexity and performance overhead. Preprocessor directives provide compile-time optimization while supporting both common stack directions.</li>\n<li><strong>Consequences</strong>: We need architecture-specific code paths, but this provides optimal performance and correctly handles the most common architectures. The fallback ensures compatibility with less common architectures.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Init Process Design Pattern</strong></p>\n<ul>\n<li><strong>Context</strong>: The container process becomes PID 1 in its namespace and must handle init responsibilities while also running the user&#39;s intended application.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Minimal init that immediately exec()s into user application</li>\n<li>Persistent init that spawns user application as child and manages it</li>\n<li>Configurable init that can operate in either mode based on container config</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement persistent init that spawns user application as child process</li>\n<li><strong>Rationale</strong>: While exec-style init has lower memory overhead, the persistent init approach provides essential container functionality including zombie reaping, signal forwarding, and graceful shutdown coordination. These capabilities are critical for production container usage and handling multi-process applications correctly.</li>\n<li><strong>Consequences</strong>: We use additional memory for the init process and increase complexity in signal handling and process management. However, we gain robust process tree management and compatibility with applications that spawn child processes.</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Incorrect Stack Pointer Calculation</strong></p>\n<p>Many developers incorrectly assume that all architectures use downward-growing stacks and pass the raw stack buffer pointer to <code>clone()</code>. On architectures with upward-growing stacks (like some ARM configurations), this causes the child process to start with an invalid stack pointer, leading to immediate segmentation faults.</p>\n<p>The mistake typically looks like:</p>\n<ul>\n<li>Allocating a stack buffer: <code>char stack[STACK_SIZE];</code></li>\n<li>Passing the base address directly: <code>clone(fn, stack, flags, arg)</code></li>\n<li>The child process crashes immediately with SIGSEGV</li>\n</ul>\n<p>The correct approach is to check the architecture and adjust the stack pointer accordingly. For downward-growing stacks, pass <code>stack + STACK_SIZE</code>. For upward-growing stacks, pass the base address <code>stack</code>. Use preprocessor directives like <code>#ifdef __hppa__</code> to detect architectures with upward-growing stacks.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Zombie Process Accumulation</strong></p>\n<p>A common mistake is implementing a container init process that doesn&#39;t properly handle SIGCHLD signals or doesn&#39;t loop when reaping zombies. This leads to zombie process accumulation, eventually exhausting the process table and preventing new process creation.</p>\n<p>The mistake occurs when developers either:</p>\n<ol>\n<li>Don&#39;t install a SIGCHLD handler at all</li>\n<li>Install a handler but only call <code>waitpid()</code> once instead of looping</li>\n<li>Use blocking <code>wait()</code> instead of non-blocking <code>waitpid()</code> with WNOHANG</li>\n</ol>\n<p>The consequence is that zombie processes accumulate until the system reaches its process limit, causing new process creation to fail with &quot;Resource temporarily unavailable&quot; errors. This is particularly problematic in long-running containers or containers that spawn many short-lived processes.</p>\n<p>The fix involves installing a proper SIGCHLD handler that loops until no more zombies are available:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Handler must loop because multiple children might exit simultaneously</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> ((pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, WNOHANG)) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process reaped successfully, continue looping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Signal Handling Race Conditions</strong></p>\n<p>PID 1 has special signal semantics in Linux - it can only be terminated by signals for which it has explicitly installed handlers. Many developers forget this and wonder why their containers don&#39;t respond to SIGTERM or SIGINT signals. Without proper signal handlers, the container init process becomes unkillable except via SIGKILL.</p>\n<p>The race condition occurs during the window between process creation and signal handler installation. If a signal arrives before handlers are installed, it may be ignored or cause unexpected behavior. This is particularly problematic during container shutdown when orchestration systems send SIGTERM expecting graceful termination.</p>\n<p>The solution is to install signal handlers as early as possible in the init process, before any other initialization:</p>\n<ol>\n<li>Install SIGCHLD handler for zombie reaping</li>\n<li>Install SIGTERM handler for graceful shutdown</li>\n<li>Install SIGINT handler for interactive termination</li>\n<li>Block signals during critical sections to prevent races</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Parent Process Waiting Strategy</strong></p>\n<p>A subtle error occurs when the parent process (host side) doesn&#39;t properly wait for the container child process, or waits incorrectly. This can lead to the container process becoming a zombie itself, or the parent process hanging indefinitely.</p>\n<p>Common mistakes include:</p>\n<ul>\n<li>Using <code>wait()</code> instead of <code>waitpid()</code> with specific PID</li>\n<li>Not handling EINTR when wait is interrupted by signals</li>\n<li>Forgetting to check the exit status to distinguish normal exit from signals</li>\n</ul>\n<p>The parent process must use <code>waitpid()</code> with the specific child PID and handle interruption correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">do</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(container->child_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR);</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Namespace Cleanup Timing</strong></p>\n<p>When a container exits, the PID namespace persists until all processes within it have exited and all file descriptors referring to the namespace are closed. Developers often forget that holding open namespace file descriptors (from /proc/PID/ns/) prevents namespace cleanup, leading to resource leaks.</p>\n<p>The mistake manifests as:</p>\n<ul>\n<li>Opening namespace file descriptors for monitoring or debugging</li>\n<li>Forgetting to close them when the container exits</li>\n<li>Namespace directories remaining in /proc after container termination</li>\n<li>Eventually exhausting namespace resources</li>\n</ul>\n<p>The fix requires careful tracking of all namespace file descriptors and ensuring they&#39;re closed during container cleanup. The cleanup process should close namespace descriptors before waiting for the container process to exit.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fnamespace-isolation.svg\" alt=\"Namespace Isolation Diagram\"></p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fcontainer-startup-flow.svg\" alt=\"Container Startup Sequence\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process Creation</td>\n<td><code>fork()</code> + <code>execve()</code> + manual namespace setup</td>\n<td><code>clone()</code> with namespace flags for atomic creation</td>\n</tr>\n<tr>\n<td>Signal Handling</td>\n<td>Basic <code>signal()</code> calls with simple handlers</td>\n<td><code>sigaction()</code> with advanced signal mask control</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td><code>perror()</code> + exit codes</td>\n<td>Structured error codes with detailed context</td>\n</tr>\n<tr>\n<td>Stack Management</td>\n<td>Fixed-size stack arrays</td>\n<td>Dynamic stack allocation with guard pages</td>\n</tr>\n<tr>\n<td>Namespace Monitoring</td>\n<td>Manual /proc filesystem inspection</td>\n<td>File descriptor-based namespace tracking</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n  src/\n    pid_namespace.c          ← PID namespace creation and management\n    pid_namespace.h          ← Function declarations and structures\n    container_init.c         ← Container init process implementation\n    signal_handling.c        ← Signal handler implementations\n    safe_clone.c            ← Clone wrapper with error handling\n    common.h                ← Shared constants and structures\n  tests/\n    test_pid_namespace.c    ← Unit tests for PID namespace functionality\n    test_container_init.c   ← Tests for init process behavior\n    test_zombie_reaping.c   ← Tests for zombie process handling\n  examples/\n    simple_container.c      ← Basic container demonstration</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>safe_clone.c</strong> - Complete clone() wrapper with error handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/syscall.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"common.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Architecture-specific stack pointer calculation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#B392F0\"> calculate_stack_pointer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack_base</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifdef</span><span style=\"color:#B392F0\"> __hppa__</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HPPA has upward-growing stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stack_base;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#else</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Most architectures have downward-growing stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)stack_base </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate stack alignment and bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> validate_stack</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack_base</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">stack_base) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for reasonable alignment (at least 8-byte aligned)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> ((</span><span style=\"color:#F97583\">uintptr_t</span><span style=\"color:#E1E4E8\">)stack_base </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#B392F0\"> safe_clone</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">fn)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">fn </span><span style=\"color:#F97583\">||</span><span style=\"color:#B392F0\"> validate_stack</span><span style=\"color:#E1E4E8\">(stack) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EINVAL;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_ptr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> calculate_stack_pointer</span><span style=\"color:#E1E4E8\">(stack);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack_ptr, flags, arg);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Provide detailed error information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> (errno) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> EPERM:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"clone failed: insufficient privileges for namespace creation</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> ENOSPC:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"clone failed: no space left in PID namespace</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> ENOMEM:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"clone failed: insufficient memory</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"clone failed: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Stack allocation helper with proper alignment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void*</span><span style=\"color:#B392F0\"> allocate_container_stack</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> aligned_alloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">stack) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to allocate container stack\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> stack;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> free_container_stack</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> stack</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(stack);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>signal_handling.c</strong> - Complete signal handler infrastructure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"common.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Global state for signal handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> volatile</span><span style=\"color:#79B8FF\"> sig_atomic_t</span><span style=\"color:#E1E4E8\"> shutdown_requested </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> pid_t</span><span style=\"color:#E1E4E8\"> main_child_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SIGCHLD handler - reaps zombie processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> sigchld_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sig</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> saved_errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errno;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Loop to reap all available zombie children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, WNOHANG)) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Log child exit if needed (avoid non-async-safe functions in real handlers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Child process reaped successfully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> saved_errno;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SIGTERM/SIGINT handler - initiates graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> sigterm_handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sig</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdown_requested </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Forward signal to main child process if it exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (main_child_pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(main_child_pid, sig);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_init_signals</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sigaction sa;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure SIGCHLD handler for zombie reaping</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigemptyset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa.sa_mask);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sa.sa_flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SA_RESTART </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SA_NOCLDSTOP;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sa.sa_handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sigchld_handler;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sigaction</span><span style=\"color:#E1E4E8\">(SIGCHLD, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to install SIGCHLD handler\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure SIGTERM handler for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sigemptyset</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa.sa_mask);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sa.sa_flags </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SA_RESTART;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sa.sa_handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sigterm_handler;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sigaction</span><span style=\"color:#E1E4E8\">(SIGTERM, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to install SIGTERM handler\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure SIGINT handler (same as SIGTERM)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sigaction</span><span style=\"color:#E1E4E8\">(SIGINT, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to install SIGINT handler\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> set_main_child_pid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    main_child_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> is_shutdown_requested</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> shutdown_requested;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Wait for graceful shutdown with timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> wait_for_graceful_shutdown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> timeout_seconds</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (elapsed </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> timeout_seconds </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> main_child_pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        elapsed</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if main child has exited</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">waitpid</span><span style=\"color:#E1E4E8\">(main_child_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, WNOHANG) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            main_child_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Graceful exit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>pid_namespace.c</strong> - Core PID namespace functionality to implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"common.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Creates a new PID namespace and container process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_pid_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate stack for container process using allocate_container_stack()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Register stack cleanup in case of failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use register_cleanup() to ensure stack is freed on failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call safe_clone() with CLONE_NEWPID flag and container_init_process as entry point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Flags should include CLONE_NEWPID | SIGCHLD for basic PID namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check clone() return value - negative means error, positive is child PID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store child PID in container->child_pid for later management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store namespace file descriptor in container->namespace_fds[0] if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Open /proc/&#x3C;child_pid>/ns/pid for namespace monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 on success, -1 on failure with errno set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container init process entry point (runs as PID 1 in new namespace)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_init_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify we're actually PID 1 in the namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: getpid() should return 1 if we're in the new PID namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Install signal handlers using setup_init_signals()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This must be done before any other operations to handle zombies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up minimal process environment (working directory, umask, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: chdir() to appropriate directory, umask(0022) for reasonable permissions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If config specifies running as persistent init, fork() the main application</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Store the child PID using set_main_child_pid() for signal forwarding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If persistent init mode, enter main loop watching for signals and reaping zombies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use is_shutdown_requested() to check for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If exec mode, directly exec into the user application</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use execve() with config->argv and config->envp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle cleanup and error cases - this should not return normally</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 255</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Should not reach here</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Wait for container process to exit and collect status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container parameter and child_pid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Use waitpid() to wait for specific child process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle EINTR interruption by retrying the wait</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store exit status and return code for caller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Distinguish between normal exit and signal termination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Mark container as exited (set child_pid to 0 or -1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li>Use <code>clone()</code> instead of <code>fork()</code> for namespace creation - it&#39;s the only way to create PID namespaces atomically</li>\n<li>Always check <code>errno</code> after failed system calls and use <code>strerror()</code> or <code>perror()</code> for debugging</li>\n<li>Use <code>sigaction()</code> instead of <code>signal()</code> for reliable signal handling behavior across platforms</li>\n<li>The <code>CLONE_NEWPID</code> flag creates the new PID namespace; combine with <code>SIGCHLD</code> for proper child handling</li>\n<li>Use <code>waitpid()</code> with <code>WNOHANG</code> in signal handlers to avoid blocking</li>\n<li>File descriptor <code>/proc/PID/ns/pid</code> can be used to hold references to namespaces for monitoring</li>\n<li>Use <code>prctl(PR_SET_PDEATHSIG, SIGKILL)</code> to ensure container dies if parent dies unexpectedly</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the PID namespace component, verify the following behavior:</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> test_pid_namespace</span><span style=\"color:#9ECBFF\"> test_pid_namespace.c</span><span style=\"color:#9ECBFF\"> pid_namespace.c</span><span style=\"color:#9ECBFF\"> safe_clone.c</span><span style=\"color:#9ECBFF\"> signal_handling.c</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_pid_namespace</span></span></code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Container PID from host perspective: 1234\nContainer PID from inside namespace: 1\nContainer successfully created and isolated\nContainer exited with status: 0</code></pre></div>\n\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li><p><strong>PID Isolation Check</strong>: Run <code>ps aux</code> in another terminal while the container is running. You should see the container process with a normal PID (e.g., 1234), but from inside the container, <code>echo $$</code> should return 1.</p>\n</li>\n<li><p><strong>Zombie Reaping Test</strong>: Create a test that spawns child processes inside the container and verifies they&#39;re properly reaped. No zombie processes should accumulate in <code>ps aux | grep defunct</code>.</p>\n</li>\n<li><p><strong>Signal Handling Test</strong>: Send <code>SIGTERM</code> to the container and verify it shuts down gracefully within a reasonable timeout.</p>\n</li>\n</ol>\n<p><strong>Signs Something is Wrong:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container process crashes immediately</td>\n<td>Stack pointer calculation error</td>\n<td>Check architecture-specific stack direction</td>\n</tr>\n<tr>\n<td><code>clone()</code> fails with EPERM</td>\n<td>Insufficient privileges</td>\n<td>Run with sudo or check namespace availability</td>\n</tr>\n<tr>\n<td>Zombie processes accumulate</td>\n<td>Missing or broken SIGCHLD handler</td>\n<td>Verify signal handler installation and waitpid loop</td>\n</tr>\n<tr>\n<td>Container doesn&#39;t respond to signals</td>\n<td>Missing signal handlers for PID 1</td>\n<td>Install handlers for SIGTERM, SIGINT early in init</td>\n</tr>\n<tr>\n<td>Container hangs on exit</td>\n<td>Parent not properly waiting</td>\n<td>Use waitpid() with correct PID, handle EINTR</td>\n</tr>\n</tbody></table>\n<h2 id=\"mount-namespace-component\">Mount Namespace Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 2 (Mount Namespace), which implements filesystem isolation to create a contained filesystem view separate from the host system.</p>\n</blockquote>\n<h3 id=\"mental-model-stage-sets\">Mental Model: Stage Sets</h3>\n<p>Think of mount namespaces like <strong>theater stage sets</strong>. In a theater production, each act might require a completely different scene - a living room for Act 1, a garden for Act 2, and a castle for Act 3. The audience sees only one set at a time, and when the curtain falls, the stage crew can completely transform the visible environment without affecting the real world outside the theater.</p>\n<p>A mount namespace works similarly for processes. Just as the theater audience sees only the current stage set and remains unaware of the other sets stored backstage, a process in a mount namespace sees only its own filesystem view and cannot access or even detect the filesystem mounts that exist on the host or in other namespaces. When we create a new mount namespace, we&#39;re essentially giving the container process its own &quot;stage&quot; where it can mount and unmount filesystems without affecting the host&#39;s filesystem layout.</p>\n<p>The <strong>pivot_root operation</strong> is like the moment when the stage crew wheels out the old set and wheels in the new one. The audience (our container process) suddenly sees a completely different environment as their reality. What was once the host&#39;s <code>/</code> root directory becomes hidden away (like storing the old stage set), and the container&#39;s new root directory takes center stage as the process&#39;s new <code>/</code>.</p>\n<p>This analogy helps explain why mount namespace isolation is so powerful: just as theater sets allow multiple completely different scenes to coexist in the same building without interfering with each other, mount namespaces allow multiple completely different filesystem views to coexist on the same machine without processes being able to escape their designated view.</p>\n<h3 id=\"mount-namespace-interface\">Mount Namespace Interface</h3>\n<p>The mount namespace component provides the core functions necessary to create filesystem isolation and establish a contained root filesystem for the container process. These functions handle the complex sequence of operations required to safely transition from the host filesystem view to an isolated container filesystem view.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fmount-namespace-transitions.svg\" alt=\"Mount Namespace and Pivot Root Process\"></p>\n<p>The primary interface functions coordinate multiple low-level mount operations to achieve filesystem isolation while maintaining the essential filesystems that the container process needs to function properly.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_mount_namespace</code></td>\n<td><code>config container_config_t*</code>, <code>container container_instance_t*</code></td>\n<td><code>int</code></td>\n<td>Creates new mount namespace and sets up isolated filesystem view</td>\n</tr>\n<tr>\n<td><code>setup_container_rootfs</code></td>\n<td><code>rootfs_path char*</code>, <code>old_root char*</code></td>\n<td><code>int</code></td>\n<td>Prepares container root filesystem directory structure</td>\n</tr>\n<tr>\n<td><code>pivot_to_container_root</code></td>\n<td><code>new_root char*</code>, <code>old_root char*</code></td>\n<td><code>int</code></td>\n<td>Switches filesystem root using pivot_root syscall</td>\n</tr>\n<tr>\n<td><code>mount_essential_filesystems</code></td>\n<td><code>void</code></td>\n<td><code>int</code></td>\n<td>Mounts /proc, /sys, and /dev inside container namespace</td>\n</tr>\n<tr>\n<td><code>setup_mount_propagation</code></td>\n<td><code>void</code></td>\n<td><code>int</code></td>\n<td>Configures mount propagation to prevent host leakage</td>\n</tr>\n<tr>\n<td><code>bind_mount_host_directories</code></td>\n<td><code>config container_config_t*</code></td>\n<td><code>int</code></td>\n<td>Creates bind mounts for shared host directories</td>\n</tr>\n</tbody></table>\n<p>The <code>create_mount_namespace</code> function serves as the main orchestrator for filesystem isolation. It begins by calling the <code>unshare</code> system call with the <code>CLONE_NEWNS</code> flag to create a new mount namespace, separating the container&#39;s filesystem view from the host. This operation creates a copy of the host&#39;s mount table that the container can then modify without affecting the host system.</p>\n<p>After creating the namespace, the function calls <code>setup_mount_propagation</code> to configure how mount events propagate between the new namespace and the host. This step is critical because the default mount propagation can cause container mounts to leak back to the host filesystem, breaking isolation. The function sets the propagation to <code>MS_PRIVATE</code> for the entire mount tree, ensuring that subsequent mount operations remain contained within the namespace.</p>\n<p>The <code>setup_container_rootfs</code> function prepares the directory structure needed for the pivot_root operation. This involves creating the new root directory if it doesn&#39;t exist and setting up a temporary directory that will hold the old root filesystem after the pivot. The function also ensures that the new root directory is on a different filesystem from the current root, as required by the pivot_root syscall.</p>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The mount namespace isolation must occur before any filesystem modifications because once we start changing mounts, we need to ensure those changes remain contained within the container&#39;s namespace and don&#39;t affect the host system.</p>\n</blockquote>\n<p>The <code>pivot_to_container_root</code> function performs the actual filesystem root transition using the pivot_root syscall. This operation atomically swaps the current root filesystem with the new container root, moving the old root to a subdirectory where it can be safely unmounted. This is more secure than using chroot because it completely removes access to the old root filesystem rather than simply changing the apparent root directory.</p>\n<h3 id=\"pivot-root-process\">Pivot Root Process</h3>\n<p>The pivot root process represents one of the most complex aspects of container filesystem isolation, requiring careful coordination of multiple mount operations to safely transition the container process from the host filesystem view to its own isolated root filesystem.</p>\n<p>The process begins with <strong>namespace preparation</strong>, where we ensure that the container has its own mount namespace and that mount propagation is configured to prevent operations from affecting the host. This preparation phase is critical because any mistakes here can cause container filesystem changes to leak back to the host system, breaking the isolation boundary.</p>\n<p><strong>Step-by-step pivot root algorithm:</strong></p>\n<ol>\n<li><p><strong>Validate filesystem requirements</strong>: Check that the new root directory exists and is accessible, and verify that it&#39;s mounted on a different filesystem from the current root (pivot_root requirement).</p>\n</li>\n<li><p><strong>Create old root directory</strong>: Inside the new root filesystem, create a temporary directory (typically <code>/old-root</code>) that will hold the current root filesystem after the pivot operation.</p>\n</li>\n<li><p><strong>Bind mount new root</strong>: Perform a bind mount of the new root directory onto itself to ensure it appears as a proper mount point, as required by pivot_root semantics.</p>\n</li>\n<li><p><strong>Execute pivot_root syscall</strong>: Call <code>pivot_root(new_root, old_root_path)</code> to atomically swap the filesystem roots, making the new root become <code>/</code> and moving the old root to <code>/old-root</code>.</p>\n</li>\n<li><p><strong>Change working directory</strong>: Update the current working directory to the new root filesystem to ensure subsequent operations occur in the container context.</p>\n</li>\n<li><p><strong>Mount essential filesystems</strong>: Mount <code>/proc</code>, <code>/sys</code>, and <code>/dev</code> filesystems inside the new root to provide essential kernel interfaces that the container process needs.</p>\n</li>\n<li><p><strong>Setup bind mounts</strong>: Create any required bind mounts to share specific host directories with the container (like shared volumes or socket directories).</p>\n</li>\n<li><p><strong>Unmount old root</strong>: Safely unmount the old root filesystem from <code>/old-root</code> and remove the temporary directory, completing the isolation.</p>\n</li>\n</ol>\n<p>The <strong>filesystem validation step</strong> requires checking several conditions that are often overlooked. The new root directory must exist and be accessible, but it also must be a mount point or be bind-mounted to itself. This requirement stems from the way pivot_root verifies that it&#39;s operating on actual filesystems rather than simple directories.</p>\n<p><strong>Mount point verification</strong> involves checking <code>/proc/mounts</code> to confirm that the new root appears as a separate mount entry. If the new root is just a directory on the existing filesystem, we must perform a bind mount operation: <code>mount --bind /path/to/new/root /path/to/new/root</code> to make it appear as a mount point.</p>\n<blockquote>\n<p><strong>Essential Insight</strong>: The pivot_root operation is atomic from the kernel&#39;s perspective, but the surrounding setup operations are not. This means we must carefully handle partial failures during the setup phase to avoid leaving the container in an inconsistent filesystem state.</p>\n</blockquote>\n<p>The <strong>old root management</strong> phase requires creating the old root directory inside the new root filesystem before calling pivot_root. This directory serves as the mount point where the current root filesystem will be relocated. The directory name should be unique and temporary since it will be unmounted and removed after the pivot completes.</p>\n<p><strong>Essential filesystem mounting</strong> happens after the pivot_root completes because these virtual filesystems need to appear in the container&#39;s filesystem namespace. The <code>/proc</code> filesystem provides process information and kernel interfaces, <code>/sys</code> exposes kernel and device information, and <code>/dev</code> provides device nodes. Each of these requires specific mount options and must be mounted in the correct order.</p>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<p>The mount namespace implementation requires several critical design decisions that affect both security and functionality. These decisions represent trade-offs between isolation strength, implementation complexity, and compatibility with existing systems.</p>\n<blockquote>\n<p><strong>Decision: pivot_root vs chroot for Root Filesystem Isolation</strong></p>\n<ul>\n<li><strong>Context</strong>: Container processes need to see a different root filesystem than the host, and we must choose between pivot_root and chroot for implementing this isolation</li>\n<li><strong>Options Considered</strong>: pivot_root syscall, chroot syscall, bind mounts with chroot</li>\n<li><strong>Decision</strong>: Use pivot_root for root filesystem switching</li>\n<li><strong>Rationale</strong>: pivot_root provides true filesystem isolation by completely removing access to the old root, while chroot only changes the apparent root and allows escape via relative paths like <code>../../../</code> or file descriptors opened before the chroot</li>\n<li><strong>Consequences</strong>: Requires more complex setup with mount namespace creation and old root management, but provides stronger security isolation</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Security Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pivot_root</td>\n<td>Complete isolation, no escape paths, proper filesystem semantics</td>\n<td>Complex setup, requires mount namespace, needs old root handling</td>\n<td>High</td>\n</tr>\n<tr>\n<td>chroot</td>\n<td>Simple implementation, widely understood, minimal setup</td>\n<td>Escape vulnerabilities, relative path issues, file descriptor leaks</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>bind + chroot</td>\n<td>Moderate complexity, some isolation improvements</td>\n<td>Still vulnerable to chroot escapes, inconsistent behavior</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Private Mount Propagation</strong></p>\n<ul>\n<li><strong>Context</strong>: Mount operations inside the container namespace can propagate back to the host filesystem depending on mount propagation settings</li>\n<li><strong>Options Considered</strong>: shared propagation, slave propagation, private propagation</li>\n<li><strong>Decision</strong>: Use private mount propagation (MS_PRIVATE) for container mount namespace</li>\n<li><strong>Rationale</strong>: Private propagation ensures that mount and unmount operations inside the container remain completely isolated and cannot affect the host filesystem, preventing accidental host filesystem modification</li>\n<li><strong>Consequences</strong>: Container mounts are fully isolated but cannot share filesystems mounted on the host after container creation</li>\n</ul>\n</blockquote>\n<p>The <strong>mount propagation decision</strong> significantly impacts how container filesystems interact with host filesystem changes. Private propagation creates the strongest isolation boundary but requires careful planning for any shared filesystem access needs.</p>\n<table>\n<thead>\n<tr>\n<th>Propagation Type</th>\n<th>Host→Container</th>\n<th>Container→Host</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Private (chosen)</td>\n<td>No</td>\n<td>No</td>\n<td>Full isolation</td>\n</tr>\n<tr>\n<td>Shared</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Shared filesystems</td>\n</tr>\n<tr>\n<td>Slave</td>\n<td>Yes</td>\n<td>No</td>\n<td>Read-only sharing</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Essential Filesystem Mount Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Container processes need access to kernel interfaces like /proc and /sys, but mounting them incorrectly can create security vulnerabilities</li>\n<li><strong>Options Considered</strong>: bind mount from host, fresh mount in namespace, selective bind mounting</li>\n<li><strong>Decision</strong>: Fresh mount of essential filesystems in container namespace</li>\n<li><strong>Rationale</strong>: Fresh mounting provides proper isolation and ensures container sees only its own processes and kernel state, while bind mounting would expose host process information</li>\n<li><strong>Consequences</strong>: Requires knowledge of correct mount options for each filesystem type, but provides better security isolation</li>\n</ul>\n</blockquote>\n<p><strong>Essential filesystem mounting</strong> requires understanding the specific purpose and security implications of each virtual filesystem. The <code>/proc</code> filesystem must be mounted fresh to show only container processes, while bind mounting would expose all host processes to the container.</p>\n<table>\n<thead>\n<tr>\n<th>Filesystem</th>\n<th>Mount Type</th>\n<th>Mount Options</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>/proc</td>\n<td>Fresh</td>\n<td><code>proc /proc proc defaults</code></td>\n<td>Container process view</td>\n</tr>\n<tr>\n<td>/sys</td>\n<td>Fresh</td>\n<td><code>sysfs /sys sysfs defaults</code></td>\n<td>Kernel interface access</td>\n</tr>\n<tr>\n<td>/dev</td>\n<td>Bind subset</td>\n<td>Selected devices only</td>\n<td>Essential device nodes</td>\n</tr>\n<tr>\n<td>/dev/pts</td>\n<td>Fresh</td>\n<td><code>devpts /dev/pts devpts defaults</code></td>\n<td>Pseudo-terminal support</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Mount namespace implementation contains several subtle pitfalls that can compromise container isolation or cause runtime failures. These issues often manifest as seemingly unrelated problems, making them particularly challenging for developers new to container implementation.</p>\n<p>⚠️ <strong>Pitfall: Mount Propagation Leakage</strong></p>\n<p>Many developers forget to configure mount propagation before performing container mount operations, causing container mounts to appear on the host filesystem. This happens because the default mount propagation setting is often <code>shared</code>, meaning mount operations propagate between namespaces.</p>\n<p><strong>Symptom</strong>: Container directories appear mounted on the host system after container startup, and host system shows container-specific mount points in <code>/proc/mounts</code>.</p>\n<p><strong>Why it&#39;s wrong</strong>: This breaks the fundamental isolation promise of containers. Host administrators can accidentally access container filesystems, and container mount operations can interfere with host system management.</p>\n<p><strong>Fix</strong>: Call <code>mount(NULL, &quot;/&quot;, NULL, MS_PRIVATE | MS_REC, NULL)</code> immediately after creating the mount namespace to set private propagation for the entire mount tree. The <code>MS_REC</code> flag applies the setting recursively to all existing mount points.</p>\n<p>⚠️ <strong>Pitfall: pivot_root Directory Requirements</strong></p>\n<p>The pivot_root syscall has strict requirements about the relationship between the old and new root directories that are not well documented. Failing to meet these requirements causes pivot_root to fail with unclear error messages.</p>\n<p><strong>Symptom</strong>: pivot_root syscall fails with <code>EINVAL</code> error, even though both directories exist and are accessible.</p>\n<p><strong>Why it&#39;s wrong</strong>: pivot_root requires that the new root directory be a mount point (not just a directory) and that the old root directory be located within the new root filesystem hierarchy.</p>\n<p><strong>Fix</strong>: Before calling pivot_root, ensure the new root is a mount point by bind mounting it to itself: <code>mount(new_root, new_root, NULL, MS_BIND, NULL)</code>. Create the old root directory inside the new root filesystem, not alongside it.</p>\n<p>⚠️ <strong>Pitfall: Device Node Accessibility</strong></p>\n<p>Containers often fail to access essential device nodes like <code>/dev/null</code>, <code>/dev/zero</code>, or <code>/dev/random</code> because these devices are not properly created or have incorrect permissions in the container namespace.</p>\n<p><strong>Symptom</strong>: Container processes fail with &quot;Permission denied&quot; or &quot;No such file or directory&quot; errors when trying to open standard device files, causing applications to crash unexpectedly.</p>\n<p><strong>Why it&#39;s wrong</strong>: Many applications and system libraries expect these device nodes to exist and be accessible. Without them, basic operations like discarding output (<code>&gt; /dev/null</code>) or generating random numbers fail.</p>\n<p><strong>Fix</strong>: Create essential device nodes in the container&#39;s <code>/dev</code> directory using <code>mknod</code> or bind mount selected devices from the host. Ensure proper permissions are set: <code>chmod 666 /dev/null /dev/zero /dev/random</code>.</p>\n<p>⚠️ <strong>Pitfall: Filesystem Type Detection</strong></p>\n<p>Different filesystem types require different mount options and may behave unexpectedly when used as container root filesystems. Developers often assume all filesystems behave identically during pivot_root operations.</p>\n<p><strong>Symptom</strong>: Container startup fails with mount errors or pivot_root failures that only occur on certain storage configurations or filesystem types.</p>\n<p><strong>Why it&#39;s wrong</strong>: Some filesystems (like NFS or FUSE) have restrictions on operations like pivot_root, and some require specific mount options to work correctly in container scenarios.</p>\n<p><strong>Fix</strong>: Detect the filesystem type using <code>statfs</code> or by parsing <code>/proc/mounts</code> before attempting pivot_root. Implement filesystem-specific handling for known problematic types, and provide clear error messages when unsupported filesystems are detected.</p>\n<p>⚠️ <strong>Pitfall: Cleanup Order Dependencies</strong></p>\n<p>Mount namespace cleanup must occur in the correct order to avoid leaving orphaned mounts or causing unmount failures. Incorrect cleanup order can leave host system resources tied up or cause subsequent container operations to fail.</p>\n<p><strong>Symptom</strong>: Container cleanup fails with &quot;Device or resource busy&quot; errors, and <code>lsof</code> or <code>fuser</code> shows processes holding references to container mount points.</p>\n<p><strong>Why it&#39;s wrong</strong>: Mount points have dependency relationships - unmounting a parent before its children fails, and some mount points cannot be unmounted while processes have open files on them.</p>\n<p><strong>Fix</strong>: Implement cleanup in reverse order of creation: unmount children before parents, terminate all container processes before unmounting filesystems, and use lazy unmounting (<code>umount2</code> with <code>MNT_DETACH</code>) as a last resort for stuck mounts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The mount namespace component requires careful coordination of multiple system calls and precise error handling to achieve reliable filesystem isolation. The implementation must handle the complex interactions between mount namespaces, pivot_root requirements, and essential filesystem mounting.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Filesystem Detection</td>\n<td>Parse <code>/proc/mounts</code> manually</td>\n<td>Use <code>libmount</code> library for robust parsing</td>\n</tr>\n<tr>\n<td>Device Node Creation</td>\n<td>Manual <code>mknod</code> calls with fixed device numbers</td>\n<td>Dynamic device discovery from <code>/proc/devices</code></td>\n</tr>\n<tr>\n<td>Mount Option Handling</td>\n<td>Hard-coded options for common filesystems</td>\n<td>Flexible configuration with validation</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Simple errno checking with <code>perror</code></td>\n<td>Structured error context with operation details</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n├── src/\n│   ├── container.c              ← main container orchestration\n│   ├── mount_namespace.c        ← mount namespace implementation\n│   ├── mount_namespace.h        ← mount namespace interface\n│   ├── filesystem_utils.c       ← helper functions for mount operations\n│   └── filesystem_utils.h       ← filesystem utility interface\n├── tests/\n│   ├── test_mount_namespace.c   ← unit tests for mount isolation\n│   └── test_filesystem_setup.c  ← integration tests for root setup\n└── examples/\n    └── minimal_container.c      ← demonstration of mount namespace usage</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>filesystem_utils.h:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> FILESYSTEM_UTILS_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> FILESYSTEM_UTILS_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Essential device nodes that containers typically need</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> device_node {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> path;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    mode_t</span><span style=\"color:#E1E4E8\"> mode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    dev_t</span><span style=\"color:#E1E4E8\"> device;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common filesystem types and their characteristics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> filesystem_info {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> supports_pivot_root;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> default_options;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Utility functions for mount operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> safe_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> ensure_directory_exists</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_device_node</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">dev_t</span><span style=\"color:#FFAB70\"> device</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> detect_filesystem_type</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char*</span><span style=\"color:#FFAB70\"> type_buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buf_size</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> is_mount_point</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> recursive_umount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mount propagation utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> set_mount_propagation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> propagation_type</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> make_private_recursive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // FILESYSTEM_UTILS_H</span></span></code></pre></div>\n\n<p><strong>filesystem_utils.c:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"filesystem_utils.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/statfs.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common device nodes needed in containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> device_node essential_devices</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\"/dev/null\"</span><span style=\"color:#E1E4E8\">, S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">makedev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\"/dev/zero\"</span><span style=\"color:#E1E4E8\">, S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">makedev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\"/dev/random\"</span><span style=\"color:#E1E4E8\">, S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">makedev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#9ECBFF\">\"/dev/urandom\"</span><span style=\"color:#E1E4E8\">, S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">makedev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">}</span><span style=\"color:#6A737D\"> // sentinel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> safe_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> target</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">               unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#FFAB70\"> flags</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(source, target, type, flags, data) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Mount failed: source=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> target=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                source </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> source </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"none\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                target </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"none\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                type </span><span style=\"color:#F97583\">?</span><span style=\"color:#E1E4E8\"> type </span><span style=\"color:#F97583\">:</span><span style=\"color:#9ECBFF\"> \"none\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> ensure_directory_exists</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">S_ISDIR</span><span style=\"color:#E1E4E8\">(st.st_mode)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Directory already exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errno </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ENOTDIR;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Path exists but is not a directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create directory and all parent directories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> path_copy </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strdup</span><span style=\"color:#E1E4E8\">(path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">path_copy) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> path_copy;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((p </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strchr</span><span style=\"color:#E1E4E8\">(p </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#E1E4E8\">(path_copy, mode) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> EEXIST) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free</span><span style=\"color:#E1E4E8\">(path_copy);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '/'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mkdir</span><span style=\"color:#E1E4E8\">(path_copy, mode);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    free</span><span style=\"color:#E1E4E8\">(path_copy);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EEXIST) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_device_node</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">mode_t</span><span style=\"color:#FFAB70\"> mode</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">dev_t</span><span style=\"color:#FFAB70\"> device</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove existing file if it exists</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    unlink</span><span style=\"color:#E1E4E8\">(path);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mknod</span><span style=\"color:#E1E4E8\">(path, mode, device) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to create device node </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">chmod</span><span style=\"color:#E1E4E8\">(path, mode </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">777</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to set permissions on </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> is_mount_point</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> mounts </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/mounts\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">mounts) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> mount_point</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fgets</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), mounts)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sscanf</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%*s</span><span style=\"color:#79B8FF\"> %511s</span><span style=\"color:#79B8FF\"> %*s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, mount_point) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(mount_point, path) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                found </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(mounts);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> found;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> set_mount_propagation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> propagation_type</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, path, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, propagation_type </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_REC, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> make_private_recursive</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> set_mount_propagation</span><span style=\"color:#E1E4E8\">(path, MS_PRIVATE);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>mount_namespace.h:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> MOUNT_NAMESPACE_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MOUNT_NAMESPACE_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"container.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mount namespace creation and management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_mount_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_container_rootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> rootfs_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> pivot_to_container_root</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> new_root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> mount_essential_filesystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_mount_propagation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> bind_mount_host_directories</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cleanup_mount_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span><span style=\"color:#6A737D\"> // MOUNT_NAMESPACE_H</span></span></code></pre></div>\n\n<p><strong>mount_namespace.c skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"mount_namespace.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"filesystem_utils.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_mount_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Call unshare(CLONE_NEWNS) to create new mount namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up private mount propagation to prevent leakage to host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Register cleanup function for mount namespace teardown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Store namespace file descriptor in container->namespace_fds[1]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return 0 on success, -1 on failure with errno set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_container_rootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> rootfs_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if rootfs_path exists and is accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Ensure rootfs_path is a mount point (bind mount if necessary)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create old_root directory inside the new root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify that new root and old root are on different filesystems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set appropriate permissions on directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use is_mount_point() and ensure_directory_exists() helper functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> pivot_to_container_root</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> new_root</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Change to the new root directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call pivot_root(new_root, old_root) to swap filesystems</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Change working directory to new root (\"/\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify that pivot operation completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle cleanup if pivot_root fails partway through</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check that old_root path exists inside new_root before pivot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> mount_essential_filesystems</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Mount /proc filesystem: mount(\"proc\", \"/proc\", \"proc\", 0, NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Mount /sys filesystem: mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create /dev directory and mount tmpfs on it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create essential device nodes in /dev using create_device_node()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Mount /dev/pts for pseudo-terminal support</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use safe_mount() wrapper for better error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_mount_propagation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Make entire mount tree private: mount(NULL, \"/\", NULL, MS_PRIVATE | MS_REC, NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify that propagation was set correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle case where MS_PRIVATE is not supported on this kernel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This must be done immediately after unshare(CLONE_NEWNS)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> bind_mount_host_directories</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse any host directory bind mount specifications from config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each bind mount, create target directory in container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Perform bind mount: mount(host_path, container_path, NULL, MS_BIND, NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set appropriate permissions on mounted directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Register cleanup functions for each bind mount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Validate that host paths exist before attempting bind mount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cleanup_mount_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Unmount all container filesystems in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove temporary directories created during setup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Close namespace file descriptor stored in container->namespace_fds[1]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Use lazy unmounting (MNT_DETACH) for stuck mounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return 0 if all cleanup succeeded, -1 if any failures occurred</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use recursive_umount() for complex mount hierarchies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>System Call Error Handling:</strong></p>\n<ul>\n<li>Always check return values from <code>mount()</code>, <code>umount()</code>, and <code>pivot_root()</code> syscalls</li>\n<li>Use <code>strerror(errno)</code> to get human-readable error descriptions</li>\n<li>Log both the operation being attempted and the errno value for debugging</li>\n</ul>\n<p><strong>Mount Flags and Options:</strong></p>\n<ul>\n<li>Use <code>MS_BIND</code> for bind mounts, <code>MS_PRIVATE</code> for mount propagation</li>\n<li>Combine flags with bitwise OR: <code>MS_PRIVATE | MS_REC</code></li>\n<li>Pass <code>NULL</code> for unused parameters rather than empty strings</li>\n</ul>\n<p><strong>Directory Path Handling:</strong></p>\n<ul>\n<li>Use <code>realpath()</code> to resolve symbolic links in filesystem paths</li>\n<li>Check for trailing slashes in directory paths and normalize them</li>\n<li>Validate that paths don&#39;t contain <code>..</code> components to prevent directory traversal</li>\n</ul>\n<p><strong>File Descriptor Management:</strong></p>\n<ul>\n<li>Open namespace file descriptors from <code>/proc/self/ns/mnt</code> for cleanup reference</li>\n<li>Use <code>O_CLOEXEC</code> flag when opening namespace descriptors</li>\n<li>Close all file descriptors before calling <code>pivot_root()</code> to avoid &quot;busy&quot; errors</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the mount namespace component, verify the following behaviors:</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile and run with a simple test rootfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-basic</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> /tmp/test-rootfs</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span></code></pre></div>\n\n<p><strong>Expected Behaviors:</strong></p>\n<ol>\n<li>Container process should see <code>/proc/self/mountinfo</code> different from host</li>\n<li>Files created in container <code>/tmp</code> should not appear in host <code>/tmp</code> </li>\n<li>Container should be able to mount/unmount without affecting host</li>\n<li>Essential device nodes (<code>/dev/null</code>, <code>/dev/zero</code>) should be accessible</li>\n<li>Container <code>/proc/mounts</code> should show only container-specific mount points</li>\n</ol>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>&quot;Operation not permitted&quot; → Check if running with sufficient privileges (CAP_SYS_ADMIN)</li>\n<li>&quot;Invalid argument&quot; from pivot_root → Verify new root is a mount point and old root directory exists</li>\n<li>&quot;Device or resource busy&quot; → Check that no processes have open files in mount directories</li>\n<li>Host shows container mounts → Mount propagation not set to private correctly</li>\n</ul>\n<p><strong>Debug Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check mount propagation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/self/mountinfo</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -E</span><span style=\"color:#9ECBFF\"> \"(shared|slave|private)\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify namespace isolation  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> lsns</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> mnt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check device nodes in container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#9ECBFF\"> /dev/zero</span><span style=\"color:#9ECBFF\"> /dev/random</span></span></code></pre></div>\n\n\n<h2 id=\"network-namespace-component\">Network Namespace Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 3 (Network Namespace), which implements network stack isolation and establishes container networking connectivity through veth pairs and bridge networking.</p>\n</blockquote>\n<p>The network namespace component provides the foundation for container network isolation by creating a completely separate network stack for each container. This component coordinates with the PID and mount namespace components to ensure containers have their own network interfaces, IP addresses, routing tables, and firewall rules while maintaining connectivity to the host system and external networks.</p>\n<p>Network isolation represents one of the most complex aspects of container implementation because it must balance complete isolation with practical connectivity requirements. Unlike PID or mount namespaces which primarily restrict visibility, network namespaces must actively establish communication channels between isolated environments. This creates intricate coordination challenges around interface creation, IP address management, and routing configuration that must be handled correctly to avoid network conflicts or connectivity failures.</p>\n<h3 id=\"mental-model-private-phone-systems\">Mental Model: Private Phone Systems</h3>\n<p>Think of network namespaces like separate office phone systems within a large corporate building. Each department (container) gets its own private phone system with internal extensions that are completely isolated from other departments. Employees within marketing can call each other using simple extension numbers (internal IP addresses), but they cannot directly dial into the engineering department&#39;s phone system.</p>\n<p>However, complete isolation would make the departments unable to collaborate or contact the outside world. So the building installs trunk lines (veth pairs) that connect each department&#39;s phone system to a central switchboard (host bridge). When marketing needs to call engineering, the call routes through the central switchboard which knows how to forward calls between departments. Similarly, all external calls to clients or vendors flow through the central switchboard to reach the appropriate department.</p>\n<p>The central switchboard (host networking stack) maintains a directory of which trunk line connects to which department and handles call routing between departments and to external networks. If marketing needs internet access, their calls flow through their trunk line to the switchboard, which then forwards them through the building&#39;s main phone line to the external provider. The switchboard can also enforce policies about which departments can call where and implement features like call forwarding or conferencing between multiple departments.</p>\n<p>This analogy maps directly to container networking: each container gets its own network namespace (private phone system), veth pairs act as trunk lines connecting container namespaces to the host bridge (central switchboard), and the host kernel handles routing between containers and to external networks. Just as phone systems need proper wiring and configuration to work correctly, container networking requires careful setup of virtual interfaces, IP addresses, and routing rules.</p>\n<h3 id=\"network-namespace-interface\">Network Namespace Interface</h3>\n<p>The network namespace interface provides functions for creating isolated network environments and establishing connectivity between containers and the host system. This interface abstracts the complexity of network namespace creation, veth pair management, and bridge configuration while ensuring proper cleanup and error handling.</p>\n<p>The core responsibility of this component is coordinating the creation of network namespaces with the setup of communication channels that connect isolated containers to each other and external networks. This requires careful orchestration of kernel network namespace operations with user-space network configuration tools to establish a complete networking solution.</p>\n<table>\n<thead>\n<tr>\n<th>Function Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_network_namespace</code></td>\n<td>config: <code>container_config_t*</code>, container: <code>container_instance_t*</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Creates new network namespace and stores namespace file descriptor for cleanup</td>\n</tr>\n<tr>\n<td><code>setup_container_networking</code></td>\n<td>config: <code>container_config_t*</code>, container_pid: <code>pid_t</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Configures veth pair and assigns container end to target namespace</td>\n</tr>\n<tr>\n<td><code>create_veth_pair</code></td>\n<td>host_if_name: <code>char*</code>, container_if_name: <code>char*</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Creates virtual ethernet pair with specified interface names</td>\n</tr>\n<tr>\n<td><code>assign_veth_to_namespace</code></td>\n<td>if_name: <code>char*</code>, target_pid: <code>pid_t</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Moves network interface to target process namespace</td>\n</tr>\n<tr>\n<td><code>configure_container_interface</code></td>\n<td>if_name: <code>char*</code>, ip_address: <code>char*</code>, netmask: <code>char*</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Sets IP address and brings interface up inside container namespace</td>\n</tr>\n<tr>\n<td><code>attach_to_bridge</code></td>\n<td>if_name: <code>char*</code>, bridge_name: <code>char*</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Adds host veth end to specified bridge for inter-container communication</td>\n</tr>\n<tr>\n<td><code>setup_default_route</code></td>\n<td>gateway_ip: <code>char*</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Configures default route inside container namespace for external connectivity</td>\n</tr>\n<tr>\n<td><code>cleanup_network_namespace</code></td>\n<td>container: <code>container_instance_t*</code></td>\n<td>int (0 success, -1 error)</td>\n<td>Removes veth interfaces and closes namespace file descriptors</td>\n</tr>\n<tr>\n<td><code>verify_bridge_exists</code></td>\n<td>bridge_name: <code>char*</code></td>\n<td>int (1 exists, 0 missing)</td>\n<td>Checks if specified bridge device exists on host system</td>\n</tr>\n<tr>\n<td><code>allocate_container_ip</code></td>\n<td>bridge_name: <code>char*</code>, requested_ip: <code>char*</code></td>\n<td>char* (allocated IP, NULL on error)</td>\n<td>Allocates available IP address from bridge subnet avoiding conflicts</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fnamespace-isolation.svg\" alt=\"Namespace Isolation Diagram\"></p>\n<p>The network namespace creation process begins when <code>create_network_namespace</code> is called during container startup. This function uses the <code>clone()</code> system call with the <code>CLONE_NEWNET</code> flag to create a new network namespace for the container process. The new namespace starts with only a loopback interface, completely isolated from the host network stack.</p>\n<p>However, complete network isolation renders containers unable to communicate with each other or external systems, so the interface includes functions for establishing controlled connectivity. The <code>setup_container_networking</code> function orchestrates the creation of a veth pair that acts as a network tunnel between the isolated container namespace and the host system. This function coordinates with <code>create_veth_pair</code> to establish the virtual ethernet devices and <code>assign_veth_to_namespace</code> to move the container end of the pair into the target namespace.</p>\n<p>Network configuration within the container namespace requires executing network configuration commands within the context of the isolated namespace. The <code>configure_container_interface</code> function handles IP address assignment and interface activation inside the container, while <code>setup_default_route</code> establishes routing rules for external connectivity. These functions must use namespace-aware network configuration approaches to ensure commands execute within the correct network context.</p>\n<p>The interface provides robust cleanup capabilities through <code>cleanup_network_namespace</code>, which removes created veth interfaces and closes namespace file descriptors to prevent resource leaks. This function coordinates with the cleanup list mechanism to ensure proper teardown even during error conditions or partial setup failures.</p>\n<h3 id=\"veth-pair-configuration\">Veth Pair Configuration</h3>\n<p>Veth pairs represent the fundamental mechanism for connecting isolated network namespaces to the host system and enabling container networking. A veth pair consists of two virtual ethernet interfaces that act as opposite ends of a virtual network cable - packets sent into one end emerge from the other end. This creates a bidirectional communication channel that can span namespace boundaries.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fnetwork-topology.svg\" alt=\"Container Network Topology\"></p>\n<p>The veth pair configuration process involves several coordinated steps that must execute in the correct order to establish proper connectivity. First, the veth pair is created in the host namespace with both interfaces initially residing on the host. The kernel assigns the interfaces names like <code>veth0</code> and <code>veth1</code>, though these can be customized during creation to follow naming conventions that identify their purpose and associated container.</p>\n<p>After creating the veth pair, one interface (typically the one intended for the container) must be moved into the target network namespace. This operation uses the <code>ip link set</code> command with network namespace targeting to transfer ownership of the interface from the host namespace to the container namespace. Once transferred, the interface becomes invisible to the host system and appears only within the container&#39;s isolated network view.</p>\n<p>Configuration of each veth interface requires namespace-specific commands that execute within the appropriate network context. The host-side veth interface typically gets added to a bridge device that connects multiple containers and provides routing to external networks. The container-side interface requires IP address assignment, netmask configuration, and interface activation to become usable for network communication.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Step</th>\n<th>Location</th>\n<th>Command Example</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Create veth pair</td>\n<td>Host namespace</td>\n<td><code>ip link add veth0 type veth peer name veth1</code></td>\n<td>Establishes virtual ethernet pair</td>\n</tr>\n<tr>\n<td>Move to container</td>\n<td>Host namespace</td>\n<td><code>ip link set veth1 netns &lt;container-pid&gt;</code></td>\n<td>Transfers interface to container namespace</td>\n</tr>\n<tr>\n<td>Configure container interface</td>\n<td>Container namespace</td>\n<td><code>ip addr add 172.17.0.2/24 dev veth1</code></td>\n<td>Assigns IP address to container interface</td>\n</tr>\n<tr>\n<td>Activate container interface</td>\n<td>Container namespace</td>\n<td><code>ip link set veth1 up</code></td>\n<td>Brings container interface online</td>\n</tr>\n<tr>\n<td>Add to host bridge</td>\n<td>Host namespace</td>\n<td><code>ip link set veth0 master br0</code></td>\n<td>Connects host interface to bridge</td>\n</tr>\n<tr>\n<td>Activate host interface</td>\n<td>Host namespace</td>\n<td><code>ip link set veth0 up</code></td>\n<td>Brings host interface online</td>\n</tr>\n</tbody></table>\n<p>The veth pair configuration must handle IP address allocation to prevent conflicts between containers and ensure proper subnet organization. Container IP addresses typically come from a private subnet associated with the host bridge, such as <code>172.17.0.0/16</code> for Docker-style networking. The configuration process must track allocated IP addresses and select available addresses for new containers while avoiding conflicts with existing containers or host system interfaces.</p>\n<p>Bridge networking represents the standard approach for connecting multiple container veth pairs and providing shared network access. The host system maintains a bridge device (similar to a network switch) that connects the host-side veth interfaces from all containers. This bridge can forward traffic between containers, route traffic to external networks through the host&#39;s physical interfaces, and implement network policies like NAT (Network Address Translation) for outbound connectivity.</p>\n<p>Veth pair cleanup requires careful coordination to avoid orphaned interfaces or namespace references. When a container terminates, both ends of its veth pair should be removed: the container-side interface disappears automatically when the namespace is destroyed, but the host-side interface must be explicitly deleted. Failure to clean up host-side veth interfaces leads to accumulation of unused network interfaces that consume system resources and clutter network configuration.</p>\n<p>The veth configuration process must also handle error conditions gracefully, particularly partial setup failures where some network configuration succeeds but other steps fail. The cleanup list mechanism ensures that successfully created interfaces get removed even if subsequent configuration steps encounter errors, preventing the system from accumulating partially configured network resources.</p>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<p>The network namespace component involves several critical architectural decisions that significantly impact performance, complexity, and functionality. These decisions affect how containers connect to networks, how IP addresses are managed, and how traffic flows between containers and external systems.</p>\n<blockquote>\n<p><strong>Decision: Veth Pairs vs MacVLAN for Container Networking</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers need network connectivity while maintaining isolation. Linux provides multiple approaches for connecting namespaces to host networking, including veth pairs with bridges and MacVLAN interfaces that share physical network adapters.</li>\n<li><strong>Options Considered</strong>: Veth pairs with bridge networking, MacVLAN interfaces, SR-IOV virtual functions</li>\n<li><strong>Decision</strong>: Use veth pairs connected through a host bridge for container networking</li>\n<li><strong>Rationale</strong>: Veth pairs provide complete traffic visibility on the host for monitoring and security policies, support arbitrary network topologies through bridge configuration, and work reliably across different host network configurations. MacVLAN requires specific network adapter features and limits traffic inspection capabilities.</li>\n<li><strong>Consequences</strong>: Enables flexible network policies and traffic monitoring but requires bridge configuration and slightly increases network latency due to additional packet processing through the bridge.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Veth + Bridge</td>\n<td>Full traffic visibility, flexible topologies, universal adapter support</td>\n<td>Additional latency, more complex setup</td>\n<td>✅ Yes</td>\n</tr>\n<tr>\n<td>MacVLAN</td>\n<td>Lower latency, simpler container setup</td>\n<td>Limited traffic visibility, adapter feature requirements</td>\n<td>❌ No</td>\n</tr>\n<tr>\n<td>SR-IOV</td>\n<td>Highest performance, hardware acceleration</td>\n<td>Expensive hardware requirements, complex management</td>\n<td>❌ No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Bridge Networking vs Host Networking vs Overlay Networks</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple containers need to communicate with each other and external networks. Different networking models provide different levels of isolation, performance, and configuration complexity.</li>\n<li><strong>Options Considered</strong>: Single host bridge for all containers, host networking without isolation, overlay networks with VXLAN tunneling</li>\n<li><strong>Decision</strong>: Implement single host bridge networking with configurable bridge names</li>\n<li><strong>Rationale</strong>: Host bridge networking provides good isolation between containers while enabling inter-container communication and external connectivity. It offers predictable performance characteristics and straightforward troubleshooting compared to overlay networks, while maintaining better security than host networking.</li>\n<li><strong>Consequences</strong>: Limits containers to single-host networking but provides reliable, performant connectivity suitable for basic container use cases. Advanced multi-host scenarios require additional networking solutions.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Host Bridge</td>\n<td>Good isolation, inter-container communication, simple troubleshooting</td>\n<td>Single-host limitation, manual IP management</td>\n<td>✅ Yes</td>\n</tr>\n<tr>\n<td>Host Networking</td>\n<td>Maximum performance, no configuration needed</td>\n<td>No network isolation, port conflicts</td>\n<td>❌ No</td>\n</tr>\n<tr>\n<td>Overlay Networks</td>\n<td>Multi-host support, advanced features</td>\n<td>Complex setup, performance overhead</td>\n<td>❌ No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Static IP Assignment vs DHCP vs Automatic Allocation</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers need IP addresses within the bridge subnet, but manual IP assignment is error-prone while DHCP adds complexity. The system needs a reliable approach for avoiding IP conflicts between containers.</li>\n<li><strong>Options Considered</strong>: Manual static IP specification, DHCP server for automatic assignment, simple automatic allocation from IP pool</li>\n<li><strong>Decision</strong>: Implement simple automatic IP allocation with optional static IP override</li>\n<li><strong>Rationale</strong>: Automatic allocation from a predefined IP pool eliminates configuration errors and IP conflicts while remaining simple to implement and debug. DHCP adds complexity and external dependencies, while purely manual assignment creates operational burden and conflict potential.</li>\n<li><strong>Consequences</strong>: Provides predictable IP allocation for most use cases while supporting static assignment when needed. Requires tracking allocated IP addresses but avoids complex DHCP infrastructure.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Static Assignment</td>\n<td>Predictable addresses, no coordination needed</td>\n<td>Manual configuration, conflict potential</td>\n<td>❌ No</td>\n</tr>\n<tr>\n<td>DHCP</td>\n<td>Industry standard, lease management</td>\n<td>Complex setup, external dependencies</td>\n<td>❌ No</td>\n</tr>\n<tr>\n<td>Automatic Allocation</td>\n<td>Simple implementation, conflict avoidance</td>\n<td>IP tracking required, limited flexibility</td>\n<td>✅ Yes</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: NAT vs Bridge Routing for External Connectivity</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers with private IP addresses need access to external networks and internet services. This requires either NAT (Network Address Translation) to hide container IPs behind host IP or direct routing if container IPs are routable.</li>\n<li><strong>Options Considered</strong>: NAT with iptables masquerading, direct routing with routable container subnets, proxy-based external access</li>\n<li><strong>Decision</strong>: Implement NAT-based external connectivity using iptables masquerading</li>\n<li><strong>Rationale</strong>: NAT provides external connectivity without requiring routable IP address allocation or complex routing configuration. It works reliably across different host network environments and provides additional security by hiding internal container addressing.</li>\n<li><strong>Consequences</strong>: Enables external connectivity with simple host configuration but prevents direct inbound connections to containers without port forwarding. Adds slight performance overhead for address translation.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NAT/Masquerading</td>\n<td>Works in any network, simple setup, security benefits</td>\n<td>No direct inbound access, translation overhead</td>\n<td>✅ Yes</td>\n</tr>\n<tr>\n<td>Direct Routing</td>\n<td>Better performance, bidirectional connectivity</td>\n<td>Requires routable IPs, complex routing</td>\n<td>❌ No</td>\n</tr>\n<tr>\n<td>Proxy Access</td>\n<td>Fine-grained control, protocol-specific features</td>\n<td>Application-specific, complex configuration</td>\n<td>❌ No</td>\n</tr>\n</tbody></table>\n<p>These architectural decisions establish a networking model that balances simplicity, functionality, and reliability for basic container networking requirements. The veth pair and bridge approach provides a solid foundation that can be extended with additional features like port forwarding, network policies, or multi-host connectivity as requirements evolve.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Network namespace implementation presents several subtle pitfalls that can cause connectivity failures, resource leaks, or security issues. These problems often manifest as intermittent failures or unexpected behavior that can be difficult to diagnose without understanding the underlying timing and coordination requirements.</p>\n<p>⚠️ <strong>Pitfall: Namespace Timing Issues During Interface Assignment</strong></p>\n<p>A common mistake is attempting to configure network interfaces before the target namespace is fully established or accessible. When moving a veth interface to a container namespace using <code>ip link set veth1 netns &lt;pid&gt;</code>, the operation can fail if the target process has not yet called <code>unshare(CLONE_NEWNET)</code> or if the process has already exited.</p>\n<p>This timing issue typically occurs when the parent process creates veth pairs and immediately tries to assign them to the child container process, but the child process hasn&#39;t yet established its network namespace or has encountered an error during startup. The assignment operation fails with &quot;No such file or directory&quot; or &quot;Invalid argument&quot; errors that don&#39;t clearly indicate the timing problem.</p>\n<p>To avoid this pitfall, implement proper synchronization between parent and child processes during container startup. Use signaling mechanisms like pipes or shared memory to ensure the child process has successfully created its network namespace before the parent attempts interface assignment. Additionally, implement retry logic with appropriate timeouts for interface assignment operations to handle minor timing variations.</p>\n<p>⚠️ <strong>Pitfall: Veth Interface Cleanup and Orphaned Interfaces</strong></p>\n<p>Failing to properly clean up veth interfaces leads to accumulation of orphaned network interfaces on the host system. When a container terminates unexpectedly or cleanup functions encounter errors, the host-side veth interface may remain active even though the container-side interface has disappeared with the destroyed namespace.</p>\n<p>These orphaned interfaces consume system resources, clutter network interface listings, and can cause naming conflicts when creating new containers. They may also remain attached to bridge devices, causing confusion during network troubleshooting and potentially affecting bridge behavior.</p>\n<p>Implement comprehensive cleanup tracking using the cleanup list mechanism to ensure veth interfaces are removed even during error conditions. Store interface names in the cleanup list immediately after creation, and implement cleanup functions that gracefully handle cases where interfaces may have already been removed. Use network interface enumeration to detect and clean up orphaned interfaces during system startup or periodic maintenance.</p>\n<p>⚠️ <strong>Pitfall: Bridge Configuration and Dependency Ordering</strong></p>\n<p>Attempting to attach veth interfaces to bridges that don&#39;t exist or haven&#39;t been properly configured causes network setup failures. Many implementations assume that bridge devices exist and are properly configured, but fail to verify bridge state or create necessary bridge configuration before attempting to use them.</p>\n<p>Bridge configuration issues also include problems with IP forwarding, NAT rules, and routing table entries that must be established on the host system for container networking to function correctly. Missing or incorrect iptables rules prevent external connectivity even when internal container networking appears to work correctly.</p>\n<p>Implement bridge existence verification and automatic bridge creation as part of the network setup process. Create comprehensive bridge configuration functions that handle IP forwarding enablement, NAT rule installation, and routing table management. Use dependency ordering to ensure bridge configuration completes before attempting to attach container interfaces.</p>\n<p>⚠️ <strong>Pitfall: IP Address Conflicts and Allocation Tracking</strong></p>\n<p>Simple IP address allocation without conflict detection leads to multiple containers receiving the same IP address, causing network connectivity problems that are difficult to diagnose. This typically occurs when IP allocation doesn&#39;t track previously assigned addresses or when containers terminate without properly releasing their IP allocations.</p>\n<p>IP conflicts manifest as intermittent connectivity issues, ARP (Address Resolution Protocol) conflicts, and unpredictable network behavior where traffic intended for one container reaches another container. These problems become more severe as the number of containers increases and IP address reuse becomes more common.</p>\n<p>Implement proper IP address allocation tracking using persistent storage or in-memory data structures that survive container lifecycle events. Include IP address validation during allocation to detect and avoid conflicts with existing network interfaces. Implement IP address release mechanisms that execute during container cleanup to ensure addresses become available for reuse.</p>\n<p>⚠️ <strong>Pitfall: NAT Configuration and iptables Rule Management</strong></p>\n<p>Incorrect NAT configuration prevents container external connectivity and can interfere with host system networking. Common mistakes include missing MASQUERADE rules, incorrect source/destination specifications in iptables rules, and failure to enable IP forwarding at the kernel level.</p>\n<p>NAT configuration problems often manifest as containers being able to communicate with each other but unable to reach external networks or receive responses to outbound connections. These issues can be particularly confusing because DNS resolution may work (if using internal DNS servers) while actual service connectivity fails.</p>\n<p>Implement systematic NAT configuration with proper rule validation and testing. Create iptables rule management functions that handle rule installation, removal, and conflict detection. Include IP forwarding enablement as part of the standard network setup process, and implement connectivity testing to verify external access after NAT configuration.</p>\n<p>⚠️ <strong>Pitfall: Network Namespace File Descriptor Management</strong></p>\n<p>Network namespaces must be properly referenced through file descriptors to ensure they persist even after the creating process exits. Failing to maintain namespace file descriptors can cause namespaces to be destroyed prematurely, leading to network connectivity loss and cleanup problems.</p>\n<p>Network namespace file descriptors require careful management during process lifecycle events, particularly when container processes fork, exec, or terminate. Improper file descriptor handling can lead to namespace reference leaks or premature namespace destruction that breaks container networking.</p>\n<p>Implement explicit network namespace file descriptor management with proper cleanup tracking. Store namespace file descriptors in the container instance structure and ensure they are properly closed during container termination. Use file descriptor validation to detect and handle cases where namespaces have been unexpectedly destroyed.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The network namespace implementation requires careful coordination of kernel networking features with user-space network configuration tools. This component builds upon the foundation established by the PID and mount namespace components while adding the complexity of network interface management and inter-process communication for network setup.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Configuration</td>\n<td>System calls to <code>ip</code> command via <code>system()</code></td>\n<td>Direct netlink socket programming for kernel communication</td>\n</tr>\n<tr>\n<td>Bridge Management</td>\n<td>Bridge utilities (<code>brctl</code> command)</td>\n<td>Native netlink interface manipulation</td>\n</tr>\n<tr>\n<td>IP Address Management</td>\n<td>Static allocation from predefined subnet</td>\n<td>Dynamic allocation with conflict detection and persistence</td>\n</tr>\n<tr>\n<td>NAT Configuration</td>\n<td>iptables command execution</td>\n<td>Direct netfilter programming</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/container/main.c         ← main container runtime entry point\n  src/network/                 ← network namespace component\n    network_namespace.c        ← core network namespace functions\n    veth_manager.c             ← veth pair creation and configuration\n    bridge_config.c            ← bridge setup and management\n    ip_allocator.c             ← IP address allocation and tracking\n    network_namespace.h        ← public interface definitions\n    network_internal.h         ← internal types and helper functions\n  src/common/                  ← shared infrastructure\n    cleanup.c                  ← cleanup list implementation\n    syscall_wrappers.c         ← safe system call wrappers\n  tests/network/               ← network-specific tests\n    test_network_isolation.c   ← namespace isolation verification\n    test_veth_setup.c          ← veth pair configuration tests\n    test_connectivity.c        ← end-to-end networking tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Network Configuration Helper (<code>src/network/network_utils.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"network_internal.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute network configuration command and return exit status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> exec_network_command</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> command</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> system</span><span style=\"color:#E1E4E8\">(command);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (status </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"system() failed\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute command within specific network namespace context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> exec_in_netns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> target_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> command</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> full_command</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(full_command, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(full_command), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"nsenter -t </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> -n </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, target_pid, command);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> exec_network_command</span><span style=\"color:#E1E4E8\">(full_command);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check if network interface exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> interface_exists</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> if_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"/sys/class/net/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, if_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> access</span><span style=\"color:#E1E4E8\">(path, F_OK) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Generate unique interface name for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> generate_veth_names</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> container_id</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        char*</span><span style=\"color:#FFAB70\"> host_if</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> host_len</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        char*</span><span style=\"color:#FFAB70\"> container_if</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> container_len</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(host_if, host_len, </span><span style=\"color:#9ECBFF\">\"veth</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_id);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(container_if, container_len, </span><span style=\"color:#9ECBFF\">\"eth0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Truncate if name too long for kernel limits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(host_if) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> IFNAMSIZ) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        host_if</span><span style=\"color:#E1E4E8\">[IFNAMSIZ</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate IP address format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> is_valid_ip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> ip_str</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_in sa;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> inet_pton</span><span style=\"color:#E1E4E8\">(AF_INET, ip_str, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">(sa.sin_addr)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Bridge Management Helper (<code>src/network/bridge_utils.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"network_internal.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Ensure bridge device exists and is properly configured</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> ensure_bridge_ready</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> bridge_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> bridge_ip</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> command</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if bridge already exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#B392F0\">interface_exists</span><span style=\"color:#E1E4E8\">(bridge_name)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create bridge device</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(command, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(command), </span><span style=\"color:#9ECBFF\">\"ip link add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type bridge\"</span><span style=\"color:#E1E4E8\">, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">exec_network_command</span><span style=\"color:#E1E4E8\">(command) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to create bridge </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Assign IP address to bridge</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(command, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(command), </span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, bridge_ip, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">exec_network_command</span><span style=\"color:#E1E4E8\">(command) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to assign IP to bridge </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bring bridge interface up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(command, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(command), </span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">exec_network_command</span><span style=\"color:#E1E4E8\">(command) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to bring up bridge </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Enable IP forwarding for container networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> enable_ip_forwarding</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> fp </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/sys/net/ipv4/ip_forward\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fp </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to open ip_forward\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fprintf</span><span style=\"color:#E1E4E8\">(fp, </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to enable IP forwarding\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fclose</span><span style=\"color:#E1E4E8\">(fp);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(fp);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Setup NAT rules for container external connectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_nat_rules</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> bridge_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> subnet</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> command</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add MASQUERADE rule for outbound traffic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(command, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(command),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"iptables -t nat -A POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> ! -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">             subnet, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">exec_network_command</span><span style=\"color:#E1E4E8\">(command) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to setup NAT masquerading</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allow forwarding for bridge traffic</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(command, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(command),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> ! -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT\"</span><span style=\"color:#E1E4E8\">, bridge_name, bridge_name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">exec_network_command</span><span style=\"color:#E1E4E8\">(command) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to setup bridge forwarding</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main Network Namespace Functions (<code>src/network/network_namespace.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"network_namespace.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"network_internal.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create new network namespace and setup basic networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_network_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify bridge exists and create if necessary using ensure_bridge_ready()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Enable IP forwarding and setup NAT rules for external connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store current network namespace fd in container->namespace_fds[NETNS_INDEX]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Network namespace creation happens during clone() - just setup cleanup here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Register cleanup function for network namespace file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Network namespace created automatically with CLONE_NEWNET flag in clone()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Setup container networking after process creation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_container_networking</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique veth pair names using container ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create veth pair in host namespace using create_veth_pair()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Move container-side veth to target namespace using assign_veth_to_namespace()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Configure host-side veth and attach to bridge using attach_to_bridge()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Configure container-side interface IP and routes using configure_container_interface()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Register cleanup functions for created veth interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use container->child_pid as target for namespace assignment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create virtual ethernet pair for container networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_veth_pair</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> host_if_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> container_if_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Construct ip command to create veth pair with specified names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute command using exec_network_command() and check return code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify both interfaces were created using interface_exists()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return 0 on success, -1 on failure with appropriate error logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Command format: \"ip link add &#x3C;host> type veth peer name &#x3C;container>\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assign network interface to target namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> assign_veth_to_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> if_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> target_pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Construct ip command to move interface to target namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute command and handle potential timing issues with retries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify interface no longer exists in host namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log success/failure with specific error information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Command format: \"ip link set &#x3C;interface> netns &#x3C;pid>\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configure IP address and routes inside container namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> configure_container_interface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> if_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> ip_address</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                 const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> netmask</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Assign IP address to interface using exec_in_netns()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Bring interface up inside container namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add default route through bridge gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify connectivity with ping test to gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use exec_in_netns() to run commands in container's network namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup network namespace resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cleanup_network_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Remove host-side veth interfaces if they still exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Close network namespace file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute registered cleanup functions in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clear namespace references from container structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Container namespace destruction happens automatically when process exits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>IP Address Allocation (<code>src/network/ip_allocator.c</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"network_internal.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Simple IP address allocator for container networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char*</span><span style=\"color:#B392F0\"> allocate_container_ip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> bridge_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> requested_ip</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If requested_ip provided and valid, check for conflicts and return if available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Otherwise, scan bridge subnet (e.g., 172.17.0.0/24) for available IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check each potential IP against existing interfaces using ping test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return allocated IP address string, or NULL if allocation failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store allocation in tracking structure for conflict prevention</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Start scanning from .2 (after gateway .1) and avoid broadcast addresses</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Release IP address back to available pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> release_container_ip</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> ip_address</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Remove IP from allocation tracking structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Perform any cleanup of IP-specific routes or rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return 0 on success, -1 if IP was not tracked</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implementation can be simple file-based or in-memory tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>System Call Integration:</strong></p>\n<ul>\n<li>Use <code>system()</code> for executing network configuration commands during development, but consider netlink sockets for production implementations</li>\n<li>Network namespace file descriptors can be opened from <code>/proc/&lt;pid&gt;/ns/net</code> for explicit namespace management</li>\n<li>The <code>nsenter</code> command provides reliable namespace context switching for configuration commands</li>\n</ul>\n<p><strong>Error Handling:</strong></p>\n<ul>\n<li>Network configuration commands can fail for many reasons (permissions, missing features, timing issues)</li>\n<li>Implement retry logic for operations that may encounter timing issues during namespace creation</li>\n<li>Use specific error messages that include the failed command and system error information</li>\n</ul>\n<p><strong>Debugging Support:</strong></p>\n<ul>\n<li>Log all executed network commands and their return codes for troubleshooting</li>\n<li>Include network interface enumeration in debug output to show current system state</li>\n<li>Implement connectivity testing functions that verify network setup success</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the network namespace component, verify the following behavior:</p>\n<p><strong>Compilation and Basic Testing:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> project-root</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> clean</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">make</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-basic</span><span style=\"color:#79B8FF\"> --network-test</span></span></code></pre></div>\n\n<p><strong>Expected Network Isolation:</strong></p>\n<ol>\n<li>Container process should have its own network namespace with only loopback interface initially</li>\n<li>After veth setup, container should have <code>eth0</code> interface with assigned IP address</li>\n<li>Container should be able to ping bridge gateway and reach external networks</li>\n<li>Host system should show veth interface connected to bridge with appropriate naming</li>\n</ol>\n<p><strong>Manual Verification Steps:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start container in background</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-basic</span><span style=\"color:#79B8FF\"> --config</span><span style=\"color:#9ECBFF\"> test.conf</span><span style=\"color:#79B8FF\"> --background</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> lsns</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> net</span><span style=\"color:#6A737D\">  # Should show separate network namespace for container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify veth pair creation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> veth</span><span style=\"color:#6A737D\">  # Should show host-side veth interface</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test container connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">container-pi</span><span style=\"color:#E1E4E8\">d</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> 8.8.8.8</span><span style=\"color:#6A737D\">  # Should succeed</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify bridge attachment</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">brctl</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#6A737D\">  # Should show veth interface attached to bridge</span></span></code></pre></div>\n\n<p><strong>Debugging Signs:</strong></p>\n<ul>\n<li><strong>Container cannot reach external networks</strong>: Check NAT rules and IP forwarding configuration</li>\n<li><strong>Veth interfaces not created</strong>: Verify network namespace creation and timing coordination</li>\n<li><strong>IP address conflicts</strong>: Check IP allocation logic and conflict detection</li>\n<li><strong>Bridge connectivity fails</strong>: Verify bridge configuration and interface attachment</li>\n</ul>\n<h2 id=\"cgroups-resource-management-component\">Cgroups Resource Management Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section corresponds to Milestone 4 (Cgroups Resource Limits), which implements resource control and enforcement using Linux cgroups to limit CPU, memory, and process counts within containers.</p>\n</blockquote>\n<h3 id=\"mental-model-budget-allocation\">Mental Model: Budget Allocation</h3>\n<p>Think of cgroups like a household budget system with automatic enforcement. In a family budget, you allocate specific amounts for different categories: $500 for groceries, $200 for entertainment, $300 for utilities. Each category has a hard limit - when the grocery budget is exhausted, no more grocery purchases are allowed until next month.</p>\n<p>Cgroups work similarly for system resources. You create a &quot;resource budget&quot; for your container: 512MB of memory, 50% of one CPU core, maximum 100 processes. The kernel automatically enforces these limits - when the container tries to allocate its 513th megabyte of memory, the kernel denies the allocation (and may terminate the process). When it tries to use more than 50% CPU over a time period, the kernel throttles the container&#39;s processes.</p>\n<p>The key insight is that cgroups provide <strong>automatic enforcement</strong> - you don&#39;t have to manually monitor resource usage. The kernel does the accounting and applies limits transparently. This is like having a bank that automatically declines transactions when you exceed your budget category limits, rather than requiring you to manually track every expense.</p>\n<p>Just as budget categories can be nested (entertainment budget might have sub-categories for movies vs games), cgroups form a hierarchy. You can create a parent cgroup for all containers with an overall memory limit, then create child cgroups for individual containers with smaller limits within that parent&#39;s allocation.</p>\n<h3 id=\"cgroups-interface\">Cgroups Interface</h3>\n<p>The cgroups interface provides functions for creating resource-limited execution contexts and enforcing those limits throughout the container lifecycle. Unlike namespaces which provide isolation, cgroups provide <strong>resource control</strong> - they determine how much of each system resource type the container can consume.</p>\n<p>The core challenge in cgroups management is handling both cgroups v1 and v2 systems, which have different filesystem layouts and control interfaces. Our design abstracts this complexity behind a unified interface that detects the available cgroup version and adapts accordingly.</p>\n<table>\n<thead>\n<tr>\n<th>Function Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_container_cgroup</code></td>\n<td><code>config container_config_t*</code>, <code>container container_instance_t*</code></td>\n<td><code>int</code></td>\n<td>Creates cgroup hierarchy for container and configures resource limits</td>\n</tr>\n<tr>\n<td><code>assign_process_to_cgroup</code></td>\n<td><code>cgroup_path char*</code>, <code>pid pid_t</code></td>\n<td><code>int</code></td>\n<td>Assigns process to cgroup by writing PID to tasks file</td>\n</tr>\n<tr>\n<td><code>set_memory_limit</code></td>\n<td><code>cgroup_path char*</code>, <code>limit_bytes size_t</code></td>\n<td><code>int</code></td>\n<td>Configures memory limit and OOM behavior for cgroup</td>\n</tr>\n<tr>\n<td><code>set_cpu_limit</code></td>\n<td><code>cgroup_path char*</code>, <code>cpu_percent int</code></td>\n<td><code>int</code></td>\n<td>Configures CPU quota and period to limit CPU usage percentage</td>\n</tr>\n<tr>\n<td><code>set_process_limit</code></td>\n<td><code>cgroup_path char*</code>, <code>max_processes int</code></td>\n<td><code>int</code></td>\n<td>Configures maximum number of processes/threads in cgroup</td>\n</tr>\n<tr>\n<td><code>cleanup_container_cgroup</code></td>\n<td><code>cgroup_path char*</code></td>\n<td><code>int</code></td>\n<td>Removes cgroup directory and cleans up kernel resources</td>\n</tr>\n<tr>\n<td><code>detect_cgroup_version</code></td>\n<td><code>void</code></td>\n<td><code>int</code></td>\n<td>Detects whether system uses cgroups v1 or v2 and returns version</td>\n</tr>\n<tr>\n<td><code>get_cgroup_path</code></td>\n<td><code>container_id char*</code>, <code>controller char*</code></td>\n<td><code>char*</code></td>\n<td>Constructs filesystem path for container&#39;s cgroup in specified controller</td>\n</tr>\n<tr>\n<td><code>verify_controller_available</code></td>\n<td><code>controller char*</code></td>\n<td><code>int</code></td>\n<td>Checks if specified cgroup controller is available and enabled</td>\n</tr>\n<tr>\n<td><code>read_cgroup_stat</code></td>\n<td><code>cgroup_path char*</code>, <code>stat_name char*</code></td>\n<td><code>long</code></td>\n<td>Reads current resource usage statistics from cgroup</td>\n</tr>\n</tbody></table>\n<p>The cgroup creation process follows a specific sequence to ensure proper resource limit enforcement. First, we detect which cgroup version is available on the system, as this determines both the filesystem layout and the control file formats. Then we create the cgroup directory hierarchy, configure resource limits in the appropriate control files, and finally assign the container process to the cgroup.</p>\n<blockquote>\n<p><strong>Design Principle</strong>: Cgroups must be created <strong>before</strong> the container process starts to ensure resource limits are enforced from the very beginning of execution. Creating cgroups after process startup creates a window where the process can consume unlimited resources.</p>\n</blockquote>\n<p>The cgroup cleanup process is equally critical. When a container exits, the cgroup must be properly destroyed to prevent resource leaks in the kernel&#39;s cgroup accounting system. However, cleanup can only occur after all processes in the cgroup have exited - attempting to remove a cgroup with active processes will fail.</p>\n<h3 id=\"resource-controllers\">Resource Controllers</h3>\n<p>Linux cgroups provide multiple <strong>controllers</strong> that each manage a different type of system resource. Our container implementation focuses on three essential controllers: memory, CPU, and process limits (pids). Each controller has its own control interface and enforcement mechanisms.</p>\n<h4 id=\"memory-controller\">Memory Controller</h4>\n<p>The memory controller tracks and limits memory usage for all processes within a cgroup. This includes anonymous memory (heap allocations), page cache, and kernel memory allocated on behalf of the cgroup&#39;s processes.</p>\n<table>\n<thead>\n<tr>\n<th>Control File</th>\n<th>Purpose</th>\n<th>Example Value</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>memory.limit_in_bytes</code> (v1) / <code>memory.max</code> (v2)</td>\n<td>Maximum memory allocation</td>\n<td><code>536870912</code> (512MB)</td>\n<td>Hard limit - allocations beyond this trigger OOM</td>\n</tr>\n<tr>\n<td><code>memory.usage_in_bytes</code> (v1) / <code>memory.current</code> (v2)</td>\n<td>Current memory usage</td>\n<td><code>134217728</code> (128MB)</td>\n<td>Read-only current usage counter</td>\n</tr>\n<tr>\n<td><code>memory.oom_control</code> (v1) / <code>memory.oom.group</code> (v2)</td>\n<td>OOM killer behavior</td>\n<td><code>oom_kill_disable 0</code></td>\n<td>Controls whether OOM killer terminates processes</td>\n</tr>\n<tr>\n<td><code>memory.swappiness</code></td>\n<td>Swap preference</td>\n<td><code>60</code></td>\n<td>How aggressively to use swap (0-100)</td>\n</tr>\n</tbody></table>\n<p>The memory controller enforcement works through the kernel&#39;s memory allocation paths. When a process in the cgroup requests memory (via <code>malloc()</code>, <code>mmap()</code>, or kernel allocations), the kernel checks the current cgroup usage against the limit. If the allocation would exceed the limit, the kernel either denies the allocation or invokes the OOM (Out of Memory) killer to terminate processes and free memory.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: Memory limits are enforced at allocation time, not usage time. A process that gradually increases its memory usage will trigger OOM when it crosses the limit, but a process that maps large virtual memory regions may fail earlier when trying to actually access those pages.</p>\n</blockquote>\n<p>Memory controller configuration involves several steps:</p>\n<ol>\n<li>Write the memory limit in bytes to the appropriate control file</li>\n<li>Configure OOM behavior - whether to kill processes or pause the cgroup</li>\n<li>Set memory swappiness to control swap usage preferences</li>\n<li>Monitor memory usage through the usage statistics file</li>\n</ol>\n<h4 id=\"cpu-controller\">CPU Controller</h4>\n<p>The CPU controller limits the amount of CPU time that processes in a cgroup can consume over time periods. Unlike memory limits which are hard caps, CPU limits are implemented through <strong>quota and period</strong> scheduling - the cgroup gets a quota of CPU time within each scheduling period.</p>\n<table>\n<thead>\n<tr>\n<th>Control File</th>\n<th>Purpose</th>\n<th>Example Value</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cpu.cfs_quota_us</code> (v1) / <code>cpu.max</code> (v2)</td>\n<td>CPU time quota per period</td>\n<td><code>50000</code> (50ms)</td>\n<td>Maximum CPU time in microseconds</td>\n</tr>\n<tr>\n<td><code>cpu.cfs_period_us</code> (v1) / <code>cpu.max</code> (v2)</td>\n<td>Scheduling period length</td>\n<td><code>100000</code> (100ms)</td>\n<td>Period length in microseconds</td>\n</tr>\n<tr>\n<td><code>cpu.stat</code></td>\n<td>CPU usage statistics</td>\n<td><code>nr_periods 1234</code></td>\n<td>Read-only usage and throttling stats</td>\n</tr>\n<tr>\n<td><code>cpu.shares</code> (v1) / <code>cpu.weight</code> (v2)</td>\n<td>Relative CPU priority</td>\n<td><code>1024</code></td>\n<td>Share of CPU when competing with other cgroups</td>\n</tr>\n</tbody></table>\n<p>The CPU quota system works by giving each cgroup a time budget that refreshes every period. For example, to limit a container to 50% of one CPU core, you set a quota of 50,000 microseconds (50ms) with a period of 100,000 microseconds (100ms). The container&#39;s processes can run for up to 50ms out of every 100ms period. When the quota is exhausted, the kernel suspends the cgroup&#39;s processes until the next period begins.</p>\n<p>CPU controller configuration requires calculating the appropriate quota and period values:</p>\n<ol>\n<li>Determine the desired CPU percentage (from <code>container_config_t.cpu_percent</code>)</li>\n<li>Choose a period length (typically 100ms for good responsiveness)</li>\n<li>Calculate quota as: <code>quota = (cpu_percent / 100) * period</code></li>\n<li>Write both values to the control files</li>\n<li>Monitor CPU throttling through statistics files</li>\n</ol>\n<h4 id=\"process-controller-pids\">Process Controller (PIDs)</h4>\n<p>The process controller limits the number of processes and threads that can be created within a cgroup. This prevents fork bombs and runaway process creation from consuming all available PIDs on the system.</p>\n<table>\n<thead>\n<tr>\n<th>Control File</th>\n<th>Purpose</th>\n<th>Example Value</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pids.max</code></td>\n<td>Maximum number of processes</td>\n<td><code>100</code></td>\n<td>Hard limit on process/thread count</td>\n</tr>\n<tr>\n<td><code>pids.current</code></td>\n<td>Current process count</td>\n<td><code>23</code></td>\n<td>Read-only current process counter</td>\n</tr>\n<tr>\n<td><code>pids.events</code></td>\n<td>Limit violation events</td>\n<td><code>max 5</code></td>\n<td>Counter of times limit was hit</td>\n</tr>\n</tbody></table>\n<p>The process controller enforcement occurs during process creation system calls (<code>fork()</code>, <code>clone()</code>, <code>vfork()</code>). When a process in the cgroup attempts to create a new process or thread, the kernel increments the cgroup&#39;s process counter and checks it against the limit. If the limit would be exceeded, the system call fails with <code>EAGAIN</code>.</p>\n<p>Process limit configuration is straightforward but requires careful consideration of the container&#39;s needs:</p>\n<ol>\n<li>Analyze the expected process tree structure (main process + children)</li>\n<li>Account for system processes like init handlers and signal processors  </li>\n<li>Add buffer for temporary processes created during normal operation</li>\n<li>Write the limit to <code>pids.max</code> control file</li>\n<li>Monitor process creation failures through the events file</li>\n</ol>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<p>The cgroups component requires several critical architectural decisions that significantly impact both implementation complexity and runtime behavior.</p>\n<blockquote>\n<p><strong>Decision: Cgroups Version Support Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Linux systems may have cgroups v1, v2, or both available. The two versions have different filesystem layouts, control interfaces, and feature sets. We need to support both to ensure compatibility across different Linux distributions and kernel versions.</li>\n<li><strong>Options Considered</strong>: 1) Support only cgroups v2 and require modern systems, 2) Support only cgroups v1 for maximum compatibility, 3) Support both versions with runtime detection</li>\n<li><strong>Decision</strong>: Support both cgroups v1 and v2 with runtime detection and abstraction</li>\n<li><strong>Rationale</strong>: Many production systems still use cgroups v1 (RHEL 7, older Ubuntu versions), while newer systems are migrating to v2. Runtime detection allows our container to work across the widest range of systems without requiring users to modify their kernel configuration.</li>\n<li><strong>Consequences</strong>: Increases implementation complexity with dual code paths, but provides maximum compatibility and future-proofs against the v1 to v2 transition.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cgroups v2 only</td>\n<td>Simpler code, modern interface, unified hierarchy</td>\n<td>Incompatible with older systems, limited adoption</td>\n</tr>\n<tr>\n<td>cgroups v1 only</td>\n<td>Maximum compatibility, well-tested interface</td>\n<td>Missing modern features, deprecated technology</td>\n</tr>\n<tr>\n<td>Both versions</td>\n<td>Works everywhere, smooth migration path</td>\n<td>Complex implementation, dual maintenance burden</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Controller Selection and Prioritization</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Linux cgroups provide many controllers (memory, cpu, cpuset, devices, freezer, net_cls, etc.). Each adds complexity but provides specific resource control capabilities. We need to choose which controllers are essential for basic container functionality.</li>\n<li><strong>Options Considered</strong>: 1) Implement all available controllers for complete resource control, 2) Implement only memory and CPU for basic limits, 3) Implement memory, CPU, and PIDs as core set with extensible architecture</li>\n<li><strong>Decision</strong>: Implement memory, CPU, and PIDs controllers as the core set with extensible architecture</li>\n<li><strong>Rationale</strong>: Memory and CPU are the most commonly needed limits for container resource management. PIDs controller prevents fork bombs which are a common security concern. This core set covers 90% of use cases while keeping complexity manageable. The extensible architecture allows adding more controllers later.</li>\n<li><strong>Consequences</strong>: Provides essential resource control without overwhelming complexity. Some advanced use cases (device access control, network traffic shaping) require additional controller implementation.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Controller</th>\n<th>Essential?</th>\n<th>Use Case</th>\n<th>Implementation Priority</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>memory</td>\n<td>Yes</td>\n<td>Prevent OOM on host, enforce resource allocation</td>\n<td>1</td>\n</tr>\n<tr>\n<td>cpu</td>\n<td>Yes</td>\n<td>Fair CPU sharing, prevent CPU monopolization</td>\n<td>2</td>\n</tr>\n<tr>\n<td>pids</td>\n<td>Yes</td>\n<td>Prevent fork bombs, limit process explosion</td>\n<td>3</td>\n</tr>\n<tr>\n<td>devices</td>\n<td>No</td>\n<td>Control device node access</td>\n<td>Future</td>\n</tr>\n<tr>\n<td>freezer</td>\n<td>No</td>\n<td>Pause/resume containers</td>\n<td>Future</td>\n</tr>\n<tr>\n<td>net_cls</td>\n<td>No</td>\n<td>Network traffic classification</td>\n<td>Future</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Cgroup Cleanup Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Cgroups must be cleaned up when containers exit to prevent resource leaks in the kernel. However, cleanup can fail if processes are still running in the cgroup, or if the cgroup hierarchy has dependencies. We need a robust cleanup strategy that handles various failure modes.</li>\n<li><strong>Options Considered</strong>: 1) Simple removal on container exit, 2) Retry-based cleanup with exponential backoff, 3) Hierarchical cleanup with process termination</li>\n<li><strong>Decision</strong>: Hierarchical cleanup with process termination and retry logic</li>\n<li><strong>Rationale</strong>: Simple removal fails when zombie processes remain in the cgroup. Hierarchical cleanup ensures we terminate any remaining processes before removing cgroups, preventing resource leaks. Retry logic handles race conditions between process termination and cgroup removal.</li>\n<li><strong>Consequences</strong>: More complex cleanup logic but prevents kernel resource leaks and handles edge cases robustly. May delay container exit in pathological cases where processes resist termination.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Cleanup Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simple removal</td>\n<td>Fast, minimal code</td>\n<td>Fails with zombie processes, leaks resources</td>\n</tr>\n<tr>\n<td>Retry-based</td>\n<td>Handles race conditions</td>\n<td>May retry indefinitely, unclear failure modes</td>\n</tr>\n<tr>\n<td>Hierarchical + retry</td>\n<td>Robust, prevents leaks</td>\n<td>Complex implementation, potential delays</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>The cgroups resource management system has several subtle pitfalls that can lead to resource leaks, enforcement failures, or system instability. Understanding these pitfalls is crucial for implementing reliable container resource controls.</p>\n<p>⚠️ <strong>Pitfall: Controller Availability Assumptions</strong></p>\n<p>A common mistake is assuming that all desired cgroup controllers are available and enabled on the target system. Different Linux distributions enable different controller sets by default, and administrators may disable controllers for performance or security reasons.</p>\n<p>The symptom appears when your container creation succeeds but resource limits are silently ignored. For example, you set a memory limit of 512MB, but the container can actually allocate 2GB without restriction. This occurs because the memory controller wasn&#39;t available, so the limit configuration failed silently.</p>\n<p><strong>Why it&#39;s wrong</strong>: Failing to verify controller availability means resource limits may not be enforced, creating a security vulnerability where containers can consume unlimited system resources.</p>\n<p><strong>How to fix it</strong>: Always call <code>verify_controller_available()</code> for each required controller before attempting to configure limits. If essential controllers are missing, fail container creation with a clear error message rather than proceeding with unprotected resource usage.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Cleanup Order</strong></p>\n<p>Another frequent mistake is attempting to remove cgroups before all processes in the cgroup have fully exited. The Linux kernel refuses to remove cgroups that contain active processes, but the error handling for this scenario is often inadequate.</p>\n<p>The symptom is that container cleanup appears to succeed, but <code>/sys/fs/cgroup</code> accumulates orphaned cgroup directories over time. Eventually, this can exhaust the kernel&#39;s cgroup limits and prevent new container creation.</p>\n<p><strong>Why it&#39;s wrong</strong>: Orphaned cgroups consume kernel memory and count against system cgroup limits. Over time, these leaks can prevent new container creation and require system reboot to resolve.</p>\n<p><strong>How to fix it</strong>: Implement hierarchical cleanup that first terminates all processes in the cgroup (using <code>SIGTERM</code> followed by <code>SIGKILL</code> if necessary), waits for process exit confirmation, then removes the cgroup directory. Use retry logic with exponential backoff to handle race conditions between process termination and cgroup removal.</p>\n<p>⚠️ <strong>Pitfall: Memory Limit and OOM Behavior Mismatch</strong></p>\n<p>A subtle issue occurs when setting memory limits without properly configuring OOM (Out of Memory) behavior. By default, the kernel&#39;s OOM killer selects victims based on heuristics that may kill processes outside the cgroup rather than within it.</p>\n<p>The symptom is that when a container exceeds its memory limit, random processes on the host system get terminated instead of processes within the offending container. This can cause system instability and difficult-to-debug application failures.</p>\n<p><strong>Why it&#39;s wrong</strong>: The purpose of memory limits is to contain the impact of memory pressure within the container. If OOM kills affect the host or other containers, the isolation is broken.</p>\n<p><strong>How to fix it</strong>: Configure <code>memory.oom.group</code> (cgroups v2) or <code>memory.use_hierarchy</code> (cgroups v1) to ensure OOM kills are contained within the cgroup. Set appropriate OOM score adjustments to prefer killing container processes over system processes.</p>\n<p>⚠️ <strong>Pitfall: CPU Quota and Period Misconfiguration</strong></p>\n<p>CPU limits are commonly misconfigured by using inappropriate quota and period values. Setting periods that are too short causes excessive scheduling overhead, while periods that are too long cause poor responsiveness.</p>\n<p>The symptom appears as either poor container performance (high scheduling overhead) or &quot;bursty&quot; CPU usage patterns where containers alternate between full CPU usage and complete suspension.</p>\n<p><strong>Why it&#39;s wrong</strong>: Incorrect CPU quota/period configuration can actually make CPU performance worse than having no limits at all, due to scheduling overhead and poor cache locality.</p>\n<p><strong>How to fix it</strong>: Use standard period values (100ms is typical) and calculate quotas as a percentage of that period. For multi-core limits, use quotas larger than the period (e.g., 150ms quota with 100ms period = 1.5 cores). Monitor <code>cpu.stat</code> to detect excessive throttling.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Process Assignment</strong></p>\n<p>A timing issue occurs when assigning processes to cgroups after those processes have already started and potentially created child processes. The child processes inherit the parent&#39;s cgroup membership at creation time, so they may end up in different cgroups than intended.</p>\n<p>The symptom is that resource limits appear to be working for the main container process, but child processes created early in container startup consume resources outside the limits.</p>\n<p><strong>Why it&#39;s wrong</strong>: Incomplete process assignment to cgroups allows resource usage to escape the intended limits, defeating the purpose of resource control.</p>\n<p><strong>How to fix it</strong>: Create cgroups and assign the container process to them <strong>before</strong> calling <code>exec()</code> to start the container&#39;s main process. Use the <code>register_cleanup()</code> mechanism to ensure proper cgroup cleanup even if process assignment fails.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The cgroups resource management component requires careful integration with the Linux cgroup filesystem and proper handling of both cgroups v1 and v2 variants. This implementation bridges the design concepts with practical code organization and error handling.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cgroup Detection</td>\n<td>File existence checks with <code>/sys/fs/cgroup/unified</code></td>\n<td>Parse <code>/proc/mounts</code> and <code>/proc/cgroups</code> for comprehensive controller detection</td>\n</tr>\n<tr>\n<td>Resource Limit Setting</td>\n<td>Direct file writes to control files</td>\n<td>Use libcgroup library for abstraction and validation</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td>Simple PID file writes</td>\n<td>Integrate with systemd-run for managed process trees</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Errno-based error checking</td>\n<td>Structured error types with retry policies</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n  src/\n    cgroups/\n      cgroups_common.c        ← shared utilities and detection\n      cgroups_v1.c           ← cgroups v1 specific implementation  \n      cgroups_v2.c           ← cgroups v2 specific implementation\n      cgroups.h              ← public interface header\n      cgroups_internal.h     ← internal structures and helpers\n    container.c              ← main container implementation\n    container.h              ← container public interface\n  tests/\n    test_cgroups.c          ← cgroup functionality tests\n    test_integration.c       ← end-to-end resource limit tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>This code provides complete, working utilities for cgroups management that handle the complexity of version detection and file system operations:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cgroups_common.c - Complete utility functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cgroups_internal.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete implementation of cgroup version detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> detect_cgroup_version</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for cgroups v2 unified hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(CGROUPS_V2_PATH, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> S_ISDIR</span><span style=\"color:#E1E4E8\">(st.st_mode)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify it's actually mounted as cgroup2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> mounts </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/mounts\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">mounts) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fgets</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), mounts)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strstr</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"cgroup2\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#B392F0\"> strstr</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"/sys/fs/cgroup\"</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fclose</span><span style=\"color:#E1E4E8\">(mounts);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // cgroups v2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fclose</span><span style=\"color:#E1E4E8\">(mounts);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check for cgroups v1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(CGROUPS_V1_PATH, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> S_ISDIR</span><span style=\"color:#E1E4E8\">(st.st_mode)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // cgroups v1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // No cgroups found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete implementation of cgroup path construction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char*</span><span style=\"color:#B392F0\"> get_cgroup_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> container_id</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> controller</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\"> cgroup_version </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cgroup_version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cgroup_version </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> detect_cgroup_version</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> path </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">path) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cgroup_version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROUPS_V2_PATH, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 CONTAINER_CGROUP_PREFIX, container_id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (cgroup_version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROUPS_V1_PATH, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 controller, CONTAINER_CGROUP_PREFIX, container_id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> path;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete implementation of controller availability checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> verify_controller_available</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> controller</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> version </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> detect_cgroup_version</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For v2, check controllers file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> controllers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/fs/cgroup/cgroup.controllers\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">controllers) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fgets</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), controllers)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            int</span><span style=\"color:#E1E4E8\"> available </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strstr</span><span style=\"color:#E1E4E8\">(line, controller) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fclose</span><span style=\"color:#E1E4E8\">(controllers);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> available;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fclose</span><span style=\"color:#E1E4E8\">(controllers);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // For v1, check if controller directory exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROUPS_V1_PATH, controller);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> stat</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#B392F0\"> S_ISDIR</span><span style=\"color:#E1E4E8\">(st.st_mode);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete implementation of safe file writing for cgroup control files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_cgroup_file</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> file </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">file) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fprintf</span><span style=\"color:#E1E4E8\">(file, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fclose</span><span style=\"color:#E1E4E8\">(file);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fclose</span><span style=\"color:#E1E4E8\">(file) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>The main cgroups interface functions that learners should implement, with detailed TODO comments mapping to the algorithm steps:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cgroups.c - Core implementation to be completed by learner</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cgroups.h\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cgroups_internal.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create cgroup hierarchy and configure resource limits for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_container_cgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Detect cgroup version using detect_cgroup_version()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate unique container ID if not provided in config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify required controllers are available (memory, cpu, pids)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Use verify_controller_available() for each controller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create cgroup directory hierarchy using mkdir() with appropriate permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Store cgroup path in container->cgroup_path for cleanup tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Register cleanup function using register_cleanup() for failure recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Configure memory limits by calling set_memory_limit()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Configure CPU limits by calling set_cpu_limit()  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Configure process limits by calling set_process_limit()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return 0 on success, -1 on failure with errno set</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Assign process to cgroup for resource limit enforcement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> assign_process_to_cgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Determine cgroup version to know which tasks file to use</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Construct path to tasks file (cgroup.procs for v2, tasks for v1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Convert PID to string for writing to control file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Write PID to appropriate tasks/procs file using write_cgroup_file()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify write succeeded by reading back the tasks file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return 0 on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: v2 uses \"cgroup.procs\", v1 uses \"tasks\" </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configure memory limit and OOM behavior for cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> set_memory_limit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> limit_bytes</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Detect cgroup version to determine control file names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Convert limit_bytes to string representation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Write limit to memory.max (v2) or memory.limit_in_bytes (v1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Configure OOM behavior - set memory.oom.group (v2) or memory.use_hierarchy (v1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Optionally set memory.swappiness to control swap usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify limits were applied by reading back control files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use write_cgroup_file() helper for atomic file writes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configure CPU quota and period to limit CPU usage percentage  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> set_cpu_limit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> cpu_percent</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate cpu_percent is reasonable (1-800 for multi-core)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate quota and period values (typically 100ms period)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         quota = (cpu_percent / 100.0) * period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Detect cgroup version for control file format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For v2: write \"quota period\" to cpu.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         For v1: write quota to cpu.cfs_quota_us, period to cpu.cfs_period_us</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify CPU limits by reading back control files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return 0 on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Standard period is 100000 microseconds (100ms)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configure maximum number of processes in cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> set_process_limit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> max_processes</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate max_processes is positive and reasonable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Convert max_processes to string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Write to pids.max control file (same name in v1 and v2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify limit was set by reading back pids.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return 0 on success, -1 on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: PIDs controller has same interface in v1 and v2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Clean up cgroup hierarchy and kernel resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cleanup_container_cgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Terminate any remaining processes in cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Read pids from cgroup.procs/tasks file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send SIGTERM to all processes, wait briefly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send SIGKILL to any remaining processes  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for all processes to exit (poll cgroup.procs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove cgroup directory using rmdir()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle EBUSY errors with retry logic (up to 3 attempts)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 on success, -1 if cleanup failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use kill(-pid, signal) to signal process groups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>File I/O for Cgroup Control Files:</strong></p>\n<ul>\n<li>Use <code>fopen()</code> with &quot;w&quot; mode for writing control files</li>\n<li>Always check <code>fclose()</code> return value - it can fail and lose data</li>\n<li>Some control files require newlines, others don&#39;t - check kernel documentation</li>\n</ul>\n<p><strong>Process Management:</strong></p>\n<ul>\n<li>Use <code>kill()</code> with negative PID to signal entire process groups</li>\n<li><code>SIGTERM</code> allows graceful shutdown, <code>SIGKILL</code> forces immediate termination</li>\n<li>Check <code>/proc/[pid]/status</code> to verify process termination</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Cgroup operations can fail with <code>ENOENT</code> (path doesn&#39;t exist), <code>EPERM</code> (insufficient privileges), or <code>EINVAL</code> (invalid values)</li>\n<li>Always check <code>errno</code> after failed operations for specific error diagnosis</li>\n<li>Use <code>perror()</code> or <code>strerror(errno)</code> for human-readable error messages</li>\n</ul>\n<p><strong>Memory Management:</strong></p>\n<ul>\n<li>Use <code>malloc()</code> for dynamic path construction, always check for NULL return</li>\n<li>Free allocated paths with <code>free()</code> to prevent memory leaks</li>\n<li>Consider using <code>alloca()</code> for small, temporary string buffers</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the cgroups component, verify correct behavior with these concrete tests:</p>\n<p><strong>Test 1: Memory Limit Enforcement</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create container with 10MB memory limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#79B8FF\"> --memory-limit=10485760</span><span style=\"color:#9ECBFF\"> stress</span><span style=\"color:#79B8FF\"> --vm</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> --vm-bytes</span><span style=\"color:#9ECBFF\"> 20M</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Container should be OOM killed when trying to allocate 20MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: dmesg should show \"Memory cgroup out of memory\" message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: echo $? should return non-zero exit code</span></span></code></pre></div>\n\n<p><strong>Test 2: CPU Limit Verification</strong>  </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create container with 25% CPU limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#79B8FF\"> --cpu-percent=25</span><span style=\"color:#9ECBFF\"> dd</span><span style=\"color:#9ECBFF\"> if=/dev/zero</span><span style=\"color:#9ECBFF\"> of=/dev/null</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Container should use ~25% CPU even under full load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: Use 'top' or 'htop' to verify CPU usage stays around 25%</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: CPU throttling stats in /sys/fs/cgroup/.../cpu.stat</span></span></code></pre></div>\n\n<p><strong>Test 3: Process Limit Testing</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create container with 5 process limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#79B8FF\"> --max-processes=5</span><span style=\"color:#9ECBFF\"> bash</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> 'for i in {1..10}; do sleep 30 &#x26; done'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Only first 5 background processes should start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check: ps aux should show exactly 5 sleep processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify: Attempts to create 6th process should fail with EAGAIN</span></span></code></pre></div>\n\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li><strong>Memory limits ignored</strong>: Container allocates more than limit without OOM → Check controller availability and cgroup v1/v2 detection</li>\n<li><strong>CPU limits not enforced</strong>: Container uses 100% CPU despite limit → Verify quota/period calculation and control file writes  </li>\n<li><strong>Process limits bypassed</strong>: More processes created than limit → Check PIDs controller mounting and process assignment</li>\n<li><strong>Cleanup failures</strong>: Orphaned cgroup directories in <code>/sys/fs/cgroup/</code> → Implement proper process termination before cgroup removal</li>\n</ul>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fcgroups-hierarchy.svg\" alt=\"Cgroups Resource Control Hierarchy\"></p>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section spans all milestones (1-4), describing how the PID namespace, mount namespace, network namespace, and cgroups components coordinate during container lifecycle operations.</p>\n</blockquote>\n<p>The container runtime operates as a carefully orchestrated system where multiple Linux kernel isolation mechanisms must be created, configured, and managed in a specific sequence. Think of launching a container like <strong>setting up a new office branch</strong>: you need to establish the building (mount namespace), assign phone numbers (PID namespace), connect telecommunications (network namespace), and allocate budgets (cgroups) - and all of these must happen in the right order, with each step depending on the previous ones completing successfully.</p>\n<p>The coordination challenge stems from the interdependencies between namespace types and the fact that many operations must occur from specific contexts (host vs container namespace). Additionally, cleanup requires the reverse order to prevent resource leaks, similar to how you must evacuate employees before disconnecting utilities when closing an office branch.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fcontainer-startup-flow.svg\" alt=\"Container Startup Sequence\"></p>\n<h3 id=\"container-startup-sequence\">Container Startup Sequence</h3>\n<p>Container creation follows a precise multi-stage sequence that coordinates namespace creation, process forking, resource limit application, and error recovery. Each stage has specific responsibilities and must complete before the next stage can begin.</p>\n<p>The startup sequence operates through <strong>three distinct execution contexts</strong>: the parent process running in host namespaces, the child process transitioning between namespaces, and the final containerized process running in complete isolation. Understanding which operations occur in which context is crucial for proper implementation.</p>\n<p><strong>Stage 1: Preparation and Validation</strong></p>\n<p>The startup sequence begins in the host context with configuration validation and resource preparation. This stage verifies that all required kernel features are available and that the container configuration is valid before creating any namespaces.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Purpose</th>\n<th>Validation Checks</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Validate rootfs path</td>\n<td>Ensure container filesystem exists</td>\n<td>Directory exists, readable, contains essential directories</td>\n</tr>\n<tr>\n<td>Check kernel features</td>\n<td>Verify namespace support available</td>\n<td>/proc/self/ns/ contains required namespace files</td>\n</tr>\n<tr>\n<td>Detect cgroup version</td>\n<td>Determine cgroups v1 vs v2</td>\n<td>Check /sys/fs/cgroup mount type and available controllers</td>\n</tr>\n<tr>\n<td>Verify privileges</td>\n<td>Ensure sufficient permissions</td>\n<td>CAP_SYS_ADMIN capability or root privileges</td>\n</tr>\n<tr>\n<td>Allocate resources</td>\n<td>Reserve network IP and cgroup paths</td>\n<td>Generate unique container ID, check IP availability</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: All validation occurs before creating any namespaces because cleanup becomes significantly more complex once kernel resources are allocated. A validation failure at this stage requires no cleanup.</p>\n</blockquote>\n<p><strong>Stage 2: Namespace Creation and Process Forking</strong></p>\n<p>The core isolation setup occurs through the <code>safe_clone()</code> system call with combined namespace flags. This single operation creates the child process and establishes all required namespaces simultaneously, avoiding the timing and synchronization issues that arise from sequential namespace creation.</p>\n<p>The parent process executes the following sequence:</p>\n<ol>\n<li><strong>Allocate clone stack</strong>: Reserve <code>STACK_SIZE</code> bytes for the child process stack, ensuring proper alignment for the target architecture</li>\n<li><strong>Prepare container instance</strong>: Initialize <code>container_instance_t</code> structure with allocated cleanup list and namespace file descriptors array</li>\n<li><strong>Register cleanup functions</strong>: Add cleanup handlers for stack deallocation, namespace closing, and cgroup removal to handle setup failures</li>\n<li><strong>Execute clone system call</strong>: Call <code>safe_clone(container_init_process, stack, CONTAINER_NS_FLAGS, config)</code> to create isolated child process</li>\n<li><strong>Store child PID</strong>: Record the child process ID in the container instance for monitoring and cleanup purposes</li>\n<li><strong>Open namespace file descriptors</strong>: Access <code>/proc/&lt;child_pid&gt;/ns/*</code> files to maintain references to the created namespaces</li>\n</ol>\n<p>The child process begins execution in the new namespaces with a completely different view of system resources. It sees itself as PID 1 in an empty process tree, has access only to the new mount namespace, and possesses an isolated network stack.</p>\n<table>\n<thead>\n<tr>\n<th>Namespace Type</th>\n<th>Child Process View</th>\n<th>Parent Process View</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID</td>\n<td>Process sees itself as PID 1, no other processes visible</td>\n<td>Child appears as normal PID in host process tree</td>\n</tr>\n<tr>\n<td>Mount</td>\n<td>Inherits host mount tree initially, will be modified</td>\n<td>Host mount tree unchanged</td>\n</tr>\n<tr>\n<td>Network</td>\n<td>Empty network namespace with only loopback interface</td>\n<td>Host network interfaces remain accessible</td>\n</tr>\n<tr>\n<td>UTS</td>\n<td>Separate hostname that can be changed independently</td>\n<td>Host hostname unchanged</td>\n</tr>\n<tr>\n<td>IPC</td>\n<td>Empty IPC namespace with no shared memory segments</td>\n<td>Host IPC resources remain accessible</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Principle</strong>: Using <code>clone()</code> with combined flags creates all namespaces atomically, eliminating race conditions that occur when creating namespaces sequentially with <code>unshare()</code>.</p>\n</blockquote>\n<p><strong>Stage 3: Cgroups Resource Limit Setup</strong></p>\n<p>Resource limits must be established immediately after process creation but before the container process begins executing user code. This timing ensures that resource consumption is controlled from the very beginning of container execution.</p>\n<p>The parent process handles cgroup setup because it retains the necessary privileges and host filesystem access:</p>\n<ol>\n<li><strong>Create cgroup hierarchy</strong>: Call <code>create_container_cgroup(config, container)</code> to establish the cgroup directory structure in the appropriate controller hierarchies</li>\n<li><strong>Assign child process</strong>: Execute <code>assign_process_to_cgroup(container-&gt;cgroup_path, container-&gt;child_pid)</code> to place the container process under resource control</li>\n<li><strong>Configure memory limits</strong>: Apply memory restrictions using <code>set_memory_limit(container-&gt;cgroup_path, config-&gt;memory_limit_bytes)</code> before significant memory allocation occurs</li>\n<li><strong>Configure CPU limits</strong>: Establish CPU usage restrictions through <code>set_cpu_limit(container-&gt;cgroup_path, config-&gt;cpu_percent)</code> to prevent CPU monopolization</li>\n<li><strong>Configure process limits</strong>: Set maximum process count via <code>set_process_limit(container-&gt;cgroup_path, config-&gt;max_processes)</code> to prevent fork bomb attacks</li>\n<li><strong>Verify limit enforcement</strong>: Read back cgroup settings using <code>read_cgroup_stat()</code> to confirm that limits were applied correctly</li>\n</ol>\n<p>The cgroup assignment affects the child process immediately, even though the child is simultaneously setting up its namespace environment. This parallel execution is safe because cgroups operate at the kernel level and do not interfere with namespace operations.</p>\n<p><strong>Stage 4: Container Environment Initialization</strong></p>\n<p>The child process, now running as PID 1 in isolated namespaces with resource limits applied, must establish the container&#39;s execution environment. This stage transforms the raw namespace environment into a functional container.</p>\n<p>The <code>container_init_process()</code> function executes the following initialization sequence:</p>\n<ol>\n<li><strong>Configure signal handling</strong>: Call <code>setup_init_signals()</code> to establish proper signal handlers for zombie process reaping, since the container process inherits PID 1 responsibilities</li>\n<li><strong>Create mount namespace isolation</strong>: Execute <code>create_mount_namespace(config, container)</code> to establish private mount propagation and prepare for filesystem modifications</li>\n<li><strong>Setup container root filesystem</strong>: Run <code>setup_container_rootfs(config-&gt;rootfs_path, &quot;/mnt/old_root&quot;)</code> to prepare the new root directory structure</li>\n<li><strong>Perform pivot root operation</strong>: Execute <code>pivot_to_container_root(config-&gt;rootfs_path, &quot;/mnt/old_root&quot;)</code> to switch the filesystem root to the container filesystem</li>\n<li><strong>Mount essential filesystems</strong>: Call <code>mount_essential_filesystems()</code> to provide <code>/proc</code>, <code>/sys</code>, and <code>/dev</code> filesystems required by containerized applications</li>\n<li><strong>Configure network interface</strong>: Execute network configuration commands to set up the container end of the veth pair with the assigned IP address</li>\n<li><strong>Set hostname</strong>: Update the container hostname using <code>sethostname()</code> to provide identity isolation</li>\n<li><strong>Drop privileges</strong>: If configured, drop unnecessary capabilities and change to a non-root user for security</li>\n</ol>\n<blockquote>\n<p><strong>Synchronization Point</strong>: The parent process waits for the child to complete mount namespace setup before proceeding with network configuration, since network setup requires knowledge of the child&#39;s network namespace.</p>\n</blockquote>\n<p><strong>Stage 5: Network Connectivity Establishment</strong></p>\n<p>Network connectivity setup requires coordination between parent and child processes because veth pair creation occurs in the host namespace while interface configuration occurs in the container namespace.</p>\n<p>The parent process handles the host-side networking:</p>\n<ol>\n<li><strong>Create veth pair</strong>: Call <code>create_veth_pair(host_if_name, container_if_name)</code> to create the virtual ethernet link with unique interface names</li>\n<li><strong>Assign container interface</strong>: Execute <code>assign_veth_to_namespace(container_if_name, container-&gt;child_pid)</code> to move the container end into the child&#39;s network namespace</li>\n<li><strong>Attach to host bridge</strong>: Run <code>attach_to_bridge(host_if_name, config-&gt;bridge_name)</code> to connect the host end to the bridge for inter-container communication</li>\n<li><strong>Configure host interface</strong>: Bring up the host end of the veth pair and configure any required routing rules for container connectivity</li>\n</ol>\n<p>The child process, running in its network namespace, configures the container-side networking:</p>\n<ol>\n<li><strong>Configure container interface</strong>: Execute <code>configure_container_interface(container_if_name, config-&gt;container_ip, netmask)</code> to assign the IP address and activate the interface</li>\n<li><strong>Setup default route</strong>: Call <code>setup_default_route(gateway_ip)</code> to establish connectivity to external networks through the host bridge</li>\n<li><strong>Verify connectivity</strong>: Test basic network functionality by attempting to reach the gateway and DNS resolution</li>\n</ol>\n<p><strong>Stage 6: Application Execution</strong></p>\n<p>Once all namespace and resource setup completes, the container process transitions to executing the user-specified application. This transition represents the completion of container initialization and the beginning of application runtime.</p>\n<p>The final steps in <code>container_init_process()</code> prepare for application execution:</p>\n<ol>\n<li><strong>Validate executable</strong>: Verify that <code>config-&gt;argv[0]</code> exists and is executable within the container filesystem</li>\n<li><strong>Prepare environment</strong>: Set up environment variables from <code>config-&gt;envp</code> and add container-specific variables</li>\n<li><strong>Change working directory</strong>: Set the working directory to an appropriate location within the container filesystem</li>\n<li><strong>Execute application</strong>: Call <code>execve(config-&gt;argv[0], config-&gt;argv, config-&gt;envp)</code> to replace the init process with the container application</li>\n</ol>\n<blockquote>\n<p><strong>Process Identity Change</strong>: The <code>execve()</code> call replaces the container init process with the application, but the process retains PID 1 and all namespace memberships and resource limits.</p>\n</blockquote>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fcontainer-lifecycle-states.svg\" alt=\"Container Lifecycle State Machine\"></p>\n<h3 id=\"container-cleanup-sequence\">Container Cleanup Sequence</h3>\n<p>Container cleanup must occur in the reverse order of creation to prevent resource leaks and ensure proper kernel resource deallocation. The cleanup sequence handles both normal termination and error recovery scenarios.</p>\n<p>The cleanup challenge stems from the fact that <strong>namespaces and cgroups form dependency relationships</strong>: processes must exit before their cgroups can be removed, namespace file descriptors must be closed before namespace resources are freed, and mount points must be unmounted before mount namespaces can be destroyed.</p>\n<p><strong>Cleanup Trigger Detection</strong></p>\n<p>Container cleanup begins when the parent process detects that the child process has exited. The <code>container_wait(container)</code> function monitors the child process and initiates cleanup when termination occurs.</p>\n<table>\n<thead>\n<tr>\n<th>Termination Cause</th>\n<th>Detection Method</th>\n<th>Cleanup Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal application exit</td>\n<td>waitpid() returns with WIFEXITED</td>\n<td>Standard cleanup sequence</td>\n</tr>\n<tr>\n<td>Application killed by signal</td>\n<td>waitpid() returns with WIFSIGNALED</td>\n<td>Standard cleanup sequence</td>\n</tr>\n<tr>\n<td>OOM killer termination</td>\n<td>waitpid() returns, check cgroup memory events</td>\n<td>Memory limit exceeded, standard cleanup</td>\n</tr>\n<tr>\n<td>Container timeout</td>\n<td>waitpid() with timeout expires</td>\n<td>Send SIGTERM, wait, send SIGKILL, then cleanup</td>\n</tr>\n<tr>\n<td>Setup error</td>\n<td>clone() fails or child setup fails</td>\n<td>Partial cleanup based on cleanup list</td>\n</tr>\n</tbody></table>\n<p><strong>Stage 1: Process Termination and Signal Handling</strong></p>\n<p>The cleanup sequence begins with ensuring that all processes within the container have terminated. This step is crucial because active processes prevent namespace destruction and can cause resource leaks.</p>\n<ol>\n<li><strong>Detect child exit</strong>: The <code>container_wait()</code> function uses <code>waitpid(container-&gt;child_pid, &amp;status, 0)</code> to detect when the main container process exits</li>\n<li><strong>Collect exit status</strong>: Extract the exit code or termination signal from the wait status for reporting to the container user</li>\n<li><strong>Handle zombie reaping</strong>: If the container process spawned additional children, ensure all zombies are collected to prevent process table pollution</li>\n<li><strong>Force termination if needed</strong>: For timeout scenarios, send <code>SIGTERM</code> followed by <code>SIGKILL</code> to ensure process termination</li>\n</ol>\n<blockquote>\n<p><strong>Zombie Prevention</strong>: Since the container process runs as PID 1, it must reap its own children. If the application fails to do this, zombie processes remain until namespace destruction.</p>\n</blockquote>\n<p><strong>Stage 2: Network Namespace Cleanup</strong></p>\n<p>Network resources require early cleanup because they involve kernel objects that reference the network namespace. Delaying network cleanup can cause memory leaks in the kernel networking subsystem.</p>\n<p>The <code>cleanup_network_namespace(container)</code> function performs network teardown:</p>\n<ol>\n<li><strong>Remove veth interfaces</strong>: The kernel automatically destroys both ends of the veth pair when the container network namespace is destroyed, but explicit cleanup ensures immediate resource recovery</li>\n<li><strong>Close namespace file descriptors</strong>: Close the network namespace file descriptor stored in <code>container-&gt;namespace_fds[CLONE_NEWNET]</code> to release the namespace reference</li>\n<li><strong>Update bridge state</strong>: Remove any bridge forwarding entries that referenced the container&#39;s MAC address to prevent stale entries</li>\n<li><strong>Release IP address</strong>: Return the allocated IP address to the available pool for reuse by future containers</li>\n</ol>\n<p><strong>Stage 3: Mount Namespace Cleanup</strong></p>\n<p>Mount namespace cleanup involves unmounting filesystems and releasing filesystem references. This stage must handle both successful containers (where pivot_root occurred) and failed containers (where mount setup was incomplete).</p>\n<p>The mount cleanup process follows this sequence:</p>\n<ol>\n<li><strong>Detect mount state</strong>: Check whether pivot_root completed successfully by examining the container&#39;s current root directory</li>\n<li><strong>Unmount essential filesystems</strong>: Remove <code>/proc</code>, <code>/sys</code>, and <code>/dev</code> mounts that were created within the container namespace</li>\n<li><strong>Handle old root cleanup</strong>: If pivot_root succeeded, unmount the old root directory that was bind-mounted during the pivot operation</li>\n<li><strong>Unmount bind mounts</strong>: Remove any host directory bind mounts that were established for the container</li>\n<li><strong>Close mount namespace</strong>: Close the mount namespace file descriptor to release the namespace reference</li>\n</ol>\n<blockquote>\n<p><strong>Mount Cleanup Challenge</strong>: Mount points must be unmounted in reverse dependency order. Child mounts must be unmounted before parent mounts, similar to how directory trees must be deleted from leaves to root.</p>\n</blockquote>\n<p><strong>Stage 4: PID Namespace Cleanup</strong></p>\n<p>PID namespace cleanup is largely automatic once all processes within the namespace have exited. However, explicit cleanup steps ensure proper resource recovery and handle edge cases.</p>\n<ol>\n<li><strong>Verify process termination</strong>: Confirm that all processes within the PID namespace have exited by checking that no <code>/proc/&lt;pid&gt;/ns/pid</code> files reference the container&#39;s PID namespace</li>\n<li><strong>Close PID namespace file descriptor</strong>: Release the PID namespace reference held by the parent process</li>\n<li><strong>Clean up process tracking</strong>: Remove any process monitoring or logging that was specific to the container&#39;s PID namespace</li>\n</ol>\n<p><strong>Stage 5: Cgroup Hierarchy Removal</strong></p>\n<p>Cgroup cleanup must occur after all processes have exited because cgroups cannot be removed while they contain active processes. The <code>cleanup_container_cgroup(cgroup_path)</code> function handles hierarchical cleanup.</p>\n<p>The cgroup removal process follows strict ordering requirements:</p>\n<ol>\n<li><strong>Verify process exit</strong>: Confirm that the cgroup&#39;s <code>tasks</code> file is empty, indicating all processes have exited</li>\n<li><strong>Read final statistics</strong>: Collect final resource usage statistics before removing the cgroup for reporting or debugging</li>\n<li><strong>Remove child cgroups</strong>: If any sub-cgroups were created, remove them in reverse creation order</li>\n<li><strong>Remove parent cgroup</strong>: Delete the main container cgroup directory, which automatically releases all associated kernel resources</li>\n<li><strong>Verify controller cleanup</strong>: Ensure that all cgroup controllers have properly released their resources</li>\n</ol>\n<blockquote>\n<p><strong>Hierarchical Dependency</strong>: Cgroups form a hierarchy where child cgroups must be removed before their parents. The kernel enforces this ordering and will reject attempts to remove parent cgroups while children exist.</p>\n</blockquote>\n<p><strong>Stage 6: Resource Cleanup and Finalization</strong></p>\n<p>The final cleanup stage releases user-space resources and updates any external state that tracked the container&#39;s existence.</p>\n<ol>\n<li><strong>Execute registered cleanup functions</strong>: Process the <code>cleanup_list_t</code> chain to execute all registered cleanup functions in reverse order</li>\n<li><strong>Release memory allocations</strong>: Free the container instance structure, configuration copies, and any allocated string buffers</li>\n<li><strong>Close remaining file descriptors</strong>: Ensure all namespace file descriptors and other file handles are closed</li>\n<li><strong>Update container registry</strong>: Remove the container from any runtime tracking structures or persistent state</li>\n<li><strong>Log cleanup completion</strong>: Record successful cleanup for debugging and auditing purposes</li>\n</ol>\n<h3 id=\"error-propagation\">Error Propagation</h3>\n<p>Error handling in container creation requires careful coordination because failures can occur in any component while other components are simultaneously executing setup operations. The error propagation system must ensure that partial setup is properly cleaned up regardless of where failure occurs.</p>\n<p><strong>Error Categories and Impact Scope</strong></p>\n<p>Container creation errors fall into distinct categories based on their scope and recovery requirements. Understanding these categories guides the error propagation strategy.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Examples</th>\n<th>Impact Scope</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Validation Errors</td>\n<td>Invalid rootfs path, missing capabilities</td>\n<td>Pre-setup</td>\n<td>Simple return, no cleanup needed</td>\n</tr>\n<tr>\n<td>Resource Allocation</td>\n<td>Out of memory, PID exhaustion</td>\n<td>Single component</td>\n<td>Component-specific cleanup</td>\n</tr>\n<tr>\n<td>Kernel Feature Errors</td>\n<td>Namespace not supported, cgroup unavailable</td>\n<td>System-wide</td>\n<td>Graceful degradation or abort</td>\n</tr>\n<tr>\n<td>Race Conditions</td>\n<td>Network interface conflicts, cgroup timing</td>\n<td>Cross-component</td>\n<td>Retry with backoff</td>\n</tr>\n<tr>\n<td>Permission Errors</td>\n<td>Insufficient privileges, filesystem access</td>\n<td>Context-dependent</td>\n<td>Privilege escalation or abort</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Error Propagation Principle</strong>: Errors must be propagated to the point where complete cleanup can be performed. This often means that child process errors must be communicated to the parent process that holds cleanup responsibilities.</p>\n</blockquote>\n<p><strong>Cleanup List Mechanism</strong></p>\n<p>The <code>cleanup_list_t</code> structure provides a systematic approach to error recovery by maintaining a stack of cleanup operations that corresponds to successful setup operations. Each setup operation registers its corresponding cleanup function before proceeding.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cleanup Registration Pattern:\n1. Attempt setup operation\n2. If successful, register corresponding cleanup function\n3. If failure, execute all registered cleanup functions\n4. Propagate error to caller</code></pre></div>\n\n<p>The cleanup list operates as a <strong>stack (LIFO) structure</strong> to ensure that cleanup occurs in reverse setup order:</p>\n<table>\n<thead>\n<tr>\n<th>Setup Operation</th>\n<th>Cleanup Registration</th>\n<th>Cleanup Function</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>clone() process creation</td>\n<td><code>register_cleanup(list, kill_child_process, &amp;child_pid)</code></td>\n<td>Send SIGKILL and waitpid()</td>\n</tr>\n<tr>\n<td>Create cgroup directory</td>\n<td><code>register_cleanup(list, remove_cgroup, cgroup_path)</code></td>\n<td>rmdir() cgroup directory</td>\n</tr>\n<tr>\n<td>Create veth pair</td>\n<td><code>register_cleanup(list, destroy_veth_pair, if_name)</code></td>\n<td>Delete network interfaces</td>\n</tr>\n<tr>\n<td>Open namespace FDs</td>\n<td><code>register_cleanup(list, close_namespace_fds, fd_array)</code></td>\n<td>Close all file descriptors</td>\n</tr>\n<tr>\n<td>Mount filesystems</td>\n<td><code>register_cleanup(list, unmount_filesystems, mount_list)</code></td>\n<td>Unmount in reverse order</td>\n</tr>\n</tbody></table>\n<p><strong>Parent-Child Error Communication</strong></p>\n<p>Error propagation between parent and child processes requires special handling because the processes operate in different contexts and may not share memory after namespace creation.</p>\n<p>The communication mechanism uses <strong>process exit codes</strong> and <strong>signal patterns</strong> to convey error information:</p>\n<ol>\n<li><strong>Success Path</strong>: Child process calls <code>execve()</code> to run the container application, never returns to init code</li>\n<li><strong>Setup Error Path</strong>: Child process exits with specific error codes that indicate the failure point</li>\n<li><strong>Runtime Error Path</strong>: Child process is killed by signal, indicating runtime failure (OOM, segmentation fault, etc.)</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Child Exit Status</th>\n<th>Error Interpretation</th>\n<th>Parent Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>execve() success (no exit)</td>\n<td>Container running normally</td>\n<td>Monitor process, wait for termination</td>\n</tr>\n<tr>\n<td>Exit code 1-99</td>\n<td>Setup error in specific component</td>\n<td>Execute cleanup, report setup failure</td>\n</tr>\n<tr>\n<td>Exit code 100-199</td>\n<td>Resource limit exceeded</td>\n<td>Execute cleanup, report resource exhaustion</td>\n</tr>\n<tr>\n<td>SIGKILL with OOM flag</td>\n<td>Memory limit enforcement</td>\n<td>Execute cleanup, report OOM condition</td>\n</tr>\n<tr>\n<td>SIGSEGV or SIGABRT</td>\n<td>Application crash</td>\n<td>Execute cleanup, report application error</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Communication Limitation</strong>: Once the child process has entered its namespaces, it cannot directly communicate complex error information to the parent. Exit codes provide the only reliable error propagation mechanism.</p>\n</blockquote>\n<p><strong>Cross-Component Error Handling</strong></p>\n<p>When multiple components are setting up simultaneously (such as cgroups in parent and mount namespace in child), error propagation must coordinate across component boundaries.</p>\n<p><strong>Network Setup Error Example</strong>: If veth pair creation fails in the parent process while the child process is simultaneously setting up mount namespaces:</p>\n<ol>\n<li><strong>Parent detects veth creation failure</strong>: The <code>create_veth_pair()</code> function returns an error code</li>\n<li><strong>Parent signals child termination</strong>: Send <code>SIGTERM</code> to child process to abort its setup</li>\n<li><strong>Child detects termination signal</strong>: Mount setup code checks for pending signals and aborts gracefully</li>\n<li><strong>Parent waits for child exit</strong>: Use <code>waitpid()</code> to confirm child has terminated</li>\n<li><strong>Parent executes cleanup</strong>: Run all registered cleanup functions to release allocated resources</li>\n<li><strong>Parent propagates error</strong>: Return error code to <code>container_create()</code> caller with specific failure reason</li>\n</ol>\n<p><strong>Mount Setup Error Example</strong>: If pivot_root fails in the child process while the parent has already created cgroups and network interfaces:</p>\n<ol>\n<li><strong>Child detects pivot_root failure</strong>: The filesystem operation returns an error</li>\n<li><strong>Child exits with specific code</strong>: Exit with code indicating mount setup failure</li>\n<li><strong>Parent detects child exit</strong>: <code>waitpid()</code> returns with child exit status</li>\n<li><strong>Parent interprets error</strong>: Exit code indicates which component failed</li>\n<li><strong>Parent executes full cleanup</strong>: Clean up cgroups, network interfaces, and other resources</li>\n<li><strong>Parent reports specific error</strong>: Return detailed error information about mount failure</li>\n</ol>\n<p><strong>Error Recovery Strategies</strong></p>\n<p>Different error scenarios require different recovery approaches based on whether the error is transient, permanent, or indicates system-level issues.</p>\n<blockquote>\n<p><strong>Decision: Fail-Fast vs. Graceful Degradation</strong></p>\n<ul>\n<li><strong>Context</strong>: Some container features (like specific cgroup controllers) may be unavailable but container creation could proceed with reduced functionality</li>\n<li><strong>Options Considered</strong>: Always fail fast, always gracefully degrade, configurable behavior</li>\n<li><strong>Decision</strong>: Fail fast for essential features (PID, mount namespaces), graceful degradation for optional features (specific cgroup controllers)</li>\n<li><strong>Rationale</strong>: Essential features are required for basic isolation security. Optional features can be disabled while maintaining core container functionality.</li>\n<li><strong>Consequences</strong>: Clear security guarantees but reduced flexibility in heterogeneous environments</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Recovery Strategy</th>\n<th>When to Apply</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Retry</td>\n<td>Transient resource conflicts</td>\n<td>Retry with exponential backoff up to 3 attempts</td>\n</tr>\n<tr>\n<td>Graceful Degradation</td>\n<td>Optional feature unavailability</td>\n<td>Continue with feature disabled, log warning</td>\n</tr>\n<tr>\n<td>Fail Fast</td>\n<td>Essential feature missing</td>\n<td>Immediate cleanup and error propagation</td>\n</tr>\n<tr>\n<td>Resource Cleanup and Retry</td>\n<td>Resource exhaustion</td>\n<td>Clean up failed attempt, wait, retry once</td>\n</tr>\n<tr>\n<td>System Error Reporting</td>\n<td>Kernel or hardware issues</td>\n<td>Clean up, report system-level error, do not retry</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The container lifecycle coordination requires careful orchestration of system calls, process synchronization, and resource management across multiple kernel subsystems.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process Creation</td>\n<td>fork() + namespace setup</td>\n<td>clone() with combined flags</td>\n</tr>\n<tr>\n<td>Error Communication</td>\n<td>Exit codes only</td>\n<td>Shared memory + exit codes</td>\n</tr>\n<tr>\n<td>Cleanup Coordination</td>\n<td>Function pointer list</td>\n<td>State machine with rollback</td>\n</tr>\n<tr>\n<td>Synchronization</td>\n<td>waitpid() polling</td>\n<td>eventfd + signaling</td>\n</tr>\n<tr>\n<td>Resource Tracking</td>\n<td>Manual cleanup functions</td>\n<td>RAII-style resource guards</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">container</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">basic</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  src</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    container.c              ← main container lifecycle coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    container.h              ← public container API and structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    container_internal.h     ← internal coordination structures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    namespace_manager.c      ← namespace creation coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanup.c               ← cleanup list and error recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sync.c                  ← parent</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">child synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_lifecycle.c        ← container creation and cleanup tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_error_handling.c   ← error propagation and recovery tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_coordination.c     ← component interaction tests</span></span></code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Complete cleanup list management for systematic error recovery:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cleanup.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cleanup_list {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup_func)(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanup.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"cleanup.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">entry </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">entry) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Failed to allocate cleanup entry</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry->cleanup_func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry->data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> data;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry->next </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> entry;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">list</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">current </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">list;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (current) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (current->cleanup_func) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current-></span><span style=\"color:#B392F0\">cleanup_func</span><span style=\"color:#E1E4E8\">(current->data);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        cleanup_list_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">next </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current->next;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        free</span><span style=\"color:#E1E4E8\">(current);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Common cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_close_fd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int*</span><span style=\"color:#E1E4E8\">)data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_kill_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t*</span><span style=\"color:#E1E4E8\">)data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(pid, SIGTERM);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        usleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\"> // 100ms grace period</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_remove_cgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char*</span><span style=\"color:#E1E4E8\">)data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (path </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#B392F0\"> strlen</span><span style=\"color:#E1E4E8\">(path) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        rmdir</span><span style=\"color:#E1E4E8\">(path);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Parent-child synchronization utilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// sync.h</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> container_sync {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> parent_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">  // Parent writes, child reads</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> child_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">   // Child writes, parent reads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_sync_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// sync.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> \"sync.h\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_sync_pipes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_sync_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sync</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(sync->parent_pipe) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(sync->child_pipe) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sync->parent_pipe[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(sync->parent_pipe[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> wait_for_child_ready</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_sync_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sync</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(sync->child_pipe[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span><span style=\"color:#6A737D\"> // Close write end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> ready_signal;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(sync->child_pipe[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ready_signal, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(sync->child_pipe[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> ready_signal </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '1'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> signal_parent_ready</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_sync_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">sync</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(sync->child_pipe[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span><span style=\"color:#6A737D\"> // Close read end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> ready_signal </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '1'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(sync->child_pipe[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ready_signal, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(sync->child_pipe[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Main container lifecycle coordination:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// container.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_create</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize container instance structure with cleanup list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate configuration (rootfs exists, privileges sufficient)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Allocate clone stack and register stack cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create synchronization pipes for parent-child coordination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Execute safe_clone() with CONTAINER_NS_FLAGS to create isolated child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store child PID and register process cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Open namespace file descriptors from /proc/&#x3C;child_pid>/ns/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Create and configure cgroup hierarchy for resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Wait for child to complete mount namespace setup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Set up host-side networking (veth pair, bridge attachment)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 11: Signal child to proceed with final application execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use cleanup list to ensure proper resource release on any failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_init_process</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set up signal handlers for PID 1 responsibilities (zombie reaping)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create mount namespace isolation with private propagation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up container root filesystem directory structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Perform pivot_root operation to switch filesystem root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Mount essential filesystems (/proc, /sys, /dev) in container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Configure container network interface with assigned IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Set container hostname for identity isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Signal parent that container setup is complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Change to application working directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Execute target application with execve()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Exit with specific error codes to communicate failure type to parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Should never reach here if execve() succeeds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_wait</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Wait for child process to exit using waitpid()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if child was killed by signal (WIFSIGNALED)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Extract exit code or signal number for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check cgroup memory events for OOM detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return appropriate error code based on termination cause</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Different termination types require different cleanup approaches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_destroy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Ensure child process has fully terminated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Clean up network namespace and veth interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Clean up mount namespace and filesystem mounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Close all namespace file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove cgroup hierarchy and release resource controls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Execute all registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Free container instance memory and allocated resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Follow reverse order of creation to prevent dependency issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Error propagation and recovery coordination:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// error_handling.c</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_NONE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_VALIDATION </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_PRIVILEGES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_NAMESPACES </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_MOUNT </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_NETWORK </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_CGROUPS </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 40</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_OOM </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_KILLED </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 200</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_error_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> handle_container_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_error_t</span><span style=\"color:#FFAB70\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log error details with specific failure component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Determine cleanup scope based on error type and setup progress</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Signal child process termination if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute appropriate cleanup sequence for current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Collect any additional error information (logs, resource usage)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return standardized error code for caller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Error cleanup must be safe to call regardless of setup progress</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> propagate_child_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> child_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> child_status</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if child exited normally or was killed by signal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract error code from child exit status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Map child error codes to container error types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for OOM killer involvement via cgroup events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return appropriate container error code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Child exit codes encode which component failed during setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> CONTAINER_ERROR_NONE;</span><span style=\"color:#6A737D\"> // Replace with implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li>Use <code>clone()</code> instead of <code>fork()</code> + <code>unshare()</code> to avoid race conditions in namespace setup</li>\n<li>The <code>SIGCHLD</code> handler for zombie reaping must be async-signal-safe (no malloc, printf, etc.)</li>\n<li>Stack for <code>clone()</code> grows downward on most architectures - allocate at high address</li>\n<li>Check <code>/proc/self/ns/</code> to verify namespace support before attempting creation</li>\n<li>Use <code>eventfd()</code> for more reliable parent-child synchronization than pipes</li>\n<li><code>pivot_root()</code> requires both old and new root to be on different filesystems</li>\n<li>Network namespace operations require <code>CAP_NET_ADMIN</code> capability</li>\n<li>Cgroup cleanup requires removing child cgroups before parent cgroups</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing container lifecycle coordination:</p>\n<p><strong>Test Container Creation and Cleanup:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile with all components</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> container-basic</span><span style=\"color:#9ECBFF\"> src/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">.c</span><span style=\"color:#79B8FF\"> -I./src</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test basic container creation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-basic</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> /tmp/container-root</span><span style=\"color:#79B8FF\"> --cmd</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify namespaces created correctly</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> lsns</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> pid,mnt,net</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> container-basic</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test error handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container-basic</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> /nonexistent</span><span style=\"color:#79B8FF\"> --cmd</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Exit code: </span><span style=\"color:#79B8FF\">$?</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test resource cleanup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-basic</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --rootfs</span><span style=\"color:#9ECBFF\"> /tmp/container-root</span><span style=\"color:#79B8FF\"> --memory</span><span style=\"color:#9ECBFF\"> 100M</span><span style=\"color:#79B8FF\"> --cmd</span><span style=\"color:#9ECBFF\"> \"sleep 1\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify cgroup removed after container exits</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/memory/container-basic-</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"Cleanup successful\"</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong></p>\n<ul>\n<li>Container starts with all namespaces isolated</li>\n<li>Application runs with resource limits enforced</li>\n<li>Cleanup removes all created resources</li>\n<li>Error conditions trigger proper cleanup</li>\n<li>No resource leaks in namespace or cgroup hierarchies</li>\n</ul>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container hangs during startup</td>\n<td>Parent-child synchronization deadlock</td>\n<td>Check pipe file descriptors, look for blocking reads</td>\n<td>Add timeouts to synchronization waits</td>\n</tr>\n<tr>\n<td>&quot;Operation not permitted&quot; on clone</td>\n<td>Insufficient privileges for namespace creation</td>\n<td>Check capabilities with <code>capsh --print</code>, verify CAP_SYS_ADMIN</td>\n<td>Run as root or add required capabilities</td>\n</tr>\n<tr>\n<td>Mount operations fail inside container</td>\n<td>Mount namespace not properly isolated</td>\n<td>Check /proc/mounts in container vs host</td>\n<td>Ensure MS_PRIVATE propagation set correctly</td>\n</tr>\n<tr>\n<td>Network interface not found</td>\n<td>Veth pair creation or assignment failed</td>\n<td>Check <code>ip link</code> for interface existence</td>\n<td>Verify network namespace creation and interface movement</td>\n</tr>\n<tr>\n<td>OOM killer terminates container immediately</td>\n<td>Memory limit too low for application</td>\n<td>Check cgroup memory.usage_in_bytes vs memory.limit_in_bytes</td>\n<td>Increase memory limit or reduce application memory usage</td>\n</tr>\n<tr>\n<td>Resources not cleaned up after exit</td>\n<td>Cleanup functions not registered or executed</td>\n<td>Check cleanup list registration and execution order</td>\n<td>Ensure all setup operations register cleanup handlers</td>\n</tr>\n<tr>\n<td>Child process becomes zombie</td>\n<td>Parent not calling waitpid()</td>\n<td>Check parent process signal handlers and main loop</td>\n<td>Implement proper SIGCHLD handling or explicit wait calls</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all milestones (1-4), covering failure modes and recovery strategies across PID namespaces, mount namespaces, network namespaces, and cgroups components.</p>\n</blockquote>\n<p>Building a container runtime involves orchestrating multiple kernel subsystems, each with distinct failure modes and complex interdependencies. When creating namespaces, configuring cgroups, or setting up networking, numerous failure scenarios can occur - from insufficient privileges to kernel feature unavailability to resource exhaustion. The challenge is not just handling individual component failures, but managing the cascading effects and cleanup requirements when failures occur during the multi-step container startup sequence.</p>\n<p><strong>Mental Model: Emergency Response System</strong>: Think of container error handling like a hospital&#39;s emergency response system. When a medical emergency occurs, the hospital has well-defined protocols for different types of incidents (cardiac arrest, trauma, stroke), clear escalation procedures, and systematic approaches to resource allocation and cleanup. Similarly, our container runtime needs protocols for different failure types (namespace creation, resource exhaustion, network setup), clear error propagation paths, and systematic cleanup procedures that prevent resource leaks even when multiple components fail simultaneously.</p>\n<p>The complexity arises because container creation involves a precise sequence of operations that create kernel resources (namespaces, cgroups, network interfaces) and establish process relationships. Unlike simple application failures that can be handled with basic exception handling, container failures often occur in privileged kernel operations with partial state changes that must be carefully unwound. A failure during network namespace creation might leave a veth interface orphaned on the host, while a failure during mount namespace setup might leave filesystems mounted that prevent proper cleanup.</p>\n<p>Our error handling strategy follows three core principles: <strong>early detection</strong> to catch problems before they cascade, <strong>graceful degradation</strong> to maintain system stability when individual components fail, and <strong>complete cleanup</strong> to ensure no kernel resources leak even during complex failure scenarios. Each component must track its own resources and provide cleanup functions, while the overall container system coordinates cleanup order and error propagation.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fcontainer-lifecycle-states.svg\" alt=\"Container Lifecycle State Machine\"></p>\n<h3 id=\"namespace-creation-failures\">Namespace Creation Failures</h3>\n<p>Namespace creation represents one of the most common failure points in container runtime operation because it depends on kernel features, system privileges, and resource availability that may not be guaranteed. Understanding and handling these failures properly is essential for building a robust container system that can operate reliably across different environments and configurations.</p>\n<p><strong>Mental Model: Apartment Building Permits</strong>: Think of namespace creation like obtaining permits to build different sections of an apartment building. You need separate permits for plumbing (network namespace), electrical (PID namespace), and structural changes (mount namespace). If the city denies any permit due to zoning restrictions (kernel features disabled), insufficient fees (privilege levels), or resource limits (too many existing permits), you can&#39;t proceed with that portion of construction. However, you need to handle the permit denial gracefully and clean up any permits you&#39;ve already obtained.</p>\n<p>The most frequent namespace creation failure is <strong>insufficient privileges</strong>. Creating namespaces typically requires either root privileges or specific capabilities like <code>CAP_SYS_ADMIN</code>. When running without sufficient privileges, the <code>clone()</code> or <code>unshare()</code> system calls fail with <code>EPERM</code>, indicating permission denied. This failure mode is particularly challenging because it often occurs after some setup has already completed, requiring careful cleanup of partial state.</p>\n<p><strong>Kernel feature unavailability</strong> represents another critical failure mode. Not all Linux kernels are compiled with namespace support enabled, and some container execution environments deliberately disable certain namespace types for security reasons. The <code>clone()</code> call may fail with <code>EINVAL</code> when attempting to create unsupported namespace types, or with <code>ENOSYS</code> if the kernel lacks namespace support entirely.</p>\n<blockquote>\n<p><strong>Decision: Graceful Namespace Degradation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Some environments may support only a subset of namespaces (e.g., PID but not network), requiring decisions about partial container functionality</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Fail completely if any namespace creation fails</li>\n<li>Allow containers to run with reduced isolation</li>\n<li>Make namespace types configurable with fallback behavior</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Fail completely for core namespaces (PID, mount) but allow optional degradation for network namespaces</li>\n<li><strong>Rationale</strong>: PID and mount isolation are fundamental to container security, while network isolation can be provided by external tools in some deployment scenarios</li>\n<li><strong>Consequences</strong>: Ensures minimum security guarantees while allowing deployment flexibility in constrained environments</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Error Code</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Insufficient privileges</td>\n<td>EPERM</td>\n<td>Check return value from clone/unshare</td>\n<td>Log clear error message, suggest running as root or with capabilities</td>\n</tr>\n<tr>\n<td>Kernel feature disabled</td>\n<td>EINVAL</td>\n<td>Attempt namespace creation, check errno</td>\n<td>Check /proc/sys/kernel for namespace support, provide feature-specific error</td>\n</tr>\n<tr>\n<td>Resource exhaustion</td>\n<td>ENOMEM</td>\n<td>Memory allocation failure during clone</td>\n<td>Free existing allocations, reduce memory requirements, retry with backoff</td>\n</tr>\n<tr>\n<td>Process limit reached</td>\n<td>EAGAIN</td>\n<td>Clone fails due to process limits</td>\n<td>Wait for processes to exit, check ulimits, suggest increasing limits</td>\n</tr>\n<tr>\n<td>Namespace limit exceeded</td>\n<td>ENOSPC</td>\n<td>System namespace limit reached</td>\n<td>Clean up unused namespaces, suggest system-level tuning</td>\n</tr>\n</tbody></table>\n<p>The <strong>namespace creation error handling function</strong> must distinguish between recoverable and non-recoverable failures. Privilege failures typically require user intervention (running with sudo or setting capabilities), while resource exhaustion might be temporary and allow for retry strategies. The error handling logic should provide actionable error messages that help operators understand both the immediate cause and potential solutions.</p>\n<p><strong>Resource exhaustion during namespace creation</strong> can manifest in several ways. Memory exhaustion (<code>ENOMEM</code>) during the <code>clone()</code> call indicates the kernel cannot allocate internal data structures for the new namespace. This often occurs in memory-constrained environments or when creating many containers rapidly. The recovery strategy involves releasing any allocated resources and potentially implementing exponential backoff for retry attempts.</p>\n<p><strong>Process limit exhaustion</strong> (<code>EAGAIN</code>) occurs when the system or user process limits prevent creating new processes via <code>clone()</code>. This is distinct from namespace limits themselves - the system may support creating namespaces but refuse to create the process that would inhabit them. Recovery requires checking both system-wide process limits (<code>/proc/sys/kernel/pid_max</code>) and user limits (<code>ulimit -u</code>).</p>\n<p>The <strong>namespace handle cleanup</strong> process becomes critical when creation fails partway through establishing multiple namespaces. Since namespace creation often involves creating PID, mount, and network namespaces in sequence, a failure during network namespace creation requires cleaning up the successfully created PID and mount namespaces. Each namespace file descriptor in the <code>namespace_fds</code> array of the <code>container_instance_t</code> structure must be closed properly to release kernel resources.</p>\n<blockquote>\n<p>The fundamental principle for namespace creation error handling is <strong>atomic semantics</strong> - either all required namespaces are successfully created, or none are left in a partial state that could cause resource leaks or security vulnerabilities.</p>\n</blockquote>\n<p><strong>Timing-dependent failures</strong> represent a subtle category of namespace creation issues. Creating multiple namespaces in sequence can encounter race conditions where kernel resources become unavailable between namespace creation calls. For example, the system might successfully create a PID namespace but fail to create the network namespace due to resource exhaustion that occurred after the PID namespace consumed memory. These failures require careful ordering and resource validation before beginning the namespace creation sequence.</p>\n<p>The <strong>error propagation mechanism</strong> must handle failures that occur in the child process after <code>clone()</code> successfully creates the process but before the child can complete its namespace setup. Since the child runs in a separate process, it cannot directly return error codes to the parent. Instead, it must use the parent-child synchronization pipes defined in <code>container_sync_t</code> to communicate setup failures back to the parent process for proper cleanup coordination.</p>\n<p>⚠️ <strong>Pitfall: Partial Namespace Cleanup</strong>\nMany implementations fail to properly clean up namespaces when creation fails partway through the sequence. For example, if PID and mount namespaces are created successfully but network namespace creation fails, the PID and mount namespace file descriptors must be closed to release kernel resources. Forgetting this cleanup can lead to namespace handle leaks that persist until the parent process exits. Always iterate through the <code>namespace_fds</code> array and close any valid file descriptors (non-negative values) during error cleanup.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Kernel Version Dependencies</strong>\nDifferent Linux kernel versions support different namespace types and have varying resource limits. Attempting to create user namespaces on kernels older than 3.8 or network namespaces without proper kernel configuration will fail in non-obvious ways. Always check kernel version compatibility and provide clear error messages that indicate minimum kernel requirements when namespace creation fails with <code>EINVAL</code> or <code>ENOSYS</code>.</p>\n<h3 id=\"resource-exhaustion\">Resource Exhaustion</h3>\n<p>Resource exhaustion scenarios represent some of the most complex failure modes in container systems because they can occur at any point during container lifecycle and often involve kernel-level enforcement mechanisms that terminate processes without warning. Unlike application-level resource limits that can be checked programmatically, kernel resource limits like memory exhaustion invoke the OOM killer, which terminates processes based on heuristics rather than application priorities.</p>\n<p><strong>Mental Model: City Utility Management</strong>: Think of resource exhaustion like a city managing utilities during peak demand. When electricity demand exceeds generation capacity, the city doesn&#39;t politely ask residents to reduce usage - it implements rolling blackouts based on priority zones. Similarly, when container memory usage exceeds cgroup limits, the kernel doesn&#39;t negotiate - it invokes the OOM killer to terminate processes based on kernel heuristics, not application priorities. The container runtime must be prepared for sudden process termination and have cleanup mechanisms that work even when primary processes are killed unexpectedly.</p>\n<p><strong>Memory exhaustion and OOM conditions</strong> represent the most dramatic form of resource exhaustion because they result in immediate process termination rather than graceful degradation. When a container exceeds its memory limit configured through the memory cgroup controller, the kernel&#39;s OOM killer selects processes within that cgroup for termination. The selection algorithm considers factors like memory usage, process age, and OOM adjustment scores, but the container runtime has limited control over which processes are terminated first.</p>\n<p>The <strong>OOM killer behavior</strong> varies significantly between cgroups v1 and v2, affecting how container processes experience memory pressure. In cgroups v1, the OOM killer typically terminates the highest memory-consuming process within the cgroup when the limit is exceeded. In cgroups v2, the kernel implements more sophisticated memory pressure handling with early warning signals before reaching hard limits. Container runtimes must handle both scenarios and provide appropriate monitoring and recovery mechanisms.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Exhaustion Trigger</th>\n<th>Kernel Response</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory</td>\n<td>Usage exceeds cgroup limit</td>\n<td>OOM killer terminates processes</td>\n<td>Process exit status 137 (SIGKILL)</td>\n<td>Monitor memory pressure, implement graceful restart</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>Usage exceeds quota</td>\n<td>Process throttling</td>\n<td>Increased execution time</td>\n<td>Monitor throttling statistics, adjust limits</td>\n</tr>\n<tr>\n<td>Process count</td>\n<td>Forks exceed pids limit</td>\n<td>fork() fails with EAGAIN</td>\n<td>Failed process creation</td>\n<td>Monitor process count, clean up zombie processes</td>\n</tr>\n<tr>\n<td>File descriptors</td>\n<td>Open files exceed limit</td>\n<td>open() fails with EMFILE</td>\n<td>File operation failures</td>\n<td>Close unused descriptors, increase limits</td>\n</tr>\n<tr>\n<td>Network bandwidth</td>\n<td>Traffic exceeds shaping rules</td>\n<td>Packet dropping/queuing</td>\n<td>Network performance degradation</td>\n<td>Implement traffic prioritization</td>\n</tr>\n</tbody></table>\n<p><strong>CPU throttling</strong> provides a more graceful form of resource exhaustion where the kernel doesn&#39;t terminate processes but instead restricts their execution time. When a container exceeds its CPU quota within the configured period, the kernel throttles the processes by putting them to sleep until the next scheduling period begins. This throttling is transparent to the application but manifests as increased execution time for CPU-bound operations.</p>\n<p>The <strong>CPU controller statistics</strong> available through the cgroup filesystem provide detailed information about throttling events, including the number of times processes were throttled and the total time spent in throttled state. Container runtimes should monitor these statistics to detect CPU pressure and potentially adjust limits or provide warnings about application performance degradation.</p>\n<p><strong>Process limit exhaustion</strong> occurs when containers attempt to create more processes or threads than allowed by the pids controller. Unlike memory exhaustion which terminates existing processes, process limit exhaustion prevents new process creation while leaving existing processes running normally. The <code>fork()</code>, <code>clone()</code>, and <code>pthread_create()</code> operations fail with <code>EAGAIN</code>, allowing applications to handle the failure gracefully if they implement appropriate error checking.</p>\n<blockquote>\n<p>The key insight for process limit handling is that applications must be designed to handle process creation failures gracefully, unlike memory exhaustion where process termination is unavoidable and must be handled through external monitoring and restart mechanisms.</p>\n</blockquote>\n<p><strong>File descriptor exhaustion</strong> can occur both at the process level (hitting the per-process <code>RLIMIT_NOFILE</code> limit) and at the system level (hitting the global file descriptor limit). Container applications that open many files, sockets, or pipes without proper cleanup can quickly exhaust available file descriptors. The failure manifests as <code>EMFILE</code> (too many open files) or <code>ENFILE</code> (file table overflow) errors from system calls like <code>open()</code>, <code>socket()</code>, or <code>pipe()</code>.</p>\n<p><strong>Network resource exhaustion</strong> primarily manifests through bandwidth limits imposed by traffic control mechanisms rather than hard cgroup limits. When containers exceed configured network bandwidth limits, the kernel may drop packets, increase latency through queuing, or apply traffic shaping rules that degrade network performance. Unlike CPU or memory limits, network exhaustion rarely causes immediate application failure but instead degrades performance gradually.</p>\n<p>The <strong>memory pressure monitoring</strong> mechanism provides early warning before OOM killer activation through cgroup event notifications. The memory controller exposes pressure events through the <code>memory.pressure_level</code> interface in cgroups v1 and through pressure stall information in cgroups v2. Container runtimes can register for these notifications to implement proactive memory management, such as requesting applications to free caches or triggering graceful container shutdown before hitting hard limits.</p>\n<p><strong>Resource exhaustion recovery strategies</strong> must consider the cascading effects of resource limits across multiple containers sharing the same host system. When one container exhausts memory and triggers OOM killer activity, other containers may experience performance degradation due to increased system memory pressure. The recovery mechanism should monitor system-wide resource pressure in addition to per-container limits.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Memory Pressure Warnings</strong>\nMany container implementations only detect memory problems when the OOM killer activates, but cgroups provide earlier warning signals through memory pressure notifications. Ignoring these warnings means missing opportunities for graceful degradation, such as reducing cache sizes or checkpointing application state. Monitor the <code>memory.pressure_level</code> events and implement proactive memory management rather than reactive OOM handling.</p>\n<p>⚠️ <strong>Pitfall: Misunderstanding CPU Throttling Effects</strong>\nCPU throttling doesn&#39;t just slow down the main application - it affects all processes in the cgroup, including monitoring agents, log collectors, and health check scripts. This can create cascading failures where health checks timeout due to throttling, causing orchestration systems to restart healthy containers unnecessarily. Account for monitoring overhead when setting CPU limits and consider excluding critical monitoring processes from throttled cgroups.</p>\n<p>⚠️ <strong>Pitfall: Process Limit Bypass Through Threading</strong>\nThe pids controller counts threads as processes, but applications might attempt to bypass process limits by using thread pools or async I/O instead of forking processes. However, thread creation can still fail when hitting the pids limit, causing subtle application failures that manifest as hanging requests or degraded performance rather than obvious process creation errors. Test applications under process pressure to ensure they handle threading failures appropriately.</p>\n<h3 id=\"cleanup-failures\">Cleanup Failures</h3>\n<p>Cleanup failures represent one of the most insidious categories of container runtime errors because they often go unnoticed until they accumulate into system-wide problems. Unlike startup failures that immediately signal problems through failed container launches, cleanup failures manifest as gradual resource leaks, orphaned kernel objects, and eventual system instability. The challenge is compounded by the fact that cleanup operations often occur during error conditions when the system is already in a degraded state.</p>\n<p><strong>Mental Model: Restaurant Closing Procedures</strong>: Think of cleanup failures like a restaurant that doesn&#39;t properly close each night. If the staff forgets to turn off equipment, clean tables, or secure the building, small problems accumulate over time. A few unwashed dishes become a pest problem; unlocked doors become security issues; equipment left running becomes fire hazards. Similarly, cleanup failures in containers start small - a forgotten veth interface, an unclosed namespace file descriptor, an abandoned cgroup directory - but accumulate into system-wide resource exhaustion, kernel object leaks, and eventually system instability requiring reboot to resolve.</p>\n<p><strong>Partial cleanup scenarios</strong> occur when some cleanup operations succeed while others fail, leaving the system in an inconsistent state. For example, a container might successfully remove its cgroup directory but fail to delete the veth interface due to network configuration errors. The container appears to have cleaned up from the cgroup perspective, but network resources remain allocated, potentially causing IP address conflicts or interface name collisions for future containers.</p>\n<p>The <strong>cleanup ordering dependencies</strong> create complex failure scenarios where the sequence of cleanup operations affects success rates. Network interfaces must be removed before closing network namespace file descriptors; mount points must be unmounted before removing mount namespaces; processes must be terminated before removing cgroups. When cleanup operations fail, subsequent operations in the sequence may also fail due to dependency violations.</p>\n<table>\n<thead>\n<tr>\n<th>Cleanup Component</th>\n<th>Dependencies</th>\n<th>Failure Modes</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process termination</td>\n<td>Must complete before cgroup removal</td>\n<td>Process refuses to die, zombie accumulation</td>\n<td>SIGTERM → wait → SIGKILL → force cleanup</td>\n</tr>\n<tr>\n<td>Network interfaces</td>\n<td>Must remove before closing network namespace</td>\n<td>Interface busy, namespace unreachable</td>\n<td>Force interface down, use different namespace</td>\n</tr>\n<tr>\n<td>Mount points</td>\n<td>Must unmount before namespace cleanup</td>\n<td>Filesystem busy, permission denied</td>\n<td>Lazy unmount (MNT_DETACH), force unmount</td>\n</tr>\n<tr>\n<td>Cgroup directories</td>\n<td>Processes must exit first</td>\n<td>Directory not empty, permission denied</td>\n<td>Kill remaining processes, recursive removal</td>\n</tr>\n<tr>\n<td>Namespace file descriptors</td>\n<td>Close after removing associated resources</td>\n<td>File descriptor corruption</td>\n<td>Force close, accept potential leaks</td>\n</tr>\n</tbody></table>\n<p><strong>Cgroup cleanup failures</strong> frequently occur because cgroup directories cannot be removed while they still contain processes, even zombie processes awaiting reaping. The kernel enforces this restriction to maintain accounting accuracy, but it creates complex cleanup scenarios when container processes don&#39;t exit cleanly. A single zombie process can prevent cgroup cleanup, leading to accumulating cgroup directories that consume kernel memory and eventually hit system limits.</p>\n<p>The <strong>hierarchical cleanup strategy</strong> addresses these dependencies by implementing cleanup in reverse dependency order: terminate processes first, then remove cgroups, then clean up namespaces, then remove network interfaces. However, each step can fail independently, requiring the cleanup system to continue with subsequent steps even when earlier steps fail partially.</p>\n<p><strong>Mount point cleanup failures</strong> occur when filesystems remain busy due to open file descriptors, running processes, or active bind mounts. The <code>umount()</code> system call fails with <code>EBUSY</code>, leaving mount points active and preventing proper mount namespace cleanup. The recovery strategy involves using <code>MNT_DETACH</code> for lazy unmounting, which removes the mount point from the namespace view immediately but defers actual filesystem cleanup until all references are released.</p>\n<blockquote>\n<p><strong>Decision: Cleanup Continuation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: When cleanup operations fail, the system must decide whether to abort cleanup entirely or continue with remaining operations</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Stop cleanup on first failure to maintain consistency</li>\n<li>Continue cleanup despite failures to release maximum resources</li>\n<li>Implement retry mechanisms with exponential backoff</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Continue cleanup despite failures, with comprehensive error logging and retry for specific failure types</li>\n<li><strong>Rationale</strong>: Resource leaks cause cumulative system degradation, so releasing as many resources as possible is preferable to maintaining perfect consistency</li>\n<li><strong>Consequences</strong>: Requires careful error aggregation and reporting to surface cleanup issues without stopping resource recovery</li>\n</ul>\n</blockquote>\n<p><strong>Network cleanup failures</strong> often involve orphaned veth interfaces that remain on the host side even after the container network namespace is destroyed. When network namespace destruction fails or is incomplete, the host-side veth interface may persist without its paired container interface, creating a dangling interface that consumes network namespace slots and may cause naming conflicts for future containers.</p>\n<p>The <strong>cleanup function registration mechanism</strong> using the <code>cleanup_list_t</code> structure provides a systematic approach to ensure all allocated resources are released even when cleanup operations fail. Each component registers its cleanup functions during resource allocation, creating a comprehensive list of cleanup operations that execute in reverse order during container destruction. This pattern ensures that cleanup attempts occur for all resources, even if individual cleanup functions encounter failures.</p>\n<p><strong>Error aggregation during cleanup</strong> requires collecting multiple error conditions and presenting them coherently to operators. Since cleanup continues despite individual failures, the final cleanup result may include errors from multiple components. The error reporting mechanism must distinguish between failures that indicate resource leaks (requiring operator attention) and failures that are purely informational (such as attempting to remove already-removed resources).</p>\n<p><strong>Timeout-based cleanup</strong> addresses scenarios where cleanup operations hang indefinitely due to kernel deadlocks, filesystem issues, or network problems. Each cleanup operation should have reasonable timeouts to prevent container destruction from hanging indefinitely. When timeouts occur, the cleanup system must decide whether to escalate to more aggressive cleanup methods (such as force-killing processes) or accept resource leaks to maintain system stability.</p>\n<p>⚠️ <strong>Pitfall: Cleanup Function Exception Safety</strong>\nCleanup functions themselves can fail and must not throw exceptions or abort the cleanup process. A common mistake is writing cleanup functions that assume resources are in a valid state, causing cleanup failures when those resources were already partially destroyed. Always check resource validity before attempting cleanup operations and handle cases where resources may already be released by other cleanup paths.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Cleanup Ordering</strong>\nAttempting to remove cgroups before terminating processes or closing namespace file descriptors before unmounting filesystems will cause cleanup failures that could be avoided with proper ordering. These failures often appear intermittent because they depend on timing between process termination and cleanup execution. Implement explicit dependency tracking between cleanup operations and ensure proper ordering even under race conditions.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Error Context in Cleanup</strong>\nCleanup failures often occur in degraded system states where normal debugging information isn&#39;t available. Cleanup error messages must include sufficient context to diagnose problems without access to the original container configuration or process state. Log the specific resource being cleaned (PID, interface name, cgroup path) and the exact error condition, not just generic &quot;cleanup failed&quot; messages that provide no actionable information.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires robust error detection, classification, and recovery mechanisms that coordinate across all container components. The implementation focuses on early failure detection, comprehensive error reporting, and systematic cleanup that prevents resource leaks even during cascading failures.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Approach</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Classification</td>\n<td>Structured error codes</td>\n<td>container_error_t enum with specific failure types</td>\n</tr>\n<tr>\n<td>Error Context</td>\n<td>Detailed error information</td>\n<td>Error structures with component, operation, and system error details</td>\n</tr>\n<tr>\n<td>Cleanup Management</td>\n<td>Resource tracking</td>\n<td>cleanup_list_t with function pointers for systematic resource cleanup</td>\n</tr>\n<tr>\n<td>Timeout Handling</td>\n<td>Non-blocking cleanup</td>\n<td>Timer-based cleanup with escalation to force operations</td>\n</tr>\n<tr>\n<td>Error Aggregation</td>\n<td>Multiple error collection</td>\n<td>Error arrays that collect failures from multiple cleanup operations</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n  src/\n    error/\n      error_types.h          ← Error codes and classification\n      error_handlers.c       ← Error handling and recovery functions\n      cleanup.h              ← Cleanup list management interface\n      cleanup.c              ← Cleanup function registration and execution\n    container/\n      container_errors.h     ← Container-specific error handling\n      container_errors.c     ← Container error coordination and propagation\n    namespace/\n      namespace_errors.c     ← Namespace creation failure handling\n    cgroups/\n      cgroups_errors.c       ← Resource exhaustion detection and handling\n    network/\n      network_errors.c       ← Network setup failure handling\n  tests/\n    error_scenarios/         ← Error injection and recovery testing</code></pre></div>\n\n<p><strong>Error Classification Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete error type enumeration for container operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_NONE </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_VALIDATION,</span><span style=\"color:#6A737D\">     // Configuration validation failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_NAMESPACES,</span><span style=\"color:#6A737D\">     // Namespace creation failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_MOUNT,</span><span style=\"color:#6A737D\">          // Mount operations failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_NETWORK,</span><span style=\"color:#6A737D\">        // Network setup failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_CGROUPS,</span><span style=\"color:#6A737D\">        // Cgroup setup failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_OOM,</span><span style=\"color:#6A737D\">            // Out of memory condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_PRIVILEGES,</span><span style=\"color:#6A737D\">     // Insufficient permissions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_KERNEL_FEATURE,</span><span style=\"color:#6A737D\"> // Kernel feature unavailable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_RESOURCE_LIMIT,</span><span style=\"color:#6A737D\"> // System resource limit hit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_CLEANUP,</span><span style=\"color:#6A737D\">        // Cleanup operation failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CONTAINER_ERROR_TIMEOUT</span><span style=\"color:#6A737D\">         // Operation timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_error_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Detailed error context for debugging and recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> container_error_context {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_error_t</span><span style=\"color:#E1E4E8\"> type;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> component;</span><span style=\"color:#6A737D\">      // Which component failed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> operation;</span><span style=\"color:#6A737D\">      // What operation was being performed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> system_errno;</span><span style=\"color:#6A737D\">          // System error code if applicable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> details;</span><span style=\"color:#6A737D\">       // Human-readable error description</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> recovery_attempted;</span><span style=\"color:#6A737D\">    // Whether recovery was attempted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_error_context_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error context creation and management</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">container_error_context_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\"> create_error_context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_error_t</span><span style=\"color:#FFAB70\"> type</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                               const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> component</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                               const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> operation</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate error context structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize fields with provided parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Capture current errno value for system_errno field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Generate human-readable error message for details field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return initialized context structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Error classification from system errno values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">container_error_t</span><span style=\"color:#B392F0\"> classify_namespace_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> errno_val</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check for permission errors (EPERM) → CONTAINER_ERROR_PRIVILEGES</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for feature errors (EINVAL, ENOSYS) → CONTAINER_ERROR_KERNEL_FEATURE  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for resource errors (ENOMEM, EAGAIN) → CONTAINER_ERROR_RESOURCE_LIMIT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for validation errors (EINVAL with bad params) → CONTAINER_ERROR_VALIDATION</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return CONTAINER_ERROR_NAMESPACES for other namespace-related errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cleanup List Management Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup function pointer type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">cleanup_function_t</span><span style=\"color:#E1E4E8\">)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> data);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup list node for systematic resource management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> cleanup_list {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cleanup_function_t</span><span style=\"color:#E1E4E8\"> cleanup_func;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> data;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#E1E4E8\"> description;</span><span style=\"color:#6A737D\">    // For debugging cleanup failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> cleanup_list</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Register cleanup function for resource that needs cleanup on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">cleanup_function_t</span><span style=\"color:#FFAB70\"> func</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> description</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Allocate new cleanup list node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize node with function pointer and data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set description for debugging cleanup failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add node to front of cleanup list for LIFO execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update list head pointer to new node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute all cleanup functions in reverse registration order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> execute_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">cleanup_list_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Iterate through cleanup list from head to tail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call each cleanup function with its associated data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Log cleanup function description and any errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Continue cleanup even if individual functions fail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Free cleanup list nodes and set list pointer to NULL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return count of failed cleanup operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup functions for specific resource types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_namespace_fd</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> fd_ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Cast void pointer to int pointer for file descriptor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if file descriptor value is valid (>= 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Close file descriptor and check for errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set file descriptor to -1 to mark as cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log cleanup completion or failure for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_cgroup_path</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> path_ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Cast void pointer to char pointer for cgroup path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify cgroup path exists before attempting removal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove cgroup directory using rmdir system call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle ENOENT (already removed) as success condition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log cgroup cleanup result with path information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cleanup_network_interface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> if_name_ptr</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Cast void pointer to char pointer for interface name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if interface exists in current namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove interface using netlink socket or ip command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle interface already removed as success condition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log interface cleanup result with interface name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Resource Exhaustion Detection:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Monitor memory pressure in container cgroup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> check_memory_pressure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> pressure_level</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Construct path to memory.pressure_level file in cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Open pressure level file for reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read current pressure level value (0=low, 1=medium, 2=critical)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Close file and handle any read errors appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set pressure_level output parameter and return success status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Monitor CPU throttling statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> check_cpu_throttling</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">long*</span><span style=\"color:#FFAB70\"> throttled_time</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Construct path to cpu.stat file in cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Open and read cpu statistics file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse throttled_time field from statistics output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate throttling rate since last check</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return throttling statistics through output parameter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Check for OOM killer activity in container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> detect_oom_condition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int*</span><span style=\"color:#FFAB70\"> oom_occurred</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check exit status of container process for signal 137 (SIGKILL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read memory.oom_control file to check for OOM events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse kernel log messages for OOM killer activity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Correlate OOM events with container PID and cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set oom_occurred flag and return detection status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Comprehensive Error Handling Coordination:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Main container error handling function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> handle_container_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                          container_error_context_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Log detailed error context with component and operation info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Classify error severity (fatal vs recoverable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute component-specific error handling based on error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute cleanup list to release partial resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update container state to ERROR and preserve error context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return appropriate error code for caller handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Propagate errors from child process to parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> propagate_child_error</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> child_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> child_status</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if child exited normally or was terminated by signal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract exit code or signal number from child status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read error information from child through sync pipes if available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Classify child error into appropriate container_error_t type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create error context with child failure details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return classified error for parent process handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After implementing error handling for each milestone, verify the following behaviors:</p>\n<p><strong>Milestone 1 (PID Namespace) Error Handling:</strong></p>\n<ul>\n<li>Run container creation without root privileges - should fail with clear privilege error message rather than cryptic system error</li>\n<li>Create containers rapidly to trigger process limit exhaustion - should detect EAGAIN and provide actionable error message</li>\n<li>Verify zombie processes are reaped even when container init process encounters errors during startup</li>\n</ul>\n<p><strong>Milestone 2 (Mount Namespace) Error Handling:</strong></p>\n<ul>\n<li>Attempt container creation with non-existent rootfs path - should fail during validation with clear error about missing directory</li>\n<li>Fill up filesystem to trigger mount failures - should detect ENOSPC and clean up partial mount points</li>\n<li>Test pivot_root failure scenarios by using rootfs on read-only filesystem - should restore original mount state</li>\n</ul>\n<p><strong>Milestone 3 (Network Namespace) Error Handling:</strong></p>\n<ul>\n<li>Create containers when veth creation fails due to interface name conflicts - should generate unique interface names or fail with specific naming error</li>\n<li>Test network setup when bridge doesn&#39;t exist - should provide clear error about bridge configuration rather than generic network error</li>\n<li>Verify network cleanup removes orphaned veth interfaces even when namespace destruction fails</li>\n</ul>\n<p><strong>Milestone 4 (Cgroups) Error Handling:</strong></p>\n<ul>\n<li>Set memory limit higher than system RAM to test validation - should reject invalid configuration before attempting container creation</li>\n<li>Trigger OOM conditions by setting very low memory limits - should detect OOM through process exit status and provide clear OOM error indication</li>\n<li>Test cgroup cleanup when processes refuse to terminate - should escalate to SIGKILL and continue cleanup despite process cleanup failures</li>\n</ul>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides testing approaches for all milestones (1-4), establishing verification methods for PID namespace isolation, mount namespace filesystem separation, network namespace connectivity, and cgroups resource enforcement.</p>\n</blockquote>\n<p>Testing a container runtime presents unique challenges because the system fundamentally alters the execution environment through kernel namespaces and resource controls. Unlike traditional application testing where functions operate in a predictable environment, container testing must verify that isolation mechanisms actually work—that processes cannot escape their boundaries, that resource limits are enforced, and that cleanup properly removes all traces of container execution.</p>\n<h3 id=\"mental-model-laboratory-safety-testing\">Mental Model: Laboratory Safety Testing</h3>\n<p>Think of container testing like verifying laboratory safety protocols. Just as a biosafety lab must prove its containment works—that dangerous specimens cannot escape their isolation chambers, that air filtration systems prevent contamination, and that emergency procedures properly decontaminate equipment—container testing must demonstrate that process isolation holds under stress, resource limits prevent one container from starving others, and cleanup procedures leave no dangerous residue.</p>\n<p>The testing approach mirrors laboratory verification: isolation tests ensure boundaries hold, resource limit tests verify controls work under pressure, and cleanup tests confirm complete decontamination. Each test must run in a controlled environment where we can safely create &quot;dangerous&quot; conditions (resource exhaustion, malicious processes) and verify they remain contained.</p>\n<h3 id=\"isolation-verification-tests\">Isolation Verification Tests</h3>\n<p>Isolation verification tests form the foundation of container testing because they validate the core security and reliability promises of containerization. These tests must prove that namespaces create genuine boundaries that malicious or buggy processes cannot breach.</p>\n<p>The <strong>PID namespace isolation test</strong> verifies that process trees remain completely separate between host and container. The test creates a container process that spawns multiple child processes with known behavior patterns, then verifies from the host that the container&#39;s PID assignments follow namespace rules. Inside the container, the init process should appear as PID 1, with child processes receiving sequential PIDs starting from 2. Simultaneously, the host should see the container processes using entirely different PID values from its own namespace.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Container View</th>\n<th>Host View</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container init process</td>\n<td>PID 1</td>\n<td>Real PID assigned by host</td>\n<td>Read <code>/proc/self/stat</code> inside container vs external <code>ps</code> output</td>\n</tr>\n<tr>\n<td>Container child process</td>\n<td>PID 2, 3, 4...</td>\n<td>Different real PIDs</td>\n<td>Compare <code>/proc</code> entries inside vs outside namespace</td>\n</tr>\n<tr>\n<td>Process visibility</td>\n<td>Only container processes visible</td>\n<td>Container processes visible with real PIDs</td>\n<td>Check <code>/proc</code> directory listings</td>\n</tr>\n<tr>\n<td>Kill signal isolation</td>\n<td>Cannot signal host processes</td>\n<td>Host can signal container processes</td>\n<td>Attempt cross-namespace kill operations</td>\n</tr>\n</tbody></table>\n<p>The test implementation involves creating a container that runs a test program which forks several processes, each writing their perceived PID to shared storage. Simultaneously, the host monitors the actual PIDs assigned to these processes. The test succeeds only if the container processes consistently report PIDs 1, 2, 3... while the host observes different values, and if attempts to signal non-existent PIDs from within the container fail appropriately.</p>\n<p><strong>Mount namespace isolation testing</strong> verifies that filesystem operations within the container cannot affect the host filesystem and that the container sees only its intended filesystem view. The test creates a container with a custom root filesystem, performs various mount operations inside the container, then verifies these changes remain invisible to the host.</p>\n<p>The test procedure involves setting up a temporary directory structure as the container root, mounting it into a mount namespace, then performing operations that would be dangerous if they escaped the namespace: creating device nodes, mounting additional filesystems, and modifying system directories. After each operation, the test verifies that the host filesystem remains unchanged and that the container&#39;s view reflects only intended modifications.</p>\n<table>\n<thead>\n<tr>\n<th>Mount Operation</th>\n<th>Container Result</th>\n<th>Host Verification</th>\n<th>Failure Indicator</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Create device node</td>\n<td>Device appears in container <code>/dev</code></td>\n<td>Host <code>/dev</code> unchanged</td>\n<td>New device visible on host</td>\n</tr>\n<tr>\n<td>Mount tmpfs on <code>/tmp</code></td>\n<td>Container sees empty <code>/tmp</code></td>\n<td>Host <code>/tmp</code> unchanged</td>\n<td>Host <code>/tmp</code> becomes tmpfs</td>\n</tr>\n<tr>\n<td>Bind mount host directory</td>\n<td>Directory visible in container</td>\n<td>Original host path unchanged</td>\n<td>Unexpected mount in host namespace</td>\n</tr>\n<tr>\n<td>Unmount <code>/proc</code></td>\n<td>Container loses <code>/proc</code></td>\n<td>Host <code>/proc</code> still functional</td>\n<td>Host loses <code>/proc</code> access</td>\n</tr>\n</tbody></table>\n<p><strong>Network namespace isolation testing</strong> demonstrates that container networking operates independently from host networking while maintaining intended connectivity paths. The test creates multiple containers with isolated network namespaces, configures networking between them, then verifies that network traffic follows only the intended paths.</p>\n<p>The test establishes a baseline by creating containers with different IP addresses in the same subnet, connected through a bridge. Each container runs a simple network service listening on a known port. The test then verifies that containers can communicate with each other through the bridge but cannot access host network services unless explicitly configured, and that host network interfaces remain unaffected by container network operations.</p>\n<p>Network isolation verification requires testing both positive connectivity (intended paths work) and negative isolation (unintended paths are blocked). The test suite includes scenarios where containers attempt to bind to privileged ports, access host network interfaces, and communicate with external networks both with and without proper routing configuration.</p>\n<table>\n<thead>\n<tr>\n<th>Network Test</th>\n<th>Expected Behavior</th>\n<th>Isolation Verification</th>\n<th>Failure Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container-to-container</td>\n<td>Communication succeeds via bridge</td>\n<td>Traffic uses veth pairs only</td>\n<td>Direct host interface access</td>\n</tr>\n<tr>\n<td>Container-to-host</td>\n<td>Blocked unless explicitly allowed</td>\n<td>Host services remain inaccessible</td>\n<td>Container bypasses network namespace</td>\n</tr>\n<tr>\n<td>Host-to-container</td>\n<td>Succeeds via configured routes</td>\n<td>Container IP only reachable via bridge</td>\n<td>Container IP visible on host interface</td>\n</tr>\n<tr>\n<td>External connectivity</td>\n<td>Requires NAT configuration</td>\n<td>Container uses host gateway correctly</td>\n<td>Container accesses external networks directly</td>\n</tr>\n</tbody></table>\n<p>The comprehensive isolation test suite runs all namespace types simultaneously to verify they don&#39;t interfere with each other. A multi-namespace test creates a container with PID, mount, and network isolation, then performs operations that would breach multiple boundaries if isolation failed. This test ensures that combining namespaces maintains the security properties of each individual namespace type.</p>\n<h3 id=\"resource-limit-testing\">Resource Limit Testing</h3>\n<p>Resource limit testing verifies that cgroups successfully prevent containers from consuming more resources than allocated and that resource exhaustion triggers appropriate system responses rather than affecting the broader system. These tests must safely create resource pressure situations and verify that limits hold under stress.</p>\n<p><strong>Memory limit enforcement testing</strong> involves creating containers with specific memory limits, then running processes that attempt to exceed those limits. The test must verify that the Out of Memory (OOM) killer activates when containers exceed their memory allocation and that the OOM behavior only affects processes within the container&#39;s cgroup.</p>\n<p>The memory test creates a container with a modest memory limit (e.g., 64MB), then runs a program inside the container that allocates memory in steadily increasing chunks. The test monitors both the container&#39;s memory usage statistics through cgroup files and system behavior when the limit is reached. Successful enforcement means the container process receives a SIGKILL when it exceeds its limit, while host processes and other containers continue operating normally.</p>\n<table>\n<thead>\n<tr>\n<th>Memory Scenario</th>\n<th>Container Behavior</th>\n<th>Cgroup Response</th>\n<th>System Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Within limit</td>\n<td>Process continues normally</td>\n<td>Usage tracked accurately</td>\n<td>No system impact</td>\n</tr>\n<tr>\n<td>Approaching limit</td>\n<td>Process continues, memory pressure increases</td>\n<td>Memory pressure indicators triggered</td>\n<td>Other containers unaffected</td>\n</tr>\n<tr>\n<td>Exceeding limit</td>\n<td>Process receives SIGKILL from OOM killer</td>\n<td>Memory usage drops to zero</td>\n<td>Host memory remains available</td>\n</tr>\n<tr>\n<td>Rapid allocation</td>\n<td>Allocation fails with ENOMEM</td>\n<td>Usage never exceeds limit</td>\n<td>System stability maintained</td>\n</tr>\n</tbody></table>\n<p>The test implementation requires careful monitoring of multiple data sources: the container process exit status to detect OOM kills, cgroup memory statistics to track usage patterns, and system memory state to ensure the host remains stable. The test must distinguish between normal process termination and OOM killing, which requires checking both the exit signal and cgroup event notifications.</p>\n<p><strong>CPU limit enforcement testing</strong> verifies that CPU quota and period settings effectively constrain container CPU usage over time. Unlike memory limits which create immediate binary responses, CPU limits require statistical verification over time periods to confirm that average CPU usage respects configured quotas.</p>\n<p>The CPU test creates a container with a specific CPU limit (e.g., 50% of one CPU core) and runs CPU-intensive processes designed to consume 100% CPU if unlimited. The test measures actual CPU consumption over multiple time periods and verifies that the average consumption converges on the configured limit despite the container processes attempting to use more CPU time.</p>\n<p>CPU limit testing requires longer observation periods because the kernel&#39;s Completely Fair Scheduler (CFS) enforces CPU quotas over scheduling periods rather than instantaneously. The test must run for multiple scheduling periods (typically 100ms each) and calculate average CPU usage across periods to distinguish between temporary bursts and actual limit enforcement.</p>\n<table>\n<thead>\n<tr>\n<th>CPU Test Duration</th>\n<th>Expected CPU Usage</th>\n<th>Measurement Method</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single period (100ms)</td>\n<td>May exceed limit temporarily</td>\n<td>Read cgroup CPU statistics</td>\n<td>Cannot evaluate limit effectiveness</td>\n</tr>\n<tr>\n<td>10 periods (1 second)</td>\n<td>Approaching configured limit</td>\n<td>Average usage over period</td>\n<td>Within 10% of configured limit</td>\n</tr>\n<tr>\n<td>100 periods (10 seconds)</td>\n<td>Converged on limit</td>\n<td>Statistical average</td>\n<td>Within 5% of configured limit</td>\n</tr>\n<tr>\n<td>Extended run (60 seconds)</td>\n<td>Stable at limit</td>\n<td>Long-term average</td>\n<td>Within 2% of configured limit</td>\n</tr>\n</tbody></table>\n<p><strong>Process limit enforcement testing</strong> verifies that containers cannot create more processes or threads than their configured limit allows. This test protects against fork bombs and other process exhaustion attacks that could destabilize the host system.</p>\n<p>The process limit test creates a container with a low process limit (e.g., 10 processes) and runs a program that continuously forks new processes. The test verifies that fork operations fail with appropriate error codes once the limit is reached and that the container cannot exceed its process allocation regardless of the forking strategy employed.</p>\n<p>Process limit testing must account for different process creation methods: traditional fork(), clone() with various flags, and pthread creation. Each method counts against the process limit differently, and the test must verify that all creation methods respect the cgroup process controller limits.</p>\n<p>The test monitors process creation through multiple mechanisms: direct counting of processes in the container&#39;s cgroup tasks file, monitoring fork() return values within the container, and observing system-wide process counts to ensure container processes don&#39;t escape the limit through namespace manipulation.</p>\n<p><strong>Resource pressure and recovery testing</strong> verifies that containers respond appropriately to sustained resource pressure and can recover when resource usage returns to normal levels. These tests simulate realistic workload patterns where resource usage fluctuates over time.</p>\n<p>The pressure test creates scenarios where containers approach but don&#39;t exceed their resource limits repeatedly, verifying that the system handles pressure situations gracefully without triggering unnecessary kills or throttling. This testing reveals whether cgroup controllers implement smooth pressure responses or exhibit unstable threshold behavior.</p>\n<p>Recovery testing complements pressure testing by verifying that containers can return to normal operation after experiencing resource pressure. The test creates containers that temporarily hit resource limits, then reduces their resource usage and verifies that performance returns to normal levels without requiring container restart.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Milestone checkpoints provide concrete verification steps that learners can execute after implementing each component to confirm their implementation works correctly before proceeding to the next milestone. These checkpoints include both automated tests and manual verification procedures.</p>\n<p><strong>Milestone 1 (PID Namespace) Checkpoint</strong> focuses on verifying that process isolation works correctly and that the container init process handles its responsibilities properly. The checkpoint includes tests for namespace creation, PID assignment verification, and zombie process reaping.</p>\n<p>The primary PID namespace verification involves running a test program inside the container that reports its PID and parent PID, while simultaneously observing these processes from the host namespace. The test succeeds when the container process reports PID 1 (indicating it&#39;s running as init in the namespace) while the host sees a different, higher PID value for the same process.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Command/Procedure</th>\n<th>Expected Output</th>\n<th>Troubleshooting</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container init PID</td>\n<td>Run <code>echo $$</code> inside container</td>\n<td>Output shows <code>1</code></td>\n<td>Check clone() flags include CLONE_NEWPID</td>\n</tr>\n<tr>\n<td>Host view of container</td>\n<td>`ps aux</td>\n<td>grep container-process`</td>\n<td>Shows different PID than 1</td>\n</tr>\n<tr>\n<td>Process tree isolation</td>\n<td><code>ps aux</code> inside container</td>\n<td>Shows only container processes</td>\n<td>Check mount namespace includes fresh /proc</td>\n</tr>\n<tr>\n<td>Zombie reaping</td>\n<td>Create child process, exit parent</td>\n<td>No zombie processes remain</td>\n<td>Implement SIGCHLD handler in init process</td>\n</tr>\n</tbody></table>\n<p>The zombie reaping test requires creating a container that spawns child processes, allowing some children to exit before their parents, then verifying that zombie processes are properly reaped. This test confirms that the container init process correctly implements PID 1 responsibilities for zombie collection.</p>\n<p><strong>Milestone 2 (Mount Namespace) Checkpoint</strong> verifies that filesystem isolation prevents container operations from affecting the host filesystem and that essential filesystems are properly mounted within the container.</p>\n<p>The mount namespace verification creates a container with a temporary root filesystem, performs filesystem operations that would be problematic if they affected the host, then confirms that the host filesystem remains unchanged while the container has access to necessary filesystem features.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Test Operation</th>\n<th>Container View</th>\n<th>Host View</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Root filesystem isolation</td>\n<td>Create file in container root</td>\n<td>File visible in container</td>\n<td>File not visible in host root</td>\n</tr>\n<tr>\n<td>/proc filesystem</td>\n<td><code>cat /proc/version</code></td>\n<td>Shows kernel version</td>\n<td>Container /proc independent of host</td>\n</tr>\n<tr>\n<td>Device node creation</td>\n<td><code>mknod /dev/test c 1 1</code></td>\n<td>Device appears in container</td>\n<td>Host /dev unchanged</td>\n</tr>\n<tr>\n<td>Mount propagation</td>\n<td>Mount tmpfs in container</td>\n<td>Container sees new mount</td>\n<td>Host mounts unchanged</td>\n</tr>\n</tbody></table>\n<p>The piviot_root verification requires special attention because this operation permanently changes the container&#39;s filesystem view. The test must verify that the container cannot access the original host filesystem after pivot_root completes while maintaining access to essential filesystems like <code>/proc</code> and <code>/sys</code>.</p>\n<p><strong>Milestone 3 (Network Namespace) Checkpoint</strong> confirms that network isolation works correctly and that container networking provides both isolation and connectivity as intended. The verification includes testing network interface isolation, veth pair connectivity, and bridge networking configuration.</p>\n<p>Network namespace verification requires creating multiple containers and testing connectivity patterns between them and between containers and the host. The test must confirm that network traffic follows intended paths and cannot bypass isolation mechanisms.</p>\n<table>\n<thead>\n<tr>\n<th>Network Test</th>\n<th>Setup</th>\n<th>Verification Command</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Interface isolation</td>\n<td>Create container with network namespace</td>\n<td><code>ip link show</code> in container</td>\n<td>Shows only loopback + veth interface</td>\n</tr>\n<tr>\n<td>Container-to-container</td>\n<td>Two containers on same bridge</td>\n<td><code>ping</code> from container A to container B</td>\n<td>Ping succeeds with low latency</td>\n</tr>\n<tr>\n<td>Host-to-container</td>\n<td>Container with bridge networking</td>\n<td><code>ping</code> from host to container IP</td>\n<td>Ping succeeds if routing configured</td>\n</tr>\n<tr>\n<td>External connectivity</td>\n<td>Container with NAT configured</td>\n<td><code>ping 8.8.8.8</code> from container</td>\n<td>Ping succeeds through host gateway</td>\n</tr>\n</tbody></table>\n<p>The veth pair verification requires inspecting both ends of the virtual ethernet connection to confirm that packets sent from the container veth interface appear on the host bridge interface and vice versa. This test confirms that the veth pair is correctly configured and assigned to the appropriate namespaces.</p>\n<p><strong>Milestone 4 (Cgroups) Checkpoint</strong> verifies that resource limits are properly enforced and that containers cannot exceed their allocated resource quotas. The verification includes testing memory limits, CPU limits, and process limits under controlled stress conditions.</p>\n<p>Cgroups verification requires creating resource pressure situations and monitoring both cgroup statistics and container behavior to confirm that limits are enforced. The test must distinguish between proper limit enforcement and system instability.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Limit</th>\n<th>Test Procedure</th>\n<th>Monitoring</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory limit</td>\n<td>Run memory allocator in container</td>\n<td>Watch <code>memory.usage_in_bytes</code></td>\n<td>Process killed before exceeding limit</td>\n</tr>\n<tr>\n<td>CPU limit</td>\n<td>Run CPU burner with 50% limit</td>\n<td>Monitor <code>cpuacct.usage</code> over time</td>\n<td>Average CPU usage converges to 50%</td>\n</tr>\n<tr>\n<td>Process limit</td>\n<td>Fork bomb with 10 process limit</td>\n<td>Count entries in <code>tasks</code> file</td>\n<td>Process count never exceeds 10</td>\n</tr>\n<tr>\n<td>Cgroup cleanup</td>\n<td>Stop container and check cleanup</td>\n<td>Verify cgroup directory removed</td>\n<td>No leaked cgroup hierarchies</td>\n</tr>\n</tbody></table>\n<p>The cgroup enforcement verification must account for kernel scheduler behavior and measurement timing. CPU limits, in particular, require statistical measurement over multiple scheduling periods to distinguish between temporary bursts and actual limit violations.</p>\n<p><strong>End-to-End Integration Checkpoint</strong> combines all four milestones to verify that the complete container system works correctly when all isolation and resource control mechanisms operate simultaneously. This comprehensive test creates containers that exercise PID namespaces, mount namespaces, network namespaces, and cgroups together.</p>\n<p>The integration test creates multiple containers with different configurations (varying resource limits, network configurations, and filesystem layouts) and runs workloads that stress multiple isolation mechanisms simultaneously. The test verifies that combining all isolation mechanisms maintains the security and performance properties of each individual mechanism.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Scenario</th>\n<th>Test Workload</th>\n<th>Verification Points</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multi-container isolation</td>\n<td>CPU and memory intensive tasks</td>\n<td>All namespaces maintain isolation</td>\n<td>No cross-container interference</td>\n</tr>\n<tr>\n<td>Resource competition</td>\n<td>Containers with different limits compete for resources</td>\n<td>Each container respects its limits</td>\n<td>Resource allocation follows cgroup limits</td>\n</tr>\n<tr>\n<td>Network and filesystem</td>\n<td>Containers sharing bridge network with isolated filesystems</td>\n<td>Network works, filesystems isolated</td>\n<td>Connectivity preserved, filesystem isolation maintained</td>\n</tr>\n<tr>\n<td>Cleanup verification</td>\n<td>Create and destroy multiple containers</td>\n<td>System returns to baseline state</td>\n<td>No leaked namespaces, cgroups, or network interfaces</td>\n</tr>\n</tbody></table>\n<p>The integration checkpoint serves as a final verification that the container implementation provides robust isolation and resource control suitable for running untrusted workloads safely on a shared system.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing infrastructure for a container runtime requires specialized tools and techniques because standard testing frameworks don&#39;t naturally handle namespace isolation and resource control verification. The testing system must create isolated environments, inject controlled failures, and measure system behavior across namespace boundaries.</p>\n<p><strong>Technology Recommendations for Testing Infrastructure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Testing Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Standard language test framework (e.g., C with assert macros)</td>\n<td>Custom test harness with namespace support</td>\n</tr>\n<tr>\n<td>Process Monitoring</td>\n<td>Parse /proc filesystem directly</td>\n<td>Use netlink sockets for real-time process events</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Read cgroup files periodically</td>\n<td>Use cgroup event notification APIs</td>\n</tr>\n<tr>\n<td>Network Testing</td>\n<td>Simple ping/nc connectivity tests</td>\n<td>Custom packet injection and monitoring</td>\n</tr>\n<tr>\n<td>Cleanup Verification</td>\n<td>Manual filesystem/process inspection</td>\n<td>Automated resource leak detection</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Test File Structure:</strong></p>\n<p>The testing infrastructure should be organized to support both component-level tests for individual namespace types and integration tests that verify the complete container system:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n  tests/\n    unit/                           ← Component-specific tests\n      test_pid_namespace.c          ← PID namespace isolation tests\n      test_mount_namespace.c        ← Mount namespace filesystem tests  \n      test_network_namespace.c      ← Network namespace connectivity tests\n      test_cgroups.c               ← Resource limit enforcement tests\n    integration/                    ← End-to-end system tests\n      test_container_lifecycle.c    ← Full container creation/destruction\n      test_multi_container.c        ← Multiple containers interaction\n      test_resource_competition.c   ← Resource limit interaction\n    fixtures/                       ← Test data and helper programs\n      test_programs/               ← Programs to run inside test containers\n        cpu_burner.c               ← CPU-intensive workload\n        memory_allocator.c         ← Memory allocation test program\n        fork_bomb.c                ← Process limit test program\n        network_client.c           ← Network connectivity test client\n        network_server.c           ← Network service for connectivity tests\n      rootfs/                      ← Minimal root filesystem for container tests\n        bin/                       ← Basic utilities (busybox)\n        dev/                       ← Device nodes\n        proc/                      ← Mount point for /proc\n        sys/                       ← Mount point for /sys\n    helpers/                       ← Testing infrastructure code\n      test_framework.h             ← Common test macros and utilities\n      namespace_helpers.c          ← Functions for namespace verification\n      cgroup_helpers.c             ← Functions for cgroup monitoring\n      network_helpers.c            ← Functions for network setup/verification\n  Makefile                        ← Build system including test targets</code></pre></div>\n\n<p><strong>Test Framework Infrastructure Code:</strong></p>\n<p>The test framework provides utilities for creating test containers, monitoring their behavior, and cleaning up resources. This infrastructure handles the complexity of coordinating tests across namespace boundaries:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test_framework.h - Common testing utilities for container verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#ifndef</span><span style=\"color:#B392F0\"> TEST_FRAMEWORK_H</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> TEST_FRAMEWORK_H</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test container configuration for creating isolated test environments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> test_name;</span><span style=\"color:#6A737D\">                 // Human-readable test identifier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> rootfs_path;</span><span style=\"color:#6A737D\">              // Path to test root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> memory_limit_bytes;</span><span style=\"color:#6A737D\">      // Memory limit for test container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cpu_percent;</span><span style=\"color:#6A737D\">                // CPU limit percentage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> max_processes;</span><span style=\"color:#6A737D\">              // Process limit for fork bomb protection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> enable_network;</span><span style=\"color:#6A737D\">             // Whether to set up network namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> cleanup_on_exit;</span><span style=\"color:#6A737D\">            // Whether to clean up resources automatically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">test_container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test verification result with detailed failure information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> success;</span><span style=\"color:#6A737D\">                    // Overall test success/failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> failure_reason;</span><span style=\"color:#6A737D\">           // Human-readable failure description</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> expected_value;</span><span style=\"color:#6A737D\">             // Expected test value for comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> actual_value;</span><span style=\"color:#6A737D\">               // Actual measured value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> verification_details;</span><span style=\"color:#6A737D\">     // Additional verification information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">test_result_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test cleanup tracking for resource leak prevention</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> test_cleanup_item {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">cleanup_func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\"> data);</span><span style=\"color:#6A737D\"> // Function to call for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> cleanup_data;</span><span style=\"color:#6A737D\">              // Data to pass to cleanup function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char*</span><span style=\"color:#E1E4E8\"> description;</span><span style=\"color:#6A737D\">               // Human-readable cleanup description</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> test_cleanup_item</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> next;</span><span style=\"color:#6A737D\">  // Next cleanup item in list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">test_cleanup_item_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Creates test container with specified configuration and returns PID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#B392F0\"> create_test_container</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">test_container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verifies that PID namespace isolation works correctly</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">test_result_t</span><span style=\"color:#B392F0\"> verify_pid_isolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verifies that mount namespace provides filesystem isolation  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">test_result_t</span><span style=\"color:#B392F0\"> verify_mount_isolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> test_file</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verifies that network namespace isolates network stack</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">test_result_t</span><span style=\"color:#B392F0\"> verify_network_isolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Verifies that cgroup limits are properly enforced</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">test_result_t</span><span style=\"color:#B392F0\"> verify_resource_limits</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">test_container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Registers cleanup function to be called on test completion or failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> register_test_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">test_cleanup_item_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">func)(</span><span style=\"color:#F97583\">void*</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#F97583\">void*</span><span style=\"color:#FFAB70\"> data</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> desc</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Executes all registered cleanup functions in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> execute_test_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">test_cleanup_item_t</span><span style=\"color:#F97583\">**</span><span style=\"color:#FFAB70\"> list</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test assertion macros with detailed failure reporting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT_EQ</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> ((expected) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> (actual)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">Expected: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, Actual: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                   __FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, message, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(expected), (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)(actual)); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> ASSERT_TRUE</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    do</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">(condition)) { </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"FAIL: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">Condition failed: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                   __FILE__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">__LINE__</span><span style=\"color:#E1E4E8\">, message, #condition); </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">while</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Implement test container creation with all namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Add test result reporting and aggregation across test suites  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Add automatic cleanup registration for namespace and cgroup resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TODO: Add timeout handling for tests that may hang due to isolation issues</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#endif</span></span></code></pre></div>\n\n<p><strong>Core Test Logic Skeleton Code:</strong></p>\n<p>The core testing logic provides template functions that learners complete to verify each type of isolation. These skeletons map directly to the verification procedures described in the design sections:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Test PID namespace isolation by verifying process ID assignment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> test_pid_namespace_isolation</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    test_cleanup_item_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create test container configuration with PID namespace enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create container using create_test_container()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Register cleanup for container process termination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Inside container: read PID from /proc/self/stat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: From host: read actual PID of container process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify container sees PID 1, host sees different PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Test process tree isolation by checking /proc entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify zombie reaping by creating child processes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    execute_test_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cleanup_list);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - learner implements actual verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test mount namespace isolation by verifying filesystem separation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> test_mount_namespace_isolation</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    test_cleanup_item_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> test_file_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create test root filesystem with basic directory structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create container with mount namespace and test rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Inside container: create test file in root directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: From host: verify test file not visible in host filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Inside container: mount /proc and verify it works independently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: From host: verify host /proc unchanged by container operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Test device node creation inside container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify container device nodes don't appear on host</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    execute_test_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cleanup_list);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - learner implements filesystem verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test network namespace isolation and connectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> test_network_namespace_isolation</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    test_cleanup_item_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create container with network namespace enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up veth pair connecting container to host bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Inside container: verify only veth and loopback interfaces visible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test container-to-host connectivity through veth pair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create second container and test inter-container communication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify containers cannot access each other's network namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Test external connectivity through host NAT</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Cleanup veth pairs and network namespaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    execute_test_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cleanup_list);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - learner implements network verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test cgroup resource limit enforcement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> test_cgroup_resource_limits</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    test_cleanup_item_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cleanup_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create container with memory limit (64MB) and CPU limit (50%)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start memory allocation test program inside container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Monitor memory usage through cgroup memory.usage_in_bytes file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify OOM killer activates when limit exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start CPU-intensive test program inside container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Monitor CPU usage over multiple scheduling periods (10+ seconds)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify average CPU usage converges to configured 50% limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Test process limit by running fork bomb with low process limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    execute_test_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cleanup_list);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // Placeholder - learner implements resource limit verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Testing Hints:</strong></p>\n<ul>\n<li>Use <code>nsenter</code> command-line tool for manual verification of namespace isolation during development</li>\n<li>Monitor <code>/proc/PID/ns/</code> directory to see namespace assignments for debugging</li>\n<li>Read cgroup files in <code>/sys/fs/cgroup/</code> to verify resource usage and limits</li>\n<li>Use <code>ip netns exec</code> to run commands inside network namespaces for verification</li>\n<li>Check <code>/proc/PID/status</code> for memory usage details when testing memory limits</li>\n<li>Monitor <code>/sys/fs/cgroup/cpuacct/*/cpuacct.stat</code> for CPU usage statistics over time</li>\n</ul>\n<p><strong>Milestone Checkpoint Commands:</strong></p>\n<p>After implementing each milestone, learners can verify their implementation using these specific commands and expected outputs:</p>\n<p><strong>Milestone 1 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run PID namespace test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_pid_namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_pid_namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Container init process reports PID 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Host sees different PID for container process  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Process tree isolation verified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Zombie reaping test completed successfully</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run mount namespace test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> test_mount_namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./test_mount_namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Container filesystem isolated from host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: /proc filesystem mounted independently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Device node creation contained within namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Mount propagation properly configured</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run network namespace test (requires root privileges)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> make</span><span style=\"color:#9ECBFF\"> test_network_namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_network_namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Network namespace created successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Veth pair configured and assigned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Container-to-host connectivity verified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Network interface isolation confirmed</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Build and run cgroup resource limit test (requires root privileges)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> make</span><span style=\"color:#9ECBFF\"> test_cgroups</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_cgroups</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Memory limit enforced - OOM killer activated at 64MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: CPU limit enforced - average usage 49.8% over 10 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Process limit enforced - fork() failed after 10 processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Cgroup cleanup completed successfully</span></span></code></pre></div>\n\n<p><strong>Integration Test Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run complete integration test suite</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> make</span><span style=\"color:#9ECBFF\"> test_integration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./test_integration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Multi-container isolation test completed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Resource competition test - all limits respected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: Network and filesystem isolation maintained</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># PASS: System cleanup verification - no resource leaks detected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Integration test summary: 24/24 tests passed</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section applies to all milestones (1-4), providing debugging strategies for PID namespace isolation issues, mount namespace filesystem problems, network namespace connectivity failures, and cgroups resource limit enforcement problems.</p>\n</blockquote>\n<p>Building a container runtime involves coordinating multiple complex Linux kernel mechanisms, each with their own failure modes and subtle interactions. The debugging process requires understanding both the symptoms visible at the application level and the underlying kernel state that drives those behaviors. This section provides a systematic approach to diagnosing and fixing the most common issues encountered when implementing namespace isolation and resource control.</p>\n<p><strong>Mental Model: Detective Investigation</strong>: Think of debugging containers like being a detective investigating a crime scene. The &quot;crime&quot; is your container not working as expected, and you need to gather evidence from multiple sources - the process tree, filesystem mounts, network interfaces, and cgroup statistics. Each piece of evidence points to potential causes, and by correlating information from different sources, you can identify the root cause and determine the fix. Just as a detective follows a methodical process of evidence collection and analysis, container debugging requires systematic inspection of kernel state through various interfaces.</p>\n<p>The debugging process follows a consistent pattern: identify the symptom, gather evidence from kernel interfaces, correlate findings to isolate the root cause, and apply targeted fixes. The key insight is that container problems often manifest as secondary symptoms - a networking issue might actually be caused by namespace creation timing, or a filesystem problem might stem from incorrect mount propagation settings.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdebugging-inspection-points.svg\" alt=\"Container Debugging Inspection Points\"></p>\n<h3 id=\"namespace-issues\">Namespace Issues</h3>\n<p>Namespace-related problems are among the most challenging to debug because they involve invisible boundaries that separate processes from system resources. The fundamental difficulty is that namespace isolation creates different views of the same underlying system, making it essential to understand which namespace context you&#39;re examining when gathering diagnostic information.</p>\n<h4 id=\"pid-namespace-debugging\">PID Namespace Debugging</h4>\n<p>PID namespace issues typically manifest as processes appearing with incorrect process IDs, zombie processes accumulating without being reaped, or signals not reaching their intended targets. These problems often stem from fundamental misunderstandings about how PID translation works across namespace boundaries.</p>\n<p><strong>Symptom Analysis and Diagnosis</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container process shows wrong PID from inside</td>\n<td>PID namespace not created properly</td>\n<td>Check <code>/proc/self/ns/pid</code> in container vs host</td>\n<td>Verify <code>CLONE_NEWPID</code> flag in <code>safe_clone()</code></td>\n</tr>\n<tr>\n<td>Child process not visible as PID 1</td>\n<td>Process started before namespace creation</td>\n<td>Use <code>lsns -t pid</code> to verify namespace membership</td>\n<td>Ensure clone() creates namespace before exec</td>\n</tr>\n<tr>\n<td>Zombie processes accumulate</td>\n<td>Init process not reaping children</td>\n<td>Check <code>/proc/1/stat</code> for zombie count in container</td>\n<td>Implement <code>SIGCHLD</code> handler in <code>container_init_process()</code></td>\n</tr>\n<tr>\n<td>Signals fail to reach container processes</td>\n<td>Wrong PID used for kill()</td>\n<td>Compare PIDs inside vs outside namespace</td>\n<td>Use namespace-local PIDs for internal signaling</td>\n</tr>\n<tr>\n<td>Container startup hangs</td>\n<td>Clone() failed but error not propagated</td>\n<td>Check parent-child pipe communication</td>\n<td>Implement proper error reporting in child process</td>\n</tr>\n</tbody></table>\n<p>The most common PID namespace issue occurs when developers assume that process IDs remain consistent across namespace boundaries. In reality, the same process has different PIDs depending on which namespace context observes it. The container init process appears as PID 1 within its namespace but has a different PID when viewed from the host namespace.</p>\n<blockquote>\n<p><strong>Key Insight: PID Translation Boundaries</strong>: Every system call that takes a PID as an argument operates within the caller&#39;s PID namespace context. This means <code>kill(pid, signal)</code> called from the host uses host PIDs, while the same call from inside the container uses container PIDs. Cross-namespace process management requires careful tracking of which PID applies in which context.</p>\n</blockquote>\n<p><strong>Debugging PID Namespace Creation</strong>:</p>\n<p>The <code>create_pid_namespace()</code> function creates isolation through the clone() system call, but several subtle issues can prevent proper namespace establishment:</p>\n<ol>\n<li><p><strong>Stack Direction Problems</strong>: The clone() system call requires a properly allocated stack that grows in the correct direction. On most architectures, stacks grow downward, so the stack pointer must point to the high end of the allocated memory region. Incorrect stack setup causes immediate segmentation faults that may be difficult to trace.</p>\n</li>\n<li><p><strong>Clone Flag Ordering</strong>: The combination of namespace flags in <code>CONTAINER_NS_FLAGS</code> must include <code>CLONE_NEWPID</code>, but the order and combination with other flags can affect behavior. Some flag combinations are incompatible or require specific kernel versions.</p>\n</li>\n<li><p><strong>Capability Requirements</strong>: Creating PID namespaces requires the <code>CAP_SYS_ADMIN</code> capability. Without proper privileges, clone() fails with <code>EPERM</code>, but this error often gets lost in complex error handling paths.</p>\n</li>\n</ol>\n<p><strong>PID 1 Responsibilities and Zombie Reaping</strong>:</p>\n<p>Within a PID namespace, the first process (PID 1) inherits special responsibilities from the kernel. Unlike regular processes, PID 1 receives orphaned processes as children and must reap their exit status to prevent zombie accumulation. Failure to implement proper zombie reaping leads to resource exhaustion and eventual process creation failures.</p>\n<p>The <code>setup_init_signals()</code> function must establish a <code>SIGCHLD</code> handler that calls <code>waitpid()</code> in a loop to collect all available child exit statuses. A common mistake is handling only one child per signal delivery, since multiple children can terminate between signal deliveries, causing zombies to accumulate.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Zombie Reaping</strong>\nMany developers implement zombie reaping by calling <code>waitpid()</code> once per <code>SIGCHLD</code> signal. However, signals are not queued - if three children terminate while the signal handler is running, only one <code>SIGCHLD</code> is delivered. The correct approach is to loop with <code>waitpid(WNOHANG)</code> until it returns zero, ensuring all available zombies are reaped.</p>\n<h4 id=\"mount-namespace-debugging\">Mount Namespace Debugging</h4>\n<p>Mount namespace problems typically appear as containers seeing incorrect filesystem contents, failing to isolate mounts from the host, or encountering permission errors when accessing expected directories. These issues often trace back to mount propagation settings, pivot_root requirements, or timing problems in filesystem setup.</p>\n<p><strong>Mount Namespace Diagnostic Approach</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Issue Category</th>\n<th>Diagnostic Commands</th>\n<th>Key Files to Check</th>\n<th>Common Problems</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace Creation</td>\n<td><code>lsns -t mnt</code>, <code>/proc/PID/ns/mnt</code></td>\n<td><code>/proc/PID/mountinfo</code></td>\n<td>Mount namespace not created, shared with parent</td>\n</tr>\n<tr>\n<td>Mount Propagation</td>\n<td><code>findmnt -D</code></td>\n<td><code>/proc/self/mountinfo</code></td>\n<td>Shared propagation leaking to host</td>\n</tr>\n<tr>\n<td>Pivot Root</td>\n<td><code>ls -la /</code>, <code>mountpoint /</code></td>\n<td><code>/proc/mounts</code></td>\n<td>Old root not unmounted, pivot_root requirements</td>\n</tr>\n<tr>\n<td>Essential Filesystems</td>\n<td><code>ls /proc /sys /dev</code></td>\n<td><code>/proc/filesystems</code></td>\n<td>Missing /proc, /sys, incorrect permissions</td>\n</tr>\n</tbody></table>\n<p><strong>Mount Propagation Issues</strong>:</p>\n<p>Mount propagation determines how mount and unmount events propagate between namespaces. The default shared propagation causes container mounts to appear on the host, breaking isolation. The <code>setup_mount_propagation()</code> function must set mount points to private propagation before performing container-specific mounts.</p>\n<p>The sequence matters critically: propagation must be set to private before creating any bind mounts or mounting essential filesystems. If propagation remains shared, every mount operation inside the container becomes visible to the host system, potentially causing conflicts and security issues.</p>\n<p><strong>Pivot Root Complexities</strong>:</p>\n<p>The <code>pivot_to_container_root()</code> function implements one of the most error-prone operations in container setup. Pivot root has specific requirements that frequently cause failures:</p>\n<ol>\n<li><p><strong>Filesystem Requirements</strong>: Both the new root and old root must be mount points on different filesystems. If they&#39;re on the same filesystem, pivot_root fails with <code>EINVAL</code>.</p>\n</li>\n<li><p><strong>Directory Structure</strong>: The old root directory must exist within the new root filesystem before calling pivot_root. This creates a chicken-and-egg problem that requires careful ordering of mount operations.</p>\n</li>\n<li><p><strong>Process Working Directory</strong>: All processes must have working directories within the new root after pivot_root completes. Processes with working directories in the old root cause pivot_root to fail.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Pivot Root vs Chroot</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to change container&#39;s root filesystem while maintaining proper isolation</li>\n<li><strong>Options Considered</strong>: chroot(), pivot_root(), bind mount with chroot</li>\n<li><strong>Decision</strong>: Use pivot_root() for root filesystem switching</li>\n<li><strong>Rationale</strong>: Unlike chroot(), pivot_root() actually changes the filesystem root at the kernel level and works properly with mount namespaces. Chroot is a per-process view change that can be escaped, while pivot_root provides genuine filesystem root isolation.</li>\n<li><strong>Consequences</strong>: More complex setup procedure but stronger security guarantees and proper integration with mount namespaces.</li>\n</ul>\n</blockquote>\n<h4 id=\"network-namespace-debugging\">Network Namespace Debugging</h4>\n<p>Network namespace problems manifest as containers having no network connectivity, failing to reach external hosts, or being unable to communicate with other containers. These issues typically stem from veth pair configuration problems, incorrect bridge setup, or missing routing configuration.</p>\n<p><strong>Network Namespace Diagnostic Strategy</strong>:</p>\n<p>The key to diagnosing network namespace issues is understanding that each namespace has its own complete network stack, including interfaces, routing tables, and netfilter rules. Problems often occur when configuration changes are applied in the wrong namespace context.</p>\n<table>\n<thead>\n<tr>\n<th>Network Component</th>\n<th>Host Diagnostic</th>\n<th>Container Diagnostic</th>\n<th>Common Issues</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace Creation</td>\n<td><code>lsns -t net</code>, <code>ip netns list</code></td>\n<td><code>/proc/self/ns/net</code></td>\n<td>Namespace not created, process in wrong namespace</td>\n</tr>\n<tr>\n<td>Interface Configuration</td>\n<td><code>ip link show</code>, <code>brctl show</code></td>\n<td><code>ip addr show</code>, <code>ip route show</code></td>\n<td>Veth pair not created, interfaces in wrong namespace</td>\n</tr>\n<tr>\n<td>Routing</td>\n<td><code>ip route show</code>, <code>iptables -t nat -L</code></td>\n<td><code>ip route show</code>, <code>ping 8.8.8.8</code></td>\n<td>Missing default route, no NAT rules</td>\n</tr>\n<tr>\n<td>Bridge Connectivity</td>\n<td><code>bridge link show</code>, <code>tcpdump -i bridge</code></td>\n<td><code>ping container_ip</code></td>\n<td>Interface not attached to bridge, bridge not forwarding</td>\n</tr>\n</tbody></table>\n<p><strong>Veth Pair Configuration Problems</strong>:</p>\n<p>The <code>create_veth_pair()</code> and <code>assign_veth_to_namespace()</code> functions must coordinate to create a virtual ethernet pair with one end in the host and one end in the container namespace. Common failures include:</p>\n<ol>\n<li><p><strong>Interface Naming Conflicts</strong>: If the chosen interface names already exist, veth creation fails. The system doesn&#39;t automatically generate unique names, so the container runtime must implement its own naming strategy.</p>\n</li>\n<li><p><strong>Namespace Assignment Timing</strong>: The veth pair must be created before the target namespace can receive an interface. If the network namespace doesn&#39;t exist when <code>assign_veth_to_namespace()</code> runs, the operation fails silently in some kernel versions.</p>\n</li>\n<li><p><strong>Interface State Management</strong>: Both ends of the veth pair start in the DOWN state. The container end must be brought UP after IP configuration, while the host end must be brought UP before bridge attachment.</p>\n</li>\n</ol>\n<p><strong>Bridge and NAT Configuration</strong>:</p>\n<p>Container networking requires coordinating bridge configuration on the host with routing configuration inside containers. The <code>attach_to_bridge()</code> function connects the host veth end to a bridge, while <code>setup_default_route()</code> configures routing inside the container namespace.</p>\n<p>A frequent mistake is configuring NAT rules that don&#39;t match the bridge subnet or container IP assignments. The iptables NAT rules must be established before containers start, and they must correctly translate between the bridge subnet and external networks.</p>\n<p>⚠️ <strong>Pitfall: Namespace Context for Network Commands</strong>\nNetwork configuration commands like <code>ip addr add</code> and <code>ip route add</code> operate within the caller&#39;s network namespace. When configuring container networking from the host process, you must use <code>nsenter</code> or equivalent mechanisms to execute commands within the target namespace. Commands run in the wrong namespace context silently fail or configure the wrong network stack.</p>\n<h3 id=\"cgroups-issues\">Cgroups Issues</h3>\n<p>Cgroups problems typically manifest as resource limits not being enforced, containers consuming more resources than allocated, or the system becoming unresponsive due to resource exhaustion. These issues often stem from incorrect cgroup hierarchy setup, controller availability problems, or timing issues in process assignment.</p>\n<h4 id=\"cgroups-hierarchy-and-controller-issues\">Cgroups Hierarchy and Controller Issues</h4>\n<p>The Linux cgroups system has evolved through multiple versions, with cgroups v1 and cgroups v2 having different interfaces and capabilities. The <code>detect_cgroup_version()</code> function must correctly identify the system configuration, but many debugging issues arise from version mismatches or missing controller support.</p>\n<p><strong>Cgroups Diagnostic Framework</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Problem Category</th>\n<th>Diagnostic Commands</th>\n<th>Key Files</th>\n<th>Investigation Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Controller Availability</td>\n<td><code>cat /proc/cgroups</code>, <code>mount | grep cgroup</code></td>\n<td><code>/sys/fs/cgroup/</code>, <code>/proc/cgroups</code></td>\n<td>Which controllers are compiled and enabled</td>\n</tr>\n<tr>\n<td>Hierarchy Setup</td>\n<td><code>systemd-cgls</code>, <code>find /sys/fs/cgroup -name &quot;container-*&quot;</code></td>\n<td><code>/sys/fs/cgroup/*/container-*</code></td>\n<td>Cgroup directories exist, proper permissions</td>\n</tr>\n<tr>\n<td>Process Assignment</td>\n<td><code>cat /sys/fs/cgroup/*/container-*/cgroup.procs</code></td>\n<td><code>cgroup.procs</code>, <code>tasks</code></td>\n<td>PIDs correctly assigned to cgroup</td>\n</tr>\n<tr>\n<td>Limit Enforcement</td>\n<td><code>cat /sys/fs/cgroup/memory/container-*/memory.*</code></td>\n<td>Controller-specific stat files</td>\n<td>Current usage vs configured limits</td>\n</tr>\n</tbody></table>\n<p><strong>Controller Availability and Version Differences</strong>:</p>\n<p>The <code>verify_controller_available()</code> function checks whether specific cgroup controllers are enabled, but this check must account for both compile-time and runtime configuration. Controllers may be compiled into the kernel but disabled via kernel command-line parameters, or they may be available but not mounted in the expected location.</p>\n<p>Cgroups v1 and v2 have fundamentally different filesystem layouts and control interfaces. Version 1 uses separate hierarchies for each controller (memory, CPU, etc.), while version 2 uses a unified hierarchy where all controllers share the same directory structure. The container runtime must adapt its file paths and control interfaces based on the detected version.</p>\n<p><strong>Memory Controller Configuration and OOM Behavior</strong>:</p>\n<p>The <code>set_memory_limit()</code> function configures memory limits through the memory controller, but several subtle issues can prevent proper enforcement:</p>\n<ol>\n<li><p><strong>Limit Granularity</strong>: Memory limits are enforced in page-sized chunks, so very small limits may not behave as expected. The kernel rounds limits to page boundaries, potentially allowing slightly more memory than requested.</p>\n</li>\n<li><p><strong>OOM Killer Behavior</strong>: When a process in a memory-limited cgroup exceeds its allocation, the kernel&#39;s OOM killer terminates processes within that cgroup. However, the selection algorithm may not match application expectations, potentially killing important processes while leaving memory-hungry processes running.</p>\n</li>\n<li><p><strong>Memory Accounting Scope</strong>: The memory controller tracks different types of memory usage (anonymous pages, file cache, kernel memory) and applies limits differently to each category. Understanding which memory types count against the limit is crucial for predicting OOM behavior.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Memory Limit Enforcement Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to prevent containers from consuming excessive memory while allowing reasonable memory usage patterns</li>\n<li><strong>Options Considered</strong>: Hard limits with immediate OOM, soft limits with pressure notifications, hierarchical limits</li>\n<li><strong>Decision</strong>: Use hard limits with OOM killer enforcement for simplicity</li>\n<li><strong>Rationale</strong>: Hard limits provide predictable behavior and clear resource boundaries. While OOM killer termination is harsh, it prevents system-wide memory exhaustion and provides clear feedback about resource requirements.</li>\n<li><strong>Consequences</strong>: Applications must be designed to handle sudden termination, but system stability is preserved even with poorly behaved containers.</li>\n</ul>\n</blockquote>\n<p><strong>CPU Controller Quota and Period Configuration</strong>:</p>\n<p>The <code>set_cpu_limit()</code> function implements CPU limits through quota and period settings, but this mechanism has several non-obvious behaviors that can cause debugging confusion:</p>\n<ol>\n<li><p><strong>Quota vs Period Relationship</strong>: CPU limits are expressed as a quota (microseconds of CPU time) within a period (typically 100,000 microseconds). A 50% CPU limit means 50,000 microseconds of CPU time per 100,000-microsecond period, not necessarily 50% of one CPU core.</p>\n</li>\n<li><p><strong>Throttling vs Starvation</strong>: When a process group exceeds its CPU quota, the kernel throttles it by preventing scheduling until the next period begins. This creates bursty behavior where processes alternate between full-speed execution and complete blocking.</p>\n</li>\n<li><p><strong>Multi-core Behavior</strong>: CPU quotas apply to the entire cgroup, not per CPU core. A cgroup with a 150% CPU limit can use 1.5 cores worth of CPU time, distributed across available cores as the scheduler determines.</p>\n</li>\n</ol>\n<p><strong>Process Controller and Fork Bomb Prevention</strong>:</p>\n<p>The <code>set_process_limit()</code> function prevents fork bombs and resource exhaustion by limiting the number of processes and threads within a cgroup. However, the process controller has some subtle behaviors that affect debugging:</p>\n<ol>\n<li><p><strong>Task vs Process Counting</strong>: The process controller can limit either processes (traditional Unix processes) or tasks (which includes threads). The choice affects how multi-threaded applications behave when approaching limits.</p>\n</li>\n<li><p><strong>Limit Enforcement Timing</strong>: Process creation limits are enforced at fork() time, not exec() time. This means that processes can fork and then fail to exec, leaving zombie processes that count against the limit but consume no other resources.</p>\n</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Cgroups Cleanup Ordering</strong>\nWhen cleaning up container resources, cgroups must be removed after all processes within them have terminated. Attempting to remove a cgroup while it still contains processes fails with <code>EBUSY</code>. The correct cleanup sequence is: terminate processes, wait for exit, remove process from cgroup, then remove cgroup directory. Many container implementations fail because they don&#39;t wait for process termination before cgroup cleanup.</p>\n<h4 id=\"resource-limit-enforcement-debugging\">Resource Limit Enforcement Debugging</h4>\n<p>Resource limit debugging requires understanding both the configured limits and the actual enforcement mechanisms. The kernel provides extensive statistics through cgroup filesystem interfaces, but interpreting these statistics correctly requires knowledge of the underlying enforcement algorithms.</p>\n<p><strong>Memory Limit Enforcement Analysis</strong>:</p>\n<p>When containers appear to ignore memory limits, the issue usually lies in incorrect limit configuration or misunderstanding of memory accounting. The <code>read_cgroup_stat()</code> function can retrieve current usage statistics, but effective debugging requires understanding what memory usage is being measured.</p>\n<p>Key memory statistics for debugging include:</p>\n<ul>\n<li><code>memory.usage_in_bytes</code>: Total memory charged to the cgroup, including file cache</li>\n<li><code>memory.max_usage_in_bytes</code>: Peak memory usage since cgroup creation</li>\n<li><code>memory.failcnt</code>: Number of times memory allocation failed due to limit enforcement</li>\n<li><code>memory.oom_control</code>: OOM killer status and configuration</li>\n</ul>\n<p>The relationship between these statistics reveals whether limits are being enforced correctly. High failure counts with usage near the limit indicate working enforcement, while usage exceeding limits suggests configuration problems.</p>\n<p><strong>CPU Throttling Detection and Analysis</strong>:</p>\n<p>CPU limits work through a throttling mechanism that blocks process execution when quota is exhausted. The <code>check_cpu_throttling()</code> function examines CPU controller statistics to determine whether throttling is occurring and how severely it affects performance.</p>\n<p>Critical CPU statistics include:</p>\n<ul>\n<li><code>cpu.stat</code>: Contains <code>nr_periods</code>, <code>nr_throttled</code>, and <code>throttled_time</code> counters</li>\n<li><code>cpuacct.usage</code>: Total CPU time consumed by the cgroup</li>\n<li><code>cpu.cfs_quota_us</code> and <code>cpu.cfs_period_us</code>: Current quota configuration</li>\n</ul>\n<p>Throttling analysis involves calculating the percentage of periods where throttling occurred and the total time lost to throttling. High throttling percentages indicate that processes are consistently hitting CPU limits, while sporadic throttling suggests bursty workloads that occasionally exceed quotas.</p>\n<h3 id=\"debugging-tools-and-techniques\">Debugging Tools and Techniques</h3>\n<p>Effective container debugging requires mastering a set of specialized tools that provide visibility into kernel namespace and cgroup state. These tools operate at different levels of abstraction, from high-level namespace listings to detailed kernel state inspection.</p>\n<h4 id=\"essential-debugging-commands\">Essential Debugging Commands</h4>\n<p><strong>Namespace Inspection Tools</strong>:</p>\n<p>The <code>lsns</code> command provides the primary interface for examining namespace relationships and membership. It shows which processes belong to which namespaces and can reveal namespace isolation failures:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Purpose</th>\n<th>Key Information</th>\n<th>Usage Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>lsns -t pid</code></td>\n<td>List PID namespaces</td>\n<td>Namespace IDs, process counts</td>\n<td>Verify container has separate PID namespace</td>\n</tr>\n<tr>\n<td><code>lsns -t mnt</code></td>\n<td>List mount namespaces</td>\n<td>Mount namespace relationships</td>\n<td>Check filesystem isolation</td>\n</tr>\n<tr>\n<td><code>lsns -t net</code></td>\n<td>List network namespaces</td>\n<td>Network isolation boundaries</td>\n<td>Verify network separation</td>\n</tr>\n<tr>\n<td><code>lsns -p PID</code></td>\n<td>Show namespaces for process</td>\n<td>All namespace memberships</td>\n<td>Debug multi-namespace issues</td>\n</tr>\n</tbody></table>\n<p>The <code>/proc/PID/ns/</code> directory contains namespace file descriptors that can be used for advanced debugging. These files support comparison operations that reveal namespace relationships:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compare namespaces between processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/1/ns/</span><span style=\"color:#6A737D\">    # Host init process namespaces</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/PID/ns/</span><span style=\"color:#6A737D\">  # Container process namespaces</span></span></code></pre></div>\n\n<p><strong>Process Tree and PID Analysis</strong>:</p>\n<p>Understanding process relationships across PID namespace boundaries requires combining multiple information sources. The <code>ps</code> command shows different views depending on the namespace context from which it&#39;s run:</p>\n<table>\n<thead>\n<tr>\n<th>Context</th>\n<th>Command</th>\n<th>Information Revealed</th>\n<th>Debugging Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Host</td>\n<td><code>ps aux --forest</code></td>\n<td>Complete process tree with host PIDs</td>\n<td>Overall system state</td>\n</tr>\n<tr>\n<td>Host</td>\n<td><code>ps -eo pid,pidns,cmd</code></td>\n<td>PID namespace membership</td>\n<td>Which processes are isolated</td>\n</tr>\n<tr>\n<td>Container</td>\n<td><code>ps aux</code></td>\n<td>Container-local process tree</td>\n<td>Container internal view</td>\n</tr>\n<tr>\n<td>Container</td>\n<td><code>ps -eo pid,ppid,cmd</code></td>\n<td>Parent-child relationships</td>\n<td>Process hierarchy validation</td>\n</tr>\n</tbody></table>\n<p><strong>Mount and Filesystem Debugging</strong>:</p>\n<p>Mount namespace debugging relies heavily on <code>/proc/mounts</code> and <code>/proc/mountinfo</code>, which provide different levels of detail about filesystem mounts:</p>\n<ul>\n<li><code>/proc/mounts</code>: Shows active mounts with filesystem types and options</li>\n<li><code>/proc/mountinfo</code>: Includes mount relationships, propagation types, and namespace information</li>\n<li><code>/proc/PID/mountinfo</code>: Mount information from specific process&#39;s mount namespace</li>\n</ul>\n<p>The <code>findmnt</code> command provides a user-friendly interface to this information:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Output Format</th>\n<th>Debugging Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>findmnt -D</code></td>\n<td>Tree with propagation</td>\n<td>Mount relationships and propagation</td>\n</tr>\n<tr>\n<td><code>findmnt -J</code></td>\n<td>JSON format</td>\n<td>Programmatic analysis</td>\n</tr>\n<tr>\n<td><code>findmnt /path</code></td>\n<td>Specific mount point</td>\n<td>Verify mount configuration</td>\n</tr>\n</tbody></table>\n<p><strong>Network Namespace Inspection</strong>:</p>\n<p>Network debugging requires examining network state from both host and container perspectives. The <code>ip netns</code> command provides namespace management capabilities, while standard network tools work within namespace contexts:</p>\n<table>\n<thead>\n<tr>\n<th>Tool Category</th>\n<th>Host Commands</th>\n<th>Container Context Commands</th>\n<th>Information Gathered</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Interface Status</td>\n<td><code>ip link show</code>, <code>brctl show</code></td>\n<td><code>ip addr show</code>, <code>ip link show</code></td>\n<td>Interface configuration and state</td>\n</tr>\n<tr>\n<td>Routing</td>\n<td><code>ip route show table all</code></td>\n<td><code>ip route show</code></td>\n<td>Routing table configuration</td>\n</tr>\n<tr>\n<td>Connectivity</td>\n<td><code>ping</code>, <code>tcpdump -i bridge</code></td>\n<td><code>ping</code>, <code>traceroute</code></td>\n<td>Network reachability</td>\n</tr>\n<tr>\n<td>Namespace Operations</td>\n<td><code>ip netns exec NS command</code></td>\n<td>Direct execution</td>\n<td>Cross-namespace operations</td>\n</tr>\n</tbody></table>\n<h4 id=\"advanced-debugging-techniques\">Advanced Debugging Techniques</h4>\n<p><strong>Namespace Entry and Context Switching</strong>:</p>\n<p>The <code>nsenter</code> command allows executing commands within specific namespace contexts, enabling detailed inspection of container state from the host system:</p>\n<table>\n<thead>\n<tr>\n<th>nsenter Options</th>\n<th>Target Namespace</th>\n<th>Common Usage</th>\n<th>Debugging Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-t PID -p</code></td>\n<td>PID namespace</td>\n<td>Process inspection</td>\n<td>Verify PID isolation</td>\n</tr>\n<tr>\n<td><code>-t PID -m</code></td>\n<td>Mount namespace</td>\n<td>Filesystem inspection</td>\n<td>Check mount configuration</td>\n</tr>\n<tr>\n<td><code>-t PID -n</code></td>\n<td>Network namespace</td>\n<td>Network inspection</td>\n<td>Debug connectivity issues</td>\n</tr>\n<tr>\n<td><code>-t PID -a</code></td>\n<td>All namespaces</td>\n<td>Complete container context</td>\n<td>Comprehensive debugging</td>\n</tr>\n</tbody></table>\n<p><strong>Systematic State Inspection</strong>:</p>\n<p>Container debugging follows a systematic progression from high-level symptoms to specific kernel state. The recommended approach is:</p>\n<ol>\n<li><strong>Process Identification</strong>: Identify the container process PID and verify namespace membership</li>\n<li><strong>Namespace Verification</strong>: Confirm that expected namespaces exist and contain the correct processes</li>\n<li><strong>Resource State</strong>: Check cgroup assignments and current resource usage</li>\n<li><strong>Configuration Validation</strong>: Verify that kernel configuration matches intended container settings</li>\n<li><strong>Dynamic Behavior</strong>: Monitor resource consumption and limit enforcement during container execution</li>\n</ol>\n<p><strong>Error Context Correlation</strong>:</p>\n<p>The <code>container_error_context_t</code> structure provides systematic error reporting, but effective debugging requires correlating error reports with kernel state. When container operations fail, the debugging process should capture:</p>\n<ul>\n<li>System call error codes and their interpretation</li>\n<li>Kernel log messages related to namespace or cgroup operations</li>\n<li>Current resource usage at the time of failure</li>\n<li>Process state and namespace membership</li>\n</ul>\n<blockquote>\n<p><strong>Key Debugging Insight: State vs Configuration Mismatch</strong>: Most container bugs arise from mismatches between intended configuration and actual kernel state. The debugging process must verify that kernel state matches configuration at each step: namespace creation, process assignment, resource limit application, and cleanup execution. Tools like <code>lsns</code>, <code>/proc</code> filesystem inspection, and <code>nsenter</code> reveal actual kernel state, while configuration dumps show intended state.</p>\n</blockquote>\n<p><strong>Performance and Resource Monitoring</strong>:</p>\n<p>Long-term debugging often requires monitoring resource usage patterns and limit enforcement behavior. Key monitoring points include:</p>\n<ul>\n<li>Memory pressure indicators in <code>memory.pressure_level</code></li>\n<li>CPU throttling frequency in <code>cpu.stat</code></li>\n<li>Process creation failure rates in fork() system call errors</li>\n<li>Network interface statistics for connectivity debugging</li>\n</ul>\n<p>These metrics reveal whether containers are operating within their intended resource boundaries and whether limit enforcement is functioning correctly.</p>\n<p>⚠️ <strong>Pitfall: Namespace Context Confusion</strong>\nThe most common debugging mistake is running diagnostic commands in the wrong namespace context. Network commands run on the host show host networking state, not container networking state. Always verify which namespace context you&#39;re examining, and use <code>nsenter</code> or equivalent tools to switch contexts when needed. Symptoms observed in the wrong context lead to incorrect diagnoses and ineffective fixes.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical debugging infrastructure and tools for systematically diagnosing container implementation issues.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Debugging Category</th>\n<th>Simple Tools</th>\n<th>Advanced Tools</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace Inspection</td>\n<td><code>lsns</code>, <code>/proc/PID/ns/*</code></td>\n<td>Custom namespace walker with detailed state</td>\n</tr>\n<tr>\n<td>Process Monitoring</td>\n<td><code>ps aux --forest</code>, <code>pstree</code></td>\n<td>Process state monitor with namespace awareness</td>\n</tr>\n<tr>\n<td>Mount Debugging</td>\n<td><code>findmnt</code>, <code>/proc/mounts</code></td>\n<td>Mount event tracer with propagation analysis</td>\n</tr>\n<tr>\n<td>Network Analysis</td>\n<td><code>ip addr/route</code>, <code>ping</code></td>\n<td>Network namespace topology mapper</td>\n</tr>\n<tr>\n<td>Cgroups Inspection</td>\n<td><code>systemd-cgls</code>, manual file reading</td>\n<td>Cgroups statistics aggregator and limit monitor</td>\n</tr>\n<tr>\n<td>System Call Tracing</td>\n<td><code>strace -f</code></td>\n<td><code>perf trace</code> with container context</td>\n</tr>\n</tbody></table>\n<h4 id=\"debugging-infrastructure-code\">Debugging Infrastructure Code</h4>\n<p><strong>Complete Namespace State Inspector</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete namespace inspection utility</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> namespace_info {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ns_type</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ns_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ino_t</span><span style=\"color:#E1E4E8\"> ns_inode;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> accessible;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">namespace_info_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Ready-to-use namespace inspector - no implementation needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> inspect_process_namespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">namespace_info_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">ns_info</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> max_ns</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">ns_types</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"pid\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"mnt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"net\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"uts\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ipc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"user\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ns_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ns_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">ns_types</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> ns_count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> max_ns; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(ns_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(ns_path), </span><span style=\"color:#9ECBFF\">\"/proc/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/ns/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid, </span><span style=\"color:#FFAB70\">ns_types</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ns_info</span><span style=\"color:#E1E4E8\">[ns_count].ns_type, </span><span style=\"color:#FFAB70\">ns_types</span><span style=\"color:#E1E4E8\">[i], </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ns_info</span><span style=\"color:#E1E4E8\">[ns_count].ns_type) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        strncpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ns_info</span><span style=\"color:#E1E4E8\">[ns_count].ns_path, ns_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ns_info</span><span style=\"color:#E1E4E8\">[ns_count].ns_path) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(ns_path, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            ns_info</span><span style=\"color:#E1E4E8\">[ns_count].ns_inode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> st.st_ino;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            ns_info</span><span style=\"color:#E1E4E8\">[ns_count].accessible </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            ns_info</span><span style=\"color:#E1E4E8\">[ns_count].ns_inode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            ns_info</span><span style=\"color:#E1E4E8\">[ns_count].accessible </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ns_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ns_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Complete cgroup state reader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> read_cgroup_stats</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">controller</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">stats_buffer</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> buffer_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> stat_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">stat_file;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Support both cgroups v1 and v2 paths</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strstr</span><span style=\"color:#E1E4E8\">(cgroup_path, </span><span style=\"color:#9ECBFF\">\"unified\"</span><span style=\"color:#E1E4E8\">)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(stat_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(stat_path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.stat\"</span><span style=\"color:#E1E4E8\">, cgroup_path, controller);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(stat_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(stat_path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">.stat\"</span><span style=\"color:#E1E4E8\">, cgroup_path, controller);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stat_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(stat_path, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">stat_file) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> bytes_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fread</span><span style=\"color:#E1E4E8\">(stats_buffer, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, buffer_size </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, stat_file);</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    stats_buffer</span><span style=\"color:#E1E4E8\">[bytes_read] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(stat_file);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes_read;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Network namespace connectivity tester</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> test_network_connectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">target_ip</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> nsenter_cmd</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> result;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use nsenter to run ping in container's network namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(nsenter_cmd, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(nsenter_cmd), </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"nsenter -t </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> -n ping -c 1 -W 1 </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> >/dev/null 2>&#x26;1\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            container_pid, target_ip);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> system</span><span style=\"color:#E1E4E8\">(nsenter_cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> :</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Return 1 for success, 0 for failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-debugging-function-skeletons\">Core Debugging Function Skeletons</h4>\n<p><strong>Container State Diagnostic Function</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// diagnose_container_state - Comprehensive container state analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This function should be called when container behavior is unexpected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> diagnose_container_state</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">container</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                           container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">diagnosis_buffer</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                           size_t</span><span style=\"color:#FFAB70\"> buffer_size</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify process is still running using kill(container->child_pid, 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check all namespace file descriptors in container->namespace_fds array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Use fstat() to verify each fd is still valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Compare namespace inodes between parent and child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Inspect cgroup membership by reading /proc/PID/cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Verify process is assigned to expected cgroup path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Check that cgroup directory still exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Read current resource usage from cgroup stat files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Memory usage vs limit in memory.usage_in_bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - CPU throttling stats from cpu.stat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Process count vs limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test namespace isolation by comparing /proc/PID/ns/* inodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - PID namespace: different inode = isolated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Mount namespace: check /proc/PID/mountinfo differences  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Network namespace: check interface lists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Compile diagnosis into human-readable report in diagnosis_buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Include specific recommendations for each detected issue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use inspect_process_namespaces() and read_cgroup_stats() helpers above</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Resource Limit Enforcement Checker</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// verify_resource_enforcement - Check if cgroup limits are working</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Call this when containers appear to ignore resource limits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> verify_resource_enforcement</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_path</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                               enforcement_report_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">report</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read current memory usage from memory.usage_in_bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Compare with config->memory_limit_bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Check memory.failcnt for limit enforcement events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read CPU throttling statistics from cpu.stat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Parse nr_periods, nr_throttled, throttled_time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Calculate throttling percentage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check process count against max_processes limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Count lines in cgroup.procs file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Verify fork() failures when limit approached</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test limit enforcement by attempting to exceed limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Try allocating memory beyond limit (should trigger OOM)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Create processes beyond process limit (should fail)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Fill enforcement_report_t with findings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Set enforcement_working flag based on test results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         - Include specific failure details and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use read_cgroup_stats() to get current usage statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-debugging-hints\">Language-Specific Debugging Hints</h4>\n<p><strong>C-Specific Debugging Considerations</strong>:</p>\n<ul>\n<li>Use <code>strace -f -p PID</code> to trace system calls for namespace creation issues</li>\n<li>Check <code>errno</code> immediately after failed system calls - container code paths often overwrite error codes</li>\n<li>Use <code>valgrind --trace-children=yes</code> to catch memory errors in forked container processes</li>\n<li>Compile with <code>-g -O0</code> for debugging to ensure accurate line number information</li>\n<li>Use <code>gdb --args program</code> and <code>set follow-fork-mode child</code> to debug container child processes</li>\n</ul>\n<p><strong>File Organization for Debugging</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/container/\n    container_debug.c        ← debugging utilities (implement above skeletons)\n    container_debug.h        ← debugging function declarations\n  debug/\n    namespace_inspector.c    ← standalone namespace inspection tool\n    cgroup_monitor.c         ← resource usage monitoring tool\n    connectivity_tester.c    ← network connectivity verification\n  scripts/\n    debug_container.sh       ← wrapper script for common debugging workflows\n    collect_debug_info.sh    ← automated debug info collection</code></pre></div>\n\n<h4 id=\"milestone-debugging-checkpoints\">Milestone Debugging Checkpoints</h4>\n<p><strong>After Milestone 1 (PID Namespace)</strong>:</p>\n<ul>\n<li>Run <code>ps aux</code> from inside container - should show only container processes with PID 1 as init</li>\n<li>Check <code>lsns -t pid</code> - container should have different PID namespace inode than host</li>\n<li>Verify zombie reaping by creating short-lived child processes and confirming they don&#39;t accumulate</li>\n<li>Test signal handling by sending signals to container init process</li>\n</ul>\n<p><strong>After Milestone 2 (Mount Namespace)</strong>:</p>\n<ul>\n<li>Run <code>findmnt</code> from container and host - should show different mount trees</li>\n<li>Verify <code>/proc</code> and <code>/sys</code> are mounted and functional in container</li>\n<li>Check that host filesystem changes don&#39;t appear in container</li>\n<li>Confirm pivot_root worked by checking that container root directory is <code>/</code></li>\n</ul>\n<p><strong>After Milestone 3 (Network Namespace)</strong>:</p>\n<ul>\n<li>Run <code>ip addr show</code> in container - should show container-specific interfaces</li>\n<li>Test connectivity with <code>ping</code> to external addresses</li>\n<li>Verify inter-container communication through bridge networking</li>\n<li>Check that container cannot see host network interfaces</li>\n</ul>\n<p><strong>After Milestone 4 (Cgroups)</strong>:</p>\n<ul>\n<li>Trigger memory limit by allocating memory beyond limit - should cause OOM kill</li>\n<li>Generate CPU load and verify throttling occurs when limit exceeded</li>\n<li>Create many processes to test process limit enforcement</li>\n<li>Monitor resource usage with <code>systemd-cgls</code> and cgroup stat files</li>\n</ul>\n<h4 id=\"common-debugging-scenarios\">Common Debugging Scenarios</h4>\n<p><strong>Debugging Scenario Reference</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Investigation Steps</th>\n<th>Expected Findings</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container sees host processes</td>\n<td>Check PID namespace creation, verify lsns output</td>\n<td>Different PID namespace inode</td>\n<td>Fix clone() flags or namespace creation</td>\n</tr>\n<tr>\n<td>Container has no network</td>\n<td>Check network namespace, veth pair, routing</td>\n<td>Isolated network namespace with configured interfaces</td>\n<td>Fix veth creation or IP configuration</td>\n</tr>\n<tr>\n<td>Resource limits ignored</td>\n<td>Check cgroup assignment, controller availability</td>\n<td>Process in correct cgroup with active controllers</td>\n<td>Fix cgroup creation or process assignment</td>\n</tr>\n<tr>\n<td>Container startup hangs</td>\n<td>Check parent-child synchronization, error propagation</td>\n<td>Clear error messages or successful startup sequence</td>\n<td>Fix synchronization pipes or error handling</td>\n</tr>\n<tr>\n<td>Filesystem isolation broken</td>\n<td>Check mount namespace, pivot_root, mount propagation</td>\n<td>Separate mount namespace with private propagation</td>\n<td>Fix mount namespace creation or propagation settings</td>\n</tr>\n</tbody></table>\n<p>This comprehensive debugging framework provides systematic approaches to diagnosing and fixing the most common container implementation issues across all four milestone areas.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides a roadmap beyond the basic container implementation from milestones 1-4, outlining additional container features that can be built on the foundation of PID namespaces, mount namespaces, network namespaces, and cgroups resource management.</p>\n</blockquote>\n<p>The basic container implementation established through the four core milestones provides a solid foundation for process isolation, filesystem isolation, network isolation, and resource control. However, production container runtimes like Docker and containerd implement numerous additional features that enhance security, usability, and operational capabilities. This section explores three major categories of extensions that can be built upon our basic container runtime: additional namespace support for enhanced isolation, image management for portable container distribution, and orchestration capabilities for multi-container coordination.</p>\n<p>These extensions represent natural evolutionary paths for the basic container runtime, each building incrementally on the existing namespace and cgroups infrastructure. Understanding these extensions helps illuminate why container platforms have become so powerful and why they&#39;ve largely replaced virtual machines for many deployment scenarios. Each extension category addresses specific operational challenges that emerge when containers move from development prototypes to production systems.</p>\n<p>The extensions follow a progression from enhanced isolation capabilities through content management to distributed coordination. Additional namespaces provide finer-grained isolation boundaries, addressing security and administrative concerns that emerge in multi-tenant environments. Image management solves the distribution and versioning challenges that arise when containers need to run consistently across different environments. Container orchestration addresses the coordination and service discovery challenges that emerge when applications are composed of multiple cooperating containers.</p>\n<h3 id=\"additional-namespaces-user-uts-and-ipc-namespace-support\">Additional Namespaces: User, UTS, and IPC Namespace Support</h3>\n<p><strong>Mental Model: Security Zones in an Office Building</strong></p>\n<p>Think of additional namespaces like security zones in a modern office building. Our basic container implementation is like giving each tenant their own office (PID namespace), their own file cabinets (mount namespace), and their own phone system (network namespace). Additional namespaces are like adding more sophisticated security measures: user namespaces are like giving each tenant their own security badge system where they can be &quot;admin&quot; inside their space but have no privileges outside; UTS namespaces are like giving each tenant their own building address and signage; IPC namespaces are like ensuring each tenant&#39;s intercom system is completely separate from others.</p>\n<p>The current basic container implementation uses three of the six available Linux namespace types. The remaining three namespaces—user, UTS (Unix Timesharing System), and IPC (Inter-Process Communication)—provide additional isolation boundaries that enhance security and administrative separation. These namespaces become increasingly important as containers move from development environments to production systems where multiple tenants or applications share the same host infrastructure.</p>\n<p><strong>User Namespace Architecture</strong></p>\n<p>User namespaces provide perhaps the most significant security enhancement by creating isolated user and group ID mappings. Inside a user namespace, processes can have different user and group IDs than they appear to have from the host perspective. This capability enables containers to run processes as root (UID 0) inside the namespace while those same processes appear as unprivileged users from the host perspective.</p>\n<p>The user namespace implementation requires extending the <code>container_config_t</code> structure to include user mapping specifications:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>enable_user_ns</code></td>\n<td><code>int</code></td>\n<td>Whether to create user namespace for container</td>\n</tr>\n<tr>\n<td><code>uid_map_inside</code></td>\n<td><code>uid_t</code></td>\n<td>User ID as seen inside the container namespace</td>\n</tr>\n<tr>\n<td><code>uid_map_outside</code></td>\n<td><code>uid_t</code></td>\n<td>User ID as seen from host perspective</td>\n</tr>\n<tr>\n<td><code>uid_map_length</code></td>\n<td><code>size_t</code></td>\n<td>Number of consecutive UIDs in the mapping range</td>\n</tr>\n<tr>\n<td><code>gid_map_inside</code></td>\n<td><code>gid_t</code></td>\n<td>Group ID as seen inside the container namespace</td>\n</tr>\n<tr>\n<td><code>gid_map_outside</code></td>\n<td><code>gid_t</code></td>\n<td>Group ID as seen from host perspective</td>\n</tr>\n<tr>\n<td><code>gid_map_length</code></td>\n<td><code>size_t</code></td>\n<td>Number of consecutive GIDs in the mapping range</td>\n</tr>\n</tbody></table>\n<p>The user namespace creation process involves several steps that must occur in a specific sequence. First, the container process creates the user namespace using the <code>CLONE_NEWUSER</code> flag with the <code>clone()</code> system call. However, unlike other namespaces, the user namespace requires additional setup steps after creation to establish the user and group ID mappings.</p>\n<blockquote>\n<p><strong>Design Insight: User Namespace Timing Requirements</strong>\nUser namespaces have unique timing constraints because processes inside a newly created user namespace initially have no user or group ID mappings. This means they cannot perform operations that require specific user privileges until the mappings are established. The parent process must write to the <code>/proc/[pid]/uid_map</code> and <code>/proc/[pid]/gid_map</code> files to establish these mappings before the container process can proceed with other initialization tasks.</p>\n</blockquote>\n<p>The user namespace component would implement the following interface:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_user_namespace</code></td>\n<td><code>config, container</code></td>\n<td><code>int</code></td>\n<td>Creates user namespace with CLONE_NEWUSER flag</td>\n</tr>\n<tr>\n<td><code>setup_user_mappings</code></td>\n<td><code>config, child_pid</code></td>\n<td><code>int</code></td>\n<td>Establishes UID/GID mappings from parent process</td>\n</tr>\n<tr>\n<td><code>write_uid_map</code></td>\n<td><code>child_pid, inside_uid, outside_uid, length</code></td>\n<td><code>int</code></td>\n<td>Writes user ID mapping to /proc/[pid]/uid_map</td>\n</tr>\n<tr>\n<td><code>write_gid_map</code></td>\n<td><code>child_pid, inside_gid, outside_gid, length</code></td>\n<td><code>int</code></td>\n<td>Writes group ID mapping to /proc/[pid]/gid_map</td>\n</tr>\n<tr>\n<td><code>verify_user_isolation</code></td>\n<td><code>container_pid</code></td>\n<td><code>int</code></td>\n<td>Verifies user namespace isolation is working</td>\n</tr>\n</tbody></table>\n<p><strong>UTS Namespace Architecture</strong></p>\n<p>UTS namespaces isolate the system hostname and domain name, allowing each container to have its own distinct identity for networking and administrative purposes. While this might seem like a minor isolation boundary, it becomes important for applications that rely on hostname for configuration, logging, or service discovery.</p>\n<p>The UTS namespace extension requires adding hostname configuration to the container setup:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>container_hostname</code></td>\n<td><code>char*</code></td>\n<td>Hostname to set inside UTS namespace</td>\n</tr>\n<tr>\n<td><code>container_domainname</code></td>\n<td><code>char*</code></td>\n<td>Domain name to set inside UTS namespace</td>\n</tr>\n</tbody></table>\n<p>The UTS namespace implementation is relatively straightforward compared to user namespaces because it doesn&#39;t require complex mappings or parent-child coordination. The container process creates the UTS namespace using <code>CLONE_NEWUTS</code> and then uses the <code>sethostname()</code> and <code>setdomainname()</code> system calls to establish the container&#39;s identity.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_uts_namespace</code></td>\n<td><code>config, container</code></td>\n<td><code>int</code></td>\n<td>Creates UTS namespace with CLONE_NEWUTS flag</td>\n</tr>\n<tr>\n<td><code>setup_container_hostname</code></td>\n<td><code>hostname</code></td>\n<td><code>int</code></td>\n<td>Sets hostname inside UTS namespace using sethostname()</td>\n</tr>\n<tr>\n<td><code>setup_container_domainname</code></td>\n<td><code>domainname</code></td>\n<td><code>int</code></td>\n<td>Sets domain name inside UTS namespace using setdomainname()</td>\n</tr>\n<tr>\n<td><code>get_container_identity</code></td>\n<td><code>hostname_buf, domain_buf</code></td>\n<td><code>int</code></td>\n<td>Retrieves current hostname and domain name</td>\n</tr>\n</tbody></table>\n<p><strong>IPC Namespace Architecture</strong></p>\n<p>IPC namespaces isolate System V IPC objects (message queues, semaphores, shared memory segments) and POSIX message queues. This isolation prevents containers from interfering with each other&#39;s inter-process communication mechanisms and provides an additional security boundary.</p>\n<p>The IPC namespace implementation requires minimal configuration because it primarily provides isolation rather than requiring specific setup:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>enable_ipc_ns</code></td>\n<td><code>int</code></td>\n<td>Whether to create IPC namespace for container</td>\n</tr>\n<tr>\n<td><code>cleanup_ipc_objects</code></td>\n<td><code>int</code></td>\n<td>Whether to clean up IPC objects on container exit</td>\n</tr>\n</tbody></table>\n<p>The IPC namespace component provides these interface methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_ipc_namespace</code></td>\n<td><code>config, container</code></td>\n<td><code>int</code></td>\n<td>Creates IPC namespace with CLONE_NEWIPC flag</td>\n</tr>\n<tr>\n<td><code>list_ipc_objects</code></td>\n<td><code>objects, max_objects</code></td>\n<td><code>int</code></td>\n<td>Lists System V IPC objects in current namespace</td>\n</tr>\n<tr>\n<td><code>cleanup_ipc_namespace</code></td>\n<td><code>container</code></td>\n<td><code>int</code></td>\n<td>Removes any remaining IPC objects before namespace destruction</td>\n</tr>\n</tbody></table>\n<p><strong>Integration with Existing Container System</strong></p>\n<p>Adding these additional namespaces requires updating the existing container creation workflow to accommodate the new namespace types. The <code>CONTAINER_NS_FLAGS</code> constant would be extended to include the new namespace flags:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_NS_FLAGS_EXTENDED</span><span style=\"color:#E1E4E8\"> (CLONE_NEWPID</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">CLONE_NEWNS</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">CLONE_NEWNET</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">CLONE_NEWUTS</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">CLONE_NEWIPC</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">CLONE_NEWUSER)</span></span></code></pre></div>\n\n<p>The container startup sequence must be modified to handle the user namespace timing requirements, where user mappings must be established before the container process can proceed with other initialization steps. This requires extending the parent-child synchronization mechanism to include a user namespace setup phase.</p>\n<blockquote>\n<p><strong>Architecture Decision: User Namespace Setup Timing</strong></p>\n<ul>\n<li><strong>Context</strong>: User namespaces require parent process to establish UID/GID mappings after namespace creation but before container initialization continues</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Setup mappings before any other namespaces</li>\n<li>Setup mappings after all namespaces are created</li>\n<li>Defer mapping setup until container process requests it</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Setup user mappings immediately after user namespace creation but before other namespace initialization</li>\n<li><strong>Rationale</strong>: This ensures the container process has proper privileges for subsequent namespace setup operations while maintaining security isolation</li>\n<li><strong>Consequences</strong>: Requires extending parent-child synchronization protocol and adds complexity to error handling during startup sequence</li>\n</ul>\n</blockquote>\n<p><strong>Common Pitfalls in Additional Namespace Implementation</strong></p>\n<p>⚠️ <strong>Pitfall: User Namespace Capability Confusion</strong>\nWhen user namespaces are enabled, processes inside the namespace may have different capabilities than expected. A process running as UID 0 (root) inside a user namespace has administrative capabilities within that namespace but no special privileges on the host system. This can cause confusion when processes attempt operations that would normally succeed for root but fail due to the user namespace boundary. The solution is to carefully design capability requirements and test operations both inside and outside user namespaces.</p>\n<p>⚠️ <strong>Pitfall: Hostname Conflicts in Service Discovery</strong>\nApplications that rely on hostname for service discovery may behave unexpectedly when each container has its own hostname via UTS namespace. Multiple containers might choose the same hostname, leading to conflicts in service registration systems. The solution is to implement hostname allocation policies that ensure uniqueness within the deployment environment, similar to IP address allocation for network namespaces.</p>\n<p>⚠️ <strong>Pitfall: IPC Object Cleanup Timing</strong>\nSystem V IPC objects persist until explicitly removed, even after the processes that created them exit. In IPC namespaces, these objects are automatically cleaned up when the namespace is destroyed, but applications might not expect this behavior. The solution is to implement graceful IPC cleanup that allows applications to properly close IPC resources before namespace destruction.</p>\n<h3 id=\"image-management-container-image-layers-and-overlay-filesystems\">Image Management: Container Image Layers and Overlay Filesystems</h3>\n<p><strong>Mental Model: Layered Transparency Sheets</strong></p>\n<p>Think of container image management like the layered transparency sheets used in anatomy textbooks. Each sheet shows one system of the body—skeletal, muscular, circulatory—and when you stack them together, you see the complete organism. Container images work similarly: the base layer might contain the operating system files, the next layer adds application dependencies, another layer adds the application binary, and the final layer adds configuration files. When you stack all these layers together using an overlay filesystem, the container sees a complete, unified filesystem that appears to be a regular directory tree.</p>\n<p>The basic container implementation uses a simple approach where each container has its own complete root filesystem directory. While this works for development and learning, production container systems use layered images that enable efficient sharing of common components between containers, faster container startup times, and reduced storage requirements. This image management system requires implementing overlay filesystems, image layer management, and content distribution mechanisms.</p>\n<p><strong>Container Image Architecture</strong></p>\n<p>Container images consist of multiple read-only layers stacked together with a single read-write layer on top. Each layer represents a set of filesystem changes (files added, modified, or deleted) relative to the previous layer. This layered approach enables multiple containers to share common base layers while maintaining their own writable layer for runtime changes.</p>\n<p>The image management system requires new data structures to represent image metadata and layer information:</p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>image_layer_t</code></td>\n<td><code>layer_id</code></td>\n<td><code>char[64]</code></td>\n<td>SHA256 hash identifying this layer uniquely</td>\n</tr>\n<tr>\n<td></td>\n<td><code>parent_layer_id</code></td>\n<td><code>char[64]</code></td>\n<td>SHA256 hash of parent layer, empty for base layer</td>\n</tr>\n<tr>\n<td></td>\n<td><code>layer_path</code></td>\n<td><code>char[256]</code></td>\n<td>Filesystem path to layer directory or archive</td>\n</tr>\n<tr>\n<td></td>\n<td><code>layer_size</code></td>\n<td><code>size_t</code></td>\n<td>Total size of layer content in bytes</td>\n</tr>\n<tr>\n<td></td>\n<td><code>change_type</code></td>\n<td><code>layer_change_t</code></td>\n<td>Whether layer adds, modifies, or removes files</td>\n</tr>\n<tr>\n<td><code>container_image_t</code></td>\n<td><code>image_id</code></td>\n<td><code>char[64]</code></td>\n<td>SHA256 hash identifying complete image</td>\n</tr>\n<tr>\n<td></td>\n<td><code>image_name</code></td>\n<td><code>char[128]</code></td>\n<td>Human-readable image name like &quot;ubuntu:20.04&quot;</td>\n</tr>\n<tr>\n<td></td>\n<td><code>layer_count</code></td>\n<td><code>int</code></td>\n<td>Number of layers in image stack</td>\n</tr>\n<tr>\n<td></td>\n<td><code>layers</code></td>\n<td><code>image_layer_t*</code></td>\n<td>Array of layers ordered from base to top</td>\n</tr>\n<tr>\n<td></td>\n<td><code>total_size</code></td>\n<td><code>size_t</code></td>\n<td>Combined size of all layers in image</td>\n</tr>\n<tr>\n<td><code>overlay_mount_t</code></td>\n<td><code>lower_dirs</code></td>\n<td><code>char**</code></td>\n<td>Array of read-only layer directories</td>\n</tr>\n<tr>\n<td></td>\n<td><code>upper_dir</code></td>\n<td><code>char*</code></td>\n<td>Read-write layer directory for container changes</td>\n</tr>\n<tr>\n<td></td>\n<td><code>work_dir</code></td>\n<td><code>char*</code></td>\n<td>Overlay filesystem work directory</td>\n</tr>\n<tr>\n<td></td>\n<td><code>merged_dir</code></td>\n<td><code>char*</code></td>\n<td>Mount point showing unified view of all layers</td>\n</tr>\n</tbody></table>\n<p><strong>Overlay Filesystem Implementation</strong></p>\n<p>Overlay filesystems provide the mechanism for combining multiple image layers into a single unified directory tree. The Linux overlay filesystem driver (overlayfs) takes multiple lower directories (read-only layers), one upper directory (read-write layer), and a work directory (for atomic operations), then presents them as a single merged directory.</p>\n<p>The overlay filesystem setup process involves several coordinated steps. First, the image management system prepares the layer directories by extracting or mounting each image layer to a separate directory. These directories become the &quot;lower&quot; layers in overlay filesystem terminology. Second, the system creates an empty &quot;upper&quot; directory where the container can make filesystem changes during execution. Third, the system creates a &quot;work&quot; directory that overlay filesystem uses for atomic operations. Finally, the system mounts the overlay filesystem with all these directories to create the unified view.</p>\n<p>The overlay filesystem component provides these interface methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>setup_overlay_mount</code></td>\n<td><code>image, container_id, overlay</code></td>\n<td><code>int</code></td>\n<td>Prepares and mounts overlay filesystem for container</td>\n</tr>\n<tr>\n<td><code>prepare_image_layers</code></td>\n<td><code>image, layer_dirs</code></td>\n<td><code>int</code></td>\n<td>Extracts or mounts all image layers to separate directories</td>\n</tr>\n<tr>\n<td><code>create_overlay_dirs</code></td>\n<td><code>container_id, upper, work, merged</code></td>\n<td><code>int</code></td>\n<td>Creates upper, work, and merged directories for overlay mount</td>\n</tr>\n<tr>\n<td><code>mount_overlay_filesystem</code></td>\n<td><code>overlay</code></td>\n<td><code>int</code></td>\n<td>Mounts overlay filesystem with specified layer configuration</td>\n</tr>\n<tr>\n<td><code>cleanup_overlay_mount</code></td>\n<td><code>overlay</code></td>\n<td><code>int</code></td>\n<td>Unmounts overlay filesystem and cleans up directories</td>\n</tr>\n<tr>\n<td><code>commit_container_changes</code></td>\n<td><code>overlay, new_layer</code></td>\n<td><code>int</code></td>\n<td>Creates new image layer from container&#39;s upper directory</td>\n</tr>\n</tbody></table>\n<p>The overlay mount process requires careful handling of directory permissions and ownership. Each layer directory must be accessible to the container process, but the overlay filesystem itself manages the permission and ownership mapping between layers. When files exist in multiple layers, the topmost layer takes precedence, implementing the &quot;copy-on-write&quot; semantics that allow containers to modify files without affecting the underlying image layers.</p>\n<blockquote>\n<p><strong>Design Insight: Copy-on-Write Behavior</strong>\nWhen a container attempts to modify a file that exists in a lower (read-only) layer, the overlay filesystem automatically copies that file to the upper (read-write) layer and applies the modification there. This copy-on-write behavior ensures that image layers remain immutable while allowing containers to make necessary runtime changes. The performance impact of this copying operation can be significant for large files, which is why container images are typically designed with frequently modified files placed in higher layers.</p>\n</blockquote>\n<p><strong>Image Layer Management</strong></p>\n<p>Container images are typically distributed as compressed archives containing layer data and metadata. The image management system must handle extracting these archives, verifying layer integrity, and managing the storage of layer data on the local filesystem. This involves implementing a local image store that can efficiently store and retrieve image layers.</p>\n<p>The image store uses content-addressable storage where each layer is stored using its SHA256 hash as the directory name. This approach ensures that identical layers are stored only once, even when they appear in multiple images. The image store structure looks like this:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/var/lib/container-basic/images/\n├── layers/\n│   ├── sha256:a1b2c3d4.../\n│   │   ├── layer.tar        ← compressed layer content\n│   │   └── metadata.json    ← layer metadata\n│   └── sha256:e5f6g7h8.../\n│       ├── layer.tar\n│       └── metadata.json\n├── images/\n│   ├── ubuntu-20.04/\n│   │   └── manifest.json    ← image manifest listing all layers\n│   └── nginx-latest/\n│       └── manifest.json\n└── containers/\n    ├── container-001/\n    │   ├── upper/           ← read-write layer for this container\n    │   ├── work/            ← overlay filesystem work directory\n    │   └── merged/          ← overlay mount point\n    └── container-002/\n        ├── upper/\n        ├── work/\n        └── merged/</code></pre></div>\n\n<p>The image layer management component provides these interface methods:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pull_image_layers</code></td>\n<td><code>image_name, registry_url</code></td>\n<td><code>int</code></td>\n<td>Downloads image layers from remote registry</td>\n</tr>\n<tr>\n<td><code>extract_layer_archive</code></td>\n<td><code>layer_path, extract_dir</code></td>\n<td><code>int</code></td>\n<td>Extracts compressed layer archive to directory</td>\n</tr>\n<tr>\n<td><code>verify_layer_integrity</code></td>\n<td><code>layer_path, expected_hash</code></td>\n<td><code>int</code></td>\n<td>Verifies layer content matches expected SHA256 hash</td>\n</tr>\n<tr>\n<td><code>store_image_manifest</code></td>\n<td><code>image_name, manifest</code></td>\n<td><code>int</code></td>\n<td>Stores image manifest in local image store</td>\n</tr>\n<tr>\n<td><code>load_image_manifest</code></td>\n<td><code>image_name, manifest</code></td>\n<td><code>int</code></td>\n<td>Loads image manifest from local image store</td>\n</tr>\n<tr>\n<td><code>garbage_collect_layers</code></td>\n<td><code>retain_days</code></td>\n<td><code>int</code></td>\n<td>Removes unused layers older than specified days</td>\n</tr>\n<tr>\n<td><code>list_available_images</code></td>\n<td><code>images, max_images</code></td>\n<td><code>int</code></td>\n<td>Lists all images available in local image store</td>\n</tr>\n</tbody></table>\n<p><strong>Integration with Mount Namespace</strong></p>\n<p>The image management system must integrate with the existing mount namespace implementation to replace the simple root filesystem setup with overlay filesystem mounting. This requires modifying the <code>setup_container_rootfs</code> function to use overlay mounting instead of bind mounting a single directory.</p>\n<p>The integration involves updating the container startup sequence to include image layer preparation before mount namespace creation. The modified sequence becomes: validate container configuration, pull and extract image layers if needed, prepare overlay directories, create mount namespace, mount overlay filesystem as container root, mount essential filesystems (/proc, /sys, /dev), and finally execute the container process.</p>\n<blockquote>\n<p><strong>Architecture Decision: Overlay vs Bind Mount Integration</strong></p>\n<ul>\n<li><strong>Context</strong>: Existing mount namespace implementation uses bind mounts for simple directory-based root filesystems, but overlay filesystems require different mount setup</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Replace bind mount implementation entirely with overlay mounting</li>\n<li>Add overlay support as alternative mount type with configuration flag</li>\n<li>Implement overlay as wrapper around existing bind mount system</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Add overlay support as alternative mount type with configuration flag</li>\n<li><strong>Rationale</strong>: This preserves backward compatibility for simple use cases while enabling advanced image layer functionality when needed</li>\n<li><strong>Consequences</strong>: Increases code complexity but provides flexibility for different deployment scenarios and easier testing of both approaches</li>\n</ul>\n</blockquote>\n<p><strong>Common Pitfalls in Image Management Implementation</strong></p>\n<p>⚠️ <strong>Pitfall: Layer Extraction Race Conditions</strong>\nWhen multiple containers attempt to use the same image simultaneously, they may try to extract the same layers concurrently, leading to corruption or incomplete extractions. The solution is to implement file locking around layer extraction operations and check for existing extracted layers before beginning extraction.</p>\n<p>⚠️ <strong>Pitfall: Overlay Work Directory Cleanup</strong>\nThe overlay filesystem work directory must be on the same filesystem as the upper directory for atomic operations to work correctly. Additionally, the work directory must be cleaned up properly when containers exit, or subsequent overlay mounts may fail with &quot;work directory not empty&quot; errors. The solution is to ensure work directories are created on the correct filesystem and implement thorough cleanup procedures.</p>\n<p>⚠️ <strong>Pitfall: Layer Hash Verification Bypass</strong>\nSkipping layer integrity verification during development can lead to subtle corruption issues that are difficult to debug. Corrupted layers may cause containers to behave unpredictably or fail in unexpected ways. The solution is to always verify layer hashes, even during development, and implement clear error messages when verification fails.</p>\n<h3 id=\"container-orchestration-multi-container-coordination-and-service-discovery\">Container Orchestration: Multi-Container Coordination and Service Discovery</h3>\n<p><strong>Mental Model: Restaurant Kitchen Coordination</strong></p>\n<p>Think of container orchestration like the coordination system in a busy restaurant kitchen. Individual containers are like cooking stations—the grill, the salad prep area, the dessert station—each specialized for specific tasks. The orchestration system is like the head chef and expeditors who coordinate between stations: they ensure orders flow smoothly between stations, ingredients are available when needed, backup stations can take over when one fails, and the final dishes are assembled correctly. Service discovery is like the communication system that lets each station know where to send completed items and where to request ingredients.</p>\n<p>The basic container implementation focuses on isolating and controlling individual containers, but real-world applications typically consist of multiple containers that must coordinate to provide complete functionality. A web application might have containers for the web server, database, cache, and background job processor, all of which need to communicate with each other and be managed as a cohesive system. Container orchestration addresses these multi-container coordination challenges.</p>\n<p><strong>Service Discovery Architecture</strong></p>\n<p>Service discovery enables containers to locate and communicate with other containers without hardcoding network addresses or relying on external configuration. As containers start and stop dynamically, their IP addresses change, making static configuration impractical. Service discovery systems provide a dynamic registry where containers can register their services and query for the services they depend on.</p>\n<p>The service discovery system requires data structures to represent services and their endpoints:</p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>service_endpoint_t</code></td>\n<td><code>service_name</code></td>\n<td><code>char[64]</code></td>\n<td>Name of service like &quot;web-server&quot; or &quot;database&quot;</td>\n</tr>\n<tr>\n<td></td>\n<td><code>container_id</code></td>\n<td><code>char[64]</code></td>\n<td>Identifier of container providing this service</td>\n</tr>\n<tr>\n<td></td>\n<td><code>ip_address</code></td>\n<td><code>char[16]</code></td>\n<td>IP address where service is accessible</td>\n</tr>\n<tr>\n<td></td>\n<td><code>port</code></td>\n<td><code>uint16_t</code></td>\n<td>TCP/UDP port number for service</td>\n</tr>\n<tr>\n<td></td>\n<td><code>health_status</code></td>\n<td><code>endpoint_health_t</code></td>\n<td>Current health status of service endpoint</td>\n</tr>\n<tr>\n<td></td>\n<td><code>last_heartbeat</code></td>\n<td><code>time_t</code></td>\n<td>Timestamp of last health check or heartbeat</td>\n</tr>\n<tr>\n<td><code>service_registry_t</code></td>\n<td><code>services</code></td>\n<td><code>service_endpoint_t**</code></td>\n<td>Hash table mapping service names to endpoint arrays</td>\n</tr>\n<tr>\n<td></td>\n<td><code>service_count</code></td>\n<td><code>int</code></td>\n<td>Total number of registered services</td>\n</tr>\n<tr>\n<td></td>\n<td><code>registry_lock</code></td>\n<td><code>pthread_mutex_t</code></td>\n<td>Mutex protecting concurrent registry access</td>\n</tr>\n<tr>\n<td><code>service_query_t</code></td>\n<td><code>service_name</code></td>\n<td><code>char[64]</code></td>\n<td>Name of service being queried</td>\n</tr>\n<tr>\n<td></td>\n<td><code>preferred_zone</code></td>\n<td><code>char[32]</code></td>\n<td>Preferred availability zone or location</td>\n</tr>\n<tr>\n<td></td>\n<td><code>load_balancing</code></td>\n<td><code>lb_strategy_t</code></td>\n<td>Load balancing strategy for multiple endpoints</td>\n</tr>\n<tr>\n<td></td>\n<td><code>timeout_ms</code></td>\n<td><code>int</code></td>\n<td>Maximum time to wait for service resolution</td>\n</tr>\n</tbody></table>\n<p>The service discovery implementation provides both registration and query capabilities. Containers register their services when they start and deregister when they stop. Other containers query the service registry to discover available services and their current endpoints.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>register_service</code></td>\n<td><code>service_name, container_id, ip, port</code></td>\n<td><code>int</code></td>\n<td>Registers new service endpoint in registry</td>\n</tr>\n<tr>\n<td><code>deregister_service</code></td>\n<td><code>service_name, container_id</code></td>\n<td><code>int</code></td>\n<td>Removes service endpoint from registry</td>\n</tr>\n<tr>\n<td><code>discover_service</code></td>\n<td><code>query, endpoints, max_endpoints</code></td>\n<td><code>int</code></td>\n<td>Queries registry for available service endpoints</td>\n</tr>\n<tr>\n<td><code>update_service_health</code></td>\n<td><code>service_name, container_id, health</code></td>\n<td><code>int</code></td>\n<td>Updates health status of registered service</td>\n</tr>\n<tr>\n<td><code>list_services</code></td>\n<td><code>services, max_services</code></td>\n<td><code>int</code></td>\n<td>Lists all services currently registered</td>\n</tr>\n<tr>\n<td><code>cleanup_expired_services</code></td>\n<td><code>max_age_seconds</code></td>\n<td><code>int</code></td>\n<td>Removes services that haven&#39;t sent heartbeats</td>\n</tr>\n</tbody></table>\n<p><strong>Container Lifecycle Management</strong></p>\n<p>Orchestration systems manage the complete lifecycle of multiple containers, including startup ordering, dependency management, failure handling, and scaling decisions. Unlike individual container management, orchestration must reason about relationships between containers and coordinate their lifecycle events.</p>\n<p>The orchestration system uses deployment specifications that describe the desired state of multi-container applications:</p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>container_spec_t</code></td>\n<td><code>container_name</code></td>\n<td><code>char[64]</code></td>\n<td>Unique name for container within deployment</td>\n</tr>\n<tr>\n<td></td>\n<td><code>image_name</code></td>\n<td><code>char[128]</code></td>\n<td>Container image to use for this container</td>\n</tr>\n<tr>\n<td></td>\n<td><code>replicas</code></td>\n<td><code>int</code></td>\n<td>Number of identical container instances to run</td>\n</tr>\n<tr>\n<td></td>\n<td><code>dependencies</code></td>\n<td><code>char**</code></td>\n<td>Array of container names this depends on</td>\n</tr>\n<tr>\n<td></td>\n<td><code>service_ports</code></td>\n<td><code>port_mapping_t*</code></td>\n<td>Ports this container exposes as services</td>\n</tr>\n<tr>\n<td></td>\n<td><code>resource_limits</code></td>\n<td><code>container_config_t</code></td>\n<td>CPU, memory, and other resource constraints</td>\n</tr>\n<tr>\n<td><code>deployment_spec_t</code></td>\n<td><code>deployment_name</code></td>\n<td><code>char[64]</code></td>\n<td>Name of multi-container deployment</td>\n</tr>\n<tr>\n<td></td>\n<td><code>container_specs</code></td>\n<td><code>container_spec_t*</code></td>\n<td>Array of container specifications</td>\n</tr>\n<tr>\n<td></td>\n<td><code>spec_count</code></td>\n<td><code>int</code></td>\n<td>Number of containers in deployment</td>\n</tr>\n<tr>\n<td></td>\n<td><code>network_name</code></td>\n<td><code>char[64]</code></td>\n<td>Name of network for inter-container communication</td>\n</tr>\n<tr>\n<td><code>deployment_state_t</code></td>\n<td><code>spec</code></td>\n<td><code>deployment_spec_t</code></td>\n<td>Desired state specification</td>\n</tr>\n<tr>\n<td></td>\n<td><code>running_containers</code></td>\n<td><code>container_instance_t**</code></td>\n<td>Currently running container instances</td>\n</tr>\n<tr>\n<td></td>\n<td><code>container_count</code></td>\n<td><code>int</code></td>\n<td>Number of currently running containers</td>\n</tr>\n<tr>\n<td></td>\n<td><code>state_lock</code></td>\n<td><code>pthread_mutex_t</code></td>\n<td>Mutex protecting concurrent state access</td>\n</tr>\n</tbody></table>\n<p>The orchestration engine implements a control loop that continuously compares the desired state (deployment specification) with the actual state (running containers) and takes actions to reconcile any differences. This approach ensures that containers are automatically restarted if they fail, scaled up or down as needed, and started in the correct dependency order.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_deployment</code></td>\n<td><code>spec, deployment</code></td>\n<td><code>int</code></td>\n<td>Creates new multi-container deployment</td>\n</tr>\n<tr>\n<td><code>update_deployment</code></td>\n<td><code>deployment, new_spec</code></td>\n<td><code>int</code></td>\n<td>Updates existing deployment with new specification</td>\n</tr>\n<tr>\n<td><code>delete_deployment</code></td>\n<td><code>deployment</code></td>\n<td><code>int</code></td>\n<td>Stops all containers and deletes deployment</td>\n</tr>\n<tr>\n<td><code>reconcile_deployment_state</code></td>\n<td><code>deployment</code></td>\n<td><code>int</code></td>\n<td>Ensures actual state matches desired state</td>\n</tr>\n<tr>\n<td><code>scale_container_replicas</code></td>\n<td><code>deployment, container_name, replicas</code></td>\n<td><code>int</code></td>\n<td>Changes number of replicas for specific container</td>\n</tr>\n<tr>\n<td><code>restart_failed_containers</code></td>\n<td><code>deployment</code></td>\n<td><code>int</code></td>\n<td>Restarts containers that have failed or stopped</td>\n</tr>\n<tr>\n<td><code>check_container_dependencies</code></td>\n<td><code>spec, container_name</code></td>\n<td><code>int</code></td>\n<td>Verifies all dependencies are running and healthy</td>\n</tr>\n</tbody></table>\n<p><strong>Inter-Container Communication</strong></p>\n<p>Containers within an orchestrated deployment need secure and efficient communication mechanisms. While containers can communicate through the network namespace and bridge networking established in milestone 3, orchestration systems typically provide higher-level communication abstractions that handle service discovery, load balancing, and failure recovery automatically.</p>\n<p>The communication system builds on the existing network namespace infrastructure but adds service-aware networking features. Instead of containers needing to know specific IP addresses and ports, they can communicate using service names that the orchestration system resolves dynamically.</p>\n<table>\n<thead>\n<tr>\n<th>Structure Name</th>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>service_connection_t</code></td>\n<td><code>source_container</code></td>\n<td><code>char[64]</code></td>\n<td>Container initiating the connection</td>\n</tr>\n<tr>\n<td></td>\n<td><code>target_service</code></td>\n<td><code>char[64]</code></td>\n<td>Service name being connected to</td>\n</tr>\n<tr>\n<td></td>\n<td><code>connection_type</code></td>\n<td><code>connection_type_t</code></td>\n<td>HTTP, TCP, UDP, or other protocol</td>\n</tr>\n<tr>\n<td></td>\n<td><code>load_balancer</code></td>\n<td><code>load_balancer_t*</code></td>\n<td>Load balancer managing multiple endpoints</td>\n</tr>\n<tr>\n<td><code>load_balancer_t</code></td>\n<td><code>strategy</code></td>\n<td><code>lb_strategy_t</code></td>\n<td>Round-robin, least-connections, or random</td>\n</tr>\n<tr>\n<td></td>\n<td><code>endpoints</code></td>\n<td><code>service_endpoint_t*</code></td>\n<td>Array of available service endpoints</td>\n</tr>\n<tr>\n<td></td>\n<td><code>endpoint_count</code></td>\n<td><code>int</code></td>\n<td>Number of currently healthy endpoints</td>\n</tr>\n<tr>\n<td></td>\n<td><code>current_index</code></td>\n<td><code>int</code></td>\n<td>Current position for round-robin selection</td>\n</tr>\n</tbody></table>\n<p>The inter-container communication component extends the existing network namespace functionality:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>create_service_network</code></td>\n<td><code>network_name, subnet</code></td>\n<td><code>int</code></td>\n<td>Creates dedicated network for service communication</td>\n</tr>\n<tr>\n<td><code>connect_container_to_service</code></td>\n<td><code>container, service_name, connection</code></td>\n<td><code>int</code></td>\n<td>Establishes connection to named service</td>\n</tr>\n<tr>\n<td><code>setup_load_balancer</code></td>\n<td><code>service_name, strategy, balancer</code></td>\n<td><code>int</code></td>\n<td>Creates load balancer for service with multiple endpoints</td>\n</tr>\n<tr>\n<td><code>route_service_request</code></td>\n<td><code>connection, request</code></td>\n<td><code>int</code></td>\n<td>Routes request to appropriate service endpoint</td>\n</tr>\n<tr>\n<td><code>handle_endpoint_failure</code></td>\n<td><code>balancer, failed_endpoint</code></td>\n<td><code>int</code></td>\n<td>Removes failed endpoint from load balancer rotation</td>\n</tr>\n<tr>\n<td><code>update_service_endpoints</code></td>\n<td><code>balancer, new_endpoints</code></td>\n<td><code>int</code></td>\n<td>Updates load balancer with current healthy endpoints</td>\n</tr>\n</tbody></table>\n<p><strong>Integration with Existing Container System</strong></p>\n<p>Container orchestration builds upon all four milestone components—PID namespaces, mount namespaces, network namespaces, and cgroups—but coordinates their use across multiple containers. The orchestration system becomes the higher-level controller that manages multiple instances of the basic container runtime.</p>\n<p>The integration requires extending the container creation and management interfaces to support orchestration-driven lifecycle management. Instead of manually calling <code>container_create</code>, <code>container_wait</code>, and <code>container_destroy</code> for individual containers, the orchestration system manages these operations based on deployment specifications and health monitoring.</p>\n<p>The orchestration system must also coordinate resource allocation across multiple containers to prevent resource conflicts and ensure fair sharing. This involves extending the cgroups implementation to support hierarchical resource allocation where the orchestration system allocates resources to deployments, and deployments sub-allocate resources to individual containers.</p>\n<blockquote>\n<p><strong>Architecture Decision: Centralized vs Distributed Orchestration</strong></p>\n<ul>\n<li><strong>Context</strong>: Multi-container deployments need coordination for startup, failure handling, and resource management</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Centralized orchestration with single control process managing all containers</li>\n<li>Distributed orchestration with peer-to-peer coordination between containers</li>\n<li>Hierarchical orchestration with local controllers managed by global coordinator</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Centralized orchestration with single control process for basic implementation</li>\n<li><strong>Rationale</strong>: Centralized approach is simpler to implement and debug, provides consistent state management, and aligns with the educational goals of understanding orchestration concepts</li>\n<li><strong>Consequences</strong>: Creates single point of failure but provides clear operational model that can be extended to distributed approaches later</li>\n</ul>\n</blockquote>\n<p><strong>Common Pitfalls in Container Orchestration Implementation</strong></p>\n<p>⚠️ <strong>Pitfall: Circular Dependency Detection</strong>\nWhen containers have complex dependency relationships, it&#39;s possible to create circular dependencies where container A depends on container B, which depends on container C, which depends back on container A. This creates a deadlock where no container can start because each is waiting for another. The solution is to implement dependency graph analysis that detects cycles before attempting to start containers and reports clear error messages about which containers form the cycle.</p>\n<p>⚠️ <strong>Pitfall: Service Discovery Race Conditions</strong>\nDuring rapid container startup and shutdown, service registration and deregistration events can arrive out of order, leading to incorrect service registry state. A container might deregister just before its replacement registers, causing temporary service unavailability. The solution is to implement proper synchronization around service registry operations and use timestamps or version numbers to handle out-of-order events correctly.</p>\n<p>⚠️ <strong>Pitfall: Resource Allocation Conflicts</strong>\nWhen multiple containers compete for limited resources, the orchestration system might allocate more resources than are actually available on the system. This can lead to containers being unable to start or experiencing performance degradation due to resource pressure. The solution is to implement resource accounting that tracks total allocated resources across all deployments and prevents over-allocation beyond system capacity.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The future extensions build incrementally on the existing container runtime foundation, allowing learners to implement them in stages based on their interests and requirements. Each extension category represents a significant engineering undertaking, so it&#39;s recommended to start with the additional namespaces as they most closely parallel the existing namespace implementations.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Implementation</th>\n<th>Advanced Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Additional Namespaces</td>\n<td>Direct syscall integration with existing namespace code</td>\n<td>Namespace capability management and privilege dropping</td>\n</tr>\n<tr>\n<td>Image Management</td>\n<td>Directory-based layer storage with tar archives</td>\n<td>Content-addressable storage with compression and deduplication</td>\n</tr>\n<tr>\n<td>Container Orchestration</td>\n<td>Single-host process coordinator with file-based service registry</td>\n<td>Distributed coordination with etcd or consul for service discovery</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure Extension</strong></p>\n<p>Building on the existing container runtime structure, the extensions would add new directories:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n├── src/\n│   ├── namespaces/\n│   │   ├── pid_namespace.c      ← existing\n│   │   ├── mount_namespace.c    ← existing\n│   │   ├── network_namespace.c  ← existing\n│   │   ├── user_namespace.c     ← new: user namespace implementation\n│   │   ├── uts_namespace.c      ← new: UTS namespace implementation\n│   │   └── ipc_namespace.c      ← new: IPC namespace implementation\n│   ├── images/\n│   │   ├── image_store.c        ← new: local image storage management\n│   │   ├── layer_manager.c      ← new: layer extraction and mounting\n│   │   ├── overlay_fs.c         ← new: overlay filesystem integration\n│   │   └── image_registry.c     ← new: remote image pulling\n│   ├── orchestration/\n│   │   ├── service_discovery.c  ← new: service registration and lookup\n│   │   ├── deployment_manager.c ← new: multi-container lifecycle\n│   │   ├── load_balancer.c      ← new: service load balancing\n│   │   └── resource_scheduler.c ← new: cross-container resource allocation\n│   └── container.c              ← existing: updated to support extensions\n├── include/\n│   ├── container_extensions.h   ← new: extension API definitions\n│   └── orchestration_types.h    ← new: orchestration data structures\n└── tests/\n    ├── test_additional_namespaces.c  ← new: additional namespace tests\n    ├── test_image_management.c       ← new: image layer tests\n    └── test_orchestration.c          ← new: multi-container tests</code></pre></div>\n\n<p><strong>Infrastructure Starter Code: Service Registry</strong></p>\n<p>Here&#39;s a complete service registry implementation that provides the foundation for container orchestration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;pthread.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/queue.h></span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_SERVICE_NAME</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_CONTAINER_ID</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> MAX_ENDPOINTS_PER_SERVICE</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> enum</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ENDPOINT_HEALTHY,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ENDPOINT_UNHEALTHY,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ENDPOINT_UNKNOWN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">endpoint_health_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> service_endpoint {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> service_name</span><span style=\"color:#E1E4E8\">[MAX_SERVICE_NAME];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> container_id</span><span style=\"color:#E1E4E8\">[MAX_CONTAINER_ID];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> ip_address</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uint16_t</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    endpoint_health_t</span><span style=\"color:#E1E4E8\"> health_status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    time_t</span><span style=\"color:#E1E4E8\"> last_heartbeat;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LIST_ENTRY</span><span style=\"color:#E1E4E8\">(service_endpoint) entries;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">service_endpoint_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> service_registry {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LIST_HEAD</span><span style=\"color:#E1E4E8\">(endpoint_list, service_endpoint) endpoints;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pthread_mutex_t</span><span style=\"color:#E1E4E8\"> registry_lock;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> endpoint_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">service_registry_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialize global service registry</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">service_registry_t</span><span style=\"color:#E1E4E8\"> global_registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .endpoints </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> LIST_HEAD_INITIALIZER</span><span style=\"color:#E1E4E8\">(global_registry.endpoints),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .registry_lock </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PTHREAD_MUTEX_INITIALIZER,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    .endpoint_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> register_service</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> service_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> container_id</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> ip_address</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint16_t</span><span style=\"color:#FFAB70\"> port</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    service_endpoint_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> endpoint </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">service_endpoint_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">endpoint) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(endpoint->service_name, service_name, MAX_SERVICE_NAME </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(endpoint->container_id, container_id, MAX_CONTAINER_ID </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    strncpy</span><span style=\"color:#E1E4E8\">(endpoint->ip_address, ip_address, </span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    endpoint->port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> port;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    endpoint->health_status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ENDPOINT_HEALTHY;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    endpoint->last_heartbeat </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.registry_lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LIST_INSERT_HEAD</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.endpoints, endpoint, entries);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_registry.endpoint_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.registry_lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Registered service </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> at </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> for container </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           service_name, ip_address, port, container_id);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> discover_service</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> service_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">service_endpoint_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> results</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    int</span><span style=\"color:#FFAB70\"> max_results</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> found_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    service_endpoint_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> endpoint;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.registry_lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LIST_FOREACH</span><span style=\"color:#E1E4E8\">(endpoint, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.endpoints, entries) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(endpoint->service_name, service_name) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            endpoint->health_status </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ENDPOINT_HEALTHY </span><span style=\"color:#F97583\">&#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            found_count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> max_results) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            memcpy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">results</span><span style=\"color:#E1E4E8\">[found_count], endpoint, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">service_endpoint_t</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            found_count</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.registry_lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> found_count;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> deregister_service</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> service_name</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> container_id</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    service_endpoint_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> endpoint;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> removed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_lock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.registry_lock);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    LIST_FOREACH</span><span style=\"color:#E1E4E8\">(endpoint, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.endpoints, entries) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strcmp</span><span style=\"color:#E1E4E8\">(endpoint->service_name, service_name) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            strcmp</span><span style=\"color:#E1E4E8\">(endpoint->container_id, container_id) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            LIST_REMOVE</span><span style=\"color:#E1E4E8\">(endpoint, entries);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            global_registry.endpoint_count</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            free</span><span style=\"color:#E1E4E8\">(endpoint);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            removed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pthread_mutex_unlock</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">global_registry.registry_lock);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (removed) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Deregistered service </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> for container </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               service_name, container_id);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> removed </span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton: User Namespace Setup</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Creates user namespace and establishes UID/GID mappings for container process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> create_user_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">container_instance_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> container</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if user namespace is enabled in configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create child process with CLONE_NEWUSER flag using safe_clone()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store child PID in container instance structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Write UID mapping to /proc/[child_pid]/uid_map from parent process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Format: \"inside_uid outside_uid length\" (e.g., \"0 1000 1\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Write GID mapping to /proc/[child_pid]/gid_map from parent process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         Format: \"inside_gid outside_gid length\" (e.g., \"0 1000 1\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Signal child process that user mappings are complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Child process continues with container initialization as mapped user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use container_sync_t pipes for parent-child coordination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check /proc/sys/user/max_user_namespaces for system limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Sets up overlay filesystem mount with multiple image layers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> setup_overlay_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">container_image_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> image</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char*</span><span style=\"color:#FFAB70\"> container_id</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                       overlay_mount_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> overlay</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create container-specific directories (upper, work, merged)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Prepare lower directories by extracting each image layer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Build comma-separated list of lower directories for mount options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Construct overlay mount options string:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //         \"lowerdir=/layer1:/layer2,upperdir=/upper,workdir=/work\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Mount overlay filesystem to merged directory using mount() syscall</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify overlay mount succeeded by checking merged directory content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Store all directory paths in overlay structure for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Lower directories must be listed in bottom-to-top layer order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Work directory must be on same filesystem as upper directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Implements orchestration control loop for multi-container deployment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> reconcile_deployment_state</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">deployment_state_t</span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\"> deployment</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Compare desired container count vs actual running container count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check dependency ordering - don't start containers before dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each missing container: create container_config_t and call container_create()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each extra container: call container_destroy() to remove excess</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: For each running container: verify health and restart if failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update service registry with any container IP/port changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return 0 if desired state achieved, -1 if actions still needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use check_container_dependencies() before starting new containers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Allow time for containers to start before marking reconciliation complete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints</strong></p>\n<p>For C implementation of the extensions:</p>\n<ul>\n<li><strong>User Namespace Mappings</strong>: Use <code>sprintf()</code> to format UID/GID mapping strings, then write them to <code>/proc/[pid]/uid_map</code> and <code>/proc/[pid]/gid_map</code> using regular file operations</li>\n<li><strong>Overlay Filesystem</strong>: The mount() syscall for overlay requires specific option format: <code>mount(&quot;overlay&quot;, &quot;/merged&quot;, &quot;overlay&quot;, 0, &quot;lowerdir=...,upperdir=...,workdir=...&quot;)</code></li>\n<li><strong>Service Discovery</strong>: Use POSIX threads (<code>pthread_create</code>) for background health checking and cleanup processes</li>\n<li><strong>Image Layer Extraction</strong>: Use <code>libarchive</code> or simple <code>tar</code> command execution for extracting layer archives</li>\n<li><strong>Container Coordination</strong>: Implement timeout handling using <code>select()</code> or <code>poll()</code> for non-blocking communication</li>\n</ul>\n<p><strong>Milestone Checkpoints</strong></p>\n<p>After implementing additional namespaces:</p>\n<ul>\n<li>Run <code>unshare --user --map-root-user whoami</code> to verify user namespace concepts</li>\n<li>Test that container process sees itself as UID 0 while host sees different UID</li>\n<li>Verify hostname isolation by setting different hostnames in containers</li>\n</ul>\n<p>After implementing image management:</p>\n<ul>\n<li>Create simple layered image with base layer + application layer</li>\n<li>Verify overlay mount shows combined view of all layers</li>\n<li>Test that changes in container don&#39;t affect original image layers</li>\n</ul>\n<p>After implementing basic orchestration:</p>\n<ul>\n<li>Start multi-container deployment with dependencies (database → web server)</li>\n<li>Verify service discovery allows web server to find database</li>\n<li>Test that failed containers are automatically restarted</li>\n</ul>\n<p>These extensions represent the natural evolution from basic container isolation to production-ready container platforms, demonstrating how fundamental namespace and cgroups concepts scale to complex distributed systems.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides definitions for all technical terms used across milestones 1-4, establishing a common vocabulary for container implementation concepts including namespaces, cgroups, and container-specific terminology.</p>\n</blockquote>\n<h3 id=\"mental-model-technical-dictionary-for-container-architecture\">Mental Model: Technical Dictionary for Container Architecture</h3>\n<p>Think of this glossary as a technical dictionary specifically for container systems, similar to how medical professionals have specialized dictionaries that define terms precisely for their field. Just as &quot;hypertension&quot; has a specific medical meaning beyond &quot;high blood pressure,&quot; container terminology has precise technical meanings that distinguish it from general computing concepts. For example, while &quot;isolation&quot; generally means &quot;separation,&quot; in the container context it specifically refers to kernel-enforced boundaries that prevent processes from accessing resources outside their designated namespace.</p>\n<p>This glossary serves as your reference manual when implementing containers, ensuring that when we discuss &quot;pivot_root&quot; or &quot;zombie reaping,&quot; you understand not just the general concept but the specific technical implementation details and system call behaviors involved.</p>\n<h3 id=\"core-container-concepts\">Core Container Concepts</h3>\n<p>The fundamental building blocks of container technology center around Linux kernel features that provide isolation and resource control. Understanding these concepts is essential before diving into implementation details.</p>\n<p><strong>Process isolation</strong> refers to the kernel-enforced separation of processes so they cannot interfere with each other&#39;s execution, memory space, or system resources. This goes beyond simple process boundaries to include isolated views of system resources like process IDs, filesystems, and network stacks. Process isolation forms the foundation of container security and resource management.</p>\n<p><strong>Namespaces</strong> are Linux kernel features that provide isolated views of system resources to different process groups. Each namespace type isolates a different category of system resources, allowing processes within a namespace to have their own private view while sharing the underlying kernel. Namespaces are the primary mechanism for achieving process isolation in containers.</p>\n<p><strong>Cgroups</strong> (control groups) are Linux kernel features that limit, account for, and control resource usage by groups of processes. While namespaces provide isolation by changing what processes can see, cgroups provide control by limiting what resources processes can consume. Cgroups enforce memory limits, CPU quotas, and process limits to prevent containers from consuming excessive system resources.</p>\n<h3 id=\"system-call-and-kernel-interface-terms\">System Call and Kernel Interface Terms</h3>\n<p>Container implementation relies heavily on specific Linux system calls and kernel interfaces that manage process creation, namespace manipulation, and resource control.</p>\n<p><strong>Clone() system call</strong> creates a new process with specified namespace isolation flags, allowing fine-grained control over which namespaces the new process inherits versus creates fresh. Unlike fork() which creates processes in the same namespaces, clone() enables selective namespace isolation during process creation.</p>\n<p><strong>Pivot_root</strong> is a system call operation that atomically changes the filesystem root directory and moves the old root to a specified location. This operation is essential for container filesystem isolation because it ensures the container process cannot access the original host filesystem tree after the switch.</p>\n<p><strong>Zombie reaping</strong> refers to the process of collecting exit status information from terminated child processes to prevent them from remaining as zombie processes in the process table. In PID namespaces, the init process (PID 1) becomes responsible for reaping all orphaned processes within the namespace.</p>\n<h3 id=\"namespace-types-and-isolation-mechanisms\">Namespace Types and Isolation Mechanisms</h3>\n<p>Each namespace type provides isolation for a specific category of system resources, creating independent views for processes within different namespaces.</p>\n<p><strong>PID namespace</strong> isolates the process ID numbering system, allowing processes in different PID namespaces to have overlapping process IDs. The first process created in a PID namespace becomes PID 1 within that namespace, regardless of its PID in the parent namespace. This enables containers to have their own process tree starting from PID 1.</p>\n<p><strong>Mount namespace</strong> isolates the filesystem mount table, allowing processes in different mount namespaces to have different views of the filesystem hierarchy. Changes to mounts within a mount namespace do not affect other namespaces, enabling containers to have private filesystem layouts.</p>\n<p><strong>Network namespace</strong> isolates the network stack including network interfaces, routing tables, firewall rules, and network statistics. Each network namespace has its own loopback interface and can contain different sets of network devices, enabling complete network isolation between containers.</p>\n<p><strong>User namespace</strong> isolates user and group ID mappings, allowing processes to have different effective user IDs inside versus outside the namespace. This enables containers to run as root within their namespace while mapping to unprivileged users on the host system.</p>\n<p><strong>UTS namespace</strong> isolates system hostname and domain name, allowing different containers to have different hostnames without affecting the host system or other containers.</p>\n<p><strong>IPC namespace</strong> isolates System V IPC objects (message queues, semaphore sets, shared memory segments) and POSIX message queues, ensuring that containers cannot interfere with each other&#39;s inter-process communication mechanisms.</p>\n<h3 id=\"container-configuration-and-management-terms\">Container Configuration and Management Terms</h3>\n<p>Container runtime systems require structured configuration and management interfaces to coordinate the creation and lifecycle of isolated environments.</p>\n<p><strong>Container configuration</strong> refers to the structured specification that defines all parameters for creating a container instance, including filesystem paths, resource limits, network settings, and namespace options. This configuration serves as the blueprint for constructing the isolated environment.</p>\n<p><strong>Container instance</strong> represents an active container with running processes, created namespaces, and allocated resources. The instance maintains references to namespace file descriptors and cleanup information required for proper resource management.</p>\n<p><strong>Namespace handles</strong> are file descriptor references to active namespaces that enable operations on existing namespaces and ensure proper cleanup when containers terminate. These handles prevent namespaces from disappearing while still in use and enable tools to enter existing namespaces.</p>\n<p><strong>Cleanup list</strong> is a mechanism for tracking resource cleanup functions that must be executed in specific order during container shutdown or failure recovery. The cleanup list ensures that partially created containers release all allocated resources properly.</p>\n<h3 id=\"filesystem-and-mount-management-terms\">Filesystem and Mount Management Terms</h3>\n<p>Container filesystem isolation relies on sophisticated mount manipulation and filesystem virtualization techniques.</p>\n<p><strong>Mount propagation</strong> controls how mount and unmount events spread between different mount namespaces. Private propagation prevents mount events from leaking between namespaces, while shared propagation allows coordination when needed.</p>\n<p><strong>Bind mount</strong> creates a mount that makes an existing directory or file accessible at an additional location in the filesystem tree. Bind mounts enable containers to access specific host directories while maintaining overall filesystem isolation.</p>\n<p><strong>Essential filesystems</strong> are kernel virtual filesystems like /proc, /sys, and /dev that provide interfaces to kernel functionality and device access. Containers typically mount their own instances of these filesystems to maintain isolation while providing necessary system interfaces.</p>\n<p><strong>Filesystem isolation</strong> prevents containers from accessing parts of the host filesystem tree outside their designated rootfs directory. This isolation is achieved through mount namespaces and careful mount table configuration.</p>\n<p><strong>Old root</strong> refers to the previous root filesystem location after a pivot_root operation has switched to a new root. The old root is typically unmounted and removed to complete the filesystem switch.</p>\n<h3 id=\"network-infrastructure-terms\">Network Infrastructure Terms</h3>\n<p>Container networking involves creating isolated network stacks and establishing connectivity between containers and external networks.</p>\n<p><strong>Veth pair</strong> is a virtual ethernet device pair where packets sent to one end appear on the other end, enabling communication between different network namespaces. One end typically remains in the host namespace while the other moves to the container namespace.</p>\n<p><strong>Bridge networking</strong> connects multiple veth pairs to a virtual bridge device, enabling communication between multiple containers and providing a common broadcast domain for inter-container networking.</p>\n<p><strong>NAT</strong> (Network Address Translation) enables containers with private IP addresses to communicate with external networks by translating between private container addresses and public host addresses.</p>\n<h3 id=\"resource-control-and-enforcement-terms\">Resource Control and Enforcement Terms</h3>\n<p>Cgroups provide fine-grained resource control and enforcement mechanisms for container workloads.</p>\n<p><strong>Resource controllers</strong> are cgroup subsystems that manage specific resource types such as memory, CPU time, process counts, or I/O bandwidth. Each controller implements accounting, limiting, and priority mechanisms for its resource type.</p>\n<p><strong>Memory controller</strong> is the cgroup controller that tracks memory usage and enforces memory limits for groups of processes. It can limit various types of memory including RSS, page cache, and kernel memory allocations.</p>\n<p><strong>CPU controller</strong> is the cgroup controller that manages CPU time allocation through quota and period mechanisms. It can enforce both absolute CPU limits and relative priority through shares and bandwidth controls.</p>\n<p><strong>Process controller</strong> is the cgroup controller that limits the number of processes and threads that can exist within a cgroup. This prevents fork bombs and ensures fair process allocation across containers.</p>\n<p><strong>OOM killer</strong> is the kernel mechanism that terminates processes when memory is exhausted and no more memory can be freed through normal reclaim. In containers, the OOM killer operates within memory cgroup boundaries.</p>\n<p><strong>CPU quota</strong> specifies the maximum amount of CPU time a cgroup can consume within a given scheduling period. Quotas are expressed in microseconds and enforce hard limits on CPU usage.</p>\n<p><strong>Hierarchical cleanup</strong> is a cleanup strategy that ensures processes are terminated before their containing cgroups are removed, preventing resource leaks and ensuring proper kernel resource release.</p>\n<h3 id=\"error-handling-and-debugging-terms\">Error Handling and Debugging Terms</h3>\n<p>Container systems must handle various failure modes and provide debugging capabilities for troubleshooting isolation issues.</p>\n<p><strong>Container startup sequence</strong> refers to the step-by-step process of creating all required namespaces, setting up resource limits, configuring networking, and launching the container process. Each step has dependencies and specific error handling requirements.</p>\n<p><strong>Container cleanup sequence</strong> is the proper teardown order for releasing container resources including terminating processes, unmounting filesystems, removing network interfaces, and cleaning up cgroups. Cleanup order is critical to avoid resource leaks.</p>\n<p><strong>Error propagation</strong> describes how errors in one container component affect other components during setup or operation. For example, mount namespace failures can prevent network namespace setup if shared directories are required.</p>\n<p><strong>Parent-child synchronization</strong> coordinates actions between the host process creating a container and the container process being created. Synchronization ensures setup steps occur in the correct order across namespace boundaries.</p>\n<p><strong>Execution context</strong> refers to whether operations occur within the host namespace context or within container namespace contexts. Many operations must occur in specific execution contexts to be effective.</p>\n<h3 id=\"container-lifecycle-and-state-management-terms\">Container Lifecycle and State Management Terms</h3>\n<p>Container systems must track and manage the lifecycle of container instances from creation through termination.</p>\n<p><strong>Dependency relationships</strong> describe how different container components rely on each other for proper operation. For example, network namespace setup depends on successful PID namespace creation for process coordination.</p>\n<p><strong>Resource exhaustion</strong> occurs when system resources such as memory, CPU, or process slots are depleted, potentially affecting container operation. Container systems must handle exhaustion gracefully and provide appropriate error reporting.</p>\n<p><strong>Partial cleanup</strong> describes situations where some cleanup operations succeed while others fail during container shutdown. Systems must track cleanup state and retry failed operations to prevent resource leaks.</p>\n<p><strong>Cleanup ordering dependencies</strong> define the sequence requirements for resource cleanup operations. For example, processes must be terminated before their cgroups can be removed, and network interfaces must be removed before network namespaces can be destroyed.</p>\n<h3 id=\"testing-and-verification-terms\">Testing and Verification Terms</h3>\n<p>Container implementations require comprehensive testing to verify isolation properties and resource enforcement.</p>\n<p><strong>Isolation verification tests</strong> validate that namespace boundaries actually prevent processes from accessing resources outside their designated namespaces. These tests ensure that isolation mechanisms work as intended.</p>\n<p><strong>Resource limit testing</strong> verifies that cgroup controllers prevent containers from exceeding their configured resource allocations. Testing must validate both soft limits and hard enforcement mechanisms.</p>\n<p><strong>Milestone checkpoints</strong> are concrete verification steps that validate successful implementation of specific container features. Each checkpoint tests a specific aspect of isolation or resource control.</p>\n<p><strong>PID namespace isolation</strong> testing verifies that process IDs are properly isolated between container and host, and that the container init process correctly handles its responsibilities as PID 1.</p>\n<p><strong>Mount namespace isolation</strong> testing verifies that filesystem changes within containers do not affect the host filesystem and that containers cannot access unauthorized host directories.</p>\n<p><strong>Network namespace isolation</strong> testing verifies that container network interfaces are isolated from host interfaces and that network configuration changes within containers do not affect host networking.</p>\n<p><strong>Memory limit enforcement</strong> testing verifies that memory controllers prevent containers from exceeding configured memory limits and that OOM conditions are handled appropriately.</p>\n<p><strong>CPU limit enforcement</strong> testing verifies that CPU controllers restrict container CPU usage to configured percentages and that CPU quota mechanisms work correctly.</p>\n<p><strong>Process limit enforcement</strong> testing verifies that process controllers prevent containers from creating more processes than configured limits allow.</p>\n<h3 id=\"advanced-container-features-terms\">Advanced Container Features Terms</h3>\n<p>Beyond basic isolation, container systems can implement additional features for image management and orchestration.</p>\n<p><strong>Container image layers</strong> are read-only filesystem layers that stack together to form a complete container filesystem. Layers enable sharing of common components between different container images.</p>\n<p><strong>Overlay filesystem</strong> is a union filesystem that combines multiple read-only layers with a read-write layer to create a single directory tree. Overlay filesystems enable efficient copy-on-write semantics for container filesystems.</p>\n<p><strong>Copy-on-write</strong> is a filesystem optimization where files are shared between containers until modified, at which point they are copied to a container-specific writable layer. This reduces storage usage and improves container startup performance.</p>\n<p><strong>Content-addressable storage</strong> is a storage system where data is accessed using cryptographic hashes of content rather than location-based paths. This enables deduplication and integrity verification for container image layers.</p>\n<p><strong>Service discovery</strong> provides mechanisms for containers to locate and communicate with other services without hardcoded network addresses. Service discovery adapts to dynamic container deployment and network changes.</p>\n<p><strong>Container orchestration</strong> coordinates multiple containers as a cohesive application, handling deployment, scaling, networking, and failure recovery across multiple container instances.</p>\n<p><strong>Deployment specification</strong> is a configuration document that describes the desired state of a multi-container application including container images, resource requirements, networking, and dependencies.</p>\n<p><strong>Control loop</strong> is a continuous process that compares desired application state with actual running state and takes corrective actions to reconcile differences. Control loops enable declarative container management.</p>\n<p><strong>Load balancing</strong> distributes incoming requests across multiple container instances to improve performance and availability. Load balancing requires service discovery and health monitoring capabilities.</p>\n<p><strong>Inter-container communication</strong> encompasses networking mechanisms that allow containers to communicate with each other while maintaining security boundaries. This includes service meshes, overlay networks, and service discovery.</p>\n<p><strong>Service registry</strong> maintains a database of available services and their current network endpoints, enabling dynamic service discovery as containers start, stop, and move between hosts.</p>\n<p><strong>Container lifecycle management</strong> coordinates container startup, health monitoring, failure detection, restart policies, and graceful shutdown across the entire container lifecycle.</p>\n<p><strong>Dependency management</strong> ensures containers start in the correct order based on service dependencies and waits for required services to become available before starting dependent containers.</p>\n<p><strong>Hierarchical resource allocation</strong> implements multi-level resource distribution from orchestration systems down to individual containers, ensuring fair resource sharing and preventing resource conflicts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Container systems involve complex interactions between kernel features and user-space management tools. Understanding the terminology provides a foundation for implementing these systems effectively.</p>\n<h4 id=\"key-terminology-categories\">Key Terminology Categories</h4>\n<table>\n<thead>\n<tr>\n<th>Category</th>\n<th>Core Terms</th>\n<th>Advanced Terms</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Isolation</td>\n<td>namespace, process isolation, PID namespace, mount namespace</td>\n<td>user namespace, UTS namespace, IPC namespace</td>\n</tr>\n<tr>\n<td>Resource Control</td>\n<td>cgroups, memory controller, CPU controller, process controller</td>\n<td>hierarchical resource allocation, resource exhaustion</td>\n</tr>\n<tr>\n<td>Networking</td>\n<td>network namespace, veth pair, bridge networking</td>\n<td>service discovery, load balancing</td>\n</tr>\n<tr>\n<td>Filesystem</td>\n<td>pivot_root, bind mount, essential filesystems</td>\n<td>overlay filesystem, copy-on-write, content-addressable storage</td>\n</tr>\n<tr>\n<td>Lifecycle</td>\n<td>container startup sequence, cleanup sequence, error propagation</td>\n<td>container orchestration, deployment specification, control loop</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>isolation verification, resource limit testing, milestone checkpoints</td>\n<td>integration testing, performance testing</td>\n</tr>\n</tbody></table>\n<h4 id=\"critical-distinction-isolation-vs-control\">Critical Distinction: Isolation vs Control</h4>\n<p>Understanding the distinction between isolation mechanisms (namespaces) and control mechanisms (cgroups) is fundamental to container implementation:</p>\n<ul>\n<li><strong>Namespaces change what processes can see</strong> - they provide different views of system resources</li>\n<li><strong>Cgroups change what processes can do</strong> - they limit and control resource consumption</li>\n<li><strong>Both mechanisms work together</strong> to create complete container isolation</li>\n</ul>\n<h4 id=\"container-vs-virtual-machine-terminology\">Container vs Virtual Machine Terminology</h4>\n<p>Container terminology often differs from virtual machine terminology, reflecting different architectural approaches:</p>\n<table>\n<thead>\n<tr>\n<th>Container Term</th>\n<th>VM Equivalent</th>\n<th>Key Difference</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>namespace</td>\n<td>virtual hardware</td>\n<td>shares kernel, isolates view</td>\n</tr>\n<tr>\n<td>cgroups</td>\n<td>resource allocation</td>\n<td>dynamic limits, shared resources</td>\n</tr>\n<tr>\n<td>container image</td>\n<td>VM image</td>\n<td>layered, content-addressable</td>\n</tr>\n<tr>\n<td>container runtime</td>\n<td>hypervisor</td>\n<td>process-based, not hardware virtualization</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-terminology-mistakes\">Common Terminology Mistakes</h4>\n<p>⚠️ <strong>Pitfall: Confusing &quot;container&quot; with &quot;containerization&quot;</strong></p>\n<ul>\n<li><strong>Container</strong> refers to a specific running instance with isolated namespaces</li>\n<li><strong>Containerization</strong> refers to the general practice of packaging applications</li>\n<li><strong>Fix</strong>: Use &quot;container instance&quot; for running containers, &quot;container image&quot; for static packages</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Using &quot;Docker&quot; and &quot;container&quot; interchangeably</strong></p>\n<ul>\n<li><strong>Docker</strong> is a specific container runtime implementation</li>\n<li><strong>Container</strong> refers to the general Linux kernel isolation technology</li>\n<li><strong>Fix</strong>: Use &quot;container runtime&quot; or &quot;container engine&quot; for implementations, &quot;container&quot; for the isolated process</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Confusing &quot;mount namespace&quot; with &quot;filesystem&quot;</strong></p>\n<ul>\n<li><strong>Mount namespace</strong> isolates the mount table (what&#39;s mounted where)</li>\n<li><strong>Filesystem</strong> refers to the actual data storage format</li>\n<li><strong>Fix</strong>: Mount namespaces control mount points, filesystems store data</li>\n</ul>\n<h4 id=\"debugging-terminology-usage\">Debugging Terminology Usage</h4>\n<p>When debugging container issues, precise terminology helps communicate problems effectively:</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Imprecise Description</th>\n<th>Precise Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process visible outside container</td>\n<td>&quot;Container not isolated&quot;</td>\n<td>&quot;PID namespace isolation failure&quot;</td>\n</tr>\n<tr>\n<td>Cannot access host directory</td>\n<td>&quot;Filesystem broken&quot;</td>\n<td>&quot;Mount namespace bind mount missing&quot;</td>\n</tr>\n<tr>\n<td>Network not working</td>\n<td>&quot;Container networking broken&quot;</td>\n<td>&quot;Network namespace veth pair misconfigured&quot;</td>\n</tr>\n<tr>\n<td>Container using too much memory</td>\n<td>&quot;Resource problem&quot;</td>\n<td>&quot;Memory controller limit not enforced&quot;</td>\n</tr>\n</tbody></table>\n<p>This precise terminology enables faster diagnosis and resolution of container implementation issues.</p>\n","toc":[{"level":1,"text":"Container (Basic): Design Document","id":"container-basic-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: Apartment Building","id":"mental-model-apartment-building"},{"level":3,"text":"Existing Isolation Approaches","id":"existing-isolation-approaches"},{"level":4,"text":"Virtual Machines: Maximum Isolation, Maximum Overhead","id":"virtual-machines-maximum-isolation-maximum-overhead"},{"level":4,"text":"Chroot Jails: Filesystem Isolation Only","id":"chroot-jails-filesystem-isolation-only"},{"level":4,"text":"Containers: Balanced Isolation and Efficiency","id":"containers-balanced-isolation-and-efficiency"},{"level":4,"text":"Comparison Summary","id":"comparison-summary"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton","id":"core-logic-skeleton"},{"level":4,"text":"Language-Specific Implementation Notes","id":"language-specific-implementation-notes"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Mental Model: Building a Safe Playground","id":"mental-model-building-a-safe-playground"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Core Isolation Capabilities","id":"core-isolation-capabilities"},{"level":4,"text":"Resource Control Requirements","id":"resource-control-requirements"},{"level":4,"text":"Configuration and Lifecycle Management","id":"configuration-and-lifecycle-management"},{"level":4,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":3,"text":"Non-Goals","id":"non-goals"},{"level":4,"text":"Container Image Management","id":"container-image-management"},{"level":4,"text":"Container Orchestration and Clustering","id":"container-orchestration-and-clustering"},{"level":4,"text":"Advanced Security Features","id":"advanced-security-features"},{"level":4,"text":"Performance Optimization and Enterprise Features","id":"performance-optimization-and-enterprise-features"},{"level":4,"text":"Network Policy and Advanced Networking","id":"network-policy-and-advanced-networking"},{"level":4,"text":"Storage and Filesystem Features","id":"storage-and-filesystem-features"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structure Implementation","id":"core-data-structure-implementation"},{"level":4,"text":"Core API Skeleton","id":"core-api-skeleton"},{"level":4,"text":"System Call Wrapper Functions","id":"system-call-wrapper-functions"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"Container Orchestrator Responsibilities","id":"container-orchestrator-responsibilities"},{"level":4,"text":"Namespace Manager Coordination","id":"namespace-manager-coordination"},{"level":4,"text":"Cgroup Manager Integration","id":"cgroup-manager-integration"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Header File Organization","id":"header-file-organization"},{"level":4,"text":"Source File Responsibilities","id":"source-file-responsibilities"},{"level":4,"text":"Build and Test Organization","id":"build-and-test-organization"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Essential Data Structures","id":"essential-data-structures"},{"level":4,"text":"Utility Functions Implementation","id":"utility-functions-implementation"},{"level":4,"text":"Container Orchestrator Skeleton","id":"container-orchestrator-skeleton"},{"level":4,"text":"File Organization Implementation","id":"file-organization-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Container Configuration","id":"container-configuration"},{"level":3,"text":"Namespace Handles","id":"namespace-handles"},{"level":3,"text":"Cleanup List Management","id":"cleanup-list-management"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structure Definitions","id":"core-data-structure-definitions"},{"level":4,"text":"Configuration Management Implementation","id":"configuration-management-implementation"},{"level":4,"text":"Cleanup System Implementation","id":"cleanup-system-implementation"},{"level":4,"text":"Instance Management Skeleton","id":"instance-management-skeleton"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Data Structure Issues","id":"debugging-data-structure-issues"},{"level":2,"text":"PID Namespace Component","id":"pid-namespace-component"},{"level":3,"text":"Mental Model: Hotel Room Numbers","id":"mental-model-hotel-room-numbers"},{"level":3,"text":"PID Namespace Interface","id":"pid-namespace-interface"},{"level":3,"text":"Init Process Responsibilities","id":"init-process-responsibilities"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Mount Namespace Component","id":"mount-namespace-component"},{"level":3,"text":"Mental Model: Stage Sets","id":"mental-model-stage-sets"},{"level":3,"text":"Mount Namespace Interface","id":"mount-namespace-interface"},{"level":3,"text":"Pivot Root Process","id":"pivot-root-process"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Network Namespace Component","id":"network-namespace-component"},{"level":3,"text":"Mental Model: Private Phone Systems","id":"mental-model-private-phone-systems"},{"level":3,"text":"Network Namespace Interface","id":"network-namespace-interface"},{"level":3,"text":"Veth Pair Configuration","id":"veth-pair-configuration"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Cgroups Resource Management Component","id":"cgroups-resource-management-component"},{"level":3,"text":"Mental Model: Budget Allocation","id":"mental-model-budget-allocation"},{"level":3,"text":"Cgroups Interface","id":"cgroups-interface"},{"level":3,"text":"Resource Controllers","id":"resource-controllers"},{"level":4,"text":"Memory Controller","id":"memory-controller"},{"level":4,"text":"CPU Controller","id":"cpu-controller"},{"level":4,"text":"Process Controller (PIDs)","id":"process-controller-pids"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Container Startup Sequence","id":"container-startup-sequence"},{"level":3,"text":"Container Cleanup Sequence","id":"container-cleanup-sequence"},{"level":3,"text":"Error Propagation","id":"error-propagation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Namespace Creation Failures","id":"namespace-creation-failures"},{"level":3,"text":"Resource Exhaustion","id":"resource-exhaustion"},{"level":3,"text":"Cleanup Failures","id":"cleanup-failures"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: Laboratory Safety Testing","id":"mental-model-laboratory-safety-testing"},{"level":3,"text":"Isolation Verification Tests","id":"isolation-verification-tests"},{"level":3,"text":"Resource Limit Testing","id":"resource-limit-testing"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Namespace Issues","id":"namespace-issues"},{"level":4,"text":"PID Namespace Debugging","id":"pid-namespace-debugging"},{"level":4,"text":"Mount Namespace Debugging","id":"mount-namespace-debugging"},{"level":4,"text":"Network Namespace Debugging","id":"network-namespace-debugging"},{"level":3,"text":"Cgroups Issues","id":"cgroups-issues"},{"level":4,"text":"Cgroups Hierarchy and Controller Issues","id":"cgroups-hierarchy-and-controller-issues"},{"level":4,"text":"Resource Limit Enforcement Debugging","id":"resource-limit-enforcement-debugging"},{"level":3,"text":"Debugging Tools and Techniques","id":"debugging-tools-and-techniques"},{"level":4,"text":"Essential Debugging Commands","id":"essential-debugging-commands"},{"level":4,"text":"Advanced Debugging Techniques","id":"advanced-debugging-techniques"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Debugging Infrastructure Code","id":"debugging-infrastructure-code"},{"level":4,"text":"Core Debugging Function Skeletons","id":"core-debugging-function-skeletons"},{"level":4,"text":"Language-Specific Debugging Hints","id":"language-specific-debugging-hints"},{"level":4,"text":"Milestone Debugging Checkpoints","id":"milestone-debugging-checkpoints"},{"level":4,"text":"Common Debugging Scenarios","id":"common-debugging-scenarios"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Additional Namespaces: User, UTS, and IPC Namespace Support","id":"additional-namespaces-user-uts-and-ipc-namespace-support"},{"level":3,"text":"Image Management: Container Image Layers and Overlay Filesystems","id":"image-management-container-image-layers-and-overlay-filesystems"},{"level":3,"text":"Container Orchestration: Multi-Container Coordination and Service Discovery","id":"container-orchestration-multi-container-coordination-and-service-discovery"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: Technical Dictionary for Container Architecture","id":"mental-model-technical-dictionary-for-container-architecture"},{"level":3,"text":"Core Container Concepts","id":"core-container-concepts"},{"level":3,"text":"System Call and Kernel Interface Terms","id":"system-call-and-kernel-interface-terms"},{"level":3,"text":"Namespace Types and Isolation Mechanisms","id":"namespace-types-and-isolation-mechanisms"},{"level":3,"text":"Container Configuration and Management Terms","id":"container-configuration-and-management-terms"},{"level":3,"text":"Filesystem and Mount Management Terms","id":"filesystem-and-mount-management-terms"},{"level":3,"text":"Network Infrastructure Terms","id":"network-infrastructure-terms"},{"level":3,"text":"Resource Control and Enforcement Terms","id":"resource-control-and-enforcement-terms"},{"level":3,"text":"Error Handling and Debugging Terms","id":"error-handling-and-debugging-terms"},{"level":3,"text":"Container Lifecycle and State Management Terms","id":"container-lifecycle-and-state-management-terms"},{"level":3,"text":"Testing and Verification Terms","id":"testing-and-verification-terms"},{"level":3,"text":"Advanced Container Features Terms","id":"advanced-container-features-terms"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Key Terminology Categories","id":"key-terminology-categories"},{"level":4,"text":"Critical Distinction: Isolation vs Control","id":"critical-distinction-isolation-vs-control"},{"level":4,"text":"Container vs Virtual Machine Terminology","id":"container-vs-virtual-machine-terminology"},{"level":4,"text":"Common Terminology Mistakes","id":"common-terminology-mistakes"},{"level":4,"text":"Debugging Terminology Usage","id":"debugging-terminology-usage"}],"title":"Container (Basic): Design Document","markdown":"# Container (Basic): Design Document\n\n\n## Overview\n\nThis system implements a basic container runtime using Linux namespaces and cgroups to achieve process isolation. The key architectural challenge is coordinating multiple kernel isolation mechanisms (PID, mount, network namespaces) with resource controls while handling the subtle timing and lifecycle management issues that arise from namespace interactions.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides foundational context for all milestones (1-4), establishing why process isolation is necessary before implementing PID, mount, network namespaces, and cgroups.\n\nModern computing environments face a fundamental challenge: how can multiple processes, applications, or users safely share the same physical machine without interfering with each other? This problem becomes particularly acute when running untrusted code, deploying applications with conflicting dependencies, or managing multi-tenant systems where isolation and resource fairness are critical.\n\nThe core issue stems from the traditional Unix process model, where all processes share the same global namespace for process IDs, filesystem mounts, network interfaces, and system resources. While Unix permissions provide some level of access control, they don't address the deeper problems of resource contention, dependency conflicts, and the blast radius of misbehaving applications. A runaway process can consume all available CPU or memory, affecting every other process on the system. Applications with conflicting library versions cannot coexist peacefully. Network services can interfere with each other by binding to the same ports.\n\n**Process isolation** addresses these challenges by creating controlled boundaries around groups of processes, giving each group its own view of system resources while maintaining efficient resource sharing at the kernel level. Unlike full machine virtualization, process isolation operates at a much finer granularity, allowing for lightweight separation that scales to hundreds or thousands of isolated environments on a single host.\n\nThis design document explores the implementation of a basic container runtime that leverages Linux kernel features—specifically namespaces and cgroups—to achieve robust process isolation. The system we'll build demonstrates how these kernel primitives can be orchestrated to create secure, resource-controlled execution environments that are both lighter weight than virtual machines and more secure than traditional process separation.\n\n### Mental Model: Apartment Building\n\nThink of a computer system as a large apartment building, and processes as the various tenants living in it. In the traditional Unix model, it's as if all tenants share one massive communal space with no private rooms, no individual mailboxes, and no separate utility meters. Everyone can see everyone else's belongings (process tree), use anyone's phone line (network interfaces), rearrange the shared furniture (filesystem mounts), and there's no way to prevent one tenant from using all the electricity (CPU and memory resources).\n\nThis communal arrangement creates obvious problems. If one tenant decides to play loud music at 3 AM (a CPU-intensive process), everyone suffers. If someone rearranges all the furniture (modifies global filesystem mounts), it affects everyone's daily routine. When the mail arrives, anyone can read anyone else's letters (no process isolation). And if someone leaves the water running (memory leak), the entire building's utilities suffer.\n\n**Containers provide each tenant with their own private apartment within the same building.** Each apartment has:\n\n- **Private room numbering** (PID namespace): Inside apartment 3B, the rooms might be numbered 1, 2, 3, but these numbers are completely independent from apartment 4A's room numbering. A tenant in 3B who thinks they're in \"room 1\" might actually be in the building's room 847 from the building manager's perspective.\n\n- **Individual interior layouts** (mount namespace): Each apartment can arrange their furniture, hang pictures, and organize their space completely independently. One tenant might prefer a minimalist setup while another fills every corner. These choices don't affect neighboring apartments.\n\n- **Separate phone/internet lines** (network namespace): Each apartment gets its own phone number and internet connection. Tenants can't accidentally answer each other's phones or interfere with each other's network traffic.\n\n- **Individual utility budgets** (cgroups): The building manager allocates specific amounts of electricity, water, and heating to each apartment. If one tenant tries to run too many appliances, their circuit breaker trips, but other apartments continue running normally.\n\nThe building manager (kernel) maintains the overall infrastructure—the structural walls, main electrical system, water mains, and building-wide policies. But within each apartment's boundaries, tenants operate independently. They can't see into other apartments, can't consume more than their allocated resources, and can't break things in ways that affect their neighbors.\n\nThis apartment model captures the essential insight of containerization: **strong isolation boundaries within shared infrastructure**. The kernel provides the \"building\" (hardware resources, core services), while containers provide the \"apartments\" (isolated process environments with controlled resource access).\n\nJust as apartment buildings are more efficient than giving each tenant their own house (virtual machines), containers are more efficient than full virtualization while still providing the isolation benefits tenants need.\n\n### Existing Isolation Approaches\n\nBefore diving into container implementation, it's important to understand the landscape of existing isolation approaches and why containers occupy a unique position in the design space. Each approach represents different trade-offs between isolation strength, resource efficiency, and operational complexity.\n\n#### Virtual Machines: Maximum Isolation, Maximum Overhead\n\nVirtual machines provide the strongest isolation by running complete, separate operating system instances on virtualized hardware. Each VM gets its own kernel, its own device drivers, and its own complete view of virtualized hardware resources.\n\n| Aspect | Description | Trade-offs |\n|--------|-------------|------------|\n| **Isolation Boundary** | Hardware virtualization layer | Complete OS-level separation |\n| **Resource Overhead** | Full OS + kernel per instance | 512MB-2GB+ memory per VM |\n| **Startup Time** | Full OS boot sequence | 30+ seconds typical |\n| **Resource Efficiency** | Poor - duplicate kernels, drivers | 10-50 VMs per host typical |\n| **Security Model** | Hypervisor-enforced boundaries | Very strong - different kernels |\n| **Failure Blast Radius** | Contained to single VM | Hypervisor bugs affect all VMs |\n\nVirtual machines excel when you need to run different operating systems, when you require maximum security isolation (different kernels can't interfere), or when you need to emulate specific hardware configurations. However, their resource overhead makes them impractical for microservice architectures where you might want to run hundreds of small, specialized services.\n\n#### Chroot Jails: Filesystem Isolation Only\n\nThe `chroot` system call, introduced in Unix Version 7, provides a much lighter-weight isolation mechanism by changing a process's view of the filesystem root. A process running in a chroot jail cannot access files outside its designated directory tree.\n\n| Aspect | Description | Trade-offs |\n|--------|-------------|------------|\n| **Isolation Boundary** | Filesystem namespace only | No process, network, or resource isolation |\n| **Resource Overhead** | Minimal - shared kernel | Nearly zero overhead |\n| **Startup Time** | Near-instantaneous | Milliseconds |\n| **Resource Efficiency** | Excellent for filesystem isolation | Hundreds per host easily |\n| **Security Model** | Filesystem access control only | Weak - shared PID space, network |\n| **Failure Blast Radius** | Processes can still interfere | No resource or process boundaries |\n\nChroot jails are useful for specific scenarios like FTP servers or build environments where you primarily need filesystem isolation. However, they provide no protection against resource exhaustion attacks, processes can still see and potentially interfere with each other, and network resources remain completely shared. A process in a chroot jail can still consume all system memory or CPU, affecting every other process on the host.\n\n#### Containers: Balanced Isolation and Efficiency\n\nContainers represent a middle ground that combines multiple Linux kernel isolation primitives to create process-level isolation boundaries that are much stronger than chroot but lighter weight than full virtualization.\n\n| Aspect | Description | Trade-offs |\n|--------|-------------|------------|\n| **Isolation Boundary** | Multiple namespace types + cgroups | Process, filesystem, network, resource isolation |\n| **Resource Overhead** | Shared kernel, isolated userspace | 10-50MB typical per container |\n| **Startup Time** | Process startup time | Milliseconds to seconds |\n| **Resource Efficiency** | Very good - shared kernel | 100s-1000s per host |\n| **Security Model** | Kernel-enforced namespace boundaries | Strong within same kernel |\n| **Failure Blast Radius** | Isolated by namespace and cgroups | Kernel vulnerabilities affect all |\n\n**The key insight that makes containers practical** is that most application isolation requirements don't actually need separate kernels. Applications typically need:\n- Their own process tree (PID namespace)\n- Their own filesystem view (mount namespace) \n- Their own network stack (network namespace)\n- Controlled resource allocation (cgroups)\n\nBut they can safely share the same kernel, device drivers, and core system services. This sharing dramatically reduces memory overhead—instead of 500MB+ per virtual machine, containers might use 10-50MB each.\n\n> **Design Insight**: Containers optimize for the common case where applications need isolation from each other but not from the underlying operating system. This allows much higher density while maintaining practical isolation boundaries.\n\n#### Comparison Summary\n\n| Criteria | Virtual Machines | Chroot Jails | Containers | Best Use Case |\n|----------|------------------|--------------|------------|---------------|\n| **Isolation Strength** | Maximum | Minimal | Strong | VMs for different OSes |\n| **Resource Efficiency** | Poor | Excellent | Very Good | Containers for microservices |\n| **Operational Complexity** | High | Low | Medium | Chroot for simple filesystem isolation |\n| **Security Boundaries** | Hypervisor | Filesystem only | Multiple namespaces | VMs for untrusted multi-tenant |\n| **Density** | 10-50/host | 1000s/host | 100s-1000s/host | Containers for application packaging |\n| **Startup Performance** | Slow | Instant | Fast | Containers for elastic scaling |\n\nThe fundamental architectural decision in our container implementation is to leverage this balanced approach: **strong enough isolation for most application security and interference requirements, while maintaining the resource efficiency needed for modern microservice architectures**.\n\nOur basic container runtime will demonstrate how to coordinate Linux namespaces (PID, mount, network) with cgroups (resource limits) to achieve this balance. The system provides process-level isolation that prevents applications from interfering with each other while allowing efficient resource sharing through a common kernel.\n\nThis approach makes containers particularly well-suited for:\n- **Microservice architectures** where you need many small, isolated services\n- **CI/CD pipelines** where you need fast, clean build environments\n- **Development environments** where you need consistent, reproducible setups\n- **Multi-tenant applications** where you need fair resource sharing\n\nThe trade-off is that all containers share the same kernel, so kernel-level vulnerabilities or crashes can affect all containers on a host. For scenarios requiring maximum security isolation, virtual machines remain the better choice. But for the vast majority of application deployment scenarios, containers provide an excellent balance of isolation, efficiency, and operational simplicity.\n\n### Implementation Guidance\n\nThe theoretical understanding of isolation approaches provides the foundation for practical container implementation. This section bridges the gap between understanding why containers are useful and actually building one using Linux kernel primitives.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Recommendation for Learning |\n|-----------|---------------|-----------------|----------------------------|\n| **Language** | C with basic syscalls | Go with advanced libraries | C - direct kernel interaction |\n| **Namespace Creation** | `clone()` system call | `unshare()` + `fork()` | Start with `clone()` - single step |\n| **Process Management** | Basic `wait()` loops | Signalfd + epoll | Basic `wait()` - easier debugging |\n| **Network Setup** | Shell commands via `system()` | Netlink sockets | Shell commands - fewer dependencies |\n| **Cgroups Interface** | Direct filesystem writes | libcgroup or systemd | Direct filesystem - clearer understanding |\n| **Error Handling** | Simple errno checking | Structured error types | errno checking - matches kernel interface |\n\n#### Recommended File Structure\n\nUnderstanding the isolation concepts leads naturally to a modular code organization that mirrors the conceptual separation:\n\n```c\ncontainer-basic/\n├── src/\n│   ├── main.c                    ← Entry point and command parsing\n│   ├── container.h               ← Main container API definitions\n│   ├── container.c               ← Container lifecycle orchestration\n│   ├── namespace/\n│   │   ├── namespace.h           ← Common namespace utilities\n│   │   ├── pid_namespace.c       ← PID isolation (Milestone 1)\n│   │   ├── mount_namespace.c     ← Filesystem isolation (Milestone 2)\n│   │   └── network_namespace.c   ← Network isolation (Milestone 3)\n│   ├── cgroups/\n│   │   ├── cgroups.h             ← Resource limit interface\n│   │   ├── cgroups.c             ← Cgroups management (Milestone 4)\n│   │   └── limits.c              ← Specific limit controllers\n│   └── utils/\n│       ├── error.h               ← Error handling utilities\n│       ├── error.c               ← Error reporting and cleanup\n│       └── syscall_wrappers.c    ← Safe syscall wrapper functions\n├── tests/\n│   ├── test_pid_namespace.c      ← PID isolation verification\n│   ├── test_mount_namespace.c    ← Filesystem isolation tests\n│   ├── test_network_namespace.c  ← Network isolation tests\n│   └── test_cgroups.c           ← Resource limit tests\n├── examples/\n│   ├── simple_container.c        ← Basic usage example\n│   └── isolated_shell.c         ← Interactive container demo\n└── Makefile                      ← Build configuration\n```\n\nThis structure reflects the apartment building model: the main `container.c` file acts as the building manager, coordinating between different isolation mechanisms (the namespace/ modules) and resource management (the cgroups/ module).\n\n#### Infrastructure Starter Code\n\nSince the focus is on learning namespace and cgroups coordination, here's complete starter code for error handling and utility functions:\n\n**src/utils/error.h**:\n```c\n#ifndef ERROR_H\n#define ERROR_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n\n// Error reporting macros that preserve errno and provide context\n#define LOG_ERROR(msg) do { \\\n    fprintf(stderr, \"ERROR [%s:%d]: %s: %s\\n\", \\\n            __FILE__, __LINE__, (msg), strerror(errno)); \\\n} while(0)\n\n#define LOG_INFO(msg) do { \\\n    printf(\"INFO: %s\\n\", (msg)); \\\n} while(0)\n\n#define HANDLE_ERROR(condition, msg) do { \\\n    if (condition) { \\\n        LOG_ERROR(msg); \\\n        return -1; \\\n    } \\\n} while(0)\n\n// Cleanup helper for partial failures\ntypedef struct cleanup_list {\n    void (*cleanup_func)(void *data);\n    void *data;\n    struct cleanup_list *next;\n} cleanup_list_t;\n\n// Register cleanup function to call on failure\nvoid register_cleanup(cleanup_list_t **list, void (*func)(void*), void *data);\n\n// Execute all registered cleanup functions\nvoid execute_cleanup(cleanup_list_t **list);\n\n#endif /* ERROR_H */\n```\n\n**src/utils/syscall_wrappers.c**:\n```c\n#define _GNU_SOURCE\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <sched.h>\n#include \"error.h\"\n\n// Safe wrapper for clone() syscall with error checking\npid_t safe_clone(int (*fn)(void *), void *stack, int flags, void *arg) {\n    pid_t pid;\n    \n    // Validate stack pointer (common mistake)\n    if (!stack) {\n        errno = EINVAL;\n        return -1;\n    }\n    \n    pid = clone(fn, stack, flags, arg);\n    if (pid == -1) {\n        LOG_ERROR(\"clone() failed\");\n        return -1;\n    }\n    \n    return pid;\n}\n\n// Safe wrapper for mount() with detailed error reporting\nint safe_mount(const char *source, const char *target, \n               const char *filesystemtype, unsigned long mountflags,\n               const void *data) {\n    int result = mount(source, target, filesystemtype, mountflags, data);\n    if (result == -1) {\n        char error_msg[256];\n        snprintf(error_msg, sizeof(error_msg), \n                \"mount(%s, %s, %s) failed\", \n                source ? source : \"NULL\",\n                target ? target : \"NULL\", \n                filesystemtype ? filesystemtype : \"NULL\");\n        LOG_ERROR(error_msg);\n        return -1;\n    }\n    return 0;\n}\n\n// Create directory with parent directories, ignore if exists\nint ensure_directory(const char *path) {\n    char cmd[512];\n    snprintf(cmd, sizeof(cmd), \"mkdir -p %s\", path);\n    int result = system(cmd);\n    if (result != 0) {\n        LOG_ERROR(\"Failed to create directory\");\n        return -1;\n    }\n    return 0;\n}\n```\n\n#### Core Logic Skeleton\n\nThe learner implements the main coordination logic that orchestrates namespace creation and cgroup setup. This skeleton maps directly to the conceptual understanding from the apartment building model:\n\n**src/container.h**:\n```c\n#ifndef CONTAINER_H\n#define CONTAINER_H\n\n#include <sys/types.h>\n#include <stdint.h>\n\n// Container configuration - the \"apartment lease agreement\"\ntypedef struct container_config {\n    char *rootfs_path;           // Path to container filesystem root\n    char *hostname;              // Container hostname (UTS namespace)\n    \n    // Resource limits (cgroups configuration)\n    size_t memory_limit_bytes;   // Memory limit (0 = unlimited)\n    int cpu_percent;             // CPU percentage (0-100, 0 = unlimited)\n    int max_processes;           // Maximum number of processes\n    \n    // Network configuration\n    char *bridge_name;           // Host bridge to connect to\n    char *container_ip;          // IP address for container\n    \n    // Command to run inside container\n    char **argv;                 // Command and arguments\n    char **envp;                 // Environment variables\n} container_config_t;\n\n// Container instance - tracks the \"apartment tenant\"\ntypedef struct container_instance {\n    pid_t child_pid;             // Main process PID in container\n    int namespace_fds[6];        // File descriptors for namespaces\n    char *cgroup_path;           // Path to container's cgroup\n    cleanup_list_t *cleanup;     // Cleanup functions for failure recovery\n} container_instance_t;\n\n// Main container lifecycle functions\nint container_create(const container_config_t *config, \n                    container_instance_t *container);\nint container_wait(container_instance_t *container);\nint container_destroy(container_instance_t *container);\n\n#endif /* CONTAINER_H */\n```\n\n**src/container.c** (skeleton for learner implementation):\n```c\n#include \"container.h\"\n#include \"namespace/namespace.h\"\n#include \"cgroups/cgroups.h\"\n#include \"utils/error.h\"\n\n// Child process entry point - runs inside all namespaces\nstatic int container_child_main(void *arg) {\n    container_config_t *config = (container_config_t *)arg;\n    \n    // TODO 1: Set up mount namespace and pivot to new root\n    // Hint: Call mount_namespace_setup(config->rootfs_path)\n    // This gives the container its own filesystem view\n    \n    // TODO 2: Set up network namespace networking  \n    // Hint: Call network_namespace_setup(config->container_ip)\n    // This configures the container's network interface\n    \n    // TODO 3: Set hostname in UTS namespace\n    // Hint: Use sethostname(config->hostname, strlen(config->hostname))\n    \n    // TODO 4: Set up minimal /proc and /sys filesystems\n    // Hint: mount(\"proc\", \"/proc\", \"proc\", 0, NULL)\n    //       mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL)\n    \n    // TODO 5: Drop privileges if running as root\n    // Hint: This is a good place to switch to non-root user\n    \n    // TODO 6: Execute the target command\n    // Hint: execve(config->argv[0], config->argv, config->envp)\n    // This should never return on success\n    \n    return -1; // Should never reach here\n}\n\nint container_create(const container_config_t *config, \n                    container_instance_t *container) {\n    char *stack;\n    pid_t child_pid;\n    \n    // TODO 1: Create cgroups and set resource limits\n    // Hint: Call cgroups_create_and_configure(config, &container->cgroup_path)\n    // This must happen before clone() so child can be added to cgroup\n    \n    // TODO 2: Allocate stack for clone() call\n    // Hint: Use malloc(STACK_SIZE) and adjust for stack growth direction\n    // Remember: stacks grow downward on most architectures\n    \n    // TODO 3: Call clone() with appropriate namespace flags\n    // Hint: flags = CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUTS\n    // Use safe_clone() wrapper to create child in new namespaces\n    \n    // TODO 4: Add child process to cgroup\n    // Hint: Call cgroups_add_process(container->cgroup_path, child_pid)\n    // This enforces resource limits on the container process tree\n    \n    // TODO 5: Set up network connectivity from host side\n    // Hint: Call network_setup_host_side(child_pid, config->bridge_name)\n    // This creates veth pair and configures bridge connection\n    \n    // TODO 6: Store namespace file descriptors for cleanup\n    // Hint: Open /proc/child_pid/ns/* files and store in container->namespace_fds\n    // These allow cleanup even if child process exits\n    \n    container->child_pid = child_pid;\n    return 0;\n}\n\nint container_wait(container_instance_t *container) {\n    int status;\n    \n    // TODO 1: Wait for container process to exit\n    // Hint: Use waitpid(container->child_pid, &status, 0)\n    // This blocks until the container's main process terminates\n    \n    // TODO 2: Handle zombie process reaping\n    // Hint: Container may have spawned child processes that need reaping\n    // Check for additional processes in the PID namespace\n    \n    // TODO 3: Return exit status from container process\n    // Hint: Use WEXITSTATUS(status) if WIFEXITED(status)\n    \n    return 0;\n}\n\nint container_destroy(container_instance_t *container) {\n    // TODO 1: Terminate container process if still running\n    // Hint: Send SIGTERM, wait briefly, then SIGKILL if needed\n    \n    // TODO 2: Clean up network interfaces\n    // Hint: Remove veth pair and bridge configuration\n    \n    // TODO 3: Remove cgroup and clean up hierarchy\n    // Hint: Call cgroups_destroy(container->cgroup_path)\n    \n    // TODO 4: Close namespace file descriptors\n    // Hint: Close all fds in container->namespace_fds array\n    \n    // TODO 5: Execute any registered cleanup functions\n    // Hint: execute_cleanup(&container->cleanup)\n    \n    return 0;\n}\n```\n\n#### Language-Specific Implementation Notes\n\nWorking with Linux namespaces and cgroups in C requires attention to several system-specific details:\n\n**Stack Management for clone():**\n```c\n#define STACK_SIZE (1024 * 1024)  // 1MB stack\n\n// Allocate stack growing downward (most architectures)\nchar *stack = malloc(STACK_SIZE);\nchar *stack_top = stack + STACK_SIZE;  // Point to high address\n```\n\n**Namespace Flags Reference:**\n```c\n// Common namespace combinations\n#define CONTAINER_NS_FLAGS (CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | \\\n                           CLONE_NEWUTS | CLONE_NEWIPC)\n\n// For testing individual namespaces\n#define PID_ONLY_FLAGS CLONE_NEWPID\n#define MOUNT_ONLY_FLAGS CLONE_NEWNS\n```\n\n**Cgroups Filesystem Paths:**\n```c\n// Check which cgroups version is available\n#define CGROUPS_V1_PATH \"/sys/fs/cgroup\"\n#define CGROUPS_V2_PATH \"/sys/fs/cgroup/unified\"\n\n// Container-specific cgroup naming\n#define CONTAINER_CGROUP_PREFIX \"container-basic\"\n```\n\n#### Milestone Checkpoints\n\nAfter implementing each milestone, verify the isolation is working correctly:\n\n**Milestone 1 - PID Namespace Checkpoint:**\n```bash\n# Compile and run\nmake && ./container-basic /bin/bash\n\n# Inside container, check process isolation\nps aux                    # Should only see processes in container\necho $$                   # Should show PID 1\ncat /proc/sys/kernel/pid_max  # Should work (need /proc mounted)\n\n# Outside container (different terminal)\nps aux | grep container-basic  # Should see real host PID\n```\n\n**Expected behavior:** Container process sees itself as PID 1 and can only see processes within its PID namespace. Host can see the container process with its real PID.\n\n**Milestone 2 - Mount Namespace Checkpoint:**\n```bash\n# Run container with custom rootfs\n./container-basic -r ./test-rootfs /bin/sh\n\n# Inside container\nls /                      # Should see only container filesystem\nmount | grep proc         # Should show container's /proc mount\ntouch /test-file          # Should not appear on host filesystem\n\n# Outside container\nls /                      # Should see normal host filesystem  \nls ./test-rootfs/         # Should see test-file if bind-mounted\n```\n\n**Expected behavior:** Container has completely different filesystem view. Changes inside container don't affect host filesystem unless explicitly bind-mounted.\n\n**Signs something is wrong:**\n- Container sees host filesystem: Mount namespace not created properly\n- Container can't access /proc: Forgot to mount proc filesystem inside container\n- pivot_root fails: Check that new root has old_root directory and is on different filesystem\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** This section defines the scope for all milestones (1-4), establishing clear boundaries for what our basic container runtime will implement versus advanced features left for future development.\n\n### Mental Model: Building a Safe Playground\n\nThink of our container system like designing a safe playground for children. We need to provide essential safety features - fences to keep kids in the right area (process isolation), separate sandboxes so they don't interfere with each other (namespaces), and rules about how many swings each child can use (resource limits). However, we're not building a full amusement park with roller coasters, water slides, and gift shops (advanced orchestration features). Our goal is a functional, safe playground that demonstrates the core safety mechanisms, not a commercial-grade entertainment complex.\n\nJust as a playground designer must decide which safety features are essential versus which amenities can be added later, we must clearly define what isolation primitives are fundamental to container functionality versus what advanced features would distract from learning the core concepts. This section establishes those boundaries to keep our implementation focused and educational.\n\n### Functional Goals\n\nOur basic container runtime must provide the four fundamental pillars of container technology: process isolation, filesystem isolation, network isolation, and resource control. These represent the minimum viable container implementation that demonstrates how modern container runtimes like Docker and containerd work under the hood.\n\n#### Core Isolation Capabilities\n\nThe primary functional goal is implementing **process isolation** through Linux namespaces. Our container must create isolated views of system resources so that processes inside the container cannot interfere with or observe processes on the host system or in other containers. This isolation forms the security boundary that makes containers useful for running untrusted code safely.\n\n| Isolation Type | Namespace | Goal Description |\n|---|---|---|\n| Process Tree | PID | Container processes see isolated PID numbering starting from PID 1 |\n| Filesystem | Mount | Container has private filesystem root with essential system directories |\n| Network Stack | Network | Container has isolated network interfaces and routing tables |\n| System Identity | UTS | Container can have different hostname without affecting host |\n| Inter-Process Communication | IPC | Container has private message queues and shared memory segments |\n\nThe **PID namespace** isolation must ensure that the container's init process appears as PID 1 within the container while the host sees the real process ID. This creates the fundamental process boundary that prevents container processes from sending signals to host processes or observing the full system process tree. The container's init process must properly handle zombie reaping responsibilities that normally belong to the system's init process.\n\n**Filesystem isolation** through mount namespaces must provide a private filesystem view where the container can mount and unmount filesystems without affecting the host. Our implementation must use `pivot_root` to switch the container to a new filesystem root, mount essential filesystems like `/proc` and `/sys` inside the container, and ensure that mount operations inside the container don't propagate to the host system.\n\n**Network isolation** through network namespaces must give the container its own network stack with private interfaces, routing tables, and firewall rules. The container should be able to bind to any port without conflicting with host services, and we must implement connectivity between the container and host using veth pairs connected to a bridge network.\n\n#### Resource Control Requirements\n\nThe second pillar is **resource limitation** through Linux cgroups. Our container must prevent runaway processes from consuming all system resources and affecting other containers or host processes. This implements the \"noisy neighbor\" protection essential for multi-tenant systems.\n\n| Resource Type | Control Mechanism | Goal Description |\n|---|---|---|\n| Memory | Memory Controller | Hard limit on RAM usage with OOM killing when exceeded |\n| CPU | CPU Controller | Proportional CPU time allocation using quota and period |\n| Processes | PIDs Controller | Maximum number of processes to prevent fork bombs |\n| File Descriptors | Files Controller | Limit open file handles to prevent descriptor exhaustion |\n\nThe memory controller must enforce hard limits where processes are killed by the Out-of-Memory (OOM) killer when they exceed their allocation. This prevents memory leaks or memory-intensive applications from consuming all system RAM. Our implementation must demonstrate both setting the limit and observing the enforcement behavior when limits are exceeded.\n\nCPU control must implement proportional sharing using the CPU quota and period mechanism. Rather than hard CPU limits (which can cause performance issues), our container should receive a guaranteed minimum CPU allocation while being able to burst above that allocation when CPU is available. This provides predictable performance isolation without wasting resources.\n\n#### Configuration and Lifecycle Management\n\nOur container runtime must provide a clean configuration interface and proper lifecycle management. The configuration should be declarative, specifying desired resource limits and networking parameters without requiring users to understand the underlying namespace and cgroup implementation details.\n\n| Lifecycle Phase | Required Capabilities |\n|---|---|\n| Creation | Parse configuration, validate parameters, prepare filesystem |\n| Startup | Create namespaces, setup cgroups, fork container process |\n| Running | Monitor container process, handle signals, maintain isolation |\n| Cleanup | Destroy namespaces, remove cgroups, cleanup filesystem mounts |\n\nThe container creation process must validate that all specified parameters are achievable (sufficient memory available, valid network configuration, accessible root filesystem) before beginning namespace creation. This prevents partial container creation that leaves system resources in an inconsistent state.\n\nContainer cleanup must be robust and handle partial failure scenarios. If namespace creation fails partway through, the cleanup process must remove any successfully created namespaces and cgroups. This prevents resource leaks that could accumulate over time and affect system stability.\n\n#### Error Handling and Recovery\n\nOur container runtime must gracefully handle common failure scenarios and provide meaningful error messages that help users diagnose configuration problems. The most common failures involve insufficient privileges, missing kernel features, and resource exhaustion.\n\n| Failure Category | Detection Method | Recovery Action |\n|---|---|---|\n| Insufficient Privileges | Check for CAP_SYS_ADMIN before namespace creation | Provide clear error about required capabilities |\n| Missing Kernel Features | Test namespace creation with CLONE_* flags | Report which namespaces are unsupported |\n| Resource Exhaustion | Monitor cgroup creation and process limits | Fail fast with resource availability information |\n| Configuration Errors | Validate filesystem paths and network parameters | Report specific configuration problems |\n\nThe error handling must distinguish between temporary failures (resource exhaustion) and permanent failures (missing kernel features). Temporary failures should be retryable, while permanent failures should provide guidance on system requirements or configuration changes needed.\n\n### Non-Goals\n\nClearly defining what we will NOT implement is equally important as defining our goals. These non-goals keep our implementation focused on learning core container isolation primitives rather than building a production container runtime with enterprise features.\n\n#### Container Image Management\n\nWe will NOT implement container image formats, image layers, or image registries. Our container will work with a simple directory containing a root filesystem, not with Docker images, OCI images, or layered filesystems. This means no support for:\n\n- Image pulling from registries like Docker Hub\n- Image layer caching and deduplication\n- Dockerfile parsing and image building\n- Image vulnerability scanning\n- Multi-architecture image support\n\nThe rationale is that image management is a separate concern from process isolation. Understanding how to create namespaces and cgroups is independent of understanding how to manage layered filesystems. Implementing image support would require overlay filesystems, cryptographic hash validation, and network protocols that would distract from the core learning objectives.\n\nUsers will need to prepare their own root filesystem directory containing the files and directory structure needed for their containerized application. This could be created by extracting an existing Docker image or by manually assembling the required files.\n\n#### Container Orchestration and Clustering\n\nWe will NOT implement multi-container coordination, service discovery, or container orchestration features. Our runtime will manage single containers in isolation without any knowledge of other containers or cluster-wide policies. This excludes:\n\n- Container scheduling across multiple hosts\n- Service mesh and load balancing between containers\n- Container health checks and automatic restart policies\n- Volume management and persistent storage\n- Secrets management and configuration distribution\n- Rolling updates and blue-green deployment strategies\n\nThese features belong to container orchestration platforms like Kubernetes, Docker Swarm, or Nomad. Our basic container runtime serves as the foundation that orchestrators build upon, but implementing orchestration features would require distributed systems concepts (consensus, leader election, cluster membership) that are beyond our scope.\n\n#### Advanced Security Features\n\nWe will NOT implement advanced security isolation beyond basic namespaces. Our security model relies on namespace isolation and assumes containers run with appropriate user privileges. We will not provide:\n\n- User namespace mapping for rootless containers  \n- SELinux or AppArmor integration for mandatory access control\n- Seccomp filtering to restrict system call access\n- Container image signing and signature verification\n- Runtime security monitoring and anomaly detection\n- Network policy enforcement and micro-segmentation\n\nWhile these features are important for production container security, they require deep knowledge of Linux security modules and cryptographic systems. Our basic implementation demonstrates the fundamental isolation mechanisms that these advanced features build upon.\n\n#### Performance Optimization and Enterprise Features\n\nWe will NOT implement performance optimizations or enterprise-grade reliability features. Our focus is on correctness and educational value, not on production performance or scalability. This means no:\n\n- Container startup time optimization through pre-warming or caching\n- Resource usage monitoring and metrics collection  \n- Log aggregation and centralized logging infrastructure\n- Backup and disaster recovery for container data\n- High availability and failover mechanisms\n- Performance profiling and resource usage analytics\n\nThese features would require sophisticated monitoring infrastructure, storage systems, and distributed computing concepts that would obscure the core container isolation mechanisms we're trying to understand.\n\n> **Key Design Principle**: We prioritize understanding over features. Every component we implement must clearly demonstrate a core container isolation concept. Any feature that doesn't directly contribute to understanding namespaces, cgroups, or basic container lifecycle is explicitly out of scope.\n\n#### Network Policy and Advanced Networking\n\nWhile we implement basic container networking through veth pairs and bridge networking, we will NOT implement advanced networking features that production container platforms provide:\n\n- Network policies and firewall rule management\n- Service mesh integration with encrypted inter-container communication\n- Load balancing and traffic routing between containers\n- Network address translation (NAT) with port forwarding rules\n- VLAN tagging and advanced network topologies\n- Container network interface (CNI) plugin architecture\n\nOur networking implementation demonstrates how containers achieve network isolation and basic connectivity. Advanced networking features require understanding of network protocols, traffic engineering, and distributed networking concepts that are separate from the core isolation mechanisms.\n\n#### Storage and Filesystem Features\n\nBeyond basic mount namespace isolation, we will NOT implement advanced storage features:\n\n- Volume mounting with different filesystem types\n- Container data persistence across container restarts\n- Filesystem encryption and secure data handling\n- Storage quotas and disk usage monitoring\n- Snapshot and backup functionality for container filesystems\n- Distributed storage integration\n\nOur filesystem isolation demonstrates how containers achieve private filesystem views using mount namespaces and `pivot_root`. Storage management involves understanding filesystem drivers, storage protocols, and data durability concepts that would distract from namespace learning objectives.\n\n### Implementation Guidance\n\nThis subsection provides concrete technical recommendations for implementing the goals defined above while avoiding the complexity of features marked as non-goals.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Namespace Creation | `clone()` system call with `CLONE_NEW*` flags | `unshare()` with separate process creation |\n| Mount Management | Direct `mount()` and `pivot_root()` calls | `libmount` library for complex mount operations |\n| Network Setup | Manual veth and bridge creation via netlink | CNI (Container Network Interface) plugins |\n| Cgroups Interface | Direct filesystem writes to `/sys/fs/cgroup` | `libcgroup` library for abstraction |\n| Configuration Format | Simple key-value text file or command line args | YAML/JSON with schema validation |\n| Error Reporting | `errno` values with `perror()` messages | Structured error codes with detailed context |\n\nFor learning purposes, choose the simple options to understand the underlying mechanisms directly. Advanced options abstract away the details we want to understand.\n\n#### Recommended File Structure\n\nOrganize the codebase to separate concerns and make testing easier:\n\n```\ncontainer-basic/\n├── src/\n│   ├── main.c                    ← CLI entry point and argument parsing\n│   ├── container.c               ← Core container lifecycle (create/wait/destroy)\n│   ├── container.h               ← Public API and data structure definitions\n│   ├── namespaces.c              ← Namespace creation and management\n│   ├── mounts.c                  ← Filesystem mounting and pivot_root\n│   ├── network.c                 ← Network namespace and veth setup\n│   ├── cgroups.c                 ← Resource limit configuration\n│   ├── cleanup.c                 ← Error recovery and resource cleanup\n│   └── utils.c                   ← Helper functions and system call wrappers\n├── tests/\n│   ├── test_isolation.c          ← Verify namespace isolation works\n│   ├── test_resources.c          ← Verify cgroup limits are enforced\n│   └── test_networking.c         ← Verify container networking\n├── rootfs/                       ← Sample root filesystem for testing\n│   ├── bin/\n│   ├── etc/\n│   └── proc/                     ← Will be mounted inside container\n└── Makefile                      ← Build system with test targets\n```\n\n#### Core Data Structure Implementation\n\nImplement the configuration and instance structures to match our naming conventions:\n\n```c\n// container.h - Core data structures\n\n#include <sys/types.h>\n#include <unistd.h>\n\n#define STACK_SIZE (1024 * 1024)\n#define CONTAINER_NS_FLAGS (CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUTS | CLONE_NEWIPC)\n#define CGROUPS_V1_PATH \"/sys/fs/cgroup\"\n#define CGROUPS_V2_PATH \"/sys/fs/cgroup/unified\"\n#define CONTAINER_CGROUP_PREFIX \"container-basic\"\n\n// Container configuration - what the user specifies\ntypedef struct {\n    char *rootfs_path;           // Path to container root filesystem\n    char *hostname;              // Container hostname (UTS namespace)\n    size_t memory_limit_bytes;   // Memory limit in bytes (0 = no limit)\n    int cpu_percent;             // CPU percentage (0-100, 0 = no limit)\n    int max_processes;           // Maximum process count (0 = no limit)\n    char *bridge_name;           // Host bridge name for networking\n    char *container_ip;          // IP address for container\n    char **argv;                 // Command and arguments to run\n    char **envp;                 // Environment variables\n} container_config_t;\n\n// Container instance - runtime state and cleanup handles\ntypedef struct {\n    pid_t child_pid;             // PID of container init process\n    int namespace_fds[6];        // File descriptors for namespaces (PID, mount, net, UTS, IPC, user)\n    char *cgroup_path;           // Path to container's cgroup directory\n    struct cleanup_list *cleanup; // Linked list of cleanup functions\n} container_instance_t;\n\n// Cleanup function registration for error recovery\ntypedef struct cleanup_list {\n    void (*cleanup_func)(void *); // Function to call for cleanup\n    void *data;                   // Data to pass to cleanup function\n    struct cleanup_list *next;    // Next cleanup function in list\n} cleanup_list_t;\n```\n\n#### Core API Skeleton\n\nImplement the main container API functions with detailed TODOs mapping to the milestone requirements:\n\n```c\n// container.c - Main container lifecycle implementation\n\n/**\n * container_create - Create and start a new container\n * @config: Container configuration specifying resources and command\n * @container: Output parameter filled with container instance data\n * \n * Returns: 0 on success, -1 on failure (check errno for details)\n */\nint container_create(const container_config_t *config, container_instance_t *container) {\n    // TODO 1: Validate configuration parameters (rootfs_path exists, memory_limit reasonable, etc.)\n    // TODO 2: Initialize cleanup list for error recovery\n    // TODO 3: Create cgroup hierarchy and set resource limits (Milestone 4)\n    // TODO 4: Prepare container root filesystem and create necessary directories\n    // TODO 5: Allocate stack for clone() call (use STACK_SIZE constant)\n    // TODO 6: Call safe_clone() with CONTAINER_NS_FLAGS and container init function\n    // TODO 7: In parent: store child PID and namespace file descriptors\n    // TODO 8: In parent: setup networking (create veth pair, configure bridge) (Milestone 3)\n    // TODO 9: In parent: move container process into cgroup\n    // TODO 10: Return success, container instance now contains cleanup handles\n    // Error handling: call execute_cleanup() if any step fails\n}\n\n/**\n * container_wait - Wait for container process to exit\n * @container: Container instance to wait for\n * \n * Returns: Exit status of container process, -1 on error\n */\nint container_wait(container_instance_t *container) {\n    // TODO 1: Use waitpid() to wait for child_pid\n    // TODO 2: Handle SIGCHLD signals appropriately  \n    // TODO 3: Return WEXITSTATUS() for normal exit, WTERMSIG() for signals\n    // Hint: Use WIFEXITED() and WIFSIGNALED() to distinguish exit types\n}\n\n/**\n * container_destroy - Clean up all container resources\n * @container: Container instance to destroy\n * \n * Returns: 0 on success, -1 if some cleanup failed\n */\nint container_destroy(container_instance_t *container) {\n    // TODO 1: Send SIGTERM to container process if still running\n    // TODO 2: Wait for graceful shutdown, then SIGKILL if necessary\n    // TODO 3: Execute all registered cleanup functions\n    // TODO 4: Close namespace file descriptors\n    // TODO 5: Remove cgroup directory and all files\n    // TODO 6: Free allocated memory in container instance\n    // Note: Continue cleanup even if some steps fail, return overall status\n}\n```\n\n#### System Call Wrapper Functions\n\nImplement safe wrappers for system calls that provide better error reporting:\n\n```c\n// utils.c - System call wrappers with error handling\n\n/**\n * safe_clone - Wrapper for clone() with error checking and logging\n */\npid_t safe_clone(int (*fn)(void *), void *stack, int flags, void *arg) {\n    // TODO 1: Calculate stack top address (stack grows down on most architectures)\n    // TODO 2: Call clone() with provided parameters\n    // TODO 3: Check for -1 return value and log specific error\n    // TODO 4: For EPERM errors, suggest checking capabilities\n    // TODO 5: For EINVAL errors, check which CLONE_ flags are unsupported\n    // Hint: Use strerror(errno) for human-readable error messages\n}\n\n/**\n * safe_mount - Wrapper for mount() with detailed error reporting\n */\nint safe_mount(const char *source, const char *target, const char *filesystemtype, \n               unsigned long mountflags, const void *data) {\n    // TODO 1: Check that target directory exists before mounting\n    // TODO 2: Call mount() with provided parameters  \n    // TODO 3: On failure, log source, target, and filesystem type\n    // TODO 4: For EACCES, suggest checking permissions or capabilities\n    // TODO 5: For ENODEV, suggest checking if filesystem type is supported\n    // Hint: Print mount command equivalent for debugging\n}\n\n/**\n * register_cleanup - Add cleanup function to be called on error or exit\n */\nvoid register_cleanup(cleanup_list_t **list, void (*func)(void *), void *data) {\n    // TODO 1: Allocate new cleanup_list_t node\n    // TODO 2: Set function pointer and data\n    // TODO 3: Insert at head of linked list\n    // TODO 4: Handle malloc() failure gracefully\n}\n\n/**\n * execute_cleanup - Call all registered cleanup functions in reverse order\n */\nvoid execute_cleanup(cleanup_list_t *list) {\n    // TODO 1: Traverse linked list and call each cleanup function\n    // TODO 2: Pass stored data pointer to each function\n    // TODO 3: Continue even if cleanup functions fail\n    // TODO 4: Free cleanup_list_t nodes after calling functions\n    // TODO 5: Log any errors but don't propagate them\n}\n```\n\n#### Milestone Checkpoints\n\nAfter implementing each milestone, verify the functionality with these specific tests:\n\n**Milestone 1 (PID Namespace):**\n```bash\n# Compile and run basic PID namespace test\nmake test_pid_namespace\nsudo ./test_pid_namespace\n\n# Expected behavior:\n# - Container process reports PID 1 when running `echo $$`\n# - Host can see real PID (e.g., 12345) in process table\n# - Container cannot see host processes in `ps` output\n# - Container init properly reaps zombie child processes\n```\n\n**Milestone 2 (Mount Namespace):**\n```bash\n# Test filesystem isolation\nmake test_mount_namespace  \nsudo ./test_mount_namespace /tmp/test_rootfs\n\n# Expected behavior:\n# - Container sees different root filesystem than host\n# - Container can mount /proc and see only container processes\n# - Mount operations inside container don't affect host\n# - Container cannot access host filesystem outside mounted volumes\n```\n\n**Milestone 3 (Network Namespace):**\n```bash\n# Test network isolation and connectivity\nmake test_network_namespace\nsudo ./test_network_namespace\n\n# Expected behavior:\n# - Container has different network interfaces than host (ip addr show)\n# - Container can ping its own IP address\n# - Container can reach external networks through host bridge\n# - Host can communicate with container through veth pair\n```\n\n**Milestone 4 (Cgroups):**\n```bash\n# Test resource limits enforcement\nmake test_cgroups\nsudo ./test_cgroups --memory-limit=100M --cpu-percent=50\n\n# Expected behavior:\n# - Memory-intensive process gets OOM killed at 100MB\n# - CPU usage stays around 50% under sustained load\n# - Process count limited to configured maximum\n# - Cgroup files show current resource usage\n```\n\n#### Debugging Tips\n\nWhen container creation fails, use these debugging techniques:\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---|---|---|---|\n| clone() returns EPERM | Missing CAP_SYS_ADMIN | Run `getcap /path/to/binary` or check `id` | Run as root or add capabilities |\n| mount() fails with EACCES | SELinux or permission issue | Check `dmesg` and `/var/log/audit/audit.log` | Disable SELinux or fix context |\n| Container sees host processes | PID namespace not created | Check `/proc/self/ns/pid` in container | Verify CLONE_NEWPID flag |\n| Network unreachable | veth pair misconfigured | Run `ip addr` and `ip route` in container | Check bridge and routing setup |\n| Process killed immediately | Memory limit too low | Check `dmesg` for OOM killer messages | Increase memory limit or check usage |\n| Cgroup creation fails | cgroups v2 vs v1 mismatch | Check `/proc/filesystems` for cgroup2 | Use correct cgroup path and API |\n\nUse these inspection commands during debugging:\n- `lsns` - List all namespaces and their processes\n- `nsenter -t <pid> -p -n -m <command>` - Enter container namespaces\n- `cat /proc/<pid>/cgroup` - Show process cgroup membership\n- `cat /sys/fs/cgroup/memory/<cgroup>/memory.usage_in_bytes` - Check memory usage\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This section provides architectural foundation for all milestones (1-4), establishing the component structure and relationships needed to implement PID namespaces, mount namespaces, network namespaces, and cgroups resource management.\n\n### Component Overview\n\nThink of our container runtime as a **theater production company** that needs to set up completely isolated stages for different performances. Just as a theater company has specialized departments—set design (mount namespace), lighting and sound (network), casting and direction (process management), and budget control (resource limits)—our container runtime has specialized managers that coordinate to create perfect isolation for each \"performance\" (container).\n\nOur container runtime architecture centers around four core managers that work together to create process isolation. Each manager has a specific responsibility and operates semi-independently, but they must coordinate carefully during container startup and cleanup to avoid timing issues and resource leaks.\n\nThe **namespace managers** handle different aspects of process isolation. The PID namespace manager creates isolated process trees where the container's init process appears as PID 1. The mount namespace manager creates isolated filesystem views and handles the complex pivot_root operation to switch the container's root directory. The network namespace manager creates isolated network stacks and sets up connectivity through virtual ethernet pairs.\n\nThe **cgroup manager** operates orthogonally to the namespace managers, focusing purely on resource limits rather than isolation. It creates cgroup hierarchies and assigns the container process to appropriate cgroups with memory, CPU, and process limits configured.\n\nThese managers are coordinated by a **container orchestrator** that handles the precise sequencing required during container creation. This orchestration is critical because namespace creation must happen in a specific order, and cgroup assignment must occur at exactly the right moment in the process lifecycle.\n\n![Container System Component Overview](./diagrams/system-overview.svg)\n\nThe following table describes each major component and its primary responsibilities:\n\n| Component | Primary Responsibility | Key Operations | Dependencies |\n|-----------|----------------------|----------------|--------------|\n| Container Orchestrator | Coordinates startup/cleanup sequence | `container_create()`, `container_wait()`, `container_destroy()` | All managers |\n| PID Namespace Manager | Process isolation and PID 1 duties | `clone()` with `CLONE_NEWPID`, zombie reaping | None |\n| Mount Namespace Manager | Filesystem isolation | `unshare(CLONE_NEWNS)`, `pivot_root()`, essential mounts | PID namespace |\n| Network Namespace Manager | Network stack isolation | `unshare(CLONE_NEWNET)`, veth pair setup, bridge config | Mount namespace |\n| Cgroup Manager | Resource limit enforcement | Cgroup creation, process assignment, limit configuration | PID namespace |\n| Cleanup Manager | Resource cleanup and error recovery | Cleanup function registration and execution | All managers |\n\n> **Design Insight**: The key architectural challenge is that Linux kernel namespaces and cgroups were designed as independent mechanisms, but containers require them to work together seamlessly. Our architecture acknowledges this by keeping the managers loosely coupled but providing strong coordination through the orchestrator and cleanup system.\n\n#### Container Orchestrator Responsibilities\n\nThe container orchestrator serves as the main entry point and coordination layer. It maintains the `container_instance_t` structure that tracks all active resources associated with a container. During startup, it sequences the manager operations to avoid race conditions—for example, ensuring the PID namespace exists before attempting cgroup assignment, or ensuring mount namespace isolation before setting up network connectivity.\n\nThe orchestrator also implements the **cleanup registration pattern**. Each manager registers cleanup functions as it creates resources, building a cleanup chain that can be executed in reverse order during normal shutdown or error recovery. This approach ensures that even if container creation fails halfway through, all successfully created resources get properly cleaned up.\n\n#### Namespace Manager Coordination\n\nThe three namespace managers must coordinate carefully because kernel namespace operations have subtle ordering dependencies. The PID namespace manager always runs first because it fundamentally changes how process creation works—subsequent operations need to account for the new PID space. The mount namespace manager runs second because filesystem isolation affects where network configuration tools can find their resources. The network namespace manager runs last because it often needs to access files and execute commands that depend on the filesystem isolation being in place.\n\nEach namespace manager maintains file descriptors to the created namespaces in the `namespace_fds` array. These descriptors serve dual purposes: they keep the namespaces alive even if the initial process exits, and they provide handles for external tools like debuggers to enter the namespaces for inspection.\n\n#### Cgroup Manager Integration\n\nThe cgroup manager operates differently from the namespace managers because cgroups work through filesystem operations rather than system calls. It creates directories in the cgroup filesystem hierarchy, writes configuration files to set limits, and assigns process IDs to the appropriate cgroup. Unlike namespaces, cgroups can be modified after container startup, allowing for dynamic resource limit adjustments.\n\nThe cgroup manager must handle both cgroups v1 and v2 hierarchies because different Linux distributions use different defaults. It detects the available cgroup version at startup and adapts its filesystem paths and configuration syntax accordingly.\n\n> **Architecture Decision Record: Component Separation Strategy**\n> - **Context**: We need to organize namespace and resource management code that involves complex kernel interactions and precise timing\n> - **Options Considered**: \n>   1. Monolithic container creation function with all operations inline\n>   2. Separate managers with loose coupling and shared state\n>   3. Separate managers with strict interfaces and no shared state\n> - **Decision**: Separate managers with loose coupling through shared `container_instance_t` structure\n> - **Rationale**: Each type of isolation (PID, mount, network, cgroups) has distinct kernel APIs and failure modes that benefit from specialized handling, but they need to coordinate timing and share cleanup responsibilities\n> - **Consequences**: More complex orchestration logic but much better testability, debugging, and maintainability of individual isolation mechanisms\n\nThe following table compares the architectural options:\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Monolithic Function | Simple control flow, no coordination complexity | Impossible to test individual mechanisms, difficult to debug failures | No |\n| Loose Coupling | Easy coordination, shared cleanup, simple interfaces | Some shared state complexity | **Yes** |\n| Strict Separation | Perfect isolation, no shared state | Complex coordination, duplicate cleanup logic, rigid interfaces | No |\n\n### Recommended File Structure\n\nOrganizing the codebase properly from the beginning prevents the common mistake of putting all container logic in a single massive file. Our file structure reflects the component architecture and makes it easy to test individual managers in isolation while maintaining clear dependencies.\n\n```\ncontainer-basic/\n├── src/\n│   ├── main.c                    ← Entry point, argument parsing, basic container operations\n│   ├── container.h               ← Main public API and shared data structures\n│   ├── container.c               ← Container orchestrator implementation\n│   ├── namespaces/\n│   │   ├── pid_namespace.h       ← PID namespace manager interface\n│   │   ├── pid_namespace.c       ← PID namespace implementation, zombie reaping\n│   │   ├── mount_namespace.h     ← Mount namespace manager interface  \n│   │   ├── mount_namespace.c     ← Mount namespace, pivot_root, essential mounts\n│   │   ├── network_namespace.h   ← Network namespace manager interface\n│   │   └── network_namespace.c   ← Network namespace, veth pairs, bridge setup\n│   ├── cgroups/\n│   │   ├── cgroup_manager.h      ← Cgroup manager interface\n│   │   ├── cgroup_manager.c      ← Cgroup creation, limits, process assignment\n│   │   ├── cgroup_v1.c          ← Cgroups v1 specific implementation\n│   │   └── cgroup_v2.c          ← Cgroups v2 specific implementation\n│   ├── utils/\n│   │   ├── cleanup.h            ← Cleanup registration and execution\n│   │   ├── cleanup.c            ← Cleanup manager implementation\n│   │   ├── syscall_wrappers.h   ← Safe syscall wrappers with error handling\n│   │   ├── syscall_wrappers.c   ← Implementation of safe_clone, safe_mount, etc.\n│   │   └── logging.h            ← Logging utilities for debugging\n│   └── logging.c                ← Logging implementation\n├── tests/\n│   ├── test_container.c         ← Integration tests for full container lifecycle\n│   ├── test_pid_namespace.c     ← Unit tests for PID isolation\n│   ├── test_mount_namespace.c   ← Unit tests for filesystem isolation\n│   ├── test_network_namespace.c ← Unit tests for network isolation\n│   ├── test_cgroups.c           ← Unit tests for resource limits\n│   └── test_utils.c             ← Unit tests for utility functions\n├── examples/\n│   ├── simple_container.c       ← Basic usage example\n│   ├── resource_limited.c       ← Example with cgroup limits\n│   └── networked_container.c    ← Example with network connectivity\n├── rootfs/                      ← Example root filesystem for testing\n│   ├── bin/                     ← Basic utilities (busybox, etc.)\n│   ├── etc/                     ← Configuration files\n│   └── proc/                    ← Empty directory for /proc mount\n├── Makefile                     ← Build configuration\n└── README.md                    ← Build and usage instructions\n```\n\n#### Header File Organization\n\nThe header file structure follows a clear dependency hierarchy. The main `container.h` defines the core data structures (`container_config_t`, `container_instance_t`) and orchestrator functions. Individual manager headers define only their specific interfaces and can be included independently for unit testing.\n\nEach manager header includes comprehensive documentation comments describing the expected call sequences and error conditions. For example, `pid_namespace.h` documents that PID namespace creation must happen before any other namespace operations because it affects subsequent `clone()` calls.\n\n#### Source File Responsibilities\n\nEach source file has a single, well-defined responsibility. The `container.c` file implements only the orchestration logic—sequencing manager operations and coordinating cleanup. Individual manager files implement only their specific kernel interactions without knowledge of other managers.\n\nThe `utils/` directory contains all the infrastructure code that handles error-prone system calls. The `syscall_wrappers.c` file implements safe versions of `clone()`, `mount()`, `unshare()`, and other system calls with comprehensive error checking and logging. This centralization makes it easier to handle the subtle differences in error codes and failure modes across different Linux kernel versions.\n\n> **Architecture Decision Record: File Organization Strategy**\n> - **Context**: Container implementation involves multiple complex kernel APIs that need to work together but should be testable in isolation\n> - **Options Considered**:\n>   1. Single file with all container logic\n>   2. Separate files by namespace type with shared utilities\n>   3. Layered architecture with clear abstraction boundaries\n> - **Decision**: Separate files by namespace type with centralized utilities and clear interfaces\n> - **Rationale**: Each namespace type has distinct kernel APIs and testing requirements, but they share common patterns for error handling and cleanup that benefit from centralization\n> - **Consequences**: More files to manage but much better testability, easier debugging of specific namespace issues, and cleaner separation of concerns\n\nThe following table compares the file organization approaches:\n\n| Approach | Maintainability | Testability | Learning Curve | Chosen? |\n|----------|-----------------|-------------|----------------|---------|\n| Single File | Low - everything mixed together | Very low - can't test parts | Easy - everything in one place | No |\n| By Namespace | High - clear separation | High - isolated testing | Moderate - need to understand structure | **Yes** |\n| Layered | Highest - strict abstractions | Moderate - complex mocking | Hard - many abstraction layers | No |\n\n#### Build and Test Organization\n\nThe `Makefile` supports building individual components for testing, which is crucial during development. For example, `make test-pid` builds and runs only the PID namespace tests, allowing rapid iteration on that specific component without waiting for the full test suite.\n\nThe test directory mirrors the source structure, with unit tests for each manager and integration tests for the full container lifecycle. Each test file includes both positive tests (verifying correct behavior) and negative tests (verifying proper error handling for various failure scenarios).\n\n⚠️ **Pitfall: Circular Dependencies**\nA common mistake is creating circular dependencies between managers. For example, having the mount namespace manager call cgroup functions, which then call mount functions. Our architecture prevents this by having all coordination flow through the container orchestrator, with managers only calling utility functions and never calling each other directly.\n\n⚠️ **Pitfall: Inadequate Error Propagation**\nAnother common issue is not properly propagating error information up through the component layers. Each manager must translate low-level system call errors into meaningful error messages that include context about what operation was being attempted. The utility functions help with this by providing detailed error logging, but each manager must add its own contextual information.\n\n### Implementation Guidance\n\nThe container implementation requires careful coordination of several Linux kernel features, each with their own complexity and failure modes. This guidance provides concrete starting points and file organization to help you build a maintainable implementation.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Build System | Simple Makefile with basic targets | Autotools or CMake with feature detection |\n| Error Handling | errno checking with perror() | Custom error types with detailed context |\n| Logging | printf to stderr | Structured logging with levels and timestamps |\n| Testing | Basic assert() macros | Full unit test framework like Check or Unity |\n| Process Management | Direct clone() syscalls | Higher-level process spawning library |\n| Filesystem Operations | Direct mount() syscalls | libmount for mount table management |\n| Network Configuration | Direct netlink socket operations | libnl for network namespace management |\n\n#### Essential Data Structures\n\nHere are the complete type definitions that all components will use:\n\n```c\n// container.h - Core data structures and API\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <stddef.h>\n\n#define STACK_SIZE (1024 * 1024)\n#define CONTAINER_NS_FLAGS (CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUTS | CLONE_NEWIPC)\n#define CGROUPS_V1_PATH \"/sys/fs/cgroup\"\n#define CGROUPS_V2_PATH \"/sys/fs/cgroup/unified\"\n#define CONTAINER_CGROUP_PREFIX \"container-basic\"\n\n// Container configuration - all parameters needed to create a container\ntypedef struct {\n    char *rootfs_path;           // Path to root filesystem directory\n    char *hostname;              // Hostname to set inside container\n    size_t memory_limit_bytes;   // Memory limit in bytes (0 for no limit)\n    int cpu_percent;             // CPU percentage limit (0-100, 0 for no limit)\n    int max_processes;           // Maximum number of processes (0 for no limit)\n    char *bridge_name;           // Host bridge name for networking (NULL for no networking)\n    char *container_ip;          // IP address to assign to container (NULL for auto)\n    char **argv;                 // Command and arguments to run in container\n    char **envp;                 // Environment variables for container process\n} container_config_t;\n\n// Active container instance - tracks all resources that need cleanup\ntypedef struct {\n    pid_t child_pid;             // PID of container init process\n    int namespace_fds[6];        // File descriptors for each namespace type\n    char *cgroup_path;           // Full path to container's cgroup directory\n    struct cleanup_list *cleanup; // Registered cleanup functions\n} container_instance_t;\n\n// Cleanup function registration for error recovery\ntypedef struct cleanup_list {\n    void (*cleanup_func)(void *data);\n    void *data;\n    struct cleanup_list *next;\n} cleanup_list_t;\n\n// Main container API\nint container_create(const container_config_t *config, container_instance_t *container);\nint container_wait(container_instance_t *container);\nint container_destroy(container_instance_t *container);\n```\n\n#### Utility Functions Implementation\n\n```c\n// utils/syscall_wrappers.c - Safe syscall wrappers with comprehensive error handling\n\n#define _GNU_SOURCE\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Safe wrapper for clone() syscall with proper error checking\npid_t safe_clone(int (*fn)(void *), void *stack, int flags, void *arg) {\n    pid_t pid = clone(fn, stack, flags, arg);\n    if (pid == -1) {\n        fprintf(stderr, \"clone() failed: %s (flags=0x%x)\\n\", strerror(errno), flags);\n        // Common clone failures and their meanings:\n        // EINVAL: Invalid flags combination or stack pointer\n        // EPERM: Insufficient privileges for namespace creation\n        // ENOSPC: Kernel ran out of PIDs or namespace resources\n        // EUSERS: Too many nested namespaces\n        return -1;\n    }\n    return pid;\n}\n\n// Safe wrapper for mount() syscall with detailed error reporting\nint safe_mount(const char *source, const char *target, const char *type, \n               unsigned long flags, const void *data) {\n    if (mount(source, target, type, flags, data) != 0) {\n        fprintf(stderr, \"mount('%s', '%s', '%s', 0x%lx) failed: %s\\n\", \n                source ? source : \"NULL\", \n                target ? target : \"NULL\", \n                type ? type : \"NULL\", \n                flags, strerror(errno));\n        // Common mount failures:\n        // ENOENT: Source or target path doesn't exist\n        // EPERM: Insufficient privileges\n        // EBUSY: Target is busy (already mounted or in use)\n        // EINVAL: Invalid filesystem type or flags\n        return -1;\n    }\n    return 0;\n}\n\n// Initialize cleanup list\nvoid cleanup_list_init(cleanup_list_t **list) {\n    *list = NULL;\n}\n\n// Register cleanup function (called in reverse order during cleanup)\nint register_cleanup(cleanup_list_t **list, void (*func)(void *), void *data) {\n    cleanup_list_t *entry = malloc(sizeof(cleanup_list_t));\n    if (!entry) {\n        return -1;\n    }\n    entry->cleanup_func = func;\n    entry->data = data;\n    entry->next = *list;\n    *list = entry;\n    return 0;\n}\n\n// Execute all registered cleanup functions in reverse registration order\nvoid execute_cleanup(cleanup_list_t **list) {\n    cleanup_list_t *current = *list;\n    while (current) {\n        cleanup_list_t *next = current->next;\n        if (current->cleanup_func) {\n            current->cleanup_func(current->data);\n        }\n        free(current);\n        current = next;\n    }\n    *list = NULL;\n}\n```\n\n#### Container Orchestrator Skeleton\n\n```c\n// container.c - Main orchestrator implementation skeleton\n\n#include \"container.h\"\n#include \"namespaces/pid_namespace.h\"\n#include \"namespaces/mount_namespace.h\"\n#include \"namespaces/network_namespace.h\"\n#include \"cgroups/cgroup_manager.h\"\n#include \"utils/cleanup.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint container_create(const container_config_t *config, container_instance_t *container) {\n    // TODO 1: Initialize container instance structure\n    //   - Set all fields to safe defaults (child_pid = 0, namespace_fds = -1, etc.)\n    //   - Initialize cleanup list for error recovery\n    //   - Validate config parameters (rootfs_path exists, limits are reasonable)\n    \n    // TODO 2: Create PID namespace and fork container init process\n    //   - Call pid_namespace_create() to set up PID isolation\n    //   - Store child PID in container->child_pid\n    //   - Register PID cleanup function for process termination\n    //   - Handle clone() failures and provide meaningful error messages\n    \n    // TODO 3: Set up cgroups for resource limits (parent process context)\n    //   - Call cgroup_create() with memory, CPU, and process limits from config\n    //   - Assign child process to cgroup using container->child_pid\n    //   - Store cgroup path in container->cgroup_path for later cleanup\n    //   - Register cgroup cleanup function\n    \n    // TODO 4: Wait for child process to signal setup completion\n    //   - Use pipe or other IPC mechanism to synchronize with child\n    //   - Child will set up mount and network namespaces, then signal ready\n    //   - Handle case where child fails during setup (read error status)\n    \n    // TODO 5: Store namespace file descriptors for external access\n    //   - Open /proc/[child_pid]/ns/* files to keep namespaces alive\n    //   - Store FDs in container->namespace_fds array\n    //   - Register FD cleanup functions to close on container destruction\n    \n    return 0; // Success - container is running\n}\n\nint container_wait(container_instance_t *container) {\n    // TODO 1: Validate container instance\n    //   - Check that container->child_pid is valid (> 0)\n    //   - Return error if container is not in running state\n    \n    // TODO 2: Wait for container process to exit\n    //   - Use waitpid() to wait for container->child_pid\n    //   - Handle EINTR (interrupted system call) by retrying\n    //   - Extract exit status and return to caller\n    \n    // TODO 3: Update container state to reflect process exit\n    //   - Set container->child_pid = 0 to indicate process is gone\n    //   - Keep other resources (namespaces, cgroups) for potential inspection\n    \n    return 0; // Return exit status of container process\n}\n\nint container_destroy(container_instance_t *container) {\n    // TODO 1: Terminate container process if still running\n    //   - Send SIGTERM to container->child_pid if > 0\n    //   - Wait briefly for graceful shutdown\n    //   - Send SIGKILL if process doesn't exit cleanly\n    \n    // TODO 2: Execute all registered cleanup functions\n    //   - Call execute_cleanup() to run cleanup chain in reverse order\n    //   - This handles cgroup removal, namespace FD closing, etc.\n    //   - Continue cleanup even if individual steps fail\n    \n    // TODO 3: Reset container instance to safe state\n    //   - Set all fields back to defaults\n    //   - Free any dynamically allocated strings (cgroup_path)\n    //   - Clear namespace_fds array\n    \n    return 0; // Success - all resources cleaned up\n}\n```\n\n#### File Organization Implementation\n\nCreate the directory structure shown above, starting with these essential files:\n\n**Makefile:**\n```makefile\nCC = gcc\nCFLAGS = -Wall -Wextra -std=c99 -D_GNU_SOURCE\nSRCDIR = src\nTESTDIR = tests\nOBJDIR = obj\n\n# Core source files\nSOURCES = $(SRCDIR)/container.c \\\n          $(SRCDIR)/namespaces/pid_namespace.c \\\n          $(SRCDIR)/namespaces/mount_namespace.c \\\n          $(SRCDIR)/namespaces/network_namespace.c \\\n          $(SRCDIR)/cgroups/cgroup_manager.c \\\n          $(SRCDIR)/utils/cleanup.c \\\n          $(SRCDIR)/utils/syscall_wrappers.c\n\nOBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)\nTARGET = container-basic\n\nall: $(TARGET)\n\n$(TARGET): $(OBJECTS) $(SRCDIR)/main.c\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# Individual component tests\ntest-pid: $(TESTDIR)/test_pid_namespace.c $(SRCDIR)/namespaces/pid_namespace.c\n\t$(CC) $(CFLAGS) -o test_pid $^ && ./test_pid\n\ntest-mount: $(TESTDIR)/test_mount_namespace.c $(SRCDIR)/namespaces/mount_namespace.c\n\t$(CC) $(CFLAGS) -o test_mount $^ && ./test_mount\n\nclean:\n\trm -rf $(OBJDIR) $(TARGET) test_*\n\n.PHONY: all clean test-pid test-mount\n```\n\n#### Milestone Checkpoints\n\nAfter implementing the basic architecture structure, verify these behaviors:\n\n1. **File Structure Checkpoint**: All header files compile without errors when included individually. Run `gcc -c src/container.h` and similar commands for each header.\n\n2. **Data Structure Checkpoint**: Create a simple test program that initializes `container_config_t` and `container_instance_t` structures. Verify all fields are accessible and have expected types.\n\n3. **Utility Functions Checkpoint**: Test the syscall wrappers with simple operations like creating a directory and mounting tmpfs. Verify error messages are helpful and cleanup functions execute properly.\n\n4. **Build System Checkpoint**: The Makefile should build the project without warnings. Individual component tests should compile (but may not pass until components are implemented).\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Header Include Guards**\nEach header file must have proper include guards to prevent multiple inclusion problems. Use the pattern:\n```c\n#ifndef CONTAINER_COMPONENT_H\n#define CONTAINER_COMPONENT_H\n// ... header content ...\n#endif\n```\n\n⚠️ **Pitfall: Memory Management in Error Paths**\nThe cleanup system only handles resources that were successfully registered. If allocation fails during container creation, you may leak partially created resources. Always check allocation results and register cleanup functions immediately after successful resource creation.\n\n⚠️ **Pitfall: File Descriptor Leaks**\nNamespace file descriptors and other FDs must be properly closed during cleanup. Initialize the `namespace_fds` array to -1 values and check for valid FDs before closing in cleanup functions.\n\n⚠️ **Pitfall: Inconsistent Error Codes**\nDifferent components should use consistent error code conventions. Consider defining an enum of container-specific error codes rather than returning raw errno values, which can be ambiguous.\n\n\n## Data Model\n\n> **Milestone(s):** This section provides the foundational data structures for all milestones (1-4), establishing how container configuration, namespace handles, and resource limits are represented and managed throughout the container lifecycle.\n\nThe data model forms the backbone of our container runtime, defining how we represent container configurations, track active namespaces, and manage resource limits. Think of the data model as the **blueprint and inventory system** for a construction project - just as a builder needs detailed blueprints specifying what to build and an inventory system tracking materials and tools, our container runtime needs structured data representing what isolation to create and tracking mechanisms for the resources we allocate.\n\nThe data model addresses several critical challenges in container management. First, we need a comprehensive **configuration structure** that captures all the parameters required to create a container - from filesystem paths and resource limits to network configuration and process arguments. Second, we need **runtime tracking structures** that maintain handles to active namespaces, cgroup hierarchies, and cleanup responsibilities. Finally, we need **error recovery mechanisms** that ensure proper cleanup even when container creation partially fails.\n\n![Container System Component Overview](./diagrams/system-overview.svg)\n\nThe key insight driving our data model design is the **separation between intent and state**. The configuration structures represent what we want to create (intent), while the instance structures track what we have actually created (state). This separation enables robust error handling - if namespace creation fails halfway through, we know exactly what resources need cleanup by examining the instance state, regardless of what the original configuration requested.\n\n### Container Configuration\n\nThe `container_config_t` structure serves as the **master specification** for container creation, analogous to an architect's detailed building plans that specify every aspect of construction before work begins. This structure captures all user intentions about how the container should be configured, from filesystem isolation to resource limits to network connectivity.\n\nThink of container configuration as a **restaurant order** - it specifies exactly what the customer wants (filesystem location, memory limits, network setup) without containing any information about kitchen state (which pots are being used, which burners are occupied). The configuration is pure intent, completely separate from the runtime state needed to fulfill that intent.\n\nThe configuration structure addresses the **complexity of container parameterization** by providing a single, comprehensive data structure that components can reference throughout the container lifecycle. Rather than passing dozens of individual parameters between functions, we pass a single configuration reference that contains everything needed for namespace creation, resource limit setup, and process execution.\n\n> **Design Principle: Configuration Immutability**\n> Once created, configuration structures should never be modified. This immutability enables safe sharing between threads and processes during container creation, and ensures that all components operate on consistent parameters even if creation takes significant time.\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `rootfs_path` | `char*` | Absolute path to container's root filesystem directory; used as new root after pivot_root operation |\n| `hostname` | `char*` | Container hostname visible inside UTS namespace; appears in /proc/sys/kernel/hostname within container |\n| `memory_limit_bytes` | `size_t` | Maximum memory consumption in bytes; enforced through memory cgroup controller |\n| `cpu_percent` | `int` | CPU usage limit as percentage (0-100); translated to cgroup cpu.cfs_quota_us and cpu.cfs_period_us |\n| `max_processes` | `int` | Maximum number of processes/threads; enforced through pids cgroup controller |\n| `bridge_name` | `char*` | Host bridge name for container networking; veth pair connects container to this bridge |\n| `container_ip` | `char*` | IP address assigned to container's network interface; must be within bridge subnet range |\n| `argv` | `char**` | Null-terminated array of command-line arguments for container's main process; argv[0] is executable path |\n| `envp` | `char**` | Null-terminated array of environment variables in \"KEY=value\" format; defines container process environment |\n\nThe **filesystem configuration** through `rootfs_path` represents one of the most critical container parameters. This path must point to a complete filesystem hierarchy containing all binaries, libraries, and configuration files needed by the container process. The path serves as the target for the pivot_root operation that switches the container's view of the filesystem root.\n\n> **Critical Requirement: Rootfs Completeness**\n> The `rootfs_path` directory must contain a complete, bootable filesystem including essential directories (/bin, /lib, /etc, /proc, /sys) and all dependencies for the target executable. Missing libraries or incorrect permissions will cause container startup failures that are difficult to debug.\n\nThe **resource limit fields** (`memory_limit_bytes`, `cpu_percent`, `max_processes`) translate directly into cgroup controller configurations. The memory limit becomes a hard boundary enforced by the kernel - processes exceeding this limit trigger OOM (Out of Memory) killer behavior. The CPU percentage translates into a quota system where the container receives the specified percentage of CPU time over each scheduling period.\n\nThe **networking configuration** (`bridge_name`, `container_ip`) defines how the container connects to the host network. The bridge name must reference an existing host bridge interface, and the container IP must fall within the bridge's subnet range. These parameters drive the creation of veth pair interfaces that connect the container's network namespace to the host bridge.\n\n> **Architecture Decision: Static vs Dynamic IP Assignment**\n> - **Context**: Containers need IP addresses for network communication, but we must choose between static assignment (user specifies IP) and dynamic assignment (runtime allocates from pool)\n> - **Options Considered**: \n>   - Static IP specification in configuration\n>   - Dynamic allocation from subnet pool\n>   - DHCP-based assignment within namespace\n> - **Decision**: Static IP specification in configuration\n> - **Rationale**: Simplifies implementation by avoiding IP allocation logic and subnet management. Users have full control over network topology. Reduces startup complexity and potential IP conflicts.\n> - **Consequences**: Users must manage IP assignment manually. Risk of IP conflicts if multiple containers specify same address. No automatic network planning capabilities.\n\n| Configuration Approach | Pros | Cons |\n|------------------------|------|------|\n| Static IP Assignment | Simple implementation, predictable addresses, user control | Manual IP management, potential conflicts |\n| Dynamic Pool Allocation | Automatic conflict avoidance, easier multi-container setup | Complex allocation logic, subnet management |\n| DHCP Integration | Industry standard, flexible configuration | Requires DHCP server, network complexity |\n\nThe **process execution parameters** (`argv`, `envp`) define what actually runs inside the container once all namespaces are created. The argv array follows standard Unix conventions where argv[0] contains the executable path and subsequent elements contain command-line arguments. The envp array provides the process environment, allowing injection of configuration through environment variables.\n\n### Namespace Handles\n\nThe `container_instance_t` structure represents the **runtime state** of an active container, analogous to a construction site's status board that tracks which workers are active, which equipment is deployed, and what cleanup tasks remain. While configuration represents intent, the instance structure represents reality - the actual kernel objects, file descriptors, and process IDs that implement container isolation.\n\nThink of namespace handles as **safety deposit box keys** - each handle provides access to a specific kernel resource (namespace, cgroup, process) that must be carefully tracked and eventually returned. Losing a handle means losing the ability to properly clean up that resource, leading to kernel object leaks that accumulate over time.\n\nThe instance structure addresses the **complexity of partial failure recovery** by maintaining explicit references to every kernel object created during container setup. If container creation fails after successfully creating PID and mount namespaces but before network setup completes, the instance structure contains exactly the information needed to clean up the successfully created resources.\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `child_pid` | `pid_t` | Process ID of container's main process; used for signaling and wait operations |\n| `namespace_fds` | `int[6]` | File descriptors for namespace handles; indexed by namespace type for cleanup access |\n| `cgroup_path` | `char*` | Absolute path to container's cgroup directory; used for resource limit cleanup |\n| `cleanup` | `cleanup_list_t*` | Linked list of cleanup functions; executed in reverse order during container destruction |\n\nThe **child process tracking** through `child_pid` provides the primary handle for container lifecycle management. This PID allows the parent process to send signals to the container (for graceful shutdown), wait for container exit, and retrieve exit status information. The PID also serves as the primary identifier for associating kernel resources with the specific container instance.\n\n> **Critical Timing Issue: PID Reuse**\n> Process IDs can be reused by the kernel after process exit. Always verify that the PID still refers to the expected process before performing operations. Use additional validation like checking /proc/[PID]/comm or process start time to ensure PID validity.\n\nThe **namespace file descriptor array** (`namespace_fds`) maintains handles to each namespace created for the container. The array indexes correspond to namespace types: PID (0), mount (1), network (2), UTS (3), IPC (4), and user (5). These file descriptors enable namespace operations like entering the namespace from other processes or querying namespace properties through /proc filesystem interfaces.\n\n| Namespace Index | Type | File Descriptor Source | Cleanup Requirement |\n|----------------|------|----------------------|-------------------|\n| 0 | PID | `/proc/[PID]/ns/pid` | Close FD; namespace dies with process |\n| 1 | Mount | `/proc/[PID]/ns/mnt` | Close FD; unmount private mounts |\n| 2 | Network | `/proc/[PID]/ns/net` | Close FD; delete veth interfaces |\n| 3 | UTS | `/proc/[PID]/ns/uts` | Close FD; no additional cleanup |\n| 4 | IPC | `/proc/[PID]/ns/ipc` | Close FD; IPC objects cleaned by kernel |\n| 5 | User | `/proc/[PID]/ns/user` | Close FD; no additional cleanup |\n\nThe **cgroup path tracking** (`cgroup_path`) maintains the filesystem location of the container's cgroup hierarchy. This path serves multiple purposes: writing resource limits to controller files, adding processes to the cgroup, and removing the cgroup directory during cleanup. The path typically follows the pattern `/sys/fs/cgroup/[controller]/container-basic-[container-id]`.\n\n> **Architecture Decision: Cleanup List vs Individual Cleanup Functions**\n> - **Context**: Container creation involves many kernel objects that require cleanup in specific order. We need a mechanism to ensure proper cleanup even during partial failures.\n> - **Options Considered**: \n>   - Individual cleanup functions called manually\n>   - Cleanup list with automatic execution\n>   - Resource Acquisition Is Initialization (RAII) pattern\n> - **Decision**: Cleanup list with automatic execution\n> - **Rationale**: Provides guaranteed cleanup even during error conditions. Enables registration of cleanup functions as resources are created. Supports proper cleanup ordering through list reversal.\n> - **Consequences**: Additional complexity in data structures. Memory overhead for cleanup list nodes. Clear separation between success and failure paths.\n\nThe **cleanup list mechanism** (`cleanup`) implements a sophisticated error recovery system that ensures proper resource cleanup regardless of where container creation fails. Each successful resource allocation registers a cleanup function that knows how to properly release that specific resource. During container destruction or error recovery, the cleanup list executes in reverse order, ensuring that dependencies are respected during teardown.\n\n```\nRegistration Order: Create PID namespace -> Create mount namespace -> Create network -> Setup cgroups\nCleanup Order: Remove cgroups -> Cleanup network -> Cleanup mount -> Cleanup PID (automatic)\n```\n\n| Cleanup Function Type | Registration Trigger | Cleanup Action | Failure Impact |\n|-----------------------|---------------------|----------------|----------------|\n| `cleanup_cgroup_fn` | Cgroup directory creation | Remove cgroup hierarchy | Cgroup directory leak |\n| `cleanup_network_fn` | Veth pair creation | Delete veth interfaces | Interface leak |\n| `cleanup_mount_fn` | Mount namespace setup | Unmount private mounts | Mount table pollution |\n| `cleanup_namespace_fd_fn` | Namespace FD opening | Close namespace file descriptors | File descriptor leak |\n\nThe cleanup list structure enables **composable error handling** where each component registers its own cleanup requirements without needing knowledge of other components' cleanup needs. This separation of concerns ensures that adding new isolation mechanisms (like additional namespaces or cgroup controllers) doesn't require modifying existing cleanup logic.\n\n### Cleanup List Management\n\nThe `cleanup_list_t` structure implements a **reverse-order cleanup system** that ensures proper resource deallocation during both successful container shutdown and error recovery. Think of the cleanup list as a **stack of undo operations** - each time we successfully create a resource, we push an \"undo\" operation onto the stack. When cleanup time comes, we pop and execute each undo operation in reverse order.\n\nThis design pattern addresses the **dependency ordering problem** inherent in container resource management. Network interfaces must be cleaned up before network namespaces are destroyed. Cgroups must be emptied before directories can be removed. Mount points must be unmounted before mount namespaces exit. The cleanup list automatically handles these ordering requirements by executing cleanup functions in the reverse of their registration order.\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `cleanup_func` | `void(*)(void*)` | Function pointer to cleanup implementation; receives `data` parameter for resource-specific cleanup |\n| `data` | `void*` | Opaque pointer to cleanup context; typically points to resource handles or configuration needed for cleanup |\n| `next` | `struct cleanup_list*` | Pointer to next cleanup node; forms singly-linked list for traversal during execution |\n\nThe **function pointer design** (`cleanup_func`) enables type-safe cleanup while maintaining flexibility for different resource types. Each cleanup function receives a generic data pointer that it casts to the appropriate type for its specific resource. This design avoids the need for complex union types or switch statements in the cleanup execution logic.\n\n> **Memory Management Principle: Cleanup Data Ownership**\n> The cleanup list takes ownership of the `data` pointers passed during registration. Cleanup functions are responsible for freeing both their resource-specific data and any dynamically allocated structures referenced by that data. This ownership transfer ensures memory cleanup even during error conditions.\n\n**Common cleanup function patterns** follow a consistent structure: validate the data pointer, cast to the appropriate type, perform the resource-specific cleanup operation, and free any associated memory. The function should be idempotent - calling it multiple times should be safe, as error conditions may cause partial cleanup list execution.\n\nThe **linked list traversal** during cleanup execution walks the list from head to tail, executing each cleanup function and freeing the list node itself. This traversal pattern ensures that cleanup functions execute in reverse registration order while also cleaning up the list structure memory.\n\n⚠️ **Pitfall: Cleanup Function Failures**\nCleanup functions should never fail in ways that prevent subsequent cleanup operations. If a cleanup function encounters an error (like failing to delete a network interface), it should log the error but continue execution. Throwing exceptions or calling exit() from cleanup functions prevents other resources from being properly cleaned up, leading to resource leaks.\n\n⚠️ **Pitfall: Circular Cleanup Dependencies** \nAvoid registering cleanup functions that depend on resources cleaned up by functions registered later. For example, don't register a mount namespace cleanup that requires network access if network cleanup is registered after mount cleanup. The reverse-order execution means network cleanup runs first, potentially breaking mount cleanup.\n\n⚠️ **Pitfall: Double-Cleanup Registration**\nNever register cleanup functions for the same resource multiple times. This leads to double-free errors or resource cleanup conflicts. Use the instance structure's tracking fields to determine whether a resource has already been created and cleanup registered.\n\n### Implementation Guidance\n\nThis data model implementation provides the foundation for all container runtime operations, from initial configuration parsing through namespace creation to final resource cleanup. The structures bridge the gap between user intent and kernel resource management, providing type safety and error recovery throughout the container lifecycle.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|------------------|\n| Configuration Parsing | `getopt()` + manual struct filling | `libconfig` or YAML parser with validation |\n| Memory Management | Manual `malloc()/free()` with cleanup lists | `talloc` hierarchical memory management |\n| String Handling | Standard C string functions with length checking | `bstring` library for safe string operations |\n| Error Reporting | `errno` + `perror()` with custom error codes | Structured error codes with detailed context |\n\n#### Recommended File Structure\n\n```\ncontainer-basic/\n├── src/\n│   ├── container.h              ← Public API and main data structures\n│   ├── container.c              ← Main container lifecycle functions\n│   ├── config/\n│   │   ├── config.h            ← Configuration parsing and validation\n│   │   ├── config.c            ← Container configuration management\n│   │   └── config_test.c       ← Configuration parsing tests\n│   ├── cleanup/\n│   │   ├── cleanup.h           ← Cleanup list management\n│   │   ├── cleanup.c           ← Cleanup execution and registration\n│   │   └── cleanup_test.c      ← Cleanup mechanism tests\n│   └── utils/\n│       ├── utils.h             ← Common utilities and error handling\n│       └── utils.c             ← Helper functions and error reporting\n├── include/\n│   └── container_types.h       ← Type definitions and constants\n└── tests/\n    ├── test_data_model.c       ← Data structure validation tests\n    └── integration/\n        └── test_container_lifecycle.c  ← End-to-end container tests\n```\n\n#### Core Data Structure Definitions\n\n```c\n#include <sys/types.h>\n#include <unistd.h>\n\n// Container configuration structure - immutable after creation\ntypedef struct {\n    char* rootfs_path;           // Path to container root filesystem\n    char* hostname;              // Container hostname for UTS namespace\n    size_t memory_limit_bytes;   // Memory limit for memory cgroup\n    int cpu_percent;             // CPU limit percentage (0-100)\n    int max_processes;           // Process limit for pids cgroup\n    char* bridge_name;           // Host bridge for container networking\n    char* container_ip;          // IP address for container interface\n    char** argv;                 // Command arguments for container process\n    char** envp;                 // Environment variables for container\n} container_config_t;\n\n// Cleanup list node for resource management\ntypedef struct cleanup_list {\n    void (*cleanup_func)(void*);  // Cleanup function pointer\n    void* data;                   // Data for cleanup function\n    struct cleanup_list* next;    // Next cleanup item\n} cleanup_list_t;\n\n// Container runtime instance - tracks active resources\ntypedef struct {\n    pid_t child_pid;             // Container process PID\n    int namespace_fds[6];        // File descriptors for namespaces\n    char* cgroup_path;           // Path to container cgroup\n    cleanup_list_t* cleanup;     // Cleanup function list\n} container_instance_t;\n\n// Container creation and management functions\nint container_create(const container_config_t* config, container_instance_t* container);\nint container_wait(container_instance_t* container);\nint container_destroy(container_instance_t* container);\n\n// Cleanup list management functions\nvoid register_cleanup(cleanup_list_t** list, void (*func)(void*), void* data);\nvoid execute_cleanup(cleanup_list_t** list);\n```\n\n#### Configuration Management Implementation\n\n```c\n// config/config.h\n#ifndef CONFIG_H\n#define CONFIG_H\n\n#include \"container_types.h\"\n\n// Configuration validation and creation\nint config_create_default(container_config_t* config);\nint config_validate(const container_config_t* config);\nint config_parse_args(int argc, char** argv, container_config_t* config);\nvoid config_destroy(container_config_t* config);\n\n// Configuration validation helpers\nint validate_rootfs_path(const char* path);\nint validate_ip_address(const char* ip);\nint validate_bridge_exists(const char* bridge);\n\n#endif\n```\n\n#### Cleanup System Implementation\n\n```c\n// cleanup/cleanup.c\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"cleanup.h\"\n\n// Register cleanup function in reverse order for proper teardown\nvoid register_cleanup(cleanup_list_t** list, void (*func)(void*), void* data) {\n    // TODO: Allocate new cleanup_list_t node\n    // TODO: Set cleanup_func to provided function pointer\n    // TODO: Set data to provided data pointer  \n    // TODO: Set next to current list head (*list)\n    // TODO: Update list head to point to new node\n    // HINT: This creates a stack (LIFO) for reverse-order execution\n}\n\n// Execute all cleanup functions in reverse registration order\nvoid execute_cleanup(cleanup_list_t** list) {\n    // TODO: Walk the linked list from head to tail\n    // TODO: For each node, call cleanup_func(data)\n    // TODO: Free the current node before moving to next\n    // TODO: Set list head to NULL after cleanup complete\n    // HINT: Handle NULL function pointers gracefully\n    // HINT: Continue cleanup even if individual functions fail\n}\n\n// Cleanup function for closing namespace file descriptors\nvoid cleanup_namespace_fds(void* data) {\n    // TODO: Cast data to int* (namespace_fds array)\n    // TODO: Iterate through all 6 namespace types\n    // TODO: Close any valid file descriptors (>= 0)\n    // TODO: Set closed descriptors to -1 to prevent double-close\n}\n\n// Cleanup function for removing cgroup directory\nvoid cleanup_cgroup(void* data) {\n    // TODO: Cast data to char* (cgroup_path)\n    // TODO: Remove cgroup directory using rmdir()\n    // TODO: Free the cgroup_path string\n    // TODO: Log errors but don't fail - other cleanup must continue\n}\n```\n\n#### Instance Management Skeleton\n\n```c\n// container.c - Core lifecycle management\n\n// Initialize container instance structure to safe defaults\nint container_instance_init(container_instance_t* instance) {\n    // TODO: Set child_pid to -1 (invalid PID)\n    // TODO: Initialize all namespace_fds entries to -1\n    // TODO: Set cgroup_path to NULL\n    // TODO: Set cleanup list to NULL\n    // TODO: Return 0 for success\n}\n\n// Create container with all namespaces and resource limits\nint container_create(const container_config_t* config, container_instance_t* container) {\n    // TODO: Initialize container instance to safe defaults\n    // TODO: Validate configuration before starting creation\n    // TODO: Create PID namespace with clone() or unshare()\n    // TODO: Register cleanup for PID namespace resources\n    // TODO: Create mount namespace and setup filesystem\n    // TODO: Register cleanup for mount namespace resources  \n    // TODO: Create network namespace and veth pair\n    // TODO: Register cleanup for network resources\n    // TODO: Setup cgroups and apply resource limits\n    // TODO: Register cleanup for cgroup resources\n    // TODO: Execute container process in new namespaces\n    // HINT: Use cleanup list for error recovery if any step fails\n    // HINT: Store all resource handles in container instance\n}\n\n// Clean up all container resources using registered cleanup functions\nint container_destroy(container_instance_t* container) {\n    // TODO: Send SIGTERM to child process if still running\n    // TODO: Wait brief period for graceful shutdown\n    // TODO: Send SIGKILL if process still exists\n    // TODO: Execute complete cleanup list\n    // TODO: Reset container instance to safe defaults\n    // HINT: Always execute cleanup even if process operations fail\n}\n```\n\n#### Milestone Checkpoints\n\n**After Configuration Implementation:**\n- Create a simple test program that parses command-line arguments into `container_config_t`\n- Verify that configuration validation catches invalid rootfs paths and IP addresses\n- Test that configuration cleanup properly frees all allocated strings\n- Expected output: Configuration parsing succeeds with valid inputs, fails gracefully with invalid inputs\n\n**After Cleanup System Implementation:**\n- Write unit tests that register multiple cleanup functions and verify reverse-order execution\n- Test cleanup execution with some functions that intentionally fail\n- Verify that cleanup list properly frees all allocated nodes\n- Expected behavior: Cleanup functions execute in reverse registration order, failures don't prevent subsequent cleanup\n\n**After Instance Management:**\n- Create container instances and verify proper initialization\n- Test partial container creation with cleanup verification\n- Use `lsof` to verify no file descriptor leaks after container destruction\n- Expected result: Clean creation and destruction with no resource leaks visible in `/proc` filesystem\n\n#### Debugging Data Structure Issues\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Segfault during config access | Uninitialized config pointer | Check if config_create was called | Always initialize structures before use |\n| Memory leak after container destroy | Missing cleanup registration | Use valgrind to identify leaked allocations | Register cleanup for every resource allocation |\n| Container creation hangs | Blocking operation without error handling | Check for infinite waits in clone/mount | Add timeouts and error checking to all syscalls |\n| Cleanup functions crash | Invalid data pointers in cleanup list | Verify data pointers before casting | Validate data != NULL in cleanup functions |\n| Double-free errors | Multiple cleanup registrations | Check cleanup list for duplicate entries | Track registration state in instance structure |\n\n\n## PID Namespace Component\n\n> **Milestone(s):** This section corresponds to Milestone 1 (Process Namespace), which implements process isolation using PID namespaces and establishes the foundation for container process management.\n\n### Mental Model: Hotel Room Numbers\n\nThink of PID namespaces like the room numbering systems in different buildings of a large hotel chain. Each hotel building has its own room numbering scheme - Building A has rooms 101, 102, 103, while Building B also has rooms 101, 102, 103. From inside Building A, you only see the room numbers for that building. Room 101 in Building A is completely different from Room 101 in Building B, even though they share the same number within their respective buildings.\n\nSimilarly, PID namespaces create isolated process numbering systems. The host system (like the hotel management office) can see all processes across all namespaces with their \"real\" PIDs, but processes inside a PID namespace only see the processes within their own namespace, numbered starting from PID 1. When a container process thinks it's PID 1, the host might see it as PID 15432 - just like how the guest in room 101 of Building A doesn't know that the hotel management system tracks their room as \"A-101\".\n\nThe critical insight is that PID 1 in a namespace has special responsibilities, just like how the manager of Building A is responsible for that building's operations. PID 1 must handle \"orphaned\" processes (zombie reaping) within its namespace, similar to how a building manager must handle abandoned rooms and maintenance issues within their building.\n\n> **Key Design Insight**: The PID namespace component must handle the dual nature of process identity - maintaining the illusion of isolation within the namespace while coordinating with the host system for actual process management. This duality drives many of the implementation complexities around process creation, signal handling, and cleanup.\n\n### PID Namespace Interface\n\nThe PID namespace interface provides functions for creating isolated process environments and managing the complex lifecycle of processes within those environments. The design centers around the `safe_clone` function and supporting infrastructure for handling the unique requirements of becoming PID 1 within a namespace.\n\n| Function Name | Parameters | Returns | Description |\n|---------------|------------|---------|-------------|\n| `create_pid_namespace` | `container_config_t* config, container_instance_t* container` | `int` | Creates new PID namespace using clone() with CLONE_NEWPID flag |\n| `safe_clone` | `int (*fn)(void*), void* stack, int flags, void* arg` | `pid_t` | Wrapper for clone() syscall with comprehensive error checking and stack validation |\n| `container_init_process` | `void* arg` | `int` | Entry point function for container process, handles PID 1 initialization and exec |\n| `setup_init_signals` | `void` | `int` | Configures signal handlers for zombie reaping and graceful shutdown |\n| `reap_zombies` | `void` | `void` | Signal handler that reaps zombie child processes using waitpid() |\n| `exec_container_command` | `char** argv, char** envp` | `int` | Replaces init process with user-specified command via execve() |\n\nThe PID namespace creation process involves careful coordination between the parent (host) process and the child (container) process. The parent process calls `safe_clone` with the `CLONE_NEWPID` flag, which causes the child process to be created in a new PID namespace where it becomes PID 1. This transition is fundamental to container isolation but introduces significant complexity around process initialization and signal handling.\n\nThe `safe_clone` function serves as a critical abstraction over the raw `clone()` system call, handling the numerous error conditions and edge cases that arise from namespace creation. It validates the stack pointer direction (growing up vs. down on different architectures), checks for sufficient privileges to create namespaces, and provides detailed error reporting for common failure modes like ENOSPC (no space in PID namespace) or EPERM (insufficient privileges).\n\n> **Critical Design Principle**: The container init process must be prepared to handle all the responsibilities of PID 1, including zombie reaping and signal forwarding, before executing the user's intended command. Failing to properly initialize can lead to zombie process accumulation and signal delivery problems within the container.\n\nThe `container_init_process` function represents the entry point for the container process after namespace creation. This function runs as PID 1 within the new namespace and must establish the proper runtime environment before transitioning to the user's intended command. It configures signal handlers, sets up minimal process state, and then uses `execve()` to replace itself with the actual container workload.\n\n| Process State | PID (Host View) | PID (Container View) | Responsibilities |\n|---------------|-----------------|---------------------|------------------|\n| Host Process | Variable | N/A | Creates namespaces, monitors container |\n| Container Init | Variable (e.g. 15432) | 1 | Zombie reaping, signal handling, exec user command |\n| Container Children | Variable | 2, 3, 4... | User workloads, inherit namespace |\n\nThe signal handling configuration is particularly critical because PID 1 in a namespace has special signal semantics. Unlike regular processes, PID 1 can only be killed by signals it has explicitly configured handlers for. This means the container init process must explicitly handle signals like SIGTERM and SIGINT to enable graceful shutdown, and must handle SIGCHLD to perform zombie reaping.\n\n### Init Process Responsibilities\n\nThe init process within a PID namespace carries the fundamental responsibility of being the root of the process tree and the ultimate parent for all orphaned processes. When any process within the namespace exits, if its parent has already terminated, that process becomes a child of PID 1 (the init process). This creates an obligation for the init process to continuously reap zombie processes to prevent resource exhaustion.\n\nThe zombie reaping mechanism operates through the SIGCHLD signal handler, which is delivered whenever a child process changes state (typically when it exits). The signal handler must call `waitpid()` in a loop with the WNOHANG flag to reap all available zombie processes without blocking. This is critical because multiple children might exit simultaneously, but only one SIGCHLD signal might be delivered due to signal coalescing.\n\n| Signal | Purpose | Handler Action | Criticality |\n|--------|---------|----------------|-------------|\n| SIGCHLD | Child process exit | Call waitpid() in loop to reap zombies | Critical - prevents resource leaks |\n| SIGTERM | Graceful shutdown request | Forward to child processes, then exit | High - enables clean container stop |\n| SIGINT | Interrupt (Ctrl+C) | Forward to child processes, then exit | High - enables interactive termination |\n| SIGUSR1 | Custom container signal | Forward to main container process | Medium - application-specific |\n| SIGKILL | Force termination | Cannot be caught - handled by kernel | N/A - immediate termination |\n\nThe signal forwarding mechanism ensures that signals sent to the container (via docker kill or similar commands) reach the actual application process rather than being handled solely by the init wrapper. This requires maintaining a reference to the main container process PID and forwarding appropriate signals while still handling init-specific signals locally.\n\nHere's the step-by-step process for handling init responsibilities:\n\n1. **Signal Handler Installation**: The init process configures signal handlers for SIGCHLD, SIGTERM, and SIGINT before doing anything else. This ensures zombie reaping capability is established immediately.\n\n2. **Initial Process Setup**: The init process may spawn the main container application as a child process, or it may exec directly into the application after setting up signal forwarding.\n\n3. **Zombie Reaping Loop**: When SIGCHLD is received, the handler enters a loop calling `waitpid(-1, &status, WNOHANG)` until no more zombie children are available. The WNOHANG flag prevents blocking if no zombies are present.\n\n4. **Signal Forwarding**: When SIGTERM or SIGINT is received, the init process forwards these signals to its child processes (if any) and then waits a reasonable timeout before exiting itself.\n\n5. **Graceful Shutdown**: The init process coordinates an orderly shutdown by signaling children, waiting for them to exit, reaping their zombie processes, and finally exiting itself.\n\n6. **Emergency Cleanup**: If children don't respond to graceful signals within the timeout period, the init process may send SIGKILL to force termination before exiting.\n\n> **Critical Implementation Detail**: The zombie reaping must handle the case where the main application process exits but has spawned daemon processes that become orphaned. These daemons become children of the container init process and must be properly reaped when they eventually exit.\n\nThe exec transition from init process to application process is an important optimization for containers that run a single primary application. Instead of maintaining the init process as a separate parent, the init process can configure signal handlers and then exec directly into the application. However, this approach sacrifices the ability to reap orphaned processes that might be created by the application.\n\n| Approach | Pros | Cons | Best For |\n|----------|------|------|----------|\n| Persistent Init | Handles zombies, signal forwarding | Extra memory overhead, complexity | Multi-process applications |\n| Exec Replacement | Minimal overhead, direct execution | No zombie reaping, limited signal handling | Single-process applications |\n| Hybrid (Setup then Exec) | Good signal setup, minimal runtime overhead | Limited zombie handling for orphans | Simple applications with known behavior |\n\n### Architecture Decision Records\n\n> **Decision: Clone() vs Unshare() for PID Namespace Creation**\n> - **Context**: We need to create a new PID namespace for container process isolation. Linux provides two system calls: `clone()` which creates a new process in a new namespace, and `unshare()` which moves the current process into a new namespace.\n> - **Options Considered**: \n>   1. Use `clone()` with CLONE_NEWPID to create child in new namespace\n>   2. Use `unshare()` to move current process into new namespace\n>   3. Hybrid approach using both calls\n> - **Decision**: Use `clone()` with CLONE_NEWPID for PID namespace creation\n> - **Rationale**: PID namespaces have a special restriction - when a process calls `unshare(CLONE_NEWPID)`, the process itself remains in the original namespace, and only its children enter the new namespace. This creates confusion about which process is actually isolated. Using `clone()` ensures the child process is immediately in the new namespace as PID 1, providing clear semantics and avoiding the need for additional process spawning.\n> - **Consequences**: We must handle the complexity of inter-process communication between parent and child, manage stack allocation for clone(), and handle the timing of namespace setup. However, we get predictable PID namespace semantics and avoid the confusion of mixed namespace membership.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| clone() with CLONE_NEWPID | Child immediately becomes PID 1, clear namespace boundaries | Complex stack management, IPC needed |\n| unshare() then fork | Simpler control flow, no stack allocation | Process calling unshare stays in old namespace |\n| Hybrid approach | Flexibility in namespace transition | Increased complexity, harder to debug |\n\n> **Decision: Stack Direction Handling in safe_clone()**\n> - **Context**: The `clone()` system call requires a stack pointer, but different CPU architectures have different stack growth directions (up vs down). ARM typically grows up, x86 grows down.\n> - **Options Considered**:\n>   1. Assume downward growing stack (x86-style) and use (stack + STACK_SIZE)\n>   2. Use architecture-specific preprocessor directives to handle both directions\n>   3. Probe stack direction at runtime and adjust accordingly\n> - **Decision**: Use architecture-specific preprocessor directives with fallback to downward growth\n> - **Rationale**: Stack direction is determined at compile time based on the target architecture. Runtime probing adds unnecessary complexity and performance overhead. Preprocessor directives provide compile-time optimization while supporting both common stack directions.\n> - **Consequences**: We need architecture-specific code paths, but this provides optimal performance and correctly handles the most common architectures. The fallback ensures compatibility with less common architectures.\n\n> **Decision: Init Process Design Pattern**\n> - **Context**: The container process becomes PID 1 in its namespace and must handle init responsibilities while also running the user's intended application.\n> - **Options Considered**:\n>   1. Minimal init that immediately exec()s into user application\n>   2. Persistent init that spawns user application as child and manages it\n>   3. Configurable init that can operate in either mode based on container config\n> - **Decision**: Implement persistent init that spawns user application as child process\n> - **Rationale**: While exec-style init has lower memory overhead, the persistent init approach provides essential container functionality including zombie reaping, signal forwarding, and graceful shutdown coordination. These capabilities are critical for production container usage and handling multi-process applications correctly.\n> - **Consequences**: We use additional memory for the init process and increase complexity in signal handling and process management. However, we gain robust process tree management and compatibility with applications that spawn child processes.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Incorrect Stack Pointer Calculation**\n\nMany developers incorrectly assume that all architectures use downward-growing stacks and pass the raw stack buffer pointer to `clone()`. On architectures with upward-growing stacks (like some ARM configurations), this causes the child process to start with an invalid stack pointer, leading to immediate segmentation faults.\n\nThe mistake typically looks like:\n- Allocating a stack buffer: `char stack[STACK_SIZE];`\n- Passing the base address directly: `clone(fn, stack, flags, arg)`\n- The child process crashes immediately with SIGSEGV\n\nThe correct approach is to check the architecture and adjust the stack pointer accordingly. For downward-growing stacks, pass `stack + STACK_SIZE`. For upward-growing stacks, pass the base address `stack`. Use preprocessor directives like `#ifdef __hppa__` to detect architectures with upward-growing stacks.\n\n⚠️ **Pitfall: Ignoring Zombie Process Accumulation**\n\nA common mistake is implementing a container init process that doesn't properly handle SIGCHLD signals or doesn't loop when reaping zombies. This leads to zombie process accumulation, eventually exhausting the process table and preventing new process creation.\n\nThe mistake occurs when developers either:\n1. Don't install a SIGCHLD handler at all\n2. Install a handler but only call `waitpid()` once instead of looping\n3. Use blocking `wait()` instead of non-blocking `waitpid()` with WNOHANG\n\nThe consequence is that zombie processes accumulate until the system reaches its process limit, causing new process creation to fail with \"Resource temporarily unavailable\" errors. This is particularly problematic in long-running containers or containers that spawn many short-lived processes.\n\nThe fix involves installing a proper SIGCHLD handler that loops until no more zombies are available:\n```c\n// Handler must loop because multiple children might exit simultaneously\nwhile ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n    // Process reaped successfully, continue looping\n}\n```\n\n⚠️ **Pitfall: Signal Handling Race Conditions**\n\nPID 1 has special signal semantics in Linux - it can only be terminated by signals for which it has explicitly installed handlers. Many developers forget this and wonder why their containers don't respond to SIGTERM or SIGINT signals. Without proper signal handlers, the container init process becomes unkillable except via SIGKILL.\n\nThe race condition occurs during the window between process creation and signal handler installation. If a signal arrives before handlers are installed, it may be ignored or cause unexpected behavior. This is particularly problematic during container shutdown when orchestration systems send SIGTERM expecting graceful termination.\n\nThe solution is to install signal handlers as early as possible in the init process, before any other initialization:\n1. Install SIGCHLD handler for zombie reaping\n2. Install SIGTERM handler for graceful shutdown\n3. Install SIGINT handler for interactive termination\n4. Block signals during critical sections to prevent races\n\n⚠️ **Pitfall: Parent Process Waiting Strategy**\n\nA subtle error occurs when the parent process (host side) doesn't properly wait for the container child process, or waits incorrectly. This can lead to the container process becoming a zombie itself, or the parent process hanging indefinitely.\n\nCommon mistakes include:\n- Using `wait()` instead of `waitpid()` with specific PID\n- Not handling EINTR when wait is interrupted by signals\n- Forgetting to check the exit status to distinguish normal exit from signals\n\nThe parent process must use `waitpid()` with the specific child PID and handle interruption correctly:\n```c\nint status;\npid_t result;\ndo {\n    result = waitpid(container->child_pid, &status, 0);\n} while (result == -1 && errno == EINTR);\n```\n\n⚠️ **Pitfall: Namespace Cleanup Timing**\n\nWhen a container exits, the PID namespace persists until all processes within it have exited and all file descriptors referring to the namespace are closed. Developers often forget that holding open namespace file descriptors (from /proc/PID/ns/) prevents namespace cleanup, leading to resource leaks.\n\nThe mistake manifests as:\n- Opening namespace file descriptors for monitoring or debugging\n- Forgetting to close them when the container exits\n- Namespace directories remaining in /proc after container termination\n- Eventually exhausting namespace resources\n\nThe fix requires careful tracking of all namespace file descriptors and ensuring they're closed during container cleanup. The cleanup process should close namespace descriptors before waiting for the container process to exit.\n\n![Namespace Isolation Diagram](./diagrams/namespace-isolation.svg)\n\n![Container Startup Sequence](./diagrams/container-startup-flow.svg)\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Process Creation | `fork()` + `execve()` + manual namespace setup | `clone()` with namespace flags for atomic creation |\n| Signal Handling | Basic `signal()` calls with simple handlers | `sigaction()` with advanced signal mask control |\n| Error Reporting | `perror()` + exit codes | Structured error codes with detailed context |\n| Stack Management | Fixed-size stack arrays | Dynamic stack allocation with guard pages |\n| Namespace Monitoring | Manual /proc filesystem inspection | File descriptor-based namespace tracking |\n\n#### Recommended File Structure\n\n```\ncontainer-basic/\n  src/\n    pid_namespace.c          ← PID namespace creation and management\n    pid_namespace.h          ← Function declarations and structures\n    container_init.c         ← Container init process implementation\n    signal_handling.c        ← Signal handler implementations\n    safe_clone.c            ← Clone wrapper with error handling\n    common.h                ← Shared constants and structures\n  tests/\n    test_pid_namespace.c    ← Unit tests for PID namespace functionality\n    test_container_init.c   ← Tests for init process behavior\n    test_zombie_reaping.c   ← Tests for zombie process handling\n  examples/\n    simple_container.c      ← Basic container demonstration\n```\n\n#### Infrastructure Starter Code\n\n**safe_clone.c** - Complete clone() wrapper with error handling:\n\n```c\n#include <sys/wait.h>\n#include <sys/syscall.h>\n#include <sched.h>\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include \"common.h\"\n\n// Architecture-specific stack pointer calculation\nstatic void* calculate_stack_pointer(void* stack_base) {\n#ifdef __hppa__\n    // HPPA has upward-growing stack\n    return stack_base;\n#else\n    // Most architectures have downward-growing stack\n    return (char*)stack_base + STACK_SIZE;\n#endif\n}\n\n// Validate stack alignment and bounds\nstatic int validate_stack(void* stack_base) {\n    if (!stack_base) {\n        return -1;\n    }\n    \n    // Check for reasonable alignment (at least 8-byte aligned)\n    if ((uintptr_t)stack_base & 7) {\n        return -1;\n    }\n    \n    return 0;\n}\n\npid_t safe_clone(int (*fn)(void*), void* stack, int flags, void* arg) {\n    if (!fn || validate_stack(stack) != 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    \n    void* stack_ptr = calculate_stack_pointer(stack);\n    pid_t pid = clone(fn, stack_ptr, flags, arg);\n    \n    if (pid == -1) {\n        // Provide detailed error information\n        switch (errno) {\n        case EPERM:\n            fprintf(stderr, \"clone failed: insufficient privileges for namespace creation\\n\");\n            break;\n        case ENOSPC:\n            fprintf(stderr, \"clone failed: no space left in PID namespace\\n\");\n            break;\n        case ENOMEM:\n            fprintf(stderr, \"clone failed: insufficient memory\\n\");\n            break;\n        default:\n            fprintf(stderr, \"clone failed: %s\\n\", strerror(errno));\n            break;\n        }\n    }\n    \n    return pid;\n}\n\n// Stack allocation helper with proper alignment\nvoid* allocate_container_stack(void) {\n    void* stack = aligned_alloc(4096, STACK_SIZE);\n    if (!stack) {\n        perror(\"Failed to allocate container stack\");\n        return NULL;\n    }\n    return stack;\n}\n\nvoid free_container_stack(void* stack) {\n    free(stack);\n}\n```\n\n**signal_handling.c** - Complete signal handler infrastructure:\n\n```c\n#include <signal.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdio.h>\n#include \"common.h\"\n\n// Global state for signal handling\nstatic volatile sig_atomic_t shutdown_requested = 0;\nstatic pid_t main_child_pid = 0;\n\n// SIGCHLD handler - reaps zombie processes\nstatic void sigchld_handler(int sig) {\n    int saved_errno = errno;\n    int status;\n    pid_t pid;\n    \n    // Loop to reap all available zombie children\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        // Log child exit if needed (avoid non-async-safe functions in real handlers)\n        // Child process reaped successfully\n    }\n    \n    errno = saved_errno;\n}\n\n// SIGTERM/SIGINT handler - initiates graceful shutdown\nstatic void sigterm_handler(int sig) {\n    shutdown_requested = 1;\n    \n    // Forward signal to main child process if it exists\n    if (main_child_pid > 0) {\n        kill(main_child_pid, sig);\n    }\n}\n\nint setup_init_signals(void) {\n    struct sigaction sa;\n    \n    // Configure SIGCHLD handler for zombie reaping\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n    sa.sa_handler = sigchld_handler;\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror(\"Failed to install SIGCHLD handler\");\n        return -1;\n    }\n    \n    // Configure SIGTERM handler for graceful shutdown\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = sigterm_handler;\n    if (sigaction(SIGTERM, &sa, NULL) == -1) {\n        perror(\"Failed to install SIGTERM handler\");\n        return -1;\n    }\n    \n    // Configure SIGINT handler (same as SIGTERM)\n    if (sigaction(SIGINT, &sa, NULL) == -1) {\n        perror(\"Failed to install SIGINT handler\");\n        return -1;\n    }\n    \n    return 0;\n}\n\nvoid set_main_child_pid(pid_t pid) {\n    main_child_pid = pid;\n}\n\nint is_shutdown_requested(void) {\n    return shutdown_requested;\n}\n\n// Wait for graceful shutdown with timeout\nint wait_for_graceful_shutdown(int timeout_seconds) {\n    int elapsed = 0;\n    while (elapsed < timeout_seconds && main_child_pid > 0) {\n        sleep(1);\n        elapsed++;\n        \n        // Check if main child has exited\n        if (waitpid(main_child_pid, NULL, WNOHANG) > 0) {\n            main_child_pid = 0;\n            return 0;  // Graceful exit\n        }\n    }\n    \n    return -1;  // Timeout\n}\n```\n\n#### Core Logic Skeleton Code\n\n**pid_namespace.c** - Core PID namespace functionality to implement:\n\n```c\n#include <sched.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include \"common.h\"\n\n// Creates a new PID namespace and container process\nint create_pid_namespace(container_config_t* config, container_instance_t* container) {\n    // TODO 1: Allocate stack for container process using allocate_container_stack()\n    \n    // TODO 2: Register stack cleanup in case of failure\n    // Hint: Use register_cleanup() to ensure stack is freed on failure\n    \n    // TODO 3: Call safe_clone() with CLONE_NEWPID flag and container_init_process as entry point\n    // Hint: Flags should include CLONE_NEWPID | SIGCHLD for basic PID namespace\n    \n    // TODO 4: Check clone() return value - negative means error, positive is child PID\n    \n    // TODO 5: Store child PID in container->child_pid for later management\n    \n    // TODO 6: Store namespace file descriptor in container->namespace_fds[0] if needed\n    // Hint: Open /proc/<child_pid>/ns/pid for namespace monitoring\n    \n    // TODO 7: Return 0 on success, -1 on failure with errno set\n    return -1;  // Replace with actual implementation\n}\n\n// Container init process entry point (runs as PID 1 in new namespace)\nint container_init_process(void* arg) {\n    container_config_t* config = (container_config_t*)arg;\n    \n    // TODO 1: Verify we're actually PID 1 in the namespace\n    // Hint: getpid() should return 1 if we're in the new PID namespace\n    \n    // TODO 2: Install signal handlers using setup_init_signals()\n    // This must be done before any other operations to handle zombies\n    \n    // TODO 3: Set up minimal process environment (working directory, umask, etc.)\n    // Hint: chdir() to appropriate directory, umask(0022) for reasonable permissions\n    \n    // TODO 4: If config specifies running as persistent init, fork() the main application\n    // Store the child PID using set_main_child_pid() for signal forwarding\n    \n    // TODO 5: If persistent init mode, enter main loop watching for signals and reaping zombies\n    // Use is_shutdown_requested() to check for graceful shutdown\n    \n    // TODO 6: If exec mode, directly exec into the user application\n    // Use execve() with config->argv and config->envp\n    \n    // TODO 7: Handle cleanup and error cases - this should not return normally\n    return 255;  // Should not reach here\n}\n\n// Wait for container process to exit and collect status\nint container_wait(container_instance_t* container) {\n    // TODO 1: Validate container parameter and child_pid\n    \n    // TODO 2: Use waitpid() to wait for specific child process\n    // Handle EINTR interruption by retrying the wait\n    \n    // TODO 3: Store exit status and return code for caller\n    // Distinguish between normal exit and signal termination\n    \n    // TODO 4: Mark container as exited (set child_pid to 0 or -1)\n    \n    return -1;  // Replace with actual implementation\n}\n```\n\n#### Language-Specific Hints\n\n- Use `clone()` instead of `fork()` for namespace creation - it's the only way to create PID namespaces atomically\n- Always check `errno` after failed system calls and use `strerror()` or `perror()` for debugging\n- Use `sigaction()` instead of `signal()` for reliable signal handling behavior across platforms\n- The `CLONE_NEWPID` flag creates the new PID namespace; combine with `SIGCHLD` for proper child handling\n- Use `waitpid()` with `WNOHANG` in signal handlers to avoid blocking\n- File descriptor `/proc/PID/ns/pid` can be used to hold references to namespaces for monitoring\n- Use `prctl(PR_SET_PDEATHSIG, SIGKILL)` to ensure container dies if parent dies unexpectedly\n\n#### Milestone Checkpoint\n\nAfter implementing the PID namespace component, verify the following behavior:\n\n**Test Command:**\n```bash\ngcc -o test_pid_namespace test_pid_namespace.c pid_namespace.c safe_clone.c signal_handling.c\nsudo ./test_pid_namespace\n```\n\n**Expected Output:**\n```\nContainer PID from host perspective: 1234\nContainer PID from inside namespace: 1\nContainer successfully created and isolated\nContainer exited with status: 0\n```\n\n**Manual Verification Steps:**\n\n1. **PID Isolation Check**: Run `ps aux` in another terminal while the container is running. You should see the container process with a normal PID (e.g., 1234), but from inside the container, `echo $$` should return 1.\n\n2. **Zombie Reaping Test**: Create a test that spawns child processes inside the container and verifies they're properly reaped. No zombie processes should accumulate in `ps aux | grep defunct`.\n\n3. **Signal Handling Test**: Send `SIGTERM` to the container and verify it shuts down gracefully within a reasonable timeout.\n\n**Signs Something is Wrong:**\n\n| Symptom | Likely Cause | Fix |\n|---------|---------------|-----|\n| Container process crashes immediately | Stack pointer calculation error | Check architecture-specific stack direction |\n| `clone()` fails with EPERM | Insufficient privileges | Run with sudo or check namespace availability |\n| Zombie processes accumulate | Missing or broken SIGCHLD handler | Verify signal handler installation and waitpid loop |\n| Container doesn't respond to signals | Missing signal handlers for PID 1 | Install handlers for SIGTERM, SIGINT early in init |\n| Container hangs on exit | Parent not properly waiting | Use waitpid() with correct PID, handle EINTR |\n\n\n## Mount Namespace Component\n\n> **Milestone(s):** This section corresponds to Milestone 2 (Mount Namespace), which implements filesystem isolation to create a contained filesystem view separate from the host system.\n\n### Mental Model: Stage Sets\n\nThink of mount namespaces like **theater stage sets**. In a theater production, each act might require a completely different scene - a living room for Act 1, a garden for Act 2, and a castle for Act 3. The audience sees only one set at a time, and when the curtain falls, the stage crew can completely transform the visible environment without affecting the real world outside the theater.\n\nA mount namespace works similarly for processes. Just as the theater audience sees only the current stage set and remains unaware of the other sets stored backstage, a process in a mount namespace sees only its own filesystem view and cannot access or even detect the filesystem mounts that exist on the host or in other namespaces. When we create a new mount namespace, we're essentially giving the container process its own \"stage\" where it can mount and unmount filesystems without affecting the host's filesystem layout.\n\nThe **pivot_root operation** is like the moment when the stage crew wheels out the old set and wheels in the new one. The audience (our container process) suddenly sees a completely different environment as their reality. What was once the host's `/` root directory becomes hidden away (like storing the old stage set), and the container's new root directory takes center stage as the process's new `/`.\n\nThis analogy helps explain why mount namespace isolation is so powerful: just as theater sets allow multiple completely different scenes to coexist in the same building without interfering with each other, mount namespaces allow multiple completely different filesystem views to coexist on the same machine without processes being able to escape their designated view.\n\n### Mount Namespace Interface\n\nThe mount namespace component provides the core functions necessary to create filesystem isolation and establish a contained root filesystem for the container process. These functions handle the complex sequence of operations required to safely transition from the host filesystem view to an isolated container filesystem view.\n\n![Mount Namespace and Pivot Root Process](./diagrams/mount-namespace-transitions.svg)\n\nThe primary interface functions coordinate multiple low-level mount operations to achieve filesystem isolation while maintaining the essential filesystems that the container process needs to function properly.\n\n| Method Name | Parameters | Returns | Description |\n|------------|------------|---------|-------------|\n| `create_mount_namespace` | `config container_config_t*`, `container container_instance_t*` | `int` | Creates new mount namespace and sets up isolated filesystem view |\n| `setup_container_rootfs` | `rootfs_path char*`, `old_root char*` | `int` | Prepares container root filesystem directory structure |\n| `pivot_to_container_root` | `new_root char*`, `old_root char*` | `int` | Switches filesystem root using pivot_root syscall |\n| `mount_essential_filesystems` | `void` | `int` | Mounts /proc, /sys, and /dev inside container namespace |\n| `setup_mount_propagation` | `void` | `int` | Configures mount propagation to prevent host leakage |\n| `bind_mount_host_directories` | `config container_config_t*` | `int` | Creates bind mounts for shared host directories |\n\nThe `create_mount_namespace` function serves as the main orchestrator for filesystem isolation. It begins by calling the `unshare` system call with the `CLONE_NEWNS` flag to create a new mount namespace, separating the container's filesystem view from the host. This operation creates a copy of the host's mount table that the container can then modify without affecting the host system.\n\nAfter creating the namespace, the function calls `setup_mount_propagation` to configure how mount events propagate between the new namespace and the host. This step is critical because the default mount propagation can cause container mounts to leak back to the host filesystem, breaking isolation. The function sets the propagation to `MS_PRIVATE` for the entire mount tree, ensuring that subsequent mount operations remain contained within the namespace.\n\nThe `setup_container_rootfs` function prepares the directory structure needed for the pivot_root operation. This involves creating the new root directory if it doesn't exist and setting up a temporary directory that will hold the old root filesystem after the pivot. The function also ensures that the new root directory is on a different filesystem from the current root, as required by the pivot_root syscall.\n\n> **Critical Design Insight**: The mount namespace isolation must occur before any filesystem modifications because once we start changing mounts, we need to ensure those changes remain contained within the container's namespace and don't affect the host system.\n\nThe `pivot_to_container_root` function performs the actual filesystem root transition using the pivot_root syscall. This operation atomically swaps the current root filesystem with the new container root, moving the old root to a subdirectory where it can be safely unmounted. This is more secure than using chroot because it completely removes access to the old root filesystem rather than simply changing the apparent root directory.\n\n### Pivot Root Process\n\nThe pivot root process represents one of the most complex aspects of container filesystem isolation, requiring careful coordination of multiple mount operations to safely transition the container process from the host filesystem view to its own isolated root filesystem.\n\nThe process begins with **namespace preparation**, where we ensure that the container has its own mount namespace and that mount propagation is configured to prevent operations from affecting the host. This preparation phase is critical because any mistakes here can cause container filesystem changes to leak back to the host system, breaking the isolation boundary.\n\n**Step-by-step pivot root algorithm:**\n\n1. **Validate filesystem requirements**: Check that the new root directory exists and is accessible, and verify that it's mounted on a different filesystem from the current root (pivot_root requirement).\n\n2. **Create old root directory**: Inside the new root filesystem, create a temporary directory (typically `/old-root`) that will hold the current root filesystem after the pivot operation.\n\n3. **Bind mount new root**: Perform a bind mount of the new root directory onto itself to ensure it appears as a proper mount point, as required by pivot_root semantics.\n\n4. **Execute pivot_root syscall**: Call `pivot_root(new_root, old_root_path)` to atomically swap the filesystem roots, making the new root become `/` and moving the old root to `/old-root`.\n\n5. **Change working directory**: Update the current working directory to the new root filesystem to ensure subsequent operations occur in the container context.\n\n6. **Mount essential filesystems**: Mount `/proc`, `/sys`, and `/dev` filesystems inside the new root to provide essential kernel interfaces that the container process needs.\n\n7. **Setup bind mounts**: Create any required bind mounts to share specific host directories with the container (like shared volumes or socket directories).\n\n8. **Unmount old root**: Safely unmount the old root filesystem from `/old-root` and remove the temporary directory, completing the isolation.\n\nThe **filesystem validation step** requires checking several conditions that are often overlooked. The new root directory must exist and be accessible, but it also must be a mount point or be bind-mounted to itself. This requirement stems from the way pivot_root verifies that it's operating on actual filesystems rather than simple directories.\n\n**Mount point verification** involves checking `/proc/mounts` to confirm that the new root appears as a separate mount entry. If the new root is just a directory on the existing filesystem, we must perform a bind mount operation: `mount --bind /path/to/new/root /path/to/new/root` to make it appear as a mount point.\n\n> **Essential Insight**: The pivot_root operation is atomic from the kernel's perspective, but the surrounding setup operations are not. This means we must carefully handle partial failures during the setup phase to avoid leaving the container in an inconsistent filesystem state.\n\nThe **old root management** phase requires creating the old root directory inside the new root filesystem before calling pivot_root. This directory serves as the mount point where the current root filesystem will be relocated. The directory name should be unique and temporary since it will be unmounted and removed after the pivot completes.\n\n**Essential filesystem mounting** happens after the pivot_root completes because these virtual filesystems need to appear in the container's filesystem namespace. The `/proc` filesystem provides process information and kernel interfaces, `/sys` exposes kernel and device information, and `/dev` provides device nodes. Each of these requires specific mount options and must be mounted in the correct order.\n\n### Architecture Decision Records\n\nThe mount namespace implementation requires several critical design decisions that affect both security and functionality. These decisions represent trade-offs between isolation strength, implementation complexity, and compatibility with existing systems.\n\n> **Decision: pivot_root vs chroot for Root Filesystem Isolation**\n> - **Context**: Container processes need to see a different root filesystem than the host, and we must choose between pivot_root and chroot for implementing this isolation\n> - **Options Considered**: pivot_root syscall, chroot syscall, bind mounts with chroot\n> - **Decision**: Use pivot_root for root filesystem switching\n> - **Rationale**: pivot_root provides true filesystem isolation by completely removing access to the old root, while chroot only changes the apparent root and allows escape via relative paths like `../../../` or file descriptors opened before the chroot\n> - **Consequences**: Requires more complex setup with mount namespace creation and old root management, but provides stronger security isolation\n\n| Option | Pros | Cons | Security Level |\n|--------|------|------|----------------|\n| pivot_root | Complete isolation, no escape paths, proper filesystem semantics | Complex setup, requires mount namespace, needs old root handling | High |\n| chroot | Simple implementation, widely understood, minimal setup | Escape vulnerabilities, relative path issues, file descriptor leaks | Low |\n| bind + chroot | Moderate complexity, some isolation improvements | Still vulnerable to chroot escapes, inconsistent behavior | Medium |\n\n> **Decision: Private Mount Propagation**\n> - **Context**: Mount operations inside the container namespace can propagate back to the host filesystem depending on mount propagation settings\n> - **Options Considered**: shared propagation, slave propagation, private propagation\n> - **Decision**: Use private mount propagation (MS_PRIVATE) for container mount namespace\n> - **Rationale**: Private propagation ensures that mount and unmount operations inside the container remain completely isolated and cannot affect the host filesystem, preventing accidental host filesystem modification\n> - **Consequences**: Container mounts are fully isolated but cannot share filesystems mounted on the host after container creation\n\nThe **mount propagation decision** significantly impacts how container filesystems interact with host filesystem changes. Private propagation creates the strongest isolation boundary but requires careful planning for any shared filesystem access needs.\n\n| Propagation Type | Host→Container | Container→Host | Use Case |\n|------------------|----------------|----------------|----------|\n| Private (chosen) | No | No | Full isolation |\n| Shared | Yes | Yes | Shared filesystems |\n| Slave | Yes | No | Read-only sharing |\n\n> **Decision: Essential Filesystem Mount Strategy**\n> - **Context**: Container processes need access to kernel interfaces like /proc and /sys, but mounting them incorrectly can create security vulnerabilities\n> - **Options Considered**: bind mount from host, fresh mount in namespace, selective bind mounting\n> - **Decision**: Fresh mount of essential filesystems in container namespace\n> - **Rationale**: Fresh mounting provides proper isolation and ensures container sees only its own processes and kernel state, while bind mounting would expose host process information\n> - **Consequences**: Requires knowledge of correct mount options for each filesystem type, but provides better security isolation\n\n**Essential filesystem mounting** requires understanding the specific purpose and security implications of each virtual filesystem. The `/proc` filesystem must be mounted fresh to show only container processes, while bind mounting would expose all host processes to the container.\n\n| Filesystem | Mount Type | Mount Options | Purpose |\n|------------|------------|---------------|---------|\n| /proc | Fresh | `proc /proc proc defaults` | Container process view |\n| /sys | Fresh | `sysfs /sys sysfs defaults` | Kernel interface access |\n| /dev | Bind subset | Selected devices only | Essential device nodes |\n| /dev/pts | Fresh | `devpts /dev/pts devpts defaults` | Pseudo-terminal support |\n\n### Common Pitfalls\n\nMount namespace implementation contains several subtle pitfalls that can compromise container isolation or cause runtime failures. These issues often manifest as seemingly unrelated problems, making them particularly challenging for developers new to container implementation.\n\n⚠️ **Pitfall: Mount Propagation Leakage**\n\nMany developers forget to configure mount propagation before performing container mount operations, causing container mounts to appear on the host filesystem. This happens because the default mount propagation setting is often `shared`, meaning mount operations propagate between namespaces.\n\n**Symptom**: Container directories appear mounted on the host system after container startup, and host system shows container-specific mount points in `/proc/mounts`.\n\n**Why it's wrong**: This breaks the fundamental isolation promise of containers. Host administrators can accidentally access container filesystems, and container mount operations can interfere with host system management.\n\n**Fix**: Call `mount(NULL, \"/\", NULL, MS_PRIVATE | MS_REC, NULL)` immediately after creating the mount namespace to set private propagation for the entire mount tree. The `MS_REC` flag applies the setting recursively to all existing mount points.\n\n⚠️ **Pitfall: pivot_root Directory Requirements**\n\nThe pivot_root syscall has strict requirements about the relationship between the old and new root directories that are not well documented. Failing to meet these requirements causes pivot_root to fail with unclear error messages.\n\n**Symptom**: pivot_root syscall fails with `EINVAL` error, even though both directories exist and are accessible.\n\n**Why it's wrong**: pivot_root requires that the new root directory be a mount point (not just a directory) and that the old root directory be located within the new root filesystem hierarchy.\n\n**Fix**: Before calling pivot_root, ensure the new root is a mount point by bind mounting it to itself: `mount(new_root, new_root, NULL, MS_BIND, NULL)`. Create the old root directory inside the new root filesystem, not alongside it.\n\n⚠️ **Pitfall: Device Node Accessibility**\n\nContainers often fail to access essential device nodes like `/dev/null`, `/dev/zero`, or `/dev/random` because these devices are not properly created or have incorrect permissions in the container namespace.\n\n**Symptom**: Container processes fail with \"Permission denied\" or \"No such file or directory\" errors when trying to open standard device files, causing applications to crash unexpectedly.\n\n**Why it's wrong**: Many applications and system libraries expect these device nodes to exist and be accessible. Without them, basic operations like discarding output (`> /dev/null`) or generating random numbers fail.\n\n**Fix**: Create essential device nodes in the container's `/dev` directory using `mknod` or bind mount selected devices from the host. Ensure proper permissions are set: `chmod 666 /dev/null /dev/zero /dev/random`.\n\n⚠️ **Pitfall: Filesystem Type Detection**\n\nDifferent filesystem types require different mount options and may behave unexpectedly when used as container root filesystems. Developers often assume all filesystems behave identically during pivot_root operations.\n\n**Symptom**: Container startup fails with mount errors or pivot_root failures that only occur on certain storage configurations or filesystem types.\n\n**Why it's wrong**: Some filesystems (like NFS or FUSE) have restrictions on operations like pivot_root, and some require specific mount options to work correctly in container scenarios.\n\n**Fix**: Detect the filesystem type using `statfs` or by parsing `/proc/mounts` before attempting pivot_root. Implement filesystem-specific handling for known problematic types, and provide clear error messages when unsupported filesystems are detected.\n\n⚠️ **Pitfall: Cleanup Order Dependencies**\n\nMount namespace cleanup must occur in the correct order to avoid leaving orphaned mounts or causing unmount failures. Incorrect cleanup order can leave host system resources tied up or cause subsequent container operations to fail.\n\n**Symptom**: Container cleanup fails with \"Device or resource busy\" errors, and `lsof` or `fuser` shows processes holding references to container mount points.\n\n**Why it's wrong**: Mount points have dependency relationships - unmounting a parent before its children fails, and some mount points cannot be unmounted while processes have open files on them.\n\n**Fix**: Implement cleanup in reverse order of creation: unmount children before parents, terminate all container processes before unmounting filesystems, and use lazy unmounting (`umount2` with `MNT_DETACH`) as a last resort for stuck mounts.\n\n### Implementation Guidance\n\nThe mount namespace component requires careful coordination of multiple system calls and precise error handling to achieve reliable filesystem isolation. The implementation must handle the complex interactions between mount namespaces, pivot_root requirements, and essential filesystem mounting.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Filesystem Detection | Parse `/proc/mounts` manually | Use `libmount` library for robust parsing |\n| Device Node Creation | Manual `mknod` calls with fixed device numbers | Dynamic device discovery from `/proc/devices` |\n| Mount Option Handling | Hard-coded options for common filesystems | Flexible configuration with validation |\n| Error Reporting | Simple errno checking with `perror` | Structured error context with operation details |\n\n#### Recommended File Structure\n\n```\ncontainer-basic/\n├── src/\n│   ├── container.c              ← main container orchestration\n│   ├── mount_namespace.c        ← mount namespace implementation\n│   ├── mount_namespace.h        ← mount namespace interface\n│   ├── filesystem_utils.c       ← helper functions for mount operations\n│   └── filesystem_utils.h       ← filesystem utility interface\n├── tests/\n│   ├── test_mount_namespace.c   ← unit tests for mount isolation\n│   └── test_filesystem_setup.c  ← integration tests for root setup\n└── examples/\n    └── minimal_container.c      ← demonstration of mount namespace usage\n```\n\n#### Infrastructure Starter Code\n\n**filesystem_utils.h:**\n```c\n#ifndef FILESYSTEM_UTILS_H\n#define FILESYSTEM_UTILS_H\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n// Essential device nodes that containers typically need\nstruct device_node {\n    const char* path;\n    mode_t mode;\n    dev_t device;\n};\n\n// Common filesystem types and their characteristics\nstruct filesystem_info {\n    const char* name;\n    int supports_pivot_root;\n    const char* default_options;\n};\n\n// Utility functions for mount operations\nint safe_mount(const char* source, const char* target, const char* type, \n               unsigned long flags, const void* data);\nint ensure_directory_exists(const char* path, mode_t mode);\nint create_device_node(const char* path, mode_t mode, dev_t device);\nint detect_filesystem_type(const char* path, char* type_buf, size_t buf_size);\nint is_mount_point(const char* path);\nint recursive_umount(const char* path);\n\n// Mount propagation utilities\nint set_mount_propagation(const char* path, int propagation_type);\nint make_private_recursive(const char* path);\n\n#endif // FILESYSTEM_UTILS_H\n```\n\n**filesystem_utils.c:**\n```c\n#include \"filesystem_utils.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/statfs.h>\n\n// Common device nodes needed in containers\nstatic const struct device_node essential_devices[] = {\n    {\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)},\n    {\"/dev/zero\", S_IFCHR | 0666, makedev(1, 5)},\n    {\"/dev/random\", S_IFCHR | 0666, makedev(1, 8)},\n    {\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9)},\n    {NULL, 0, 0} // sentinel\n};\n\nint safe_mount(const char* source, const char* target, const char* type,\n               unsigned long flags, const void* data) {\n    if (mount(source, target, type, flags, data) != 0) {\n        fprintf(stderr, \"Mount failed: source=%s target=%s type=%s: %s\\n\",\n                source ? source : \"none\",\n                target ? target : \"none\", \n                type ? type : \"none\",\n                strerror(errno));\n        return -1;\n    }\n    return 0;\n}\n\nint ensure_directory_exists(const char* path, mode_t mode) {\n    struct stat st;\n    if (stat(path, &st) == 0) {\n        if (S_ISDIR(st.st_mode)) {\n            return 0; // Directory already exists\n        } else {\n            errno = ENOTDIR;\n            return -1; // Path exists but is not a directory\n        }\n    }\n    \n    // Create directory and all parent directories\n    char* path_copy = strdup(path);\n    if (!path_copy) return -1;\n    \n    char* p = path_copy;\n    while ((p = strchr(p + 1, '/')) != NULL) {\n        *p = '\\0';\n        if (mkdir(path_copy, mode) != 0 && errno != EEXIST) {\n            free(path_copy);\n            return -1;\n        }\n        *p = '/';\n    }\n    \n    int result = mkdir(path_copy, mode);\n    free(path_copy);\n    \n    return (result == 0 || errno == EEXIST) ? 0 : -1;\n}\n\nint create_device_node(const char* path, mode_t mode, dev_t device) {\n    // Remove existing file if it exists\n    unlink(path);\n    \n    if (mknod(path, mode, device) != 0) {\n        fprintf(stderr, \"Failed to create device node %s: %s\\n\", \n                path, strerror(errno));\n        return -1;\n    }\n    \n    if (chmod(path, mode & 0777) != 0) {\n        fprintf(stderr, \"Failed to set permissions on %s: %s\\n\",\n                path, strerror(errno));\n        return -1;\n    }\n    \n    return 0;\n}\n\nint is_mount_point(const char* path) {\n    FILE* mounts = fopen(\"/proc/mounts\", \"r\");\n    if (!mounts) return -1;\n    \n    char line[1024];\n    char mount_point[512];\n    int found = 0;\n    \n    while (fgets(line, sizeof(line), mounts)) {\n        if (sscanf(line, \"%*s %511s %*s\", mount_point) == 1) {\n            if (strcmp(mount_point, path) == 0) {\n                found = 1;\n                break;\n            }\n        }\n    }\n    \n    fclose(mounts);\n    return found;\n}\n\nint set_mount_propagation(const char* path, int propagation_type) {\n    return mount(NULL, path, NULL, propagation_type | MS_REC, NULL);\n}\n\nint make_private_recursive(const char* path) {\n    return set_mount_propagation(path, MS_PRIVATE);\n}\n```\n\n#### Core Logic Skeleton Code\n\n**mount_namespace.h:**\n```c\n#ifndef MOUNT_NAMESPACE_H\n#define MOUNT_NAMESPACE_H\n\n#include \"container.h\"\n\n// Mount namespace creation and management\nint create_mount_namespace(container_config_t* config, container_instance_t* container);\nint setup_container_rootfs(const char* rootfs_path, const char* old_root);\nint pivot_to_container_root(const char* new_root, const char* old_root);\nint mount_essential_filesystems(void);\nint setup_mount_propagation(void);\nint bind_mount_host_directories(container_config_t* config);\n\n// Cleanup functions\nint cleanup_mount_namespace(container_instance_t* container);\n\n#endif // MOUNT_NAMESPACE_H\n```\n\n**mount_namespace.c skeleton:**\n```c\n#include \"mount_namespace.h\"\n#include \"filesystem_utils.h\"\n#include <sched.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\nint create_mount_namespace(container_config_t* config, container_instance_t* container) {\n    // TODO 1: Call unshare(CLONE_NEWNS) to create new mount namespace\n    // TODO 2: Set up private mount propagation to prevent leakage to host\n    // TODO 3: Register cleanup function for mount namespace teardown\n    // TODO 4: Store namespace file descriptor in container->namespace_fds[1]\n    // TODO 5: Return 0 on success, -1 on failure with errno set\n}\n\nint setup_container_rootfs(const char* rootfs_path, const char* old_root) {\n    // TODO 1: Check if rootfs_path exists and is accessible\n    // TODO 2: Ensure rootfs_path is a mount point (bind mount if necessary)\n    // TODO 3: Create old_root directory inside the new root filesystem\n    // TODO 4: Verify that new root and old root are on different filesystems\n    // TODO 5: Set appropriate permissions on directories\n    // Hint: Use is_mount_point() and ensure_directory_exists() helper functions\n}\n\nint pivot_to_container_root(const char* new_root, const char* old_root) {\n    // TODO 1: Change to the new root directory\n    // TODO 2: Call pivot_root(new_root, old_root) to swap filesystems\n    // TODO 3: Change working directory to new root (\"/\")\n    // TODO 4: Verify that pivot operation completed successfully\n    // TODO 5: Handle cleanup if pivot_root fails partway through\n    // Hint: Check that old_root path exists inside new_root before pivot\n}\n\nint mount_essential_filesystems(void) {\n    // TODO 1: Mount /proc filesystem: mount(\"proc\", \"/proc\", \"proc\", 0, NULL)\n    // TODO 2: Mount /sys filesystem: mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL)  \n    // TODO 3: Create /dev directory and mount tmpfs on it\n    // TODO 4: Create essential device nodes in /dev using create_device_node()\n    // TODO 5: Mount /dev/pts for pseudo-terminal support\n    // Hint: Use safe_mount() wrapper for better error reporting\n}\n\nint setup_mount_propagation(void) {\n    // TODO 1: Make entire mount tree private: mount(NULL, \"/\", NULL, MS_PRIVATE | MS_REC, NULL)\n    // TODO 2: Verify that propagation was set correctly\n    // TODO 3: Handle case where MS_PRIVATE is not supported on this kernel\n    // Hint: This must be done immediately after unshare(CLONE_NEWNS)\n}\n\nint bind_mount_host_directories(container_config_t* config) {\n    // TODO 1: Parse any host directory bind mount specifications from config\n    // TODO 2: For each bind mount, create target directory in container\n    // TODO 3: Perform bind mount: mount(host_path, container_path, NULL, MS_BIND, NULL)\n    // TODO 4: Set appropriate permissions on mounted directories\n    // TODO 5: Register cleanup functions for each bind mount\n    // Hint: Validate that host paths exist before attempting bind mount\n}\n\nint cleanup_mount_namespace(container_instance_t* container) {\n    // TODO 1: Unmount all container filesystems in reverse order\n    // TODO 2: Remove temporary directories created during setup\n    // TODO 3: Close namespace file descriptor stored in container->namespace_fds[1]\n    // TODO 4: Use lazy unmounting (MNT_DETACH) for stuck mounts\n    // TODO 5: Return 0 if all cleanup succeeded, -1 if any failures occurred\n    // Hint: Use recursive_umount() for complex mount hierarchies\n}\n```\n\n#### Language-Specific Hints\n\n**System Call Error Handling:**\n- Always check return values from `mount()`, `umount()`, and `pivot_root()` syscalls\n- Use `strerror(errno)` to get human-readable error descriptions\n- Log both the operation being attempted and the errno value for debugging\n\n**Mount Flags and Options:**\n- Use `MS_BIND` for bind mounts, `MS_PRIVATE` for mount propagation\n- Combine flags with bitwise OR: `MS_PRIVATE | MS_REC`\n- Pass `NULL` for unused parameters rather than empty strings\n\n**Directory Path Handling:**\n- Use `realpath()` to resolve symbolic links in filesystem paths\n- Check for trailing slashes in directory paths and normalize them\n- Validate that paths don't contain `..` components to prevent directory traversal\n\n**File Descriptor Management:**\n- Open namespace file descriptors from `/proc/self/ns/mnt` for cleanup reference\n- Use `O_CLOEXEC` flag when opening namespace descriptors\n- Close all file descriptors before calling `pivot_root()` to avoid \"busy\" errors\n\n#### Milestone Checkpoint\n\nAfter implementing the mount namespace component, verify the following behaviors:\n\n**Test Command:**\n```bash\n# Compile and run with a simple test rootfs\nsudo ./container-basic --rootfs /tmp/test-rootfs /bin/sh\n```\n\n**Expected Behaviors:**\n1. Container process should see `/proc/self/mountinfo` different from host\n2. Files created in container `/tmp` should not appear in host `/tmp` \n3. Container should be able to mount/unmount without affecting host\n4. Essential device nodes (`/dev/null`, `/dev/zero`) should be accessible\n5. Container `/proc/mounts` should show only container-specific mount points\n\n**Signs of Problems:**\n- \"Operation not permitted\" → Check if running with sufficient privileges (CAP_SYS_ADMIN)\n- \"Invalid argument\" from pivot_root → Verify new root is a mount point and old root directory exists\n- \"Device or resource busy\" → Check that no processes have open files in mount directories\n- Host shows container mounts → Mount propagation not set to private correctly\n\n**Debug Commands:**\n```bash\n# Check mount propagation\ncat /proc/self/mountinfo | grep -E \"(shared|slave|private)\"\n\n# Verify namespace isolation  \nsudo lsns -t mnt\n\n# Check device nodes in container\nls -la /dev/null /dev/zero /dev/random\n\n```\n\n\n## Network Namespace Component\n\n> **Milestone(s):** This section corresponds to Milestone 3 (Network Namespace), which implements network stack isolation and establishes container networking connectivity through veth pairs and bridge networking.\n\nThe network namespace component provides the foundation for container network isolation by creating a completely separate network stack for each container. This component coordinates with the PID and mount namespace components to ensure containers have their own network interfaces, IP addresses, routing tables, and firewall rules while maintaining connectivity to the host system and external networks.\n\nNetwork isolation represents one of the most complex aspects of container implementation because it must balance complete isolation with practical connectivity requirements. Unlike PID or mount namespaces which primarily restrict visibility, network namespaces must actively establish communication channels between isolated environments. This creates intricate coordination challenges around interface creation, IP address management, and routing configuration that must be handled correctly to avoid network conflicts or connectivity failures.\n\n### Mental Model: Private Phone Systems\n\nThink of network namespaces like separate office phone systems within a large corporate building. Each department (container) gets its own private phone system with internal extensions that are completely isolated from other departments. Employees within marketing can call each other using simple extension numbers (internal IP addresses), but they cannot directly dial into the engineering department's phone system.\n\nHowever, complete isolation would make the departments unable to collaborate or contact the outside world. So the building installs trunk lines (veth pairs) that connect each department's phone system to a central switchboard (host bridge). When marketing needs to call engineering, the call routes through the central switchboard which knows how to forward calls between departments. Similarly, all external calls to clients or vendors flow through the central switchboard to reach the appropriate department.\n\nThe central switchboard (host networking stack) maintains a directory of which trunk line connects to which department and handles call routing between departments and to external networks. If marketing needs internet access, their calls flow through their trunk line to the switchboard, which then forwards them through the building's main phone line to the external provider. The switchboard can also enforce policies about which departments can call where and implement features like call forwarding or conferencing between multiple departments.\n\nThis analogy maps directly to container networking: each container gets its own network namespace (private phone system), veth pairs act as trunk lines connecting container namespaces to the host bridge (central switchboard), and the host kernel handles routing between containers and to external networks. Just as phone systems need proper wiring and configuration to work correctly, container networking requires careful setup of virtual interfaces, IP addresses, and routing rules.\n\n### Network Namespace Interface\n\nThe network namespace interface provides functions for creating isolated network environments and establishing connectivity between containers and the host system. This interface abstracts the complexity of network namespace creation, veth pair management, and bridge configuration while ensuring proper cleanup and error handling.\n\nThe core responsibility of this component is coordinating the creation of network namespaces with the setup of communication channels that connect isolated containers to each other and external networks. This requires careful orchestration of kernel network namespace operations with user-space network configuration tools to establish a complete networking solution.\n\n| Function Name | Parameters | Returns | Description |\n|---------------|------------|---------|-------------|\n| `create_network_namespace` | config: `container_config_t*`, container: `container_instance_t*` | int (0 success, -1 error) | Creates new network namespace and stores namespace file descriptor for cleanup |\n| `setup_container_networking` | config: `container_config_t*`, container_pid: `pid_t` | int (0 success, -1 error) | Configures veth pair and assigns container end to target namespace |\n| `create_veth_pair` | host_if_name: `char*`, container_if_name: `char*` | int (0 success, -1 error) | Creates virtual ethernet pair with specified interface names |\n| `assign_veth_to_namespace` | if_name: `char*`, target_pid: `pid_t` | int (0 success, -1 error) | Moves network interface to target process namespace |\n| `configure_container_interface` | if_name: `char*`, ip_address: `char*`, netmask: `char*` | int (0 success, -1 error) | Sets IP address and brings interface up inside container namespace |\n| `attach_to_bridge` | if_name: `char*`, bridge_name: `char*` | int (0 success, -1 error) | Adds host veth end to specified bridge for inter-container communication |\n| `setup_default_route` | gateway_ip: `char*` | int (0 success, -1 error) | Configures default route inside container namespace for external connectivity |\n| `cleanup_network_namespace` | container: `container_instance_t*` | int (0 success, -1 error) | Removes veth interfaces and closes namespace file descriptors |\n| `verify_bridge_exists` | bridge_name: `char*` | int (1 exists, 0 missing) | Checks if specified bridge device exists on host system |\n| `allocate_container_ip` | bridge_name: `char*`, requested_ip: `char*` | char* (allocated IP, NULL on error) | Allocates available IP address from bridge subnet avoiding conflicts |\n\n![Namespace Isolation Diagram](./diagrams/namespace-isolation.svg)\n\nThe network namespace creation process begins when `create_network_namespace` is called during container startup. This function uses the `clone()` system call with the `CLONE_NEWNET` flag to create a new network namespace for the container process. The new namespace starts with only a loopback interface, completely isolated from the host network stack.\n\nHowever, complete network isolation renders containers unable to communicate with each other or external systems, so the interface includes functions for establishing controlled connectivity. The `setup_container_networking` function orchestrates the creation of a veth pair that acts as a network tunnel between the isolated container namespace and the host system. This function coordinates with `create_veth_pair` to establish the virtual ethernet devices and `assign_veth_to_namespace` to move the container end of the pair into the target namespace.\n\nNetwork configuration within the container namespace requires executing network configuration commands within the context of the isolated namespace. The `configure_container_interface` function handles IP address assignment and interface activation inside the container, while `setup_default_route` establishes routing rules for external connectivity. These functions must use namespace-aware network configuration approaches to ensure commands execute within the correct network context.\n\nThe interface provides robust cleanup capabilities through `cleanup_network_namespace`, which removes created veth interfaces and closes namespace file descriptors to prevent resource leaks. This function coordinates with the cleanup list mechanism to ensure proper teardown even during error conditions or partial setup failures.\n\n### Veth Pair Configuration\n\nVeth pairs represent the fundamental mechanism for connecting isolated network namespaces to the host system and enabling container networking. A veth pair consists of two virtual ethernet interfaces that act as opposite ends of a virtual network cable - packets sent into one end emerge from the other end. This creates a bidirectional communication channel that can span namespace boundaries.\n\n![Container Network Topology](./diagrams/network-topology.svg)\n\nThe veth pair configuration process involves several coordinated steps that must execute in the correct order to establish proper connectivity. First, the veth pair is created in the host namespace with both interfaces initially residing on the host. The kernel assigns the interfaces names like `veth0` and `veth1`, though these can be customized during creation to follow naming conventions that identify their purpose and associated container.\n\nAfter creating the veth pair, one interface (typically the one intended for the container) must be moved into the target network namespace. This operation uses the `ip link set` command with network namespace targeting to transfer ownership of the interface from the host namespace to the container namespace. Once transferred, the interface becomes invisible to the host system and appears only within the container's isolated network view.\n\nConfiguration of each veth interface requires namespace-specific commands that execute within the appropriate network context. The host-side veth interface typically gets added to a bridge device that connects multiple containers and provides routing to external networks. The container-side interface requires IP address assignment, netmask configuration, and interface activation to become usable for network communication.\n\n| Configuration Step | Location | Command Example | Purpose |\n|-------------------|----------|-----------------|---------|\n| Create veth pair | Host namespace | `ip link add veth0 type veth peer name veth1` | Establishes virtual ethernet pair |\n| Move to container | Host namespace | `ip link set veth1 netns <container-pid>` | Transfers interface to container namespace |\n| Configure container interface | Container namespace | `ip addr add 172.17.0.2/24 dev veth1` | Assigns IP address to container interface |\n| Activate container interface | Container namespace | `ip link set veth1 up` | Brings container interface online |\n| Add to host bridge | Host namespace | `ip link set veth0 master br0` | Connects host interface to bridge |\n| Activate host interface | Host namespace | `ip link set veth0 up` | Brings host interface online |\n\nThe veth pair configuration must handle IP address allocation to prevent conflicts between containers and ensure proper subnet organization. Container IP addresses typically come from a private subnet associated with the host bridge, such as `172.17.0.0/16` for Docker-style networking. The configuration process must track allocated IP addresses and select available addresses for new containers while avoiding conflicts with existing containers or host system interfaces.\n\nBridge networking represents the standard approach for connecting multiple container veth pairs and providing shared network access. The host system maintains a bridge device (similar to a network switch) that connects the host-side veth interfaces from all containers. This bridge can forward traffic between containers, route traffic to external networks through the host's physical interfaces, and implement network policies like NAT (Network Address Translation) for outbound connectivity.\n\nVeth pair cleanup requires careful coordination to avoid orphaned interfaces or namespace references. When a container terminates, both ends of its veth pair should be removed: the container-side interface disappears automatically when the namespace is destroyed, but the host-side interface must be explicitly deleted. Failure to clean up host-side veth interfaces leads to accumulation of unused network interfaces that consume system resources and clutter network configuration.\n\nThe veth configuration process must also handle error conditions gracefully, particularly partial setup failures where some network configuration succeeds but other steps fail. The cleanup list mechanism ensures that successfully created interfaces get removed even if subsequent configuration steps encounter errors, preventing the system from accumulating partially configured network resources.\n\n### Architecture Decision Records\n\nThe network namespace component involves several critical architectural decisions that significantly impact performance, complexity, and functionality. These decisions affect how containers connect to networks, how IP addresses are managed, and how traffic flows between containers and external systems.\n\n> **Decision: Veth Pairs vs MacVLAN for Container Networking**\n> - **Context**: Containers need network connectivity while maintaining isolation. Linux provides multiple approaches for connecting namespaces to host networking, including veth pairs with bridges and MacVLAN interfaces that share physical network adapters.\n> - **Options Considered**: Veth pairs with bridge networking, MacVLAN interfaces, SR-IOV virtual functions\n> - **Decision**: Use veth pairs connected through a host bridge for container networking\n> - **Rationale**: Veth pairs provide complete traffic visibility on the host for monitoring and security policies, support arbitrary network topologies through bridge configuration, and work reliably across different host network configurations. MacVLAN requires specific network adapter features and limits traffic inspection capabilities.\n> - **Consequences**: Enables flexible network policies and traffic monitoring but requires bridge configuration and slightly increases network latency due to additional packet processing through the bridge.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Veth + Bridge | Full traffic visibility, flexible topologies, universal adapter support | Additional latency, more complex setup | ✅ Yes |\n| MacVLAN | Lower latency, simpler container setup | Limited traffic visibility, adapter feature requirements | ❌ No |\n| SR-IOV | Highest performance, hardware acceleration | Expensive hardware requirements, complex management | ❌ No |\n\n> **Decision: Bridge Networking vs Host Networking vs Overlay Networks**\n> - **Context**: Multiple containers need to communicate with each other and external networks. Different networking models provide different levels of isolation, performance, and configuration complexity.\n> - **Options Considered**: Single host bridge for all containers, host networking without isolation, overlay networks with VXLAN tunneling\n> - **Decision**: Implement single host bridge networking with configurable bridge names\n> - **Rationale**: Host bridge networking provides good isolation between containers while enabling inter-container communication and external connectivity. It offers predictable performance characteristics and straightforward troubleshooting compared to overlay networks, while maintaining better security than host networking.\n> - **Consequences**: Limits containers to single-host networking but provides reliable, performant connectivity suitable for basic container use cases. Advanced multi-host scenarios require additional networking solutions.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Host Bridge | Good isolation, inter-container communication, simple troubleshooting | Single-host limitation, manual IP management | ✅ Yes |\n| Host Networking | Maximum performance, no configuration needed | No network isolation, port conflicts | ❌ No |\n| Overlay Networks | Multi-host support, advanced features | Complex setup, performance overhead | ❌ No |\n\n> **Decision: Static IP Assignment vs DHCP vs Automatic Allocation**\n> - **Context**: Containers need IP addresses within the bridge subnet, but manual IP assignment is error-prone while DHCP adds complexity. The system needs a reliable approach for avoiding IP conflicts between containers.\n> - **Options Considered**: Manual static IP specification, DHCP server for automatic assignment, simple automatic allocation from IP pool\n> - **Decision**: Implement simple automatic IP allocation with optional static IP override\n> - **Rationale**: Automatic allocation from a predefined IP pool eliminates configuration errors and IP conflicts while remaining simple to implement and debug. DHCP adds complexity and external dependencies, while purely manual assignment creates operational burden and conflict potential.\n> - **Consequences**: Provides predictable IP allocation for most use cases while supporting static assignment when needed. Requires tracking allocated IP addresses but avoids complex DHCP infrastructure.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Static Assignment | Predictable addresses, no coordination needed | Manual configuration, conflict potential | ❌ No |\n| DHCP | Industry standard, lease management | Complex setup, external dependencies | ❌ No |\n| Automatic Allocation | Simple implementation, conflict avoidance | IP tracking required, limited flexibility | ✅ Yes |\n\n> **Decision: NAT vs Bridge Routing for External Connectivity**\n> - **Context**: Containers with private IP addresses need access to external networks and internet services. This requires either NAT (Network Address Translation) to hide container IPs behind host IP or direct routing if container IPs are routable.\n> - **Options Considered**: NAT with iptables masquerading, direct routing with routable container subnets, proxy-based external access\n> - **Decision**: Implement NAT-based external connectivity using iptables masquerading\n> - **Rationale**: NAT provides external connectivity without requiring routable IP address allocation or complex routing configuration. It works reliably across different host network environments and provides additional security by hiding internal container addressing.\n> - **Consequences**: Enables external connectivity with simple host configuration but prevents direct inbound connections to containers without port forwarding. Adds slight performance overhead for address translation.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| NAT/Masquerading | Works in any network, simple setup, security benefits | No direct inbound access, translation overhead | ✅ Yes |\n| Direct Routing | Better performance, bidirectional connectivity | Requires routable IPs, complex routing | ❌ No |\n| Proxy Access | Fine-grained control, protocol-specific features | Application-specific, complex configuration | ❌ No |\n\nThese architectural decisions establish a networking model that balances simplicity, functionality, and reliability for basic container networking requirements. The veth pair and bridge approach provides a solid foundation that can be extended with additional features like port forwarding, network policies, or multi-host connectivity as requirements evolve.\n\n### Common Pitfalls\n\nNetwork namespace implementation presents several subtle pitfalls that can cause connectivity failures, resource leaks, or security issues. These problems often manifest as intermittent failures or unexpected behavior that can be difficult to diagnose without understanding the underlying timing and coordination requirements.\n\n⚠️ **Pitfall: Namespace Timing Issues During Interface Assignment**\n\nA common mistake is attempting to configure network interfaces before the target namespace is fully established or accessible. When moving a veth interface to a container namespace using `ip link set veth1 netns <pid>`, the operation can fail if the target process has not yet called `unshare(CLONE_NEWNET)` or if the process has already exited.\n\nThis timing issue typically occurs when the parent process creates veth pairs and immediately tries to assign them to the child container process, but the child process hasn't yet established its network namespace or has encountered an error during startup. The assignment operation fails with \"No such file or directory\" or \"Invalid argument\" errors that don't clearly indicate the timing problem.\n\nTo avoid this pitfall, implement proper synchronization between parent and child processes during container startup. Use signaling mechanisms like pipes or shared memory to ensure the child process has successfully created its network namespace before the parent attempts interface assignment. Additionally, implement retry logic with appropriate timeouts for interface assignment operations to handle minor timing variations.\n\n⚠️ **Pitfall: Veth Interface Cleanup and Orphaned Interfaces**\n\nFailing to properly clean up veth interfaces leads to accumulation of orphaned network interfaces on the host system. When a container terminates unexpectedly or cleanup functions encounter errors, the host-side veth interface may remain active even though the container-side interface has disappeared with the destroyed namespace.\n\nThese orphaned interfaces consume system resources, clutter network interface listings, and can cause naming conflicts when creating new containers. They may also remain attached to bridge devices, causing confusion during network troubleshooting and potentially affecting bridge behavior.\n\nImplement comprehensive cleanup tracking using the cleanup list mechanism to ensure veth interfaces are removed even during error conditions. Store interface names in the cleanup list immediately after creation, and implement cleanup functions that gracefully handle cases where interfaces may have already been removed. Use network interface enumeration to detect and clean up orphaned interfaces during system startup or periodic maintenance.\n\n⚠️ **Pitfall: Bridge Configuration and Dependency Ordering**\n\nAttempting to attach veth interfaces to bridges that don't exist or haven't been properly configured causes network setup failures. Many implementations assume that bridge devices exist and are properly configured, but fail to verify bridge state or create necessary bridge configuration before attempting to use them.\n\nBridge configuration issues also include problems with IP forwarding, NAT rules, and routing table entries that must be established on the host system for container networking to function correctly. Missing or incorrect iptables rules prevent external connectivity even when internal container networking appears to work correctly.\n\nImplement bridge existence verification and automatic bridge creation as part of the network setup process. Create comprehensive bridge configuration functions that handle IP forwarding enablement, NAT rule installation, and routing table management. Use dependency ordering to ensure bridge configuration completes before attempting to attach container interfaces.\n\n⚠️ **Pitfall: IP Address Conflicts and Allocation Tracking**\n\nSimple IP address allocation without conflict detection leads to multiple containers receiving the same IP address, causing network connectivity problems that are difficult to diagnose. This typically occurs when IP allocation doesn't track previously assigned addresses or when containers terminate without properly releasing their IP allocations.\n\nIP conflicts manifest as intermittent connectivity issues, ARP (Address Resolution Protocol) conflicts, and unpredictable network behavior where traffic intended for one container reaches another container. These problems become more severe as the number of containers increases and IP address reuse becomes more common.\n\nImplement proper IP address allocation tracking using persistent storage or in-memory data structures that survive container lifecycle events. Include IP address validation during allocation to detect and avoid conflicts with existing network interfaces. Implement IP address release mechanisms that execute during container cleanup to ensure addresses become available for reuse.\n\n⚠️ **Pitfall: NAT Configuration and iptables Rule Management**\n\nIncorrect NAT configuration prevents container external connectivity and can interfere with host system networking. Common mistakes include missing MASQUERADE rules, incorrect source/destination specifications in iptables rules, and failure to enable IP forwarding at the kernel level.\n\nNAT configuration problems often manifest as containers being able to communicate with each other but unable to reach external networks or receive responses to outbound connections. These issues can be particularly confusing because DNS resolution may work (if using internal DNS servers) while actual service connectivity fails.\n\nImplement systematic NAT configuration with proper rule validation and testing. Create iptables rule management functions that handle rule installation, removal, and conflict detection. Include IP forwarding enablement as part of the standard network setup process, and implement connectivity testing to verify external access after NAT configuration.\n\n⚠️ **Pitfall: Network Namespace File Descriptor Management**\n\nNetwork namespaces must be properly referenced through file descriptors to ensure they persist even after the creating process exits. Failing to maintain namespace file descriptors can cause namespaces to be destroyed prematurely, leading to network connectivity loss and cleanup problems.\n\nNetwork namespace file descriptors require careful management during process lifecycle events, particularly when container processes fork, exec, or terminate. Improper file descriptor handling can lead to namespace reference leaks or premature namespace destruction that breaks container networking.\n\nImplement explicit network namespace file descriptor management with proper cleanup tracking. Store namespace file descriptors in the container instance structure and ensure they are properly closed during container termination. Use file descriptor validation to detect and handle cases where namespaces have been unexpectedly destroyed.\n\n### Implementation Guidance\n\nThe network namespace implementation requires careful coordination of kernel networking features with user-space network configuration tools. This component builds upon the foundation established by the PID and mount namespace components while adding the complexity of network interface management and inter-process communication for network setup.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Network Configuration | System calls to `ip` command via `system()` | Direct netlink socket programming for kernel communication |\n| Bridge Management | Bridge utilities (`brctl` command) | Native netlink interface manipulation |\n| IP Address Management | Static allocation from predefined subnet | Dynamic allocation with conflict detection and persistence |\n| NAT Configuration | iptables command execution | Direct netfilter programming |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  cmd/container/main.c         ← main container runtime entry point\n  src/network/                 ← network namespace component\n    network_namespace.c        ← core network namespace functions\n    veth_manager.c             ← veth pair creation and configuration\n    bridge_config.c            ← bridge setup and management\n    ip_allocator.c             ← IP address allocation and tracking\n    network_namespace.h        ← public interface definitions\n    network_internal.h         ← internal types and helper functions\n  src/common/                  ← shared infrastructure\n    cleanup.c                  ← cleanup list implementation\n    syscall_wrappers.c         ← safe system call wrappers\n  tests/network/               ← network-specific tests\n    test_network_isolation.c   ← namespace isolation verification\n    test_veth_setup.c          ← veth pair configuration tests\n    test_connectivity.c        ← end-to-end networking tests\n```\n\n#### Infrastructure Starter Code\n\n**Network Configuration Helper (`src/network/network_utils.c`):**\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <errno.h>\n#include \"network_internal.h\"\n\n// Execute network configuration command and return exit status\nint exec_network_command(const char* command) {\n    int status = system(command);\n    if (status == -1) {\n        perror(\"system() failed\");\n        return -1;\n    }\n    return WEXITSTATUS(status);\n}\n\n// Execute command within specific network namespace context\nint exec_in_netns(pid_t target_pid, const char* command) {\n    char full_command[512];\n    snprintf(full_command, sizeof(full_command), \n             \"nsenter -t %d -n %s\", target_pid, command);\n    return exec_network_command(full_command);\n}\n\n// Check if network interface exists\nint interface_exists(const char* if_name) {\n    char path[256];\n    snprintf(path, sizeof(path), \"/sys/class/net/%s\", if_name);\n    return access(path, F_OK) == 0;\n}\n\n// Generate unique interface name for container\nvoid generate_veth_names(const char* container_id, \n                        char* host_if, size_t host_len,\n                        char* container_if, size_t container_len) {\n    snprintf(host_if, host_len, \"veth%s\", container_id);\n    snprintf(container_if, container_len, \"eth0\");\n    \n    // Truncate if name too long for kernel limits\n    if (strlen(host_if) >= IFNAMSIZ) {\n        host_if[IFNAMSIZ-1] = '\\0';\n    }\n}\n\n// Validate IP address format\nint is_valid_ip(const char* ip_str) {\n    struct sockaddr_in sa;\n    return inet_pton(AF_INET, ip_str, &(sa.sin_addr)) == 1;\n}\n```\n\n**Bridge Management Helper (`src/network/bridge_utils.c`):**\n```c\n#include <stdio.h>\n#include <string.h>\n#include \"network_internal.h\"\n\n// Ensure bridge device exists and is properly configured\nint ensure_bridge_ready(const char* bridge_name, const char* bridge_ip) {\n    char command[256];\n    \n    // Check if bridge already exists\n    if (!interface_exists(bridge_name)) {\n        // Create bridge device\n        snprintf(command, sizeof(command), \"ip link add %s type bridge\", bridge_name);\n        if (exec_network_command(command) != 0) {\n            fprintf(stderr, \"Failed to create bridge %s\\n\", bridge_name);\n            return -1;\n        }\n        \n        // Assign IP address to bridge\n        snprintf(command, sizeof(command), \"ip addr add %s dev %s\", bridge_ip, bridge_name);\n        if (exec_network_command(command) != 0) {\n            fprintf(stderr, \"Failed to assign IP to bridge %s\\n\", bridge_name);\n            return -1;\n        }\n        \n        // Bring bridge interface up\n        snprintf(command, sizeof(command), \"ip link set %s up\", bridge_name);\n        if (exec_network_command(command) != 0) {\n            fprintf(stderr, \"Failed to bring up bridge %s\\n\", bridge_name);\n            return -1;\n        }\n    }\n    \n    return 0;\n}\n\n// Enable IP forwarding for container networking\nint enable_ip_forwarding() {\n    FILE* fp = fopen(\"/proc/sys/net/ipv4/ip_forward\", \"w\");\n    if (fp == NULL) {\n        perror(\"Failed to open ip_forward\");\n        return -1;\n    }\n    \n    if (fprintf(fp, \"1\") < 0) {\n        perror(\"Failed to enable IP forwarding\");\n        fclose(fp);\n        return -1;\n    }\n    \n    fclose(fp);\n    return 0;\n}\n\n// Setup NAT rules for container external connectivity\nint setup_nat_rules(const char* bridge_name, const char* subnet) {\n    char command[512];\n    \n    // Add MASQUERADE rule for outbound traffic\n    snprintf(command, sizeof(command),\n             \"iptables -t nat -A POSTROUTING -s %s ! -o %s -j MASQUERADE\",\n             subnet, bridge_name);\n    \n    if (exec_network_command(command) != 0) {\n        fprintf(stderr, \"Failed to setup NAT masquerading\\n\");\n        return -1;\n    }\n    \n    // Allow forwarding for bridge traffic\n    snprintf(command, sizeof(command),\n             \"iptables -A FORWARD -i %s ! -o %s -j ACCEPT\", bridge_name, bridge_name);\n    \n    if (exec_network_command(command) != 0) {\n        fprintf(stderr, \"Failed to setup bridge forwarding\\n\");\n        return -1;\n    }\n    \n    return 0;\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Main Network Namespace Functions (`src/network/network_namespace.c`):**\n```c\n#include \"network_namespace.h\"\n#include \"network_internal.h\"\n\n// Create new network namespace and setup basic networking\nint create_network_namespace(container_config_t* config, container_instance_t* container) {\n    // TODO 1: Verify bridge exists and create if necessary using ensure_bridge_ready()\n    // TODO 2: Enable IP forwarding and setup NAT rules for external connectivity\n    // TODO 3: Store current network namespace fd in container->namespace_fds[NETNS_INDEX]\n    // TODO 4: Network namespace creation happens during clone() - just setup cleanup here\n    // TODO 5: Register cleanup function for network namespace file descriptor\n    // Hint: Network namespace created automatically with CLONE_NEWNET flag in clone()\n}\n\n// Setup container networking after process creation\nint setup_container_networking(container_config_t* config, container_instance_t* container) {\n    // TODO 1: Generate unique veth pair names using container ID\n    // TODO 2: Create veth pair in host namespace using create_veth_pair()\n    // TODO 3: Move container-side veth to target namespace using assign_veth_to_namespace()\n    // TODO 4: Configure host-side veth and attach to bridge using attach_to_bridge()\n    // TODO 5: Configure container-side interface IP and routes using configure_container_interface()\n    // TODO 6: Register cleanup functions for created veth interfaces\n    // Hint: Use container->child_pid as target for namespace assignment\n}\n\n// Create virtual ethernet pair for container networking\nint create_veth_pair(const char* host_if_name, const char* container_if_name) {\n    // TODO 1: Construct ip command to create veth pair with specified names\n    // TODO 2: Execute command using exec_network_command() and check return code\n    // TODO 3: Verify both interfaces were created using interface_exists()\n    // TODO 4: Return 0 on success, -1 on failure with appropriate error logging\n    // Hint: Command format: \"ip link add <host> type veth peer name <container>\"\n}\n\n// Assign network interface to target namespace\nint assign_veth_to_namespace(const char* if_name, pid_t target_pid) {\n    // TODO 1: Construct ip command to move interface to target namespace\n    // TODO 2: Execute command and handle potential timing issues with retries\n    // TODO 3: Verify interface no longer exists in host namespace\n    // TODO 4: Log success/failure with specific error information\n    // Hint: Command format: \"ip link set <interface> netns <pid>\"\n}\n\n// Configure IP address and routes inside container namespace\nint configure_container_interface(const char* if_name, const char* ip_address, \n                                 const char* netmask, pid_t container_pid) {\n    // TODO 1: Assign IP address to interface using exec_in_netns()\n    // TODO 2: Bring interface up inside container namespace\n    // TODO 3: Add default route through bridge gateway\n    // TODO 4: Verify connectivity with ping test to gateway\n    // Hint: Use exec_in_netns() to run commands in container's network namespace\n}\n\n// Cleanup network namespace resources\nint cleanup_network_namespace(container_instance_t* container) {\n    // TODO 1: Remove host-side veth interfaces if they still exist\n    // TODO 2: Close network namespace file descriptor\n    // TODO 3: Execute registered cleanup functions in reverse order\n    // TODO 4: Clear namespace references from container structure\n    // Hint: Container namespace destruction happens automatically when process exits\n}\n```\n\n**IP Address Allocation (`src/network/ip_allocator.c`):**\n```c\n#include \"network_internal.h\"\n\n// Simple IP address allocator for container networking\nchar* allocate_container_ip(const char* bridge_name, const char* requested_ip) {\n    // TODO 1: If requested_ip provided and valid, check for conflicts and return if available\n    // TODO 2: Otherwise, scan bridge subnet (e.g., 172.17.0.0/24) for available IP\n    // TODO 3: Check each potential IP against existing interfaces using ping test\n    // TODO 4: Return allocated IP address string, or NULL if allocation failed\n    // TODO 5: Store allocation in tracking structure for conflict prevention\n    // Hint: Start scanning from .2 (after gateway .1) and avoid broadcast addresses\n}\n\n// Release IP address back to available pool\nint release_container_ip(const char* ip_address) {\n    // TODO 1: Remove IP from allocation tracking structure\n    // TODO 2: Perform any cleanup of IP-specific routes or rules\n    // TODO 3: Return 0 on success, -1 if IP was not tracked\n    // Hint: Implementation can be simple file-based or in-memory tracking\n}\n```\n\n#### Language-Specific Hints\n\n**System Call Integration:**\n- Use `system()` for executing network configuration commands during development, but consider netlink sockets for production implementations\n- Network namespace file descriptors can be opened from `/proc/<pid>/ns/net` for explicit namespace management\n- The `nsenter` command provides reliable namespace context switching for configuration commands\n\n**Error Handling:**\n- Network configuration commands can fail for many reasons (permissions, missing features, timing issues)\n- Implement retry logic for operations that may encounter timing issues during namespace creation\n- Use specific error messages that include the failed command and system error information\n\n**Debugging Support:**\n- Log all executed network commands and their return codes for troubleshooting\n- Include network interface enumeration in debug output to show current system state\n- Implement connectivity testing functions that verify network setup success\n\n#### Milestone Checkpoint\n\nAfter implementing the network namespace component, verify the following behavior:\n\n**Compilation and Basic Testing:**\n```bash\ncd project-root\nmake clean && make\nsudo ./container-basic --network-test\n```\n\n**Expected Network Isolation:**\n1. Container process should have its own network namespace with only loopback interface initially\n2. After veth setup, container should have `eth0` interface with assigned IP address\n3. Container should be able to ping bridge gateway and reach external networks\n4. Host system should show veth interface connected to bridge with appropriate naming\n\n**Manual Verification Steps:**\n```bash\n# Start container in background\nsudo ./container-basic --config test.conf --background\n\n# Check namespace isolation\nsudo lsns -t net  # Should show separate network namespace for container\n\n# Verify veth pair creation\nip link show | grep veth  # Should show host-side veth interface\n\n# Test container connectivity\nsudo nsenter -t <container-pid> -n ping -c 1 8.8.8.8  # Should succeed\n\n# Verify bridge attachment\nbrctl show  # Should show veth interface attached to bridge\n```\n\n**Debugging Signs:**\n- **Container cannot reach external networks**: Check NAT rules and IP forwarding configuration\n- **Veth interfaces not created**: Verify network namespace creation and timing coordination\n- **IP address conflicts**: Check IP allocation logic and conflict detection\n- **Bridge connectivity fails**: Verify bridge configuration and interface attachment\n\n\n## Cgroups Resource Management Component\n\n> **Milestone(s):** This section corresponds to Milestone 4 (Cgroups Resource Limits), which implements resource control and enforcement using Linux cgroups to limit CPU, memory, and process counts within containers.\n\n### Mental Model: Budget Allocation\n\nThink of cgroups like a household budget system with automatic enforcement. In a family budget, you allocate specific amounts for different categories: $500 for groceries, $200 for entertainment, $300 for utilities. Each category has a hard limit - when the grocery budget is exhausted, no more grocery purchases are allowed until next month.\n\nCgroups work similarly for system resources. You create a \"resource budget\" for your container: 512MB of memory, 50% of one CPU core, maximum 100 processes. The kernel automatically enforces these limits - when the container tries to allocate its 513th megabyte of memory, the kernel denies the allocation (and may terminate the process). When it tries to use more than 50% CPU over a time period, the kernel throttles the container's processes.\n\nThe key insight is that cgroups provide **automatic enforcement** - you don't have to manually monitor resource usage. The kernel does the accounting and applies limits transparently. This is like having a bank that automatically declines transactions when you exceed your budget category limits, rather than requiring you to manually track every expense.\n\nJust as budget categories can be nested (entertainment budget might have sub-categories for movies vs games), cgroups form a hierarchy. You can create a parent cgroup for all containers with an overall memory limit, then create child cgroups for individual containers with smaller limits within that parent's allocation.\n\n### Cgroups Interface\n\nThe cgroups interface provides functions for creating resource-limited execution contexts and enforcing those limits throughout the container lifecycle. Unlike namespaces which provide isolation, cgroups provide **resource control** - they determine how much of each system resource type the container can consume.\n\nThe core challenge in cgroups management is handling both cgroups v1 and v2 systems, which have different filesystem layouts and control interfaces. Our design abstracts this complexity behind a unified interface that detects the available cgroup version and adapts accordingly.\n\n| Function Name | Parameters | Returns | Description |\n|---------------|------------|---------|-------------|\n| `create_container_cgroup` | `config container_config_t*`, `container container_instance_t*` | `int` | Creates cgroup hierarchy for container and configures resource limits |\n| `assign_process_to_cgroup` | `cgroup_path char*`, `pid pid_t` | `int` | Assigns process to cgroup by writing PID to tasks file |\n| `set_memory_limit` | `cgroup_path char*`, `limit_bytes size_t` | `int` | Configures memory limit and OOM behavior for cgroup |\n| `set_cpu_limit` | `cgroup_path char*`, `cpu_percent int` | `int` | Configures CPU quota and period to limit CPU usage percentage |\n| `set_process_limit` | `cgroup_path char*`, `max_processes int` | `int` | Configures maximum number of processes/threads in cgroup |\n| `cleanup_container_cgroup` | `cgroup_path char*` | `int` | Removes cgroup directory and cleans up kernel resources |\n| `detect_cgroup_version` | `void` | `int` | Detects whether system uses cgroups v1 or v2 and returns version |\n| `get_cgroup_path` | `container_id char*`, `controller char*` | `char*` | Constructs filesystem path for container's cgroup in specified controller |\n| `verify_controller_available` | `controller char*` | `int` | Checks if specified cgroup controller is available and enabled |\n| `read_cgroup_stat` | `cgroup_path char*`, `stat_name char*` | `long` | Reads current resource usage statistics from cgroup |\n\nThe cgroup creation process follows a specific sequence to ensure proper resource limit enforcement. First, we detect which cgroup version is available on the system, as this determines both the filesystem layout and the control file formats. Then we create the cgroup directory hierarchy, configure resource limits in the appropriate control files, and finally assign the container process to the cgroup.\n\n> **Design Principle**: Cgroups must be created **before** the container process starts to ensure resource limits are enforced from the very beginning of execution. Creating cgroups after process startup creates a window where the process can consume unlimited resources.\n\nThe cgroup cleanup process is equally critical. When a container exits, the cgroup must be properly destroyed to prevent resource leaks in the kernel's cgroup accounting system. However, cleanup can only occur after all processes in the cgroup have exited - attempting to remove a cgroup with active processes will fail.\n\n### Resource Controllers\n\nLinux cgroups provide multiple **controllers** that each manage a different type of system resource. Our container implementation focuses on three essential controllers: memory, CPU, and process limits (pids). Each controller has its own control interface and enforcement mechanisms.\n\n#### Memory Controller\n\nThe memory controller tracks and limits memory usage for all processes within a cgroup. This includes anonymous memory (heap allocations), page cache, and kernel memory allocated on behalf of the cgroup's processes.\n\n| Control File | Purpose | Example Value | Effect |\n|-------------|---------|---------------|--------|\n| `memory.limit_in_bytes` (v1) / `memory.max` (v2) | Maximum memory allocation | `536870912` (512MB) | Hard limit - allocations beyond this trigger OOM |\n| `memory.usage_in_bytes` (v1) / `memory.current` (v2) | Current memory usage | `134217728` (128MB) | Read-only current usage counter |\n| `memory.oom_control` (v1) / `memory.oom.group` (v2) | OOM killer behavior | `oom_kill_disable 0` | Controls whether OOM killer terminates processes |\n| `memory.swappiness` | Swap preference | `60` | How aggressively to use swap (0-100) |\n\nThe memory controller enforcement works through the kernel's memory allocation paths. When a process in the cgroup requests memory (via `malloc()`, `mmap()`, or kernel allocations), the kernel checks the current cgroup usage against the limit. If the allocation would exceed the limit, the kernel either denies the allocation or invokes the OOM (Out of Memory) killer to terminate processes and free memory.\n\n> **Critical Insight**: Memory limits are enforced at allocation time, not usage time. A process that gradually increases its memory usage will trigger OOM when it crosses the limit, but a process that maps large virtual memory regions may fail earlier when trying to actually access those pages.\n\nMemory controller configuration involves several steps:\n\n1. Write the memory limit in bytes to the appropriate control file\n2. Configure OOM behavior - whether to kill processes or pause the cgroup\n3. Set memory swappiness to control swap usage preferences\n4. Monitor memory usage through the usage statistics file\n\n#### CPU Controller\n\nThe CPU controller limits the amount of CPU time that processes in a cgroup can consume over time periods. Unlike memory limits which are hard caps, CPU limits are implemented through **quota and period** scheduling - the cgroup gets a quota of CPU time within each scheduling period.\n\n| Control File | Purpose | Example Value | Effect |\n|-------------|---------|---------------|--------|\n| `cpu.cfs_quota_us` (v1) / `cpu.max` (v2) | CPU time quota per period | `50000` (50ms) | Maximum CPU time in microseconds |\n| `cpu.cfs_period_us` (v1) / `cpu.max` (v2) | Scheduling period length | `100000` (100ms) | Period length in microseconds |\n| `cpu.stat` | CPU usage statistics | `nr_periods 1234` | Read-only usage and throttling stats |\n| `cpu.shares` (v1) / `cpu.weight` (v2) | Relative CPU priority | `1024` | Share of CPU when competing with other cgroups |\n\nThe CPU quota system works by giving each cgroup a time budget that refreshes every period. For example, to limit a container to 50% of one CPU core, you set a quota of 50,000 microseconds (50ms) with a period of 100,000 microseconds (100ms). The container's processes can run for up to 50ms out of every 100ms period. When the quota is exhausted, the kernel suspends the cgroup's processes until the next period begins.\n\nCPU controller configuration requires calculating the appropriate quota and period values:\n\n1. Determine the desired CPU percentage (from `container_config_t.cpu_percent`)\n2. Choose a period length (typically 100ms for good responsiveness)\n3. Calculate quota as: `quota = (cpu_percent / 100) * period`\n4. Write both values to the control files\n5. Monitor CPU throttling through statistics files\n\n#### Process Controller (PIDs)\n\nThe process controller limits the number of processes and threads that can be created within a cgroup. This prevents fork bombs and runaway process creation from consuming all available PIDs on the system.\n\n| Control File | Purpose | Example Value | Effect |\n|-------------|---------|---------------|--------|\n| `pids.max` | Maximum number of processes | `100` | Hard limit on process/thread count |\n| `pids.current` | Current process count | `23` | Read-only current process counter |\n| `pids.events` | Limit violation events | `max 5` | Counter of times limit was hit |\n\nThe process controller enforcement occurs during process creation system calls (`fork()`, `clone()`, `vfork()`). When a process in the cgroup attempts to create a new process or thread, the kernel increments the cgroup's process counter and checks it against the limit. If the limit would be exceeded, the system call fails with `EAGAIN`.\n\nProcess limit configuration is straightforward but requires careful consideration of the container's needs:\n\n1. Analyze the expected process tree structure (main process + children)\n2. Account for system processes like init handlers and signal processors  \n3. Add buffer for temporary processes created during normal operation\n4. Write the limit to `pids.max` control file\n5. Monitor process creation failures through the events file\n\n### Architecture Decision Records\n\nThe cgroups component requires several critical architectural decisions that significantly impact both implementation complexity and runtime behavior.\n\n> **Decision: Cgroups Version Support Strategy**\n> - **Context**: Linux systems may have cgroups v1, v2, or both available. The two versions have different filesystem layouts, control interfaces, and feature sets. We need to support both to ensure compatibility across different Linux distributions and kernel versions.\n> - **Options Considered**: 1) Support only cgroups v2 and require modern systems, 2) Support only cgroups v1 for maximum compatibility, 3) Support both versions with runtime detection\n> - **Decision**: Support both cgroups v1 and v2 with runtime detection and abstraction\n> - **Rationale**: Many production systems still use cgroups v1 (RHEL 7, older Ubuntu versions), while newer systems are migrating to v2. Runtime detection allows our container to work across the widest range of systems without requiring users to modify their kernel configuration.\n> - **Consequences**: Increases implementation complexity with dual code paths, but provides maximum compatibility and future-proofs against the v1 to v2 transition.\n\n| Option | Pros | Cons |\n|--------|------|------|\n| cgroups v2 only | Simpler code, modern interface, unified hierarchy | Incompatible with older systems, limited adoption |\n| cgroups v1 only | Maximum compatibility, well-tested interface | Missing modern features, deprecated technology |\n| Both versions | Works everywhere, smooth migration path | Complex implementation, dual maintenance burden |\n\n> **Decision: Controller Selection and Prioritization**  \n> - **Context**: Linux cgroups provide many controllers (memory, cpu, cpuset, devices, freezer, net_cls, etc.). Each adds complexity but provides specific resource control capabilities. We need to choose which controllers are essential for basic container functionality.\n> - **Options Considered**: 1) Implement all available controllers for complete resource control, 2) Implement only memory and CPU for basic limits, 3) Implement memory, CPU, and PIDs as core set with extensible architecture\n> - **Decision**: Implement memory, CPU, and PIDs controllers as the core set with extensible architecture\n> - **Rationale**: Memory and CPU are the most commonly needed limits for container resource management. PIDs controller prevents fork bombs which are a common security concern. This core set covers 90% of use cases while keeping complexity manageable. The extensible architecture allows adding more controllers later.\n> - **Consequences**: Provides essential resource control without overwhelming complexity. Some advanced use cases (device access control, network traffic shaping) require additional controller implementation.\n\n| Controller | Essential? | Use Case | Implementation Priority |\n|------------|------------|----------|-------------------------|\n| memory | Yes | Prevent OOM on host, enforce resource allocation | 1 |\n| cpu | Yes | Fair CPU sharing, prevent CPU monopolization | 2 |\n| pids | Yes | Prevent fork bombs, limit process explosion | 3 |\n| devices | No | Control device node access | Future |\n| freezer | No | Pause/resume containers | Future |\n| net_cls | No | Network traffic classification | Future |\n\n> **Decision: Cgroup Cleanup Strategy**\n> - **Context**: Cgroups must be cleaned up when containers exit to prevent resource leaks in the kernel. However, cleanup can fail if processes are still running in the cgroup, or if the cgroup hierarchy has dependencies. We need a robust cleanup strategy that handles various failure modes.\n> - **Options Considered**: 1) Simple removal on container exit, 2) Retry-based cleanup with exponential backoff, 3) Hierarchical cleanup with process termination\n> - **Decision**: Hierarchical cleanup with process termination and retry logic\n> - **Rationale**: Simple removal fails when zombie processes remain in the cgroup. Hierarchical cleanup ensures we terminate any remaining processes before removing cgroups, preventing resource leaks. Retry logic handles race conditions between process termination and cgroup removal.\n> - **Consequences**: More complex cleanup logic but prevents kernel resource leaks and handles edge cases robustly. May delay container exit in pathological cases where processes resist termination.\n\n| Cleanup Strategy | Pros | Cons |\n|------------------|------|------|\n| Simple removal | Fast, minimal code | Fails with zombie processes, leaks resources |\n| Retry-based | Handles race conditions | May retry indefinitely, unclear failure modes |\n| Hierarchical + retry | Robust, prevents leaks | Complex implementation, potential delays |\n\n### Common Pitfalls\n\nThe cgroups resource management system has several subtle pitfalls that can lead to resource leaks, enforcement failures, or system instability. Understanding these pitfalls is crucial for implementing reliable container resource controls.\n\n⚠️ **Pitfall: Controller Availability Assumptions**\n\nA common mistake is assuming that all desired cgroup controllers are available and enabled on the target system. Different Linux distributions enable different controller sets by default, and administrators may disable controllers for performance or security reasons.\n\nThe symptom appears when your container creation succeeds but resource limits are silently ignored. For example, you set a memory limit of 512MB, but the container can actually allocate 2GB without restriction. This occurs because the memory controller wasn't available, so the limit configuration failed silently.\n\n**Why it's wrong**: Failing to verify controller availability means resource limits may not be enforced, creating a security vulnerability where containers can consume unlimited system resources.\n\n**How to fix it**: Always call `verify_controller_available()` for each required controller before attempting to configure limits. If essential controllers are missing, fail container creation with a clear error message rather than proceeding with unprotected resource usage.\n\n⚠️ **Pitfall: Incorrect Cleanup Order**\n\nAnother frequent mistake is attempting to remove cgroups before all processes in the cgroup have fully exited. The Linux kernel refuses to remove cgroups that contain active processes, but the error handling for this scenario is often inadequate.\n\nThe symptom is that container cleanup appears to succeed, but `/sys/fs/cgroup` accumulates orphaned cgroup directories over time. Eventually, this can exhaust the kernel's cgroup limits and prevent new container creation.\n\n**Why it's wrong**: Orphaned cgroups consume kernel memory and count against system cgroup limits. Over time, these leaks can prevent new container creation and require system reboot to resolve.\n\n**How to fix it**: Implement hierarchical cleanup that first terminates all processes in the cgroup (using `SIGTERM` followed by `SIGKILL` if necessary), waits for process exit confirmation, then removes the cgroup directory. Use retry logic with exponential backoff to handle race conditions between process termination and cgroup removal.\n\n⚠️ **Pitfall: Memory Limit and OOM Behavior Mismatch**\n\nA subtle issue occurs when setting memory limits without properly configuring OOM (Out of Memory) behavior. By default, the kernel's OOM killer selects victims based on heuristics that may kill processes outside the cgroup rather than within it.\n\nThe symptom is that when a container exceeds its memory limit, random processes on the host system get terminated instead of processes within the offending container. This can cause system instability and difficult-to-debug application failures.\n\n**Why it's wrong**: The purpose of memory limits is to contain the impact of memory pressure within the container. If OOM kills affect the host or other containers, the isolation is broken.\n\n**How to fix it**: Configure `memory.oom.group` (cgroups v2) or `memory.use_hierarchy` (cgroups v1) to ensure OOM kills are contained within the cgroup. Set appropriate OOM score adjustments to prefer killing container processes over system processes.\n\n⚠️ **Pitfall: CPU Quota and Period Misconfiguration**\n\nCPU limits are commonly misconfigured by using inappropriate quota and period values. Setting periods that are too short causes excessive scheduling overhead, while periods that are too long cause poor responsiveness.\n\nThe symptom appears as either poor container performance (high scheduling overhead) or \"bursty\" CPU usage patterns where containers alternate between full CPU usage and complete suspension.\n\n**Why it's wrong**: Incorrect CPU quota/period configuration can actually make CPU performance worse than having no limits at all, due to scheduling overhead and poor cache locality.\n\n**How to fix it**: Use standard period values (100ms is typical) and calculate quotas as a percentage of that period. For multi-core limits, use quotas larger than the period (e.g., 150ms quota with 100ms period = 1.5 cores). Monitor `cpu.stat` to detect excessive throttling.\n\n⚠️ **Pitfall: Race Conditions in Process Assignment**\n\nA timing issue occurs when assigning processes to cgroups after those processes have already started and potentially created child processes. The child processes inherit the parent's cgroup membership at creation time, so they may end up in different cgroups than intended.\n\nThe symptom is that resource limits appear to be working for the main container process, but child processes created early in container startup consume resources outside the limits.\n\n**Why it's wrong**: Incomplete process assignment to cgroups allows resource usage to escape the intended limits, defeating the purpose of resource control.\n\n**How to fix it**: Create cgroups and assign the container process to them **before** calling `exec()` to start the container's main process. Use the `register_cleanup()` mechanism to ensure proper cgroup cleanup even if process assignment fails.\n\n### Implementation Guidance\n\nThe cgroups resource management component requires careful integration with the Linux cgroup filesystem and proper handling of both cgroups v1 and v2 variants. This implementation bridges the design concepts with practical code organization and error handling.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Cgroup Detection | File existence checks with `/sys/fs/cgroup/unified` | Parse `/proc/mounts` and `/proc/cgroups` for comprehensive controller detection |\n| Resource Limit Setting | Direct file writes to control files | Use libcgroup library for abstraction and validation |\n| Process Management | Simple PID file writes | Integrate with systemd-run for managed process trees |\n| Error Handling | Errno-based error checking | Structured error types with retry policies |\n\n#### Recommended File Structure\n\n```\ncontainer-basic/\n  src/\n    cgroups/\n      cgroups_common.c        ← shared utilities and detection\n      cgroups_v1.c           ← cgroups v1 specific implementation  \n      cgroups_v2.c           ← cgroups v2 specific implementation\n      cgroups.h              ← public interface header\n      cgroups_internal.h     ← internal structures and helpers\n    container.c              ← main container implementation\n    container.h              ← container public interface\n  tests/\n    test_cgroups.c          ← cgroup functionality tests\n    test_integration.c       ← end-to-end resource limit tests\n```\n\n#### Infrastructure Starter Code\n\nThis code provides complete, working utilities for cgroups management that handle the complexity of version detection and file system operations:\n\n```c\n// cgroups_common.c - Complete utility functions\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include \"cgroups_internal.h\"\n\n// Complete implementation of cgroup version detection\nint detect_cgroup_version(void) {\n    struct stat st;\n    \n    // Check for cgroups v2 unified hierarchy\n    if (stat(CGROUPS_V2_PATH, &st) == 0 && S_ISDIR(st.st_mode)) {\n        // Verify it's actually mounted as cgroup2\n        FILE* mounts = fopen(\"/proc/mounts\", \"r\");\n        if (!mounts) return -1;\n        \n        char line[256];\n        while (fgets(line, sizeof(line), mounts)) {\n            if (strstr(line, \"cgroup2\") && strstr(line, \"/sys/fs/cgroup\")) {\n                fclose(mounts);\n                return 2;  // cgroups v2\n            }\n        }\n        fclose(mounts);\n    }\n    \n    // Check for cgroups v1\n    if (stat(CGROUPS_V1_PATH, &st) == 0 && S_ISDIR(st.st_mode)) {\n        return 1;  // cgroups v1\n    }\n    \n    return -1;  // No cgroups found\n}\n\n// Complete implementation of cgroup path construction\nchar* get_cgroup_path(const char* container_id, const char* controller) {\n    static int cgroup_version = 0;\n    if (cgroup_version == 0) {\n        cgroup_version = detect_cgroup_version();\n    }\n    \n    char* path = malloc(256);\n    if (!path) return NULL;\n    \n    if (cgroup_version == 2) {\n        snprintf(path, 256, \"%s/%s-%s\", CGROUPS_V2_PATH, \n                 CONTAINER_CGROUP_PREFIX, container_id);\n    } else if (cgroup_version == 1) {\n        snprintf(path, 256, \"%s/%s/%s-%s\", CGROUPS_V1_PATH, \n                 controller, CONTAINER_CGROUP_PREFIX, container_id);\n    } else {\n        free(path);\n        return NULL;\n    }\n    \n    return path;\n}\n\n// Complete implementation of controller availability checking\nint verify_controller_available(const char* controller) {\n    int version = detect_cgroup_version();\n    \n    if (version == 2) {\n        // For v2, check controllers file\n        FILE* controllers = fopen(\"/sys/fs/cgroup/cgroup.controllers\", \"r\");\n        if (!controllers) return 0;\n        \n        char line[256];\n        if (fgets(line, sizeof(line), controllers)) {\n            int available = strstr(line, controller) != NULL;\n            fclose(controllers);\n            return available;\n        }\n        fclose(controllers);\n        return 0;\n    } else if (version == 1) {\n        // For v1, check if controller directory exists\n        char path[256];\n        snprintf(path, sizeof(path), \"%s/%s\", CGROUPS_V1_PATH, controller);\n        struct stat st;\n        return stat(path, &st) == 0 && S_ISDIR(st.st_mode);\n    }\n    \n    return 0;\n}\n\n// Complete implementation of safe file writing for cgroup control files\nint write_cgroup_file(const char* path, const char* value) {\n    FILE* file = fopen(path, \"w\");\n    if (!file) {\n        return -1;\n    }\n    \n    int result = fprintf(file, \"%s\", value);\n    if (result < 0) {\n        fclose(file);\n        return -1;\n    }\n    \n    if (fclose(file) != 0) {\n        return -1;\n    }\n    \n    return 0;\n}\n```\n\n#### Core Logic Skeleton Code\n\nThe main cgroups interface functions that learners should implement, with detailed TODO comments mapping to the algorithm steps:\n\n```c\n// cgroups.c - Core implementation to be completed by learner\n#include \"cgroups.h\"\n#include \"cgroups_internal.h\"\n\n// Create cgroup hierarchy and configure resource limits for container\nint create_container_cgroup(container_config_t* config, container_instance_t* container) {\n    // TODO 1: Detect cgroup version using detect_cgroup_version()\n    // TODO 2: Generate unique container ID if not provided in config\n    // TODO 3: Verify required controllers are available (memory, cpu, pids)\n    //         Use verify_controller_available() for each controller\n    // TODO 4: Create cgroup directory hierarchy using mkdir() with appropriate permissions\n    // TODO 5: Store cgroup path in container->cgroup_path for cleanup tracking\n    // TODO 6: Register cleanup function using register_cleanup() for failure recovery\n    // TODO 7: Configure memory limits by calling set_memory_limit()\n    // TODO 8: Configure CPU limits by calling set_cpu_limit()  \n    // TODO 9: Configure process limits by calling set_process_limit()\n    // TODO 10: Return 0 on success, -1 on failure with errno set\n    \n    return -1; // Replace with implementation\n}\n\n// Assign process to cgroup for resource limit enforcement\nint assign_process_to_cgroup(const char* cgroup_path, pid_t pid) {\n    // TODO 1: Determine cgroup version to know which tasks file to use\n    // TODO 2: Construct path to tasks file (cgroup.procs for v2, tasks for v1)\n    // TODO 3: Convert PID to string for writing to control file\n    // TODO 4: Write PID to appropriate tasks/procs file using write_cgroup_file()\n    // TODO 5: Verify write succeeded by reading back the tasks file\n    // TODO 6: Return 0 on success, -1 on failure\n    // Hint: v2 uses \"cgroup.procs\", v1 uses \"tasks\" \n    \n    return -1; // Replace with implementation\n}\n\n// Configure memory limit and OOM behavior for cgroup\nint set_memory_limit(const char* cgroup_path, size_t limit_bytes) {\n    // TODO 1: Detect cgroup version to determine control file names\n    // TODO 2: Convert limit_bytes to string representation\n    // TODO 3: Write limit to memory.max (v2) or memory.limit_in_bytes (v1)\n    // TODO 4: Configure OOM behavior - set memory.oom.group (v2) or memory.use_hierarchy (v1)\n    // TODO 5: Optionally set memory.swappiness to control swap usage\n    // TODO 6: Verify limits were applied by reading back control files\n    // TODO 7: Return 0 on success, -1 on failure\n    // Hint: Use write_cgroup_file() helper for atomic file writes\n    \n    return -1; // Replace with implementation\n}\n\n// Configure CPU quota and period to limit CPU usage percentage  \nint set_cpu_limit(const char* cgroup_path, int cpu_percent) {\n    // TODO 1: Validate cpu_percent is reasonable (1-800 for multi-core)\n    // TODO 2: Calculate quota and period values (typically 100ms period)\n    //         quota = (cpu_percent / 100.0) * period\n    // TODO 3: Detect cgroup version for control file format\n    // TODO 4: For v2: write \"quota period\" to cpu.max\n    //         For v1: write quota to cpu.cfs_quota_us, period to cpu.cfs_period_us\n    // TODO 5: Verify CPU limits by reading back control files\n    // TODO 6: Return 0 on success, -1 on failure\n    // Hint: Standard period is 100000 microseconds (100ms)\n    \n    return -1; // Replace with implementation\n}\n\n// Configure maximum number of processes in cgroup\nint set_process_limit(const char* cgroup_path, int max_processes) {\n    // TODO 1: Validate max_processes is positive and reasonable\n    // TODO 2: Convert max_processes to string\n    // TODO 3: Write to pids.max control file (same name in v1 and v2)\n    // TODO 4: Verify limit was set by reading back pids.max\n    // TODO 5: Return 0 on success, -1 on failure\n    // Hint: PIDs controller has same interface in v1 and v2\n    \n    return -1; // Replace with implementation\n}\n\n// Clean up cgroup hierarchy and kernel resources\nint cleanup_container_cgroup(const char* cgroup_path) {\n    // TODO 1: Terminate any remaining processes in cgroup\n    //         Read pids from cgroup.procs/tasks file\n    // TODO 2: Send SIGTERM to all processes, wait briefly\n    // TODO 3: Send SIGKILL to any remaining processes  \n    // TODO 4: Wait for all processes to exit (poll cgroup.procs)\n    // TODO 5: Remove cgroup directory using rmdir()\n    // TODO 6: Handle EBUSY errors with retry logic (up to 3 attempts)\n    // TODO 7: Return 0 on success, -1 if cleanup failed\n    // Hint: Use kill(-pid, signal) to signal process groups\n    \n    return -1; // Replace with implementation\n}\n```\n\n#### Language-Specific Hints\n\n**File I/O for Cgroup Control Files:**\n- Use `fopen()` with \"w\" mode for writing control files\n- Always check `fclose()` return value - it can fail and lose data\n- Some control files require newlines, others don't - check kernel documentation\n\n**Process Management:**\n- Use `kill()` with negative PID to signal entire process groups\n- `SIGTERM` allows graceful shutdown, `SIGKILL` forces immediate termination\n- Check `/proc/[pid]/status` to verify process termination\n\n**Error Handling Patterns:**\n- Cgroup operations can fail with `ENOENT` (path doesn't exist), `EPERM` (insufficient privileges), or `EINVAL` (invalid values)\n- Always check `errno` after failed operations for specific error diagnosis\n- Use `perror()` or `strerror(errno)` for human-readable error messages\n\n**Memory Management:**\n- Use `malloc()` for dynamic path construction, always check for NULL return\n- Free allocated paths with `free()` to prevent memory leaks\n- Consider using `alloca()` for small, temporary string buffers\n\n#### Milestone Checkpoint\n\nAfter implementing the cgroups component, verify correct behavior with these concrete tests:\n\n**Test 1: Memory Limit Enforcement**\n```bash\n# Create container with 10MB memory limit\n./container --memory-limit=10485760 stress --vm 1 --vm-bytes 20M\n\n# Expected: Container should be OOM killed when trying to allocate 20MB\n# Check: dmesg should show \"Memory cgroup out of memory\" message\n# Verify: echo $? should return non-zero exit code\n```\n\n**Test 2: CPU Limit Verification**  \n```bash\n# Create container with 25% CPU limit\n./container --cpu-percent=25 dd if=/dev/zero of=/dev/null\n\n# Expected: Container should use ~25% CPU even under full load\n# Check: Use 'top' or 'htop' to verify CPU usage stays around 25%\n# Verify: CPU throttling stats in /sys/fs/cgroup/.../cpu.stat\n```\n\n**Test 3: Process Limit Testing**\n```bash\n# Create container with 5 process limit\n./container --max-processes=5 bash -c 'for i in {1..10}; do sleep 30 & done'\n\n# Expected: Only first 5 background processes should start\n# Check: ps aux should show exactly 5 sleep processes\n# Verify: Attempts to create 6th process should fail with EAGAIN\n```\n\n**Signs of Problems:**\n- **Memory limits ignored**: Container allocates more than limit without OOM → Check controller availability and cgroup v1/v2 detection\n- **CPU limits not enforced**: Container uses 100% CPU despite limit → Verify quota/period calculation and control file writes  \n- **Process limits bypassed**: More processes created than limit → Check PIDs controller mounting and process assignment\n- **Cleanup failures**: Orphaned cgroup directories in `/sys/fs/cgroup/` → Implement proper process termination before cgroup removal\n\n![Cgroups Resource Control Hierarchy](./diagrams/cgroups-hierarchy.svg)\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** This section spans all milestones (1-4), describing how the PID namespace, mount namespace, network namespace, and cgroups components coordinate during container lifecycle operations.\n\nThe container runtime operates as a carefully orchestrated system where multiple Linux kernel isolation mechanisms must be created, configured, and managed in a specific sequence. Think of launching a container like **setting up a new office branch**: you need to establish the building (mount namespace), assign phone numbers (PID namespace), connect telecommunications (network namespace), and allocate budgets (cgroups) - and all of these must happen in the right order, with each step depending on the previous ones completing successfully.\n\nThe coordination challenge stems from the interdependencies between namespace types and the fact that many operations must occur from specific contexts (host vs container namespace). Additionally, cleanup requires the reverse order to prevent resource leaks, similar to how you must evacuate employees before disconnecting utilities when closing an office branch.\n\n![Container Startup Sequence](./diagrams/container-startup-flow.svg)\n\n### Container Startup Sequence\n\nContainer creation follows a precise multi-stage sequence that coordinates namespace creation, process forking, resource limit application, and error recovery. Each stage has specific responsibilities and must complete before the next stage can begin.\n\nThe startup sequence operates through **three distinct execution contexts**: the parent process running in host namespaces, the child process transitioning between namespaces, and the final containerized process running in complete isolation. Understanding which operations occur in which context is crucial for proper implementation.\n\n**Stage 1: Preparation and Validation**\n\nThe startup sequence begins in the host context with configuration validation and resource preparation. This stage verifies that all required kernel features are available and that the container configuration is valid before creating any namespaces.\n\n| Operation | Purpose | Validation Checks |\n|-----------|---------|-------------------|\n| Validate rootfs path | Ensure container filesystem exists | Directory exists, readable, contains essential directories |\n| Check kernel features | Verify namespace support available | /proc/self/ns/ contains required namespace files |\n| Detect cgroup version | Determine cgroups v1 vs v2 | Check /sys/fs/cgroup mount type and available controllers |\n| Verify privileges | Ensure sufficient permissions | CAP_SYS_ADMIN capability or root privileges |\n| Allocate resources | Reserve network IP and cgroup paths | Generate unique container ID, check IP availability |\n\n> **Critical Insight**: All validation occurs before creating any namespaces because cleanup becomes significantly more complex once kernel resources are allocated. A validation failure at this stage requires no cleanup.\n\n**Stage 2: Namespace Creation and Process Forking**\n\nThe core isolation setup occurs through the `safe_clone()` system call with combined namespace flags. This single operation creates the child process and establishes all required namespaces simultaneously, avoiding the timing and synchronization issues that arise from sequential namespace creation.\n\nThe parent process executes the following sequence:\n\n1. **Allocate clone stack**: Reserve `STACK_SIZE` bytes for the child process stack, ensuring proper alignment for the target architecture\n2. **Prepare container instance**: Initialize `container_instance_t` structure with allocated cleanup list and namespace file descriptors array\n3. **Register cleanup functions**: Add cleanup handlers for stack deallocation, namespace closing, and cgroup removal to handle setup failures\n4. **Execute clone system call**: Call `safe_clone(container_init_process, stack, CONTAINER_NS_FLAGS, config)` to create isolated child process\n5. **Store child PID**: Record the child process ID in the container instance for monitoring and cleanup purposes\n6. **Open namespace file descriptors**: Access `/proc/<child_pid>/ns/*` files to maintain references to the created namespaces\n\nThe child process begins execution in the new namespaces with a completely different view of system resources. It sees itself as PID 1 in an empty process tree, has access only to the new mount namespace, and possesses an isolated network stack.\n\n| Namespace Type | Child Process View | Parent Process View |\n|----------------|-------------------|---------------------|\n| PID | Process sees itself as PID 1, no other processes visible | Child appears as normal PID in host process tree |\n| Mount | Inherits host mount tree initially, will be modified | Host mount tree unchanged |\n| Network | Empty network namespace with only loopback interface | Host network interfaces remain accessible |\n| UTS | Separate hostname that can be changed independently | Host hostname unchanged |\n| IPC | Empty IPC namespace with no shared memory segments | Host IPC resources remain accessible |\n\n> **Design Principle**: Using `clone()` with combined flags creates all namespaces atomically, eliminating race conditions that occur when creating namespaces sequentially with `unshare()`.\n\n**Stage 3: Cgroups Resource Limit Setup**\n\nResource limits must be established immediately after process creation but before the container process begins executing user code. This timing ensures that resource consumption is controlled from the very beginning of container execution.\n\nThe parent process handles cgroup setup because it retains the necessary privileges and host filesystem access:\n\n1. **Create cgroup hierarchy**: Call `create_container_cgroup(config, container)` to establish the cgroup directory structure in the appropriate controller hierarchies\n2. **Assign child process**: Execute `assign_process_to_cgroup(container->cgroup_path, container->child_pid)` to place the container process under resource control\n3. **Configure memory limits**: Apply memory restrictions using `set_memory_limit(container->cgroup_path, config->memory_limit_bytes)` before significant memory allocation occurs\n4. **Configure CPU limits**: Establish CPU usage restrictions through `set_cpu_limit(container->cgroup_path, config->cpu_percent)` to prevent CPU monopolization\n5. **Configure process limits**: Set maximum process count via `set_process_limit(container->cgroup_path, config->max_processes)` to prevent fork bomb attacks\n6. **Verify limit enforcement**: Read back cgroup settings using `read_cgroup_stat()` to confirm that limits were applied correctly\n\nThe cgroup assignment affects the child process immediately, even though the child is simultaneously setting up its namespace environment. This parallel execution is safe because cgroups operate at the kernel level and do not interfere with namespace operations.\n\n**Stage 4: Container Environment Initialization**\n\nThe child process, now running as PID 1 in isolated namespaces with resource limits applied, must establish the container's execution environment. This stage transforms the raw namespace environment into a functional container.\n\nThe `container_init_process()` function executes the following initialization sequence:\n\n1. **Configure signal handling**: Call `setup_init_signals()` to establish proper signal handlers for zombie process reaping, since the container process inherits PID 1 responsibilities\n2. **Create mount namespace isolation**: Execute `create_mount_namespace(config, container)` to establish private mount propagation and prepare for filesystem modifications\n3. **Setup container root filesystem**: Run `setup_container_rootfs(config->rootfs_path, \"/mnt/old_root\")` to prepare the new root directory structure\n4. **Perform pivot root operation**: Execute `pivot_to_container_root(config->rootfs_path, \"/mnt/old_root\")` to switch the filesystem root to the container filesystem\n5. **Mount essential filesystems**: Call `mount_essential_filesystems()` to provide `/proc`, `/sys`, and `/dev` filesystems required by containerized applications\n6. **Configure network interface**: Execute network configuration commands to set up the container end of the veth pair with the assigned IP address\n7. **Set hostname**: Update the container hostname using `sethostname()` to provide identity isolation\n8. **Drop privileges**: If configured, drop unnecessary capabilities and change to a non-root user for security\n\n> **Synchronization Point**: The parent process waits for the child to complete mount namespace setup before proceeding with network configuration, since network setup requires knowledge of the child's network namespace.\n\n**Stage 5: Network Connectivity Establishment**\n\nNetwork connectivity setup requires coordination between parent and child processes because veth pair creation occurs in the host namespace while interface configuration occurs in the container namespace.\n\nThe parent process handles the host-side networking:\n\n1. **Create veth pair**: Call `create_veth_pair(host_if_name, container_if_name)` to create the virtual ethernet link with unique interface names\n2. **Assign container interface**: Execute `assign_veth_to_namespace(container_if_name, container->child_pid)` to move the container end into the child's network namespace\n3. **Attach to host bridge**: Run `attach_to_bridge(host_if_name, config->bridge_name)` to connect the host end to the bridge for inter-container communication\n4. **Configure host interface**: Bring up the host end of the veth pair and configure any required routing rules for container connectivity\n\nThe child process, running in its network namespace, configures the container-side networking:\n\n1. **Configure container interface**: Execute `configure_container_interface(container_if_name, config->container_ip, netmask)` to assign the IP address and activate the interface\n2. **Setup default route**: Call `setup_default_route(gateway_ip)` to establish connectivity to external networks through the host bridge\n3. **Verify connectivity**: Test basic network functionality by attempting to reach the gateway and DNS resolution\n\n**Stage 6: Application Execution**\n\nOnce all namespace and resource setup completes, the container process transitions to executing the user-specified application. This transition represents the completion of container initialization and the beginning of application runtime.\n\nThe final steps in `container_init_process()` prepare for application execution:\n\n1. **Validate executable**: Verify that `config->argv[0]` exists and is executable within the container filesystem\n2. **Prepare environment**: Set up environment variables from `config->envp` and add container-specific variables\n3. **Change working directory**: Set the working directory to an appropriate location within the container filesystem\n4. **Execute application**: Call `execve(config->argv[0], config->argv, config->envp)` to replace the init process with the container application\n\n> **Process Identity Change**: The `execve()` call replaces the container init process with the application, but the process retains PID 1 and all namespace memberships and resource limits.\n\n![Container Lifecycle State Machine](./diagrams/container-lifecycle-states.svg)\n\n### Container Cleanup Sequence\n\nContainer cleanup must occur in the reverse order of creation to prevent resource leaks and ensure proper kernel resource deallocation. The cleanup sequence handles both normal termination and error recovery scenarios.\n\nThe cleanup challenge stems from the fact that **namespaces and cgroups form dependency relationships**: processes must exit before their cgroups can be removed, namespace file descriptors must be closed before namespace resources are freed, and mount points must be unmounted before mount namespaces can be destroyed.\n\n**Cleanup Trigger Detection**\n\nContainer cleanup begins when the parent process detects that the child process has exited. The `container_wait(container)` function monitors the child process and initiates cleanup when termination occurs.\n\n| Termination Cause | Detection Method | Cleanup Requirements |\n|-------------------|------------------|---------------------|\n| Normal application exit | waitpid() returns with WIFEXITED | Standard cleanup sequence |\n| Application killed by signal | waitpid() returns with WIFSIGNALED | Standard cleanup sequence |\n| OOM killer termination | waitpid() returns, check cgroup memory events | Memory limit exceeded, standard cleanup |\n| Container timeout | waitpid() with timeout expires | Send SIGTERM, wait, send SIGKILL, then cleanup |\n| Setup error | clone() fails or child setup fails | Partial cleanup based on cleanup list |\n\n**Stage 1: Process Termination and Signal Handling**\n\nThe cleanup sequence begins with ensuring that all processes within the container have terminated. This step is crucial because active processes prevent namespace destruction and can cause resource leaks.\n\n1. **Detect child exit**: The `container_wait()` function uses `waitpid(container->child_pid, &status, 0)` to detect when the main container process exits\n2. **Collect exit status**: Extract the exit code or termination signal from the wait status for reporting to the container user\n3. **Handle zombie reaping**: If the container process spawned additional children, ensure all zombies are collected to prevent process table pollution\n4. **Force termination if needed**: For timeout scenarios, send `SIGTERM` followed by `SIGKILL` to ensure process termination\n\n> **Zombie Prevention**: Since the container process runs as PID 1, it must reap its own children. If the application fails to do this, zombie processes remain until namespace destruction.\n\n**Stage 2: Network Namespace Cleanup**\n\nNetwork resources require early cleanup because they involve kernel objects that reference the network namespace. Delaying network cleanup can cause memory leaks in the kernel networking subsystem.\n\nThe `cleanup_network_namespace(container)` function performs network teardown:\n\n1. **Remove veth interfaces**: The kernel automatically destroys both ends of the veth pair when the container network namespace is destroyed, but explicit cleanup ensures immediate resource recovery\n2. **Close namespace file descriptors**: Close the network namespace file descriptor stored in `container->namespace_fds[CLONE_NEWNET]` to release the namespace reference\n3. **Update bridge state**: Remove any bridge forwarding entries that referenced the container's MAC address to prevent stale entries\n4. **Release IP address**: Return the allocated IP address to the available pool for reuse by future containers\n\n**Stage 3: Mount Namespace Cleanup**\n\nMount namespace cleanup involves unmounting filesystems and releasing filesystem references. This stage must handle both successful containers (where pivot_root occurred) and failed containers (where mount setup was incomplete).\n\nThe mount cleanup process follows this sequence:\n\n1. **Detect mount state**: Check whether pivot_root completed successfully by examining the container's current root directory\n2. **Unmount essential filesystems**: Remove `/proc`, `/sys`, and `/dev` mounts that were created within the container namespace\n3. **Handle old root cleanup**: If pivot_root succeeded, unmount the old root directory that was bind-mounted during the pivot operation\n4. **Unmount bind mounts**: Remove any host directory bind mounts that were established for the container\n5. **Close mount namespace**: Close the mount namespace file descriptor to release the namespace reference\n\n> **Mount Cleanup Challenge**: Mount points must be unmounted in reverse dependency order. Child mounts must be unmounted before parent mounts, similar to how directory trees must be deleted from leaves to root.\n\n**Stage 4: PID Namespace Cleanup**\n\nPID namespace cleanup is largely automatic once all processes within the namespace have exited. However, explicit cleanup steps ensure proper resource recovery and handle edge cases.\n\n1. **Verify process termination**: Confirm that all processes within the PID namespace have exited by checking that no `/proc/<pid>/ns/pid` files reference the container's PID namespace\n2. **Close PID namespace file descriptor**: Release the PID namespace reference held by the parent process\n3. **Clean up process tracking**: Remove any process monitoring or logging that was specific to the container's PID namespace\n\n**Stage 5: Cgroup Hierarchy Removal**\n\nCgroup cleanup must occur after all processes have exited because cgroups cannot be removed while they contain active processes. The `cleanup_container_cgroup(cgroup_path)` function handles hierarchical cleanup.\n\nThe cgroup removal process follows strict ordering requirements:\n\n1. **Verify process exit**: Confirm that the cgroup's `tasks` file is empty, indicating all processes have exited\n2. **Read final statistics**: Collect final resource usage statistics before removing the cgroup for reporting or debugging\n3. **Remove child cgroups**: If any sub-cgroups were created, remove them in reverse creation order\n4. **Remove parent cgroup**: Delete the main container cgroup directory, which automatically releases all associated kernel resources\n5. **Verify controller cleanup**: Ensure that all cgroup controllers have properly released their resources\n\n> **Hierarchical Dependency**: Cgroups form a hierarchy where child cgroups must be removed before their parents. The kernel enforces this ordering and will reject attempts to remove parent cgroups while children exist.\n\n**Stage 6: Resource Cleanup and Finalization**\n\nThe final cleanup stage releases user-space resources and updates any external state that tracked the container's existence.\n\n1. **Execute registered cleanup functions**: Process the `cleanup_list_t` chain to execute all registered cleanup functions in reverse order\n2. **Release memory allocations**: Free the container instance structure, configuration copies, and any allocated string buffers\n3. **Close remaining file descriptors**: Ensure all namespace file descriptors and other file handles are closed\n4. **Update container registry**: Remove the container from any runtime tracking structures or persistent state\n5. **Log cleanup completion**: Record successful cleanup for debugging and auditing purposes\n\n### Error Propagation\n\nError handling in container creation requires careful coordination because failures can occur in any component while other components are simultaneously executing setup operations. The error propagation system must ensure that partial setup is properly cleaned up regardless of where failure occurs.\n\n**Error Categories and Impact Scope**\n\nContainer creation errors fall into distinct categories based on their scope and recovery requirements. Understanding these categories guides the error propagation strategy.\n\n| Error Category | Examples | Impact Scope | Recovery Strategy |\n|----------------|----------|--------------|------------------|\n| Validation Errors | Invalid rootfs path, missing capabilities | Pre-setup | Simple return, no cleanup needed |\n| Resource Allocation | Out of memory, PID exhaustion | Single component | Component-specific cleanup |\n| Kernel Feature Errors | Namespace not supported, cgroup unavailable | System-wide | Graceful degradation or abort |\n| Race Conditions | Network interface conflicts, cgroup timing | Cross-component | Retry with backoff |\n| Permission Errors | Insufficient privileges, filesystem access | Context-dependent | Privilege escalation or abort |\n\n> **Error Propagation Principle**: Errors must be propagated to the point where complete cleanup can be performed. This often means that child process errors must be communicated to the parent process that holds cleanup responsibilities.\n\n**Cleanup List Mechanism**\n\nThe `cleanup_list_t` structure provides a systematic approach to error recovery by maintaining a stack of cleanup operations that corresponds to successful setup operations. Each setup operation registers its corresponding cleanup function before proceeding.\n\n```\nCleanup Registration Pattern:\n1. Attempt setup operation\n2. If successful, register corresponding cleanup function\n3. If failure, execute all registered cleanup functions\n4. Propagate error to caller\n```\n\nThe cleanup list operates as a **stack (LIFO) structure** to ensure that cleanup occurs in reverse setup order:\n\n| Setup Operation | Cleanup Registration | Cleanup Function |\n|-----------------|---------------------|------------------|\n| clone() process creation | `register_cleanup(list, kill_child_process, &child_pid)` | Send SIGKILL and waitpid() |\n| Create cgroup directory | `register_cleanup(list, remove_cgroup, cgroup_path)` | rmdir() cgroup directory |\n| Create veth pair | `register_cleanup(list, destroy_veth_pair, if_name)` | Delete network interfaces |\n| Open namespace FDs | `register_cleanup(list, close_namespace_fds, fd_array)` | Close all file descriptors |\n| Mount filesystems | `register_cleanup(list, unmount_filesystems, mount_list)` | Unmount in reverse order |\n\n**Parent-Child Error Communication**\n\nError propagation between parent and child processes requires special handling because the processes operate in different contexts and may not share memory after namespace creation.\n\nThe communication mechanism uses **process exit codes** and **signal patterns** to convey error information:\n\n1. **Success Path**: Child process calls `execve()` to run the container application, never returns to init code\n2. **Setup Error Path**: Child process exits with specific error codes that indicate the failure point\n3. **Runtime Error Path**: Child process is killed by signal, indicating runtime failure (OOM, segmentation fault, etc.)\n\n| Child Exit Status | Error Interpretation | Parent Action |\n|-------------------|---------------------|---------------|\n| execve() success (no exit) | Container running normally | Monitor process, wait for termination |\n| Exit code 1-99 | Setup error in specific component | Execute cleanup, report setup failure |\n| Exit code 100-199 | Resource limit exceeded | Execute cleanup, report resource exhaustion |\n| SIGKILL with OOM flag | Memory limit enforcement | Execute cleanup, report OOM condition |\n| SIGSEGV or SIGABRT | Application crash | Execute cleanup, report application error |\n\n> **Communication Limitation**: Once the child process has entered its namespaces, it cannot directly communicate complex error information to the parent. Exit codes provide the only reliable error propagation mechanism.\n\n**Cross-Component Error Handling**\n\nWhen multiple components are setting up simultaneously (such as cgroups in parent and mount namespace in child), error propagation must coordinate across component boundaries.\n\n**Network Setup Error Example**: If veth pair creation fails in the parent process while the child process is simultaneously setting up mount namespaces:\n\n1. **Parent detects veth creation failure**: The `create_veth_pair()` function returns an error code\n2. **Parent signals child termination**: Send `SIGTERM` to child process to abort its setup\n3. **Child detects termination signal**: Mount setup code checks for pending signals and aborts gracefully\n4. **Parent waits for child exit**: Use `waitpid()` to confirm child has terminated\n5. **Parent executes cleanup**: Run all registered cleanup functions to release allocated resources\n6. **Parent propagates error**: Return error code to `container_create()` caller with specific failure reason\n\n**Mount Setup Error Example**: If pivot_root fails in the child process while the parent has already created cgroups and network interfaces:\n\n1. **Child detects pivot_root failure**: The filesystem operation returns an error\n2. **Child exits with specific code**: Exit with code indicating mount setup failure\n3. **Parent detects child exit**: `waitpid()` returns with child exit status\n4. **Parent interprets error**: Exit code indicates which component failed\n5. **Parent executes full cleanup**: Clean up cgroups, network interfaces, and other resources\n6. **Parent reports specific error**: Return detailed error information about mount failure\n\n**Error Recovery Strategies**\n\nDifferent error scenarios require different recovery approaches based on whether the error is transient, permanent, or indicates system-level issues.\n\n> **Decision: Fail-Fast vs. Graceful Degradation**\n> - **Context**: Some container features (like specific cgroup controllers) may be unavailable but container creation could proceed with reduced functionality\n> - **Options Considered**: Always fail fast, always gracefully degrade, configurable behavior\n> - **Decision**: Fail fast for essential features (PID, mount namespaces), graceful degradation for optional features (specific cgroup controllers)\n> - **Rationale**: Essential features are required for basic isolation security. Optional features can be disabled while maintaining core container functionality.\n> - **Consequences**: Clear security guarantees but reduced flexibility in heterogeneous environments\n\n| Recovery Strategy | When to Apply | Implementation Approach |\n|-------------------|---------------|-------------------------|\n| Immediate Retry | Transient resource conflicts | Retry with exponential backoff up to 3 attempts |\n| Graceful Degradation | Optional feature unavailability | Continue with feature disabled, log warning |\n| Fail Fast | Essential feature missing | Immediate cleanup and error propagation |\n| Resource Cleanup and Retry | Resource exhaustion | Clean up failed attempt, wait, retry once |\n| System Error Reporting | Kernel or hardware issues | Clean up, report system-level error, do not retry |\n\n### Implementation Guidance\n\nThe container lifecycle coordination requires careful orchestration of system calls, process synchronization, and resource management across multiple kernel subsystems.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Process Creation | fork() + namespace setup | clone() with combined flags |\n| Error Communication | Exit codes only | Shared memory + exit codes |\n| Cleanup Coordination | Function pointer list | State machine with rollback |\n| Synchronization | waitpid() polling | eventfd + signaling |\n| Resource Tracking | Manual cleanup functions | RAII-style resource guards |\n\n**B. Recommended File Structure**\n\n```c\ncontainer-basic/\n  src/\n    container.c              ← main container lifecycle coordination\n    container.h              ← public container API and structures\n    container_internal.h     ← internal coordination structures\n    namespace_manager.c      ← namespace creation coordination\n    cleanup.c               ← cleanup list and error recovery\n    sync.c                  ← parent-child synchronization\n  tests/\n    test_lifecycle.c        ← container creation and cleanup tests\n    test_error_handling.c   ← error propagation and recovery tests\n    test_coordination.c     ← component interaction tests\n```\n\n**C. Infrastructure Starter Code**\n\nComplete cleanup list management for systematic error recovery:\n\n```c\n// cleanup.h\ntypedef struct cleanup_list {\n    void (*cleanup_func)(void *data);\n    void *data;\n    struct cleanup_list *next;\n} cleanup_list_t;\n\n// cleanup.c\n#include <stdlib.h>\n#include <stdio.h>\n#include \"cleanup.h\"\n\nvoid register_cleanup(cleanup_list_t **list, void (*func)(void*), void *data) {\n    cleanup_list_t *entry = malloc(sizeof(cleanup_list_t));\n    if (!entry) {\n        fprintf(stderr, \"Failed to allocate cleanup entry\\n\");\n        return;\n    }\n    entry->cleanup_func = func;\n    entry->data = data;\n    entry->next = *list;\n    *list = entry;\n}\n\nvoid execute_cleanup(cleanup_list_t **list) {\n    cleanup_list_t *current = *list;\n    while (current) {\n        if (current->cleanup_func) {\n            current->cleanup_func(current->data);\n        }\n        cleanup_list_t *next = current->next;\n        free(current);\n        current = next;\n    }\n    *list = NULL;\n}\n\n// Common cleanup functions\nvoid cleanup_close_fd(void *data) {\n    int fd = *(int*)data;\n    if (fd >= 0) {\n        close(fd);\n    }\n}\n\nvoid cleanup_kill_process(void *data) {\n    pid_t pid = *(pid_t*)data;\n    if (pid > 0) {\n        kill(pid, SIGTERM);\n        usleep(100000); // 100ms grace period\n        kill(pid, SIGKILL);\n        waitpid(pid, NULL, 0);\n    }\n}\n\nvoid cleanup_remove_cgroup(void *data) {\n    char *path = (char*)data;\n    if (path && strlen(path) > 0) {\n        rmdir(path);\n    }\n}\n```\n\nParent-child synchronization utilities:\n\n```c\n// sync.h\ntypedef struct container_sync {\n    int parent_pipe[2];  // Parent writes, child reads\n    int child_pipe[2];   // Child writes, parent reads\n} container_sync_t;\n\n// sync.c\n#include <unistd.h>\n#include <sys/wait.h>\n#include \"sync.h\"\n\nint create_sync_pipes(container_sync_t *sync) {\n    if (pipe(sync->parent_pipe) == -1) {\n        return -1;\n    }\n    if (pipe(sync->child_pipe) == -1) {\n        close(sync->parent_pipe[0]);\n        close(sync->parent_pipe[1]);\n        return -1;\n    }\n    return 0;\n}\n\nint wait_for_child_ready(container_sync_t *sync) {\n    close(sync->child_pipe[1]); // Close write end\n    char ready_signal;\n    ssize_t result = read(sync->child_pipe[0], &ready_signal, 1);\n    close(sync->child_pipe[0]);\n    return (result == 1 && ready_signal == '1') ? 0 : -1;\n}\n\nint signal_parent_ready(container_sync_t *sync) {\n    close(sync->child_pipe[0]); // Close read end\n    char ready_signal = '1';\n    ssize_t result = write(sync->child_pipe[1], &ready_signal, 1);\n    close(sync->child_pipe[1]);\n    return (result == 1) ? 0 : -1;\n}\n```\n\n**D. Core Logic Skeleton Code**\n\nMain container lifecycle coordination:\n\n```c\n// container.c\nint container_create(const container_config_t *config, container_instance_t *container) {\n    // TODO 1: Initialize container instance structure with cleanup list\n    // TODO 2: Validate configuration (rootfs exists, privileges sufficient)\n    // TODO 3: Allocate clone stack and register stack cleanup\n    // TODO 4: Create synchronization pipes for parent-child coordination\n    // TODO 5: Execute safe_clone() with CONTAINER_NS_FLAGS to create isolated child\n    // TODO 6: Store child PID and register process cleanup function\n    // TODO 7: Open namespace file descriptors from /proc/<child_pid>/ns/\n    // TODO 8: Create and configure cgroup hierarchy for resource limits\n    // TODO 9: Wait for child to complete mount namespace setup\n    // TODO 10: Set up host-side networking (veth pair, bridge attachment)\n    // TODO 11: Signal child to proceed with final application execution\n    // Hint: Use cleanup list to ensure proper resource release on any failure\n    return -1; // Replace with implementation\n}\n\nint container_init_process(void *arg) {\n    container_config_t *config = (container_config_t*)arg;\n    \n    // TODO 1: Set up signal handlers for PID 1 responsibilities (zombie reaping)\n    // TODO 2: Create mount namespace isolation with private propagation\n    // TODO 3: Set up container root filesystem directory structure\n    // TODO 4: Perform pivot_root operation to switch filesystem root\n    // TODO 5: Mount essential filesystems (/proc, /sys, /dev) in container\n    // TODO 6: Configure container network interface with assigned IP\n    // TODO 7: Set container hostname for identity isolation\n    // TODO 8: Signal parent that container setup is complete\n    // TODO 9: Change to application working directory\n    // TODO 10: Execute target application with execve()\n    // Hint: Exit with specific error codes to communicate failure type to parent\n    return -1; // Should never reach here if execve() succeeds\n}\n\nint container_wait(container_instance_t *container) {\n    int status;\n    pid_t result;\n    \n    // TODO 1: Wait for child process to exit using waitpid()\n    // TODO 2: Check if child was killed by signal (WIFSIGNALED)\n    // TODO 3: Extract exit code or signal number for error reporting\n    // TODO 4: Check cgroup memory events for OOM detection\n    // TODO 5: Return appropriate error code based on termination cause\n    // Hint: Different termination types require different cleanup approaches\n    return -1; // Replace with implementation\n}\n\nint container_destroy(container_instance_t *container) {\n    // TODO 1: Ensure child process has fully terminated\n    // TODO 2: Clean up network namespace and veth interfaces\n    // TODO 3: Clean up mount namespace and filesystem mounts\n    // TODO 4: Close all namespace file descriptors\n    // TODO 5: Remove cgroup hierarchy and release resource controls\n    // TODO 6: Execute all registered cleanup functions\n    // TODO 7: Free container instance memory and allocated resources\n    // Hint: Follow reverse order of creation to prevent dependency issues\n    return -1; // Replace with implementation\n}\n```\n\nError propagation and recovery coordination:\n\n```c\n// error_handling.c\ntypedef enum {\n    CONTAINER_ERROR_NONE = 0,\n    CONTAINER_ERROR_VALIDATION = 1,\n    CONTAINER_ERROR_PRIVILEGES = 2,\n    CONTAINER_ERROR_NAMESPACES = 10,\n    CONTAINER_ERROR_MOUNT = 20,\n    CONTAINER_ERROR_NETWORK = 30,\n    CONTAINER_ERROR_CGROUPS = 40,\n    CONTAINER_ERROR_OOM = 100,\n    CONTAINER_ERROR_KILLED = 200\n} container_error_t;\n\nint handle_container_error(container_instance_t *container, container_error_t error) {\n    // TODO 1: Log error details with specific failure component\n    // TODO 2: Determine cleanup scope based on error type and setup progress\n    // TODO 3: Signal child process termination if necessary\n    // TODO 4: Execute appropriate cleanup sequence for current state\n    // TODO 5: Collect any additional error information (logs, resource usage)\n    // TODO 6: Return standardized error code for caller\n    // Hint: Error cleanup must be safe to call regardless of setup progress\n    return -1; // Replace with implementation\n}\n\nint propagate_child_error(pid_t child_pid, int child_status) {\n    // TODO 1: Check if child exited normally or was killed by signal\n    // TODO 2: Extract error code from child exit status\n    // TODO 3: Map child error codes to container error types\n    // TODO 4: Check for OOM killer involvement via cgroup events\n    // TODO 5: Return appropriate container error code\n    // Hint: Child exit codes encode which component failed during setup\n    return CONTAINER_ERROR_NONE; // Replace with implementation\n}\n```\n\n**E. Language-Specific Hints**\n\n- Use `clone()` instead of `fork()` + `unshare()` to avoid race conditions in namespace setup\n- The `SIGCHLD` handler for zombie reaping must be async-signal-safe (no malloc, printf, etc.)\n- Stack for `clone()` grows downward on most architectures - allocate at high address\n- Check `/proc/self/ns/` to verify namespace support before attempting creation\n- Use `eventfd()` for more reliable parent-child synchronization than pipes\n- `pivot_root()` requires both old and new root to be on different filesystems\n- Network namespace operations require `CAP_NET_ADMIN` capability\n- Cgroup cleanup requires removing child cgroups before parent cgroups\n\n**F. Milestone Checkpoint**\n\nAfter implementing container lifecycle coordination:\n\n**Test Container Creation and Cleanup:**\n```bash\n# Compile with all components\ngcc -o container-basic src/*.c -I./src\n\n# Test basic container creation\nsudo ./container-basic create --rootfs /tmp/container-root --cmd /bin/sh\n\n# Verify namespaces created correctly\nsudo lsns -t pid,mnt,net -p $(pgrep container-basic)\n\n# Test error handling\n./container-basic create --rootfs /nonexistent --cmd /bin/sh\necho \"Exit code: $?\"\n\n# Test resource cleanup\nsudo ./container-basic create --rootfs /tmp/container-root --memory 100M --cmd \"sleep 1\"\n# Verify cgroup removed after container exits\nls /sys/fs/cgroup/memory/container-basic-* 2>/dev/null || echo \"Cleanup successful\"\n```\n\n**Expected behavior:**\n- Container starts with all namespaces isolated\n- Application runs with resource limits enforced\n- Cleanup removes all created resources\n- Error conditions trigger proper cleanup\n- No resource leaks in namespace or cgroup hierarchies\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Container hangs during startup | Parent-child synchronization deadlock | Check pipe file descriptors, look for blocking reads | Add timeouts to synchronization waits |\n| \"Operation not permitted\" on clone | Insufficient privileges for namespace creation | Check capabilities with `capsh --print`, verify CAP_SYS_ADMIN | Run as root or add required capabilities |\n| Mount operations fail inside container | Mount namespace not properly isolated | Check /proc/mounts in container vs host | Ensure MS_PRIVATE propagation set correctly |\n| Network interface not found | Veth pair creation or assignment failed | Check `ip link` for interface existence | Verify network namespace creation and interface movement |\n| OOM killer terminates container immediately | Memory limit too low for application | Check cgroup memory.usage_in_bytes vs memory.limit_in_bytes | Increase memory limit or reduce application memory usage |\n| Resources not cleaned up after exit | Cleanup functions not registered or executed | Check cleanup list registration and execution order | Ensure all setup operations register cleanup handlers |\n| Child process becomes zombie | Parent not calling waitpid() | Check parent process signal handlers and main loop | Implement proper SIGCHLD handling or explicit wait calls |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** This section applies to all milestones (1-4), covering failure modes and recovery strategies across PID namespaces, mount namespaces, network namespaces, and cgroups components.\n\nBuilding a container runtime involves orchestrating multiple kernel subsystems, each with distinct failure modes and complex interdependencies. When creating namespaces, configuring cgroups, or setting up networking, numerous failure scenarios can occur - from insufficient privileges to kernel feature unavailability to resource exhaustion. The challenge is not just handling individual component failures, but managing the cascading effects and cleanup requirements when failures occur during the multi-step container startup sequence.\n\n**Mental Model: Emergency Response System**: Think of container error handling like a hospital's emergency response system. When a medical emergency occurs, the hospital has well-defined protocols for different types of incidents (cardiac arrest, trauma, stroke), clear escalation procedures, and systematic approaches to resource allocation and cleanup. Similarly, our container runtime needs protocols for different failure types (namespace creation, resource exhaustion, network setup), clear error propagation paths, and systematic cleanup procedures that prevent resource leaks even when multiple components fail simultaneously.\n\nThe complexity arises because container creation involves a precise sequence of operations that create kernel resources (namespaces, cgroups, network interfaces) and establish process relationships. Unlike simple application failures that can be handled with basic exception handling, container failures often occur in privileged kernel operations with partial state changes that must be carefully unwound. A failure during network namespace creation might leave a veth interface orphaned on the host, while a failure during mount namespace setup might leave filesystems mounted that prevent proper cleanup.\n\nOur error handling strategy follows three core principles: **early detection** to catch problems before they cascade, **graceful degradation** to maintain system stability when individual components fail, and **complete cleanup** to ensure no kernel resources leak even during complex failure scenarios. Each component must track its own resources and provide cleanup functions, while the overall container system coordinates cleanup order and error propagation.\n\n![Container Lifecycle State Machine](./diagrams/container-lifecycle-states.svg)\n\n### Namespace Creation Failures\n\nNamespace creation represents one of the most common failure points in container runtime operation because it depends on kernel features, system privileges, and resource availability that may not be guaranteed. Understanding and handling these failures properly is essential for building a robust container system that can operate reliably across different environments and configurations.\n\n**Mental Model: Apartment Building Permits**: Think of namespace creation like obtaining permits to build different sections of an apartment building. You need separate permits for plumbing (network namespace), electrical (PID namespace), and structural changes (mount namespace). If the city denies any permit due to zoning restrictions (kernel features disabled), insufficient fees (privilege levels), or resource limits (too many existing permits), you can't proceed with that portion of construction. However, you need to handle the permit denial gracefully and clean up any permits you've already obtained.\n\nThe most frequent namespace creation failure is **insufficient privileges**. Creating namespaces typically requires either root privileges or specific capabilities like `CAP_SYS_ADMIN`. When running without sufficient privileges, the `clone()` or `unshare()` system calls fail with `EPERM`, indicating permission denied. This failure mode is particularly challenging because it often occurs after some setup has already completed, requiring careful cleanup of partial state.\n\n**Kernel feature unavailability** represents another critical failure mode. Not all Linux kernels are compiled with namespace support enabled, and some container execution environments deliberately disable certain namespace types for security reasons. The `clone()` call may fail with `EINVAL` when attempting to create unsupported namespace types, or with `ENOSYS` if the kernel lacks namespace support entirely.\n\n> **Decision: Graceful Namespace Degradation Strategy**\n> - **Context**: Some environments may support only a subset of namespaces (e.g., PID but not network), requiring decisions about partial container functionality\n> - **Options Considered**: \n>   - Fail completely if any namespace creation fails\n>   - Allow containers to run with reduced isolation\n>   - Make namespace types configurable with fallback behavior\n> - **Decision**: Fail completely for core namespaces (PID, mount) but allow optional degradation for network namespaces\n> - **Rationale**: PID and mount isolation are fundamental to container security, while network isolation can be provided by external tools in some deployment scenarios\n> - **Consequences**: Ensures minimum security guarantees while allowing deployment flexibility in constrained environments\n\n| Failure Mode | Error Code | Detection Method | Recovery Strategy |\n|---------------|------------|-----------------|-------------------|\n| Insufficient privileges | EPERM | Check return value from clone/unshare | Log clear error message, suggest running as root or with capabilities |\n| Kernel feature disabled | EINVAL | Attempt namespace creation, check errno | Check /proc/sys/kernel for namespace support, provide feature-specific error |\n| Resource exhaustion | ENOMEM | Memory allocation failure during clone | Free existing allocations, reduce memory requirements, retry with backoff |\n| Process limit reached | EAGAIN | Clone fails due to process limits | Wait for processes to exit, check ulimits, suggest increasing limits |\n| Namespace limit exceeded | ENOSPC | System namespace limit reached | Clean up unused namespaces, suggest system-level tuning |\n\nThe **namespace creation error handling function** must distinguish between recoverable and non-recoverable failures. Privilege failures typically require user intervention (running with sudo or setting capabilities), while resource exhaustion might be temporary and allow for retry strategies. The error handling logic should provide actionable error messages that help operators understand both the immediate cause and potential solutions.\n\n**Resource exhaustion during namespace creation** can manifest in several ways. Memory exhaustion (`ENOMEM`) during the `clone()` call indicates the kernel cannot allocate internal data structures for the new namespace. This often occurs in memory-constrained environments or when creating many containers rapidly. The recovery strategy involves releasing any allocated resources and potentially implementing exponential backoff for retry attempts.\n\n**Process limit exhaustion** (`EAGAIN`) occurs when the system or user process limits prevent creating new processes via `clone()`. This is distinct from namespace limits themselves - the system may support creating namespaces but refuse to create the process that would inhabit them. Recovery requires checking both system-wide process limits (`/proc/sys/kernel/pid_max`) and user limits (`ulimit -u`).\n\nThe **namespace handle cleanup** process becomes critical when creation fails partway through establishing multiple namespaces. Since namespace creation often involves creating PID, mount, and network namespaces in sequence, a failure during network namespace creation requires cleaning up the successfully created PID and mount namespaces. Each namespace file descriptor in the `namespace_fds` array of the `container_instance_t` structure must be closed properly to release kernel resources.\n\n> The fundamental principle for namespace creation error handling is **atomic semantics** - either all required namespaces are successfully created, or none are left in a partial state that could cause resource leaks or security vulnerabilities.\n\n**Timing-dependent failures** represent a subtle category of namespace creation issues. Creating multiple namespaces in sequence can encounter race conditions where kernel resources become unavailable between namespace creation calls. For example, the system might successfully create a PID namespace but fail to create the network namespace due to resource exhaustion that occurred after the PID namespace consumed memory. These failures require careful ordering and resource validation before beginning the namespace creation sequence.\n\nThe **error propagation mechanism** must handle failures that occur in the child process after `clone()` successfully creates the process but before the child can complete its namespace setup. Since the child runs in a separate process, it cannot directly return error codes to the parent. Instead, it must use the parent-child synchronization pipes defined in `container_sync_t` to communicate setup failures back to the parent process for proper cleanup coordination.\n\n⚠️ **Pitfall: Partial Namespace Cleanup**\nMany implementations fail to properly clean up namespaces when creation fails partway through the sequence. For example, if PID and mount namespaces are created successfully but network namespace creation fails, the PID and mount namespace file descriptors must be closed to release kernel resources. Forgetting this cleanup can lead to namespace handle leaks that persist until the parent process exits. Always iterate through the `namespace_fds` array and close any valid file descriptors (non-negative values) during error cleanup.\n\n⚠️ **Pitfall: Ignoring Kernel Version Dependencies**\nDifferent Linux kernel versions support different namespace types and have varying resource limits. Attempting to create user namespaces on kernels older than 3.8 or network namespaces without proper kernel configuration will fail in non-obvious ways. Always check kernel version compatibility and provide clear error messages that indicate minimum kernel requirements when namespace creation fails with `EINVAL` or `ENOSYS`.\n\n### Resource Exhaustion\n\nResource exhaustion scenarios represent some of the most complex failure modes in container systems because they can occur at any point during container lifecycle and often involve kernel-level enforcement mechanisms that terminate processes without warning. Unlike application-level resource limits that can be checked programmatically, kernel resource limits like memory exhaustion invoke the OOM killer, which terminates processes based on heuristics rather than application priorities.\n\n**Mental Model: City Utility Management**: Think of resource exhaustion like a city managing utilities during peak demand. When electricity demand exceeds generation capacity, the city doesn't politely ask residents to reduce usage - it implements rolling blackouts based on priority zones. Similarly, when container memory usage exceeds cgroup limits, the kernel doesn't negotiate - it invokes the OOM killer to terminate processes based on kernel heuristics, not application priorities. The container runtime must be prepared for sudden process termination and have cleanup mechanisms that work even when primary processes are killed unexpectedly.\n\n**Memory exhaustion and OOM conditions** represent the most dramatic form of resource exhaustion because they result in immediate process termination rather than graceful degradation. When a container exceeds its memory limit configured through the memory cgroup controller, the kernel's OOM killer selects processes within that cgroup for termination. The selection algorithm considers factors like memory usage, process age, and OOM adjustment scores, but the container runtime has limited control over which processes are terminated first.\n\nThe **OOM killer behavior** varies significantly between cgroups v1 and v2, affecting how container processes experience memory pressure. In cgroups v1, the OOM killer typically terminates the highest memory-consuming process within the cgroup when the limit is exceeded. In cgroups v2, the kernel implements more sophisticated memory pressure handling with early warning signals before reaching hard limits. Container runtimes must handle both scenarios and provide appropriate monitoring and recovery mechanisms.\n\n| Resource Type | Exhaustion Trigger | Kernel Response | Detection Method | Recovery Strategy |\n|---------------|-------------------|-----------------|------------------|-------------------|\n| Memory | Usage exceeds cgroup limit | OOM killer terminates processes | Process exit status 137 (SIGKILL) | Monitor memory pressure, implement graceful restart |\n| CPU | Usage exceeds quota | Process throttling | Increased execution time | Monitor throttling statistics, adjust limits |\n| Process count | Forks exceed pids limit | fork() fails with EAGAIN | Failed process creation | Monitor process count, clean up zombie processes |\n| File descriptors | Open files exceed limit | open() fails with EMFILE | File operation failures | Close unused descriptors, increase limits |\n| Network bandwidth | Traffic exceeds shaping rules | Packet dropping/queuing | Network performance degradation | Implement traffic prioritization |\n\n**CPU throttling** provides a more graceful form of resource exhaustion where the kernel doesn't terminate processes but instead restricts their execution time. When a container exceeds its CPU quota within the configured period, the kernel throttles the processes by putting them to sleep until the next scheduling period begins. This throttling is transparent to the application but manifests as increased execution time for CPU-bound operations.\n\nThe **CPU controller statistics** available through the cgroup filesystem provide detailed information about throttling events, including the number of times processes were throttled and the total time spent in throttled state. Container runtimes should monitor these statistics to detect CPU pressure and potentially adjust limits or provide warnings about application performance degradation.\n\n**Process limit exhaustion** occurs when containers attempt to create more processes or threads than allowed by the pids controller. Unlike memory exhaustion which terminates existing processes, process limit exhaustion prevents new process creation while leaving existing processes running normally. The `fork()`, `clone()`, and `pthread_create()` operations fail with `EAGAIN`, allowing applications to handle the failure gracefully if they implement appropriate error checking.\n\n> The key insight for process limit handling is that applications must be designed to handle process creation failures gracefully, unlike memory exhaustion where process termination is unavoidable and must be handled through external monitoring and restart mechanisms.\n\n**File descriptor exhaustion** can occur both at the process level (hitting the per-process `RLIMIT_NOFILE` limit) and at the system level (hitting the global file descriptor limit). Container applications that open many files, sockets, or pipes without proper cleanup can quickly exhaust available file descriptors. The failure manifests as `EMFILE` (too many open files) or `ENFILE` (file table overflow) errors from system calls like `open()`, `socket()`, or `pipe()`.\n\n**Network resource exhaustion** primarily manifests through bandwidth limits imposed by traffic control mechanisms rather than hard cgroup limits. When containers exceed configured network bandwidth limits, the kernel may drop packets, increase latency through queuing, or apply traffic shaping rules that degrade network performance. Unlike CPU or memory limits, network exhaustion rarely causes immediate application failure but instead degrades performance gradually.\n\nThe **memory pressure monitoring** mechanism provides early warning before OOM killer activation through cgroup event notifications. The memory controller exposes pressure events through the `memory.pressure_level` interface in cgroups v1 and through pressure stall information in cgroups v2. Container runtimes can register for these notifications to implement proactive memory management, such as requesting applications to free caches or triggering graceful container shutdown before hitting hard limits.\n\n**Resource exhaustion recovery strategies** must consider the cascading effects of resource limits across multiple containers sharing the same host system. When one container exhausts memory and triggers OOM killer activity, other containers may experience performance degradation due to increased system memory pressure. The recovery mechanism should monitor system-wide resource pressure in addition to per-container limits.\n\n⚠️ **Pitfall: Ignoring Memory Pressure Warnings**\nMany container implementations only detect memory problems when the OOM killer activates, but cgroups provide earlier warning signals through memory pressure notifications. Ignoring these warnings means missing opportunities for graceful degradation, such as reducing cache sizes or checkpointing application state. Monitor the `memory.pressure_level` events and implement proactive memory management rather than reactive OOM handling.\n\n⚠️ **Pitfall: Misunderstanding CPU Throttling Effects**\nCPU throttling doesn't just slow down the main application - it affects all processes in the cgroup, including monitoring agents, log collectors, and health check scripts. This can create cascading failures where health checks timeout due to throttling, causing orchestration systems to restart healthy containers unnecessarily. Account for monitoring overhead when setting CPU limits and consider excluding critical monitoring processes from throttled cgroups.\n\n⚠️ **Pitfall: Process Limit Bypass Through Threading**\nThe pids controller counts threads as processes, but applications might attempt to bypass process limits by using thread pools or async I/O instead of forking processes. However, thread creation can still fail when hitting the pids limit, causing subtle application failures that manifest as hanging requests or degraded performance rather than obvious process creation errors. Test applications under process pressure to ensure they handle threading failures appropriately.\n\n### Cleanup Failures\n\nCleanup failures represent one of the most insidious categories of container runtime errors because they often go unnoticed until they accumulate into system-wide problems. Unlike startup failures that immediately signal problems through failed container launches, cleanup failures manifest as gradual resource leaks, orphaned kernel objects, and eventual system instability. The challenge is compounded by the fact that cleanup operations often occur during error conditions when the system is already in a degraded state.\n\n**Mental Model: Restaurant Closing Procedures**: Think of cleanup failures like a restaurant that doesn't properly close each night. If the staff forgets to turn off equipment, clean tables, or secure the building, small problems accumulate over time. A few unwashed dishes become a pest problem; unlocked doors become security issues; equipment left running becomes fire hazards. Similarly, cleanup failures in containers start small - a forgotten veth interface, an unclosed namespace file descriptor, an abandoned cgroup directory - but accumulate into system-wide resource exhaustion, kernel object leaks, and eventually system instability requiring reboot to resolve.\n\n**Partial cleanup scenarios** occur when some cleanup operations succeed while others fail, leaving the system in an inconsistent state. For example, a container might successfully remove its cgroup directory but fail to delete the veth interface due to network configuration errors. The container appears to have cleaned up from the cgroup perspective, but network resources remain allocated, potentially causing IP address conflicts or interface name collisions for future containers.\n\nThe **cleanup ordering dependencies** create complex failure scenarios where the sequence of cleanup operations affects success rates. Network interfaces must be removed before closing network namespace file descriptors; mount points must be unmounted before removing mount namespaces; processes must be terminated before removing cgroups. When cleanup operations fail, subsequent operations in the sequence may also fail due to dependency violations.\n\n| Cleanup Component | Dependencies | Failure Modes | Recovery Strategy |\n|-------------------|--------------|---------------|-------------------|\n| Process termination | Must complete before cgroup removal | Process refuses to die, zombie accumulation | SIGTERM → wait → SIGKILL → force cleanup |\n| Network interfaces | Must remove before closing network namespace | Interface busy, namespace unreachable | Force interface down, use different namespace |\n| Mount points | Must unmount before namespace cleanup | Filesystem busy, permission denied | Lazy unmount (MNT_DETACH), force unmount |\n| Cgroup directories | Processes must exit first | Directory not empty, permission denied | Kill remaining processes, recursive removal |\n| Namespace file descriptors | Close after removing associated resources | File descriptor corruption | Force close, accept potential leaks |\n\n**Cgroup cleanup failures** frequently occur because cgroup directories cannot be removed while they still contain processes, even zombie processes awaiting reaping. The kernel enforces this restriction to maintain accounting accuracy, but it creates complex cleanup scenarios when container processes don't exit cleanly. A single zombie process can prevent cgroup cleanup, leading to accumulating cgroup directories that consume kernel memory and eventually hit system limits.\n\nThe **hierarchical cleanup strategy** addresses these dependencies by implementing cleanup in reverse dependency order: terminate processes first, then remove cgroups, then clean up namespaces, then remove network interfaces. However, each step can fail independently, requiring the cleanup system to continue with subsequent steps even when earlier steps fail partially.\n\n**Mount point cleanup failures** occur when filesystems remain busy due to open file descriptors, running processes, or active bind mounts. The `umount()` system call fails with `EBUSY`, leaving mount points active and preventing proper mount namespace cleanup. The recovery strategy involves using `MNT_DETACH` for lazy unmounting, which removes the mount point from the namespace view immediately but defers actual filesystem cleanup until all references are released.\n\n> **Decision: Cleanup Continuation Strategy**\n> - **Context**: When cleanup operations fail, the system must decide whether to abort cleanup entirely or continue with remaining operations\n> - **Options Considered**:\n>   - Stop cleanup on first failure to maintain consistency\n>   - Continue cleanup despite failures to release maximum resources\n>   - Implement retry mechanisms with exponential backoff\n> - **Decision**: Continue cleanup despite failures, with comprehensive error logging and retry for specific failure types\n> - **Rationale**: Resource leaks cause cumulative system degradation, so releasing as many resources as possible is preferable to maintaining perfect consistency\n> - **Consequences**: Requires careful error aggregation and reporting to surface cleanup issues without stopping resource recovery\n\n**Network cleanup failures** often involve orphaned veth interfaces that remain on the host side even after the container network namespace is destroyed. When network namespace destruction fails or is incomplete, the host-side veth interface may persist without its paired container interface, creating a dangling interface that consumes network namespace slots and may cause naming conflicts for future containers.\n\nThe **cleanup function registration mechanism** using the `cleanup_list_t` structure provides a systematic approach to ensure all allocated resources are released even when cleanup operations fail. Each component registers its cleanup functions during resource allocation, creating a comprehensive list of cleanup operations that execute in reverse order during container destruction. This pattern ensures that cleanup attempts occur for all resources, even if individual cleanup functions encounter failures.\n\n**Error aggregation during cleanup** requires collecting multiple error conditions and presenting them coherently to operators. Since cleanup continues despite individual failures, the final cleanup result may include errors from multiple components. The error reporting mechanism must distinguish between failures that indicate resource leaks (requiring operator attention) and failures that are purely informational (such as attempting to remove already-removed resources).\n\n**Timeout-based cleanup** addresses scenarios where cleanup operations hang indefinitely due to kernel deadlocks, filesystem issues, or network problems. Each cleanup operation should have reasonable timeouts to prevent container destruction from hanging indefinitely. When timeouts occur, the cleanup system must decide whether to escalate to more aggressive cleanup methods (such as force-killing processes) or accept resource leaks to maintain system stability.\n\n⚠️ **Pitfall: Cleanup Function Exception Safety**\nCleanup functions themselves can fail and must not throw exceptions or abort the cleanup process. A common mistake is writing cleanup functions that assume resources are in a valid state, causing cleanup failures when those resources were already partially destroyed. Always check resource validity before attempting cleanup operations and handle cases where resources may already be released by other cleanup paths.\n\n⚠️ **Pitfall: Ignoring Cleanup Ordering**\nAttempting to remove cgroups before terminating processes or closing namespace file descriptors before unmounting filesystems will cause cleanup failures that could be avoided with proper ordering. These failures often appear intermittent because they depend on timing between process termination and cleanup execution. Implement explicit dependency tracking between cleanup operations and ensure proper ordering even under race conditions.\n\n⚠️ **Pitfall: Incomplete Error Context in Cleanup**\nCleanup failures often occur in degraded system states where normal debugging information isn't available. Cleanup error messages must include sufficient context to diagnose problems without access to the original container configuration or process state. Log the specific resource being cleaned (PID, interface name, cgroup path) and the exact error condition, not just generic \"cleanup failed\" messages that provide no actionable information.\n\n### Implementation Guidance\n\nThe error handling implementation requires robust error detection, classification, and recovery mechanisms that coordinate across all container components. The implementation focuses on early failure detection, comprehensive error reporting, and systematic cleanup that prevents resource leaks even during cascading failures.\n\n**Technology Recommendations:**\n\n| Component | Approach | Implementation |\n|-----------|----------|----------------|\n| Error Classification | Structured error codes | container_error_t enum with specific failure types |\n| Error Context | Detailed error information | Error structures with component, operation, and system error details |\n| Cleanup Management | Resource tracking | cleanup_list_t with function pointers for systematic resource cleanup |\n| Timeout Handling | Non-blocking cleanup | Timer-based cleanup with escalation to force operations |\n| Error Aggregation | Multiple error collection | Error arrays that collect failures from multiple cleanup operations |\n\n**Recommended File Structure:**\n```\ncontainer-basic/\n  src/\n    error/\n      error_types.h          ← Error codes and classification\n      error_handlers.c       ← Error handling and recovery functions\n      cleanup.h              ← Cleanup list management interface\n      cleanup.c              ← Cleanup function registration and execution\n    container/\n      container_errors.h     ← Container-specific error handling\n      container_errors.c     ← Container error coordination and propagation\n    namespace/\n      namespace_errors.c     ← Namespace creation failure handling\n    cgroups/\n      cgroups_errors.c       ← Resource exhaustion detection and handling\n    network/\n      network_errors.c       ← Network setup failure handling\n  tests/\n    error_scenarios/         ← Error injection and recovery testing\n```\n\n**Error Classification Infrastructure:**\n\n```c\n#include <errno.h>\n#include <string.h>\n#include <sys/wait.h>\n\n// Complete error type enumeration for container operations\ntypedef enum {\n    CONTAINER_ERROR_NONE = 0,\n    CONTAINER_ERROR_VALIDATION,     // Configuration validation failed\n    CONTAINER_ERROR_NAMESPACES,     // Namespace creation failed\n    CONTAINER_ERROR_MOUNT,          // Mount operations failed\n    CONTAINER_ERROR_NETWORK,        // Network setup failed\n    CONTAINER_ERROR_CGROUPS,        // Cgroup setup failed\n    CONTAINER_ERROR_OOM,            // Out of memory condition\n    CONTAINER_ERROR_PRIVILEGES,     // Insufficient permissions\n    CONTAINER_ERROR_KERNEL_FEATURE, // Kernel feature unavailable\n    CONTAINER_ERROR_RESOURCE_LIMIT, // System resource limit hit\n    CONTAINER_ERROR_CLEANUP,        // Cleanup operation failed\n    CONTAINER_ERROR_TIMEOUT         // Operation timeout\n} container_error_t;\n\n// Detailed error context for debugging and recovery\ntypedef struct container_error_context {\n    container_error_t type;\n    const char* component;      // Which component failed\n    const char* operation;      // What operation was being performed\n    int system_errno;          // System error code if applicable\n    const char* details;       // Human-readable error description\n    int recovery_attempted;    // Whether recovery was attempted\n} container_error_context_t;\n\n// Error context creation and management\ncontainer_error_context_t* create_error_context(container_error_t type, \n                                               const char* component,\n                                               const char* operation) {\n    // TODO 1: Allocate error context structure\n    // TODO 2: Initialize fields with provided parameters\n    // TODO 3: Capture current errno value for system_errno field\n    // TODO 4: Generate human-readable error message for details field\n    // TODO 5: Return initialized context structure\n}\n\n// Error classification from system errno values\ncontainer_error_t classify_namespace_error(int errno_val) {\n    // TODO 1: Check for permission errors (EPERM) → CONTAINER_ERROR_PRIVILEGES\n    // TODO 2: Check for feature errors (EINVAL, ENOSYS) → CONTAINER_ERROR_KERNEL_FEATURE  \n    // TODO 3: Check for resource errors (ENOMEM, EAGAIN) → CONTAINER_ERROR_RESOURCE_LIMIT\n    // TODO 4: Check for validation errors (EINVAL with bad params) → CONTAINER_ERROR_VALIDATION\n    // TODO 5: Return CONTAINER_ERROR_NAMESPACES for other namespace-related errors\n}\n```\n\n**Cleanup List Management Infrastructure:**\n\n```c\n#include <stdlib.h>\n\n// Cleanup function pointer type\ntypedef void (*cleanup_function_t)(void* data);\n\n// Cleanup list node for systematic resource management\ntypedef struct cleanup_list {\n    cleanup_function_t cleanup_func;\n    void* data;\n    const char* description;    // For debugging cleanup failures\n    struct cleanup_list* next;\n} cleanup_list_t;\n\n// Register cleanup function for resource that needs cleanup on failure\nvoid register_cleanup(cleanup_list_t** list, cleanup_function_t func, \n                     void* data, const char* description) {\n    // TODO 1: Allocate new cleanup list node\n    // TODO 2: Initialize node with function pointer and data\n    // TODO 3: Set description for debugging cleanup failures\n    // TODO 4: Add node to front of cleanup list for LIFO execution\n    // TODO 5: Update list head pointer to new node\n}\n\n// Execute all cleanup functions in reverse registration order\nint execute_cleanup(cleanup_list_t** list) {\n    // TODO 1: Iterate through cleanup list from head to tail\n    // TODO 2: Call each cleanup function with its associated data\n    // TODO 3: Log cleanup function description and any errors\n    // TODO 4: Continue cleanup even if individual functions fail\n    // TODO 5: Free cleanup list nodes and set list pointer to NULL\n    // TODO 6: Return count of failed cleanup operations\n}\n\n// Cleanup functions for specific resource types\nvoid cleanup_namespace_fd(void* fd_ptr) {\n    // TODO 1: Cast void pointer to int pointer for file descriptor\n    // TODO 2: Check if file descriptor value is valid (>= 0)\n    // TODO 3: Close file descriptor and check for errors\n    // TODO 4: Set file descriptor to -1 to mark as cleaned up\n    // TODO 5: Log cleanup completion or failure for debugging\n}\n\nvoid cleanup_cgroup_path(void* path_ptr) {\n    // TODO 1: Cast void pointer to char pointer for cgroup path\n    // TODO 2: Verify cgroup path exists before attempting removal\n    // TODO 3: Remove cgroup directory using rmdir system call\n    // TODO 4: Handle ENOENT (already removed) as success condition\n    // TODO 5: Log cgroup cleanup result with path information\n}\n\nvoid cleanup_network_interface(void* if_name_ptr) {\n    // TODO 1: Cast void pointer to char pointer for interface name\n    // TODO 2: Check if interface exists in current namespace\n    // TODO 3: Remove interface using netlink socket or ip command\n    // TODO 4: Handle interface already removed as success condition\n    // TODO 5: Log interface cleanup result with interface name\n}\n```\n\n**Resource Exhaustion Detection:**\n\n```c\n#include <sys/stat.h>\n#include <fcntl.h>\n\n// Monitor memory pressure in container cgroup\nint check_memory_pressure(const char* cgroup_path, int* pressure_level) {\n    // TODO 1: Construct path to memory.pressure_level file in cgroup\n    // TODO 2: Open pressure level file for reading\n    // TODO 3: Read current pressure level value (0=low, 1=medium, 2=critical)\n    // TODO 4: Close file and handle any read errors appropriately\n    // TODO 5: Set pressure_level output parameter and return success status\n}\n\n// Monitor CPU throttling statistics\nint check_cpu_throttling(const char* cgroup_path, long* throttled_time) {\n    // TODO 1: Construct path to cpu.stat file in cgroup directory\n    // TODO 2: Open and read cpu statistics file content\n    // TODO 3: Parse throttled_time field from statistics output\n    // TODO 4: Calculate throttling rate since last check\n    // TODO 5: Return throttling statistics through output parameter\n}\n\n// Check for OOM killer activity in container\nint detect_oom_condition(pid_t container_pid, int* oom_occurred) {\n    // TODO 1: Check exit status of container process for signal 137 (SIGKILL)\n    // TODO 2: Read memory.oom_control file to check for OOM events\n    // TODO 3: Parse kernel log messages for OOM killer activity\n    // TODO 4: Correlate OOM events with container PID and cgroup\n    // TODO 5: Set oom_occurred flag and return detection status\n}\n```\n\n**Comprehensive Error Handling Coordination:**\n\n```c\n// Main container error handling function\nint handle_container_error(container_instance_t* container, \n                          container_error_context_t* error) {\n    // TODO 1: Log detailed error context with component and operation info\n    // TODO 2: Classify error severity (fatal vs recoverable)\n    // TODO 3: Execute component-specific error handling based on error type\n    // TODO 4: Execute cleanup list to release partial resources\n    // TODO 5: Update container state to ERROR and preserve error context\n    // TODO 6: Return appropriate error code for caller handling\n}\n\n// Propagate errors from child process to parent\nint propagate_child_error(pid_t child_pid, int child_status) {\n    // TODO 1: Check if child exited normally or was terminated by signal\n    // TODO 2: Extract exit code or signal number from child status\n    // TODO 3: Read error information from child through sync pipes if available\n    // TODO 4: Classify child error into appropriate container_error_t type\n    // TODO 5: Create error context with child failure details\n    // TODO 6: Return classified error for parent process handling\n}\n```\n\n**Milestone Checkpoints:**\n\nAfter implementing error handling for each milestone, verify the following behaviors:\n\n**Milestone 1 (PID Namespace) Error Handling:**\n- Run container creation without root privileges - should fail with clear privilege error message rather than cryptic system error\n- Create containers rapidly to trigger process limit exhaustion - should detect EAGAIN and provide actionable error message\n- Verify zombie processes are reaped even when container init process encounters errors during startup\n\n**Milestone 2 (Mount Namespace) Error Handling:**\n- Attempt container creation with non-existent rootfs path - should fail during validation with clear error about missing directory\n- Fill up filesystem to trigger mount failures - should detect ENOSPC and clean up partial mount points\n- Test pivot_root failure scenarios by using rootfs on read-only filesystem - should restore original mount state\n\n**Milestone 3 (Network Namespace) Error Handling:**\n- Create containers when veth creation fails due to interface name conflicts - should generate unique interface names or fail with specific naming error\n- Test network setup when bridge doesn't exist - should provide clear error about bridge configuration rather than generic network error\n- Verify network cleanup removes orphaned veth interfaces even when namespace destruction fails\n\n**Milestone 4 (Cgroups) Error Handling:**\n- Set memory limit higher than system RAM to test validation - should reject invalid configuration before attempting container creation\n- Trigger OOM conditions by setting very low memory limits - should detect OOM through process exit status and provide clear OOM error indication\n- Test cgroup cleanup when processes refuse to terminate - should escalate to SIGKILL and continue cleanup despite process cleanup failures\n\n\n## Testing Strategy\n\n> **Milestone(s):** This section provides testing approaches for all milestones (1-4), establishing verification methods for PID namespace isolation, mount namespace filesystem separation, network namespace connectivity, and cgroups resource enforcement.\n\nTesting a container runtime presents unique challenges because the system fundamentally alters the execution environment through kernel namespaces and resource controls. Unlike traditional application testing where functions operate in a predictable environment, container testing must verify that isolation mechanisms actually work—that processes cannot escape their boundaries, that resource limits are enforced, and that cleanup properly removes all traces of container execution.\n\n### Mental Model: Laboratory Safety Testing\n\nThink of container testing like verifying laboratory safety protocols. Just as a biosafety lab must prove its containment works—that dangerous specimens cannot escape their isolation chambers, that air filtration systems prevent contamination, and that emergency procedures properly decontaminate equipment—container testing must demonstrate that process isolation holds under stress, resource limits prevent one container from starving others, and cleanup procedures leave no dangerous residue.\n\nThe testing approach mirrors laboratory verification: isolation tests ensure boundaries hold, resource limit tests verify controls work under pressure, and cleanup tests confirm complete decontamination. Each test must run in a controlled environment where we can safely create \"dangerous\" conditions (resource exhaustion, malicious processes) and verify they remain contained.\n\n### Isolation Verification Tests\n\nIsolation verification tests form the foundation of container testing because they validate the core security and reliability promises of containerization. These tests must prove that namespaces create genuine boundaries that malicious or buggy processes cannot breach.\n\nThe **PID namespace isolation test** verifies that process trees remain completely separate between host and container. The test creates a container process that spawns multiple child processes with known behavior patterns, then verifies from the host that the container's PID assignments follow namespace rules. Inside the container, the init process should appear as PID 1, with child processes receiving sequential PIDs starting from 2. Simultaneously, the host should see the container processes using entirely different PID values from its own namespace.\n\n| Test Scenario | Container View | Host View | Verification Method |\n|---------------|----------------|-----------|-------------------|\n| Container init process | PID 1 | Real PID assigned by host | Read `/proc/self/stat` inside container vs external `ps` output |\n| Container child process | PID 2, 3, 4... | Different real PIDs | Compare `/proc` entries inside vs outside namespace |\n| Process visibility | Only container processes visible | Container processes visible with real PIDs | Check `/proc` directory listings |\n| Kill signal isolation | Cannot signal host processes | Host can signal container processes | Attempt cross-namespace kill operations |\n\nThe test implementation involves creating a container that runs a test program which forks several processes, each writing their perceived PID to shared storage. Simultaneously, the host monitors the actual PIDs assigned to these processes. The test succeeds only if the container processes consistently report PIDs 1, 2, 3... while the host observes different values, and if attempts to signal non-existent PIDs from within the container fail appropriately.\n\n**Mount namespace isolation testing** verifies that filesystem operations within the container cannot affect the host filesystem and that the container sees only its intended filesystem view. The test creates a container with a custom root filesystem, performs various mount operations inside the container, then verifies these changes remain invisible to the host.\n\nThe test procedure involves setting up a temporary directory structure as the container root, mounting it into a mount namespace, then performing operations that would be dangerous if they escaped the namespace: creating device nodes, mounting additional filesystems, and modifying system directories. After each operation, the test verifies that the host filesystem remains unchanged and that the container's view reflects only intended modifications.\n\n| Mount Operation | Container Result | Host Verification | Failure Indicator |\n|-----------------|------------------|-------------------|-------------------|\n| Create device node | Device appears in container `/dev` | Host `/dev` unchanged | New device visible on host |\n| Mount tmpfs on `/tmp` | Container sees empty `/tmp` | Host `/tmp` unchanged | Host `/tmp` becomes tmpfs |\n| Bind mount host directory | Directory visible in container | Original host path unchanged | Unexpected mount in host namespace |\n| Unmount `/proc` | Container loses `/proc` | Host `/proc` still functional | Host loses `/proc` access |\n\n**Network namespace isolation testing** demonstrates that container networking operates independently from host networking while maintaining intended connectivity paths. The test creates multiple containers with isolated network namespaces, configures networking between them, then verifies that network traffic follows only the intended paths.\n\nThe test establishes a baseline by creating containers with different IP addresses in the same subnet, connected through a bridge. Each container runs a simple network service listening on a known port. The test then verifies that containers can communicate with each other through the bridge but cannot access host network services unless explicitly configured, and that host network interfaces remain unaffected by container network operations.\n\nNetwork isolation verification requires testing both positive connectivity (intended paths work) and negative isolation (unintended paths are blocked). The test suite includes scenarios where containers attempt to bind to privileged ports, access host network interfaces, and communicate with external networks both with and without proper routing configuration.\n\n| Network Test | Expected Behavior | Isolation Verification | Failure Mode |\n|--------------|-------------------|------------------------|--------------|\n| Container-to-container | Communication succeeds via bridge | Traffic uses veth pairs only | Direct host interface access |\n| Container-to-host | Blocked unless explicitly allowed | Host services remain inaccessible | Container bypasses network namespace |\n| Host-to-container | Succeeds via configured routes | Container IP only reachable via bridge | Container IP visible on host interface |\n| External connectivity | Requires NAT configuration | Container uses host gateway correctly | Container accesses external networks directly |\n\nThe comprehensive isolation test suite runs all namespace types simultaneously to verify they don't interfere with each other. A multi-namespace test creates a container with PID, mount, and network isolation, then performs operations that would breach multiple boundaries if isolation failed. This test ensures that combining namespaces maintains the security properties of each individual namespace type.\n\n### Resource Limit Testing\n\nResource limit testing verifies that cgroups successfully prevent containers from consuming more resources than allocated and that resource exhaustion triggers appropriate system responses rather than affecting the broader system. These tests must safely create resource pressure situations and verify that limits hold under stress.\n\n**Memory limit enforcement testing** involves creating containers with specific memory limits, then running processes that attempt to exceed those limits. The test must verify that the Out of Memory (OOM) killer activates when containers exceed their memory allocation and that the OOM behavior only affects processes within the container's cgroup.\n\nThe memory test creates a container with a modest memory limit (e.g., 64MB), then runs a program inside the container that allocates memory in steadily increasing chunks. The test monitors both the container's memory usage statistics through cgroup files and system behavior when the limit is reached. Successful enforcement means the container process receives a SIGKILL when it exceeds its limit, while host processes and other containers continue operating normally.\n\n| Memory Scenario | Container Behavior | Cgroup Response | System Impact |\n|-----------------|-------------------|-----------------|---------------|\n| Within limit | Process continues normally | Usage tracked accurately | No system impact |\n| Approaching limit | Process continues, memory pressure increases | Memory pressure indicators triggered | Other containers unaffected |\n| Exceeding limit | Process receives SIGKILL from OOM killer | Memory usage drops to zero | Host memory remains available |\n| Rapid allocation | Allocation fails with ENOMEM | Usage never exceeds limit | System stability maintained |\n\nThe test implementation requires careful monitoring of multiple data sources: the container process exit status to detect OOM kills, cgroup memory statistics to track usage patterns, and system memory state to ensure the host remains stable. The test must distinguish between normal process termination and OOM killing, which requires checking both the exit signal and cgroup event notifications.\n\n**CPU limit enforcement testing** verifies that CPU quota and period settings effectively constrain container CPU usage over time. Unlike memory limits which create immediate binary responses, CPU limits require statistical verification over time periods to confirm that average CPU usage respects configured quotas.\n\nThe CPU test creates a container with a specific CPU limit (e.g., 50% of one CPU core) and runs CPU-intensive processes designed to consume 100% CPU if unlimited. The test measures actual CPU consumption over multiple time periods and verifies that the average consumption converges on the configured limit despite the container processes attempting to use more CPU time.\n\nCPU limit testing requires longer observation periods because the kernel's Completely Fair Scheduler (CFS) enforces CPU quotas over scheduling periods rather than instantaneously. The test must run for multiple scheduling periods (typically 100ms each) and calculate average CPU usage across periods to distinguish between temporary bursts and actual limit enforcement.\n\n| CPU Test Duration | Expected CPU Usage | Measurement Method | Success Criteria |\n|-------------------|-------------------|-------------------|------------------|\n| Single period (100ms) | May exceed limit temporarily | Read cgroup CPU statistics | Cannot evaluate limit effectiveness |\n| 10 periods (1 second) | Approaching configured limit | Average usage over period | Within 10% of configured limit |\n| 100 periods (10 seconds) | Converged on limit | Statistical average | Within 5% of configured limit |\n| Extended run (60 seconds) | Stable at limit | Long-term average | Within 2% of configured limit |\n\n**Process limit enforcement testing** verifies that containers cannot create more processes or threads than their configured limit allows. This test protects against fork bombs and other process exhaustion attacks that could destabilize the host system.\n\nThe process limit test creates a container with a low process limit (e.g., 10 processes) and runs a program that continuously forks new processes. The test verifies that fork operations fail with appropriate error codes once the limit is reached and that the container cannot exceed its process allocation regardless of the forking strategy employed.\n\nProcess limit testing must account for different process creation methods: traditional fork(), clone() with various flags, and pthread creation. Each method counts against the process limit differently, and the test must verify that all creation methods respect the cgroup process controller limits.\n\nThe test monitors process creation through multiple mechanisms: direct counting of processes in the container's cgroup tasks file, monitoring fork() return values within the container, and observing system-wide process counts to ensure container processes don't escape the limit through namespace manipulation.\n\n**Resource pressure and recovery testing** verifies that containers respond appropriately to sustained resource pressure and can recover when resource usage returns to normal levels. These tests simulate realistic workload patterns where resource usage fluctuates over time.\n\nThe pressure test creates scenarios where containers approach but don't exceed their resource limits repeatedly, verifying that the system handles pressure situations gracefully without triggering unnecessary kills or throttling. This testing reveals whether cgroup controllers implement smooth pressure responses or exhibit unstable threshold behavior.\n\nRecovery testing complements pressure testing by verifying that containers can return to normal operation after experiencing resource pressure. The test creates containers that temporarily hit resource limits, then reduces their resource usage and verifies that performance returns to normal levels without requiring container restart.\n\n### Milestone Checkpoints\n\nMilestone checkpoints provide concrete verification steps that learners can execute after implementing each component to confirm their implementation works correctly before proceeding to the next milestone. These checkpoints include both automated tests and manual verification procedures.\n\n**Milestone 1 (PID Namespace) Checkpoint** focuses on verifying that process isolation works correctly and that the container init process handles its responsibilities properly. The checkpoint includes tests for namespace creation, PID assignment verification, and zombie process reaping.\n\nThe primary PID namespace verification involves running a test program inside the container that reports its PID and parent PID, while simultaneously observing these processes from the host namespace. The test succeeds when the container process reports PID 1 (indicating it's running as init in the namespace) while the host sees a different, higher PID value for the same process.\n\n| Verification Step | Command/Procedure | Expected Output | Troubleshooting |\n|-------------------|-------------------|-----------------|-----------------|\n| Container init PID | Run `echo $$` inside container | Output shows `1` | Check clone() flags include CLONE_NEWPID |\n| Host view of container | `ps aux | grep container-process` | Shows different PID than 1 | Verify parent process can see child PID |\n| Process tree isolation | `ps aux` inside container | Shows only container processes | Check mount namespace includes fresh /proc |\n| Zombie reaping | Create child process, exit parent | No zombie processes remain | Implement SIGCHLD handler in init process |\n\nThe zombie reaping test requires creating a container that spawns child processes, allowing some children to exit before their parents, then verifying that zombie processes are properly reaped. This test confirms that the container init process correctly implements PID 1 responsibilities for zombie collection.\n\n**Milestone 2 (Mount Namespace) Checkpoint** verifies that filesystem isolation prevents container operations from affecting the host filesystem and that essential filesystems are properly mounted within the container.\n\nThe mount namespace verification creates a container with a temporary root filesystem, performs filesystem operations that would be problematic if they affected the host, then confirms that the host filesystem remains unchanged while the container has access to necessary filesystem features.\n\n| Verification Step | Test Operation | Container View | Host View |\n|-------------------|----------------|----------------|-----------|\n| Root filesystem isolation | Create file in container root | File visible in container | File not visible in host root |\n| /proc filesystem | `cat /proc/version` | Shows kernel version | Container /proc independent of host |\n| Device node creation | `mknod /dev/test c 1 1` | Device appears in container | Host /dev unchanged |\n| Mount propagation | Mount tmpfs in container | Container sees new mount | Host mounts unchanged |\n\nThe piviot_root verification requires special attention because this operation permanently changes the container's filesystem view. The test must verify that the container cannot access the original host filesystem after pivot_root completes while maintaining access to essential filesystems like `/proc` and `/sys`.\n\n**Milestone 3 (Network Namespace) Checkpoint** confirms that network isolation works correctly and that container networking provides both isolation and connectivity as intended. The verification includes testing network interface isolation, veth pair connectivity, and bridge networking configuration.\n\nNetwork namespace verification requires creating multiple containers and testing connectivity patterns between them and between containers and the host. The test must confirm that network traffic follows intended paths and cannot bypass isolation mechanisms.\n\n| Network Test | Setup | Verification Command | Expected Result |\n|--------------|-------|---------------------|-----------------|\n| Interface isolation | Create container with network namespace | `ip link show` in container | Shows only loopback + veth interface |\n| Container-to-container | Two containers on same bridge | `ping` from container A to container B | Ping succeeds with low latency |\n| Host-to-container | Container with bridge networking | `ping` from host to container IP | Ping succeeds if routing configured |\n| External connectivity | Container with NAT configured | `ping 8.8.8.8` from container | Ping succeeds through host gateway |\n\nThe veth pair verification requires inspecting both ends of the virtual ethernet connection to confirm that packets sent from the container veth interface appear on the host bridge interface and vice versa. This test confirms that the veth pair is correctly configured and assigned to the appropriate namespaces.\n\n**Milestone 4 (Cgroups) Checkpoint** verifies that resource limits are properly enforced and that containers cannot exceed their allocated resource quotas. The verification includes testing memory limits, CPU limits, and process limits under controlled stress conditions.\n\nCgroups verification requires creating resource pressure situations and monitoring both cgroup statistics and container behavior to confirm that limits are enforced. The test must distinguish between proper limit enforcement and system instability.\n\n| Resource Limit | Test Procedure | Monitoring | Success Criteria |\n|-----------------|----------------|------------|------------------|\n| Memory limit | Run memory allocator in container | Watch `memory.usage_in_bytes` | Process killed before exceeding limit |\n| CPU limit | Run CPU burner with 50% limit | Monitor `cpuacct.usage` over time | Average CPU usage converges to 50% |\n| Process limit | Fork bomb with 10 process limit | Count entries in `tasks` file | Process count never exceeds 10 |\n| Cgroup cleanup | Stop container and check cleanup | Verify cgroup directory removed | No leaked cgroup hierarchies |\n\nThe cgroup enforcement verification must account for kernel scheduler behavior and measurement timing. CPU limits, in particular, require statistical measurement over multiple scheduling periods to distinguish between temporary bursts and actual limit violations.\n\n**End-to-End Integration Checkpoint** combines all four milestones to verify that the complete container system works correctly when all isolation and resource control mechanisms operate simultaneously. This comprehensive test creates containers that exercise PID namespaces, mount namespaces, network namespaces, and cgroups together.\n\nThe integration test creates multiple containers with different configurations (varying resource limits, network configurations, and filesystem layouts) and runs workloads that stress multiple isolation mechanisms simultaneously. The test verifies that combining all isolation mechanisms maintains the security and performance properties of each individual mechanism.\n\n| Integration Scenario | Test Workload | Verification Points | Success Criteria |\n|---------------------|---------------|-------------------|------------------|\n| Multi-container isolation | CPU and memory intensive tasks | All namespaces maintain isolation | No cross-container interference |\n| Resource competition | Containers with different limits compete for resources | Each container respects its limits | Resource allocation follows cgroup limits |\n| Network and filesystem | Containers sharing bridge network with isolated filesystems | Network works, filesystems isolated | Connectivity preserved, filesystem isolation maintained |\n| Cleanup verification | Create and destroy multiple containers | System returns to baseline state | No leaked namespaces, cgroups, or network interfaces |\n\nThe integration checkpoint serves as a final verification that the container implementation provides robust isolation and resource control suitable for running untrusted workloads safely on a shared system.\n\n### Implementation Guidance\n\nThe testing infrastructure for a container runtime requires specialized tools and techniques because standard testing frameworks don't naturally handle namespace isolation and resource control verification. The testing system must create isolated environments, inject controlled failures, and measure system behavior across namespace boundaries.\n\n**Technology Recommendations for Testing Infrastructure:**\n\n| Testing Component | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Test Framework | Standard language test framework (e.g., C with assert macros) | Custom test harness with namespace support |\n| Process Monitoring | Parse /proc filesystem directly | Use netlink sockets for real-time process events |\n| Resource Monitoring | Read cgroup files periodically | Use cgroup event notification APIs |\n| Network Testing | Simple ping/nc connectivity tests | Custom packet injection and monitoring |\n| Cleanup Verification | Manual filesystem/process inspection | Automated resource leak detection |\n\n**Recommended Test File Structure:**\n\nThe testing infrastructure should be organized to support both component-level tests for individual namespace types and integration tests that verify the complete container system:\n\n```\ncontainer-basic/\n  tests/\n    unit/                           ← Component-specific tests\n      test_pid_namespace.c          ← PID namespace isolation tests\n      test_mount_namespace.c        ← Mount namespace filesystem tests  \n      test_network_namespace.c      ← Network namespace connectivity tests\n      test_cgroups.c               ← Resource limit enforcement tests\n    integration/                    ← End-to-end system tests\n      test_container_lifecycle.c    ← Full container creation/destruction\n      test_multi_container.c        ← Multiple containers interaction\n      test_resource_competition.c   ← Resource limit interaction\n    fixtures/                       ← Test data and helper programs\n      test_programs/               ← Programs to run inside test containers\n        cpu_burner.c               ← CPU-intensive workload\n        memory_allocator.c         ← Memory allocation test program\n        fork_bomb.c                ← Process limit test program\n        network_client.c           ← Network connectivity test client\n        network_server.c           ← Network service for connectivity tests\n      rootfs/                      ← Minimal root filesystem for container tests\n        bin/                       ← Basic utilities (busybox)\n        dev/                       ← Device nodes\n        proc/                      ← Mount point for /proc\n        sys/                       ← Mount point for /sys\n    helpers/                       ← Testing infrastructure code\n      test_framework.h             ← Common test macros and utilities\n      namespace_helpers.c          ← Functions for namespace verification\n      cgroup_helpers.c             ← Functions for cgroup monitoring\n      network_helpers.c            ← Functions for network setup/verification\n  Makefile                        ← Build system including test targets\n```\n\n**Test Framework Infrastructure Code:**\n\nThe test framework provides utilities for creating test containers, monitoring their behavior, and cleaning up resources. This infrastructure handles the complexity of coordinating tests across namespace boundaries:\n\n```c\n// test_framework.h - Common testing utilities for container verification\n#ifndef TEST_FRAMEWORK_H\n#define TEST_FRAMEWORK_H\n\n#include <sys/types.h>\n#include <stdint.h>\n\n// Test container configuration for creating isolated test environments\ntypedef struct {\n    char* test_name;                 // Human-readable test identifier\n    char* rootfs_path;              // Path to test root filesystem\n    size_t memory_limit_bytes;      // Memory limit for test container\n    int cpu_percent;                // CPU limit percentage\n    int max_processes;              // Process limit for fork bomb protection\n    int enable_network;             // Whether to set up network namespace\n    int cleanup_on_exit;            // Whether to clean up resources automatically\n} test_container_config_t;\n\n// Test verification result with detailed failure information\ntypedef struct {\n    int success;                    // Overall test success/failure\n    char* failure_reason;           // Human-readable failure description\n    int expected_value;             // Expected test value for comparison\n    int actual_value;               // Actual measured value\n    char* verification_details;     // Additional verification information\n} test_result_t;\n\n// Test cleanup tracking for resource leak prevention\ntypedef struct test_cleanup_item {\n    void (*cleanup_func)(void* data); // Function to call for cleanup\n    void* cleanup_data;              // Data to pass to cleanup function\n    char* description;               // Human-readable cleanup description\n    struct test_cleanup_item* next;  // Next cleanup item in list\n} test_cleanup_item_t;\n\n// Creates test container with specified configuration and returns PID\npid_t create_test_container(test_container_config_t* config);\n\n// Verifies that PID namespace isolation works correctly\ntest_result_t verify_pid_isolation(pid_t container_pid);\n\n// Verifies that mount namespace provides filesystem isolation  \ntest_result_t verify_mount_isolation(pid_t container_pid, const char* test_file);\n\n// Verifies that network namespace isolates network stack\ntest_result_t verify_network_isolation(pid_t container_pid);\n\n// Verifies that cgroup limits are properly enforced\ntest_result_t verify_resource_limits(pid_t container_pid, test_container_config_t* config);\n\n// Registers cleanup function to be called on test completion or failure\nvoid register_test_cleanup(test_cleanup_item_t** list, void (*func)(void*), void* data, const char* desc);\n\n// Executes all registered cleanup functions in reverse order\nvoid execute_test_cleanup(test_cleanup_item_t** list);\n\n// Test assertion macros with detailed failure reporting\n#define ASSERT_EQ(expected, actual, message) \\\n    do { \\\n        if ((expected) != (actual)) { \\\n            fprintf(stderr, \"FAIL: %s:%d: %s\\nExpected: %d, Actual: %d\\n\", \\\n                   __FILE__, __LINE__, message, (int)(expected), (int)(actual)); \\\n            return 0; \\\n        } \\\n    } while(0)\n\n#define ASSERT_TRUE(condition, message) \\\n    do { \\\n        if (!(condition)) { \\\n            fprintf(stderr, \"FAIL: %s:%d: %s\\nCondition failed: %s\\n\", \\\n                   __FILE__, __LINE__, message, #condition); \\\n            return 0; \\\n        } \\\n    } while(0)\n\n// TODO: Implement test container creation with all namespace isolation\n// TODO: Add test result reporting and aggregation across test suites  \n// TODO: Add automatic cleanup registration for namespace and cgroup resources\n// TODO: Add timeout handling for tests that may hang due to isolation issues\n\n#endif\n```\n\n**Core Test Logic Skeleton Code:**\n\nThe core testing logic provides template functions that learners complete to verify each type of isolation. These skeletons map directly to the verification procedures described in the design sections:\n\n```c\n// Test PID namespace isolation by verifying process ID assignment\nint test_pid_namespace_isolation() {\n    test_cleanup_item_t* cleanup_list = NULL;\n    \n    // TODO 1: Create test container configuration with PID namespace enabled\n    // TODO 2: Create container using create_test_container()\n    // TODO 3: Register cleanup for container process termination\n    // TODO 4: Inside container: read PID from /proc/self/stat\n    // TODO 5: From host: read actual PID of container process\n    // TODO 6: Verify container sees PID 1, host sees different PID\n    // TODO 7: Test process tree isolation by checking /proc entries\n    // TODO 8: Verify zombie reaping by creating child processes\n    \n    execute_test_cleanup(&cleanup_list);\n    return 1; // Placeholder - learner implements actual verification\n}\n\n// Test mount namespace isolation by verifying filesystem separation\nint test_mount_namespace_isolation() {\n    test_cleanup_item_t* cleanup_list = NULL;\n    char test_file_path[256];\n    \n    // TODO 1: Create test root filesystem with basic directory structure\n    // TODO 2: Create container with mount namespace and test rootfs\n    // TODO 3: Inside container: create test file in root directory\n    // TODO 4: From host: verify test file not visible in host filesystem\n    // TODO 5: Inside container: mount /proc and verify it works independently\n    // TODO 6: From host: verify host /proc unchanged by container operations\n    // TODO 7: Test device node creation inside container\n    // TODO 8: Verify container device nodes don't appear on host\n    \n    execute_test_cleanup(&cleanup_list);\n    return 1; // Placeholder - learner implements filesystem verification\n}\n\n// Test network namespace isolation and connectivity\nint test_network_namespace_isolation() {\n    test_cleanup_item_t* cleanup_list = NULL;\n    \n    // TODO 1: Create container with network namespace enabled\n    // TODO 2: Set up veth pair connecting container to host bridge\n    // TODO 3: Inside container: verify only veth and loopback interfaces visible\n    // TODO 4: Test container-to-host connectivity through veth pair\n    // TODO 5: Create second container and test inter-container communication\n    // TODO 6: Verify containers cannot access each other's network namespaces\n    // TODO 7: Test external connectivity through host NAT\n    // TODO 8: Cleanup veth pairs and network namespaces\n    \n    execute_test_cleanup(&cleanup_list);\n    return 1; // Placeholder - learner implements network verification\n}\n\n// Test cgroup resource limit enforcement\nint test_cgroup_resource_limits() {\n    test_cleanup_item_t* cleanup_list = NULL;\n    \n    // TODO 1: Create container with memory limit (64MB) and CPU limit (50%)\n    // TODO 2: Start memory allocation test program inside container\n    // TODO 3: Monitor memory usage through cgroup memory.usage_in_bytes file\n    // TODO 4: Verify OOM killer activates when limit exceeded\n    // TODO 5: Start CPU-intensive test program inside container\n    // TODO 6: Monitor CPU usage over multiple scheduling periods (10+ seconds)\n    // TODO 7: Verify average CPU usage converges to configured 50% limit\n    // TODO 8: Test process limit by running fork bomb with low process limit\n    \n    execute_test_cleanup(&cleanup_list);\n    return 1; // Placeholder - learner implements resource limit verification\n}\n```\n\n**Language-Specific Testing Hints:**\n\n- Use `nsenter` command-line tool for manual verification of namespace isolation during development\n- Monitor `/proc/PID/ns/` directory to see namespace assignments for debugging\n- Read cgroup files in `/sys/fs/cgroup/` to verify resource usage and limits\n- Use `ip netns exec` to run commands inside network namespaces for verification\n- Check `/proc/PID/status` for memory usage details when testing memory limits\n- Monitor `/sys/fs/cgroup/cpuacct/*/cpuacct.stat` for CPU usage statistics over time\n\n**Milestone Checkpoint Commands:**\n\nAfter implementing each milestone, learners can verify their implementation using these specific commands and expected outputs:\n\n**Milestone 1 Checkpoint:**\n```bash\n# Build and run PID namespace test\nmake test_pid_namespace\n./test_pid_namespace\n\n# Expected output:\n# PASS: Container init process reports PID 1\n# PASS: Host sees different PID for container process  \n# PASS: Process tree isolation verified\n# PASS: Zombie reaping test completed successfully\n```\n\n**Milestone 2 Checkpoint:**\n```bash\n# Build and run mount namespace test\nmake test_mount_namespace\n./test_mount_namespace\n\n# Expected output:\n# PASS: Container filesystem isolated from host\n# PASS: /proc filesystem mounted independently\n# PASS: Device node creation contained within namespace\n# PASS: Mount propagation properly configured\n```\n\n**Milestone 3 Checkpoint:**\n```bash\n# Build and run network namespace test (requires root privileges)\nsudo make test_network_namespace\nsudo ./test_network_namespace\n\n# Expected output:\n# PASS: Network namespace created successfully\n# PASS: Veth pair configured and assigned\n# PASS: Container-to-host connectivity verified\n# PASS: Network interface isolation confirmed\n```\n\n**Milestone 4 Checkpoint:**\n```bash\n# Build and run cgroup resource limit test (requires root privileges)\nsudo make test_cgroups\nsudo ./test_cgroups\n\n# Expected output:\n# PASS: Memory limit enforced - OOM killer activated at 64MB\n# PASS: CPU limit enforced - average usage 49.8% over 10 seconds\n# PASS: Process limit enforced - fork() failed after 10 processes\n# PASS: Cgroup cleanup completed successfully\n```\n\n**Integration Test Checkpoint:**\n```bash\n# Run complete integration test suite\nsudo make test_integration\nsudo ./test_integration\n\n# Expected output:\n# PASS: Multi-container isolation test completed\n# PASS: Resource competition test - all limits respected\n# PASS: Network and filesystem isolation maintained\n# PASS: System cleanup verification - no resource leaks detected\n# \n# Integration test summary: 24/24 tests passed\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** This section applies to all milestones (1-4), providing debugging strategies for PID namespace isolation issues, mount namespace filesystem problems, network namespace connectivity failures, and cgroups resource limit enforcement problems.\n\nBuilding a container runtime involves coordinating multiple complex Linux kernel mechanisms, each with their own failure modes and subtle interactions. The debugging process requires understanding both the symptoms visible at the application level and the underlying kernel state that drives those behaviors. This section provides a systematic approach to diagnosing and fixing the most common issues encountered when implementing namespace isolation and resource control.\n\n**Mental Model: Detective Investigation**: Think of debugging containers like being a detective investigating a crime scene. The \"crime\" is your container not working as expected, and you need to gather evidence from multiple sources - the process tree, filesystem mounts, network interfaces, and cgroup statistics. Each piece of evidence points to potential causes, and by correlating information from different sources, you can identify the root cause and determine the fix. Just as a detective follows a methodical process of evidence collection and analysis, container debugging requires systematic inspection of kernel state through various interfaces.\n\nThe debugging process follows a consistent pattern: identify the symptom, gather evidence from kernel interfaces, correlate findings to isolate the root cause, and apply targeted fixes. The key insight is that container problems often manifest as secondary symptoms - a networking issue might actually be caused by namespace creation timing, or a filesystem problem might stem from incorrect mount propagation settings.\n\n![Container Debugging Inspection Points](./diagrams/debugging-inspection-points.svg)\n\n### Namespace Issues\n\nNamespace-related problems are among the most challenging to debug because they involve invisible boundaries that separate processes from system resources. The fundamental difficulty is that namespace isolation creates different views of the same underlying system, making it essential to understand which namespace context you're examining when gathering diagnostic information.\n\n#### PID Namespace Debugging\n\nPID namespace issues typically manifest as processes appearing with incorrect process IDs, zombie processes accumulating without being reaped, or signals not reaching their intended targets. These problems often stem from fundamental misunderstandings about how PID translation works across namespace boundaries.\n\n**Symptom Analysis and Diagnosis**:\n\n| Symptom | Likely Cause | Diagnostic Steps | Resolution |\n|---------|--------------|------------------|------------|\n| Container process shows wrong PID from inside | PID namespace not created properly | Check `/proc/self/ns/pid` in container vs host | Verify `CLONE_NEWPID` flag in `safe_clone()` |\n| Child process not visible as PID 1 | Process started before namespace creation | Use `lsns -t pid` to verify namespace membership | Ensure clone() creates namespace before exec |\n| Zombie processes accumulate | Init process not reaping children | Check `/proc/1/stat` for zombie count in container | Implement `SIGCHLD` handler in `container_init_process()` |\n| Signals fail to reach container processes | Wrong PID used for kill() | Compare PIDs inside vs outside namespace | Use namespace-local PIDs for internal signaling |\n| Container startup hangs | Clone() failed but error not propagated | Check parent-child pipe communication | Implement proper error reporting in child process |\n\nThe most common PID namespace issue occurs when developers assume that process IDs remain consistent across namespace boundaries. In reality, the same process has different PIDs depending on which namespace context observes it. The container init process appears as PID 1 within its namespace but has a different PID when viewed from the host namespace.\n\n> **Key Insight: PID Translation Boundaries**: Every system call that takes a PID as an argument operates within the caller's PID namespace context. This means `kill(pid, signal)` called from the host uses host PIDs, while the same call from inside the container uses container PIDs. Cross-namespace process management requires careful tracking of which PID applies in which context.\n\n**Debugging PID Namespace Creation**:\n\nThe `create_pid_namespace()` function creates isolation through the clone() system call, but several subtle issues can prevent proper namespace establishment:\n\n1. **Stack Direction Problems**: The clone() system call requires a properly allocated stack that grows in the correct direction. On most architectures, stacks grow downward, so the stack pointer must point to the high end of the allocated memory region. Incorrect stack setup causes immediate segmentation faults that may be difficult to trace.\n\n2. **Clone Flag Ordering**: The combination of namespace flags in `CONTAINER_NS_FLAGS` must include `CLONE_NEWPID`, but the order and combination with other flags can affect behavior. Some flag combinations are incompatible or require specific kernel versions.\n\n3. **Capability Requirements**: Creating PID namespaces requires the `CAP_SYS_ADMIN` capability. Without proper privileges, clone() fails with `EPERM`, but this error often gets lost in complex error handling paths.\n\n**PID 1 Responsibilities and Zombie Reaping**:\n\nWithin a PID namespace, the first process (PID 1) inherits special responsibilities from the kernel. Unlike regular processes, PID 1 receives orphaned processes as children and must reap their exit status to prevent zombie accumulation. Failure to implement proper zombie reaping leads to resource exhaustion and eventual process creation failures.\n\nThe `setup_init_signals()` function must establish a `SIGCHLD` handler that calls `waitpid()` in a loop to collect all available child exit statuses. A common mistake is handling only one child per signal delivery, since multiple children can terminate between signal deliveries, causing zombies to accumulate.\n\n⚠️ **Pitfall: Incomplete Zombie Reaping**\nMany developers implement zombie reaping by calling `waitpid()` once per `SIGCHLD` signal. However, signals are not queued - if three children terminate while the signal handler is running, only one `SIGCHLD` is delivered. The correct approach is to loop with `waitpid(WNOHANG)` until it returns zero, ensuring all available zombies are reaped.\n\n#### Mount Namespace Debugging\n\nMount namespace problems typically appear as containers seeing incorrect filesystem contents, failing to isolate mounts from the host, or encountering permission errors when accessing expected directories. These issues often trace back to mount propagation settings, pivot_root requirements, or timing problems in filesystem setup.\n\n**Mount Namespace Diagnostic Approach**:\n\n| Issue Category | Diagnostic Commands | Key Files to Check | Common Problems |\n|----------------|-------------------|-------------------|-----------------|\n| Namespace Creation | `lsns -t mnt`, `/proc/PID/ns/mnt` | `/proc/PID/mountinfo` | Mount namespace not created, shared with parent |\n| Mount Propagation | `findmnt -D` | `/proc/self/mountinfo` | Shared propagation leaking to host |\n| Pivot Root | `ls -la /`, `mountpoint /` | `/proc/mounts` | Old root not unmounted, pivot_root requirements |\n| Essential Filesystems | `ls /proc /sys /dev` | `/proc/filesystems` | Missing /proc, /sys, incorrect permissions |\n\n**Mount Propagation Issues**:\n\nMount propagation determines how mount and unmount events propagate between namespaces. The default shared propagation causes container mounts to appear on the host, breaking isolation. The `setup_mount_propagation()` function must set mount points to private propagation before performing container-specific mounts.\n\nThe sequence matters critically: propagation must be set to private before creating any bind mounts or mounting essential filesystems. If propagation remains shared, every mount operation inside the container becomes visible to the host system, potentially causing conflicts and security issues.\n\n**Pivot Root Complexities**:\n\nThe `pivot_to_container_root()` function implements one of the most error-prone operations in container setup. Pivot root has specific requirements that frequently cause failures:\n\n1. **Filesystem Requirements**: Both the new root and old root must be mount points on different filesystems. If they're on the same filesystem, pivot_root fails with `EINVAL`.\n\n2. **Directory Structure**: The old root directory must exist within the new root filesystem before calling pivot_root. This creates a chicken-and-egg problem that requires careful ordering of mount operations.\n\n3. **Process Working Directory**: All processes must have working directories within the new root after pivot_root completes. Processes with working directories in the old root cause pivot_root to fail.\n\n> **Decision: Pivot Root vs Chroot**\n> - **Context**: Need to change container's root filesystem while maintaining proper isolation\n> - **Options Considered**: chroot(), pivot_root(), bind mount with chroot\n> - **Decision**: Use pivot_root() for root filesystem switching\n> - **Rationale**: Unlike chroot(), pivot_root() actually changes the filesystem root at the kernel level and works properly with mount namespaces. Chroot is a per-process view change that can be escaped, while pivot_root provides genuine filesystem root isolation.\n> - **Consequences**: More complex setup procedure but stronger security guarantees and proper integration with mount namespaces.\n\n#### Network Namespace Debugging\n\nNetwork namespace problems manifest as containers having no network connectivity, failing to reach external hosts, or being unable to communicate with other containers. These issues typically stem from veth pair configuration problems, incorrect bridge setup, or missing routing configuration.\n\n**Network Namespace Diagnostic Strategy**:\n\nThe key to diagnosing network namespace issues is understanding that each namespace has its own complete network stack, including interfaces, routing tables, and netfilter rules. Problems often occur when configuration changes are applied in the wrong namespace context.\n\n| Network Component | Host Diagnostic | Container Diagnostic | Common Issues |\n|-------------------|----------------|---------------------|---------------|\n| Namespace Creation | `lsns -t net`, `ip netns list` | `/proc/self/ns/net` | Namespace not created, process in wrong namespace |\n| Interface Configuration | `ip link show`, `brctl show` | `ip addr show`, `ip route show` | Veth pair not created, interfaces in wrong namespace |\n| Routing | `ip route show`, `iptables -t nat -L` | `ip route show`, `ping 8.8.8.8` | Missing default route, no NAT rules |\n| Bridge Connectivity | `bridge link show`, `tcpdump -i bridge` | `ping container_ip` | Interface not attached to bridge, bridge not forwarding |\n\n**Veth Pair Configuration Problems**:\n\nThe `create_veth_pair()` and `assign_veth_to_namespace()` functions must coordinate to create a virtual ethernet pair with one end in the host and one end in the container namespace. Common failures include:\n\n1. **Interface Naming Conflicts**: If the chosen interface names already exist, veth creation fails. The system doesn't automatically generate unique names, so the container runtime must implement its own naming strategy.\n\n2. **Namespace Assignment Timing**: The veth pair must be created before the target namespace can receive an interface. If the network namespace doesn't exist when `assign_veth_to_namespace()` runs, the operation fails silently in some kernel versions.\n\n3. **Interface State Management**: Both ends of the veth pair start in the DOWN state. The container end must be brought UP after IP configuration, while the host end must be brought UP before bridge attachment.\n\n**Bridge and NAT Configuration**:\n\nContainer networking requires coordinating bridge configuration on the host with routing configuration inside containers. The `attach_to_bridge()` function connects the host veth end to a bridge, while `setup_default_route()` configures routing inside the container namespace.\n\nA frequent mistake is configuring NAT rules that don't match the bridge subnet or container IP assignments. The iptables NAT rules must be established before containers start, and they must correctly translate between the bridge subnet and external networks.\n\n⚠️ **Pitfall: Namespace Context for Network Commands**\nNetwork configuration commands like `ip addr add` and `ip route add` operate within the caller's network namespace. When configuring container networking from the host process, you must use `nsenter` or equivalent mechanisms to execute commands within the target namespace. Commands run in the wrong namespace context silently fail or configure the wrong network stack.\n\n### Cgroups Issues\n\nCgroups problems typically manifest as resource limits not being enforced, containers consuming more resources than allocated, or the system becoming unresponsive due to resource exhaustion. These issues often stem from incorrect cgroup hierarchy setup, controller availability problems, or timing issues in process assignment.\n\n#### Cgroups Hierarchy and Controller Issues\n\nThe Linux cgroups system has evolved through multiple versions, with cgroups v1 and cgroups v2 having different interfaces and capabilities. The `detect_cgroup_version()` function must correctly identify the system configuration, but many debugging issues arise from version mismatches or missing controller support.\n\n**Cgroups Diagnostic Framework**:\n\n| Problem Category | Diagnostic Commands | Key Files | Investigation Focus |\n|------------------|-------------------|-----------|-------------------|\n| Controller Availability | `cat /proc/cgroups`, `mount \\| grep cgroup` | `/sys/fs/cgroup/`, `/proc/cgroups` | Which controllers are compiled and enabled |\n| Hierarchy Setup | `systemd-cgls`, `find /sys/fs/cgroup -name \"container-*\"` | `/sys/fs/cgroup/*/container-*` | Cgroup directories exist, proper permissions |\n| Process Assignment | `cat /sys/fs/cgroup/*/container-*/cgroup.procs` | `cgroup.procs`, `tasks` | PIDs correctly assigned to cgroup |\n| Limit Enforcement | `cat /sys/fs/cgroup/memory/container-*/memory.*` | Controller-specific stat files | Current usage vs configured limits |\n\n**Controller Availability and Version Differences**:\n\nThe `verify_controller_available()` function checks whether specific cgroup controllers are enabled, but this check must account for both compile-time and runtime configuration. Controllers may be compiled into the kernel but disabled via kernel command-line parameters, or they may be available but not mounted in the expected location.\n\nCgroups v1 and v2 have fundamentally different filesystem layouts and control interfaces. Version 1 uses separate hierarchies for each controller (memory, CPU, etc.), while version 2 uses a unified hierarchy where all controllers share the same directory structure. The container runtime must adapt its file paths and control interfaces based on the detected version.\n\n**Memory Controller Configuration and OOM Behavior**:\n\nThe `set_memory_limit()` function configures memory limits through the memory controller, but several subtle issues can prevent proper enforcement:\n\n1. **Limit Granularity**: Memory limits are enforced in page-sized chunks, so very small limits may not behave as expected. The kernel rounds limits to page boundaries, potentially allowing slightly more memory than requested.\n\n2. **OOM Killer Behavior**: When a process in a memory-limited cgroup exceeds its allocation, the kernel's OOM killer terminates processes within that cgroup. However, the selection algorithm may not match application expectations, potentially killing important processes while leaving memory-hungry processes running.\n\n3. **Memory Accounting Scope**: The memory controller tracks different types of memory usage (anonymous pages, file cache, kernel memory) and applies limits differently to each category. Understanding which memory types count against the limit is crucial for predicting OOM behavior.\n\n> **Decision: Memory Limit Enforcement Strategy**\n> - **Context**: Need to prevent containers from consuming excessive memory while allowing reasonable memory usage patterns\n> - **Options Considered**: Hard limits with immediate OOM, soft limits with pressure notifications, hierarchical limits\n> - **Decision**: Use hard limits with OOM killer enforcement for simplicity\n> - **Rationale**: Hard limits provide predictable behavior and clear resource boundaries. While OOM killer termination is harsh, it prevents system-wide memory exhaustion and provides clear feedback about resource requirements.\n> - **Consequences**: Applications must be designed to handle sudden termination, but system stability is preserved even with poorly behaved containers.\n\n**CPU Controller Quota and Period Configuration**:\n\nThe `set_cpu_limit()` function implements CPU limits through quota and period settings, but this mechanism has several non-obvious behaviors that can cause debugging confusion:\n\n1. **Quota vs Period Relationship**: CPU limits are expressed as a quota (microseconds of CPU time) within a period (typically 100,000 microseconds). A 50% CPU limit means 50,000 microseconds of CPU time per 100,000-microsecond period, not necessarily 50% of one CPU core.\n\n2. **Throttling vs Starvation**: When a process group exceeds its CPU quota, the kernel throttles it by preventing scheduling until the next period begins. This creates bursty behavior where processes alternate between full-speed execution and complete blocking.\n\n3. **Multi-core Behavior**: CPU quotas apply to the entire cgroup, not per CPU core. A cgroup with a 150% CPU limit can use 1.5 cores worth of CPU time, distributed across available cores as the scheduler determines.\n\n**Process Controller and Fork Bomb Prevention**:\n\nThe `set_process_limit()` function prevents fork bombs and resource exhaustion by limiting the number of processes and threads within a cgroup. However, the process controller has some subtle behaviors that affect debugging:\n\n1. **Task vs Process Counting**: The process controller can limit either processes (traditional Unix processes) or tasks (which includes threads). The choice affects how multi-threaded applications behave when approaching limits.\n\n2. **Limit Enforcement Timing**: Process creation limits are enforced at fork() time, not exec() time. This means that processes can fork and then fail to exec, leaving zombie processes that count against the limit but consume no other resources.\n\n⚠️ **Pitfall: Cgroups Cleanup Ordering**\nWhen cleaning up container resources, cgroups must be removed after all processes within them have terminated. Attempting to remove a cgroup while it still contains processes fails with `EBUSY`. The correct cleanup sequence is: terminate processes, wait for exit, remove process from cgroup, then remove cgroup directory. Many container implementations fail because they don't wait for process termination before cgroup cleanup.\n\n#### Resource Limit Enforcement Debugging\n\nResource limit debugging requires understanding both the configured limits and the actual enforcement mechanisms. The kernel provides extensive statistics through cgroup filesystem interfaces, but interpreting these statistics correctly requires knowledge of the underlying enforcement algorithms.\n\n**Memory Limit Enforcement Analysis**:\n\nWhen containers appear to ignore memory limits, the issue usually lies in incorrect limit configuration or misunderstanding of memory accounting. The `read_cgroup_stat()` function can retrieve current usage statistics, but effective debugging requires understanding what memory usage is being measured.\n\nKey memory statistics for debugging include:\n\n- `memory.usage_in_bytes`: Total memory charged to the cgroup, including file cache\n- `memory.max_usage_in_bytes`: Peak memory usage since cgroup creation\n- `memory.failcnt`: Number of times memory allocation failed due to limit enforcement\n- `memory.oom_control`: OOM killer status and configuration\n\nThe relationship between these statistics reveals whether limits are being enforced correctly. High failure counts with usage near the limit indicate working enforcement, while usage exceeding limits suggests configuration problems.\n\n**CPU Throttling Detection and Analysis**:\n\nCPU limits work through a throttling mechanism that blocks process execution when quota is exhausted. The `check_cpu_throttling()` function examines CPU controller statistics to determine whether throttling is occurring and how severely it affects performance.\n\nCritical CPU statistics include:\n\n- `cpu.stat`: Contains `nr_periods`, `nr_throttled`, and `throttled_time` counters\n- `cpuacct.usage`: Total CPU time consumed by the cgroup\n- `cpu.cfs_quota_us` and `cpu.cfs_period_us`: Current quota configuration\n\nThrottling analysis involves calculating the percentage of periods where throttling occurred and the total time lost to throttling. High throttling percentages indicate that processes are consistently hitting CPU limits, while sporadic throttling suggests bursty workloads that occasionally exceed quotas.\n\n### Debugging Tools and Techniques\n\nEffective container debugging requires mastering a set of specialized tools that provide visibility into kernel namespace and cgroup state. These tools operate at different levels of abstraction, from high-level namespace listings to detailed kernel state inspection.\n\n#### Essential Debugging Commands\n\n**Namespace Inspection Tools**:\n\nThe `lsns` command provides the primary interface for examining namespace relationships and membership. It shows which processes belong to which namespaces and can reveal namespace isolation failures:\n\n| Command | Purpose | Key Information | Usage Examples |\n|---------|---------|-----------------|----------------|\n| `lsns -t pid` | List PID namespaces | Namespace IDs, process counts | Verify container has separate PID namespace |\n| `lsns -t mnt` | List mount namespaces | Mount namespace relationships | Check filesystem isolation |\n| `lsns -t net` | List network namespaces | Network isolation boundaries | Verify network separation |\n| `lsns -p PID` | Show namespaces for process | All namespace memberships | Debug multi-namespace issues |\n\nThe `/proc/PID/ns/` directory contains namespace file descriptors that can be used for advanced debugging. These files support comparison operations that reveal namespace relationships:\n\n```bash\n# Compare namespaces between processes\nls -la /proc/1/ns/    # Host init process namespaces\nls -la /proc/PID/ns/  # Container process namespaces\n```\n\n**Process Tree and PID Analysis**:\n\nUnderstanding process relationships across PID namespace boundaries requires combining multiple information sources. The `ps` command shows different views depending on the namespace context from which it's run:\n\n| Context | Command | Information Revealed | Debugging Value |\n|---------|---------|---------------------|-----------------|\n| Host | `ps aux --forest` | Complete process tree with host PIDs | Overall system state |\n| Host | `ps -eo pid,pidns,cmd` | PID namespace membership | Which processes are isolated |\n| Container | `ps aux` | Container-local process tree | Container internal view |\n| Container | `ps -eo pid,ppid,cmd` | Parent-child relationships | Process hierarchy validation |\n\n**Mount and Filesystem Debugging**:\n\nMount namespace debugging relies heavily on `/proc/mounts` and `/proc/mountinfo`, which provide different levels of detail about filesystem mounts:\n\n- `/proc/mounts`: Shows active mounts with filesystem types and options\n- `/proc/mountinfo`: Includes mount relationships, propagation types, and namespace information\n- `/proc/PID/mountinfo`: Mount information from specific process's mount namespace\n\nThe `findmnt` command provides a user-friendly interface to this information:\n\n| Command | Output Format | Debugging Focus |\n|---------|---------------|-----------------|\n| `findmnt -D` | Tree with propagation | Mount relationships and propagation |\n| `findmnt -J` | JSON format | Programmatic analysis |\n| `findmnt /path` | Specific mount point | Verify mount configuration |\n\n**Network Namespace Inspection**:\n\nNetwork debugging requires examining network state from both host and container perspectives. The `ip netns` command provides namespace management capabilities, while standard network tools work within namespace contexts:\n\n| Tool Category | Host Commands | Container Context Commands | Information Gathered |\n|---------------|---------------|---------------------------|----------------------|\n| Interface Status | `ip link show`, `brctl show` | `ip addr show`, `ip link show` | Interface configuration and state |\n| Routing | `ip route show table all` | `ip route show` | Routing table configuration |\n| Connectivity | `ping`, `tcpdump -i bridge` | `ping`, `traceroute` | Network reachability |\n| Namespace Operations | `ip netns exec NS command` | Direct execution | Cross-namespace operations |\n\n#### Advanced Debugging Techniques\n\n**Namespace Entry and Context Switching**:\n\nThe `nsenter` command allows executing commands within specific namespace contexts, enabling detailed inspection of container state from the host system:\n\n| nsenter Options | Target Namespace | Common Usage | Debugging Purpose |\n|----------------|------------------|--------------|-------------------|\n| `-t PID -p` | PID namespace | Process inspection | Verify PID isolation |\n| `-t PID -m` | Mount namespace | Filesystem inspection | Check mount configuration |\n| `-t PID -n` | Network namespace | Network inspection | Debug connectivity issues |\n| `-t PID -a` | All namespaces | Complete container context | Comprehensive debugging |\n\n**Systematic State Inspection**:\n\nContainer debugging follows a systematic progression from high-level symptoms to specific kernel state. The recommended approach is:\n\n1. **Process Identification**: Identify the container process PID and verify namespace membership\n2. **Namespace Verification**: Confirm that expected namespaces exist and contain the correct processes\n3. **Resource State**: Check cgroup assignments and current resource usage\n4. **Configuration Validation**: Verify that kernel configuration matches intended container settings\n5. **Dynamic Behavior**: Monitor resource consumption and limit enforcement during container execution\n\n**Error Context Correlation**:\n\nThe `container_error_context_t` structure provides systematic error reporting, but effective debugging requires correlating error reports with kernel state. When container operations fail, the debugging process should capture:\n\n- System call error codes and their interpretation\n- Kernel log messages related to namespace or cgroup operations\n- Current resource usage at the time of failure\n- Process state and namespace membership\n\n> **Key Debugging Insight: State vs Configuration Mismatch**: Most container bugs arise from mismatches between intended configuration and actual kernel state. The debugging process must verify that kernel state matches configuration at each step: namespace creation, process assignment, resource limit application, and cleanup execution. Tools like `lsns`, `/proc` filesystem inspection, and `nsenter` reveal actual kernel state, while configuration dumps show intended state.\n\n**Performance and Resource Monitoring**:\n\nLong-term debugging often requires monitoring resource usage patterns and limit enforcement behavior. Key monitoring points include:\n\n- Memory pressure indicators in `memory.pressure_level`\n- CPU throttling frequency in `cpu.stat`\n- Process creation failure rates in fork() system call errors\n- Network interface statistics for connectivity debugging\n\nThese metrics reveal whether containers are operating within their intended resource boundaries and whether limit enforcement is functioning correctly.\n\n⚠️ **Pitfall: Namespace Context Confusion**\nThe most common debugging mistake is running diagnostic commands in the wrong namespace context. Network commands run on the host show host networking state, not container networking state. Always verify which namespace context you're examining, and use `nsenter` or equivalent tools to switch contexts when needed. Symptoms observed in the wrong context lead to incorrect diagnoses and ineffective fixes.\n\n### Implementation Guidance\n\nThis section provides practical debugging infrastructure and tools for systematically diagnosing container implementation issues.\n\n#### Technology Recommendations\n\n| Debugging Category | Simple Tools | Advanced Tools |\n|-------------------|--------------|----------------|\n| Namespace Inspection | `lsns`, `/proc/PID/ns/*` | Custom namespace walker with detailed state |\n| Process Monitoring | `ps aux --forest`, `pstree` | Process state monitor with namespace awareness |\n| Mount Debugging | `findmnt`, `/proc/mounts` | Mount event tracer with propagation analysis |\n| Network Analysis | `ip addr/route`, `ping` | Network namespace topology mapper |\n| Cgroups Inspection | `systemd-cgls`, manual file reading | Cgroups statistics aggregator and limit monitor |\n| System Call Tracing | `strace -f` | `perf trace` with container context |\n\n#### Debugging Infrastructure Code\n\n**Complete Namespace State Inspector**:\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <string.h>\n\n// Complete namespace inspection utility\ntypedef struct namespace_info {\n    char ns_type[16];\n    char ns_path[256];\n    ino_t ns_inode;\n    int accessible;\n} namespace_info_t;\n\n// Ready-to-use namespace inspector - no implementation needed\nint inspect_process_namespaces(pid_t pid, namespace_info_t *ns_info, int max_ns) {\n    const char *ns_types[] = {\"pid\", \"mnt\", \"net\", \"uts\", \"ipc\", \"user\", NULL};\n    struct stat st;\n    char ns_path[512];\n    int ns_count = 0;\n    \n    for (int i = 0; ns_types[i] && ns_count < max_ns; i++) {\n        snprintf(ns_path, sizeof(ns_path), \"/proc/%d/ns/%s\", pid, ns_types[i]);\n        \n        strncpy(ns_info[ns_count].ns_type, ns_types[i], sizeof(ns_info[ns_count].ns_type) - 1);\n        strncpy(ns_info[ns_count].ns_path, ns_path, sizeof(ns_info[ns_count].ns_path) - 1);\n        \n        if (stat(ns_path, &st) == 0) {\n            ns_info[ns_count].ns_inode = st.st_ino;\n            ns_info[ns_count].accessible = 1;\n        } else {\n            ns_info[ns_count].ns_inode = 0;\n            ns_info[ns_count].accessible = 0;\n        }\n        ns_count++;\n    }\n    \n    return ns_count;\n}\n\n// Complete cgroup state reader\nint read_cgroup_stats(const char *cgroup_path, const char *controller, \n                     char *stats_buffer, size_t buffer_size) {\n    char stat_path[512];\n    FILE *stat_file;\n    \n    // Support both cgroups v1 and v2 paths\n    if (strstr(cgroup_path, \"unified\")) {\n        snprintf(stat_path, sizeof(stat_path), \"%s/%s.stat\", cgroup_path, controller);\n    } else {\n        snprintf(stat_path, sizeof(stat_path), \"%s/%s.stat\", cgroup_path, controller);\n    }\n    \n    stat_file = fopen(stat_path, \"r\");\n    if (!stat_file) {\n        return -1;\n    }\n    \n    size_t bytes_read = fread(stats_buffer, 1, buffer_size - 1, stat_file);\n    stats_buffer[bytes_read] = '\\0';\n    fclose(stat_file);\n    \n    return bytes_read;\n}\n\n// Network namespace connectivity tester\nint test_network_connectivity(pid_t container_pid, const char *target_ip) {\n    char nsenter_cmd[512];\n    int result;\n    \n    // Use nsenter to run ping in container's network namespace\n    snprintf(nsenter_cmd, sizeof(nsenter_cmd), \n            \"nsenter -t %d -n ping -c 1 -W 1 %s >/dev/null 2>&1\", \n            container_pid, target_ip);\n    \n    result = system(nsenter_cmd);\n    return (result == 0) ? 1 : 0;  // Return 1 for success, 0 for failure\n}\n```\n\n#### Core Debugging Function Skeletons\n\n**Container State Diagnostic Function**:\n\n```c\n// diagnose_container_state - Comprehensive container state analysis\n// This function should be called when container behavior is unexpected\nint diagnose_container_state(container_instance_t *container, \n                           container_config_t *config,\n                           char *diagnosis_buffer, \n                           size_t buffer_size) {\n    // TODO 1: Verify process is still running using kill(container->child_pid, 0)\n    // TODO 2: Check all namespace file descriptors in container->namespace_fds array\n    //         - Use fstat() to verify each fd is still valid\n    //         - Compare namespace inodes between parent and child\n    // TODO 3: Inspect cgroup membership by reading /proc/PID/cgroup\n    //         - Verify process is assigned to expected cgroup path\n    //         - Check that cgroup directory still exists\n    // TODO 4: Read current resource usage from cgroup stat files\n    //         - Memory usage vs limit in memory.usage_in_bytes\n    //         - CPU throttling stats from cpu.stat\n    //         - Process count vs limit\n    // TODO 5: Test namespace isolation by comparing /proc/PID/ns/* inodes\n    //         - PID namespace: different inode = isolated\n    //         - Mount namespace: check /proc/PID/mountinfo differences  \n    //         - Network namespace: check interface lists\n    // TODO 6: Compile diagnosis into human-readable report in diagnosis_buffer\n    //         - Include specific recommendations for each detected issue\n    // Hint: Use inspect_process_namespaces() and read_cgroup_stats() helpers above\n}\n```\n\n**Resource Limit Enforcement Checker**:\n\n```c\n// verify_resource_enforcement - Check if cgroup limits are working\n// Call this when containers appear to ignore resource limits\nint verify_resource_enforcement(const char *cgroup_path, \n                               container_config_t *config,\n                               enforcement_report_t *report) {\n    // TODO 1: Read current memory usage from memory.usage_in_bytes\n    //         - Compare with config->memory_limit_bytes\n    //         - Check memory.failcnt for limit enforcement events\n    // TODO 2: Read CPU throttling statistics from cpu.stat\n    //         - Parse nr_periods, nr_throttled, throttled_time\n    //         - Calculate throttling percentage\n    // TODO 3: Check process count against max_processes limit\n    //         - Count lines in cgroup.procs file\n    //         - Verify fork() failures when limit approached\n    // TODO 4: Test limit enforcement by attempting to exceed limits\n    //         - Try allocating memory beyond limit (should trigger OOM)\n    //         - Create processes beyond process limit (should fail)\n    // TODO 5: Fill enforcement_report_t with findings\n    //         - Set enforcement_working flag based on test results\n    //         - Include specific failure details and recommendations\n    // Hint: Use read_cgroup_stats() to get current usage statistics\n}\n```\n\n#### Language-Specific Debugging Hints\n\n**C-Specific Debugging Considerations**:\n\n- Use `strace -f -p PID` to trace system calls for namespace creation issues\n- Check `errno` immediately after failed system calls - container code paths often overwrite error codes\n- Use `valgrind --trace-children=yes` to catch memory errors in forked container processes\n- Compile with `-g -O0` for debugging to ensure accurate line number information\n- Use `gdb --args program` and `set follow-fork-mode child` to debug container child processes\n\n**File Organization for Debugging**:\n\n```\nproject-root/\n  src/container/\n    container_debug.c        ← debugging utilities (implement above skeletons)\n    container_debug.h        ← debugging function declarations\n  debug/\n    namespace_inspector.c    ← standalone namespace inspection tool\n    cgroup_monitor.c         ← resource usage monitoring tool\n    connectivity_tester.c    ← network connectivity verification\n  scripts/\n    debug_container.sh       ← wrapper script for common debugging workflows\n    collect_debug_info.sh    ← automated debug info collection\n```\n\n#### Milestone Debugging Checkpoints\n\n**After Milestone 1 (PID Namespace)**:\n- Run `ps aux` from inside container - should show only container processes with PID 1 as init\n- Check `lsns -t pid` - container should have different PID namespace inode than host\n- Verify zombie reaping by creating short-lived child processes and confirming they don't accumulate\n- Test signal handling by sending signals to container init process\n\n**After Milestone 2 (Mount Namespace)**:\n- Run `findmnt` from container and host - should show different mount trees\n- Verify `/proc` and `/sys` are mounted and functional in container\n- Check that host filesystem changes don't appear in container\n- Confirm pivot_root worked by checking that container root directory is `/`\n\n**After Milestone 3 (Network Namespace)**:\n- Run `ip addr show` in container - should show container-specific interfaces\n- Test connectivity with `ping` to external addresses\n- Verify inter-container communication through bridge networking\n- Check that container cannot see host network interfaces\n\n**After Milestone 4 (Cgroups)**:\n- Trigger memory limit by allocating memory beyond limit - should cause OOM kill\n- Generate CPU load and verify throttling occurs when limit exceeded\n- Create many processes to test process limit enforcement\n- Monitor resource usage with `systemd-cgls` and cgroup stat files\n\n#### Common Debugging Scenarios\n\n**Debugging Scenario Reference**:\n\n| Symptom | Investigation Steps | Expected Findings | Resolution |\n|---------|-------------------|------------------|------------|\n| Container sees host processes | Check PID namespace creation, verify lsns output | Different PID namespace inode | Fix clone() flags or namespace creation |\n| Container has no network | Check network namespace, veth pair, routing | Isolated network namespace with configured interfaces | Fix veth creation or IP configuration |\n| Resource limits ignored | Check cgroup assignment, controller availability | Process in correct cgroup with active controllers | Fix cgroup creation or process assignment |\n| Container startup hangs | Check parent-child synchronization, error propagation | Clear error messages or successful startup sequence | Fix synchronization pipes or error handling |\n| Filesystem isolation broken | Check mount namespace, pivot_root, mount propagation | Separate mount namespace with private propagation | Fix mount namespace creation or propagation settings |\n\nThis comprehensive debugging framework provides systematic approaches to diagnosing and fixing the most common container implementation issues across all four milestone areas.\n\n\n## Future Extensions\n\n> **Milestone(s):** This section provides a roadmap beyond the basic container implementation from milestones 1-4, outlining additional container features that can be built on the foundation of PID namespaces, mount namespaces, network namespaces, and cgroups resource management.\n\nThe basic container implementation established through the four core milestones provides a solid foundation for process isolation, filesystem isolation, network isolation, and resource control. However, production container runtimes like Docker and containerd implement numerous additional features that enhance security, usability, and operational capabilities. This section explores three major categories of extensions that can be built upon our basic container runtime: additional namespace support for enhanced isolation, image management for portable container distribution, and orchestration capabilities for multi-container coordination.\n\nThese extensions represent natural evolutionary paths for the basic container runtime, each building incrementally on the existing namespace and cgroups infrastructure. Understanding these extensions helps illuminate why container platforms have become so powerful and why they've largely replaced virtual machines for many deployment scenarios. Each extension category addresses specific operational challenges that emerge when containers move from development prototypes to production systems.\n\nThe extensions follow a progression from enhanced isolation capabilities through content management to distributed coordination. Additional namespaces provide finer-grained isolation boundaries, addressing security and administrative concerns that emerge in multi-tenant environments. Image management solves the distribution and versioning challenges that arise when containers need to run consistently across different environments. Container orchestration addresses the coordination and service discovery challenges that emerge when applications are composed of multiple cooperating containers.\n\n### Additional Namespaces: User, UTS, and IPC Namespace Support\n\n**Mental Model: Security Zones in an Office Building**\n\nThink of additional namespaces like security zones in a modern office building. Our basic container implementation is like giving each tenant their own office (PID namespace), their own file cabinets (mount namespace), and their own phone system (network namespace). Additional namespaces are like adding more sophisticated security measures: user namespaces are like giving each tenant their own security badge system where they can be \"admin\" inside their space but have no privileges outside; UTS namespaces are like giving each tenant their own building address and signage; IPC namespaces are like ensuring each tenant's intercom system is completely separate from others.\n\nThe current basic container implementation uses three of the six available Linux namespace types. The remaining three namespaces—user, UTS (Unix Timesharing System), and IPC (Inter-Process Communication)—provide additional isolation boundaries that enhance security and administrative separation. These namespaces become increasingly important as containers move from development environments to production systems where multiple tenants or applications share the same host infrastructure.\n\n**User Namespace Architecture**\n\nUser namespaces provide perhaps the most significant security enhancement by creating isolated user and group ID mappings. Inside a user namespace, processes can have different user and group IDs than they appear to have from the host perspective. This capability enables containers to run processes as root (UID 0) inside the namespace while those same processes appear as unprivileged users from the host perspective.\n\nThe user namespace implementation requires extending the `container_config_t` structure to include user mapping specifications:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `enable_user_ns` | `int` | Whether to create user namespace for container |\n| `uid_map_inside` | `uid_t` | User ID as seen inside the container namespace |\n| `uid_map_outside` | `uid_t` | User ID as seen from host perspective |\n| `uid_map_length` | `size_t` | Number of consecutive UIDs in the mapping range |\n| `gid_map_inside` | `gid_t` | Group ID as seen inside the container namespace |\n| `gid_map_outside` | `gid_t` | Group ID as seen from host perspective |\n| `gid_map_length` | `size_t` | Number of consecutive GIDs in the mapping range |\n\nThe user namespace creation process involves several steps that must occur in a specific sequence. First, the container process creates the user namespace using the `CLONE_NEWUSER` flag with the `clone()` system call. However, unlike other namespaces, the user namespace requires additional setup steps after creation to establish the user and group ID mappings.\n\n> **Design Insight: User Namespace Timing Requirements**\n> User namespaces have unique timing constraints because processes inside a newly created user namespace initially have no user or group ID mappings. This means they cannot perform operations that require specific user privileges until the mappings are established. The parent process must write to the `/proc/[pid]/uid_map` and `/proc/[pid]/gid_map` files to establish these mappings before the container process can proceed with other initialization tasks.\n\nThe user namespace component would implement the following interface:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `create_user_namespace` | `config, container` | `int` | Creates user namespace with CLONE_NEWUSER flag |\n| `setup_user_mappings` | `config, child_pid` | `int` | Establishes UID/GID mappings from parent process |\n| `write_uid_map` | `child_pid, inside_uid, outside_uid, length` | `int` | Writes user ID mapping to /proc/[pid]/uid_map |\n| `write_gid_map` | `child_pid, inside_gid, outside_gid, length` | `int` | Writes group ID mapping to /proc/[pid]/gid_map |\n| `verify_user_isolation` | `container_pid` | `int` | Verifies user namespace isolation is working |\n\n**UTS Namespace Architecture**\n\nUTS namespaces isolate the system hostname and domain name, allowing each container to have its own distinct identity for networking and administrative purposes. While this might seem like a minor isolation boundary, it becomes important for applications that rely on hostname for configuration, logging, or service discovery.\n\nThe UTS namespace extension requires adding hostname configuration to the container setup:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `container_hostname` | `char*` | Hostname to set inside UTS namespace |\n| `container_domainname` | `char*` | Domain name to set inside UTS namespace |\n\nThe UTS namespace implementation is relatively straightforward compared to user namespaces because it doesn't require complex mappings or parent-child coordination. The container process creates the UTS namespace using `CLONE_NEWUTS` and then uses the `sethostname()` and `setdomainname()` system calls to establish the container's identity.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `create_uts_namespace` | `config, container` | `int` | Creates UTS namespace with CLONE_NEWUTS flag |\n| `setup_container_hostname` | `hostname` | `int` | Sets hostname inside UTS namespace using sethostname() |\n| `setup_container_domainname` | `domainname` | `int` | Sets domain name inside UTS namespace using setdomainname() |\n| `get_container_identity` | `hostname_buf, domain_buf` | `int` | Retrieves current hostname and domain name |\n\n**IPC Namespace Architecture**\n\nIPC namespaces isolate System V IPC objects (message queues, semaphores, shared memory segments) and POSIX message queues. This isolation prevents containers from interfering with each other's inter-process communication mechanisms and provides an additional security boundary.\n\nThe IPC namespace implementation requires minimal configuration because it primarily provides isolation rather than requiring specific setup:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `enable_ipc_ns` | `int` | Whether to create IPC namespace for container |\n| `cleanup_ipc_objects` | `int` | Whether to clean up IPC objects on container exit |\n\nThe IPC namespace component provides these interface methods:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `create_ipc_namespace` | `config, container` | `int` | Creates IPC namespace with CLONE_NEWIPC flag |\n| `list_ipc_objects` | `objects, max_objects` | `int` | Lists System V IPC objects in current namespace |\n| `cleanup_ipc_namespace` | `container` | `int` | Removes any remaining IPC objects before namespace destruction |\n\n**Integration with Existing Container System**\n\nAdding these additional namespaces requires updating the existing container creation workflow to accommodate the new namespace types. The `CONTAINER_NS_FLAGS` constant would be extended to include the new namespace flags:\n\n```c\n#define CONTAINER_NS_FLAGS_EXTENDED (CLONE_NEWPID|CLONE_NEWNS|CLONE_NEWNET|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWUSER)\n```\n\nThe container startup sequence must be modified to handle the user namespace timing requirements, where user mappings must be established before the container process can proceed with other initialization steps. This requires extending the parent-child synchronization mechanism to include a user namespace setup phase.\n\n> **Architecture Decision: User Namespace Setup Timing**\n> - **Context**: User namespaces require parent process to establish UID/GID mappings after namespace creation but before container initialization continues\n> - **Options Considered**: \n>   1. Setup mappings before any other namespaces\n>   2. Setup mappings after all namespaces are created\n>   3. Defer mapping setup until container process requests it\n> - **Decision**: Setup user mappings immediately after user namespace creation but before other namespace initialization\n> - **Rationale**: This ensures the container process has proper privileges for subsequent namespace setup operations while maintaining security isolation\n> - **Consequences**: Requires extending parent-child synchronization protocol and adds complexity to error handling during startup sequence\n\n**Common Pitfalls in Additional Namespace Implementation**\n\n⚠️ **Pitfall: User Namespace Capability Confusion**\nWhen user namespaces are enabled, processes inside the namespace may have different capabilities than expected. A process running as UID 0 (root) inside a user namespace has administrative capabilities within that namespace but no special privileges on the host system. This can cause confusion when processes attempt operations that would normally succeed for root but fail due to the user namespace boundary. The solution is to carefully design capability requirements and test operations both inside and outside user namespaces.\n\n⚠️ **Pitfall: Hostname Conflicts in Service Discovery**\nApplications that rely on hostname for service discovery may behave unexpectedly when each container has its own hostname via UTS namespace. Multiple containers might choose the same hostname, leading to conflicts in service registration systems. The solution is to implement hostname allocation policies that ensure uniqueness within the deployment environment, similar to IP address allocation for network namespaces.\n\n⚠️ **Pitfall: IPC Object Cleanup Timing**\nSystem V IPC objects persist until explicitly removed, even after the processes that created them exit. In IPC namespaces, these objects are automatically cleaned up when the namespace is destroyed, but applications might not expect this behavior. The solution is to implement graceful IPC cleanup that allows applications to properly close IPC resources before namespace destruction.\n\n### Image Management: Container Image Layers and Overlay Filesystems\n\n**Mental Model: Layered Transparency Sheets**\n\nThink of container image management like the layered transparency sheets used in anatomy textbooks. Each sheet shows one system of the body—skeletal, muscular, circulatory—and when you stack them together, you see the complete organism. Container images work similarly: the base layer might contain the operating system files, the next layer adds application dependencies, another layer adds the application binary, and the final layer adds configuration files. When you stack all these layers together using an overlay filesystem, the container sees a complete, unified filesystem that appears to be a regular directory tree.\n\nThe basic container implementation uses a simple approach where each container has its own complete root filesystem directory. While this works for development and learning, production container systems use layered images that enable efficient sharing of common components between containers, faster container startup times, and reduced storage requirements. This image management system requires implementing overlay filesystems, image layer management, and content distribution mechanisms.\n\n**Container Image Architecture**\n\nContainer images consist of multiple read-only layers stacked together with a single read-write layer on top. Each layer represents a set of filesystem changes (files added, modified, or deleted) relative to the previous layer. This layered approach enables multiple containers to share common base layers while maintaining their own writable layer for runtime changes.\n\nThe image management system requires new data structures to represent image metadata and layer information:\n\n| Structure Name | Field Name | Type | Description |\n|----------------|------------|------|-------------|\n| `image_layer_t` | `layer_id` | `char[64]` | SHA256 hash identifying this layer uniquely |\n|                | `parent_layer_id` | `char[64]` | SHA256 hash of parent layer, empty for base layer |\n|                | `layer_path` | `char[256]` | Filesystem path to layer directory or archive |\n|                | `layer_size` | `size_t` | Total size of layer content in bytes |\n|                | `change_type` | `layer_change_t` | Whether layer adds, modifies, or removes files |\n| `container_image_t` | `image_id` | `char[64]` | SHA256 hash identifying complete image |\n|                    | `image_name` | `char[128]` | Human-readable image name like \"ubuntu:20.04\" |\n|                    | `layer_count` | `int` | Number of layers in image stack |\n|                    | `layers` | `image_layer_t*` | Array of layers ordered from base to top |\n|                    | `total_size` | `size_t` | Combined size of all layers in image |\n| `overlay_mount_t` | `lower_dirs` | `char**` | Array of read-only layer directories |\n|                  | `upper_dir` | `char*` | Read-write layer directory for container changes |\n|                  | `work_dir` | `char*` | Overlay filesystem work directory |\n|                  | `merged_dir` | `char*` | Mount point showing unified view of all layers |\n\n**Overlay Filesystem Implementation**\n\nOverlay filesystems provide the mechanism for combining multiple image layers into a single unified directory tree. The Linux overlay filesystem driver (overlayfs) takes multiple lower directories (read-only layers), one upper directory (read-write layer), and a work directory (for atomic operations), then presents them as a single merged directory.\n\nThe overlay filesystem setup process involves several coordinated steps. First, the image management system prepares the layer directories by extracting or mounting each image layer to a separate directory. These directories become the \"lower\" layers in overlay filesystem terminology. Second, the system creates an empty \"upper\" directory where the container can make filesystem changes during execution. Third, the system creates a \"work\" directory that overlay filesystem uses for atomic operations. Finally, the system mounts the overlay filesystem with all these directories to create the unified view.\n\nThe overlay filesystem component provides these interface methods:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `setup_overlay_mount` | `image, container_id, overlay` | `int` | Prepares and mounts overlay filesystem for container |\n| `prepare_image_layers` | `image, layer_dirs` | `int` | Extracts or mounts all image layers to separate directories |\n| `create_overlay_dirs` | `container_id, upper, work, merged` | `int` | Creates upper, work, and merged directories for overlay mount |\n| `mount_overlay_filesystem` | `overlay` | `int` | Mounts overlay filesystem with specified layer configuration |\n| `cleanup_overlay_mount` | `overlay` | `int` | Unmounts overlay filesystem and cleans up directories |\n| `commit_container_changes` | `overlay, new_layer` | `int` | Creates new image layer from container's upper directory |\n\nThe overlay mount process requires careful handling of directory permissions and ownership. Each layer directory must be accessible to the container process, but the overlay filesystem itself manages the permission and ownership mapping between layers. When files exist in multiple layers, the topmost layer takes precedence, implementing the \"copy-on-write\" semantics that allow containers to modify files without affecting the underlying image layers.\n\n> **Design Insight: Copy-on-Write Behavior**\n> When a container attempts to modify a file that exists in a lower (read-only) layer, the overlay filesystem automatically copies that file to the upper (read-write) layer and applies the modification there. This copy-on-write behavior ensures that image layers remain immutable while allowing containers to make necessary runtime changes. The performance impact of this copying operation can be significant for large files, which is why container images are typically designed with frequently modified files placed in higher layers.\n\n**Image Layer Management**\n\nContainer images are typically distributed as compressed archives containing layer data and metadata. The image management system must handle extracting these archives, verifying layer integrity, and managing the storage of layer data on the local filesystem. This involves implementing a local image store that can efficiently store and retrieve image layers.\n\nThe image store uses content-addressable storage where each layer is stored using its SHA256 hash as the directory name. This approach ensures that identical layers are stored only once, even when they appear in multiple images. The image store structure looks like this:\n\n```\n/var/lib/container-basic/images/\n├── layers/\n│   ├── sha256:a1b2c3d4.../\n│   │   ├── layer.tar        ← compressed layer content\n│   │   └── metadata.json    ← layer metadata\n│   └── sha256:e5f6g7h8.../\n│       ├── layer.tar\n│       └── metadata.json\n├── images/\n│   ├── ubuntu-20.04/\n│   │   └── manifest.json    ← image manifest listing all layers\n│   └── nginx-latest/\n│       └── manifest.json\n└── containers/\n    ├── container-001/\n    │   ├── upper/           ← read-write layer for this container\n    │   ├── work/            ← overlay filesystem work directory\n    │   └── merged/          ← overlay mount point\n    └── container-002/\n        ├── upper/\n        ├── work/\n        └── merged/\n```\n\nThe image layer management component provides these interface methods:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `pull_image_layers` | `image_name, registry_url` | `int` | Downloads image layers from remote registry |\n| `extract_layer_archive` | `layer_path, extract_dir` | `int` | Extracts compressed layer archive to directory |\n| `verify_layer_integrity` | `layer_path, expected_hash` | `int` | Verifies layer content matches expected SHA256 hash |\n| `store_image_manifest` | `image_name, manifest` | `int` | Stores image manifest in local image store |\n| `load_image_manifest` | `image_name, manifest` | `int` | Loads image manifest from local image store |\n| `garbage_collect_layers` | `retain_days` | `int` | Removes unused layers older than specified days |\n| `list_available_images` | `images, max_images` | `int` | Lists all images available in local image store |\n\n**Integration with Mount Namespace**\n\nThe image management system must integrate with the existing mount namespace implementation to replace the simple root filesystem setup with overlay filesystem mounting. This requires modifying the `setup_container_rootfs` function to use overlay mounting instead of bind mounting a single directory.\n\nThe integration involves updating the container startup sequence to include image layer preparation before mount namespace creation. The modified sequence becomes: validate container configuration, pull and extract image layers if needed, prepare overlay directories, create mount namespace, mount overlay filesystem as container root, mount essential filesystems (/proc, /sys, /dev), and finally execute the container process.\n\n> **Architecture Decision: Overlay vs Bind Mount Integration**\n> - **Context**: Existing mount namespace implementation uses bind mounts for simple directory-based root filesystems, but overlay filesystems require different mount setup\n> - **Options Considered**:\n>   1. Replace bind mount implementation entirely with overlay mounting\n>   2. Add overlay support as alternative mount type with configuration flag\n>   3. Implement overlay as wrapper around existing bind mount system\n> - **Decision**: Add overlay support as alternative mount type with configuration flag\n> - **Rationale**: This preserves backward compatibility for simple use cases while enabling advanced image layer functionality when needed\n> - **Consequences**: Increases code complexity but provides flexibility for different deployment scenarios and easier testing of both approaches\n\n**Common Pitfalls in Image Management Implementation**\n\n⚠️ **Pitfall: Layer Extraction Race Conditions**\nWhen multiple containers attempt to use the same image simultaneously, they may try to extract the same layers concurrently, leading to corruption or incomplete extractions. The solution is to implement file locking around layer extraction operations and check for existing extracted layers before beginning extraction.\n\n⚠️ **Pitfall: Overlay Work Directory Cleanup**\nThe overlay filesystem work directory must be on the same filesystem as the upper directory for atomic operations to work correctly. Additionally, the work directory must be cleaned up properly when containers exit, or subsequent overlay mounts may fail with \"work directory not empty\" errors. The solution is to ensure work directories are created on the correct filesystem and implement thorough cleanup procedures.\n\n⚠️ **Pitfall: Layer Hash Verification Bypass**\nSkipping layer integrity verification during development can lead to subtle corruption issues that are difficult to debug. Corrupted layers may cause containers to behave unpredictably or fail in unexpected ways. The solution is to always verify layer hashes, even during development, and implement clear error messages when verification fails.\n\n### Container Orchestration: Multi-Container Coordination and Service Discovery\n\n**Mental Model: Restaurant Kitchen Coordination**\n\nThink of container orchestration like the coordination system in a busy restaurant kitchen. Individual containers are like cooking stations—the grill, the salad prep area, the dessert station—each specialized for specific tasks. The orchestration system is like the head chef and expeditors who coordinate between stations: they ensure orders flow smoothly between stations, ingredients are available when needed, backup stations can take over when one fails, and the final dishes are assembled correctly. Service discovery is like the communication system that lets each station know where to send completed items and where to request ingredients.\n\nThe basic container implementation focuses on isolating and controlling individual containers, but real-world applications typically consist of multiple containers that must coordinate to provide complete functionality. A web application might have containers for the web server, database, cache, and background job processor, all of which need to communicate with each other and be managed as a cohesive system. Container orchestration addresses these multi-container coordination challenges.\n\n**Service Discovery Architecture**\n\nService discovery enables containers to locate and communicate with other containers without hardcoding network addresses or relying on external configuration. As containers start and stop dynamically, their IP addresses change, making static configuration impractical. Service discovery systems provide a dynamic registry where containers can register their services and query for the services they depend on.\n\nThe service discovery system requires data structures to represent services and their endpoints:\n\n| Structure Name | Field Name | Type | Description |\n|----------------|------------|------|-------------|\n| `service_endpoint_t` | `service_name` | `char[64]` | Name of service like \"web-server\" or \"database\" |\n|                     | `container_id` | `char[64]` | Identifier of container providing this service |\n|                     | `ip_address` | `char[16]` | IP address where service is accessible |\n|                     | `port` | `uint16_t` | TCP/UDP port number for service |\n|                     | `health_status` | `endpoint_health_t` | Current health status of service endpoint |\n|                     | `last_heartbeat` | `time_t` | Timestamp of last health check or heartbeat |\n| `service_registry_t` | `services` | `service_endpoint_t**` | Hash table mapping service names to endpoint arrays |\n|                      | `service_count` | `int` | Total number of registered services |\n|                      | `registry_lock` | `pthread_mutex_t` | Mutex protecting concurrent registry access |\n| `service_query_t` | `service_name` | `char[64]` | Name of service being queried |\n|                  | `preferred_zone` | `char[32]` | Preferred availability zone or location |\n|                  | `load_balancing` | `lb_strategy_t` | Load balancing strategy for multiple endpoints |\n|                  | `timeout_ms` | `int` | Maximum time to wait for service resolution |\n\nThe service discovery implementation provides both registration and query capabilities. Containers register their services when they start and deregister when they stop. Other containers query the service registry to discover available services and their current endpoints.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `register_service` | `service_name, container_id, ip, port` | `int` | Registers new service endpoint in registry |\n| `deregister_service` | `service_name, container_id` | `int` | Removes service endpoint from registry |\n| `discover_service` | `query, endpoints, max_endpoints` | `int` | Queries registry for available service endpoints |\n| `update_service_health` | `service_name, container_id, health` | `int` | Updates health status of registered service |\n| `list_services` | `services, max_services` | `int` | Lists all services currently registered |\n| `cleanup_expired_services` | `max_age_seconds` | `int` | Removes services that haven't sent heartbeats |\n\n**Container Lifecycle Management**\n\nOrchestration systems manage the complete lifecycle of multiple containers, including startup ordering, dependency management, failure handling, and scaling decisions. Unlike individual container management, orchestration must reason about relationships between containers and coordinate their lifecycle events.\n\nThe orchestration system uses deployment specifications that describe the desired state of multi-container applications:\n\n| Structure Name | Field Name | Type | Description |\n|----------------|------------|------|-------------|\n| `container_spec_t` | `container_name` | `char[64]` | Unique name for container within deployment |\n|                   | `image_name` | `char[128]` | Container image to use for this container |\n|                   | `replicas` | `int` | Number of identical container instances to run |\n|                   | `dependencies` | `char**` | Array of container names this depends on |\n|                   | `service_ports` | `port_mapping_t*` | Ports this container exposes as services |\n|                   | `resource_limits` | `container_config_t` | CPU, memory, and other resource constraints |\n| `deployment_spec_t` | `deployment_name` | `char[64]` | Name of multi-container deployment |\n|                    | `container_specs` | `container_spec_t*` | Array of container specifications |\n|                    | `spec_count` | `int` | Number of containers in deployment |\n|                    | `network_name` | `char[64]` | Name of network for inter-container communication |\n| `deployment_state_t` | `spec` | `deployment_spec_t` | Desired state specification |\n|                     | `running_containers` | `container_instance_t**` | Currently running container instances |\n|                     | `container_count` | `int` | Number of currently running containers |\n|                     | `state_lock` | `pthread_mutex_t` | Mutex protecting concurrent state access |\n\nThe orchestration engine implements a control loop that continuously compares the desired state (deployment specification) with the actual state (running containers) and takes actions to reconcile any differences. This approach ensures that containers are automatically restarted if they fail, scaled up or down as needed, and started in the correct dependency order.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `create_deployment` | `spec, deployment` | `int` | Creates new multi-container deployment |\n| `update_deployment` | `deployment, new_spec` | `int` | Updates existing deployment with new specification |\n| `delete_deployment` | `deployment` | `int` | Stops all containers and deletes deployment |\n| `reconcile_deployment_state` | `deployment` | `int` | Ensures actual state matches desired state |\n| `scale_container_replicas` | `deployment, container_name, replicas` | `int` | Changes number of replicas for specific container |\n| `restart_failed_containers` | `deployment` | `int` | Restarts containers that have failed or stopped |\n| `check_container_dependencies` | `spec, container_name` | `int` | Verifies all dependencies are running and healthy |\n\n**Inter-Container Communication**\n\nContainers within an orchestrated deployment need secure and efficient communication mechanisms. While containers can communicate through the network namespace and bridge networking established in milestone 3, orchestration systems typically provide higher-level communication abstractions that handle service discovery, load balancing, and failure recovery automatically.\n\nThe communication system builds on the existing network namespace infrastructure but adds service-aware networking features. Instead of containers needing to know specific IP addresses and ports, they can communicate using service names that the orchestration system resolves dynamically.\n\n| Structure Name | Field Name | Type | Description |\n|----------------|------------|------|-------------|\n| `service_connection_t` | `source_container` | `char[64]` | Container initiating the connection |\n|                       | `target_service` | `char[64]` | Service name being connected to |\n|                       | `connection_type` | `connection_type_t` | HTTP, TCP, UDP, or other protocol |\n|                       | `load_balancer` | `load_balancer_t*` | Load balancer managing multiple endpoints |\n| `load_balancer_t` | `strategy` | `lb_strategy_t` | Round-robin, least-connections, or random |\n|                  | `endpoints` | `service_endpoint_t*` | Array of available service endpoints |\n|                  | `endpoint_count` | `int` | Number of currently healthy endpoints |\n|                  | `current_index` | `int` | Current position for round-robin selection |\n\nThe inter-container communication component extends the existing network namespace functionality:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `create_service_network` | `network_name, subnet` | `int` | Creates dedicated network for service communication |\n| `connect_container_to_service` | `container, service_name, connection` | `int` | Establishes connection to named service |\n| `setup_load_balancer` | `service_name, strategy, balancer` | `int` | Creates load balancer for service with multiple endpoints |\n| `route_service_request` | `connection, request` | `int` | Routes request to appropriate service endpoint |\n| `handle_endpoint_failure` | `balancer, failed_endpoint` | `int` | Removes failed endpoint from load balancer rotation |\n| `update_service_endpoints` | `balancer, new_endpoints` | `int` | Updates load balancer with current healthy endpoints |\n\n**Integration with Existing Container System**\n\nContainer orchestration builds upon all four milestone components—PID namespaces, mount namespaces, network namespaces, and cgroups—but coordinates their use across multiple containers. The orchestration system becomes the higher-level controller that manages multiple instances of the basic container runtime.\n\nThe integration requires extending the container creation and management interfaces to support orchestration-driven lifecycle management. Instead of manually calling `container_create`, `container_wait`, and `container_destroy` for individual containers, the orchestration system manages these operations based on deployment specifications and health monitoring.\n\nThe orchestration system must also coordinate resource allocation across multiple containers to prevent resource conflicts and ensure fair sharing. This involves extending the cgroups implementation to support hierarchical resource allocation where the orchestration system allocates resources to deployments, and deployments sub-allocate resources to individual containers.\n\n> **Architecture Decision: Centralized vs Distributed Orchestration**\n> - **Context**: Multi-container deployments need coordination for startup, failure handling, and resource management\n> - **Options Considered**:\n>   1. Centralized orchestration with single control process managing all containers\n>   2. Distributed orchestration with peer-to-peer coordination between containers\n>   3. Hierarchical orchestration with local controllers managed by global coordinator\n> - **Decision**: Centralized orchestration with single control process for basic implementation\n> - **Rationale**: Centralized approach is simpler to implement and debug, provides consistent state management, and aligns with the educational goals of understanding orchestration concepts\n> - **Consequences**: Creates single point of failure but provides clear operational model that can be extended to distributed approaches later\n\n**Common Pitfalls in Container Orchestration Implementation**\n\n⚠️ **Pitfall: Circular Dependency Detection**\nWhen containers have complex dependency relationships, it's possible to create circular dependencies where container A depends on container B, which depends on container C, which depends back on container A. This creates a deadlock where no container can start because each is waiting for another. The solution is to implement dependency graph analysis that detects cycles before attempting to start containers and reports clear error messages about which containers form the cycle.\n\n⚠️ **Pitfall: Service Discovery Race Conditions**\nDuring rapid container startup and shutdown, service registration and deregistration events can arrive out of order, leading to incorrect service registry state. A container might deregister just before its replacement registers, causing temporary service unavailability. The solution is to implement proper synchronization around service registry operations and use timestamps or version numbers to handle out-of-order events correctly.\n\n⚠️ **Pitfall: Resource Allocation Conflicts**\nWhen multiple containers compete for limited resources, the orchestration system might allocate more resources than are actually available on the system. This can lead to containers being unable to start or experiencing performance degradation due to resource pressure. The solution is to implement resource accounting that tracks total allocated resources across all deployments and prevents over-allocation beyond system capacity.\n\n### Implementation Guidance\n\nThe future extensions build incrementally on the existing container runtime foundation, allowing learners to implement them in stages based on their interests and requirements. Each extension category represents a significant engineering undertaking, so it's recommended to start with the additional namespaces as they most closely parallel the existing namespace implementations.\n\n**Technology Recommendations**\n\n| Extension Category | Simple Implementation | Advanced Implementation |\n|--------------------|----------------------|------------------------|\n| Additional Namespaces | Direct syscall integration with existing namespace code | Namespace capability management and privilege dropping |\n| Image Management | Directory-based layer storage with tar archives | Content-addressable storage with compression and deduplication |\n| Container Orchestration | Single-host process coordinator with file-based service registry | Distributed coordination with etcd or consul for service discovery |\n\n**Recommended File Structure Extension**\n\nBuilding on the existing container runtime structure, the extensions would add new directories:\n\n```\ncontainer-basic/\n├── src/\n│   ├── namespaces/\n│   │   ├── pid_namespace.c      ← existing\n│   │   ├── mount_namespace.c    ← existing\n│   │   ├── network_namespace.c  ← existing\n│   │   ├── user_namespace.c     ← new: user namespace implementation\n│   │   ├── uts_namespace.c      ← new: UTS namespace implementation\n│   │   └── ipc_namespace.c      ← new: IPC namespace implementation\n│   ├── images/\n│   │   ├── image_store.c        ← new: local image storage management\n│   │   ├── layer_manager.c      ← new: layer extraction and mounting\n│   │   ├── overlay_fs.c         ← new: overlay filesystem integration\n│   │   └── image_registry.c     ← new: remote image pulling\n│   ├── orchestration/\n│   │   ├── service_discovery.c  ← new: service registration and lookup\n│   │   ├── deployment_manager.c ← new: multi-container lifecycle\n│   │   ├── load_balancer.c      ← new: service load balancing\n│   │   └── resource_scheduler.c ← new: cross-container resource allocation\n│   └── container.c              ← existing: updated to support extensions\n├── include/\n│   ├── container_extensions.h   ← new: extension API definitions\n│   └── orchestration_types.h    ← new: orchestration data structures\n└── tests/\n    ├── test_additional_namespaces.c  ← new: additional namespace tests\n    ├── test_image_management.c       ← new: image layer tests\n    └── test_orchestration.c          ← new: multi-container tests\n```\n\n**Infrastructure Starter Code: Service Registry**\n\nHere's a complete service registry implementation that provides the foundation for container orchestration:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <time.h>\n#include <sys/queue.h>\n\n#define MAX_SERVICE_NAME 64\n#define MAX_CONTAINER_ID 64\n#define MAX_ENDPOINTS_PER_SERVICE 16\n\ntypedef enum {\n    ENDPOINT_HEALTHY,\n    ENDPOINT_UNHEALTHY,\n    ENDPOINT_UNKNOWN\n} endpoint_health_t;\n\ntypedef struct service_endpoint {\n    char service_name[MAX_SERVICE_NAME];\n    char container_id[MAX_CONTAINER_ID];\n    char ip_address[16];\n    uint16_t port;\n    endpoint_health_t health_status;\n    time_t last_heartbeat;\n    LIST_ENTRY(service_endpoint) entries;\n} service_endpoint_t;\n\ntypedef struct service_registry {\n    LIST_HEAD(endpoint_list, service_endpoint) endpoints;\n    pthread_mutex_t registry_lock;\n    int endpoint_count;\n} service_registry_t;\n\n// Initialize global service registry\nservice_registry_t global_registry = {\n    .endpoints = LIST_HEAD_INITIALIZER(global_registry.endpoints),\n    .registry_lock = PTHREAD_MUTEX_INITIALIZER,\n    .endpoint_count = 0\n};\n\nint register_service(const char* service_name, const char* container_id, \n                    const char* ip_address, uint16_t port) {\n    service_endpoint_t* endpoint = malloc(sizeof(service_endpoint_t));\n    if (!endpoint) return -1;\n    \n    strncpy(endpoint->service_name, service_name, MAX_SERVICE_NAME - 1);\n    strncpy(endpoint->container_id, container_id, MAX_CONTAINER_ID - 1);\n    strncpy(endpoint->ip_address, ip_address, 15);\n    endpoint->port = port;\n    endpoint->health_status = ENDPOINT_HEALTHY;\n    endpoint->last_heartbeat = time(NULL);\n    \n    pthread_mutex_lock(&global_registry.registry_lock);\n    LIST_INSERT_HEAD(&global_registry.endpoints, endpoint, entries);\n    global_registry.endpoint_count++;\n    pthread_mutex_unlock(&global_registry.registry_lock);\n    \n    printf(\"Registered service %s at %s:%d for container %s\\n\", \n           service_name, ip_address, port, container_id);\n    return 0;\n}\n\nint discover_service(const char* service_name, service_endpoint_t* results, \n                    int max_results) {\n    int found_count = 0;\n    service_endpoint_t* endpoint;\n    \n    pthread_mutex_lock(&global_registry.registry_lock);\n    LIST_FOREACH(endpoint, &global_registry.endpoints, entries) {\n        if (strcmp(endpoint->service_name, service_name) == 0 && \n            endpoint->health_status == ENDPOINT_HEALTHY &&\n            found_count < max_results) {\n            memcpy(&results[found_count], endpoint, sizeof(service_endpoint_t));\n            found_count++;\n        }\n    }\n    pthread_mutex_unlock(&global_registry.registry_lock);\n    \n    return found_count;\n}\n\nint deregister_service(const char* service_name, const char* container_id) {\n    service_endpoint_t* endpoint;\n    int removed = 0;\n    \n    pthread_mutex_lock(&global_registry.registry_lock);\n    LIST_FOREACH(endpoint, &global_registry.endpoints, entries) {\n        if (strcmp(endpoint->service_name, service_name) == 0 && \n            strcmp(endpoint->container_id, container_id) == 0) {\n            LIST_REMOVE(endpoint, entries);\n            global_registry.endpoint_count--;\n            free(endpoint);\n            removed = 1;\n            break;\n        }\n    }\n    pthread_mutex_unlock(&global_registry.registry_lock);\n    \n    if (removed) {\n        printf(\"Deregistered service %s for container %s\\n\", \n               service_name, container_id);\n    }\n    return removed ? 0 : -1;\n}\n```\n\n**Core Logic Skeleton: User Namespace Setup**\n\n```c\n// Creates user namespace and establishes UID/GID mappings for container process\nint create_user_namespace(container_config_t* config, container_instance_t* container) {\n    // TODO 1: Check if user namespace is enabled in configuration\n    // TODO 2: Create child process with CLONE_NEWUSER flag using safe_clone()\n    // TODO 3: Store child PID in container instance structure\n    // TODO 4: Write UID mapping to /proc/[child_pid]/uid_map from parent process\n    //         Format: \"inside_uid outside_uid length\" (e.g., \"0 1000 1\")\n    // TODO 5: Write GID mapping to /proc/[child_pid]/gid_map from parent process\n    //         Format: \"inside_gid outside_gid length\" (e.g., \"0 1000 1\")\n    // TODO 6: Signal child process that user mappings are complete\n    // TODO 7: Child process continues with container initialization as mapped user\n    // Hint: Use container_sync_t pipes for parent-child coordination\n    // Hint: Check /proc/sys/user/max_user_namespaces for system limits\n}\n\n// Sets up overlay filesystem mount with multiple image layers\nint setup_overlay_mount(container_image_t* image, const char* container_id, \n                       overlay_mount_t* overlay) {\n    // TODO 1: Create container-specific directories (upper, work, merged)\n    // TODO 2: Prepare lower directories by extracting each image layer\n    // TODO 3: Build comma-separated list of lower directories for mount options\n    // TODO 4: Construct overlay mount options string:\n    //         \"lowerdir=/layer1:/layer2,upperdir=/upper,workdir=/work\"\n    // TODO 5: Mount overlay filesystem to merged directory using mount() syscall\n    // TODO 6: Verify overlay mount succeeded by checking merged directory content\n    // TODO 7: Store all directory paths in overlay structure for cleanup\n    // Hint: Lower directories must be listed in bottom-to-top layer order\n    // Hint: Work directory must be on same filesystem as upper directory\n}\n\n// Implements orchestration control loop for multi-container deployment\nint reconcile_deployment_state(deployment_state_t* deployment) {\n    // TODO 1: Compare desired container count vs actual running container count\n    // TODO 2: Check dependency ordering - don't start containers before dependencies\n    // TODO 3: For each missing container: create container_config_t and call container_create()\n    // TODO 4: For each extra container: call container_destroy() to remove excess\n    // TODO 5: For each running container: verify health and restart if failed\n    // TODO 6: Update service registry with any container IP/port changes\n    // TODO 7: Return 0 if desired state achieved, -1 if actions still needed\n    // Hint: Use check_container_dependencies() before starting new containers\n    // Hint: Allow time for containers to start before marking reconciliation complete\n}\n```\n\n**Language-Specific Implementation Hints**\n\nFor C implementation of the extensions:\n\n- **User Namespace Mappings**: Use `sprintf()` to format UID/GID mapping strings, then write them to `/proc/[pid]/uid_map` and `/proc/[pid]/gid_map` using regular file operations\n- **Overlay Filesystem**: The mount() syscall for overlay requires specific option format: `mount(\"overlay\", \"/merged\", \"overlay\", 0, \"lowerdir=...,upperdir=...,workdir=...\")`\n- **Service Discovery**: Use POSIX threads (`pthread_create`) for background health checking and cleanup processes\n- **Image Layer Extraction**: Use `libarchive` or simple `tar` command execution for extracting layer archives\n- **Container Coordination**: Implement timeout handling using `select()` or `poll()` for non-blocking communication\n\n**Milestone Checkpoints**\n\nAfter implementing additional namespaces:\n- Run `unshare --user --map-root-user whoami` to verify user namespace concepts\n- Test that container process sees itself as UID 0 while host sees different UID\n- Verify hostname isolation by setting different hostnames in containers\n\nAfter implementing image management:\n- Create simple layered image with base layer + application layer\n- Verify overlay mount shows combined view of all layers\n- Test that changes in container don't affect original image layers\n\nAfter implementing basic orchestration:\n- Start multi-container deployment with dependencies (database → web server)\n- Verify service discovery allows web server to find database\n- Test that failed containers are automatically restarted\n\nThese extensions represent the natural evolution from basic container isolation to production-ready container platforms, demonstrating how fundamental namespace and cgroups concepts scale to complex distributed systems.\n\n\n## Glossary\n\n> **Milestone(s):** This section provides definitions for all technical terms used across milestones 1-4, establishing a common vocabulary for container implementation concepts including namespaces, cgroups, and container-specific terminology.\n\n### Mental Model: Technical Dictionary for Container Architecture\n\nThink of this glossary as a technical dictionary specifically for container systems, similar to how medical professionals have specialized dictionaries that define terms precisely for their field. Just as \"hypertension\" has a specific medical meaning beyond \"high blood pressure,\" container terminology has precise technical meanings that distinguish it from general computing concepts. For example, while \"isolation\" generally means \"separation,\" in the container context it specifically refers to kernel-enforced boundaries that prevent processes from accessing resources outside their designated namespace.\n\nThis glossary serves as your reference manual when implementing containers, ensuring that when we discuss \"pivot_root\" or \"zombie reaping,\" you understand not just the general concept but the specific technical implementation details and system call behaviors involved.\n\n### Core Container Concepts\n\nThe fundamental building blocks of container technology center around Linux kernel features that provide isolation and resource control. Understanding these concepts is essential before diving into implementation details.\n\n**Process isolation** refers to the kernel-enforced separation of processes so they cannot interfere with each other's execution, memory space, or system resources. This goes beyond simple process boundaries to include isolated views of system resources like process IDs, filesystems, and network stacks. Process isolation forms the foundation of container security and resource management.\n\n**Namespaces** are Linux kernel features that provide isolated views of system resources to different process groups. Each namespace type isolates a different category of system resources, allowing processes within a namespace to have their own private view while sharing the underlying kernel. Namespaces are the primary mechanism for achieving process isolation in containers.\n\n**Cgroups** (control groups) are Linux kernel features that limit, account for, and control resource usage by groups of processes. While namespaces provide isolation by changing what processes can see, cgroups provide control by limiting what resources processes can consume. Cgroups enforce memory limits, CPU quotas, and process limits to prevent containers from consuming excessive system resources.\n\n### System Call and Kernel Interface Terms\n\nContainer implementation relies heavily on specific Linux system calls and kernel interfaces that manage process creation, namespace manipulation, and resource control.\n\n**Clone() system call** creates a new process with specified namespace isolation flags, allowing fine-grained control over which namespaces the new process inherits versus creates fresh. Unlike fork() which creates processes in the same namespaces, clone() enables selective namespace isolation during process creation.\n\n**Pivot_root** is a system call operation that atomically changes the filesystem root directory and moves the old root to a specified location. This operation is essential for container filesystem isolation because it ensures the container process cannot access the original host filesystem tree after the switch.\n\n**Zombie reaping** refers to the process of collecting exit status information from terminated child processes to prevent them from remaining as zombie processes in the process table. In PID namespaces, the init process (PID 1) becomes responsible for reaping all orphaned processes within the namespace.\n\n### Namespace Types and Isolation Mechanisms\n\nEach namespace type provides isolation for a specific category of system resources, creating independent views for processes within different namespaces.\n\n**PID namespace** isolates the process ID numbering system, allowing processes in different PID namespaces to have overlapping process IDs. The first process created in a PID namespace becomes PID 1 within that namespace, regardless of its PID in the parent namespace. This enables containers to have their own process tree starting from PID 1.\n\n**Mount namespace** isolates the filesystem mount table, allowing processes in different mount namespaces to have different views of the filesystem hierarchy. Changes to mounts within a mount namespace do not affect other namespaces, enabling containers to have private filesystem layouts.\n\n**Network namespace** isolates the network stack including network interfaces, routing tables, firewall rules, and network statistics. Each network namespace has its own loopback interface and can contain different sets of network devices, enabling complete network isolation between containers.\n\n**User namespace** isolates user and group ID mappings, allowing processes to have different effective user IDs inside versus outside the namespace. This enables containers to run as root within their namespace while mapping to unprivileged users on the host system.\n\n**UTS namespace** isolates system hostname and domain name, allowing different containers to have different hostnames without affecting the host system or other containers.\n\n**IPC namespace** isolates System V IPC objects (message queues, semaphore sets, shared memory segments) and POSIX message queues, ensuring that containers cannot interfere with each other's inter-process communication mechanisms.\n\n### Container Configuration and Management Terms\n\nContainer runtime systems require structured configuration and management interfaces to coordinate the creation and lifecycle of isolated environments.\n\n**Container configuration** refers to the structured specification that defines all parameters for creating a container instance, including filesystem paths, resource limits, network settings, and namespace options. This configuration serves as the blueprint for constructing the isolated environment.\n\n**Container instance** represents an active container with running processes, created namespaces, and allocated resources. The instance maintains references to namespace file descriptors and cleanup information required for proper resource management.\n\n**Namespace handles** are file descriptor references to active namespaces that enable operations on existing namespaces and ensure proper cleanup when containers terminate. These handles prevent namespaces from disappearing while still in use and enable tools to enter existing namespaces.\n\n**Cleanup list** is a mechanism for tracking resource cleanup functions that must be executed in specific order during container shutdown or failure recovery. The cleanup list ensures that partially created containers release all allocated resources properly.\n\n### Filesystem and Mount Management Terms\n\nContainer filesystem isolation relies on sophisticated mount manipulation and filesystem virtualization techniques.\n\n**Mount propagation** controls how mount and unmount events spread between different mount namespaces. Private propagation prevents mount events from leaking between namespaces, while shared propagation allows coordination when needed.\n\n**Bind mount** creates a mount that makes an existing directory or file accessible at an additional location in the filesystem tree. Bind mounts enable containers to access specific host directories while maintaining overall filesystem isolation.\n\n**Essential filesystems** are kernel virtual filesystems like /proc, /sys, and /dev that provide interfaces to kernel functionality and device access. Containers typically mount their own instances of these filesystems to maintain isolation while providing necessary system interfaces.\n\n**Filesystem isolation** prevents containers from accessing parts of the host filesystem tree outside their designated rootfs directory. This isolation is achieved through mount namespaces and careful mount table configuration.\n\n**Old root** refers to the previous root filesystem location after a pivot_root operation has switched to a new root. The old root is typically unmounted and removed to complete the filesystem switch.\n\n### Network Infrastructure Terms\n\nContainer networking involves creating isolated network stacks and establishing connectivity between containers and external networks.\n\n**Veth pair** is a virtual ethernet device pair where packets sent to one end appear on the other end, enabling communication between different network namespaces. One end typically remains in the host namespace while the other moves to the container namespace.\n\n**Bridge networking** connects multiple veth pairs to a virtual bridge device, enabling communication between multiple containers and providing a common broadcast domain for inter-container networking.\n\n**NAT** (Network Address Translation) enables containers with private IP addresses to communicate with external networks by translating between private container addresses and public host addresses.\n\n### Resource Control and Enforcement Terms\n\nCgroups provide fine-grained resource control and enforcement mechanisms for container workloads.\n\n**Resource controllers** are cgroup subsystems that manage specific resource types such as memory, CPU time, process counts, or I/O bandwidth. Each controller implements accounting, limiting, and priority mechanisms for its resource type.\n\n**Memory controller** is the cgroup controller that tracks memory usage and enforces memory limits for groups of processes. It can limit various types of memory including RSS, page cache, and kernel memory allocations.\n\n**CPU controller** is the cgroup controller that manages CPU time allocation through quota and period mechanisms. It can enforce both absolute CPU limits and relative priority through shares and bandwidth controls.\n\n**Process controller** is the cgroup controller that limits the number of processes and threads that can exist within a cgroup. This prevents fork bombs and ensures fair process allocation across containers.\n\n**OOM killer** is the kernel mechanism that terminates processes when memory is exhausted and no more memory can be freed through normal reclaim. In containers, the OOM killer operates within memory cgroup boundaries.\n\n**CPU quota** specifies the maximum amount of CPU time a cgroup can consume within a given scheduling period. Quotas are expressed in microseconds and enforce hard limits on CPU usage.\n\n**Hierarchical cleanup** is a cleanup strategy that ensures processes are terminated before their containing cgroups are removed, preventing resource leaks and ensuring proper kernel resource release.\n\n### Error Handling and Debugging Terms\n\nContainer systems must handle various failure modes and provide debugging capabilities for troubleshooting isolation issues.\n\n**Container startup sequence** refers to the step-by-step process of creating all required namespaces, setting up resource limits, configuring networking, and launching the container process. Each step has dependencies and specific error handling requirements.\n\n**Container cleanup sequence** is the proper teardown order for releasing container resources including terminating processes, unmounting filesystems, removing network interfaces, and cleaning up cgroups. Cleanup order is critical to avoid resource leaks.\n\n**Error propagation** describes how errors in one container component affect other components during setup or operation. For example, mount namespace failures can prevent network namespace setup if shared directories are required.\n\n**Parent-child synchronization** coordinates actions between the host process creating a container and the container process being created. Synchronization ensures setup steps occur in the correct order across namespace boundaries.\n\n**Execution context** refers to whether operations occur within the host namespace context or within container namespace contexts. Many operations must occur in specific execution contexts to be effective.\n\n### Container Lifecycle and State Management Terms\n\nContainer systems must track and manage the lifecycle of container instances from creation through termination.\n\n**Dependency relationships** describe how different container components rely on each other for proper operation. For example, network namespace setup depends on successful PID namespace creation for process coordination.\n\n**Resource exhaustion** occurs when system resources such as memory, CPU, or process slots are depleted, potentially affecting container operation. Container systems must handle exhaustion gracefully and provide appropriate error reporting.\n\n**Partial cleanup** describes situations where some cleanup operations succeed while others fail during container shutdown. Systems must track cleanup state and retry failed operations to prevent resource leaks.\n\n**Cleanup ordering dependencies** define the sequence requirements for resource cleanup operations. For example, processes must be terminated before their cgroups can be removed, and network interfaces must be removed before network namespaces can be destroyed.\n\n### Testing and Verification Terms\n\nContainer implementations require comprehensive testing to verify isolation properties and resource enforcement.\n\n**Isolation verification tests** validate that namespace boundaries actually prevent processes from accessing resources outside their designated namespaces. These tests ensure that isolation mechanisms work as intended.\n\n**Resource limit testing** verifies that cgroup controllers prevent containers from exceeding their configured resource allocations. Testing must validate both soft limits and hard enforcement mechanisms.\n\n**Milestone checkpoints** are concrete verification steps that validate successful implementation of specific container features. Each checkpoint tests a specific aspect of isolation or resource control.\n\n**PID namespace isolation** testing verifies that process IDs are properly isolated between container and host, and that the container init process correctly handles its responsibilities as PID 1.\n\n**Mount namespace isolation** testing verifies that filesystem changes within containers do not affect the host filesystem and that containers cannot access unauthorized host directories.\n\n**Network namespace isolation** testing verifies that container network interfaces are isolated from host interfaces and that network configuration changes within containers do not affect host networking.\n\n**Memory limit enforcement** testing verifies that memory controllers prevent containers from exceeding configured memory limits and that OOM conditions are handled appropriately.\n\n**CPU limit enforcement** testing verifies that CPU controllers restrict container CPU usage to configured percentages and that CPU quota mechanisms work correctly.\n\n**Process limit enforcement** testing verifies that process controllers prevent containers from creating more processes than configured limits allow.\n\n### Advanced Container Features Terms\n\nBeyond basic isolation, container systems can implement additional features for image management and orchestration.\n\n**Container image layers** are read-only filesystem layers that stack together to form a complete container filesystem. Layers enable sharing of common components between different container images.\n\n**Overlay filesystem** is a union filesystem that combines multiple read-only layers with a read-write layer to create a single directory tree. Overlay filesystems enable efficient copy-on-write semantics for container filesystems.\n\n**Copy-on-write** is a filesystem optimization where files are shared between containers until modified, at which point they are copied to a container-specific writable layer. This reduces storage usage and improves container startup performance.\n\n**Content-addressable storage** is a storage system where data is accessed using cryptographic hashes of content rather than location-based paths. This enables deduplication and integrity verification for container image layers.\n\n**Service discovery** provides mechanisms for containers to locate and communicate with other services without hardcoded network addresses. Service discovery adapts to dynamic container deployment and network changes.\n\n**Container orchestration** coordinates multiple containers as a cohesive application, handling deployment, scaling, networking, and failure recovery across multiple container instances.\n\n**Deployment specification** is a configuration document that describes the desired state of a multi-container application including container images, resource requirements, networking, and dependencies.\n\n**Control loop** is a continuous process that compares desired application state with actual running state and takes corrective actions to reconcile differences. Control loops enable declarative container management.\n\n**Load balancing** distributes incoming requests across multiple container instances to improve performance and availability. Load balancing requires service discovery and health monitoring capabilities.\n\n**Inter-container communication** encompasses networking mechanisms that allow containers to communicate with each other while maintaining security boundaries. This includes service meshes, overlay networks, and service discovery.\n\n**Service registry** maintains a database of available services and their current network endpoints, enabling dynamic service discovery as containers start, stop, and move between hosts.\n\n**Container lifecycle management** coordinates container startup, health monitoring, failure detection, restart policies, and graceful shutdown across the entire container lifecycle.\n\n**Dependency management** ensures containers start in the correct order based on service dependencies and waits for required services to become available before starting dependent containers.\n\n**Hierarchical resource allocation** implements multi-level resource distribution from orchestration systems down to individual containers, ensuring fair resource sharing and preventing resource conflicts.\n\n### Implementation Guidance\n\nContainer systems involve complex interactions between kernel features and user-space management tools. Understanding the terminology provides a foundation for implementing these systems effectively.\n\n#### Key Terminology Categories\n\n| Category | Core Terms | Advanced Terms |\n|----------|------------|----------------|\n| Isolation | namespace, process isolation, PID namespace, mount namespace | user namespace, UTS namespace, IPC namespace |\n| Resource Control | cgroups, memory controller, CPU controller, process controller | hierarchical resource allocation, resource exhaustion |\n| Networking | network namespace, veth pair, bridge networking | service discovery, load balancing |\n| Filesystem | pivot_root, bind mount, essential filesystems | overlay filesystem, copy-on-write, content-addressable storage |\n| Lifecycle | container startup sequence, cleanup sequence, error propagation | container orchestration, deployment specification, control loop |\n| Testing | isolation verification, resource limit testing, milestone checkpoints | integration testing, performance testing |\n\n#### Critical Distinction: Isolation vs Control\n\nUnderstanding the distinction between isolation mechanisms (namespaces) and control mechanisms (cgroups) is fundamental to container implementation:\n\n- **Namespaces change what processes can see** - they provide different views of system resources\n- **Cgroups change what processes can do** - they limit and control resource consumption\n- **Both mechanisms work together** to create complete container isolation\n\n#### Container vs Virtual Machine Terminology\n\nContainer terminology often differs from virtual machine terminology, reflecting different architectural approaches:\n\n| Container Term | VM Equivalent | Key Difference |\n|----------------|---------------|----------------|\n| namespace | virtual hardware | shares kernel, isolates view |\n| cgroups | resource allocation | dynamic limits, shared resources |\n| container image | VM image | layered, content-addressable |\n| container runtime | hypervisor | process-based, not hardware virtualization |\n\n#### Common Terminology Mistakes\n\n⚠️ **Pitfall: Confusing \"container\" with \"containerization\"**\n- **Container** refers to a specific running instance with isolated namespaces\n- **Containerization** refers to the general practice of packaging applications\n- **Fix**: Use \"container instance\" for running containers, \"container image\" for static packages\n\n⚠️ **Pitfall: Using \"Docker\" and \"container\" interchangeably**\n- **Docker** is a specific container runtime implementation\n- **Container** refers to the general Linux kernel isolation technology\n- **Fix**: Use \"container runtime\" or \"container engine\" for implementations, \"container\" for the isolated process\n\n⚠️ **Pitfall: Confusing \"mount namespace\" with \"filesystem\"**\n- **Mount namespace** isolates the mount table (what's mounted where)\n- **Filesystem** refers to the actual data storage format\n- **Fix**: Mount namespaces control mount points, filesystems store data\n\n#### Debugging Terminology Usage\n\nWhen debugging container issues, precise terminology helps communicate problems effectively:\n\n| Symptom | Imprecise Description | Precise Description |\n|---------|----------------------|---------------------|\n| Process visible outside container | \"Container not isolated\" | \"PID namespace isolation failure\" |\n| Cannot access host directory | \"Filesystem broken\" | \"Mount namespace bind mount missing\" |\n| Network not working | \"Container networking broken\" | \"Network namespace veth pair misconfigured\" |\n| Container using too much memory | \"Resource problem\" | \"Memory controller limit not enforced\" |\n\nThis precise terminology enables faster diagnosis and resolution of container implementation issues.\n"}