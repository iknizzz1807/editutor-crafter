{"html":"<h1 id=\"-project-charter-container-basic\">üéØ Project Charter: Container (Basic)</h1>\n<h2 id=\"what-you-are-building\">What You Are Building</h2>\n<p>A minimal Linux container runtime from scratch that implements the core primitives used by Docker and runc. You will build a systems-level tool that uses the <code>clone()</code> and <code>unshare()</code> system calls to create isolated process environments, <code>pivot_root()</code> to swap filesystems, and Linux bridges to establish networking. By the end, you will have a binary that can pull an Alpine Linux rootfs and execute a shell inside a sandbox where the host‚Äôs files, processes, and network interfaces are completely invisible.</p>\n<h2 id=\"why-this-project-exists\">Why This Project Exists</h2>\n<p>Most developers use containers daily but treat them as &quot;Lightweight Virtual Machines,&quot; leading to confusion during debugging and security configuration. Building a container from raw kernel primitives shatters this illusion, revealing that a container is simply an ordinary process with a restricted view of the kernel&#39;s global data structures. Learning to manipulate namespaces and cgroups directly is the best way to understand container escape vulnerabilities and production orchestration.</p>\n<h2 id=\"what-you-will-be-able-to-do-when-done\">What You Will Be Able to Do When Done</h2>\n<ul>\n<li><strong>Implement Process Isolation:</strong> Use PID and UTS namespaces to make a containerized process believe it is PID 1 on a uniquely named host.</li>\n<li><strong>Enforce Filesystem Boundaries:</strong> Use <code>pivot_root</code> and mount namespaces to provide a private root filesystem, making the host‚Äôs <code>/etc</code> and <code>/root</code> unreachable.</li>\n<li><strong>Construct Virtual Networks:</strong> Create <code>veth</code> pairs and Linux bridges to route traffic from an isolated network namespace to the internet via NAT.</li>\n<li><strong>Apply Resource Constraints:</strong> Manually configure Cgroup v2 controllers to trigger OOM kills for memory-hungry processes and throttle CPU-intensive tasks.</li>\n<li><strong>Enable Rootless Execution:</strong> Map internal root privileges to unprivileged host UIDs using User Namespaces, allowing the container to run without <code>sudo</code>.</li>\n</ul>\n<h2 id=\"final-deliverable\">Final Deliverable</h2>\n<p>A functional container runtime (approx. 800‚Äì1,200 lines of C, Rust, or Go) comprised of a single binary. It will be able to launch an isolated shell that:</p>\n<ul>\n<li>Runs as a mapped &quot;root&quot; user but has no host-level privileges.</li>\n<li>Has a private IP address and functional DNS resolution.</li>\n<li>Is strictly limited to defined CPU and Memory quotas.</li>\n<li>Resides in a directory-based rootfs with no access to host files.</li>\n</ul>\n<h2 id=\"is-this-project-for-you\">Is This Project For You?</h2>\n<p><strong>You should start this if you:</strong></p>\n<ul>\n<li>Are comfortable with C-style systems programming (manual memory management, pointers).</li>\n<li>Understand the Linux process lifecycle (<code>fork</code>, <code>exec</code>, <code>wait</code>, <code>exit</code>).</li>\n<li>Have a basic grasp of networking concepts like IP addresses, gateways, and bridges.</li>\n<li>Want to know exactly what happens inside the kernel when you run <code>docker run</code>.</li>\n</ul>\n<p><strong>Come back after you&#39;ve learned:</strong></p>\n<ul>\n<li><a href=\"https://man7.org/tlpi/\">Linux System Programming Basics</a> (specifically file descriptors and signals).</li>\n<li>Basic shell networking commands (<code>ip link</code>, <code>iptables</code>).</li>\n</ul>\n<h2 id=\"estimated-effort\">Estimated Effort</h2>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID and UTS Namespace Isolation</td>\n<td>~5 hours</td>\n</tr>\n<tr>\n<td>Mount Namespace and <code>pivot_root</code></td>\n<td>~6 hours</td>\n</tr>\n<tr>\n<td>Network Namespace and veth Bridge</td>\n<td>~7 hours</td>\n</tr>\n<tr>\n<td>Cgroups v2 Resource Limits</td>\n<td>~6 hours</td>\n</tr>\n<tr>\n<td>User Namespace and Rootless Setup</td>\n<td>~6 hours</td>\n</tr>\n<tr>\n<td><strong>Total</strong></td>\n<td><strong>~30 hours</strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"definition-of-done\">Definition of Done</h2>\n<p>The project is complete when:</p>\n<ul>\n<li>Running <code>ps aux</code> inside the container shows the init process as PID 1 and no host processes.</li>\n<li>The command <code>ls /</code> inside the container shows only the Alpine rootfs; the host filesystem is inaccessible.</li>\n<li>The container successfully executes <code>ping 8.8.8.8</code> and resolves hostnames via <code>/etc/resolv.conf</code>.</li>\n<li>A &quot;fork bomb&quot; or memory-exhaustion script run inside the container is terminated by the kernel without crashing the host.</li>\n<li>The runtime launches the container successfully when executed by a non-root user.</li>\n</ul>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>\n---\n\n# üìö Before You Read This: Prerequisites &amp; Further Reading\n\n&gt; **Read these first.** The Atlas assumes you are familiar with the foundations below.\n&gt; Resources are ordered by when you should encounter them ‚Äî some before you start, some at specific milestones.\n\n### üõ†Ô∏è Core Primitives: Clone &amp; Namespaces\n*   **Spec**: [man 7 namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)\n*   **Code**: [runc/libcontainer/namespaces_linux.go](https://github.com/opencontainers/runc/blob/main/libcontainer/namespaces_linux.go) ‚Äî See how production runtimes map OCI specs to `CLONE_NEW*` flags.\n*   **Best Explanation**: [Namespaces in Operation](https://lwn.net/Articles/531114/) by Michael Kerrisk. Read the &quot;Introduction&quot; and &quot;PID Namespaces&quot; sections.\n*   **Why**: This series by the man-page maintainer is the definitive technical history of how namespaces were integrated into the kernel.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 1** to understand the &quot;Why&quot; behind the bitmask flags you are about to use.\n\n### üßü PID 1 &amp; The Zombie Problem\n*   **Code**: [krallin/tini/src/tini.c](https://github.com/krallin/tini/blob/master/src/tini.c) ‚Äî Specifically the `wait_and_forward_signal` loop.\n*   **Best Explanation**: [Docker and the PID 1 Zombie Reaping Problem](https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/) by Phusion.\n*   **Why**: It explains the Unix process lifecycle transitions (orphaning/reaping) that cause real-world production leaks in containers.\n*   **Pedagogical Timing**: Read **AFTER Milestone 1** to appreciate why your `while(1)` reaper loop is a critical stability feature, not just boilerplate.\n\n### üìÇ Filesystem Isolation: Pivot_root\n*   **Spec**: [man 2 pivot_root](https://man7.org/linux/man-pages/man2/pivot_root.2.html) ‚Äî Read the &quot;Notes&quot; section regarding the 7 kernel checks.\n*   **Code**: [runc/libcontainer/rootfs_linux.go](https://github.com/opencontainers/runc/blob/main/libcontainer/rootfs_linux.go) ‚Äî Look for the `pivotRoot` function.\n*   **Best Explanation**: [Path resolution: the kernel's perspective](https://lwn.net/Articles/649115/) by Neil Brown.\n*   **Why**: Understanding how the kernel walks a path is the only way to truly grasp how `pivot_root` physically disconnects the process from the host.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 2** to avoid the &quot;Invalid Argument&quot; errors caused by failing the kernel's mount-point requirements.\n\n### üåê Networking: Veth &amp; Bridges\n*   **Code**: [linux/drivers/net/veth.c](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c) ‚Äî See `veth_xmit` to confirm it‚Äôs just a pointer handoff.\n*   **Best Explanation**: [Container Networking From Scratch](https://iximiuz.com/en/posts/container-networking-is-simple/) by Ivan Velichko.\n*   **Why**: It provides the best visual mental model of how packets cross namespace boundaries via virtual wires.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 3** to visualize the &quot;Two-Phase Dance&quot; before you implement the synchronization pipe.\n\n### ‚öñÔ∏è Resource Control: Cgroups v2\n*   **Spec**: [Control Group v2 Documentation](https://www.kernel.org/doc/Documentation/admin-guide/cgroup-v2.rst)\n*   **Code**: [systemd/src/core/cgroup.c](https://github.com/systemd/systemd/blob/main/src/core/cgroup.c) ‚Äî How the world's most common init system manages the unified hierarchy.\n*   **Best Explanation**: [Understanding Cgroups v2](https://facebookmicrosites.github.io/cgroup2/docs/overview.html) by Facebook Engineering.\n*   **Why**: Facebook (Meta) was the primary driver for v2; this guide explains the &quot;No Internal Process&quot; rule which is the biggest architectural shift from v1.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 4** to understand why you must enable controllers in the `subtree_control` file.\n\n### ‚è±Ô∏è CPU Scheduling: CFS Bandwidth\n*   **Paper**: [Design of the CFS Bandwidth Controller](https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html) (Kernel Docs).\n*   **Best Explanation**: [Demystifying Kubernetes CPU Limits](https://itnext.io/demystifying-kubernetes-cpu-limits-7ed847895088) by Omkar Birade.\n*   **Why**: It explains the &quot;Sawtooth&quot; performance degradation caused by period/quota mismatches.\n*   **Pedagogical Timing**: Read **DURING Milestone 4** while you are running the `cpu_stress` test to interpret your `cpu.stat` results.\n\n### üë§ Identity: User Namespaces\n*   **Best Explanation**: [User Namespaces: A Practical Guide](https://lwn.net/Articles/532593/) by Michael Kerrisk.\n*   **Code**: [shadow-utils/src/newuidmap.c](https://github.com/shadow-utils/shadow-utils/blob/master/src/newuidmap.c) ‚Äî The privileged helper that validates `/etc/subuid`.\n*   **Why**: It clarifies the &quot;Scoped Capabilities&quot; model which is counter-intuitive to traditional Unix security.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 5** to understand why your container has `CAP_SYS_ADMIN` inside but `EPERM` on the host.\n\n### üõ°Ô∏è Security: Capabilities &amp; Seccomp\n*   **Spec**: [man 7 capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html)\n*   **Best Explanation**: [Container Security: A Guide to User Namespaces and Capabilities](https://sysdig.com/blog/linux-capabilities-docker/) by Sysdig.\n*   **Why**: This resource bridges the gap between raw kernel bits and how Docker/Kubernetes use &quot;Capability Dropping&quot; for hardening.\n*   **Pedagogical Timing**: Read **AFTER Milestone 5** to round out your understanding of the container's security profile.\n\n### üê≥ The Production Standard: OCI &amp; Runc\n*   **Spec**: [OCI Runtime Specification](https://github.com/opencontainers/runtime-spec)\n*   **Why**: This is the industry standard that defines exactly how the variables you've built (rootfs, namespaces, cgroups) should be formatted in a `config.json`.\n*   **Pedagogical Timing**: Read **AFTER finishing the project** to see how your &quot;basic&quot; container matches the industrial-grade specification.\n\n---\n\n# Container (Basic): Linux Namespace Isolation, Cgroups, and Rootless Containers from Scratch\n\nThis project builds a minimal container runtime from scratch using raw Linux kernel primitives ‚Äî no Docker, no runc, no abstraction layers. You will invoke clone(), unshare(), pivot_root(), and write to cgroup filesystem entries directly, constructing process isolation (PID namespace), filesystem isolation (mount namespace + pivot_root), network isolation (network namespace + veth pairs + bridge), resource limits (cgroups v2), and unprivileged execution (user namespaces) piece by piece.\n\nThe journey reveals that containers are not lightweight VMs ‚Äî they are carefully orchestrated kernel namespace boundaries combined with resource accounting. Every milestone peels back a layer of the illusion that Docker presents, exposing the syscalls, the /proc filesystem mechanics, and the security boundaries that production container runtimes depend on. By the end, you'll have a working container runtime that can isolate a process tree, limit its resources, give it its own network stack, and run without root privileges.\n\nThis is intermediate-level systems programming: you need comfort with fork/exec/wait and basic Linux filesystem concepts, but we'll teach the namespace-specific syscall semantics, mount propagation subtleties, and cgroup filesystem conventions as we go.\n\n\n\n&lt;!-- MS_ID: container-basic-m1 --&gt;\n# Milestone 1: PID and UTS Namespace Isolation\n## The Illusion You Are About to Build\nDocker runs a process. You type `ps aux` inside the container and see one process with PID 1. You type `ps aux` on the host and see that same process with PID 47832. Same process, two different PIDs, two different realities.\nThis isn't virtualization. There's no hypervisor, no emulated CPU, no separate kernel. The process is running natively on your CPU, in your kernel, with your scheduler. The kernel is simply maintaining *two simultaneous views* of the same process tree ‚Äî one for the host, one for the container ‚Äî and each view reports a different PID for the same physical process.\nThat mechanism is called a **PID namespace**, and by the end of this milestone, you will have built it from scratch.\nBut there's a twist. When you clone a process into a new PID namespace, the child doesn't just get a different number ‚Äî it becomes something fundamentally different at the kernel level. It becomes PID 1. And PID 1 has responsibilities that most processes never have to think about.\n\n![PID Namespace Dual View ‚Äî Inside vs Outside](./diagrams/diag-pid-ns-dual-view.svg)\n\n---\n## The Tension: Why Namespaces Exist\n[[EXPLAIN:linux-namespace-concept-‚Äî-what-kernel-resources-are-virtualized|Linux namespace concept ‚Äî what kernel resources are virtualized]]\nImagine running two applications on the same machine. Application A spawns 50 worker processes. Application B also spawns workers. Without isolation, they share:\n- **The PID space**: App A's process might be PID 1000, App B's might be PID 1001. If App B wants to send a signal to its own worker by PID, it must be careful not to accidentally target App A's processes.\n- **The hostname**: If App A calls `sethostname(&quot;web-server-a&quot;)`, that change is instantly visible to App B. Both apps now think they're on a machine called &quot;web-server-a.&quot;\n- **The filesystem mount table**: If App A mounts a secret volume at `/data`, App B can see it.\n- **The network interfaces**: App A can listen on port 80 or sniff App B's network traffic.\nThe traditional Unix answer to this was: &quot;run as different users and use permissions.&quot; But permissions are coarse. They prevent *access*, not *awareness*. App B still sees App A's processes in `ps`. They still share a hostname.\nThe Linux kernel answer, developed from 2006 onward, is **namespaces**: partition the kernel's global data structures so each process group sees its own private view. The kernel maintains one process table, one routing table, one mount table ‚Äî but namespace wrappers filter which entries each process can see.\n| Namespace | Flag | Virtualizes |\n|-----------|------|-------------|\n| PID | `CLONE_NEWPID` | Process IDs and process tree |\n| UTS | `CLONE_NEWUTS` | Hostname and NIS domain name |\n| Mount | `CLONE_NEWNS` | Filesystem mount table |\n| Network | `CLONE_NEWNET` | Network interfaces, routing, iptables |\n| User | `CLONE_NEWUSER` | UIDs, GIDs, capabilities |\n| IPC | `CLONE_NEWIPC` | System V IPC, POSIX message queues |\n| Cgroup | `CLONE_NEWCGROUP` | Cgroup root view |\nYou're implementing PID and UTS namespaces in this milestone. Each is created with a single flag passed to `clone()`.\n\n![Linux Namespace Taxonomy ‚Äî What Each Namespace Virtualizes](./diagrams/diag-namespace-taxonomy.svg)\n\n---\n## The Syscall That Makes It Happen: `clone()`\n[[EXPLAIN:clone()-syscall-and-its-relationship-to-fork()|clone() syscall and its relationship to fork()]]\n`fork()` creates a child process that is a copy of the parent, inheriting all the parent's namespaces. That's fine for normal processes ‚Äî but useless for containers, where you *want* the child to live in different namespaces.\n`clone()` is `fork()`'s lower-level cousin. It creates a new process (or thread) with precise control over what is shared and what is separated. Where `fork()` has a fixed behavior, `clone()` takes a `flags` argument that is a bitmask of decisions:\n```c\n#include &lt;sched.h&gt;\n// fork() equivalent in clone():\npid_t pid = clone(child_fn, stack_top, SIGCHLD, arg);\n// Container child with new PID and UTS namespaces:\npid_t pid = clone(child_fn, stack_top,\n                  CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD,\n                  arg);</code></pre></div>\n<p>The <code>SIGCHLD</code> flag at the end tells the kernel to send SIGCHLD to the parent when the child exits ‚Äî this is what makes <code>waitpid()</code> work on the returned PID. Without it, the parent won&#39;t get notified of child exit.\nThe key difference from <code>fork()</code>: <code>clone()</code> requires you to provide a <strong>child stack</strong>. This is where the design gets hardware-specific.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-clone-fork-comparison.svg\" alt=\"clone() vs fork() vs unshare()+fork() ‚Äî Syscall Comparison\"></p>\n<h3 id=\"stack-allocation-for-clone\">Stack Allocation for <code>clone()</code></h3>\n<p>[[EXPLAIN:stack-allocation-for-clone()-‚Äî-mmap-+-stack-direction|Stack allocation for clone() ‚Äî mmap + stack direction]]\nOn x86-64 Linux, the stack grows <strong>downward</strong> ‚Äî from high addresses toward low addresses. When you call a function, the stack pointer (<code>rsp</code>) decreases. When the function returns, it increases.\n<code>clone()</code> needs you to hand it a stack for the child to use. The signature says <code>void *stack</code> ‚Äî but this means the <strong>bottom</strong> of the allocated memory region, and you must pass the <strong>top</strong> (highest address) to <code>clone()</code> as the child&#39;s starting stack pointer.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mman.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1 MiB stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Allocate stack memory using mmap (not malloc ‚Äî mmap gives page-aligned memory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// with guard page support if you add PROT_NONE at the bottom)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, STACK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   MAP_PRIVATE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_ANONYMOUS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_STACK,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (stack </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MAP_FAILED) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mmap stack\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CRITICAL: pass the TOP of the stack (stack + STACK_SIZE),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// not the bottom. x86-64 stack grows downward.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> child_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_fn, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        &#x26;</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p><code>MAP_STACK</code> is a hint to the kernel that this region will be used as a stack ‚Äî on Linux it&#39;s currently a no-op, but it&#39;s the correct semantic flag to use. <code>MAP_ANONYMOUS</code> means the memory isn&#39;t backed by a file. <code>MAP_PRIVATE</code> means writes aren&#39;t visible to other processes.\nWhy <code>mmap</code> instead of <code>malloc</code>? Two reasons:</p>\n<ol>\n<li><code>mmap</code> returns page-aligned memory (4 KiB alignment), which the kernel requires for stack regions.</li>\n<li>You can add a guard page ‚Äî a <code>PROT_NONE</code> page at the bottom ‚Äî that causes a segfault if the stack overflows, rather than silent memory corruption.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Optional but recommended: add a guard page at the bottom</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// to catch stack overflows</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mprotect</span><span style=\"color:#E1E4E8\">(stack, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, PROT_NONE);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Then stack_top is still stack + STACK_SIZE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The usable stack is [stack + 4096, stack + STACK_SIZE)</span></span></code></pre></div>\n\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-clone-stack-layout.svg\" alt=\"clone() Stack Allocation ‚Äî Memory Layout\"></p>\n<hr>\n<h2 id=\"what-happens-inside-the-child\">What Happens Inside the Child</h2>\n<p>When <code>clone()</code> executes with <code>CLONE_NEWPID</code>, the child process starts executing <code>container_fn</code>. From inside <code>container_fn</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> container_fn</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This process's PID inside the namespace: 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This process's PID on the host: whatever clone() returned to the parent</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Inside container, PID = </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Prints: Inside container, PID = 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-child-is-pid-1-inside-its-namespace-the-parent-received-the-host-pid-from-clone-perhaps-47832-but-being-pid-1-is-not-just-a-number-this-is-the-revelation\">The child is PID 1 inside its namespace. The parent received the host PID from <code>clone()</code> ‚Äî perhaps 47832.\nBut being PID 1 is not just a number. This is the revelation.</h2>\n<h2 id=\"the-revelation-pid-1-is-not-just-a-label\">The Revelation: PID 1 Is Not Just a Label</h2>\n<p>Here is what most developers assume: PID 1 inside a container is cosmetic. The process is identical to any other child process ‚Äî it just happens to report PID 1 when it calls <code>getpid()</code>. The namespace is a labeling system.\n<strong>This assumption is wrong. The kernel treats namespace-PID-1 as a true init process.</strong>\nThree behaviors distinguish PID 1 in any PID namespace from every other process:</p>\n<h3 id=\"1-signal-immunity\">1. Signal Immunity</h3>\n<p>On the host, you cannot kill PID 1 (the system&#39;s <code>init</code>/<code>systemd</code>) with <code>SIGKILL</code> or <code>SIGTERM</code> unless you&#39;re root and the process has explicitly registered a signal handler. The same applies to PID 1 inside a namespace: <strong>the kernel will not deliver SIGKILL or SIGTERM to PID 1 from outside the namespace unless that process has installed a handler for those signals.</strong>\nThis is why <code>docker stop</code> sends SIGTERM, waits for a grace period (default 10 seconds), then sends SIGKILL. The SIGTERM goes to the container&#39;s PID 1. If that process doesn&#39;t handle SIGTERM, it won&#39;t stop ‚Äî and SIGKILL finally forces it. If your container&#39;s entrypoint is a shell script, the script (as PID 1) typically doesn&#39;t handle SIGTERM at all, which is why the app inside the script takes 10 seconds to stop.\nTools like <code>tini</code> and <code>dumb-init</code> exist specifically to be a proper PID 1: they handle signals correctly and forward them to child processes.</p>\n<h3 id=\"2-orphan-adoption-the-zombie-problem\">2. Orphan Adoption (The Zombie Problem)</h3>\n<p>When any process dies, its children don&#39;t die with it ‚Äî they become <strong>orphans</strong>. The kernel re-parents orphaned processes to PID 1 of their PID namespace. PID 1&#39;s job is to call <code>waitpid()</code> on these adopted children to collect their exit status and remove their entries from the process table. If PID 1 doesn&#39;t do this, the dead children remain in the process table as <strong>zombies</strong> ‚Äî consuming a PID slot and a process table entry.\nIn a container, if your entrypoint launches worker processes and those workers die before the entrypoint calls <code>wait()</code>, they become zombies. At scale ‚Äî thousands of containers, each leaking zombie PIDs ‚Äî you can exhaust the kernel&#39;s PID limit (default 32,768 on most systems) and prevent any new processes from spawning. This is a real production bug in containers that use naive shell scripts as entrypoints.\nYour implementation must include a zombie reaper.</p>\n<h3 id=\"3-namespace-death\">3. Namespace Death</h3>\n<p>When PID 1 of a namespace exits, <strong>the kernel kills every other process in that namespace with SIGKILL.</strong> There&#39;s no grace period, no cleanup opportunity for those processes ‚Äî they&#39;re terminated immediately. This is why your container exits when its main process exits. The kernel isn&#39;t &quot;watching&quot; for the last process ‚Äî it triggers on the death of exactly PID 1.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-pid1-init-responsibilities.svg\" alt=\"PID 1 Init Responsibilities ‚Äî Zombie Reaping Flow\"></p>\n<hr>\n<h2 id=\"building-the-pid-namespace-complete-implementation\">Building the PID Namespace: Complete Implementation</h2>\n<p>Here is a complete, working implementation that demonstrates PID namespace creation, UTS namespace creation, PID verification, and zombie reaping:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mman.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;signal.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#6A737D\">  // 1 MiB</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_HOSTNAME</span><span style=\"color:#9ECBFF\"> \"mycontainer\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configuration passed to the container's init function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span><span style=\"color:#6A737D\">  // Command to run inside the container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Zombie reaper: non-blocking collection of all dead children.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called periodically by the container's PID 1 to prevent zombie accumulation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WNOHANG makes waitpid() return immediately if no child has exited.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> reap_zombies</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Loop until waitpid returns 0 (no more dead children)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // or -1 (no children at all)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, WNOHANG)) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-init] reaped PID </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (exit </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    pid, </span><span style=\"color:#B392F0\">WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-init] reaped PID </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (signal </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    pid, </span><span style=\"color:#B392F0\">WTERMSIG</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The container's init process (PID 1 inside the namespace).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This function runs inside the new PID and UTS namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> container_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 1: Set the container hostname ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We're inside CLONE_NEWUTS, so this does NOT affect the host.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sethostname</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sethostname\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] hostname set to: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CONTAINER_HOSTNAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 2: Verify we are PID 1 inside the namespace ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] PID inside namespace: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Should print: 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 3: Spawn the user's requested command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We fork() here because exec() would replace us ‚Äî and we ARE PID 1.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If PID 1 exec()s and then exits, the namespace dies. We must stay alive.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Child process: run the requested command</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(cfg->argv[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], cfg->argv);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // execvp only returns on error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 4: Init process event loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PID 1 must stay alive and reap children.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We wait for the main child to exit, then clean up.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> exited </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // blocking wait for any child</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> child) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Our main process exited ‚Äî time to exit the namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // First, reap any lingering zombies.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            reap_zombies</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFEXITED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] main process exited with status </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                       WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">WIFSIGNALED</span><span style=\"color:#E1E4E8\">(status)) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] main process killed by signal </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                       WTERMSIG</span><span style=\"color:#E1E4E8\">(status));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // An adopted orphan child died ‚Äî reap it.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-init] reaped orphan PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, exited);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // No more children ‚Äî all done.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // waitpid was interrupted by a signal ‚Äî retry.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;command> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Example: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> /bin/sh</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Allocate child stack ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // clone() requires us to provide a stack for the child.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // x86-64: stack grows downward, so we pass stack + STACK_SIZE (the top).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, STACK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       MAP_PRIVATE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_ANONYMOUS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_STACK,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stack </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MAP_FAILED) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mmap\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Guard page: catch stack overflows before they corrupt memory silently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mprotect</span><span style=\"color:#E1E4E8\">(stack, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, PROT_NONE) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mprotect guard page\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Non-fatal: continue without guard page</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Configure the container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#E1E4E8\"> cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .argv </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">],</span><span style=\"color:#6A737D\">  // The command the container should run</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Create the namespaces with clone() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CLONE_NEWPID: child gets new PID namespace, sees itself as PID 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CLONE_NEWUTS: child gets new UTS namespace, independent hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SIGCHLD: parent receives SIGCHLD when child exits (needed for waitpid)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Creating container with PID and UTS namespaces...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> container_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_init, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                &#x26;</span><span style=\"color:#E1E4E8\">cfg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (container_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clone\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Common error: EPERM means you need root (or user namespace first)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EPERM) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Hint: run as root or add CAP_SYS_ADMIN capability</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container running with host PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Inside the container, that process sees PID: 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"waitpid\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container exited</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> container_m1</span><span style=\"color:#9ECBFF\"> container_m1.c</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container_m1</span><span style=\"color:#9ECBFF\"> /bin/bash</span></span></code></pre></div>\n<blockquote>\n<p><strong>Why <code>sudo</code>?</strong> Creating PID namespaces requires <code>CAP_SYS_ADMIN</code> ‚Äî a Linux capability that allows privileged operations. Without user namespace support (Milestone 5), you need root. We&#39;ll remove this requirement when we implement <code>CLONE_NEWUSER</code>.</p>\n</blockquote>\n<hr>\n<h2 id=\"verifying-isolation-the-procselfstatus-nspid-field\">Verifying Isolation: The <code>/proc/self/status</code> NSpid Field</h2>\n<p>The kernel exposes namespace PID information through <code>/proc</code>. Every process&#39;s <code>/proc/self/status</code> file contains a line called <code>NSpid</code> that lists the process&#39;s PID in each nested namespace, from outermost to innermost.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inside the container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/self/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> NSpid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># NSpid:  1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Outside the container (replace 47832 with the actual host PID):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> NSpid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># NSpid:  47832   1</span></span></code></pre></div>\n<p>The <code>NSpid</code> field shows PIDs separated by tabs. From outside (the host), the container&#39;s init process has two PIDs: its host PID (47832) and its namespace-local PID (1). From inside the container, you only see the innermost namespace&#39;s view: <code>1</code>.\nThis is exactly how container monitoring tools like cAdvisor and Prometheus node-exporter correlate container metrics to host processes ‚Äî they read <code>/proc/&lt;host_pid&gt;/status</code> and extract the NSpid field to map between container PID and host PID.\nAdd this verification to your <code>container_init</code> function:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Verification: read and display our NSpid from /proc</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> verify_pid_namespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/self/status\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"r\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">f) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen /proc/self/status\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> line</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">fgets</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(line), f)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // NSpid line format: \"NSpid:\\t&#x3C;pid1>\\t&#x3C;pid2>\\t...\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">strncmp</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"NSpid:\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, line);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Should show: NSpid:\t1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Call <code>verify_pid_namespace()</code> at the top of <code>container_init</code> to see the PID namespace isolation confirmed.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-proc-filesystem-container-debugging.svg\" alt=\"/proc Filesystem for Container Debugging ‚Äî Key Files\"></p>\n<hr>\n<h2 id=\"the-uts-namespace-independent-hostname\">The UTS Namespace: Independent Hostname</h2>\n<p>UTS stands for &quot;Unix Time-sharing System&quot; ‚Äî a historical artifact from the <code>utsname</code> struct defined in POSIX, which stores the hostname and NIS domain name. The name is obscure; the functionality is simple: each UTS namespace has its own hostname that&#39;s writable independently.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-uts-hostname-isolation.svg\" alt=\"UTS Namespace Hostname Isolation ‚Äî Before/After\"></p>\n<p>With <code>CLONE_NEWUTS</code> in your <code>clone()</code> call:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Inside the container (runs in CLONE_NEWUTS):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sethostname</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mycontainer\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Affects ONLY this namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> hostname</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gethostname</span><span style=\"color:#E1E4E8\">(hostname, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(hostname));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Container hostname: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, hostname);</span><span style=\"color:#6A737D\">  // mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// On the host simultaneously:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// gethostname() still returns the original host hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The kernel maintains two separate copies of the hostname string</span></span></code></pre></div>\n<p>Verify from the outside:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># After launching your container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># your-actual-host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside the container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The host hostname is unchanged ‚Äî UTS namespace is working</span></span></code></pre></div>\n<h2 id=\"the-kernel-implementation-each-uts-namespace-contains-a-copy-of-the-new_utsname-struct-64-bytes-nodename65-sysname65-etc-sethostname-writes-to-the-struct-of-the-calling-process39s-uts-namespace-since-the-container-has-its-own-namespace-its-sethostname-call-writes-to-a-different-struct-than-the-host39s\">The kernel implementation: each UTS namespace contains a copy of the <code>new_utsname</code> struct (64 bytes: nodename[65], sysname[65], etc.). <code>sethostname()</code> writes to the struct of the calling process&#39;s UTS namespace. Since the container has its own namespace, its <code>sethostname()</code> call writes to a different struct than the host&#39;s.</h2>\n<h2 id=\"the-unshare-alternative\">The <code>unshare()</code> Alternative</h2>\n<p><code>clone()</code> creates a <em>new process</em> in new namespaces. But sometimes you want to move the <em>current process</em> into new namespaces without creating a child. That&#39;s <code>unshare()</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current process enters new namespaces</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">unshare</span><span style=\"color:#E1E4E8\">(CLONE_NEWUTS);</span><span style=\"color:#6A737D\">  // Now this process is in a new UTS namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sethostname</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"isolated\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Only affects this namespace</span></span></code></pre></div>\n<p><strong>Critical gotcha with <code>unshare(CLONE_NEWPID)</code></strong>: <code>unshare()</code> creates the new PID namespace but the <em>calling process</em> does NOT move into it. The calling process remains in its original PID namespace. The new namespace becomes active for <strong>children</strong> of the calling process. So after <code>unshare(CLONE_NEWPID)</code>, you must <code>fork()</code> to get a process that&#39;s actually PID 1 inside the new namespace.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Using unshare + fork to create PID namespace:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">unshare</span><span style=\"color:#E1E4E8\">(CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Child is PID 1 in the new namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span><span style=\"color:#6A737D\">  // Prints: 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ... container init logic ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parent is still in the original namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(child, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-clone-approach-is-cleaner-for-container-runtimes-because-you-get-the-namespace-creation-and-child-process-in-one-atomic-call-the-unshare-approach-is-used-by-the-unshare1-command-line-tool-and-by-kubernetes-when-a-pod-shares-namespaces-between-containers\">The <code>clone()</code> approach is cleaner for container runtimes because you get the namespace creation and child process in one atomic call. The <code>unshare()</code> approach is used by the <code>unshare(1)</code> command-line tool and by Kubernetes when a pod shares namespaces between containers.</h2>\n<h2 id=\"hardware-soul-what-the-kernel-is-actually-doing\">Hardware Soul: What the Kernel Is Actually Doing</h2>\n<p>Every time your container calls <code>getpid()</code>, the kernel executes this path:</p>\n<ol>\n<li><code>getpid()</code> ‚Üí <code>syscall(SYS_getpid)</code> ‚Üí trap into kernel</li>\n<li>Kernel looks up <code>current-&gt;nsproxy-&gt;pid_ns_for_children</code></li>\n<li>Walks the namespace chain to find the PID in the innermost namespace</li>\n<li>Returns that PID to userspace\n<strong>Cache behavior</strong>: The <code>task_struct</code> (kernel&#39;s process descriptor, ~7 KB on modern kernels) is typically cold on first access after a context switch ‚Äî it won&#39;t be in L1 cache. The namespace pointer chain adds 2-3 pointer dereferences. On a context switch, the TLB is partially flushed (PCID optimization reduces this), and the first access to the task&#39;s memory will incur TLB misses.\nFor <code>getpid()</code>: ~50-100 ns on a warm cache, ~500 ns on a cold cache with TLB misses. This is negligible for container overhead ‚Äî namespaces themselves add essentially zero CPU cost to process execution.\n<strong>The <code>clone()</code> call itself</strong>: Creating a PID namespace is a kernel-side operation that:</li>\n</ol>\n<ul>\n<li>Allocates a new <code>pid_namespace</code> struct (~200 bytes)</li>\n<li>Initializes an <code>idr</code> (ID radix tree) for PID allocation within the namespace</li>\n<li>Sets up the namespace&#39;s PID 1 slot</li>\n<li>Copies the parent&#39;s signal handlers (with <code>CLONE_NEWPID</code>, signals are <em>not</em> shared)</li>\n<li>Allocates the <code>task_struct</code> for the child\nTotal cost: one <code>clone()</code> with <code>CLONE_NEWPID | CLONE_NEWUTS</code> takes approximately 20-50 Œºs on modern hardware ‚Äî comparable to a normal <code>fork()</code>. This is why containers start in milliseconds while VMs take seconds: there&#39;s no hardware initialization, no firmware, no boot sequence.</li>\n</ul>\n<hr>\n<h2 id=\"pitfall-compendium-the-mistakes-that-will-cost-you-hours\">Pitfall Compendium: The Mistakes That Will Cost You Hours</h2>\n<h3 id=\"pitfall-1-passing-stack-bottom-instead-of-stack-top\">Pitfall 1: Passing Stack Bottom Instead of Stack Top</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG: passes the bottom of the stack</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack, flags, arg);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT: passes the top (x86-64 stack grows downward)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE, flags, arg);</span></span></code></pre></div>\n<p>Passing the wrong end causes immediate memory corruption. The child will write its first stack frame into whatever is below <code>stack</code> ‚Äî likely your program&#39;s heap or code. The resulting crash is often mysterious: a SIGSEGV in a totally unrelated part of the code, or silent data corruption that causes wrong behavior minutes later.</p>\n<h3 id=\"pitfall-2-sigchld-missing-from-clone-flags\">Pitfall 2: <code>SIGCHLD</code> Missing from <code>clone()</code> Flags</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG: parent can't waitpid() without SIGCHLD</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack_top, CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS, arg);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT: SIGCHLD enables the parent to use waitpid()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(fn, stack_top, CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SIGCHLD, arg);</span></span></code></pre></div>\n<p>Without <code>SIGCHLD</code>, <code>waitpid()</code> in the parent returns -1 with <code>ECHILD</code>. The child becomes an orphan that the host&#39;s <code>init</code> (systemd) will eventually reap.</p>\n<h3 id=\"pitfall-3-not-running-as-root-eperm\">Pitfall 3: Not Running as Root (EPERM)</h3>\n<p><code>CLONE_NEWPID</code> requires <code>CAP_SYS_ADMIN</code>. Without root:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EPERM</span><span style=\"color:#6A737D\">  // \"Operation not permitted\"</span></span></code></pre></div>\n<p>Solution for this milestone: run with <code>sudo</code>. Solution for production: combine with <code>CLONE_NEWUSER</code> (Milestone 5) to create user namespaces first, which allows unprivileged namespace creation.</p>\n<h3 id=\"pitfall-4-the-exec-trap-in-pid-1\">Pitfall 4: The <code>exec()</code> Trap in PID 1</h3>\n<p>If your container&#39;s init function directly calls <code>exec()</code> (replacing itself), <em>it</em> becomes the user process. When that user process exits, PID 1 exits, and the kernel kills the entire namespace. This is fine for single-process containers, but breaks multi-process scenarios. The correct pattern is <code>fork()</code> then <code>exec()</code> in the child, while the init stays alive as the reaper. This is exactly what Docker does ‚Äî and why <code>tini</code> exists as a minimal init that does nothing but the fork-exec-reap loop.</p>\n<h3 id=\"pitfall-5-unshareclone_newpid-without-subsequent-fork\">Pitfall 5: <code>unshare(CLONE_NEWPID)</code> Without Subsequent <code>fork()</code></h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG: calling process does NOT enter the new PID namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">unshare</span><span style=\"color:#E1E4E8\">(CLONE_NEWPID);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span><span style=\"color:#6A737D\">  // Still shows original PID, not 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT: fork() after unshare to get PID 1 in new namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">unshare</span><span style=\"color:#E1E4E8\">(CLONE_NEWPID);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span><span style=\"color:#6A737D\">  // Now prints 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"verification-checklist\">Verification Checklist</h2>\n<p>After implementing and running your code, verify each criterion manually:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># 1. Inside the container, verify PID 1:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $$</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should print: 1 (if shell is direct child) or close to 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. Verify NSpid field shows dual PIDs from outside:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># From the host, where $HOST_PID is what clone() returned:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#E1E4E8\">$HOST_PID</span><span style=\"color:#9ECBFF\">/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> NSpid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: NSpid:   &#x3C;host_pid>    1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. Verify hostname isolation:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host (new terminal):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># your-original-hostname  (unchanged)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. Test zombie reaping: inside container, run:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\"> &#x26;   </span><span style=\"color:#6A737D\"># Start a background process</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#9ECBFF\"> %1</span><span style=\"color:#6A737D\">       # Kill it</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#6A737D\">        # Should NOT show a zombie (Z state) if reaping works</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 5. Test namespace death: exit PID 1:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Exit the container ‚Äî verify all container processes stop on the host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ps aux | grep &#x3C;command_you_ran>  # Should show nothing</span></span></code></pre></div>\n<hr>\n<h2 id=\"understanding-the-process-tree\">Understanding the Process Tree</h2>\n<p>When your container is running, the host sees:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>systemd (PID 1)\n‚îî‚îÄ‚îÄ sudo (PID 47830)\n    ‚îî‚îÄ‚îÄ ./container_m1 (PID 47831)  ‚Üê your runtime\n        ‚îî‚îÄ‚îÄ container_init (PID 47832) ‚Üê PID 1 inside namespace\n            ‚îî‚îÄ‚îÄ /bin/bash (PID 47833) ‚Üê PID 2 inside namespace</code></pre></div>\n<p>Inside the container:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container_init (PID 1)  ‚Üê same process as host's 47832\n‚îî‚îÄ‚îÄ /bin/bash (PID 2)   ‚Üê same process as host's 47833</code></pre></div>\n<p>The kernel maintains both views simultaneously. The host sees the real PIDs. The namespace members see the virtualized PIDs. The PID table has entries for both mappings.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-clone-fork-comparison.svg\" alt=\"clone() vs fork() vs unshare()+fork() ‚Äî Syscall Comparison\"></p>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<p>Understanding PID namespaces and init process behavior is a seed that grows into a forest of systems knowledge:</p>\n<h3 id=\"1-why-docker-uses-tini\">1. Why Docker Uses <code>tini</code></h3>\n<p>The <code>--init</code> flag in <code>docker run --init</code> injects <code>tini</code> as PID 1. <code>tini</code> does exactly three things: installs signal handlers, <code>fork()</code>s your entrypoint as a child, and loops on <code>waitpid(-1, ...)</code>. Without it, if your application forks workers (as Node.js, Python multiprocessing, and Java do), the workers become zombies when they die. At scale ‚Äî thousands of requests, thousands of short-lived workers ‚Äî you exhaust the PID space. <code>tini</code>&#39;s entire codebase is ~200 lines of C doing exactly the init loop you just wrote.</p>\n<h3 id=\"2-signal-delivery-across-namespace-boundaries\">2. Signal Delivery Across Namespace Boundaries</h3>\n<p>When you run <code>docker kill &lt;container_id&gt;</code>, Docker&#39;s daemon calls <code>kill(host_pid, SIGTERM)</code> on the host. The kernel delivers this to the process identified by that host PID ‚Äî which is the container&#39;s PID 1. Inside the namespace, PID 1 receives the signal. If PID 1 handles SIGTERM by forwarding it to children, your application gets graceful shutdown. If not, after Docker&#39;s grace period, SIGKILL arrives and the namespace forcibly terminates. This is the entire reason for <code>docker stop</code>&#39;s 10-second default timeout ‚Äî it&#39;s not arbitrary, it&#39;s &quot;how long we give PID 1 to forward SIGTERM and shut down gracefully.&quot;</p>\n<h3 id=\"3-kubernetes-pod-pause-containers\">3. Kubernetes Pod Pause Containers</h3>\n<p>Every Kubernetes pod has an invisible &quot;pause&quot; container that runs <code>/pause</code> ‚Äî a binary that does nothing except call <code>pause()</code> (wait forever for a signal). This pause container is created first and holds the PID namespace. All other containers in the pod join this namespace via <code>setns(CLONE_NEWPID)</code>. The pause container is the pod&#39;s PID 1 and zombie reaper. This is why all containers in a pod share a process tree, can see each other&#39;s processes with <code>ps</code>, and why killing the pause container kills the entire pod. You just learned the mechanism that makes Kubernetes pod semantics work.</p>\n<h3 id=\"4-clone-flag-composition-is-additive-and-atomic\">4. <code>clone()</code> Flag Composition Is Additive and Atomic</h3>\n<p><code>CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUSER</code> ‚Äî you can compose any combination in a single <code>clone()</code> call. Real container runtimes (<code>runc</code>, used by Docker and Kubernetes) create all namespaces atomically in one <code>clone()</code> call. This atomicity matters: there&#39;s no window between namespace creations where the process is in a partial state. Next milestone (mount namespaces), you&#39;ll add <code>CLONE_NEWNS</code> to this call and everything composes cleanly.</p>\n<h3 id=\"5-proc-as-the-namespace-debugging-interface\">5. <code>/proc</code> as the Namespace Debugging Interface</h3>\n<p><code>/proc/&lt;pid&gt;/ns/</code> directory contains symbolic links for each namespace the process belongs to:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/47832/ns/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># pid -> pid:[4026532189]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># uts -> uts:[4026532190]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mnt -> mnt:[4026531840]  (still host's mount namespace ‚Äî next milestone!)</span></span></code></pre></div>\n<h2 id=\"the-numbers-in-brackets-are-namespace-inode-numbers-two-processes-in-the-same-namespace-have-the-same-inode-number-for-that-namespace-type-this-is-how-nsenter1-finds-and-joins-existing-namespaces-it-opens-the-symlink-and-calls-setns-with-the-file-descriptor\">The numbers in brackets are namespace inode numbers. Two processes in the same namespace have the same inode number for that namespace type. This is how <code>nsenter(1)</code> finds and joins existing namespaces ‚Äî it opens the symlink and calls <code>setns()</code> with the file descriptor.</h2>\n<h2 id=\"looking-ahead\">Looking Ahead</h2>\n<h2 id=\"you-now-have-a-container-that-isolates-its-process-tree-and-hostname-but-if-you-run-ls-inside-your-container-you-see-the-host39s-filesystem-if-you-run-ip-addr-you-see-the-host39s-network-interfaces-if-you-spawn-10000-processes-inside-your-container-they-consume-host-pids-the-next-milestone-mount-namespace-and-filesystem-isolation-adds-clone_newns-to-your-clone-call-and-uses-pivot_root-to-swap-the-container39s-root-filesystem-you39ll-finally-see-a-truly-isolated-filesystem-view-and-understand-why-chroot-is-weaker-than-pivot_root-from-a-security-standpoint-the-clone_newpid-clone_newuts-pair-you39ve-built-is-the-foundation-every-subsequent-namespace-flags-into-the-same-clone-call-the-architecture-you39ve-established-container_init-as-pid-1-zombie-reaper-loop-config-struct-passed-through-clone-is-the-skeleton-the-rest-of-the-milestones-flesh-out\">You now have a container that isolates its process tree and hostname. But if you run <code>ls /</code> inside your container, you see the host&#39;s filesystem. If you run <code>ip addr</code>, you see the host&#39;s network interfaces. If you spawn 10,000 processes inside your container, they consume host PIDs.\nThe next milestone (Mount Namespace and Filesystem Isolation) adds <code>CLONE_NEWNS</code> to your <code>clone()</code> call and uses <code>pivot_root()</code> to swap the container&#39;s root filesystem. You&#39;ll finally see a truly isolated filesystem view ‚Äî and understand why <code>chroot</code> is weaker than <code>pivot_root</code> from a security standpoint.\nThe <code>CLONE_NEWPID | CLONE_NEWUTS</code> pair you&#39;ve built is the foundation. Every subsequent namespace flags into the same <code>clone()</code> call. The architecture you&#39;ve established ‚Äî <code>container_init</code> as PID 1, zombie reaper loop, config struct passed through <code>clone()</code> ‚Äî is the skeleton the rest of the milestones flesh out.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m2 -->\n<!-- MS_ID: container-basic-m2 -->\n<h1 id=\"milestone-2-mount-namespace-and-filesystem-isolation\">Milestone 2: Mount Namespace and Filesystem Isolation</h1>\n<h2 id=\"the-illusion-you-are-about-to-shatter\">The Illusion You Are About to Shatter</h2>\n<p>Run your container from Milestone 1. Inside the shell, type <code>ls /</code>. You&#39;ll see the host&#39;s root filesystem ‚Äî <code>/etc</code>, <code>/home</code>, <code>/var</code>, <code>/root</code>. Every file on your machine is accessible. Your &quot;container&quot; is a lie.\nThe process tree is isolated. The hostname is isolated. But the filesystem is completely open. A process inside your container can read <code>/etc/passwd</code>, write to <code>/tmp</code>, and ‚Äî if it has the right permissions ‚Äî modify files that affect the host system. That&#39;s not a container. That&#39;s a renamed terminal window.\nThis milestone closes that gap. You will give the container its own root filesystem, one that contains only what you choose to put there. The host&#39;s filesystem will not just be hidden ‚Äî it will be genuinely inaccessible, unreachable through any path, invisible to the kernel&#39;s path resolution engine for processes inside the container.\nThe mechanism that makes this real is called <code>pivot_root()</code>. But before we get there, you need to understand why the obvious solution ‚Äî <code>chroot()</code> ‚Äî is not good enough, and why every production container runtime from Docker to Kubernetes uses <code>pivot_root()</code> instead.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-chroot-vs-pivot-root.svg\" alt=\"chroot() vs pivot_root() Security Comparison\"></p>\n<hr>\n<h2 id=\"the-fundamental-tension-shared-filesystem-multiple-worlds\">The Fundamental Tension: Shared Filesystem, Multiple Worlds</h2>\n<p>[[EXPLAIN:linux-namespace-concept-‚Äî-what-kernel-resources-are-virtualized|Linux namespace concept ‚Äî what kernel resources are virtualized]]\nThe Linux filesystem is a single global tree rooted at <code>/</code>. Every file, directory, device, and pseudo-filesystem hangs from that single root. The kernel maintains a <strong>mount table</strong> ‚Äî a data structure that maps directory paths to filesystem objects. When you open <code>/etc/passwd</code>, the kernel walks this table, finds which filesystem is mounted at <code>/</code> or <code>/etc</code>, and reads from it.\nMultiple processes on the same machine share this mount table. When you run <code>mount /dev/sdb1 /mnt/disk</code>, every process on the system immediately sees the new filesystem at <code>/mnt/disk</code>. Mount operations are global ‚Äî or at least they were, until Linux 2.4.19 introduced mount namespaces in 2002.\nThe constraint: <strong>you cannot give a process its own private filesystem view without either hardware virtualization (a hypervisor with emulated disks) or kernel namespace machinery.</strong> Hardware virtualization is expensive ‚Äî it requires copying entire filesystem images and booting a kernel. Namespace machinery is essentially free ‚Äî it&#39;s a pointer in the kernel&#39;s process descriptor.\nThe solution the kernel offers: give each process group its own mount table ‚Äî a <strong>mount namespace</strong>. Operations in one namespace don&#39;t affect others. A process in namespace A can mount and unmount filesystems freely; namespace B is untouched. Combined with a root directory swap (pivot_root), the container gets its own root ‚Äî and the host&#39;s filesystem disappears.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-mount-propagation-types.svg\" alt=\"Mount Propagation Types ‚Äî Shared, Private, Slave\"></p>\n<hr>\n<h2 id=\"why-chroot-is-not-enough-the-revelation\">Why <code>chroot()</code> Is Not Enough: The Revelation</h2>\n<p>Here is what most developers believe when they first encounter container isolation: <code>chroot()</code> provides real filesystem isolation. If you <code>chroot(&quot;/container/rootfs&quot;)</code>, the process can&#39;t escape to the host filesystem because <code>/</code> now points to <code>/container/rootfs</code>. The host&#39;s <code>/etc</code> is unreachable.\n<strong>This belief is wrong.</strong> <code>chroot()</code> is security theater for anything running with elevated privileges.\n<code>chroot()</code> does exactly one thing: it changes the <strong>path resolution starting point</strong> for the calling process. The kernel sets <code>task_struct-&gt;fs-&gt;root</code> to the new directory. When the process calls <code>open(&quot;/etc/passwd&quot;)</code>, the kernel starts path resolution at the new root instead of the real root. That&#39;s the entire implementation ‚Äî a pointer change.\nWhat <code>chroot()</code> does <em>not</em> do:</p>\n<ol>\n<li>It does not create a new mount namespace. The process still has access to the same mount table as the host.</li>\n<li>It does not remove the kernel&#39;s reference to the real root filesystem.</li>\n<li>It does not prevent a privileged process from escaping.\nThe classic <code>chroot()</code> escape ‚Äî known for decades, present in every security textbook ‚Äî works like this for a process with <code>CAP_SYS_CHROOT</code>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Classic chroot escape (educational ‚Äî shows why chroot is insufficient)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This works because chroot() only changes a pointer, not actual namespace boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 1: We're chrooted to /container/rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 2: Create a temporary directory to chroot into</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"escape_tmp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 3: Chroot into our temporary directory (moving root \"forward\")</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">chroot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"escape_tmp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 4: Walk up the directory tree past the original chroot boundary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Because chroot() didn't change the mount namespace, \"..\" still works</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// across the original chroot boundary if you chroot to a subdirectory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    chdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 5: Chroot to the current directory ‚Äî which is now the real /</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">chroot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\".\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// We're now unchrooted. Host filesystem fully accessible.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// open(\"/etc/shadow\", O_RDONLY) ‚Äî works.</span></span></code></pre></div>\n<p>This escape works because <code>chroot()</code> is a <em>per-process</em> path resolution change, not a <em>namespace</em> change. The mount table is still shared. The kernel&#39;s VFS (Virtual Filesystem Switch) layer still has references to the real root. A sufficiently privileged process can navigate above the chroot boundary by abusing the still-shared mount namespace.\n[[EXPLAIN:pivot_root()-vs-chroot()-security-guarantees|pivot_root() vs chroot() security guarantees]]\n<code>pivot_root()</code> is categorically different. It operates at the <strong>mount namespace level</strong>. It atomically:</p>\n<ol>\n<li>Makes the new root directory the root mount point of the current mount namespace</li>\n<li>Moves the old root to a subdirectory you specify (so you can unmount it)</li>\n<li>Optionally allows you to completely unmount the old root ‚Äî removing every kernel reference to it\nAfter <code>pivot_root()</code> followed by <code>umount2(old_root, MNT_DETACH)</code>, there is no path the container can walk to reach the host filesystem. There&#39;s no <code>..</code> trick, no <code>chroot</code> escape, no file descriptor inheritance trick that works ‚Äî because the kernel literally has no mount namespace entry pointing to the host&#39;s filesystem tree. It&#39;s not hidden. It&#39;s <em>gone</em> from the container&#39;s perspective.\nThis is why Docker, containerd, runc, LXC, podman, and every serious container runtime use <code>pivot_root()</code>. <code>chroot()</code> is a 1979 Unix feature. <code>pivot_root()</code> is a 2001 Linux feature built specifically for containers (and Linux-VServer before that).\nThe Leaky Vessels CVE (2024) exploited a container runtime that didn&#39;t properly complete the old-root unmount sequence ‚Äî leaving a kernel reference to the host filesystem accessible through a specific file descriptor path. Understanding the <code>pivot_root()</code> + <code>umount2(MNT_DETACH)</code> sequence exactly is not academic. It&#39;s the difference between a container and a container escape.</li>\n</ol>\n<hr>\n<h2 id=\"mount-namespaces-the-foundation\">Mount Namespaces: The Foundation</h2>\n<p>Before <code>pivot_root()</code> can work, you need a mount namespace. A mount namespace is a private copy of the mount table ‚Äî the kernel&#39;s mapping of directory paths to filesystem objects.\nCreating one is simple: add <code>CLONE_NEWNS</code> to your <code>clone()</code> call:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">pid_t</span><span style=\"color:#E1E4E8\"> container_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_init, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUTS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            &#x26;</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<h2 id=\"clone_newns-is-historically-named-quotnsquot-originally-referred-only-to-mount-namespaces-because-they-were-the-first-namespace-type-added-to-linux-2419-2002-all-other-namespace-flags-were-added-later-with-more-descriptive-names-clone_newpid-clone_newnet-etc-when-the-child-process-starts-with-clone_newns-it-receives-a-copy-of-the-parent39s-mount-table-initially-the-child39s-mount-namespace-looks-identical-to-the-host39s-same-filesystems-same-mount-points-the-isolation-begins-when-the-child-makes-mountunmount-operations-those-changes-are-invisible-to-the-host-and-the-host39s-subsequent-mounts-are-invisible-to-the-child-but-there39s-a-critical-subtlety-even-with-a-private-mount-namespace-if-mount-events-can-propagate-between-namespaces-you-lose-isolation-this-is-where-mount-propagation-types-become-essential\"><code>CLONE_NEWNS</code> is historically named ‚Äî &quot;NS&quot; originally referred only to mount namespaces because they were the first namespace type added to Linux (2.4.19, 2002). All other namespace flags were added later with more descriptive names (<code>CLONE_NEWPID</code>, <code>CLONE_NEWNET</code>, etc.).\nWhen the child process starts with <code>CLONE_NEWNS</code>, it receives a <strong>copy</strong> of the parent&#39;s mount table. Initially, the child&#39;s mount namespace looks identical to the host&#39;s ‚Äî same filesystems, same mount points. The isolation begins when the child makes mount/unmount operations: those changes are invisible to the host, and the host&#39;s subsequent mounts are invisible to the child.\nBut there&#39;s a critical subtlety: even with a private mount namespace, if mount events can <strong>propagate</strong> between namespaces, you lose isolation. This is where mount propagation types become essential.</h2>\n<h2 id=\"mount-propagation-the-hidden-complexity\">Mount Propagation: The Hidden Complexity</h2>\n<p>[[EXPLAIN:mount-propagation-types-(shared,-private,-slave)|Mount propagation types (shared, private, slave)]]\nLinux mounts have a propagation mode that determines whether mount/unmount events in one namespace (or peer group) propagate to other namespaces. There are four modes:</p>\n<table>\n<thead>\n<tr>\n<th>Mode</th>\n<th>Flag</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Shared</strong></td>\n<td><code>MS_SHARED</code></td>\n<td>Mount events propagate to all peer mounts in the same peer group, and new mounts in the subtree are shared</td>\n</tr>\n<tr>\n<td><strong>Private</strong></td>\n<td><code>MS_PRIVATE</code></td>\n<td>Mount events are completely isolated ‚Äî no propagation in or out</td>\n</tr>\n<tr>\n<td><strong>Slave</strong></td>\n<td><code>MS_SLAVE</code></td>\n<td>Mount events propagate FROM the master TO this mount, but not in reverse</td>\n</tr>\n<tr>\n<td><strong>Unbindable</strong></td>\n<td><code>MS_UNBINDABLE</code></td>\n<td>Private + cannot be bind-mounted</td>\n</tr>\n<tr>\n<td>On a typical Linux system, the root filesystem is mounted as <strong>shared</strong> (<code>MS_SHARED</code>). This means if you create a mount namespace with <code>CLONE_NEWNS</code>, your copy of the mount table inherits the shared propagation type. Any mount operation you perform inside the container <strong>immediately propagates to the host&#39;s mount namespace</strong>.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>This is the subtle trap: <code>CLONE_NEWNS</code> gives you a copy of the mount table, but not isolation from propagation. If you mount <code>/proc</code> inside your container (for the container&#39;s process list) and the root is still shared, that mount event propagates back to the host. The host&#39;s <code>/proc</code> doesn&#39;t change (because the bind would fail due to path differences), but the propagation attempt happens ‚Äî and in more complex scenarios, it causes real leaks.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>The fix: immediately after entering the new mount namespace, make the root private:</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Inside container_init, FIRST thing after entering the mount namespace:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MS_REC ensures the flag applies recursively to all submounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_REC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_PRIVATE, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount MS_PRIVATE\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>This <code>mount()</code> call doesn&#39;t mount anything new. The <code>NULL</code> source and <code>MS_PRIVATE</code> flag with <code>MS_REC</code> recursively change the propagation type of every existing mount in the namespace to private. From this point forward, no mount event in the container leaks to the host, and no host mount event propagates into the container.\n<strong>Why <code>MS_REC</code>?</strong> The mount table is a tree. <code>/</code> might be shared, but <code>/proc</code> has its own mount entry, <code>/sys</code> has its own, and so on. Without <code>MS_REC</code>, you&#39;d only make <code>/</code> private ‚Äî all sub-mounts would remain shared. <code>MS_REC</code> walks the entire tree recursively.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-mount-propagation-types.svg\" alt=\"Mount Propagation Types ‚Äî Shared, Private, Slave\"></p>\n<blockquote>\n<p><strong>Connection: Docker Volumes and Bind Mounts</strong>\nThis propagation model is exactly why <code>docker run -v /host/data:/container/data</code> works selectively. The bind mount uses <code>MS_SHARED</code> propagation on the specific mount point ‚Äî so changes to <code>/host/data</code> are visible inside the container and vice versa. But the container&#39;s other mounts remain private. This is also why Kubernetes <code>hostPath</code> mounts with <code>MountPropagation: Bidirectional</code> are considered dangerous ‚Äî they create shared-propagation mounts that allow the container to affect the host&#39;s filesystem namespace.</p>\n</blockquote>\n<hr>\n<h2 id=\"building-the-new-root-filesystem\">Building the New Root Filesystem</h2>\n<p>Before <code>pivot_root()</code>, you need something to pivot to: a new root filesystem with the minimal structure a container process needs.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-container-rootfs-structure.svg\" alt=\"Minimal Container Root Filesystem ‚Äî Directory Layout\"></p>\n<p>The minimal directory structure:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/newroot/\n‚îú‚îÄ‚îÄ proc/          # For mounting /proc (container process list)\n‚îú‚îÄ‚îÄ sys/           # For mounting /sys (kernel parameters)\n‚îú‚îÄ‚îÄ dev/           # For device nodes\n‚îÇ   ‚îú‚îÄ‚îÄ null       # /dev/null (programs write garbage here)\n‚îÇ   ‚îú‚îÄ‚îÄ zero       # /dev/zero (source of zero bytes)\n‚îÇ   ‚îú‚îÄ‚îÄ random     # /dev/random (entropy source)\n‚îÇ   ‚îî‚îÄ‚îÄ urandom    # /dev/urandom (non-blocking entropy)\n‚îú‚îÄ‚îÄ etc/\n‚îÇ   ‚îî‚îÄ‚îÄ resolv.conf  # DNS configuration\n‚îú‚îÄ‚îÄ tmp/           # Temporary files\n‚îú‚îÄ‚îÄ .pivot_old/    # Staging directory for old root during pivot\n‚îî‚îÄ‚îÄ [your container's rootfs content]</code></pre></div>\n<p>For testing, you can use a minimal Alpine Linux rootfs or a directory tree you construct manually. For the purposes of this implementation, we&#39;ll assume you have a rootfs directory at a known path.\nCreate the structure in your setup:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create essential directories in the new rootfs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> create_rootfs_dirs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">dirs</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sys\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"dev\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"etc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tmp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\".pivot_old\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">dirs</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, rootfs, </span><span style=\"color:#FFAB70\">dirs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> EEXIST) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-pivot_root-sequence-step-by-step\">The <code>pivot_root()</code> Sequence: Step by Step</h2>\n<p><code>pivot_root()</code> has precise requirements. Violating any of them returns <code>EINVAL</code> ‚Äî a frustratingly generic error code. Let&#39;s understand each requirement before writing the code.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-pivot-root-sequence.svg\" alt=\"pivot_root() Atomic Root Swap ‚Äî Step-by-Step\"></p>\n<p><strong>Requirement 1: The new root must be a mount point.</strong>\n<code>pivot_root()</code> operates on mount points ‚Äî entries in the mount table ‚Äî not arbitrary directories. A directory that isn&#39;t a mount point isn&#39;t tracked by the mount table, so <code>pivot_root()</code> can&#39;t swap it in as root.\nHow do you make a directory a mount point without mounting a separate filesystem onto it? The <strong>bind-mount-to-self</strong> trick:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Bind-mount newroot onto itself ‚Äî now it IS a mount point</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(rootfs_path, rootfs_path, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_REC, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bind-mount rootfs to itself\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>MS_BIND</code> creates a bind mount ‚Äî it makes a directory accessible at another path (or the same path in this case). The source and destination are the same path. The effect: the kernel creates a new mount table entry pointing to the same filesystem block device, but at this specific path. Now the directory is a mount point. <code>MS_REC</code> ensures any nested mounts within the directory are also bind-mounted.\n<strong>Requirement 2: The new root and the current root must be on different filesystems</strong> (or the new root must be a bind mount, which satisfies this in practice).\nThe bind-mount-to-self satisfies this because the bind mount is a <em>new mount point</em> ‚Äî even though it points to the same underlying filesystem, it&#39;s a distinct entry in the mount table with a new mount ID.\n<strong>Requirement 3: The old root destination must exist inside the new root.</strong>\n<code>pivot_root(new_root, put_old)</code> moves the old root to <code>put_old</code>. This directory must exist inside <code>new_root</code>. In our case: <code>rootfs/.pivot_old</code>.\n<strong>The complete <code>pivot_root()</code> sequence:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> pivot_to_rootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(old_root), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/.pivot_old\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 1: Bind-mount rootfs to itself to make it a mount point ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(rootfs, rootfs, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_REC, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bind-mount rootfs to self\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 2: pivot_root ‚Äî atomically swap root filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // new_root: our container rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // put_old:  where to mount the current root (must be inside new_root)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_pivot_root, rootfs, old_root) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 3: Change working directory to new root ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // After pivot_root, cwd might be in the old root ‚Äî cd to / to fix this</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">chdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"chdir /\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 4: Unmount the old root with MNT_DETACH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MNT_DETACH: lazy unmount ‚Äî the filesystem becomes unreachable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // immediately, but the kernel waits for all open file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // on it to close before freeing the memory.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">umount2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">, MNT_DETACH) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"umount2 old root\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 5: Remove the staging directory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">rmdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Non-fatal ‚Äî the unmount succeeded, this is cosmetic cleanup</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"rmdir .pivot_old\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<blockquote>\n<p><strong>Note on <code>syscall(SYS_pivot_root, ...)</code></strong>: The <code>pivot_root()</code> system call is not wrapped by glibc in a standard header-accessible function (unlike <code>mount()</code>, <code>clone()</code>, etc.). You must call it via <code>syscall()</code> directly. Include <code>&lt;sys/syscall.h&gt;</code> and <code>&lt;unistd.h&gt;</code>.</p>\n</blockquote>\n<h3 id=\"what-happens-at-each-step-in-the-kernel\">What Happens at Each Step in the Kernel</h3>\n<p><strong>Before pivot_root</strong>: Mount namespace contains:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/          ‚Üí host root filesystem (device sda1)\n/proc      ‚Üí procfs\n/sys       ‚Üí sysfs\n/container/rootfs  ‚Üí (bind mount of ext4 filesystem)</code></pre></div>\n<p><strong>After <code>pivot_root(rootfs, rootfs/.pivot_old)</code></strong>: Mount namespace contains:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/             ‚Üí container rootfs (what was /container/rootfs)\n/.pivot_old   ‚Üí old host root filesystem\n/.pivot_old/proc   ‚Üí host procfs\n/.pivot_old/sys    ‚Üí host sysfs</code></pre></div>\n<p><strong>After <code>umount2(&quot;/.pivot_old&quot;, MNT_DETACH)</code></strong>: Mount namespace contains:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/             ‚Üí container rootfs only</code></pre></div>\n<p>The host filesystem is gone from the mount table. The kernel&#39;s VFS layer has no path entry leading to it. <code>open(&quot;/etc/shadow&quot;)</code> resolves to the container&#39;s <code>/etc/shadow</code> ‚Äî if there is one. If not, <code>ENOENT</code>. The host&#39;s <code>/etc/shadow</code> is unreachable.\n<code>MNT_DETACH</code> </p>\n<blockquote>\n<p><strong>üîë Foundation: MNT_DETACH lazy unmount</strong></p>\n<h3 id=\"1-what-it-is\">1. What it IS</h3>\n<p><code>MNT_DETACH</code> (often called a &quot;lazy&quot; unmount) is a flag for the <code>umount2</code> system call that allows you to unmount a filesystem even if it is currently &quot;busy&quot;‚Äîmeaning processes still have open file descriptors or are using a directory on that mount as their current working directory. </p>\n</blockquote>\n<p>In a standard unmount, the system checks if any process is using the mount; if so, it returns a <code>Device or resource busy</code> error. With <code>MNT_DETACH</code>, the kernel immediately performs a &quot;partial&quot; unmount: it removes the mount point from the shared directory hierarchy (the mount namespace). To any new process, the directory looks empty or disconnected. However, the kernel keeps the actual filesystem alive in the background until the very last process using it closes its files or exits.</p>\n<h3 id=\"2-why-you-need-it-right-now\">2. WHY you need it right now</h3>\n<p>In modern system architecture‚Äîparticularly involving containers, namespaces, or automated cleanup scripts‚Äîyou often encounter the &quot;Busy&quot; error. For example, if a container crashes but a background logging process still holds a file handle on its volume, a standard <code>umount</code> will fail, leaving your system in a messy, inconsistent state.</p>\n<p><code>MNT_DETACH</code> allows you to &quot;fire and forget.&quot; You can signal that a mount should no longer be part of the system&#39;s accessible pathing, ensuring that no <em>new</em> processes can enter that filesystem, while allowing existing processes to finish their work gracefully without causing your cleanup script to hang or error out.</p>\n<h3 id=\"3-one-key-insight-or-mental-model\">3. ONE key insight or mental model</h3>\n<p><strong>The &quot;Ghost&quot; Filesystem:</strong> Think of <code>MNT_DETACH</code> as making a building invisible and removing its address from the city map, while allowing the people already inside to finish their business and leave through the back door. Once the last person leaves, the building finally vanishes. </p>\n<h2 id=\"remember-it-provides-immediate-invisibility-but-delayed-destruction-deserves-explanation-it-performs-a-lazy-unmount-the-mount-point-becomes-immediately-invisible-and-unreachable-from-new-path-lookups-however-if-any-process-has-an-open-file-descriptor-pointing-into-that-filesystem-eg-a-file-from-the-old-root-is-still-open-the-kernel-keeps-the-filesystem-alive-until-those-descriptors-are-closed-only-then-is-the-memory-freed-this-is-safer-than-a-quotforcequot-unmount-mnt_force-which-would-close-those-file-descriptors-forcibly-potentially-corrupting-data-for-our-use-case-the-container39s-init-process-shouldn39t-have-open-files-in-the-old-root-so-mnt_detach-completes-effectively-immediately\"><strong>Remember:</strong> It provides <strong>immediate invisibility</strong> but <strong>delayed destruction</strong>.\n deserves explanation: it performs a <strong>lazy unmount</strong>. The mount point becomes immediately invisible and unreachable from new path lookups. However, if any process has an open file descriptor pointing into that filesystem (e.g., a file from the old root is still open), the kernel keeps the filesystem alive until those descriptors are closed. Only then is the memory freed. This is safer than a &quot;force&quot; unmount (<code>MNT_FORCE</code>) which would close those file descriptors forcibly ‚Äî potentially corrupting data. For our use case, the container&#39;s init process shouldn&#39;t have open files in the old root, so <code>MNT_DETACH</code> completes effectively immediately.</h2>\n<h2 id=\"mounting-essential-pseudo-filesystems\">Mounting Essential Pseudo-Filesystems</h2>\n<p>After <code>pivot_root()</code>, the container&#39;s process tree is completely disconnected from the host filesystem. But several pseudo-filesystems need to be re-mounted inside the container for basic functionality.\nThese are not real filesystems on disk. They are <strong>kernel interfaces</strong> exposed as a filesystem API. The kernel generates their contents dynamically in response to reads and writes.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-proc-mount-pid-ns-interaction.svg\" alt=\"/proc Mount and PID Namespace Interaction\"></p>\n<h3 id=\"proc-process-and-kernel-information\"><code>/proc</code> ‚Äî Process and Kernel Information</h3>\n<p><code>/proc</code> is not files on disk. It&#39;s the kernel exposing its internal data structures as a filesystem. When you read <code>/proc/self/status</code>, the kernel doesn&#39;t read from disk ‚Äî it formats the current process&#39;s <code>task_struct</code> into text and returns it. When you read <code>/proc/cpuinfo</code>, the kernel reads CPU registers and formats them.\n<strong>Critical interaction with PID namespaces</strong>: when you mount <code>/proc</code> inside a container that has <code>CLONE_NEWPID</code>, the resulting <code>/proc</code> shows only the processes in that PID namespace. From inside the container, <code>ls /proc/</code> shows only the container&#39;s PIDs (1, 2, etc.). The host processes are invisible.\nIf you mount <code>/proc</code> <em>without</em> a PID namespace, the container would see the host&#39;s entire process tree. This is a real mistake: running a container with a mount namespace but <em>without</em> a PID namespace, then mounting <code>/proc</code>, gives the container a window into all host processes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mount_proc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mount a fresh procfs at /proc inside our new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MS_NOSUID: prevent setuid execution through proc paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MS_NOEXEC: prevent executing files through proc paths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MS_NODEV: prevent device access through proc paths</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NODEV, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount /proc\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The first argument <code>&quot;proc&quot;</code> is the source ‚Äî for pseudo-filesystems, this is typically the filesystem type name used as a conventional label (not a device path). The third argument <code>&quot;proc&quot;</code> is the filesystem type. The kernel looks up the registered <code>proc_fs_type</code> and creates a fresh procfs instance scoped to the current PID namespace.</p>\n<h3 id=\"sys-kernel-and-device-parameters\"><code>/sys</code> ‚Äî Kernel and Device Parameters</h3>\n<p><code>/sys</code> (sysfs) exposes the kernel&#39;s internal device model ‚Äî PCI buses, block devices, network interfaces, power management. Like <code>/proc</code>, it&#39;s kernel memory exposed as a filesystem.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mount_sysfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/sys\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NODEV </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_RDONLY, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount /sys\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>MS_RDONLY</code> is worth discussing: making <code>/sys</code> read-only inside the container prevents the container from modifying kernel parameters (e.g., writing to <code>/sys/kernel/mm/transparent_hugepage/enabled</code>). Production containers almost always mount <code>/sys</code> read-only. Docker uses a read-only <code>/sys</code> with specific paths bind-mounted writable for cgroup operations.</p>\n<h3 id=\"dev-device-nodes\"><code>/dev</code> ‚Äî Device Nodes</h3>\n<p>Device nodes are special files that the kernel uses to communicate with device drivers. <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/urandom</code> are not files on disk ‚Äî they&#39;re kernel objects that implement the <code>file_operations</code> interface.\nA freshly <code>pivot_root()</code>&#39;d container has an empty <code>/dev</code>. Programs that call <code>open(&quot;/dev/null&quot;, ...)</code> get <code>ENOENT</code>. You have two options:\n<strong>Option A: <code>tmpfs</code> + bind-mount specific devices</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mount_dev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mount a tmpfs at /dev ‚Äî an in-memory filesystem for device nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/dev\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_STRICTATIME,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              \"mode=755,size=65536k\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount /dev tmpfs\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bind-mount essential device nodes from the host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is safe because we bind specific nodes, not the entire /dev</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">devices</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"null\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"zero\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"random\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"urandom\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tty\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"full\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">dst</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">devices</span><span style=\"color:#E1E4E8\">[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(src, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(src), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devices</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(dst, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(dst), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devices</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create the destination file (bind mounts require the target to exist)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Device nodes require open() followed by mknod-equivalent, or just</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // create an empty file and bind-mount over it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(dst, O_CREAT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_WRONLY, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(src, dst, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            perror</span><span style=\"color:#E1E4E8\">(src);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Non-fatal: continue with other devices</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Option B: <code>mknod()</code> to create device nodes directly</strong>\nThis requires <code>CAP_MKNOD</code> (or user namespace mapping in Milestone 5):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create /dev/null: character device, major 1, minor 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mknod</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/dev/null\"</span><span style=\"color:#E1E4E8\">, S_IFCHR </span><span style=\"color:#F97583\">|</span><span style=\"color:#F97583\"> 0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">makedev</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mknod /dev/null\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// /dev/zero: major 1, minor 5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// /dev/urandom: major 1, minor 9</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// /dev/random: major 1, minor 8</span></span></code></pre></div>\n<h2 id=\"the-bind-mount-approach-option-a-is-what-docker-and-runc-use-for-most-scenarios-it-avoids-requiring-cap_mknod-by-inheriting-device-nodes-from-the-host-where-they-already-exist-then-making-them-individually-visible-inside-the-container\">The bind-mount approach (Option A) is what Docker and runc use for most scenarios ‚Äî it avoids requiring <code>CAP_MKNOD</code> by inheriting device nodes from the host where they already exist, then making them individually visible inside the container.</h2>\n<h2 id=\"complete-implementation-filesystem-isolation\">Complete Implementation: Filesystem Isolation</h2>\n<p>Here is the complete implementation of the mount namespace and filesystem isolation, integrated with the Milestone 1 structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mman.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/syscall.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_HOSTNAME</span><span style=\"color:#9ECBFF\"> \"mycontainer\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">rootfs;</span><span style=\"color:#6A737D\">   // Path to the container's root filesystem on the host</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span><span style=\"color:#6A737D\">     // Command to execute inside the container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Filesystem Setup Functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 1: Make all existing mounts private so container mounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// don't propagate to the host (and host mounts don't propagate in).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> set_mounts_private</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_REC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_PRIVATE, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount MS_REC|MS_PRIVATE on /\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 2: Bind-mount the rootfs directory onto itself.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// pivot_root() requires new_root to be a mount point.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Without this, pivot_root() fails with EINVAL.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(rootfs, rootfs, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_REC, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bind-mount rootfs to self\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 3: Atomically swap the root filesystem.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// old root lands in rootfs/.pivot_old, then we detach it.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> do_pivot_root</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(old_root), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/.pivot_old\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure the staging directory exists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">700</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> EEXIST) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mkdir .pivot_old\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // pivot_root is not in glibc ‚Äî must use syscall directly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_pivot_root, rootfs, old_root) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Hint: new_root must be a mountpoint and \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"different from old_root</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Move our working directory into the new root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">chdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"chdir /\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Lazy-unmount the old root: immediately removes it from path resolution,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // defers memory release until all file descriptors into it are closed.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">umount2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">, MNT_DETACH) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"umount2 /.pivot_old\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean up the now-empty staging directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">rmdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Non-fatal ‚Äî filesystem is already isolated</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"rmdir /.pivot_old (non-fatal)\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Step 4: Mount pseudo-filesystems the container needs.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These are kernel data structures exposed as filesystem APIs.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mount_pseudofs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // /proc: process information and kernel tunables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Mount AFTER pivot_root so it reflects our PID namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NODEV, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount /proc\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // /sys: kernel device model and hardware parameters (read-only)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/sys\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NODEV </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_RDONLY, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount /sys\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // /dev: tmpfs for device node staging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/dev\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">              MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_STRICTATIME,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              \"mode=755,size=65536k\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mount /dev tmpfs\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // Fatal ‚Äî /dev is required</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bind essential device nodes from host into container /dev</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We need the bind mounts before pivot but the target files after,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // so we do this in two passes: create target, then bind.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">name;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        mode_t</span><span style=\"color:#E1E4E8\">      mode;</span><span style=\"color:#6A737D\">  // for creating the target file</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } devnodes</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        { </span><span style=\"color:#9ECBFF\">\"null\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        { </span><span style=\"color:#9ECBFF\">\"zero\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        { </span><span style=\"color:#9ECBFF\">\"random\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        { </span><span style=\"color:#9ECBFF\">\"urandom\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        { </span><span style=\"color:#9ECBFF\">\"tty\"</span><span style=\"color:#E1E4E8\">,     </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        { </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> host_dev</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">cont_dev</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">devnodes</span><span style=\"color:#E1E4E8\">[i].name </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(host_dev, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(host_dev), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devnodes</span><span style=\"color:#E1E4E8\">[i].name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(cont_dev, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cont_dev), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devnodes</span><span style=\"color:#E1E4E8\">[i].name);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Create an empty file as the bind-mount target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(cont_dev, O_CREAT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_WRONLY, </span><span style=\"color:#FFAB70\">devnodes</span><span style=\"color:#E1E4E8\">[i].mode);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(host_dev, cont_dev, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Warning: bind-mount </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    host_dev, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Zombie Reaper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> reap_zombies</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, WNOHANG)) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-init] reaped PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container Init ‚Äî PID 1 inside the namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> container_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 1: Filesystem Isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1a. Make all mounts private ‚Äî no propagation in or out</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">set_mounts_private</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1b. Bind-mount rootfs to itself ‚Äî create the required mount point</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1c. Atomically swap root filesystem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">do_pivot_root</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 2: Identity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">sethostname</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sethostname\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 3: Mount pseudo-filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Must happen AFTER pivot_root so they mount inside the container root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mount_pseudofs</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 4: Verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] Filesystem isolation active</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] PID: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (should be 1)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] Root: \"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // List the new root to confirm isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ls /\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 5: Spawn user command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(cfg->argv[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], cfg->argv);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 6: Init reaper loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> exited </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> child) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            reap_zombies</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[init] reaped orphan PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, exited);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main ‚Äî Host Side</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;rootfs-path> &#x3C;command> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Example: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs /bin/sh</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allocate child stack (x86-64: stack grows down, pass stack top)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, STACK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       MAP_PRIVATE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_ANONYMOUS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_STACK,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stack </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MAP_FAILED) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mmap\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Guard page at the bottom: segfault on stack overflow (not silent corruption)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mprotect</span><span style=\"color:#E1E4E8\">(stack, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, PROT_NONE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#E1E4E8\"> cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .rootfs </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .argv   </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create new PID, UTS, and Mount namespaces atomically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> container_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_init, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWPID  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWUTS  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNS   </span><span style=\"color:#F97583\">|</span><span style=\"color:#6A737D\">  // ‚Üê NEW: mount namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                &#x26;</span><span style=\"color:#E1E4E8\">cfg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (container_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clone\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container running, host PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container exited</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> container_m2</span><span style=\"color:#9ECBFF\"> container_m2.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You'll need a rootfs to pivot into. Get Alpine Linux minimal rootfs:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> alpine-rootfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#9ECBFF\"> https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-minirootfs-3.19.0-x86_64.tar.gz</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    tar</span><span style=\"color:#79B8FF\"> -xz</span><span style=\"color:#79B8FF\"> -C</span><span style=\"color:#9ECBFF\"> alpine-rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create the .pivot_old staging directory</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> alpine-rootfs/.pivot_old</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run the container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container_m2</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span></code></pre></div>\n<p>Inside the container, verify isolation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sh</span><pre class=\"arch-pre shiki-highlighted\"><code># Should show Alpine's filesystem, NOT the host's\nls /\n# bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  srv  sys  tmp  usr  var\n# Should NOT show host processes (only container processes)\nls /proc/\n# 1  self  ...  (only container PIDs)\n# Host filesystem completely inaccessible\nls /.pivot_old\n# ls: cannot access '/.pivot_old': No such file or directory\n# Confirm we're seeing our process tree\ncat /proc/self/status | grep NSpid\n# NSpid:\t1</code></pre></div>\n<hr>\n<h2 id=\"the-order-of-operations-why-sequence-matters\">The Order of Operations: Why Sequence Matters</h2>\n<p>The sequence of operations in <code>container_init</code> is not arbitrary. Each step creates a precondition for the next. Getting the order wrong produces mysterious failures.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. CLONE_NEWNS          ‚Üê Must be in clone() flags ‚Äî can't create after the fact\n        ‚Üì\n2. MS_REC | MS_PRIVATE  ‚Üê Must happen BEFORE any mounts; stops propagation leaks\n        ‚Üì\n3. MS_BIND on rootfs    ‚Üê Creates mount point; must happen before pivot_root\n        ‚Üì\n4. pivot_root()         ‚Üê Must happen before pseudo-fs mounts (they go inside new root)\n        ‚Üì\n5. umount2(MNT_DETACH)  ‚Üê Must happen immediately after pivot_root\n        ‚Üì\n6. mount /proc          ‚Üê Must happen after pivot_root (inside new root, new namespace)\n        ‚Üì\n7. mount /sys, /dev     ‚Üê Same: after pivot_root\n        ‚Üì\n8. fork() + exec()      ‚Üê User command runs with full isolation in place</code></pre></div>\n<h2 id=\"common-mistake-mounting-proc-before-pivot_root-if-you-mount-proc-in-the-new-namespace-while-still-at-the-host-root-proc-is-mounted-at-the-host39s-proc-after-pivot_root-the-new-root-doesn39t-have-proc-you39d-need-to-mount-it-again-inside-the-container-worse-if-mount-propagation-wasn39t-set-to-private-yet-you-might-have-accidentally-modified-the-host39s-proc-mount-if-any-parent-mount-was-shared-always-pivot_root-first-then-mount-pseudo-filesystems-common-mistake-forgetting-ms_private-before-any-mounts-if-you-call-ms_bind-on-the-rootfs-before-setting-ms_private-on-the-bind-mount-event-may-propagate-back-to-the-host-through-shared-propagation-the-host-gains-a-new-mount-entry-it-didn39t-expect-in-a-containerized-environment-with-many-containers-this-leaks-mount-events-between-containers-a-security-and-operational-issue\"><strong>Common mistake: mounting /proc before pivot_root.</strong> If you <code>mount /proc</code> in the new namespace while still at the host root, <code>/proc</code> is mounted at the <em>host&#39;s</em> <code>/proc</code>. After <code>pivot_root</code>, the new root doesn&#39;t have <code>/proc</code> ‚Äî you&#39;d need to mount it again inside the container. Worse, if mount propagation wasn&#39;t set to private yet, you might have accidentally modified the host&#39;s <code>/proc</code> mount (if any parent mount was shared). Always <code>pivot_root</code> first, then mount pseudo-filesystems.\n<strong>Common mistake: forgetting <code>MS_PRIVATE</code> before any mounts.</strong> If you call <code>MS_BIND</code> on the rootfs before setting <code>MS_PRIVATE</code> on <code>/</code>, the bind-mount event may propagate back to the host through shared propagation. The host gains a new mount entry it didn&#39;t expect. In a containerized environment with many containers, this leaks mount events between containers ‚Äî a security and operational issue.</h2>\n<h2 id=\"pitfall-compendium-what-will-break-and-why\">Pitfall Compendium: What Will Break and Why</h2>\n<h3 id=\"pitfall-1-pivot_root-fails-with-einval\">Pitfall 1: <code>pivot_root</code> Fails with <code>EINVAL</code></h3>\n<p>The most common failure. Causes:</p>\n<ul>\n<li>New root is not a mount point ‚Üí bind-mount-to-self was skipped or failed</li>\n<li>New root and current root are on the same filesystem without a new mount entry ‚Üí bind-mount-to-self wasn&#39;t actually a bind mount</li>\n<li><code>.pivot_old</code> directory doesn&#39;t exist inside the new root</li>\n<li>Not inside a mount namespace (<code>CLONE_NEWNS</code> was forgotten)\nDebug: check <code>dmesg</code> ‚Äî the kernel often prints a more specific reason. Verify the mount point with <code>findmnt</code> on the host, or <code>cat /proc/self/mountinfo</code> from inside the namespace.</li>\n</ul>\n<h3 id=\"pitfall-2-mounting-proc-without-a-pid-namespace\">Pitfall 2: Mounting <code>/proc</code> Without a PID Namespace</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG: If you're not in a PID namespace, /proc shows HOST processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container can now read /proc/&#x3C;host_pid>/maps, /proc/&#x3C;host_pid>/mem, etc.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT: CLONE_NEWPID in clone() ensures /proc shows only container PIDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mount /proc AFTER pivot_root, INSIDE the PID namespace</span></span></code></pre></div>\n<p>If you&#39;re testing mount namespace isolation independently of PID namespace isolation (which you shouldn&#39;t be in production), be aware that <code>/proc</code> will expose host processes. This is a real information-disclosure vulnerability in misconfigured containers.</p>\n<h3 id=\"pitfall-3-host-filesystem-accessible-via-open-file-descriptors\">Pitfall 3: Host Filesystem Accessible via Open File Descriptors</h3>\n<p>If the container runtime (the parent, on the host) has open file descriptors pointing into the host filesystem when the container starts, those descriptors are inherited by the child process before <code>exec()</code>. The child can use those file descriptors to access host files even after <code>pivot_root()</code>.\nFix: close all file descriptors above a threshold before <code>exec()</code> in the container, or use <code>O_CLOEXEC</code> on all host-side file opens:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Close all file descriptors except stdin/stdout/stderr before exec</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">; fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">; fd</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span><span style=\"color:#6A737D\">  // Ignore errors ‚Äî most aren't open</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Or: use close_range() syscall (Linux 5.9+)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_close_range, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, UINT_MAX, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<h3 id=\"pitfall-4-tmpfs-size-limit-on-dev\">Pitfall 4: <code>tmpfs</code> Size Limit on <code>/dev</code></h3>\n<p>The <code>size=65536k</code> option on the <code>/dev</code> tmpfs is a sensible limit, but some container workloads create many large device nodes (e.g., GPU containers with <code>/dev/nvidia*</code>). If you&#39;re building a GPU-capable container, increase this or omit the size limit. An unbounded tmpfs is bounded by physical RAM ‚Äî on modern systems, that&#39;s fine for <code>/dev</code> which contains only small files.</p>\n<h3 id=\"pitfall-5-missing-ms_rec-on-propagation-change\">Pitfall 5: Missing <code>MS_REC</code> on Propagation Change</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG: Only changes propagation of /, not submounts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_PRIVATE, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT: Recursively changes all submounts (proc, sys, dev on host, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_REC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_PRIVATE, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>Without <code>MS_REC</code>, submounts (<code>/proc</code>, <code>/sys</code>, <code>/dev</code>, any <code>/mnt/*</code>) retain their original propagation type. A subsequent bind-mount inside the container that happens to overlap with a shared submount can still propagate. Always use <code>MS_REC</code>.</p>\n<h3 id=\"pitfall-6-chdir-after-pivot_root-is-mandatory\">Pitfall 6: <code>chdir()</code> After <code>pivot_root</code> is Mandatory</h3>\n<h2 id=\"after-pivot_root-the-process39s-working-directory-cwd-still-points-to-the-old-root39s-directory-entry-relative-path-operations-behave-unexpectedly-because-the-cwd-is-now-in-the-detached-old-root-the-chdirquotquot-call-immediately-after-pivot_root-resets-the-cwd-to-the-new-root-missing-this-step-produces-confusing-enoent-errors-in-subsequent-operations\">After <code>pivot_root()</code>, the process&#39;s working directory (cwd) still points to the old root&#39;s directory entry. Relative path operations behave unexpectedly because the cwd is now in the detached old root. The <code>chdir(&quot;/&quot;)</code> call immediately after <code>pivot_root()</code> resets the cwd to the new root. Missing this step produces confusing <code>ENOENT</code> errors in subsequent operations.</h2>\n<h2 id=\"hardware-soul-what-the-kernel-is-actually-doing\">Hardware Soul: What the Kernel Is Actually Doing</h2>\n<h3 id=\"cache-behavior-during-pivot_root\">Cache Behavior During <code>pivot_root()</code></h3>\n<p><code>pivot_root()</code> is a kernel-side metadata operation. It modifies the mount namespace&#39;s mount table ‚Äî a doubly-linked list of <code>mount</code> structs in kernel memory. The actual filesystem data (file contents) is not touched. The operation involves:</p>\n<ol>\n<li><strong>Lock acquisition</strong>: <code>namespace_lock()</code> takes a write lock on the mount namespace. This is a kernel semaphore, not a user-visible lock.</li>\n<li><strong>Pointer surgery</strong>: The kernel swaps <code>ns-&gt;root</code> to point to the new root mount. The old root mount gets re-parented to the <code>put_old</code> directory entry.</li>\n<li><strong>Lock release</strong>: The operation completes.\n<strong>Cache impact</strong>: The <code>mount</code> structs are small (~200 bytes each) and frequently accessed. They&#39;re typically hot in L2/L3 cache. <code>pivot_root()</code> on a namespace with ~20 mounts (typical Docker container) touches maybe 4-5 KB of kernel data structures ‚Äî fits easily in L1 cache (32-64 KB typical). The operation is <strong>not</strong> I/O-bound, not memory-bound, and barely CPU-bound.\n<strong>Latency</strong>: <code>pivot_root()</code> takes approximately 2-10 Œºs on modern hardware, including the lock acquire and release. The dominant cost is the lock contention if many namespaces are being created simultaneously ‚Äî which is why container orchestration systems (Kubernetes) pipeline container creation rather than batching it serially.</li>\n</ol>\n<h3 id=\"tlb-and-page-table-impact\">TLB and Page Table Impact</h3>\n<p>Mount namespace operations don&#39;t directly affect the TLB or page tables. The container&#39;s address space (page tables, TLB entries) is unchanged by <code>pivot_root()</code>. What changes is the VFS pathname resolution ‚Äî a pure kernel data structure operation.\n<code>mount()</code> calls for pseudo-filesystems (<code>/proc</code>, <code>/sys</code>, <code>/dev</code>) allocate kernel memory for superblock objects and inode caches. For procfs, the kernel allocates one <code>proc_inode</code> per <code>/proc/&lt;pid&gt;</code> entry ‚Äî about 256 bytes each. With 10 container processes, that&#39;s ~2.5 KB of kernel memory per container for procfs ‚Äî negligible.</p>\n<h3 id=\"memory-access-pattern\">Memory Access Pattern</h3>\n<h2 id=\"the-bind-mount-to-self-ms_bind-copies-the-source-mount39s-mount-struct-and-adds-it-to-the-namespace39s-mount-list-this-is-a-sequential-write-into-kernel-memory-cache-friendly-the-pivot_root-operation-is-a-tree-rotation-in-the-mount-list-o1-pointer-operations-all-in-already-hot-cache-lines\">The bind-mount-to-self (<code>MS_BIND</code>) copies the source mount&#39;s <code>mount</code> struct and adds it to the namespace&#39;s mount list. This is a sequential write into kernel memory ‚Äî cache-friendly. The <code>pivot_root()</code> operation is a tree rotation in the mount list ‚Äî O(1) pointer operations, all in already-hot cache lines.</h2>\n<h2 id=\"knowledge-cascade-mount-namespaces-unlock-everything\">Knowledge Cascade: Mount Namespaces Unlock Everything</h2>\n<h3 id=\"1-docker39s-overlay2-storage-driver\">1. Docker&#39;s <code>overlay2</code> Storage Driver</h3>\n<p>When you pull a Docker image, Docker doesn&#39;t store one copy per container ‚Äî it uses overlay filesystems. Each image layer is a directory (the &quot;lower&quot; layer). The container gets a writable &quot;upper&quot; layer. The overlay filesystem presents a merged view: reads fall through upper ‚Üí lower layers, writes go to upper only. The lower layers are never modified.\nHow does this connect to <code>pivot_root()</code>? Docker uses the overlay-merged directory as the new root. <code>pivot_root()</code> swaps the root filesystem to this overlaid view. The container sees a writable root that&#39;s actually a union of immutable image layers. When the container exits, Docker discards the upper (writable) layer ‚Äî the image layers are untouched. Ten containers running the same image share the same read-only lower layers ‚Äî only their upper (diff) layers are separate.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-mount-namespace-overlay-layers.svg\" alt=\"Docker Image Layers to Container Rootfs ‚Äî Overlay Mount\"></p>\n<p>Understanding <code>pivot_root()</code> explains why Docker images are copy-on-write, why <code>docker diff</code> shows only modified files, and why multi-stage builds reduce image size (fewer layers = smaller lower layer footprint).</p>\n<h3 id=\"2-the-leaky-vessels-cve-2024-container-escape-via-incomplete-pivot_root\">2. The Leaky Vessels CVE (2024): Container Escape via Incomplete <code>pivot_root</code></h3>\n<p>CVE-2024-21626 (Leaky Vessels) affected runc, the container runtime used by Docker and Kubernetes. The vulnerability: a file descriptor (<code>/proc/self/fd/...</code>) pointing into the host filesystem was inherited by the container process <em>after</em> <code>pivot_root()</code> but <em>before</em> the fd was closed. The container could use this fd to access and write to host filesystem paths ‚Äî a full container escape with write access to the host.\nThe fix: close all file descriptors into the host namespace before executing the container&#39;s process. The vulnerable code path opened an fd for a cgroup-related directory lookup during container setup, then forgot to close it before <code>exec()</code>.\nThis is exactly the &quot;open file descriptor inheritance&quot; pitfall described above. The <code>pivot_root()</code> sequence is correct ‚Äî the mistake was in fd management before <code>exec()</code>. Understanding the sequence tells you exactly where to look for this class of vulnerability.</p>\n<h3 id=\"3-kubernetes-hostpath-mounts-and-bidirectional-propagation\">3. Kubernetes <code>hostPath</code> Mounts and Bidirectional Propagation</h3>\n<p>Kubernetes allows <code>hostPath</code> volumes ‚Äî mounting a host directory directly into a container. The <code>MountPropagation</code> field controls how mount events propagate:</p>\n<ul>\n<li><code>None</code> (default): MS_PRIVATE ‚Äî container mounts don&#39;t reach host</li>\n<li><code>HostToContainer</code>: MS_SLAVE ‚Äî host mounts propagate in, container mounts stay out</li>\n<li><code>Bidirectional</code>: MS_SHARED ‚Äî mounts propagate both ways\n<code>Bidirectional</code> requires the pod to be privileged. When a privileged pod mounts something inside a <code>hostPath</code> with <code>Bidirectional</code> propagation, that mount becomes visible on the host and to other containers sharing the <code>hostPath</code>. This is how legitimate use cases (CSI drivers) work ‚Äî but it&#39;s also why <code>Bidirectional</code> is a security concern. A compromised privileged pod can mount things onto the host.\nUnderstanding <code>MS_SHARED</code>, <code>MS_SLAVE</code>, and <code>MS_PRIVATE</code> from this milestone gives you the vocabulary to reason about Kubernetes storage security policies precisely.</li>\n</ul>\n<h3 id=\"4-distroless-images-and-minimal-rootfs\">4. Distroless Images and Minimal rootfs</h3>\n<p>Google&#39;s distroless images contain only the application and its runtime dependencies ‚Äî no shell, no package manager, no <code>/usr/bin/id</code>. The container&#39;s rootfs is constructed by <code>pivot_root()</code>&#39;ing into a carefully curated directory tree.\nUnderstanding what a container actually <em>needs</em> in its rootfs (from this milestone):</p>\n<ul>\n<li><code>/proc</code>, <code>/sys</code>, <code>/dev</code> (pseudo-filesystems, mounted at runtime ‚Äî not needed in the image)</li>\n<li>Shared libraries (<code>/lib</code>, <code>/lib64</code>) for the binary to link against</li>\n<li><code>/etc/resolv.conf</code>, <code>/etc/passwd</code>, <code>/etc/hosts</code> for network and identity</li>\n<li>The application binary itself\nEverything else ‚Äî shells, compilers, debug tools ‚Äî is optional. Distroless images remove them. A compromised distroless container has no shell to drop into, no <code>curl</code> to exfiltrate data, no <code>chmod</code> to escalate. Understanding <code>pivot_root()</code> explains why this works: the container is literally running inside a rootfs that doesn&#39;t contain those tools. There&#39;s no path to them, because the host filesystem is inaccessible.</li>\n</ul>\n<h3 id=\"5-setns-and-joining-existing-namespaces\">5. <code>setns()</code> and Joining Existing Namespaces</h3>\n<h2 id=\"the-inverse-of-creating-a-mount-namespace-is-joining-an-existing-one-setnsfd-clone_newns-switches-the-calling-process-into-the-mount-namespace-referenced-by-fd-obtained-by-openquotprocltpidgtnsmntquot-o_rdonly-this-is-how-docker-exec-works-it-opens-the-running-container39s-namespace-descriptors-from-procltcontainer_pidgtns-and-joins-each-one-using-setns-then-execs-the-user39s-command-in-the-container39s-environment-now-you-understand-why-docker-exec-can-run-commands-inside-a-running-container-without-restarting-it-it39s-joining-the-existing-namespaces-at-runtime-including-the-mount-namespace-with-pivot_root39d-rootfs-still-in-effect\">The inverse of creating a mount namespace is joining an existing one. <code>setns(fd, CLONE_NEWNS)</code> switches the calling process into the mount namespace referenced by <code>fd</code> (obtained by <code>open(&quot;/proc/&lt;pid&gt;/ns/mnt&quot;, O_RDONLY)</code>). This is how <code>docker exec</code> works: it opens the running container&#39;s namespace descriptors from <code>/proc/&lt;container_pid&gt;/ns/*</code> and joins each one using <code>setns()</code>, then <code>exec()</code>s the user&#39;s command in the container&#39;s environment.\nNow you understand why <code>docker exec</code> can run commands inside a running container without restarting it ‚Äî it&#39;s joining the existing namespaces at runtime, including the mount namespace with <code>pivot_root()</code>&#39;d rootfs still in effect.</h2>\n<h2 id=\"verification-checklist\">Verification Checklist</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 1. Verify mount namespace isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container: mount operations don't appear on host</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> /tmp</span><span style=\"color:#6A737D\">      # Inside container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host: cat /proc/mounts | grep tmpfs  ‚Äî should NOT show container's tmpfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 2. Verify root filesystem isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show ONLY your container rootfs contents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Try to reach host filesystem:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /etc/shadow</span><span style=\"color:#6A737D\">      # Should show CONTAINER's /etc/shadow (if any), not host's</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /.pivot_old</span><span style=\"color:#6A737D\">      # ENOENT ‚Äî old root is gone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 3. Verify /proc shows only container processes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: 1  2  self  ... (only container PIDs, not thousands of host PIDs)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/1/cmdline</span><span style=\"color:#6A737D\">  # Should show your container_init binary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 4. Verify /sys is read-only ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /sys/kernel/mm/transparent_hugepage/enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Permission denied ‚Äî /sys is MS_RDONLY</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 5. Verify /dev has essential devices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"test\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /dev/null</span><span style=\"color:#6A737D\">    # Should succeed silently</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /dev/urandom</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> xxd</span><span style=\"color:#6A737D\">  # Should produce random bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 6. Verify hostname isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mycontainer (not the host's hostname)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 7. Verify host can still see container via host PID ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On HOST (replace 12345 with actual host PID from clone() output):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/12345/mountinfo</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show container's mount namespace entries (/ ‚Üí container rootfs)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/12345/ns/mnt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mnt:[4026532345]  (different inode from host's mnt namespace)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/self/ns/mnt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mnt:[4026531840]  (host's mount namespace ‚Äî different number)</span></span></code></pre></div>\n<hr>\n<h2 id=\"looking-ahead\">Looking Ahead</h2>\n<h2 id=\"your-container-now-has-genuine-filesystem-isolation-pivot_root-has-atomically-swapped-the-root-filesystem-umount2mnt_detach-has-removed-the-host-filesystem-from-the-kernel39s-path-resolution-and-pseudo-filesystems-provide-the-minimal-infrastructure-the-container-process-needs-but-if-you-run-ip-addr-inside-the-container-you-see-the-host39s-network-interfaces-eth0-wlan0-all-of-it-the-container-can-open-network-connections-on-behalf-of-the-host39s-network-stack-listen-on-ports-that-appear-on-the-host-and-enumerate-the-host39s-network-configuration-the-next-milestone-network-namespace-and-container-networking-adds-clone_newnet-to-the-growing-list-of-namespace-flags-the-pattern-is-now-clear-clone_newpid-clone_newuts-clone_newns-clone_newnet-sigchld-all-atomic-in-a-single-clone-call-each-namespace-flag-adds-another-dimension-of-isolation-by-milestone-4-cgroups-you39ll-also-enforce-resource-limits-not-just-visibility-limits-and-by-milestone-5-user-namespaces-you39ll-remove-the-sudo-requirement-entirely-the-container_init-architecture-you39ve-been-building-clone-with-accumulated-flags-pid-1-reaper-loop-sequential-isolation-setup-inside-the-child-is-the-skeleton-every-container-runtime-follows-runc-the-oci-runtime-used-by-docker-does-exactly-this-sequence-with-additional-complexity-around-oci-spec-compliance-seccomp-filters-and-capability-management-you39ve-now-built-the-core\">Your container now has genuine filesystem isolation. <code>pivot_root()</code> has atomically swapped the root filesystem, <code>umount2(MNT_DETACH)</code> has removed the host filesystem from the kernel&#39;s path resolution, and pseudo-filesystems provide the minimal infrastructure the container process needs.\nBut if you run <code>ip addr</code> inside the container, you see the host&#39;s network interfaces ‚Äî <code>eth0</code>, <code>wlan0</code>, all of it. The container can open network connections on behalf of the host&#39;s network stack, listen on ports that appear on the host, and enumerate the host&#39;s network configuration.\nThe next milestone (Network Namespace and Container Networking) adds <code>CLONE_NEWNET</code> to the growing list of namespace flags. The pattern is now clear: <code>CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWNET | SIGCHLD</code> ‚Äî all atomic in a single <code>clone()</code> call. Each namespace flag adds another dimension of isolation. By Milestone 4 (cgroups), you&#39;ll also enforce <em>resource</em> limits ‚Äî not just visibility limits. And by Milestone 5 (user namespaces), you&#39;ll remove the <code>sudo</code> requirement entirely.\nThe <code>container_init</code> architecture you&#39;ve been building ‚Äî <code>clone()</code> with accumulated flags, PID 1 reaper loop, sequential isolation setup inside the child ‚Äî is the skeleton every container runtime follows. <code>runc</code> (the OCI runtime used by Docker) does exactly this sequence, with additional complexity around OCI spec compliance, seccomp filters, and capability management. You&#39;ve now built the core.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m3 -->\n<!-- MS_ID: container-basic-m3 -->\n<h1 id=\"milestone-3-network-namespace-and-container-networking\">Milestone 3: Network Namespace and Container Networking</h1>\n<h2 id=\"the-illusion-you-are-about-to-demystify\">The Illusion You Are About to Demystify</h2>\n<p>Run your container from Milestone 2. Inside the shell, type <code>ip addr</code>. You see the host&#39;s network interfaces ‚Äî <code>eth0</code>, <code>lo</code>, <code>wlan0</code>, every interface on your machine. Your container has perfect filesystem isolation and process isolation, but its network stack is completely exposed to the host.\nType <code>ip route</code> inside your container. You see the host&#39;s routing table. Type <code>ss -tlnp</code> ‚Äî you see every port the host is listening on. Your container could open a socket on port 80, and that socket would appear on the host&#39;s interface. That&#39;s not isolation. That&#39;s a namespace sticker placed over a window that&#39;s still wide open.\nBut here&#39;s the misconception worth shattering first: many developers assume that container networking involves specialized kernel modules, hardware-level NIC virtualization, or some kind of complex SDN (Software Defined Networking) magic. The mental model is: <em>Docker networking must be complicated ‚Äî it routes packets between containers, across hosts, through overlays. This can&#39;t be simple.</em>\n<strong>It is simple.</strong> Docker&#39;s default bridge network ‚Äî the <code>docker0</code> bridge you see on any Docker host ‚Äî is built from exactly three kernel primitives that have existed since Linux 2.x:</p>\n<ol>\n<li>A <strong>network namespace</strong> creates an empty, isolated network stack.</li>\n<li>A <strong>veth pair</strong> is a virtual ethernet cable connecting two namespaces.</li>\n<li>A <strong>Linux bridge</strong> is a virtual L2 switch connecting multiple veth endpoints.\nAdd one <code>iptables MASQUERADE</code> rule for NAT, and you have Docker&#39;s default bridge network. Literally. The same architecture. The same kernel objects. By the end of this milestone, you will have built <code>docker0</code> from scratch.</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-veth-pair-bridge-topology.svg\" alt=\"Container Networking Topology ‚Äî veth Pairs + Bridge\"></p>\n<hr>\n<h2 id=\"the-tension-one-network-stack-many-isolated-worlds\">The Tension: One Network Stack, Many Isolated Worlds</h2>\n<p>The Linux kernel maintains a single global network stack. Every socket, every routing table entry, every network interface ‚Äî they all live in one shared namespace. Without isolation:</p>\n<ul>\n<li>Container A binds port 8080. Container B tries to bind port 8080. <code>EADDRINUSE</code>. They fight over port space.</li>\n<li>Container A can call <code>socket(AF_PACKET, ...)</code> and sniff every packet on <code>eth0</code>. Your containers are eavesdropping on each other.</li>\n<li>Container A can modify the host&#39;s routing table with <code>ip route add</code>. It can redirect traffic. It can ARP-poison the network.</li>\n<li><code>iptables</code> rules are global. Container A&#39;s firewall rules affect Container B&#39;s traffic.\nThe kernel&#39;s answer ‚Äî as you now know from the PID and mount namespaces ‚Äî is to partition the global data structure. A <strong>network namespace</strong> (<code>CLONE_NEWNET</code>) gives each container its own:</li>\n<li>Network interfaces (visible with <code>ip link</code>)</li>\n<li>Routing tables (<code>ip route</code>)</li>\n<li><code>iptables</code> / <code>nftables</code> rules</li>\n<li>Sockets and connection tracking table</li>\n<li>Port space (container A and B can both bind port 8080 simultaneously)\nBut an isolated network stack is useless without connectivity. A container that can&#39;t reach the internet or other containers is an island. This is the fundamental tension in container networking: <strong>you want complete isolation AND selective connectivity.</strong> \nThe solution ‚Äî veth pairs and bridges ‚Äî threads this needle precisely. You get isolation by default, and you punch selective holes through namespace boundaries exactly where you choose.</li>\n</ul>\n<hr>\n<h2 id=\"concept-1-the-virtual-ethernet-pair\">Concept 1: The Virtual Ethernet Pair</h2>\n<p>[[EXPLAIN:virtual-ethernet-(veth)-pair-model|Virtual ethernet (veth) pair model]]\nA veth pair is the most elegant network primitive in the Linux kernel. It&#39;s created as a single unit ‚Äî two virtual network interfaces permanently linked together. Whatever you send into one end comes out the other, exactly like a physical ethernet cable.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[veth0] ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ wire ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí [veth1]</code></pre></div>\n<p>But unlike a physical cable, these two ends can live in <strong>different network namespaces</strong>. That&#39;s the key. You create the pair in the host namespace, then move one end into the container&#39;s network namespace. Now the container&#39;s network interface is directly connected to the host ‚Äî via the veth wire ‚Äî even though they&#39;re in separate namespaces.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-net-ns-empty-state.svg\" alt=\"Network Namespace Empty State ‚Äî Before and After veth\"></p>\n<p>The kernel implementation: when a packet is <code>xmit</code>&#39;d on one veth end, the kernel&#39;s <code>veth_xmit()</code> function pushes the skb (socket buffer ‚Äî the kernel&#39;s packet representation) directly to the receive queue of the other end. No actual hardware, no DMA, no interrupt ‚Äî just a function call that moves a pointer from one queue to another. This is why veth pairs are fast: the &quot;network&quot; traversal is pure software.\nHowever, this single-hop path still traverses the full kernel network stack twice ‚Äî once on transmit (sender&#39;s namespace) and once on receive (receiver&#39;s namespace). That&#39;s two invocations of <code>netif_rx()</code>, two routing lookups, two sets of netfilter hooks. This is the measurable overhead: roughly 5-15% additional latency compared to host networking for small packets, measurable with <code>netperf</code> or <code>iperf3</code>. We&#39;ll quantify this in the Hardware Soul section.\nCreating a veth pair from userspace uses the <code>rtnetlink</code> socket API ‚Äî the same API that the <code>ip</code> command uses. In C, this requires constructing Netlink messages. For clarity, we&#39;ll wrap the <code>ip</code> command using <code>system()</code> in the implementation and then show the raw Netlink approach as an extension.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-veth-creation-sequence.svg\" alt=\"veth Pair Creation and Namespace Assignment ‚Äî Step Sequence\"></p>\n<hr>\n<h2 id=\"concept-2-the-linux-bridge\">Concept 2: The Linux Bridge</h2>\n<p>[[EXPLAIN:linux-bridge-as-a-virtual-l2-switch|Linux bridge as a virtual L2 switch]]\nA Linux bridge (<code>br_netfilter</code> kernel module, interface type <code>ARPHRD_ETHER</code>) behaves like a hardware L2 Ethernet switch: it forwards frames between attached interfaces based on MAC addresses, maintains an FDB (Forwarding Database) mapping MAC addresses to ports, and broadcasts frames for unknown destinations.\nIn our topology, the bridge serves as the hub that connects all container veth endpoints to each other and to the host&#39;s outbound interface. Each container&#39;s &quot;host-side&quot; veth end is attached to the bridge as a port. The bridge gets an IP address ‚Äî this becomes the <strong>gateway</strong> that all containers route through.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[ ctr0 bridge: 172.20.0.1/24 ]\n        |          |\n    [veth_h0]  [veth_h1]   ‚Üê host-side veth ends (bridge ports)\n        |          |\n    [veth_c0]  [veth_c1]   ‚Üê container-side veth ends\n        |          |\n  [container0]  [container1]</code></pre></div>\n<h2 id=\"the-bridge-is-created-with-arphrd_ether-type-and-given-an-ip-address-the-ip-serves-as-the-container-gateway-containers-send-their-default-route-traffic-to-this-ip-and-the-bridge-being-on-the-host-network-stack-can-forward-it-onward\">The bridge is created with <code>ARPHRD_ETHER</code> type and given an IP address. The IP serves as the container gateway ‚Äî containers send their default route traffic to this IP, and the bridge (being on the host network stack) can forward it onward.</h2>\n<h2 id=\"building-the-network-topology-complete-plan\">Building the Network Topology: Complete Plan</h2>\n<p>Before writing any code, map the full topology you&#39;re about to construct:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Host Network Stack:\n‚îú‚îÄ‚îÄ eth0 (or enp3s0, etc.) ‚Äî host's outbound interface, e.g., 192.168.1.100/24\n‚îú‚îÄ‚îÄ ctr0 bridge ‚Äî 172.20.0.1/24 (container gateway)\n‚îÇ   ‚îî‚îÄ‚îÄ veth_h0 ‚Äî bridge port (host side of veth pair)\n‚îÇ\nContainer Network Namespace:\n‚îî‚îÄ‚îÄ veth_c0 ‚Äî 172.20.0.2/24 (container's interface)\n    ‚îî‚îÄ‚îÄ default route via 172.20.0.1 (the bridge)\niptables NAT:\n‚îî‚îÄ‚îÄ POSTROUTING MASQUERADE on eth0 ‚Äî rewrites container IPs to host IP for outbound</code></pre></div>\n<p>IP subnet: <code>172.20.0.0/24</code> ‚Äî chosen to avoid conflict with common home networks (<code>192.168.0.0/24</code>, <code>10.0.0.0/8</code>). Docker uses <code>172.17.0.0/16</code> by default.\nInterface naming:</p>\n<ul>\n<li><code>ctr0</code> ‚Äî the bridge (analogous to Docker&#39;s <code>docker0</code>)</li>\n<li><code>veth_h0</code> ‚Äî host-side veth (attached to bridge)</li>\n<li><code>veth_c0</code> ‚Äî container-side veth (inside container namespace)</li>\n</ul>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-packet-walk-container-to-internet.svg\" alt=\"Packet Walk: Container ‚Üí Bridge ‚Üí NAT ‚Üí Internet\"></p>\n<hr>\n<h2 id=\"the-two-phase-implementation\">The Two-Phase Implementation</h2>\n<p>Network namespace setup requires coordination between two sides: the <strong>host side</strong> (parent process, runs before <code>clone()</code> and after) and the <strong>container side</strong> (child process, <code>container_init()</code>). This split exists because:</p>\n<ol>\n<li>veth pairs must be created on the <strong>host</strong> ‚Äî you can&#39;t create a veth pair from inside a new empty network namespace that has no interfaces yet.</li>\n<li>Moving one end of the veth into the container namespace requires knowing the container&#39;s PID ‚Äî which only exists after <code>clone()</code> returns.</li>\n<li>Interface configuration inside the container must happen <strong>inside</strong> the container&#39;s network namespace.\nThe timing sequence:</li>\n</ol>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HOST                                    CONTAINER (after clone)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1. clone(CLONE_NEWNET | ...) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  (network namespace is empty)\n   returns container_pid\n2. create veth pair (veth_h0/veth_c0)  (waiting for network setup signal)\n3. ip link set veth_c0 netns $pid ‚îÄ‚îÄ‚Üí  (veth_c0 appears in container)\n4. configure veth_h0 + bridge          \n5. signal container to continue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 6. bring up lo\n                                        7. assign IP to veth_c0\n                                        8. add default route\n                                        9. exec user command</code></pre></div>\n<p>This is a classic parent-child synchronization problem. We&#39;ll use a <code>pipe()</code> ‚Äî the parent writes one byte to signal the container that network setup is complete; the container blocks reading from the pipe until that byte arrives.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Synchronization via pipe</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(sync_pipe);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parent: after network setup, write one byte</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container: block until parent writes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#E1E4E8\"> ready;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">read</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">ready</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<h2 id=\"this-is-the-same-technique-used-by-runc-and-containerd-they-call-it-the-quotinit-pipequot-or-quotsync-socketquot-the-oci-runtime-spec-formalizes-this-two-phase-initialization-exactly-because-network-setup-requires-the-split-second-coordination-between-parent-and-child\">This is the same technique used by <code>runc</code> and <code>containerd</code> ‚Äî they call it the &quot;init pipe&quot; or &quot;sync socket&quot;. The OCI runtime spec formalizes this two-phase initialization exactly because network setup requires the split-second coordination between parent and child.</h2>\n<h2 id=\"phase-1-host-side-network-setup\">Phase 1: Host-Side Network Setup</h2>\n<p>All of the following runs in the <strong>host</strong> process (parent), after <code>clone()</code> returns the container PID.</p>\n<h3 id=\"step-1-create-the-linux-bridge\">Step 1: Create the Linux Bridge</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_NAME</span><span style=\"color:#9ECBFF\">   \"ctr0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_IP</span><span style=\"color:#9ECBFF\">     \"172.20.0.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_CIDR</span><span style=\"color:#9ECBFF\">   \"172.20.0.1/24\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_IP</span><span style=\"color:#9ECBFF\">  \"172.20.0.2\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_CIDR</span><span style=\"color:#9ECBFF\"> \"172.20.0.2/24\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_GW</span><span style=\"color:#9ECBFF\">  \"172.20.0.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VETH_HOST</span><span style=\"color:#9ECBFF\">     \"veth_h0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VETH_CONT</span><span style=\"color:#9ECBFF\">     \"veth_c0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Execute a shell command; die on failure.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Production code would use rtnetlink directly ‚Äî see the Netlink extension below.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    va_list ap;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_start</span><span style=\"color:#E1E4E8\">(ap, fmt);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vsnprintf</span><span style=\"color:#E1E4E8\">(cmd, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cmd), fmt, ap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_end</span><span style=\"color:#E1E4E8\">(ap);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> system</span><span style=\"color:#E1E4E8\">(cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host-net] FAILED (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret, cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create the bridge ctr0 and assign it an IP.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the container gateway ‚Äî the virtual switch hub.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_bridge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create bridge interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link add name </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type bridge\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Bridge may already exist from a previous run ‚Äî try to continue</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host-net] Bridge may already exist, continuing</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assign IP ‚Äî this becomes the container's default gateway</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, BRIDGE_CIDR, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bring it up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"step-2-create-the-veth-pair\">Step 2: Create the veth Pair</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Create a veth pair: veth_h0 &#x3C;--> veth_c0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Both start in the host namespace; we'll move veth_c0 into the container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> create_veth_pair</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type veth peer name </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               VETH_HOST, VETH_CONT);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The <code>ip link add ... type veth peer name ...</code> command creates both ends atomically. After this call, the host network namespace contains two new interfaces: <code>veth_h0</code> and <code>veth_c0</code>, both DOWN and with no IP addresses.</p>\n<h3 id=\"step-3-attach-host-side-to-bridge\">Step 3: Attach Host-Side to Bridge</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Attach the host-side veth end to the bridge.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The bridge acts as the L2 switch; veth_h0 is now one of its ports.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> attach_veth_to_bridge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> master </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_HOST, BRIDGE_NAME) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bring the host-side veth up (bridge port must be up to forward)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, VETH_HOST);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"step-4-move-container-side-veth-into-the-container-namespace\">Step 4: Move Container-Side veth Into the Container Namespace</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Move veth_c0 into the container's network namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After this call, veth_c0 disappears from the host and appears inside the container.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// container_pid is the PID returned by clone() ‚Äî the host-visible PID of the container init.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> move_veth_to_container</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> netns </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_CONT, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>This is the magic step. <code>ip link set &lt;iface&gt; netns &lt;pid&gt;</code> uses <code>IFLA_NET_NS_PID</code> in a Netlink <code>RTM_SETLINK</code> message to move the interface&#39;s ownership from the current namespace to the namespace of the process with that PID. After this:</p>\n<ul>\n<li><code>ip link show</code> on the <strong>host</strong> no longer shows <code>veth_c0</code></li>\n<li><code>ip link show</code> inside the <strong>container</strong> now shows <code>veth_c0</code>\nThe interface physically &quot;moved&quot; ‚Äî the kernel&#39;s <code>struct net_device</code> changed which <code>struct net</code> (network namespace) it belongs to.</li>\n</ul>\n<h3 id=\"step-5-enable-ip-forwarding-and-nat\">Step 5: Enable IP Forwarding and NAT</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Enable IP forwarding on the host.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Without this, the kernel drops packets that arrive on one interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (from the container via the bridge) destined for another interface (eth0).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The kernel's default is to NOT forward ‚Äî it assumes it's a host, not a router.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> enable_ip_forwarding</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysctl -w net.ipv4.ip_forward=1\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add iptables MASQUERADE rule for outbound NAT.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// When a container packet leaves via the host's outbound interface,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MASQUERADE rewrites the source IP from 172.20.0.2 to the host's IP.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Without this, the internet sees packets from 172.20.0.2 ‚Äî a private address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// that responses can't be routed back to.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The FORWARD rule allows the kernel to forward packets from the bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// subnet to the outbound interface.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_nat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">outbound_iface</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allow forwarding from container subnet to internet</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_NAME, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -m state --state RELATED,ESTABLISHED -j ACCEPT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        outbound_iface, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Masquerade outbound container traffic ‚Äî rewrite source IP to host IP</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -t nat -A POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/24 -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               BRIDGE_IP, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-nat-iptables-rules.svg\" alt=\"iptables NAT Rules ‚Äî MASQUERADE and FORWARD Chains\"></p>\n<h2 id=\"masquerade-is-a-special-case-of-snat-source-nat-snat-requires-you-to-specify-the-replacement-ip-explicitly-masquerade-automatically-uses-whatever-ip-is-currently-assigned-to-the-outbound-interface-useful-when-the-host-has-a-dynamic-ip-dhcp-the-kernel39s-nf_nat_masqueradec-looks-up-the-outbound-interface39s-current-ip-at-packet-send-time-and-substitutes-it-as-the-source-explainnetfilter-hook-points-and-iptables-chain-traversalnetfilter-hook-points-and-iptables-forwardpostrouting-chain-traversal\"><code>MASQUERADE</code> is a special case of SNAT (Source NAT). SNAT requires you to specify the replacement IP explicitly. MASQUERADE automatically uses whatever IP is currently assigned to the outbound interface ‚Äî useful when the host has a dynamic IP (DHCP). The kernel&#39;s <code>nf_nat_masquerade.c</code> looks up the outbound interface&#39;s current IP at packet-send time and substitutes it as the source.\n[[EXPLAIN:netfilter-hook-points-and-iptables-chain-traversal|Netfilter hook points and iptables FORWARD/POSTROUTING chain traversal]]</h2>\n<h2 id=\"phase-2-container-side-network-setup\">Phase 2: Container-Side Network Setup</h2>\n<p>This runs inside <code>container_init()</code>, after the synchronization pipe signals that the host has completed network setup.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Configure the container's network interfaces.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Called from container_init() after the host signals network setup is complete.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_container_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 1: Bring up loopback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Loopback MUST be up. Without it:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Connections to 127.0.0.1 fail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Many server processes bind to 127.0.0.1 first and fail to start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - DNS resolution via 127.0.0.1 (local resolver) fails silently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set lo up\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-net] Failed to bring up loopback</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 2: Assign IP to container veth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CONTAINER_CIDR, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-net] Failed to assign IP to </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_CONT);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 3: Bring up container veth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-net] Failed to bring up </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_CONT);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 4: Add default route ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // All traffic not destined for the local subnet goes through the gateway.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The gateway is the bridge's IP on the host side.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip route add default via </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CONTAINER_GW, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container-net] Failed to add default route</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container-net] Network configured: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, gateway </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           CONTAINER_CIDR, CONTAINER_GW);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"dns-configuration\">DNS Configuration</h3>\n<p>A freshly isolated container has an empty <code>/etc</code>. There&#39;s no <code>/etc/resolv.conf</code>. Every DNS lookup returns <code>EAI_AGAIN</code> or hangs. This is the #1 silent failure in container networking ‚Äî applications look like they&#39;re &quot;broken&quot; when actually they simply can&#39;t resolve hostnames.\n[[EXPLAIN:dns-resolv.conf-mechanics-and-resolver-library-behavior|DNS resolv.conf mechanics ‚Äî how glibc resolver reads /etc/resolv.conf]]</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-dns-resolution-in-container.svg\" alt=\"Container DNS Resolution ‚Äî /etc/resolv.conf Configuration\"></p>\n<p>There are three approaches to DNS in a container:\n<strong>Option A: Bind-mount <code>/etc/resolv.conf</code> from host</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Copy host DNS configuration into container rootfs before pivot_root,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// or bind-mount the host file into the container.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Simple, inherits host DNS settings.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> configure_dns_bind_mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> dest</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(dest, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(dest), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/etc/resolv.conf\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create the destination file if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(dest, O_CREAT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_WRONLY </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_TRUNC, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">644</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bind-mount the host's resolv.conf into the container rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This must happen BEFORE pivot_root (we reference the container path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/etc/resolv.conf\"</span><span style=\"color:#E1E4E8\">, dest, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Option B: Write a static <code>/etc/resolv.conf</code> into the rootfs</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Write a known-good DNS configuration directly into the container rootfs.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Use a public resolver (8.8.8.8 = Google, 1.1.1.1 = Cloudflare).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> configure_dns_static</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/etc/resolv.conf\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">f) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen resolv.conf\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"nameserver 8.8.8.8</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"nameserver 1.1.1.1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"options ndots:0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Disable search domain expansion</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><strong>Option C: Generate from container network configuration</strong>\nWrite <code>nameserver &lt;gateway_ip&gt;</code> and run a DNS forwarder on the host at the gateway IP. This is what Kubernetes does ‚Äî <code>kube-dns</code>/<code>CoreDNS</code> runs at a known cluster IP, and every pod&#39;s <code>/etc/resolv.conf</code> points to that IP.\nFor this milestone, Option B (static configuration with public resolvers) is simplest. Production container runtimes use Option C for cluster DNS. We&#39;ll use Option B and note the Kubernetes connection in the Knowledge Cascade.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Call this before pivot_root in Milestone 2's setup sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_dns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> configure_dns_static</span><span style=\"color:#E1E4E8\">(rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"complete-implementation-everything-together\">Complete Implementation: Everything Together</h2>\n<p>Here is the full implementation integrating network namespace support into the container runtime built in Milestones 1 and 2:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdarg.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mman.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/syscall.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\">       (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_HOSTNAME</span><span style=\"color:#9ECBFF\"> \"mycontainer\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ Network Configuration Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_NAME</span><span style=\"color:#9ECBFF\">    \"ctr0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_IP</span><span style=\"color:#9ECBFF\">      \"172.20.0.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_CIDR</span><span style=\"color:#9ECBFF\">    \"172.20.0.1/24\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_IP</span><span style=\"color:#9ECBFF\">   \"172.20.0.2\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_CIDR</span><span style=\"color:#9ECBFF\"> \"172.20.0.2/24\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_GW</span><span style=\"color:#9ECBFF\">   \"172.20.0.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VETH_HOST</span><span style=\"color:#9ECBFF\">      \"veth_h0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VETH_CONT</span><span style=\"color:#9ECBFF\">      \"veth_c0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ Configuration passed through clone() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">rootfs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">outbound_iface;</span><span style=\"color:#6A737D\">  // Host's outbound interface (e.g., \"eth0\")</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">    sync_pipe_read;</span><span style=\"color:#6A737D\">  // Container reads from this fd to wait for host setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Utility: execute shell command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    va_list ap;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_start</span><span style=\"color:#E1E4E8\">(ap, fmt);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vsnprintf</span><span style=\"color:#E1E4E8\">(cmd, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cmd), fmt, ap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_end</span><span style=\"color:#E1E4E8\">(ap);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> system</span><span style=\"color:#E1E4E8\">(cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[net] FAILED (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret, cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Filesystem isolation (from Milestone 2 ‚Äî abbreviated for space)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> set_mounts_private</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_REC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_PRIVATE, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(rootfs, rootfs, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_REC, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> do_pivot_root</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(old_root), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/.pivot_old\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mkdir</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">700</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_pivot_root, rootfs, old_root) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    chdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">umount2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">, MNT_DETACH) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"umount2 /.pivot_old\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rmdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mount_pseudofs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">,  MS_NOSUID</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">MS_NOEXEC</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">MS_NODEV, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/sys\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, MS_NOSUID</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">MS_NOEXEC</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">MS_NODEV</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">MS_RDONLY, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/dev\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">, MS_NOSUID</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">MS_STRICTATIME, </span><span style=\"color:#9ECBFF\">\"mode=755,size=65536k\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">devs</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#9ECBFF\">\"null\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"zero\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"random\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"urandom\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"tty\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">dst</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">devs</span><span style=\"color:#E1E4E8\">[i]; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(src, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(src), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(dst, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(dst), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(dst, O_CREAT</span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\">O_WRONLY, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mount</span><span style=\"color:#E1E4E8\">(src, dst, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container-side network setup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_container_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Loopback: without this, connections to 127.0.0.1 fail silently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set lo up\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assign IP to our veth end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CONTAINER_CIDR, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bring the interface up</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Default route: all non-local traffic goes through the bridge/gateway</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip route add default via </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CONTAINER_GW, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Zombie reaper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> reap_zombies</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, WNOHANG)) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[init] reaped PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container init ‚Äî PID 1 inside the namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> container_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 1: Wait for host to complete network setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Block until parent writes to the sync pipe, confirming veth has been</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // moved into this namespace and the bridge is ready.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> ready;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read</span><span style=\"color:#E1E4E8\">(cfg->sync_pipe_read, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ready, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container] Sync pipe read failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(cfg->sync_pipe_read);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 2: Filesystem isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">set_mounts_private</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)     </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">do_pivot_root</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)     </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 3: Identity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sethostname</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 4: Pseudo-filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount_pseudofs</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 5: Container-side network configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // veth_c0 is already in our namespace (host moved it before signaling us).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We configure it: IP address, bring up, default route.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">setup_container_network</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container] Network setup failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 6: Verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] Network interfaces:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] Routing table:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    system</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip route\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 7: Spawn user command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(cfg->argv[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], cfg->argv);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 8: Init reaper loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> exited </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> child) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            reap_zombies</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[init] reaped orphan PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, exited);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Host-side network setup (called from main, after clone)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_host_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">outbound_iface</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Create bridge (idempotent ‚Äî ignore error if already exists)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link add name </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type bridge 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, BRIDGE_CIDR, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Create veth pair</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type veth peer name </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_HOST, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host-net] veth pair creation failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Attach host-side veth to bridge</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> master </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_HOST, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, VETH_HOST);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Move container-side veth into container's network namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is the cross-namespace handoff: after this, veth_c0 is gone from host</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> netns </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_CONT, container_pid) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host-net] Failed to move veth to container namespace</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. IP forwarding: allow kernel to route packets between interfaces</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysctl -w net.ipv4.ip_forward=1 -q\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. NAT: MASQUERADE containers' private IPs as host IP for outbound traffic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // FORWARD rules: allow traffic to flow bridge &#x3C;-> outbound interface</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -C FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT 2>/dev/null || \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_NAME, outbound_iface, BRIDGE_NAME, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -C FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -m state \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -m state \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"--state RELATED,ESTABLISHED -j ACCEPT\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        outbound_iface, BRIDGE_NAME, outbound_iface, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // POSTROUTING MASQUERADE: rewrite source IP for outbound packets</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -t nat -C POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/24 -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE 2>/dev/null || \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"iptables -t nat -A POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/24 -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_IP, outbound_iface, BRIDGE_IP, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host-net] Network setup complete. Container IP: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, Gateway: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           CONTAINER_IP, BRIDGE_IP);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup: remove network resources on container exit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> cleanup_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">outbound_iface</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // veth_h0 is deleted automatically when its peer (veth_c0) is deleted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // or when the container namespace is destroyed. Explicit cleanup:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link del </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, VETH_HOST);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link del </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -t nat -D POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/24 -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_IP, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -D FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_NAME, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -D FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -m state \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        outbound_iface, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host-net] Network resources cleaned up</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Write DNS configuration before pivot_root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> write_resolv_conf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/etc/resolv.conf\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">f) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen resolv.conf\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Public DNS resolvers ‚Äî reachable once NAT is configured</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"nameserver 8.8.8.8</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"nameserver 1.1.1.1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"options ndots:0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main ‚Äî Host Side</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;rootfs> &#x3C;outbound-iface> &#x3C;command> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Example: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs eth0 /bin/sh</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">rootfs        </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">outbound_if   </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">      **</span><span style=\"color:#E1E4E8\">container_cmd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Write DNS config before pivot_root ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_resolv_conf</span><span style=\"color:#E1E4E8\">(rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Warning: DNS configuration failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Create sync pipe: parent signals container when network is ready ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(sync_pipe) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pipe\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Allocate child stack ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, STACK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       MAP_PRIVATE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_ANONYMOUS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_STACK,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stack </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MAP_FAILED) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mmap\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mprotect</span><span style=\"color:#E1E4E8\">(stack, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, PROT_NONE);</span><span style=\"color:#6A737D\">  // Guard page</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Configure container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#E1E4E8\"> cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .rootfs          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)rootfs,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .argv            </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> container_cmd,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .outbound_iface  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)outbound_if,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .sync_pipe_read  </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Clone with all namespace flags accumulated so far ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CLONE_NEWNET: child gets empty network namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Creating container namespaces...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> container_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_init, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWPID  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWUTS  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNS   </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNET  </span><span style=\"color:#F97583\">|</span><span style=\"color:#6A737D\">   // ‚Üê NEW: network namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                &#x26;</span><span style=\"color:#E1E4E8\">cfg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (container_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clone\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container host PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parent no longer needs the read end of sync pipe</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Host-side network setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The container is blocked reading from sync_pipe[0], waiting for us.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">setup_host_network</span><span style=\"color:#E1E4E8\">(container_pid, outbound_if) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host] Network setup failed ‚Äî terminating container</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(container_pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Signal container that network setup is complete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This unblocks the container's read() in container_init().</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Signaled container ‚Äî network ready</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container exited</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cleanup_network</span><span style=\"color:#E1E4E8\">(outbound_if);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> container_m3</span><span style=\"color:#9ECBFF\"> container_m3.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Ensure Alpine rootfs exists from Milestone 2:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container_m3</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span></code></pre></div>\n<blockquote>\n<p><strong>Finding your outbound interface</strong>: run <code>ip route | grep default</code> on the host. The <code>dev</code> field is your outbound interface (commonly <code>eth0</code>, <code>enp3s0</code>, <code>wlan0</code>, etc.).</p>\n</blockquote>\n<hr>\n<h2 id=\"extension-raw-netlink-interface\">Extension: Raw Netlink Interface</h2>\n<p>The <code>system()</code> + <code>ip</code> command approach above is clear and correct, but production container runtimes use the <strong>rtnetlink</strong> socket API directly ‚Äî the same API that <code>iproute2</code> (<code>ip</code> command) uses internally. Using Netlink avoids the overhead of spawning a shell for each operation and gives you precise error handling.\nThe key operations via Netlink:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/rtnetlink.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/if_link.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/veth.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;net/if.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/socket.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper: open a Netlink socket for rtnetlink operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> nl_socket_open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> socket</span><span style=\"color:#E1E4E8\">(AF_NETLINK, SOCK_RAW </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SOCK_CLOEXEC, NETLINK_ROUTE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"netlink socket\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sockaddr_nl sa </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .nl_family </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AF_NETLINK,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind</span><span style=\"color:#E1E4E8\">(fd, (</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sockaddr </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">sa, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(sa)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"netlink bind\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fd;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create a veth pair via Netlink RTM_NEWLINK message.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is what 'ip link add veth_h0 type veth peer name veth_c0' does internally.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Full implementation requires constructing nested Netlink attributes ‚Äî</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// see linux/if_link.h for IFLA_LINKINFO, IFLA_INFO_KIND, IFLA_INFO_DATA.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// The structure:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   RTM_NEWLINK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   ‚îî‚îÄ‚îÄ IFLA_IFNAME: \"veth_h0\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   ‚îî‚îÄ‚îÄ IFLA_LINKINFO</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//       ‚îî‚îÄ‚îÄ IFLA_INFO_KIND: \"veth\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//       ‚îî‚îÄ‚îÄ IFLA_INFO_DATA</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//           ‚îî‚îÄ‚îÄ VETH_INFO_PEER</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//               ‚îî‚îÄ‚îÄ ifinfomsg (for veth_c0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//               ‚îî‚îÄ‚îÄ IFLA_IFNAME: \"veth_c0\"</span></span></code></pre></div>\n<h2 id=\"explainrtnetlink-message-construction-and-nested-attributesrtnetlink-netlink-message-structure-and-nested-attribute-encoding-the-libmnl-library-provides-a-cleaner-c-api-for-netlink-message-construction-and-is-used-by-iproute2-itself-for-a-production-container-runtime-use-libmnl-rather-than-raw-netlink-socket-construction\">[[EXPLAIN:rtnetlink-message-construction-and-nested-attributes|rtnetlink Netlink message structure and nested attribute encoding]]\nThe <code>libmnl</code> library provides a cleaner C API for Netlink message construction and is used by <code>iproute2</code> itself. For a production container runtime, use <code>libmnl</code> rather than raw Netlink socket construction.</h2>\n<h2 id=\"the-packet-walk-container-to-internet\">The Packet Walk: Container to Internet</h2>\n<p>Understanding what happens to a single packet as it travels from container to internet solidifies the entire topology. Follow a <code>curl https://example.com</code> packet step by step:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>1. Container process calls connect(fd, 93.184.216.34:443)\n   ‚îÇ\n   ‚îî‚îÄ‚îÄ Kernel creates TCP SYN packet\n       Source IP:  172.20.0.2 (container's veth_c0 IP)\n       Source Port: 54321 (ephemeral)\n       Dest IP:    93.184.216.34\n2. Routing lookup in container's namespace:\n   Route: default via 172.20.0.1 dev veth_c0\n   ‚Üí Next hop: 172.20.0.1, send out veth_c0\n3. veth_c0 ‚Üí kernel's veth_xmit() ‚Üí packet arrives at veth_h0\n   (This is the namespace boundary crossing ‚Äî pure function call in kernel)\n4. veth_h0 is a bridge port ‚Üí Linux bridge receives packet\n   Bridge FDB lookup: 172.20.0.1 ‚Üí local (bridge owns this IP)\n   Packet delivered to bridge interface (ctr0)\n5. ctr0 is in the host network namespace ‚Üí kernel routing in HOST namespace\n   Host routing table: 93.184.216.34 ‚Üí via &lt;gateway&gt; dev eth0\n   ‚Üí Next hop: send out eth0\n6. Before leaving eth0: netfilter POSTROUTING chain\n   Rule: -t nat -A POSTROUTING -s 172.20.0.0/24 -o eth0 -j MASQUERADE\n   ‚Üí MASQUERADE fires: source IP rewritten 172.20.0.2 ‚Üí host's eth0 IP (e.g., 192.168.1.100)\n   ‚Üí Connection tracked: (172.20.0.2:54321) ‚Üî (192.168.1.100:54321) saved in conntrack table\n7. Packet leaves eth0 with source 192.168.1.100:54321\n   Destination server responds to 192.168.1.100:54321\n8. Response arrives at host eth0\n   Netfilter PREROUTING: conntrack lookup finds 192.168.1.100:54321\n   ‚Üí DNAT: destination rewritten to 172.20.0.2:54321\n9. Kernel routes to 172.20.0.2 ‚Üí bridge ctr0 ‚Üí veth_h0 ‚Üí veth_c0 ‚Üí container</code></pre></div>\n\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-packet-walk-container-to-internet.svg\" alt=\"Packet Walk: Container ‚Üí Bridge ‚Üí NAT ‚Üí Internet\"></p>\n<h2 id=\"the-conntrack-connection-tracking-table-is-the-invisible-glue-that-makes-stateful-nat-work-the-kernel-records-every-outbound-connection-translation-and-automatically-applies-the-reverse-translation-to-incoming-responses-without-conntrack-nat-would-require-explicit-dnat-rules-for-every-outbound-connection-which-is-obviously-impractical\">The conntrack (connection tracking) table is the invisible glue that makes stateful NAT work. The kernel records every outbound connection translation and automatically applies the reverse translation to incoming responses. Without conntrack, NAT would require explicit DNAT rules for every outbound connection ‚Äî which is obviously impractical.</h2>\n<h2 id=\"hardware-soul-what-the-kernel-is-actually-doing\">Hardware Soul: What the Kernel Is Actually Doing</h2>\n<h3 id=\"veth-packet-transmission-latency\">veth Packet Transmission Latency</h3>\n<p>When a packet crosses a veth pair, the kernel calls <code>veth_xmit()</code> in <code>drivers/net/veth.c</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Simplified veth_xmit() ‚Äî what happens when you send a packet into a veth</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#79B8FF\"> netdev_tx_t</span><span style=\"color:#B392F0\"> veth_xmit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> sk_buff </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">skb</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> net_device </span><span style=\"color:#F97583\">*</span><span style=\"color:#FFAB70\">dev</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> veth_priv </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">rcv_priv </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> netdev_priv</span><span style=\"color:#E1E4E8\">(rcv);</span><span style=\"color:#6A737D\"> // peer interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // RX on the peer ‚Äî push skb into peer's receive queue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">likely</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">veth_forward_skb</span><span style=\"color:#E1E4E8\">(rcv, skb, rq, use_napi) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> NET_RX_SUCCESS)) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // ...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> NETDEV_TX_OK;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>The sk_buff (socket buffer) ‚Äî Linux&#39;s packet representation ‚Äî contains:</p>\n<ul>\n<li>A pointer to the packet data (typically in DMA-accessible memory)</li>\n<li>Header pointers (network layer, transport layer)</li>\n<li>Metadata: timestamps, checksum offload flags, mark bits\n<code>veth_xmit()</code> moves the sk_buff pointer from the transmit queue of one veth end to the receive queue of the other ‚Äî no memory copy, no hardware DMA, no interrupt. It&#39;s O(1) in data size.\n<strong>Cache behavior</strong>:</li>\n<li>The sk_buff itself is ~200 bytes ‚Äî fits in one or two cache lines</li>\n<li>The packet data is a separate allocation (typically 2-4 KB for a full MTU packet)</li>\n<li><code>veth_xmit()</code> touches: the sk_buff header (hot), the peer&#39;s receive queue spinlock (potentially contended), the peer&#39;s NAPI poll list (cold on first access)\n<strong>Measured latency</strong> (same-host container-to-container via veth+bridge):</li>\n<li>Typical: 15-40 Œºs RTT (microseconds) for a 64-byte UDP ping</li>\n<li>Compare: host-to-host on localhost (<code>lo</code>): 5-10 Œºs RTT</li>\n<li>Compare: hardware NIC round trip (same switch): 80-200 Œºs RTT\nThe veth overhead (~10-30 Œºs over loopback) comes from:</li>\n</ul>\n<ol>\n<li>Two full kernel network stack traversals (TX path + RX path, each namespace)</li>\n<li>Netfilter hook evaluation (iptables rules checked at each hook point)</li>\n<li>Bridge FDB lookup (MAC table scan ‚Äî O(1) with hash table, but cache miss if cold)\n<strong>Why host networking is faster</strong>: <code>--network=host</code> in Docker bypasses veth entirely. The container process uses the host&#39;s network stack directly, same as a non-containerized process. No extra traversal, no bridge, no NAT. Used for latency-sensitive workloads: high-frequency trading, game servers, DPDK-based applications.</li>\n</ol>\n<h3 id=\"iptables-masquerade-performance\">iptables MASQUERADE Performance</h3>\n<p>Every outbound packet from the container traverses the netfilter POSTROUTING hook. The kernel evaluates the iptables rule:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>-t nat -A POSTROUTING -s 172.20.0.0/24 -o eth0 -j MASQUERADE</code></pre></div>\n<p>Rule evaluation is linear scan through the rule chain (for iptables; <code>nftables</code> and eBPF use hash maps for O(1)). With one rule, this is negligible. With thousands of rules (large Kubernetes clusters with many services and policies), iptables rule evaluation becomes measurable overhead ‚Äî the famous iptables scaling problem that motivated <code>ipvs</code> mode in <code>kube-proxy</code> and ultimately eBPF-based solutions (Cilium).\nFor our single-container runtime: MASQUERADE costs approximately 200-500 ns per packet (conntrack lookup + rule match + source IP rewrite). For bulk data transfer, the per-packet overhead amortizes across large segments. For small-packet workloads (many tiny writes), it&#39;s measurable.</p>\n<h3 id=\"tlb-and-page-table-impact\">TLB and Page Table Impact</h3>\n<h2 id=\"network-namespaces-don39t-directly-create-new-address-spaces-they39re-kernel-data-structures-not-process-address-spaces-the-tlb-is-not-affected-by-namespace-creation-or-packet-forwarding-the-one-tlb-relevant-operation-when-the-kernel-switches-between-the-container39s-network-namespace-and-the-host39s-during-bridge-forwarding-it-accesses-different-struct-net-objects-these-objects-are-typically-in-different-cache-lines-and-may-not-be-hot-first-packet-latency-for-a-new-connection-from-a-container-that-hasn39t-recently-sent-traffic-will-be-slightly-higher-cold-cache-subsequent-packets-benefit-from-the-warm-cache\">Network namespaces don&#39;t directly create new address spaces ‚Äî they&#39;re kernel data structures, not process address spaces. The TLB is not affected by namespace creation or packet forwarding.\nThe one TLB-relevant operation: when the kernel switches between the container&#39;s network namespace and the host&#39;s (during bridge forwarding), it accesses different <code>struct net</code> objects. These objects are typically in different cache lines and may not be hot. First-packet latency for a new connection from a container that hasn&#39;t recently sent traffic will be slightly higher (cold cache) ‚Äî subsequent packets benefit from the warm cache.</h2>\n<h2 id=\"pitfall-compendium\">Pitfall Compendium</h2>\n<h3 id=\"pitfall-1-creating-veth-pair-before-container-namespace-exists\">Pitfall 1: Creating veth Pair Before Container Namespace Exists</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>‚ùå WRONG approach (conceptual):\n   1. Create veth pair\n   2. clone(CLONE_NEWNET)\n   3. Try to move veth into container ‚Äî but what is the container's PID?\n      You don't know it yet, and the namespace doesn't exist yet.\n‚úÖ CORRECT approach (what we implemented):\n   1. clone(CLONE_NEWNET) ‚Üí get container_pid\n   2. Create veth pair on host\n   3. ip link set veth_c0 netns &lt;container_pid&gt;\n   4. Signal container to proceed</code></pre></div>\n<p>The container&#39;s network namespace exists the moment <code>clone()</code> returns ‚Äî the child process is created with an empty network namespace. The host can then &quot;inject&quot; the veth interface into it using <code>ip link set ... netns &lt;pid&gt;</code>.</p>\n<h3 id=\"pitfall-2-forgetting-to-bring-up-loopback\">Pitfall 2: Forgetting to Bring Up Loopback</h3>\n<p>This is the most common silent failure. Applications that bind to <code>127.0.0.1</code> (many server processes bind loopback first as a health-check port) fail with <code>EADDRNOTAVAIL</code> if loopback is down. <code>ss -tlnp</code> inside the container won&#39;t show any issue ‚Äî the interface is just down.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify loopback is up inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> lo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: UP LOWER_UP (not DOWN)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test loopback:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ping</span><span style=\"color:#79B8FF\"> 127.0.0.1</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span></span></code></pre></div>\n<h3 id=\"pitfall-3-ip-forwarding-not-enabled-on-host\">Pitfall 3: IP Forwarding Not Enabled on Host</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check current setting:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#9ECBFF\"> net.ipv4.ip_forward</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># net.ipv4.ip_forward = 0   ‚Üê BLOCKED. Packets dropped at FORWARD chain.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Enable temporarily (lost on reboot):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#79B8FF\"> -w</span><span style=\"color:#9ECBFF\"> net.ipv4.ip_forward=</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Enable permanently:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"net.ipv4.ip_forward=1\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> /etc/sysctl.conf</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#79B8FF\"> -p</span></span></code></pre></div>\n<p>Without IP forwarding, the FORWARD iptables chain is never reached ‚Äî packets arriving on <code>ctr0</code> (from the container) destined for <code>eth0</code> are silently dropped. The container can ping the gateway (<code>172.20.0.1</code>) but cannot reach anything beyond it. This is a maddening debugging scenario because the symptom is &quot;can ping gateway, cannot ping internet&quot; which looks like a routing issue, but it&#39;s actually a kernel forwarding policy issue.</p>\n<h3 id=\"pitfall-4-veth-pair-left-behind-after-container-exit\">Pitfall 4: veth Pair Left Behind After Container Exit</h3>\n<p>The veth pair and bridge persist after the container exits unless explicitly deleted. Running the container a second time fails because <code>veth_h0</code> and <code>veth_c0</code> already exist. The cleanup function in our implementation handles this, but it must run even when the container exits abnormally (signal, kill). Use <code>atexit()</code> or a signal handler:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Register cleanup at program start</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">g_outbound_if </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> NULL</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> cleanup_on_exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (g_outbound_if)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cleanup_network</span><span style=\"color:#E1E4E8\">(g_outbound_if);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In main():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">g_outbound_if </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> outbound_if;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">atexit</span><span style=\"color:#E1E4E8\">(cleanup_on_exit);</span></span></code></pre></div>\n<h3 id=\"pitfall-5-nat-rule-duplication\">Pitfall 5: NAT Rule Duplication</h3>\n<p>The idempotent check in our <code>setup_nat()</code> (using <code>iptables -C</code> to check before <code>-A</code> to add) prevents duplicates within a single run. But if the program crashes without cleanup, NAT rules accumulate on subsequent runs. The <code>cleanup_network()</code> function uses <code>iptables -D</code> (delete) to remove them ‚Äî but multiple accumulated rules require multiple <code>-D</code> invocations.\nFor robust cleanup: use <code>iptables -F</code> (flush chain) or better, use <strong>named iptables chains</strong> that can be created/deleted atomically:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create a named chain for our container's NAT rules</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -N</span><span style=\"color:#9ECBFF\"> CONTAINER_NAT</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -A</span><span style=\"color:#9ECBFF\"> POSTROUTING</span><span style=\"color:#79B8FF\"> -j</span><span style=\"color:#9ECBFF\"> CONTAINER_NAT</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -A</span><span style=\"color:#9ECBFF\"> CONTAINER_NAT</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> 172.20.0.0/24</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#79B8FF\"> -j</span><span style=\"color:#9ECBFF\"> MASQUERADE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Cleanup: flush and delete the chain</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -F</span><span style=\"color:#9ECBFF\"> CONTAINER_NAT</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -D</span><span style=\"color:#9ECBFF\"> POSTROUTING</span><span style=\"color:#79B8FF\"> -j</span><span style=\"color:#9ECBFF\"> CONTAINER_NAT</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> CONTAINER_NAT</span></span></code></pre></div>\n<p>This is exactly what Docker does ‚Äî <code>docker0</code> has its own iptables chain (<code>DOCKER</code>, <code>DOCKER-USER</code>, <code>DOCKER-ISOLATION-STAGE-1</code>, <code>DOCKER-ISOLATION-STAGE-2</code>).</p>\n<h3 id=\"pitfall-6-dns-resolution-fails-silently\">Pitfall 6: DNS Resolution Fails Silently</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inside container after pivot_root ‚Äî try DNS:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nslookup</span><span style=\"color:#9ECBFF\"> google.com</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ;; connection timed out; no servers could be reached</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Debug:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /etc/resolv.conf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (empty or missing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with explicit nameserver:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nslookup</span><span style=\"color:#9ECBFF\"> google.com</span><span style=\"color:#79B8FF\"> 8.8.8.8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Works! ‚Äî confirms NAT is functional, only resolv.conf was missing</span></span></code></pre></div>\n<h2 id=\"always-write-etcresolvconf-before-pivot_root-after-pivot_root-the-container39s-etc-is-in-the-container-rootfs-writes-go-there-but-the-write_resolv_conf-function-in-our-implementation-writes-to-ltrootfsgtetcresolvconf-from-the-host-before-the-container-starts-this-is-the-correct-sequence\">Always write <code>/etc/resolv.conf</code> before <code>pivot_root()</code>. After <code>pivot_root()</code>, the container&#39;s <code>/etc/</code> is in the container rootfs ‚Äî writes go there. But the <code>write_resolv_conf()</code> function in our implementation writes to <code>&lt;rootfs&gt;/etc/resolv.conf</code> <em>from the host</em>, before the container starts. This is the correct sequence.</h2>\n<h2 id=\"verification-checklist\">Verification Checklist</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 1. Verify network namespace isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container: only lo and veth_c0 should be visible</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: lo (UP) and veth_c0 (UP) ‚Äî NOT eth0, wlan0, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 2. Verify IP assignment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> addr</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> veth_c0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: 172.20.0.2/24</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 3. Verify routing table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> route</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># default via 172.20.0.1 dev veth_c0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 172.20.0.0/24 dev veth_c0  proto kernel  scope link  src 172.20.0.2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 4. Verify loopback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ping</span><span style=\"color:#79B8FF\"> 127.0.0.1</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1 packets transmitted, 1 received</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 5. Verify gateway reachability ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ping</span><span style=\"color:#79B8FF\"> 172.20.0.1</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should get replies from the host bridge IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 6. Verify internet connectivity (requires NAT to be working) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ping</span><span style=\"color:#79B8FF\"> 8.8.8.8</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Replies from Google's DNS server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 7. Verify DNS resolution ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /etc/resolv.conf</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># nameserver 8.8.8.8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># nameserver 1.1.1.1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nslookup</span><span style=\"color:#9ECBFF\"> google.com</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Non-authoritative answer: google.com address 142.250.x.x</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 8. Verify port isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nc</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#79B8FF\"> 0.0.0.0</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host: try to connect to container IP on 8080</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nc</span><span style=\"color:#79B8FF\"> -z</span><span style=\"color:#79B8FF\"> 172.20.0.2</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#6A737D\">  # Should succeed (bridge routes to it)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host: verify host's 0.0.0.0:8080 is NOT bound</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ss</span><span style=\"color:#79B8FF\"> -tlnp</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> 8080</span><span style=\"color:#6A737D\">   # Should show nothing ‚Äî container's port is isolated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 9. Verify host-side bridge and veth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> ctr0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ctr0: &#x3C;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> veth_h0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># veth_h0: master ctr0 state UP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 10. Verify cleanup on exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After container exits:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> ctr0</span><span style=\"color:#F97583\"> 2>&#x26;1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Device \"ctr0\" does not exist ‚Äî cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#9ECBFF\"> POSTROUTING</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> 172.20.0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (empty) ‚Äî NAT rule removed</span></span></code></pre></div>\n<hr>\n<h2 id=\"knowledge-cascade-what-this-unlocks\">Knowledge Cascade: What This Unlocks</h2>\n<h3 id=\"1-kubernetes-networking-model-cross-domain\">1. Kubernetes Networking Model (Cross-Domain)</h3>\n<p>Every Kubernetes pod gets its own network namespace ‚Äî created using exactly the same <code>CLONE_NEWNET</code> + veth pair mechanism you just built. The pod&#39;s &quot;pause container&quot; holds the network namespace; all other containers in the pod join it via <code>setns()</code>. This is why all containers in a pod share a network stack ‚Äî they share one network namespace.\nA <strong>CNI (Container Network Interface) plugin</strong> is called after pod creation to configure the network namespace. The CNI plugin creates veth pairs, attaches them to a bridge (or VXLAN overlay, or BGP-routed interface), assigns pod IPs, and configures routes ‚Äî exactly the same operations you just implemented. Calico, Flannel, Cilium, Weave ‚Äî they all do the same thing at this level. Their differences are in:</p>\n<ul>\n<li><strong>Flannel</strong>: simple VXLAN overlay (encapsulates pod packets in UDP for cross-node routing)</li>\n<li><strong>Calico</strong>: BGP routing of pod CIDR blocks, no overlay needed in routed networks</li>\n<li><strong>Cilium</strong>: eBPF programs instead of iptables for O(1) policy enforcement\nWhen you debug &quot;pod cannot reach service&quot; in Kubernetes:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check the pod's veth pair:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> veth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check the bridge/CNI interface:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#9ECBFF\"> cni0</span><span style=\"color:#6A737D\">  # Flannel's bridge (equivalent to our ctr0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check iptables rules (kube-proxy's service rules):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">service-cluster-i</span><span style=\"color:#E1E4E8\">p</span><span style=\"color:#F97583\">></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Enter the pod's network namespace directly:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> --net=/proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\">pod-pid</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\">/ns/net</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> --net=/proc/</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\">pod-pid</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\">/ns/net</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> route</span></span></code></pre></div>\n<p>You now have the vocabulary to do this effectively. The abstractions (CNI, kube-proxy, services) are built on exactly what you just implemented.</p>\n<h3 id=\"2-service-mesh-data-plane-istioenvoy\">2. Service Mesh Data Plane (Istio/Envoy)</h3>\n<p>When Istio injects an Envoy sidecar into your pod, it adds an <code>iptables</code> rule <strong>inside the pod&#39;s network namespace</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>iptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 15001</code></pre></div>\n<p>This rule redirects all outbound TCP traffic from the application to Envoy&#39;s port 15001, before it leaves the pod. Envoy then applies mTLS, retries, circuit breaking, and telemetry ‚Äî transparently, without the application knowing.\nThis is the same <code>iptables REDIRECT</code> mechanism as MASQUERADE, operating in the same netfilter framework, inside the same network namespace you just created. The &quot;magic&quot; of transparent proxying in service meshes is: <code>iptables</code> rules in the pod&#39;s network namespace, configured by the init container before the application starts. Understanding your <code>iptables MASQUERADE</code> rule directly translates to understanding Istio&#39;s traffic interception model.</p>\n<h3 id=\"3-network-performance-veth-vs-host-vs-macvlan\">3. Network Performance: veth vs Host vs macvlan</h3>\n<p>The ~10-30 Œºs veth overhead matters for latency-sensitive workloads. Three alternatives exist:</p>\n<table>\n<thead>\n<tr>\n<th>Mode</th>\n<th>Mechanism</th>\n<th>Latency</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>veth+bridge</strong></td>\n<td>Two NS traversals</td>\n<td>15-40 Œºs RTT</td>\n<td>Default Docker, Kubernetes</td>\n</tr>\n<tr>\n<td><strong>host networking</strong></td>\n<td>No NS, no NAT</td>\n<td>5-10 Œºs RTT</td>\n<td>High-perf, monitoring agents</td>\n</tr>\n<tr>\n<td><strong>macvlan</strong></td>\n<td>Direct NIC sub-interface</td>\n<td>8-15 Œºs RTT</td>\n<td>Bare-metal performance</td>\n</tr>\n<tr>\n<td><strong>SR-IOV</strong></td>\n<td>Hardware vNIC</td>\n<td>3-8 Œºs RTT</td>\n<td>Telco, HPC</td>\n</tr>\n<tr>\n<td><code>macvlan</code> creates a sub-interface directly on a physical NIC ‚Äî each container gets a MAC address on the physical network. No bridge, no NAT, packets go directly through the NIC. The tradeoff: macvlan interfaces can&#39;t communicate with their parent interface (the host). Kubernetes uses macvlan via <code>macvlan</code> CNI for cases where pod IPs need to be routeable on the physical network directly.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Understanding veth overhead explains why database containers, message queues, and caches often use <code>--network=host</code> in performance-critical deployments ‚Äî and why Kubernetes <code>hostNetwork: true</code> exists.</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"4-dns-resolution-the-1-container-networking-bug\">4. DNS Resolution ‚Äî The #1 Container Networking Bug</h3>\n<p>DNS inside containers fails in three distinct, confusing ways:\n<strong>Scenario A</strong>: <code>/etc/resolv.conf</code> missing ‚Üí immediate <code>SERVFAIL</code> on first lookup. Obvious from <code>cat /etc/resolv.conf</code>.\n<strong>Scenario B</strong>: <code>resolv.conf</code> present but points to a DNS server unreachable from inside the container (e.g., <code>127.0.0.53</code> ‚Äî systemd-resolved&#39;s stub listener on the host). The container can&#39;t reach <code>127.0.0.53</code> because that&#39;s the host&#39;s loopback. Symptom: DNS timeouts, not <code>SERVFAIL</code>.\n<strong>Scenario C</strong> (Kubernetes-specific): <code>resolv.conf</code> points to <code>kube-dns</code> service IP (<code>10.96.0.10</code> in default clusters). kube-dns is itself a pod. If the kube-dns pod is down, all DNS in the cluster fails ‚Äî cascading failure that looks like &quot;my application is broken&quot; rather than &quot;DNS is broken.&quot; This is called a <strong>DNS split-brain</strong> failure and it&#39;s the most common production Kubernetes incident.\nThe debugging ladder:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Step 1: Can I reach the nameserver at all?</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ping</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> nameserver</span><span style=\"color:#9ECBFF\"> /etc/resolv.conf</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> awk</span><span style=\"color:#9ECBFF\"> '{print $2}'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 2: Can the nameserver answer?</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nslookup</span><span style=\"color:#9ECBFF\"> google.com</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">nameserver-i</span><span style=\"color:#E1E4E8\">p</span><span style=\"color:#F97583\">></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Step 3: Is the failure DNS-specific or network-general?</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> https://8.8.8.8</span><span style=\"color:#79B8FF\"> --resolve</span><span style=\"color:#9ECBFF\"> google.com:443:8.8.8.8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Uses explicit IP ‚Äî bypasses DNS</span></span></code></pre></div>\n<p>Understanding that <code>/etc/resolv.conf</code> is a static file written during container creation (not dynamically updated) explains why Kubernetes&#39;s <code>dnsPolicy: ClusterFirst</code> and <code>ndots: 5</code> setting causes performance issues: <code>ndots:5</code> means 5-dot search expansion, turning <code>http://myservice</code> into 6 DNS queries before resolving. Production clusters tune this to <code>ndots: 2</code> or <code>1</code>.</p>\n<h3 id=\"5-network-policy-enforcement-calicocilium\">5. Network Policy Enforcement (Calico/Cilium)</h3>\n<p>Container network policy (Kubernetes <code>NetworkPolicy</code> objects) is enforced by attaching rules at the veth interface level. Where exactly?\n<strong>Calico with iptables</strong>: programs <code>iptables</code> rules on the host at the veth interface:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Calico creates chains like:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -A</span><span style=\"color:#9ECBFF\"> cali-from-wl-dispatch</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> cali</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">has</span><span style=\"color:#E1E4E8\">h</span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> -j</span><span style=\"color:#9ECBFF\"> cali-from-wl-</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#9ECBFF\">endpoin</span><span style=\"color:#E1E4E8\">t</span><span style=\"color:#F97583\">></span></span></code></pre></div>\n<h2 id=\"cilium-with-ebpf-attaches-ebpf-programs-to-the-tc-traffic-control-hook-on-the-veth-interface-earlier-in-the-packet-path-than-iptables-lower-overhead-o1-policy-lookup-via-ebpf-hash-maps-instead-of-iptables-linear-scan-the-veth-interface-is-the-natural-policy-enforcement-point-it39s-the-first-kernel-touch-point-for-packets-entering-or-leaving-a-container-everything-that-flows-tofrom-a-container-must-cross-the-veth-this-is-why-cni-plugins-attach-hooks-there-there39s-no-way-to-bypass-it-without-bypassing-the-entire-network-namespace-model-understanding-this-when-a-kubernetes-network-policy-says-quotdeny-all-ingress-to-pod-a-except-from-pods-with-label-appfrontendquot-that-rule-is-an-iptables-chain-or-ebpf-program-on-the-veth-interface-that-connects-pod-a39s-namespace-to-the-host-every-packet-entering-pod-a39s-veth-from-the-bridge-is-evaluated-against-this-rule\"><strong>Cilium with eBPF</strong>: attaches eBPF programs to the TC (Traffic Control) hook on the veth interface ‚Äî earlier in the packet path than iptables, lower overhead, O(1) policy lookup via eBPF hash maps instead of iptables linear scan.\nThe veth interface is the natural policy enforcement point: it&#39;s the first kernel touch point for packets entering or leaving a container. Everything that flows to/from a container must cross the veth. This is why CNI plugins attach hooks there ‚Äî there&#39;s no way to bypass it without bypassing the entire network namespace model.\nUnderstanding this: when a Kubernetes network policy says &quot;deny all ingress to pod A except from pods with label app=frontend,&quot; that rule is an iptables chain (or eBPF program) on the veth interface that connects pod A&#39;s namespace to the host. Every packet entering pod A&#39;s veth from the bridge is evaluated against this rule.</h2>\n<h2 id=\"the-one-line-summary\">The One-Line Summary</h2>\n<p>Container networking is: <code>CLONE_NEWNET</code> (isolate) + veth pair (connect) + bridge (switch) + iptables MASQUERADE (route). Every container runtime from Docker to Kubernetes CNI is built from these four primitives. You&#39;ve now built them from scratch.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"Container Runtime Architecture ‚Äî Satellite Map\"></p>\n<hr>\n<!-- END_MS -->\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m4 -->\n<!-- MS_ID: container-basic-m4 -->\n<h1 id=\"milestone-4-cgroups-resource-limits\">Milestone 4: Cgroups Resource Limits</h1>\n<h2 id=\"the-illusion-you-are-about-to-break\">The Illusion You Are About to Break</h2>\n<p>Your container from Milestone 3 has genuine isolation: its own process tree, its own filesystem, its own network stack. But open a shell inside it and run this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inside your container ‚Äî watch this exhaust host memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">while</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    dd</span><span style=\"color:#9ECBFF\"> if=/dev/zero</span><span style=\"color:#9ECBFF\"> of=/tmp/blob</span><span style=\"color:#9ECBFF\"> bs=1M</span><span style=\"color:#9ECBFF\"> count=</span><span style=\"color:#79B8FF\">100</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span></code></pre></div>\n<p>Let it run for thirty seconds. Check your host&#39;s <code>free -m</code>. The host is running out of memory ‚Äî because your &quot;isolated&quot; container is consuming shared physical RAM with no limit. The isolation you&#39;ve built so far is <strong>visibility isolation</strong>: the container can&#39;t <em>see</em> host processes, can&#39;t <em>see</em> host files, can&#39;t <em>see</em> host network interfaces. But it can <em>consume</em> host resources without any restraint.\nNow try this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># A classic fork bomb ‚Äî inside your container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">:</span><span style=\"color:#E1E4E8\">(){ </span><span style=\"color:#79B8FF\">:</span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#E1E4E8\">&#x26; };</span><span style=\"color:#79B8FF\">:</span></span></code></pre></div>\n<h2 id=\"watch-ps-aux-on-the-host-your-container-is-spawning-thousands-of-processes-consuming-host-pids-potentially-making-the-entire-system-unresponsive-there39s-no-wall-there39s-no-limit-the-quotcontainerquot-has-a-view-restriction-but-no-resource-restriction-this-is-the-gap-that-cgroups-fills-but-before-we-get-to-the-implementation-you-need-to-shed-a-misconception-that39s-so-natural-it-will-feel-correct-even-after-you39ve-read-this-sentence\">Watch <code>ps aux</code> on the host. Your container is spawning thousands of processes, consuming host PIDs, potentially making the entire system unresponsive. There&#39;s no wall. There&#39;s no limit. The &quot;container&quot; has a view restriction but no resource restriction.\nThis is the gap that <strong>cgroups</strong> fills. But before we get to the implementation, you need to shed a misconception that&#39;s so natural it will feel correct even after you&#39;ve read this sentence.</h2>\n<h2 id=\"the-revelation-cgroups-don39t-prevent-they-react\">The Revelation: Cgroups Don&#39;t Prevent ‚Äî They React</h2>\n<p>Here is what most developers believe when they first set a memory limit:</p>\n<blockquote>\n<p>&quot;I&#39;ve set <code>memory.max = 100MB</code>. The container now has exactly 100MB of memory available. When it tries to allocate the 101st megabyte, the allocation will fail ‚Äî <code>malloc()</code> will return <code>NULL</code>, the process will handle the error, and life will continue.&quot;\nThis model is wrong in almost every detail.\nHere&#39;s what actually happens:\nThe kernel&#39;s memory accounting is <strong>lazy and retrospective</strong>. The kernel tracks how much memory is attributed to each cgroup ‚Äî RSS (resident set size, meaning pages actually in RAM), anonymous memory, and page cache ‚Äî and compares that running total against <code>memory.max</code>. But it doesn&#39;t check this limit <em>before</em> every allocation. It checks it <em>during page fault handling</em>, after the physical page has been assigned.\nWhen the cgroup&#39;s memory usage exceeds <code>memory.max</code>, the kernel doesn&#39;t return a failure code to the allocating process. Instead, it invokes the <strong>OOM killer</strong> (Out-of-Memory killer) ‚Äî a kernel subsystem that selects a process <em>inside the cgroup</em> and sends it <code>SIGKILL</code>. The selection is not random. The OOM killer uses a scoring algorithm based on <code>oom_score_adj</code> (a tunable per-process value) and memory usage to select the most expendable process.</p>\n</blockquote>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-memory-limit-oom-sequence.svg\" alt=\"Memory Limit ‚Üí OOM Kill Sequence\"></p>\n<p>The implication: <strong>a memory-limited container can appear healthy for a long time while slowly accumulating memory, then suddenly and without warning get killed.</strong> From the container&#39;s perspective ‚Äî and from the perspective of whatever monitoring you have ‚Äî everything is fine until it isn&#39;t. There&#39;s no &quot;allocation failed&quot; error. There&#39;s no graceful degradation. There&#39;s just a <code>SIGKILL</code> arriving at some process, often not even the one that was doing the allocating.\nThis is the root cause of one of the most frustrating classes of production incidents: &quot;the container just dies randomly.&quot;\nCPU limits contain an equally important surprise. Setting <code>cpu.max = &#39;50000 100000&#39;</code> (which reads as &quot;50,000 microseconds of CPU time per 100,000 microsecond period&quot;) does <em>not</em> give the container 50% of a CPU core continuously. It gives the container <em>50 milliseconds of CPU time per 100-millisecond period</em> ‚Äî and when those 50ms are consumed, the container&#39;s processes are <strong>throttled</strong> (forcibly paused by the CFS scheduler) until the next period begins, even if the host CPU is sitting at 5% utilization overall.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-cpu-throttling-timeline.svg\" alt=\"CFS CPU Throttling ‚Äî Quota/Period Timeline\"></p>\n<h2 id=\"this-throttling-is-the-source-of-one-of-kubernetes39s-most-common-and-frustrating-performance-problems-a-container-that-sets-cpu-limits-too-low-experiences-latency-spikes-at-the-period-boundary-even-when-the-node-has-plenty-of-spare-cpu-capacity-the-metric-that-reveals-this-is-cpustat39s-throttled_usec-counter-a-number-that-most-developers-never-look-at-until-something-is-mysteriously-slow-you-are-about-to-build-the-machinery-that-causes-these-behaviors-understanding-what-you39re-building-is-more-important-than-the-implementation-itself\">This throttling is the source of one of Kubernetes&#39;s most common and frustrating performance problems: a container that sets CPU limits too low experiences <strong>latency spikes</strong> at the period boundary, even when the node has plenty of spare CPU capacity. The metric that reveals this is <code>cpu.stat</code>&#39;s <code>throttled_usec</code> counter ‚Äî a number that most developers never look at until something is mysteriously slow.\nYou are about to build the machinery that causes these behaviors. Understanding what you&#39;re building is more important than the implementation itself.</h2>\n<h2 id=\"what-cgroups-are-the-kernel39s-resource-accounting-ledger\">What Cgroups Are: The Kernel&#39;s Resource Accounting Ledger</h2>\n<blockquote>\n<p><strong>üîë Foundation: cgroups v2 unified hierarchy filesystem interface</strong></p>\n<p><strong>1. What it IS</strong>\nControl Groups (cgroups) version 2 is the Linux kernel feature used to organize processes into a tree structure to manage and monitor resource usage (CPU, memory, I/O). The &quot;unified hierarchy&quot; means that, unlike version 1 which had separate trees for each resource, v2 forces all resource controllers into a single, consistent directory structure located at <code>/sys/fs/cgroup</code>. The &quot;filesystem interface&quot; refers to the fact that you manage these groups by simply creating directories and reading/writing plain text files within that path.</p>\n</blockquote>\n<p><strong>2. WHY the reader needs it right now</strong>\nModern container runtimes (like containerd and CRI-O) and Kubernetes (since version 1.25) have transitioned to cgroups v2 as the default. If you are debugging why a container is being throttled or why memory limits aren&#39;t behaving as expected, you need to look at the unified hierarchy. The files you used to check in v1 (like <code>memory.limit_in_bytes</code>) have been renamed and moved (to <code>memory.max</code>).</p>\n<p><strong>3. ONE key insight or mental model</strong>\n<strong>&quot;The Single-Writer Rule.&quot;</strong> In cgroups v2, a process cannot belong to two different groups at once, and a directory cannot both contain processes and have child groups that also contain processes (except at the root). This eliminates the &quot;spaghetti&quot; logic of v1 where a process could be in one group for CPU and a completely different group for RAM.</p>\n<p>A <strong>cgroup</strong> (control group) is a kernel data structure that associates a set of processes with a set of resource controllers. A <strong>resource controller</strong> (also called a subsystem) is a kernel module that tracks and enforces limits on a specific resource: memory, CPU time, I/O bandwidth, or process count.\nThe interaction model is unusual: cgroups are configured entirely through a <strong>pseudo-filesystem</strong> mounted at <code>/sys/fs/cgroup</code>. There are no special syscalls for cgroup operations. Creating a cgroup is <code>mkdir</code>. Assigning a process to it is <code>write(pid)</code>. Setting limits is <code>write(value)</code>. Reading usage is <code>read(file)</code>. The filesystem interface <em>is</em> the API.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># This is how you create a cgroup:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This is how you assign a process (PID 1234) to it:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> 1234</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cgroup.procs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This is how you set a 100MB memory limit:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#E1E4E8\"> $((</span><span style=\"color:#B392F0\">100</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)) </span><span style=\"color:#F97583\">></span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This is how you read current memory usage:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.current</span></span></code></pre></div>\n<p>That&#39;s the entire interface. No library, no syscall wrapper, no special header file. Read and write to files.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-cgroups-v2-hierarchy.svg\" alt=\"cgroups v2 Unified Hierarchy ‚Äî Filesystem Layout\"></p>\n<h2 id=\"the-hierarchy-is-also-a-filesystem-directory-tree-child-cgroups-inherit-constraints-from-parents-but-can-set-tighter-never-looser-limits-this-is-why-kubernetes39s-cgroup-parent-flag-works-kubernetes-creates-a-parent-cgroup-for-each-pod-and-individual-container-cgroups-live-inside-it-resource-limits-cascade\">The hierarchy is also a filesystem directory tree. Child cgroups inherit constraints from parents but can set tighter (never looser) limits. This is why Kubernetes&#39;s <code>--cgroup-parent</code> flag works: Kubernetes creates a parent cgroup for each pod, and individual container cgroups live inside it. Resource limits cascade.</h2>\n<h2 id=\"cgroups-v1-vs-v2-the-architectural-schism-you-must-detect\">cgroups v1 vs v2: The Architectural Schism You Must Detect</h2>\n<p>Linux shipped cgroups v1 starting with kernel 2.6.24 (2008). The design was decentralized: each controller (memory, cpu, pids) had its own independent hierarchy, mounted at separate paths:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>/sys/fs/cgroup/memory/mycontainer/    # v1 memory controller\n/sys/fs/cgroup/cpu/mycontainer/       # v1 CPU controller\n/sys/fs/cgroup/pids/mycontainer/      # v1 PID controller</code></pre></div>\n<p>A process could belong to different cgroups in each controller hierarchy simultaneously ‚Äî which sounds flexible but caused nightmarish consistency problems. The memory controller thought a process was in group A; the CPU controller thought it was in group B. Coordinating between controllers required keeping multiple hierarchies in sync manually.\ncgroups v2 arrived in Linux 4.5 (2016) and became the default on most distributions around 2020-2021. It uses a <strong>unified hierarchy</strong>: one directory tree under <code>/sys/fs/cgroup</code>, and a process belongs to exactly one cgroup in that tree. All controllers operate on that same cgroup. Consistency is structural, not maintained manually.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-cgroup-v1-vs-v2.svg\" alt=\"cgroups v1 vs v2 ‚Äî Architecture Comparison\"></p>\n<p>The file names changed between versions:</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>v1 file</th>\n<th>v2 file</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Assign process</td>\n<td><code>cgroup.procs</code> (same)</td>\n<td><code>cgroup.procs</code> (same)</td>\n</tr>\n<tr>\n<td>Memory limit</td>\n<td><code>memory.limit_in_bytes</code></td>\n<td><code>memory.max</code></td>\n</tr>\n<tr>\n<td>Memory usage</td>\n<td><code>memory.usage_in_bytes</code></td>\n<td><code>memory.current</code></td>\n</tr>\n<tr>\n<td>CPU quota</td>\n<td><code>cpu.cfs_quota_us</code> + <code>cpu.cfs_period_us</code></td>\n<td><code>cpu.max</code> (combined)</td>\n</tr>\n<tr>\n<td>CPU usage</td>\n<td><code>cpuacct.usage</code> (separate subsystem)</td>\n<td><code>cpu.stat</code></td>\n</tr>\n<tr>\n<td>PID limit</td>\n<td><code>pids.max</code> (same)</td>\n<td><code>pids.max</code> (same)</td>\n</tr>\n<tr>\n<td>Your code must detect which version is active before performing any cgroup operations. The detection is simple: cgroups v2 exposes a <code>cgroup.controllers</code> file at the root; v1 does not.</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Returns: 2 for v2, 1 for v1, -1 on error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> detect_cgroup_version</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> stat st;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // cgroups v2 unified hierarchy: the root exposes cgroup.controllers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/fs/cgroup/cgroup.controllers\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // cgroups v1: the root has per-subsystem directories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">stat</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/fs/cgroup/memory\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">st) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"modern-ubuntu-2204-fedora-33-debian-11-and-alpine-316-all-default-to-cgroups-v2-if-you39re-running-a-production-system-from-2019-or-earlier-you-may-still-have-v1-our-implementation-handles-both-but-optimizes-for-clarity-on-v2\">Modern Ubuntu (22.04+), Fedora (33+), Debian (11+), and Alpine (3.16+) all default to cgroups v2. If you&#39;re running a production system from 2019 or earlier, you may still have v1. Our implementation handles both, but optimizes for clarity on v2.</h2>\n<h2 id=\"the-controller-enablement-problem-the-subtlety-that-breaks-everyone\">The Controller Enablement Problem: The Subtlety That Breaks Everyone</h2>\n<p>Here is the gotcha that derails almost every first cgroups v2 implementation:\nIn cgroups v2, resource controllers are <strong>not automatically available</strong> in newly created child cgroups. Before you can use the <code>memory</code> or <code>cpu</code> controller in a child cgroup, you must explicitly enable it in the <em>parent</em> cgroup&#39;s <code>cgroup.subtree_control</code> file.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Enable memory, cpu, and pids controllers for children of root cgroup</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"+memory +cpu +pids\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/cgroup.subtree_control</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># NOW you can create a child cgroup that uses these controllers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># WITHOUT the above step, writing to memory.max gives: EINVAL</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> 104857600</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># write: Invalid argument  ‚Üê confusing error if you don't know about subtree_control</span></span></code></pre></div>\n<p>The <code>cgroup.subtree_control</code> file governs which controllers are available to <em>child</em> cgroups. The parent cgroup must delegate the controller to its children. This cascades: if you want a grandchild cgroup to have the memory controller, both the root and the intermediate parent must have <code>+memory</code> in their <code>subtree_control</code>.\nOn systemd-based systems (the vast majority of modern Linux), systemd manages the root cgroup and has already enabled the common controllers. But if you&#39;re running in a container already (a container inside a container), or on a minimal system, you may need to enable them yourself.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Enable controllers in the parent cgroup before creating the container's cgroup.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is idempotent: enabling an already-enabled controller is not an error.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> enable_controllers_v2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">parent_cgroup_path</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/cgroup.subtree_control\"</span><span style=\"color:#E1E4E8\">, parent_cgroup_path);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(path, O_WRONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"open cgroup.subtree_control\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Enable memory, cpu, and pids controllers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">controllers </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"+memory +cpu +pids\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write</span><span style=\"color:#E1E4E8\">(fd, controllers, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(controllers)) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"write cgroup.subtree_control\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-the-cgroup-manager-complete-implementation\">Building the Cgroup Manager: Complete Implementation</h2>\n<p>Now you have all the conceptual groundwork. Let&#39;s build the cgroup management layer that integrates with the container runtime from the previous milestones.\nThe architecture: the host process (the container runtime, running as root) creates and configures the cgroup <em>before</em> signaling the container to proceed. The container PID is written to <code>cgroup.procs</code> after <code>clone()</code> but before the container calls <code>exec()</code>. The synchronization pipe from Milestone 3 gives us the natural hook: host writes to sync pipe only after cgroup setup is complete.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-cgroup-lifecycle.svg\" alt=\"Cgroup Lifecycle ‚Äî Create, Assign, Monitor, Cleanup\"></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cgroup configuration ‚Äî what resource limits to apply</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\">  memory_limit_bytes;</span><span style=\"color:#6A737D\">  // -1 means \"no limit\" (write \"max\" to memory.max)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\">  cpu_quota_us;</span><span style=\"color:#6A737D\">        // CFS quota in microseconds per period; -1 = unlimited</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    long</span><span style=\"color:#E1E4E8\">  cpu_period_us;</span><span style=\"color:#6A737D\">       // CFS period in microseconds (default: 100000 = 100ms)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">   pids_max;</span><span style=\"color:#6A737D\">            // Maximum number of processes; -1 = unlimited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">cgroup_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Internal helpers: write a string or integer to a cgroup file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> cg_write_str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dir, file);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(path, O_WRONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"cgroup: open(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, value, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(value));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errno;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"cgroup: write(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">'): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, value, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> cg_write_long</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">long</span><span style=\"color:#FFAB70\"> value</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, value);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> cg_write_str</span><span style=\"color:#E1E4E8\">(dir, file, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read a cgroup file ‚Äî used for reporting and verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> cg_read_str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">dir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">size_t</span><span style=\"color:#FFAB70\"> bufsz</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dir, file);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(path, O_RDONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> read</span><span style=\"color:#E1E4E8\">(fd, buf, bufsz </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    buf</span><span style=\"color:#E1E4E8\">[n] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trim trailing newline for clean display</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[n</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#FFAB70\">buf</span><span style=\"color:#E1E4E8\">[n</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\0</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cgroups v2: configure a single unified cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROOT_V2</span><span style=\"color:#9ECBFF\">  \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> cgroup_setup_v2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            const</span><span style=\"color:#79B8FF\"> cgroup_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cg_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cg_path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROOT_V2, cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 1: Enable controllers in the root cgroup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Allow child cgroups to use memory, cpu, and pids controllers.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is idempotent; harmless if already enabled.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">enable_controllers_v2</span><span style=\"color:#E1E4E8\">(CGROOT_V2) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"cgroup: failed to enable controllers in root</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Continue ‚Äî may already be enabled by systemd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 2: Create the cgroup directory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">mkdir</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> EEXIST) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cgroup: mkdir\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 3: Write container PID to cgroup.procs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is the most critical step: it moves the container process into</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // this cgroup. All resource limits now apply to it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Must happen BEFORE exec() runs in the container.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_write_long</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"cgroup.procs\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)container_pid) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"cgroup: failed to assign PID </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> to cgroup</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] Assigned PID </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> to cgroup: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid, cg_path);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 4: Memory limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cfg->memory_limit_bytes </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_write_long</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.max\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          cfg->memory_limit_bytes) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] Memory limit: </span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\"> bytes (</span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\"> MB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               cfg->memory_limit_bytes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               cfg->memory_limit_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Also set memory.swap.max to 0 to prevent the container from</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // evading the memory limit via swap. Without this, the kernel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // can swap container pages to disk, allowing it to exceed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // memory.max in terms of virtual memory consumption.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.swap.max\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.max\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"max\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 5: CPU limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // v2 format: \"quota_us period_us\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Example: \"50000 100000\" = 50ms per 100ms = 50% of one CPU core</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cfg->cpu_quota_us </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#FFAB70\"> cpu_max</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> period </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cfg->cpu_period_us </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> cfg->cpu_period_us </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(cpu_max, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cpu_max), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#79B8FF\"> %ld</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 cfg->cpu_quota_us, period);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_write_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"cpu.max\"</span><span style=\"color:#E1E4E8\">, cpu_max) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] CPU limit: </span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">us quota / </span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\">us period (</span><span style=\"color:#79B8FF\">%.1f%%</span><span style=\"color:#9ECBFF\"> of 1 core)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               cfg->cpu_quota_us, period,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">               100.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> cfg->cpu_quota_us </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> period);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"cpu.max\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"max 100000\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 6: Process count limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cfg->pids_max </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_write_long</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"pids.max\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)cfg->pids_max) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] PID limit: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> processes</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, cfg->pids_max);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cgroups v1: configure separate controller hierarchies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROOT_V1_MEM</span><span style=\"color:#9ECBFF\">   \"/sys/fs/cgroup/memory\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROOT_V1_CPU</span><span style=\"color:#9ECBFF\">   \"/sys/fs/cgroup/cpu\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CGROOT_V1_PIDS</span><span style=\"color:#9ECBFF\">  \"/sys/fs/cgroup/pids\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> cgroup_setup_v1</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                            const</span><span style=\"color:#79B8FF\"> cgroup_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> mem_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">cpu_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">pids_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(mem_path,  </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(mem_path),  </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROOT_V1_MEM,  cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(cpu_path,  </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cpu_path),  </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROOT_V1_CPU,  cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(pids_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pids_path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROOT_V1_PIDS, cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create cgroup directories in each controller hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mkdir</span><span style=\"color:#E1E4E8\">(mem_path,  </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mkdir</span><span style=\"color:#E1E4E8\">(cpu_path,  </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mkdir</span><span style=\"color:#E1E4E8\">(pids_path, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">755</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Assign PID to each controller (must do all three)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cg_write_long</span><span style=\"color:#E1E4E8\">(mem_path,  </span><span style=\"color:#9ECBFF\">\"cgroup.procs\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cg_write_long</span><span style=\"color:#E1E4E8\">(cpu_path,  </span><span style=\"color:#9ECBFF\">\"cgroup.procs\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cg_write_long</span><span style=\"color:#E1E4E8\">(pids_path, </span><span style=\"color:#9ECBFF\">\"cgroup.procs\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Memory limit: v1 uses limit_in_bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cfg->memory_limit_bytes </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_long</span><span style=\"color:#E1E4E8\">(mem_path, </span><span style=\"color:#9ECBFF\">\"memory.limit_in_bytes\"</span><span style=\"color:#E1E4E8\">, cfg->memory_limit_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Disable swap separately in v1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_long</span><span style=\"color:#E1E4E8\">(mem_path, </span><span style=\"color:#9ECBFF\">\"memory.memsw.limit_in_bytes\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      cfg->memory_limit_bytes);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CPU quota: v1 uses separate quota and period files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cfg->cpu_quota_us </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> period </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cfg->cpu_period_us </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#E1E4E8\"> cfg->cpu_period_us </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_long</span><span style=\"color:#E1E4E8\">(cpu_path, </span><span style=\"color:#9ECBFF\">\"cpu.cfs_period_us\"</span><span style=\"color:#E1E4E8\">, period);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_long</span><span style=\"color:#E1E4E8\">(cpu_path, </span><span style=\"color:#9ECBFF\">\"cpu.cfs_quota_us\"</span><span style=\"color:#E1E4E8\">, cfg->cpu_quota_us);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // PID limit: same file name in v1 and v2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (cfg->pids_max </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cg_write_long</span><span style=\"color:#E1E4E8\">(pids_path, </span><span style=\"color:#9ECBFF\">\"pids.max\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\">)cfg->pids_max);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Public API: detect version and dispatch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> cgroup_setup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_name</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                 const</span><span style=\"color:#79B8FF\"> cgroup_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cfg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> version </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> detect_cgroup_version</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] Detected cgroups v</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, version);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> cgroup_setup_v2</span><span style=\"color:#E1E4E8\">(cgroup_name, container_pid, cfg);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> cgroup_setup_v1</span><span style=\"color:#E1E4E8\">(cgroup_name, container_pid, cfg);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"cgroup: cannot detect cgroup version</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"cleanup-you-cannot-rmdir-a-live-cgroup\">Cleanup: You Cannot <code>rmdir</code> a Live Cgroup</h2>\n<p>Cgroup lifecycle has a rule that bites every first implementation:\n<strong>You cannot remove a cgroup directory with <code>rmdir()</code> while any process is assigned to it.</strong>\nThe kernel returns <code>EBUSY</code> if the cgroup has any live processes. The cleanup sequence must be:</p>\n<ol>\n<li>Wait for all container processes to exit (your existing <code>waitpid()</code> loop handles this)</li>\n<li>Then <code>rmdir()</code> the cgroup directory\nBut there&#39;s a subtlety: zombie processes still count as &quot;live&quot; in the kernel&#39;s cgroup accounting until they&#39;re reaped with <code>waitpid()</code>. Your PID 1 reaper from Milestone 1 ensures orphans are reaped, but you must call <code>waitpid()</code> on the container init process itself before attempting cleanup.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Cleanup: remove cgroup directory after all processes have exited</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cgroup_cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> version </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> detect_cgroup_version</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROOT_V2, cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">rmdir</span><span style=\"color:#E1E4E8\">(path) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[cgroup] cleanup: rmdir(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EBUSY) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[cgroup] cleanup: processes still in cgroup \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                                \"(zombie not reaped?)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] Cleaned up: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (version </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Must rmdir each controller hierarchy separately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">roots</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CGROOT_V1_MEM, CGROOT_V1_CPU, CGROOT_V1_PIDS, </span><span style=\"color:#79B8FF\">NULL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">roots</span><span style=\"color:#E1E4E8\">[i]; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">roots</span><span style=\"color:#E1E4E8\">[i], cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            rmdir</span><span style=\"color:#E1E4E8\">(path);</span><span style=\"color:#6A737D\">  // Best-effort; log but don't abort</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"resource-observability-reading-the-cgroup-meters\">Resource Observability: Reading the Cgroup Meters</h2>\n<p>The cgroup filesystem exposes live resource usage as readable files. These are the exact files that cAdvisor and the kubelet read to feed Prometheus metrics ‚Äî and you can read them directly with <code>cat</code> or <code>open()</code>/<code>read()</code> in C.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Report current resource usage for a v2 cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">void</span><span style=\"color:#B392F0\"> cgroup_report_v2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">cgroup_name</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cg_path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cg_path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CGROOT_V2, cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Memory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_read_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.current\"</span><span style=\"color:#E1E4E8\">, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        long</span><span style=\"color:#E1E4E8\"> mem_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> atol</span><span style=\"color:#E1E4E8\">(buf);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] memory.current: </span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#9ECBFF\"> bytes (</span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\"> MB)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               mem_bytes, mem_bytes </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_read_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.max\"</span><span style=\"color:#E1E4E8\">, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] memory.max: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ CPU ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // cpu.stat contains multiple fields: usage_usec, user_usec, system_usec,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // throttled_usec (how long processes were paused due to CFS throttling),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // throttled_periods (how many 100ms periods had throttling)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_read_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"cpu.stat\"</span><span style=\"color:#E1E4E8\">, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] cpu.stat:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Parse and display each line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">line </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (line) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"         </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, line);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> strtok</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ PIDs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_read_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"pids.current\"</span><span style=\"color:#E1E4E8\">, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] pids.current: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cg_read_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"pids.max\"</span><span style=\"color:#E1E4E8\">, buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf)) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[cgroup] pids.max: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, buf);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h2 id=\"the-most-revealing-field-in-cpustat-is-throttled_usec-if-this-number-is-non-zero-and-growing-your-container-is-being-cpu-throttled-processes-are-spending-time-waiting-for-the-next-cfs-period-to-begin-rather-than-actually-executing-a-container-with-throttled_usec-growing-at-1-second-per-10-seconds-of-wall-time-is-experiencing-10-cpu-throttling-which-will-appear-as-10-longer-response-times-for-every-request-that-runs-through-that-cpu-period-boundary\">The most revealing field in <code>cpu.stat</code> is <code>throttled_usec</code>. If this number is non-zero and growing, your container is being CPU-throttled ‚Äî processes are spending time waiting for the next CFS period to begin rather than actually executing. A container with <code>throttled_usec</code> growing at 1 second per 10 seconds of wall time is experiencing ~10% CPU throttling, which will appear as 10% longer response times for every request that runs through that CPU period boundary.</h2>\n<h2 id=\"integrating-cgroups-into-the-container-runtime\">Integrating Cgroups Into the Container Runtime</h2>\n<p>Here is the complete integration point with the container runtime from Milestones 1-3. The key change: cgroup setup happens on the <strong>host side</strong>, after <code>clone()</code> returns the container PID but before the sync pipe signals the container to proceed.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Updated main() ‚Äî integrates cgroup resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;rootfs> &#x3C;outbound-iface> &#x3C;command> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">rootfs       </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">outbound_if  </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">      **</span><span style=\"color:#E1E4E8\">container_cmd </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Cgroup configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 100MB memory, 50% of one CPU core, max 32 processes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cgroup_config_t</span><span style=\"color:#E1E4E8\"> cg_cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .memory_limit_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // 100 MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .cpu_quota_us       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">               // 50ms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .cpu_period_us      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">              // per 100ms period</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pids_max           </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cgroup_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mycontainer\"</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ DNS, sync pipe, stack allocation (from Milestone 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_resolv_conf</span><span style=\"color:#E1E4E8\">(rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(sync_pipe) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pipe\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, STACK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       MAP_PRIVATE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_ANONYMOUS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_STACK,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stack </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MAP_FAILED) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mmap\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mprotect</span><span style=\"color:#E1E4E8\">(stack, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, PROT_NONE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#E1E4E8\"> cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .rootfs         </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)rootfs,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .argv           </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> container_cmd,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .outbound_iface </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)outbound_if,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .sync_pipe_read </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ clone() with all namespace flags ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> container_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_init, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWPID  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWUTS  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNS   </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNET  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                &#x26;</span><span style=\"color:#E1E4E8\">cfg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (container_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clone\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container host PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Cgroup setup ‚Äî BEFORE signaling container to proceed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The container is blocked on read(sync_pipe_read).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is our window to apply resource limits before exec() runs.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cgroup_setup</span><span style=\"color:#E1E4E8\">(cgroup_name, container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cg_cfg) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host] Cgroup setup failed ‚Äî terminating</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(container_pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Network setup (from Milestone 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">setup_host_network</span><span style=\"color:#E1E4E8\">(container_pid, outbound_if) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host] Network setup failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(container_pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        cgroup_cleanup</span><span style=\"color:#E1E4E8\">(cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Signal container: all setup complete, proceed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container ready. Resources limited.</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Monitor loop: print resource usage every 5 seconds ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In a real runtime, this would be a separate thread.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Here we fork a simple monitor process.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> monitor_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (monitor_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Monitor child: poll cgroup stats until container exits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            cgroup_report_v2</span><span style=\"color:#E1E4E8\">(cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container exited</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Terminate monitor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (monitor_pid </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">kill</span><span style=\"color:#E1E4E8\">(monitor_pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Cleanup: network, then cgroup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ORDER MATTERS: clean network first (no process dependency),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // then cgroup (requires all processes to have exited ‚Äî waitpid above</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ensures the init process has exited, and since it's PID 1, all</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // namespace processes were killed when it exited).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cleanup_network</span><span style=\"color:#E1E4E8\">(outbound_if);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cgroup_cleanup</span><span style=\"color:#E1E4E8\">(cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"verifying-memory-limits-triggering-the-oom-killer\">Verifying Memory Limits: Triggering the OOM Killer</h2>\n<p>The best way to understand the OOM killer is to trigger it. Here is a small C program that allocates memory in a tight loop and touches every page (forcing it to be resident ‚Äî allocated but not touched doesn&#39;t consume physical memory in Linux&#39;s overcommitted allocator):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// oom_test.c ‚Äî allocate memory until killed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> chunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\">  // 10 MB per step</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PID </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> starting memory allocation...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">p </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> malloc</span><span style=\"color:#E1E4E8\">(chunk);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">p) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"malloc failed at </span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\"> MB total</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    total </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">60</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Stay alive so we can observe zombie state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // CRITICAL: memset forces the kernel to actually allocate physical pages.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Without this, malloc succeeds via overcommit but RSS stays low.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        memset</span><span style=\"color:#E1E4E8\">(p, </span><span style=\"color:#F97583\">0x</span><span style=\"color:#79B8FF\">AA</span><span style=\"color:#E1E4E8\">, chunk);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> chunk;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Allocated </span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\"> MB total</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, total </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024.0</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile this and put it in your container rootfs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> alpine-rootfs/bin/oom_test</span><span style=\"color:#9ECBFF\"> oom_test.c</span></span></code></pre></div>\n<p>Run the container with a 100MB memory limit and execute <code>oom_test</code> inside it:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container_m4</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#9ECBFF\"> /bin/oom_test</span></span></code></pre></div>\n<p>Expected output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[cgroup] Detected cgroups v2\n[cgroup] Assigned PID 12345 to cgroup: /sys/fs/cgroup/mycontainer\n[cgroup] Memory limit: 104857600 bytes (100.0 MB)\n...\nInside container, /bin/oom_test:\nAllocated 10.0 MB total\nAllocated 20.0 MB total\n...\nAllocated 90.0 MB total\nAllocated 100.0 MB total\nKilled                    ‚Üê OOM killer sent SIGKILL\n[host] Container exited</code></pre></div>\n<p>Notice: the process doesn&#39;t gracefully fail. It doesn&#39;t receive a catchable signal. <code>SIGKILL</code> cannot be handled or ignored ‚Äî the process simply stops. From the process&#39;s perspective, nothing happened. It was allocating memory, and then it ceased to exist.\nYou can observe the OOM event from the host:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -20</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> oom</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [12345.678] oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#             cpuset=mycontainer,mems_allowed=0,oom_memcg=/mycontainer,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#             task_memcg=/mycontainer,task=oom_test,pid=12346,uid=0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [12345.678] Memory cgroup out of memory: Killed process 12346 (oom_test)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#             total-vm:105472kB, anon-rss:103424kB, file-rss:1024kB</span></span></code></pre></div>\n<p>The kernel&#39;s <code>oom-kill</code> message tells you exactly which cgroup triggered the OOM kill, which process was selected, and how much memory it was using.</p>\n<blockquote>\n<p><strong>üîë Foundation: Linux OOM killer process selection algorithm and oom_score_adj</strong></p>\n<p><strong>1. What it IS</strong>\nThe Out-Of-Memory (OOM) Killer is the kernel&#39;s &quot;emergency janitor.&quot; When the system&#39;s RAM is completely exhausted, the OOM Killer selects a process to terminate to save the system from crashing. It uses a scoring algorithm (<code>oom_score</code>) ranging from 0 to 1000. This score is primarily based on the percentage of allowed memory the process is using, which is then adjusted by the <code>oom_score_adj</code> (a value from -1000 to +1000) provided by the user or orchestrator.</p>\n</blockquote>\n<p><strong>2. WHY the reader needs it right now</strong>\nIn Kubernetes, &quot;OOMKilled&quot; is a common pod status. To prevent your critical database from being killed instead of a background worker, you must understand how Kubernetes manipulates the <code>oom_score_adj</code>. If you don&#39;t set your resource requests and limits correctly, the kernel might see your most important application as the &quot;best&quot; candidate for termination during a memory crunch.</p>\n<p><strong>3. ONE key insight or mental model</strong>\n<strong>&quot;The Bad Neighbor Calculation.&quot;</strong> Think of the OOM Killer as looking for the process that is &quot;taking more than its fair share.&quot; A process using 90% of its limit with a high adjustment score will always be killed before a process using 10% of its limit with a low adjustment score.</p>\n<hr>\n<h2 id=\"verifying-cpu-throttling-the-cfs-quota-mechanism\">Verifying CPU Throttling: The CFS Quota Mechanism</h2>\n<p>CPU throttling is more subtle than OOM kills because the process doesn&#39;t die ‚Äî it just becomes sluggish in a way that&#39;s difficult to distinguish from a slow algorithm.\nA stress test to demonstrate throttling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cpu_stress.c ‚Äî burn CPU and report throughput</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;time.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdint.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"PID </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> burning CPU...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        struct</span><span style=\"color:#E1E4E8\"> timespec start, end;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">start);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Do 100 million iterations of arithmetic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        volatile</span><span style=\"color:#F97583\"> uint64_t</span><span style=\"color:#E1E4E8\"> sum </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">uint64_t</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000000</span><span style=\"color:#F97583\">ULL</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> i;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        clock_gettime</span><span style=\"color:#E1E4E8\">(CLOCK_MONOTONIC, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">end);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        double</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (end.tv_sec </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start.tv_sec) </span><span style=\"color:#F97583\">+</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         (end.tv_nsec </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start.tv_nsec) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">e</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"100M iterations in </span><span style=\"color:#79B8FF\">%.3f</span><span style=\"color:#9ECBFF\">s (</span><span style=\"color:#79B8FF\">%.1f</span><span style=\"color:#9ECBFF\">M iter/sec), sum=</span><span style=\"color:#79B8FF\">%lu\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               elapsed, </span><span style=\"color:#79B8FF\">100.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> elapsed, (</span><span style=\"color:#F97583\">unsigned</span><span style=\"color:#F97583\"> long</span><span style=\"color:#E1E4E8\">)sum);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Run this in your container with a 50% CPU limit (<code>cpu_quota_us=50000, cpu_period_us=100000</code>). Compare:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Without CPU limit (full core available):\n100M iterations in 0.089s (1123.6M iter/sec)\n100M iterations in 0.088s (1136.4M iter/sec)\n# With 50% CPU limit (50ms quota per 100ms period):\n100M iterations in 0.178s (561.8M iter/sec)    ‚Üê ~2x slower (as expected)\n100M iterations in 0.210s (476.2M iter/sec)    ‚Üê sometimes slower due to period boundary\n100M iterations in 0.165s (606.1M iter/sec)    ‚Üê variability from throttling boundary timing</code></pre></div>\n<p>The variability is the tell: without throttling, throughput is consistent. With throttling, iterations that straddle a period boundary take longer ‚Äî the process was mid-computation when its quota ran out and it was forced to sleep until the next period.\nNow read the throttling statistics:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># From the HOST, while the container is running:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cpu.stat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># usage_usec 1234567        ‚Üê total CPU time consumed (microseconds)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># user_usec 1100000         ‚Üê time in user space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># system_usec 134567        ‚Üê time in kernel space</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># nr_periods 1532           ‚Üê number of 100ms periods elapsed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># nr_throttled 847          ‚Üê periods where the cgroup was throttled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># throttled_usec 42350000   ‚Üê total microseconds spent throttled</span></span></code></pre></div>\n<p><code>nr_throttled / nr_periods</code> gives you the throttle ratio. In this case: <code>847 / 1532 ‚âà 55%</code> ‚Äî more than half of all periods hit the quota limit. <code>throttled_usec / nr_periods</code> gives the average throttle time per period: <code>42350000 / 1532 ‚âà 27.6ms</code> ‚Äî meaning the process waited an average of 27.6ms per period even though the host CPU was otherwise idle.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-cpu-throttling-timeline.svg\" alt=\"CFS CPU Throttling ‚Äî Quota/Period Timeline\"></p>\n<h2 id=\"this-is-the-kubernetes-throttling-problem-in-miniature-a-kubernetes-pod-with-resourceslimitscpu-quot05quot-half-a-core-gets-cpumax-quot50000-100000quot-if-the-pod-runs-a-bursty-workload-periodic-http-requests-each-doing-80ms-of-cpu-work-those-requests-will-be-throttled-at-the-period-boundary-even-when-the-node-has-15-spare-cpu-cores-the-fix-is-to-either-raise-the-limit-switch-to-cpuweight-requests-only-no-hard-limit-or-increase-the-period-we39ll-explore-these-in-the-knowledge-cascade\">This is the Kubernetes throttling problem in miniature. A Kubernetes pod with <code>resources.limits.cpu: &quot;0.5&quot;</code> (half a core) gets <code>cpu.max = &quot;50000 100000&quot;</code>. If the pod runs a bursty workload ‚Äî periodic HTTP requests each doing 80ms of CPU work ‚Äî those requests will be throttled at the period boundary even when the node has 15 spare CPU cores. The fix is to either raise the limit, switch to <code>cpu.weight</code> (requests-only, no hard limit), or increase the period. We&#39;ll explore these in the Knowledge Cascade.</h2>\n<h2 id=\"verifying-fork-bomb-containment\">Verifying Fork Bomb Containment</h2>\n<p>The fork bomb test is the most viscerally satisfying verification because you can feel the difference between a contained and uncontained explosion:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inside the container with pids.max=32:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">:</span><span style=\"color:#E1E4E8\">(){ </span><span style=\"color:#79B8FF\">:</span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#E1E4E8\">&#x26; };</span><span style=\"color:#79B8FF\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># bash: fork: Resource temporarily unavailable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># bash: fork: Resource temporarily unavailable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ... (a dozen times, then stops)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The shell survives. The host is unaffected.</span></span></code></pre></div>\n<p>Without <code>pids.max</code>, this command would exhaust the kernel&#39;s global PID limit (default 4,194,304 on modern kernels, often 32,768 on older ones), making it impossible for any new process to start anywhere on the host until the zombie processes are cleared.\nWith <code>pids.max=32</code>, the kernel counts processes assigned to the cgroup. When any <code>fork()</code> or <code>clone()</code> in the cgroup would cause the count to exceed 32, the syscall returns <code>EAGAIN</code> (&quot;try again&quot; ‚Äî but there&#39;s no point trying). The fork bomb starts, saturates the limit at 32, and stalls. The container&#39;s shell process survives because it was already running.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-pids-max-fork-bomb.svg\" alt=\"pids.max Fork Bomb Containment\"></p>\n<p>Read the current process count from the host:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/pids.current</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 28     ‚Üê 28 processes (the fork bomb hit the ceiling)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/pids.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 32</span></span></code></pre></div>\n<h2 id=\"after-the-fork-bomb-processes-die-they-exit-quickly-since-they-have-nothing-to-do-pidscurrent-drops-back-to-the-baseline-container-process-count\">After the fork bomb processes die (they exit quickly since they have nothing to do), <code>pids.current</code> drops back to the baseline container process count.</h2>\n<h2 id=\"hardware-soul-what-the-kernel-is-actually-doing\">Hardware Soul: What the Kernel Is Actually Doing</h2>\n<h3 id=\"memory-accounting-the-page-fault-path\">Memory Accounting: The Page Fault Path</h3>\n<p>Every time your container process accesses a new virtual memory page for the first time (which triggers a <strong>page fault</strong>), the kernel&#39;s memory allocator attributes that page to the cgroup. Here&#39;s the path:</p>\n<ol>\n<li>Process accesses unmapped address ‚Üí CPU raises <code>#PF</code> exception</li>\n<li>Kernel&#39;s <code>do_page_fault()</code> ‚Üí <code>handle_pte_fault()</code> ‚Üí <code>do_anonymous_page()</code></li>\n<li><code>do_anonymous_page()</code> calls <code>mem_cgroup_charge()</code> before allocating the physical page</li>\n<li><code>mem_cgroup_charge()</code> checks the cgroup&#39;s current usage against <code>memory.max</code></li>\n<li>If limit exceeded: <code>try_charge_memcg()</code> ‚Üí triggers memory reclaim ‚Üí may invoke OOM killer</li>\n<li>If limit not exceeded: page is charged to the cgroup, physical frame allocated</li>\n<li>Page table updated, execution resumes\n<strong>Cache behavior</strong>: The cgroup memory accounting structures live in kernel memory. The hot path for a page fault that doesn&#39;t hit the limit is approximately:</li>\n</ol>\n<ul>\n<li>2-3 pointer dereferences into the <code>mem_cgroup</code> struct</li>\n<li>Atomic increment of the memory counter (cache line bounce if multi-threaded ‚Äî every concurrent allocation from the same cgroup contends on this counter)</li>\n<li>The counter is 8 bytes, fits in one cache line, but that cache line is exclusively owned by the accounting logic\n<strong>Latency impact</strong>: Normal page fault handling takes approximately 1-3 Œºs. Memory accounting (the cgroup charge check) adds roughly 50-200 ns on an uncontested cache line. Under heavy multi-threaded allocation from the same cgroup, the counter contention adds more. This is why memory-intensive workloads sometimes show slightly higher allocation latency when running inside cgroup-limited containers compared to unconstrained processes.</li>\n</ul>\n<h3 id=\"cfs-scheduler-the-bandwidth-controller\">CFS Scheduler: The Bandwidth Controller</h3>\n<p>[[EXPLAIN:completely-fair-scheduler-(cfs)-and-bandwidth-controller|Linux CFS scheduler bandwidth controller ‚Äî quota, period, and throttle mechanism]]\nThe CPU limit is enforced by the <strong>CFS bandwidth controller</strong> ‚Äî a component of the Completely Fair Scheduler. The kernel maintains a per-cgroup runtime budget:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>runtime_remaining = cpu.max quota (e.g., 50000 Œºs)</code></pre></div>\n<p>Each time a thread in the cgroup runs, the elapsed CPU time is subtracted from <code>runtime_remaining</code>. When <code>runtime_remaining</code> reaches zero, every runnable thread in the cgroup is removed from the scheduler&#39;s run queues and placed in a &quot;throttle&quot; list. A high-resolution timer (<code>hrtimer</code>) fires at the next period boundary, refills <code>runtime_remaining</code> to the quota value, and unthrottles all threads ‚Äî they go back on the run queues.\n<strong>The bandwidth accounting is per-CPU but with a global pool</strong>. Each CPU core maintains a local sub-quota (called a &quot;slice&quot;) to reduce contention. When a CPU&#39;s slice is exhausted, it borrows more from the global pool. When the global pool is exhausted, all CPUs in the cgroup are throttled together. This design reduces the contention on the global counter (which would otherwise be a scalability bottleneck on NUMA systems with many cores).\n<strong>Memory access pattern</strong>: The throttle list is a linked list of task structs. Unthrottling involves walking this list and re-inserting each task into its CPU&#39;s run queue. For a cgroup with 32 processes all throttled simultaneously, this is 32 list operations at period boundary ‚Äî sequential pointer traversal, likely in L2/L3 cache since these structs were recently accessed.\n<strong>Latency floor</strong>: Even if a cgroup has quota remaining, the minimum scheduler granularity is <code>sysctl_sched_min_granularity_ns</code> (typically 750 Œºs - 6 ms depending on system load). A cgroup process cannot get less than one granularity slice of CPU time per scheduling decision. This means very low CPU limits (e.g., <code>cpu.max = &quot;1000 100000&quot;</code> for 1% of a core) cause very frequent context switches and high scheduling overhead relative to useful work.</p>\n<h3 id=\"pidsmax-atomic-fork-count\">pids.max: Atomic Fork Count</h3>\n<p>The PID limit check is the simplest of the three controllers. In <code>kernel/fork.c</code>&#39;s <code>copy_process()</code> function (which is called by both <code>fork()</code> and <code>clone()</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Simplified kernel code path (conceptual ‚Äî not actual kernel source)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">task_pids_current</span><span style=\"color:#E1E4E8\">(cgroup) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#B392F0\"> pids_max_for_cgroup</span><span style=\"color:#E1E4E8\">(cgroup)) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ERR_PTR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">EAGAIN);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">atomic_inc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cgroup</span><span style=\"color:#F97583\">-></span><span style=\"color:#E1E4E8\">pids.events_count);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... proceed with process creation</span></span></code></pre></div>\n<h2 id=\"the-check-is-a-single-atomic-comparison-on-an-unconstrained-cgroup-pidsmax-quotmaxquot-this-comparison-is-skipped-entirely-no-overhead-on-a-constrained-cgroup-it39s-one-atomic-load-plus-one-comparison-on-the-order-of-5-20-ns-depending-on-cache-state-negligible-the-eagain-return-code-propagates-back-to-fork-in-userspace-which-sets-errno-eagain-this-is-why-you-see-fork-resource-temporarily-unavailable-in-the-fork-bomb-output-eagain-is-quotresource-temporarily-unavailablequot-in-the-posix-error-space\">The check is a single atomic comparison. On an unconstrained cgroup (<code>pids.max = &quot;max&quot;</code>), this comparison is skipped entirely ‚Äî no overhead. On a constrained cgroup, it&#39;s one atomic load plus one comparison ‚Äî on the order of 5-20 ns depending on cache state. Negligible.\nThe <code>EAGAIN</code> return code propagates back to <code>fork()</code> in userspace, which sets <code>errno = EAGAIN</code>. This is why you see <code>fork: Resource temporarily unavailable</code> in the fork bomb output ‚Äî <code>EAGAIN</code> is &quot;resource temporarily unavailable&quot; in the POSIX error space.</h2>\n<h2 id=\"pitfall-compendium-the-mistakes-that-will-ruin-your-weekend\">Pitfall Compendium: The Mistakes That Will Ruin Your Weekend</h2>\n<h3 id=\"pitfall-1-writing-to-cgroupprocs-after-exec\">Pitfall 1: Writing to cgroup.procs After exec()</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>‚ùå WRONG timeline:\n   clone() ‚Üí exec() runs inside container ‚Üí (container now running your binary)\n            ‚Üí write PID to cgroup.procs ‚Üê WRONG: the exec'd binary is running unconstrained\n‚úÖ CORRECT timeline:\n   clone() ‚Üí write PID to cgroup.procs ‚Üí signal container via pipe\n            ‚Üí container reads pipe, proceeds ‚Üí exec() runs inside cgroup</code></pre></div>\n<p>The window between <code>clone()</code> and <code>exec()</code> is your only opportunity to apply cgroup limits before any user code runs. The sync pipe from Milestone 3 creates this window precisely for this purpose. If you write to <code>cgroup.procs</code> after <code>exec()</code>, the user process has been running without resource limits ‚Äî it may have already allocated memory above your limit, and the OOM kill might be immediate and surprising.</p>\n<h3 id=\"pitfall-2-not-writing-to-memoryswapmax\">Pitfall 2: Not Writing to <code>memory.swap.max</code></h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå INCOMPLETE: memory.max alone doesn't prevent swap usage</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cg_write_long</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.max\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ COMPLETE: also cap swap to 0 for strict memory containment</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cg_write_long</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.max\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cg_write_str</span><span style=\"color:#E1E4E8\">(cg_path, </span><span style=\"color:#9ECBFF\">\"memory.swap.max\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n<p>Without <code>memory.swap.max = 0</code>, a container that hits its memory limit doesn&#39;t immediately get OOM killed. The kernel first tries to reclaim memory by swapping pages out to disk. The container&#39;s RSS drops below <code>memory.max</code>, the OOM killer backs off, and the container continues running ‚Äî but with every memory access now going through disk I/O (swap reads/writes cost 10-100ms each vs. 100ns for RAM). The container appears &quot;alive&quot; but is actually in a death spiral of swapping, becoming 100-10,000x slower. Setting <code>memory.swap.max = 0</code> ensures the OOM killer fires immediately when RSS exceeds the limit, which is usually the right behavior for containers.</p>\n<h3 id=\"pitfall-3-forgetting-cgroupsubtree_control-on-v2\">Pitfall 3: Forgetting <code>cgroup.subtree_control</code> on v2</h3>\n<p>The symptom: <code>write(memory.max)</code> returns <code>EINVAL</code>. The cause: the <code>memory</code> controller is not enabled in the parent cgroup&#39;s <code>subtree_control</code>. This is the most common first-time cgroups v2 error because v1 had no equivalent concept.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Diagnosis:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/cgroup.subtree_control</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># cpu io memory pids    ‚Üê if memory is here, it's enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># If memory is missing:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"+memory\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/cgroup.subtree_control</span></span></code></pre></div>\n<p>On systemd systems, the common controllers are pre-enabled. On minimal systems (Alpine running from RAM, embedded Linux), you may need to enable them yourself.</p>\n<h3 id=\"pitfall-4-cleanup-order-rmdir-before-processes-exit\">Pitfall 4: Cleanup Order ‚Äî rmdir Before Processes Exit</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG: cgroup still has processes; rmdir returns EBUSY</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kill</span><span style=\"color:#E1E4E8\">(container_pid, SIGKILL);</span><span style=\"color:#6A737D\">  // Signal sent but not necessarily delivered yet</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cgroup_cleanup</span><span style=\"color:#E1E4E8\">(cgroup_name);</span><span style=\"color:#6A737D\">   // EBUSY ‚Äî container_pid may still be alive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT: wait for process to actually exit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kill</span><span style=\"color:#E1E4E8\">(container_pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // Blocks until process is dead AND reaped</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cgroup_cleanup</span><span style=\"color:#E1E4E8\">(cgroup_name);</span><span style=\"color:#6A737D\">   // Safe ‚Äî all processes gone</span></span></code></pre></div>\n<p><code>SIGKILL</code> delivery is asynchronous. Sending the signal doesn&#39;t mean the process has exited ‚Äî it means the signal has been queued. The process must be scheduled, receive the signal, and have its exit handled by the kernel before <code>rmdir</code> can succeed. <code>waitpid()</code> blocks until all of this has happened and the process&#39;s resources are fully released.</p>\n<h3 id=\"pitfall-5-cpu-period-too-large-or-too-small\">Pitfall 5: CPU Period Too Large or Too Small</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå TOO SMALL period: high scheduling overhead, poor throughput</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.cpu_quota_us  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">    // 5ms quota</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.cpu_period_us </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // per 10ms period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 50% of a core, but the scheduler must context-switch every 10ms minimum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå TOO LARGE period: poor responsiveness and bursty behavior</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.cpu_quota_us  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5000000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // 5 seconds of CPU</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.cpu_period_us </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10000000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\"> // per 10-second period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container can use 5 full seconds of CPU, then is throttled for 5 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Latency spikes of up to 5 seconds!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ STANDARD period: good balance of overhead and responsiveness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.cpu_quota_us  </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">   // 50ms quota</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">.cpu_period_us </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // per 100ms period (Kubernetes default)</span></span></code></pre></div>\n<p>The 100ms period (<code>100000 Œºs</code>) is the Kubernetes default and a good general-purpose choice. It&#39;s small enough that throttling causes at most 100ms latency spikes (acceptable for most services) and large enough that scheduler overhead is negligible. High-frequency trading systems and hard real-time workloads use smaller periods (1-10ms) or bypass CFS entirely with <code>SCHED_FIFO</code>.</p>\n<h3 id=\"pitfall-6-the-v1-memory-swap-accounting-split\">Pitfall 6: The v1 Memory + Swap Accounting Split</h3>\n<h2 id=\"in-cgroups-v1-memory-and-swap-accounting-are-separate-controllers-and-the-combined-limit-is-memorymemswlimit_in_bytes-a-different-file-than-memorylimit_in_bytes-if-you-only-set-memorylimit_in_bytes-in-v1-the-container-can-exceed-the-limit-via-swap-the-v1-code-above-shows-the-correct-approach-set-both-in-v2-memorymax-and-memoryswapmax-are-separate-but-both-must-be-set-for-strict-containment-the-semantic-is-cleaner-in-v2\">In cgroups v1, memory and swap accounting are separate controllers, and the combined limit is <code>memory.memsw.limit_in_bytes</code> ‚Äî a different file than <code>memory.limit_in_bytes</code>. If you only set <code>memory.limit_in_bytes</code> in v1, the container can exceed the limit via swap. The v1 code above shows the correct approach: set both.\nIn v2, <code>memory.max</code> and <code>memory.swap.max</code> are separate but both must be set for strict containment. The semantic is cleaner in v2.</h2>\n<h2 id=\"knowledge-cascade-from-container-to-cluster\">Knowledge Cascade: From Container to Cluster</h2>\n<h3 id=\"1-kubernetes-resource-requests-vs-limits-the-invisible-performance-knob\">1. Kubernetes Resource Requests vs. Limits: The Invisible Performance Knob</h3>\n<p>Kubernetes has two resource fields for CPU: <code>requests</code> and <code>limits</code>. They map to different cgroup mechanisms:</p>\n<ul>\n<li><strong><code>resources.requests.cpu: &quot;500m&quot;</code></strong> (500 millicores = 0.5 core) ‚Üí sets <code>cpu.weight</code> (cgroups v2) or <code>cpu.shares</code> (v1). This is <strong>proportional sharing</strong>: if the node has spare capacity, the container can use more than 500m. <code>cpu.weight</code> is a relative priority ‚Äî a container with weight 100 gets twice the CPU of one with weight 50 when both are CPU-hungry. When the node is idle, a container with <code>requests: 100m</code> can burst to 100% of a core.</li>\n<li><strong><code>resources.limits.cpu: &quot;500m&quot;</code></strong> ‚Üí sets <code>cpu.max = &quot;50000 100000&quot;</code>. This is a <strong>hard ceiling</strong>: the container will be throttled even if the node has 15 idle cores. The container cannot burst above this limit, ever.\nThe implication: setting CPU limits in Kubernetes trades burst capacity for predictability. A container with only <code>requests</code> (no <code>limits</code>) can burst when the node has spare capacity, which is usually what you want. A container with tight <code>limits</code> will be throttled ‚Äî causing the latency spikes you saw in the verification section ‚Äî even when the node is completely idle.</li>\n</ul>\n<blockquote>\n<p><strong>üîë Foundation: Kubernetes Quality of Service</strong></p>\n<p><strong>1. What it IS</strong>\nKubernetes assigns every Pod a Quality of Service (QoS) class‚Äî<strong>Guaranteed</strong>, <strong>Burstable</strong>, or <strong>BestEffort</strong>‚Äîbased on its <code>requests</code> and <code>limits</code>. Kubernetes then maps these classes to specific cgroup configurations. For example, a &quot;Guaranteed&quot; pod gets an <code>oom_score_adj</code> of -997 (making it nearly impossible to kill), while a &quot;BestEffort&quot; pod gets a +1000 (making it the first to die). It also maps CPU requests to cgroup &quot;weights&quot; to ensure fair sharing during CPU contention.</p>\n</blockquote>\n<p><strong>2. WHY the reader needs it right now</strong>\nYou cannot manually set cgroup values in Kubernetes; you can only influence them via the QoS class. Understanding this mapping is the only way to predict how your application will behave under pressure. If you have a &quot;Burstable&quot; pod with a large gap between request and limit, it is at high risk of being killed if the node runs out of memory, even if it hasn&#39;t hit its own limit yet.</p>\n<p><strong>3. ONE key insight or mental model</strong>\n<strong>&quot;Priority as a Safety Net.&quot;</strong> QoS classes are the translation layer between your YAML intent and the Linux kernel&#39;s enforcement. Your Pod&#39;s YAML manifest is essentially a request for a specific &quot;survival priority&quot; in the eyes of the Linux kernel.</p>\n<p>The Kubernetes community has an ongoing debate: <a href=\"https://home.robusta.dev/blog/stop-using-cpu-limits\">should you set CPU limits at all?</a> The answer is nuanced: limits prevent one runaway container from starving others on the same node, but limits set too low cause <code>throttled_usec</code> to grow and latency to spike. The right answer is: set <code>requests</code> accurately (the scheduler uses this for placement), set <code>limits</code> conservatively above the p99 CPU usage (not the average), and monitor <code>throttled_usec</code> in production.</p>\n<h3 id=\"2-oom-killer-scoring-and-kubernetes-qos\">2. OOM Killer Scoring and Kubernetes QoS</h3>\n<p>When the OOM killer selects a process to kill inside a cgroup (or system-wide when the host is under memory pressure), it uses an <strong><code>oom_score</code></strong> ‚Äî a number from 0 to 1000 that represents how &quot;killable&quot; the process is. Higher score = killed first.\n<code>oom_score</code> is calculated from:</p>\n<ul>\n<li>Process memory usage (higher usage ‚Üí higher score)</li>\n<li><code>oom_score_adj</code> ‚Äî a tunable from -1000 to 1000 written to <code>/proc/&lt;pid&gt;/oom_score_adj</code>\nKubernetes sets <code>oom_score_adj</code> based on the pod&#39;s QoS class:<table>\n<thead>\n<tr>\n<th>Kubernetes QoS Class</th>\n<th>Condition</th>\n<th><code>oom_score_adj</code></th>\n<th>Behavior under pressure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Guaranteed</strong></td>\n<td>requests == limits for all resources</td>\n<td>-997</td>\n<td>Last to be killed</td>\n</tr>\n<tr>\n<td><strong>Burstable</strong></td>\n<td>requests set, limits set but != requests</td>\n<td>proportional to memory %</td>\n<td>Killed in middle</td>\n</tr>\n<tr>\n<td><strong>BestEffort</strong></td>\n<td>no requests or limits</td>\n<td>1000</td>\n<td>First to be killed</td>\n</tr>\n<tr>\n<td>A BestEffort pod has <code>oom_score_adj = 1000</code>, meaning the OOM killer selects it first when the node runs out of memory. This is intentional: BestEffort pods have made no resource claims and get no guarantees. Guaranteed pods have <code>oom_score_adj = -997</code>, meaning the OOM killer almost never selects them (only if truly nothing else is available to kill).</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>You can read and set <code>oom_score_adj</code> directly in C:</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Set the container's OOM priority (called from container_init() before exec)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> set_oom_score_adj</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> adj</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // adj: -1000 (never kill) to 1000 (kill first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/self/oom_score_adj\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">f) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fopen oom_score_adj\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, adj);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In container_init(), before exec:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">set_oom_score_adj</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Neutral ‚Äî system default behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Or: set_oom_score_adj(500) for a lower-priority container (killed sooner)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Or: set_oom_score_adj(-500) for a higher-priority container (killed later)</span></span></code></pre></div>\n<h3 id=\"3-memory-accounting-subtleties-the-page-cache-trap\">3. Memory Accounting Subtleties: The Page Cache Trap</h3>\n<p>Here&#39;s a surprise that bites production deployments: <strong>reading files counts against the cgroup&#39;s memory limit</strong>, even though the process has no explicit allocation for that data.\nWhen a process calls <code>read(fd, buf, n)</code> or <code>mmap()</code>s a file, the kernel satisfies the read from the <strong>page cache</strong> ‚Äî a kernel-managed cache of disk file contents. These cached pages are attributed to the cgroup of the process that read them. If your 100MB-limited container reads 150MB of log files (perhaps via <code>grep</code>), those 150MB of cache pages push the cgroup&#39;s <code>memory.current</code> over 100MB, and the OOM killer fires.\nThe container&#39;s actual application heap (the data it explicitly <code>malloc()</code>&#39;d) might only be 5MB. But the page cache attribution causes the OOM kill.\nThe kernel&#39;s memory reclaim algorithm does handle this: when a cgroup approaches its limit, the kernel first tries to reclaim <strong>page cache pages</strong> (since they can be re-read from disk). Only if reclaim fails to bring usage below the limit does the OOM killer run. But reclaim takes time, and during reclaim, every memory access that would normally be a cache hit becomes a disk read ‚Äî causing a temporary performance cliff before the OOM kill.\nMonitoring <code>memory.stat</code> (a more detailed version of the summary you get from <code>memory.current</code>) reveals the breakdown:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.stat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># anon 52428800      ‚Üê anonymous memory (heap, stack) = 50MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># file 58720256      ‚Üê page cache = 56MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># total = ~108MB ‚Üí over a 100MB limit despite the heap being only 50MB</span></span></code></pre></div>\n<p>Production containers serving files or reading large datasets should set their <code>memory.max</code> to account for realistic page cache usage, not just heap usage. Alternatively, use <code>POSIX_FADV_DONTNEED</code> hints (<code>posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED)</code>) to tell the kernel to release cached pages after reading.</p>\n<h3 id=\"4-cgroup-delegation-for-rootless-containers\">4. cgroup Delegation for Rootless Containers</h3>\n<p>Milestone 5 will implement user namespaces for rootless containers. But rootless containers have a resource limiting problem: writing to cgroup files requires write permission on those files, which normally requires root.\nThe solution is <strong>cgroup delegation</strong>: a privileged process (typically systemd) creates a subtree of the cgroup hierarchy and grants ownership of it to an unprivileged user. The user can then create child cgroups within that subtree and apply resource limits ‚Äî without root.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Systemd can delegate a cgroup slice to a user:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">loginctl</span><span style=\"color:#9ECBFF\"> enable-linger</span><span style=\"color:#E1E4E8\"> $USER  </span><span style=\"color:#6A737D\"># Allow user's systemd slice to persist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># systemd automatically creates:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># owned by UID 1000 ‚Äî writable without root</span></span></code></pre></div>\n<p>Rootless Podman and rootless Docker use this delegation mechanism. When you run <code>podman run --memory=100m</code> as a non-root user, Podman creates a cgroup under the delegated subtree and applies the limit ‚Äî no root required. The kernel enforces the resource limit just the same.\nThis delegation is why the Milestone 5 implementation note about &quot;cgroup delegation for rootless&quot; exists: to run cgroup operations without root, you need systemd (or another privileged process) to have pre-delegated a cgroup subtree to your user. Your user namespace alone doesn&#39;t grant cgroup write permission ‚Äî delegation is a separate mechanism.</p>\n<h3 id=\"5-container-observability-the-cgroup-filesystem-as-metrics-source\">5. Container Observability: The cgroup Filesystem as Metrics Source</h3>\n<blockquote>\n<p><strong>üîë Foundation: How cAdvisor reads cgroup files to produce Prometheus metrics for Kubernetes</strong></p>\n<p><strong>1. What it IS</strong>\ncAdvisor (Container Advisor) is an open-source agent integrated into the Kubelet binary. It acts as a bridge between the Linux kernel and monitoring tools. It &quot;walks&quot; the cgroup filesystem tree (e.g., <code>/sys/fs/cgroup/kubepods.slice/...</code>), reads the raw binary/text counters provided by the kernel, aggregates them, and exports them as Prometheus-formatted metrics via the <code>/metrics/cadvisor</code> endpoint on the Kubelet.</p>\n</blockquote>\n<p><strong>2. WHY the reader needs it right now</strong>\nWhen you use <code>kubectl top</code>, Prometheus, or Datadog, you aren&#39;t looking at &quot;live&quot; data directly from the container; you are looking at a snapshot processed by this pipeline. If metrics are missing or delayed, the bottleneck is usually here. Knowing this pipeline exists helps you trace issues from the &quot;Metric&quot; (e.g., <code>container_cpu_usage_seconds_total</code>) back to the &quot;Source&quot; (the cgroup file <code>cpu.stat</code>).</p>\n<p><strong>3. ONE key insight or mental model</strong>\n<strong>&quot;The Translator.&quot;</strong> cAdvisor is a specialized file-parser. It doesn&#39;t &quot;ask&quot; the container how much memory it&#39;s using; it reads the kernel&#39;s internal accounting books (cgroup files) and translates that &quot;kernel-speak&quot; into &quot;human-observable metrics.&quot;</p>\n<p>Every metric you see in a Kubernetes dashboard ‚Äî container CPU usage, container memory usage, container process count ‚Äî originates from reading the cgroup filesystem files you just implemented. The pipeline:</p>\n<ol>\n<li><strong>kubelet</strong> (the per-node Kubernetes agent) embeds <strong>cAdvisor</strong> (Container Advisor)</li>\n<li>cAdvisor scans <code>/sys/fs/cgroup/</code> periodically (default: 15s)</li>\n<li>For each container&#39;s cgroup directory, it reads:<ul>\n<li><code>memory.current</code> ‚Üí <code>container_memory_working_set_bytes</code> in Prometheus</li>\n<li><code>cpu.stat</code> (specifically <code>usage_usec</code>) ‚Üí <code>container_cpu_usage_seconds_total</code></li>\n<li><code>cpu.stat</code> (specifically <code>throttled_usec</code>) ‚Üí <code>container_cpu_cfs_throttled_seconds_total</code></li>\n<li><code>pids.current</code> ‚Üí <code>container_processes</code></li>\n</ul>\n</li>\n<li>cAdvisor exposes these as Prometheus metrics on port 8080 (<code>/metrics/cadvisor</code>)</li>\n<li>Prometheus scrapes these metrics and stores them</li>\n<li>Grafana queries Prometheus and renders dashboards\nWhen you&#39;re debugging a Kubernetes performance issue and you query <code>container_cpu_cfs_throttled_seconds_total</code>, you&#39;re reading a derived value from the same <code>throttled_usec</code> field in <code>cpu.stat</code> that you just learned to read with <code>cat</code>. The metric has a Prometheus name, a nice Grafana panel, and elaborate alert rules ‚Äî but at the bottom of the stack, it&#39;s a 64-bit integer in a file at <code>/sys/fs/cgroup/&lt;pod&gt;/&lt;container&gt;/cpu.stat</code>. \nYou can bypass the entire monitoring stack and read it directly:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># On a Kubernetes node, find the container's cgroup:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTAINER_ID</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">crictl</span><span style=\"color:#9ECBFF\"> ps</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> myapp</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> awk</span><span style=\"color:#9ECBFF\"> '{print $1}'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CGROUP_PATH</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">find</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup</span><span style=\"color:#79B8FF\"> -name</span><span style=\"color:#9ECBFF\"> \"cgroup.procs\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    xargs</span><span style=\"color:#9ECBFF\"> grep</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">crictl</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#E1E4E8\"> $CONTAINER_ID </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> '.info.pid'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    head</span><span style=\"color:#79B8FF\"> -1</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> xargs</span><span style=\"color:#9ECBFF\"> dirname</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Read CPU throttling directly:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#E1E4E8\"> $CGROUP_PATH</span><span style=\"color:#9ECBFF\">/cpu.stat</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> throttled_usec</span></span></code></pre></div>\n<p>This is one of the most powerful debugging techniques for Kubernetes performance: bypass the monitoring abstraction and read the ground truth directly from the kernel.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-cgroup-lifecycle.svg\" alt=\"Cgroup Lifecycle ‚Äî Create, Assign, Monitor, Cleanup\"></p>\n<hr>\n<h2 id=\"the-three-level-view-a-resource-limited-malloc\">The Three-Level View: A Resource-Limited <code>malloc()</code></h2>\n<p>When your container calls <code>malloc(10 * 1024 * 1024)</code> ‚Äî allocating 10MB ‚Äî and then touches every byte with <code>memset()</code>, here&#39;s what happens at all three levels:\n<strong>Level 1 ‚Äî Application (your container process)</strong>:</p>\n<ul>\n<li><code>malloc(10MB)</code> ‚Üí <code>mmap(NULL, 10MB, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)</code></li>\n<li>Returns a virtual address range. The memory is &quot;allocated&quot; but not yet backed by physical pages.</li>\n<li><code>memset(ptr, 0, 10MB)</code> ‚Üí touching each byte triggers page faults.\n<strong>Level 2 ‚Äî OS/Kernel</strong>:</li>\n<li>Each page fault calls <code>do_page_fault()</code> ‚Üí <code>handle_mm_fault()</code> ‚Üí <code>do_anonymous_page()</code></li>\n<li><code>mem_cgroup_charge()</code> is called: atomically increment the cgroup&#39;s <code>memory.current</code> counter</li>\n<li>If <code>memory.current &gt; memory.max</code>: trigger memory reclaim. If reclaim fails: invoke OOM killer ‚Üí <code>SIGKILL</code> to selected process.</li>\n<li>If within limit: allocate a physical frame, update page tables, return to user.\n<strong>Level 3 ‚Äî Hardware</strong>:</li>\n<li>The page fault is raised by the CPU&#39;s Memory Management Unit (MMU) when it finds no valid Page Table Entry (PTE) for the virtual address.</li>\n<li>The kernel sets the PTE to point to the newly allocated physical frame.</li>\n<li>The TLB (Translation Lookaside Buffer ‚Äî the CPU&#39;s cache of virtual-to-physical address translations) is updated with the new mapping.</li>\n<li>On NUMA (Non-Uniform Memory Access) systems with multiple CPU sockets, the kernel tries to allocate the physical frame on the NUMA node closest to the CPU that triggered the fault ‚Äî &quot;local&quot; allocation. If the local NUMA node&#39;s memory is full, it falls back to &quot;remote&quot; allocation from another node, which costs 2-3x more latency (60ns local vs. 120-200ns remote for DRAM access).\nThe cgroup accounting layer (Level 2) adds roughly 50-200ns to each page fault. For an application that triggers millions of page faults per second (large <code>malloc</code>/<code>memset</code> loops), this overhead is measurable. For normal workloads, it&#39;s negligible.</li>\n</ul>\n<hr>\n<h2 id=\"compilation-and-testing-running-the-complete-stack\">Compilation and Testing: Running the Complete Stack</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Compile the full container runtime with cgroup support</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> container_m4</span><span style=\"color:#9ECBFF\"> container_m4.c</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Ensure Alpine rootfs is available</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs/bin/</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#F97583\"> 2>&#x26;1</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mkdir</span><span style=\"color:#79B8FF\"> -p</span><span style=\"color:#9ECBFF\"> alpine-rootfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    curl</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#9ECBFF\"> https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/</span><span style=\"color:#79B8FF\">\\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">alpine-minirootfs-3.19.0-x86_64.tar.gz </span><span style=\"color:#F97583\">|</span><span style=\"color:#B392F0\"> tar</span><span style=\"color:#79B8FF\"> -xz</span><span style=\"color:#79B8FF\"> -C</span><span style=\"color:#9ECBFF\"> alpine-rootfs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compile test binaries and install them in the rootfs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> alpine-rootfs/bin/oom_test</span><span style=\"color:#9ECBFF\"> oom_test.c</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -O2</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> alpine-rootfs/bin/cpu_stress</span><span style=\"color:#9ECBFF\"> cpu_stress.c</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run with 100MB memory limit, 50% CPU, 32 max processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container_m4</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside the container ‚Äî test OOM:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">/bin/oom_test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside the container ‚Äî test CPU throttling:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">/bin/cpu_stress</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># From the HOST (while container is running):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cpu.stat</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.current</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside the container ‚Äî test fork bomb containment:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">:</span><span style=\"color:#E1E4E8\">(){ </span><span style=\"color:#79B8FF\">:</span><span style=\"color:#F97583\">|</span><span style=\"color:#79B8FF\">:</span><span style=\"color:#E1E4E8\">&#x26; };</span><span style=\"color:#79B8FF\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should fail with \"Resource temporarily unavailable\" after ~32 processes</span></span></code></pre></div>\n<hr>\n<h2 id=\"verification-checklist\">Verification Checklist</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 1. Detect cgroup version correctly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/cgroup.controllers</span><span style=\"color:#F97583\"> 2></span><span style=\"color:#9ECBFF\">/dev/null</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"v2\"</span><span style=\"color:#F97583\"> ||</span><span style=\"color:#79B8FF\"> echo</span><span style=\"color:#9ECBFF\"> \"v1\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 2. Verify cgroup directory was created ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/</span><span style=\"color:#6A737D\">      # Should exist while container runs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 3. Verify container PID is in the cgroup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cgroup.procs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show the container's host PID (e.g., 12345)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 4. Verify memory limit is set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: 104857600  (100 * 1024 * 1024)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 5. Verify CPU limit is set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cpu.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: 50000 100000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 6. Verify PID limit is set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/pids.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show: 32</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 7. OOM kill verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run oom_test inside container; it should be killed before reaching 110MB</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">dmesg</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> tail</span><span style=\"color:#79B8FF\"> -5</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -i</span><span style=\"color:#9ECBFF\"> \"oom\\|memory cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show OOM kill event for the container's cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 8. CPU throttling verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run cpu_stress inside container for 30 seconds, then:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cpu.stat</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> throttled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># nr_throttled should be > 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># throttled_usec should be > 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 9. Fork bomb containment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run fork bomb inside container; verify pids.current never exceeds pids.max</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">watch</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#9ECBFF\"> 'cat /sys/fs/cgroup/mycontainer/pids.current'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should stabilize at ‚â§32, not grow unboundedly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 10. Cgroup cleanup after container exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After container exits:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/</span><span style=\"color:#F97583\"> 2>&#x26;1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should give: ls: cannot access '/sys/fs/cgroup/mycontainer/': No such file or directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 11. Resource usage reporting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># While container is running:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/memory.current</span><span style=\"color:#6A737D\">  # Live memory usage in bytes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/cpu.stat</span><span style=\"color:#6A737D\">        # Detailed CPU statistics</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/mycontainer/pids.current</span><span style=\"color:#6A737D\">    # Current process count</span></span></code></pre></div>\n<hr>\n<h2 id=\"looking-ahead\">Looking Ahead</h2>\n<p>You now have a container that isolates its process tree, filesystem, network stack, and resource consumption. The cgroup layer is the last resource enforcement mechanism ‚Äî the container cannot exceed its CPU allocation, cannot consume unlimited memory, and cannot spawn unlimited processes.\nBut if you run <code>id</code> inside the container:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>uid=0(root) gid=0(root)</code></pre></div>\n<h2 id=\"your-container-is-running-as-root-not-effective-root-inside-a-namespace-actual-root-on-the-host-if-there39s-a-container-escape-vulnerability-a-bug-in-your-pivot_root-sequence-a-missing-seccomp-filter-a-suid-binary-in-the-rootfs-the-escaping-process-has-full-root-access-on-the-host-milestone-5-user-namespaces-and-rootless-containers-solves-this-by-creating-a-user-namespace-where-the-container-process-appears-to-be-root-inside-the-container-but-maps-to-an-unprivileged-uid-on-the-host-the-uid-0-inside-the-container-becomes-uid-1000-on-the-host-an-escaped-process-has-only-the-privileges-of-uid-1000-not-root-user-namespace-creation-is-also-the-key-that-removes-the-sudo-requirement-from-your-entire-container-runtime-with-clone_newuser-unprivileged-users-can-create-network-namespaces-mount-namespaces-and-pid-namespaces-capabilities-that-currently-require-cap_sys_admin-the-kernel39s-reasoning-if-you-can-only-affect-your-own-namespaced-resources-you39re-not-actually-gaining-privileges-that-affect-anyone-else-the-clone_newuser-flag-slots-directly-into-your-existing-clone-call-alongside-the-other-namespace-flags-the-complication-is-the-uidgid-mapping-write-sequence-a-precise-ordering-requirement-enforced-by-the-kernel-that-causes-confusing-eperm-errors-if-violated-we39ll-dissect-that-sequence-carefully-in-milestone-5\">Your container is running as root. Not effective root inside a namespace ‚Äî actual root on the host. If there&#39;s a container escape vulnerability (a bug in your <code>pivot_root</code> sequence, a missing seccomp filter, a suid binary in the rootfs), the escaping process has full root access on the host.\nMilestone 5 (User Namespaces and Rootless Containers) solves this by creating a user namespace where the container process <em>appears</em> to be root inside the container, but maps to an unprivileged UID on the host. The <code>UID 0</code> inside the container becomes <code>UID 1000</code> on the host. An escaped process has only the privileges of UID 1000 ‚Äî not root.\nUser namespace creation is also the key that removes the <code>sudo</code> requirement from your entire container runtime. With <code>CLONE_NEWUSER</code>, unprivileged users can create network namespaces, mount namespaces, and PID namespaces ‚Äî capabilities that currently require <code>CAP_SYS_ADMIN</code>. The kernel&#39;s reasoning: if you can only affect your own namespaced resources, you&#39;re not actually gaining privileges that affect anyone else.\nThe <code>CLONE_NEWUSER</code> flag slots directly into your existing <code>clone()</code> call alongside the other namespace flags. The complication is the UID/GID mapping write sequence ‚Äî a precise ordering requirement enforced by the kernel that causes confusing <code>EPERM</code> errors if violated. We&#39;ll dissect that sequence carefully in Milestone 5.</h2>\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m5 -->\n<!-- MS_ID: container-basic-m5 -->\n<h1 id=\"milestone-5-user-namespace-and-rootless-containers\">Milestone 5: User Namespace and Rootless Containers</h1>\n<h2 id=\"the-misconception-you-carry-into-this-milestone\">The Misconception You Carry Into This Milestone</h2>\n<p>Every container you&#39;ve built so far requires <code>sudo</code>. Every <code>clone()</code> call with <code>CLONE_NEWPID</code>, <code>CLONE_NEWNS</code>, <code>CLONE_NEWNET</code> demands <code>CAP_SYS_ADMIN</code> ‚Äî the Linux capability that grants sweeping kernel-level access. You&#39;ve been running as root.\nThis feels inevitable. After all, you&#39;re manipulating kernel data structures, swapping root filesystems, creating virtual network interfaces. Surely this requires elevated privileges?\nNow here&#39;s the misconception worth dismantling:</p>\n<blockquote>\n<p>&quot;Rootless containers are a security theater compromise. UID 0 inside a user namespace is &#39;fake root&#39; ‚Äî a cosmetic label with no real capabilities. Rootless containers severely limit what containers can do, sacrificing real functionality for the marketing claim of &#39;no root required.&#39;&quot;\n<strong>This is wrong in almost every detail.</strong>\nHere is what actually happens when you create a user namespace:\nThe kernel grants the process inside the user namespace a <strong>full capability set</strong> ‚Äî <code>CAP_SYS_ADMIN</code>, <code>CAP_NET_ADMIN</code>, <code>CAP_SYS_CHROOT</code>, <code>CAP_MKNOD</code>, the full set of 41 capabilities defined in <code>&lt;linux/capability.h&gt;</code>. Not a subset. Not a crippled version. The complete capability set.\nBut those capabilities are <strong>scoped</strong> to the resources owned by the user namespace. The kernel&#39;s capability check asks a different question: not &quot;does this process have the capability?&quot; but &quot;does this process have the capability <em>in the user namespace that owns the target resource</em>?&quot;\nThis distinction is everything. A process with <code>CAP_SYS_ADMIN</code> inside a user namespace can:</p>\n</blockquote>\n<ul>\n<li>Mount filesystems <em>inside its own mount namespace</em></li>\n<li>Create PID, UTS, and network namespaces <em>owned by its user namespace</em></li>\n<li>Perform <code>pivot_root()</code> <em>within its own mount namespace</em></li>\n<li>Write to cgroup files <em>within delegated cgroup subtrees</em>\nBut the same process <strong>cannot</strong>:</li>\n<li>Write to <code>/etc/passwd</code> on the host (the host&#39;s filesystem is owned by the initial user namespace)</li>\n<li>Load kernel modules (affects the host kernel, outside the namespace&#39;s scope)</li>\n<li>Modify host network interfaces (owned by the initial network namespace)</li>\n<li>Send signals to arbitrary host processes (outside the PID namespace)\nThis is not a hack. This is the Linux kernel&#39;s designed security model for capability scoping ‚Äî and it is the foundation of Podman&#39;s rootless mode that runs millions of container workloads in production. By the end of this milestone, you&#39;ll remove <code>sudo</code> from your container runtime entirely, and your containers will be more secure than the rootful versions you&#39;ve been building.</li>\n</ul>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-capability-scoping.svg\" alt=\"Capability Scoping Across User Namespaces\"></p>\n<hr>\n<h2 id=\"the-problem-user-namespaces-solve-privilege-without-exposure\">The Problem User Namespaces Solve: Privilege Without Exposure</h2>\n<p>[[EXPLAIN:linux-capabilities-model-(cap_sys_admin,-cap_net_admin)|Linux capabilities model (CAP_SYS_ADMIN, CAP_NET_ADMIN)]]\nBefore user namespaces (pre-Linux 3.8), container runtimes faced an inescapable dilemma:</p>\n<ul>\n<li>Creating namespaces requires <code>CAP_SYS_ADMIN</code> ‚Äî which requires running as root or with a setuid binary</li>\n<li>Running as root means that a container escape vulnerability gives the attacker <strong>full host root access</strong></li>\n<li>The attack surface for container escapes was enormous: pivot_root bugs, mount namespace escapes, overlayfs vulnerabilities, cgroup misconfigurations\nThe choice was: &quot;give the container runtime root, and hope nothing goes wrong&quot; versus &quot;don&#39;t use containers.&quot; Neither is acceptable in a security-conscious environment.\nUser namespaces resolve this dilemma by making the privilege grant <em>scoped</em> rather than <em>global</em>. The kernel&#39;s security model shifts from &quot;you either have the capability or you don&#39;t&quot; to &quot;you have the capability within the scope of resources your namespace owns.&quot; An escaping container process has only the capabilities of the unprivileged host user ‚Äî not root. The blast radius of any escape drops from &quot;full host compromise&quot; to &quot;unprivileged user account on the host.&quot;</li>\n</ul>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-rootless-vs-rootful-comparison.svg\" alt=\"Rootful vs Rootless Container Stack ‚Äî Security Comparison\"></p>\n<h2 id=\"this-is-why-the-security-research-community-considers-user-namespace-based-rootless-containers-categorically-more-secure-than-rootful-containers-despite-providing-the-same-isolation-guarantees-the-comparison-target-podman39s-rootless-mode-enabled-by-default-since-podman-10-2018-is-built-entirely-on-user-namespaces\">This is why the security research community considers user namespace-based rootless containers categorically more secure than rootful containers, despite providing the same isolation guarantees. The comparison target: Podman&#39;s rootless mode, enabled by default since Podman 1.0 (2018), is built entirely on user namespaces.</h2>\n<h2 id=\"how-user-namespace-uid-mapping-works-the-core-mechanism\">How User Namespace UID Mapping Works: The Core Mechanism</h2>\n<p>[[EXPLAIN:user-namespace-uid/gid-mapping-semantics|User namespace UID/GID mapping semantics]]\nA user namespace creates a private mapping between <strong>inside UIDs</strong> and <strong>outside UIDs</strong>. The mapping is a set of translation rules written to two files: <code>/proc/&lt;pid&gt;/uid_map</code> and <code>/proc/&lt;pid&gt;/gid_map</code>.\nEach line in these files is a triple:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>&lt;inside_start&gt;  &lt;outside_start&gt;  &lt;count&gt;</code></pre></div>\n<p>This means: &quot;UIDs from <code>inside_start</code> to <code>inside_start + count - 1</code> inside the namespace map to UIDs from <code>outside_start</code> to <code>outside_start + count - 1</code> outside.&quot;\nThe simplest and most common mapping for container use:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>0  1000  1</code></pre></div>\n<p>This says: &quot;UID 0 inside the namespace maps to UID 1000 outside.&quot; The container sees itself as root. The host sees it as the normal user with UID 1000. One UID mapped, in both directions.\nA broader mapping for supporting more UIDs inside the container (important for multi-user container images):</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>0  100000  65536</code></pre></div>\n<p>This maps UIDs 0-65535 inside the container to UIDs 100000-165535 on the host. The container can have 65,536 distinct users ‚Äî root, daemon, nobody, and application-specific UIDs ‚Äî all mapped to a safe range of subordinate UIDs on the host that no real person uses.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-user-ns-uid-mapping.svg\" alt=\"User Namespace UID Mapping ‚Äî Inside vs Outside View\"></p>\n<p>The kernel enforces this translation transparently. When a container process calls <code>getuid()</code>, the kernel translates the process&#39;s real UID (1000 on the host) through the mapping to return 0. When the container creates a file owned by UID 0, the kernel stores it on disk as owned by UID 1000 (or 100000 in the broader mapping). When a host process reads that file&#39;s ownership, it sees UID 1000. This translation happens in the kernel&#39;s VFS layer on every <code>stat()</code>, <code>chown()</code>, <code>open()</code>, and file creation operation.\nThe security property: a container running as UID 0 inside its namespace, creating files in a <code>tmpfs</code> or <code>overlayfs</code>, stores those files owned by the subordinate UID range on disk. If the container escapes and tries to access files owned by real UIDs (root&#39;s files, other users&#39; files), the translation reveals that the escaped process has no special privileges ‚Äî it&#39;s just UID 1000.</p>\n<h3 id=\"the-mapping-file-format-in-detail\">The Mapping File Format in Detail</h3>\n<p>The exact syntax matters. The files accept whitespace-separated triples, one per line:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># /proc/&lt;pid&gt;/uid_map ‚Äî inside_uid  outside_uid  count\n0 1000 1         # UID 0 inside ‚Üí UID 1000 outside (1 UID mapped)</code></pre></div>\n<h2 id=\"multiple-lines-are-allowed-up-to-340-entries-a-kernel-limit-each-line-must-be-a-non-overlapping-range-the-kernel-validates-the-mapping-when-written-and-rejects-invalid-configurations-with-einval-the-write-must-happen-from-outside-the-namespace-specifically-from-a-process-in-the-parent-user-namespace-the-container-process-itself-cannot-write-its-own-uid-map-this-is-a-security-invariant-the-entity-granting-capabilities-cannot-self-grant-them-the-parent-which-you-control-writes-the-mapping-that-determines-what-capabilities-the-child-namespace-has\">Multiple lines are allowed (up to 340 entries, a kernel limit). Each line must be a non-overlapping range. The kernel validates the mapping when written and rejects invalid configurations with <code>EINVAL</code>.\nThe write must happen from <strong>outside</strong> the namespace ‚Äî specifically, from a process in the <strong>parent</strong> user namespace. The container process itself cannot write its own UID map. This is a security invariant: the entity granting capabilities cannot self-grant them. The parent (which you control) writes the mapping that determines what capabilities the child namespace has.</h2>\n<h2 id=\"the-setgroups-requirement-a-security-fix-made-permanent\">The setgroups Requirement: A Security Fix Made Permanent</h2>\n<p>Before writing <code>gid_map</code>, you must write <code>&quot;deny&quot;</code> to <code>/proc/&lt;pid&gt;/setgroups</code>. This is not optional. If you skip it, writing to <code>gid_map</code> as an unprivileged user returns <code>EPERM</code>.\nHere&#39;s why this requirement exists:\nThe <code>setgroups()</code> syscall allows a process to change its supplementary group IDs. Historically, a user could call <code>setgroups()</code> to <em>drop</em> their supplementary groups ‚Äî giving up privileges. User namespaces created a problem: if an unprivileged user (UID 1000) creates a user namespace and writes a GID map that maps their GID to GID 0 (root), they could then call <code>setgroups()</code> to <em>add</em> group 0 to their supplementary groups ‚Äî even though no privilege grant was intended. This was CVE-2014-8989, a privilege escalation bug.\nThe kernel&#39;s fix: before an unprivileged user can write <code>gid_map</code>, they must declare whether <code>setgroups()</code> is allowed in this namespace. Writing <code>&quot;deny&quot;</code> disables <code>setgroups()</code> for all processes in the namespace, eliminating the attack vector. Writing <code>&quot;allow&quot;</code> permits <code>setgroups()</code> but then requires the caller to have <code>CAP_SETGID</code> in the parent namespace (which an unprivileged user doesn&#39;t have, so they can&#39;t write <code>gid_map</code> at all).\nThe consequence: <strong>all unprivileged user namespace creation must write <code>&quot;deny&quot;</code> to <code>setgroups</code> before writing <code>gid_map</code></strong>. This has been required since Linux 3.19 (2015).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// The mandatory sequence (order is enforced by kernel):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 1. Write \"deny\" to setgroups</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// 2. Write gid_map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// If you reverse steps 1 and 2 for an unprivileged user, step 2 returns EPERM.</span></span></code></pre></div>\n<hr>\n<h2 id=\"building-the-uidgid-map-writer-complete-implementation\">Building the UID/GID Map Writer: Complete Implementation</h2>\n<p>The map writing code runs in the <strong>parent process</strong> (your container runtime, the host side), after <code>clone()</code> returns the container PID but before the container proceeds past the sync pipe.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Write a string to a /proc/&#x3C;pid>/&#x3C;file> entry.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// These files have specific write semantics: they accept exactly one write()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// call (not multiple writes to the same fd). Write the entire content at once.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> proc_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">content</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"/proc/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid, file);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // O_WRONLY only ‚Äî these files don't support O_RDWR</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(path, O_WRONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"proc_write: open(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write the entire content in one write() call.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // The kernel requires this for uid_map/gid_map ‚Äî partial writes are rejected.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, content, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(content));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errno;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"proc_write: write(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, '</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">'): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                path, content, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Configure UID/GID mappings for a newly created user namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Parameters:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   container_pid   ‚Äî host PID of the container's init process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   host_uid        ‚Äî the unprivileged UID on the host (your real UID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//   host_gid        ‚Äî the unprivileged GID on the host (your real GID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mapping chosen: 0 ‚Üí host_uid (1 UID mapped)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This makes UID 0 inside the container appear as host_uid outside.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> write_uid_gid_maps</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uid_t</span><span style=\"color:#FFAB70\"> host_uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">gid_t</span><span style=\"color:#FFAB70\"> host_gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> map_content</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 1: Write uid_map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Format: \"&#x3C;inside_uid> &#x3C;outside_uid> &#x3C;count>\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // \"0 &#x3C;host_uid> 1\" means: UID 0 inside = host_uid outside, 1 UID mapped</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(map_content, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(map_content), </span><span style=\"color:#9ECBFF\">\"0 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_uid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#9ECBFF\">\"uid_map\"</span><span style=\"color:#E1E4E8\">, map_content) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"write_uid_gid_maps: uid_map write failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[userns] uid_map written: 0 ‚Üí </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (1 UID)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_uid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 2: Write \"deny\" to setgroups BEFORE gid_map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MANDATORY for unprivileged user namespace creation (since Linux 3.19).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Prevents privilege escalation via setgroups() within the namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This MUST happen before gid_map is written; reverse order returns EPERM.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#9ECBFF\">\"setgroups\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"deny\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"write_uid_gid_maps: setgroups deny failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 3: Write gid_map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Same format as uid_map. GID 0 inside = host_gid outside.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(map_content, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(map_content), </span><span style=\"color:#9ECBFF\">\"0 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_gid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#9ECBFF\">\"gid_map\"</span><span style=\"color:#E1E4E8\">, map_content) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"write_uid_gid_maps: gid_map write failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[userns] gid_map written: 0 ‚Üí </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (1 GID)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_gid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-uid-gid-map-write-sequence.svg\" alt=\"UID/GID Map Write Sequence ‚Äî Timing and Ordering\"></p>\n<hr>\n<h2 id=\"the-synchronization-challenge-mapping-must-precede-exec\">The Synchronization Challenge: Mapping Must Precede exec()</h2>\n<p>Adding user namespace support introduces a new timing constraint on top of the synchronization pipe from Milestone 3. The full ordering requirement is:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HOST SIDE                                   CONTAINER SIDE\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1. clone(CLONE_NEWUSER | ...) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  (born into new user namespace)\n   returns container_pid                     (UID is &quot;nobody&quot; ‚Äî mapping not yet set)\n                                             (blocks reading from sync_pipe_read[0])\n2. write_uid_gid_maps(container_pid, ...)   \n   ‚Üë MUST happen before container proceeds ‚Üë\n3. cgroup_setup(cgroup_name, container_pid)\n4. setup_host_network(container_pid, if)\n5. write sync_pipe &quot;1&quot; ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  6. reads &quot;1&quot; from sync_pipe\n                                             7. (now UID 0 inside namespace)\n                                             8. mounts, pivot_root, network config\n                                             9. exec() user command</code></pre></div>\n<h2 id=\"the-container-process-must-not-proceed-to-any-privileged-operation-mounting-sethostname-etc-until-the-uidgid-maps-are-written-before-the-mapping-is-set-the-container-process-has-an-effectively-unmapped-uid-attempts-to-call-privileged-syscalls-fail-with-eperm-because-the-capability-check-finds-no-valid-user-namespace-mapping-the-sync-pipe-naturally-enforces-this-the-container-blocks-at-readsync_pipe_read-the-host-writes-the-maps-step-2-configures-cgroups-step-3-sets-up-networking-step-4-then-unblocks-the-container-step-5-by-the-time-the-container-reads-from-the-pipe-its-namespace-is-fully-configured\">The container process must not proceed to any privileged operation (mounting, sethostname, etc.) until the UID/GID maps are written. Before the mapping is set, the container process has an effectively unmapped UID ‚Äî attempts to call privileged syscalls fail with <code>EPERM</code> because the capability check finds no valid user namespace mapping.\nThe sync pipe naturally enforces this. The container blocks at <code>read(sync_pipe_read, ...)</code>. The host writes the maps (step 2), configures cgroups (step 3), sets up networking (step 4), then unblocks the container (step 5). By the time the container reads from the pipe, its namespace is fully configured.</h2>\n<h2 id=\"what-changes-inside-container_init-with-user-namespaces\">What Changes Inside <code>container_init()</code> with User Namespaces</h2>\n<p>With user namespace support, the container init function gains two important changes:</p>\n<ol>\n<li><strong>It no longer needs to be called from a root process.</strong> The calling process (main) runs as an unprivileged user. <code>clone(CLONE_NEWUSER | ...)</code> is permitted by unprivileged users ‚Äî this is the specific exception the kernel makes.</li>\n<li><strong>After the UID map is written, the container process holds real kernel capabilities.</strong> The <code>cap_effective</code>, <code>cap_permitted</code>, and <code>cap_inheritable</code> sets for the container&#39;s PID 1 are all fully populated ‚Äî the process can mount filesystems, call <code>pivot_root()</code>, configure network interfaces (within the network namespace it owns), and perform all the operations from previous milestones.</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> container_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 1: Wait for UID/GID maps and host setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // At this point, we're in a new user namespace but our UID map hasn't</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // been written yet. We're in an unmapped state ‚Äî getuid() returns 65534</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (the kernel's \"nobody\" UID for unmapped processes).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Block until the host writes the maps AND signals us.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> ready;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read</span><span style=\"color:#E1E4E8\">(cfg->sync_pipe_read, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ready, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container] sync pipe read failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(cfg->sync_pipe_read);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Verify we are now UID 0 inside the namespace ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] UID inside namespace: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (should be 0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getuid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] GID inside namespace: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> (should be 0)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getgid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 2: Filesystem isolation (identical to Milestone 2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We now have CAP_SYS_ADMIN scoped to our user namespace ‚Äî</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // sufficient for mount() and pivot_root() within our mount namespace.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">set_mounts_private</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)        </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">do_pivot_root</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)     </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 3: Identity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // sethostname() requires CAP_SYS_ADMIN in the UTS namespace's</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // owning user namespace ‚Äî which is our user namespace. Permitted.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sethostname</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 4: Pseudo-filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // mount(\"proc\", \"/proc\", \"proc\", ...) requires CAP_SYS_ADMIN in the</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // user namespace that owns the mount namespace. That's us.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount_pseudofs</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 5: Container-side network configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Note: veth interface was moved into our network namespace by the host.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuring it (ip addr add, ip route add) only requires</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CAP_NET_ADMIN in OUR network namespace's owning user namespace.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    setup_container_network</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 6: Verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getpid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] UID: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, GID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">getuid</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">getgid</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read our capabilities ‚Äî should show full set inside the namespace</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    verify_capabilities</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 7: Spawn user command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(cfg->argv[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], cfg->argv);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Phase 8: Init reaper loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> exited </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> child) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            reap_zombies</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[init] reaped orphan </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, exited);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<h3 id=\"verifying-capabilities-inside-the-namespace\">Verifying Capabilities Inside the Namespace</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/prctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/capability.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Read and display the effective capability set.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// After UID mapping, this should show a full capability bitmask.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> verify_capabilities</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> __user_cap_header_struct hdr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .version </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> _LINUX_CAPABILITY_VERSION_3,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#6A737D\">  // 0 means \"current process\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> __user_cap_data_struct </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_capget, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">hdr, data) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"capget\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Effective capabilities are a bitmask across two 32-bit words</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (64 capabilities total in the Linux capability model)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] Capabilities:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  effective[0]: 0x</span><span style=\"color:#79B8FF\">%08x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].effective);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  effective[1]: 0x</span><span style=\"color:#79B8FF\">%08x\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].effective);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check specific capabilities relevant to container operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CAP_SYS_ADMIN = bit 21 in word 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> has_sys_admin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].effective </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 21</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CAP_NET_ADMIN = bit 12 in word 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> has_net_admin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].effective </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CAP_MKNOD = bit 27 in word 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> has_mknod </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].effective </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 27</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  CAP_SYS_ADMIN: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, has_sys_admin </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  CAP_NET_ADMIN: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, has_net_admin </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  CAP_MKNOD:     </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, has_mknod    </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (has_sys_admin </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> has_net_admin) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"  ‚Üí Full capability set confirmed inside user namespace</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"complete-rootless-runtime-full-integration\">Complete Rootless Runtime: Full Integration</h2>\n<p>Here is the complete container runtime integrating all five milestones. The key difference from the previous version: <strong>main() no longer requires root</strong>. Run it as a normal user.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> _GNU_SOURCE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sched.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdio.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdlib.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;stdarg.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;string.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;unistd.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;fcntl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;errno.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/wait.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mman.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/mount.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/stat.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/types.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/syscall.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/capability.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> STACK_SIZE</span><span style=\"color:#E1E4E8\">          (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_HOSTNAME</span><span style=\"color:#9ECBFF\">  \"mycontainer\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ Network constants (from Milestone 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_NAME</span><span style=\"color:#9ECBFF\">    \"ctr0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_IP</span><span style=\"color:#9ECBFF\">      \"172.20.0.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> BRIDGE_CIDR</span><span style=\"color:#9ECBFF\">    \"172.20.0.1/24\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_IP</span><span style=\"color:#9ECBFF\">   \"172.20.0.2\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_CIDR</span><span style=\"color:#9ECBFF\"> \"172.20.0.2/24\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> CONTAINER_GW</span><span style=\"color:#9ECBFF\">   \"172.20.0.1\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VETH_HOST</span><span style=\"color:#9ECBFF\">      \"veth_h0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#define</span><span style=\"color:#B392F0\"> VETH_CONT</span><span style=\"color:#9ECBFF\">      \"veth_c0\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">rootfs;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#E1E4E8\">argv;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">outbound_iface;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\">    sync_pipe_read;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // User namespace configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uid_t</span><span style=\"color:#E1E4E8\">  host_uid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    gid_t</span><span style=\"color:#E1E4E8\">  host_gid;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cgroup name (for resource limits)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">  *</span><span style=\"color:#E1E4E8\">cgroup_name;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Utility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">fmt</span><span style=\"color:#E1E4E8\">, ...) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> cmd</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    va_list ap;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_start</span><span style=\"color:#E1E4E8\">(ap, fmt);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    vsnprintf</span><span style=\"color:#E1E4E8\">(cmd, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(cmd), fmt, ap);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    va_end</span><span style=\"color:#E1E4E8\">(ap);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> system</span><span style=\"color:#E1E4E8\">(cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (ret </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[net] FAILED (</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ret, cmd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ret </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UID/GID map writing (runs on HOST SIDE, PARENT process)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> proc_write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">file</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">content</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"/proc/</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid, file);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(path, O_WRONLY);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"proc_write(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(errno));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    ssize_t</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> write</span><span style=\"color:#E1E4E8\">(fd, content, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(content));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> errno;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (n </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"proc_write write(</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, path, </span><span style=\"color:#B392F0\">strerror</span><span style=\"color:#E1E4E8\">(err));</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> write_uid_gid_maps</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                               uid_t</span><span style=\"color:#FFAB70\"> host_uid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">gid_t</span><span style=\"color:#FFAB70\"> host_gid</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // uid_map: UID 0 inside ‚Üí host_uid outside</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf), </span><span style=\"color:#9ECBFF\">\"0 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_uid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#9ECBFF\">\"uid_map\"</span><span style=\"color:#E1E4E8\">, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[userns] uid_map: 0 ‚Üí </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_uid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // setgroups MUST be denied before gid_map for unprivileged callers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#9ECBFF\">\"setgroups\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"deny\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // gid_map: GID 0 inside ‚Üí host_gid outside</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf), </span><span style=\"color:#9ECBFF\">\"0 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_gid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#9ECBFF\">\"gid_map\"</span><span style=\"color:#E1E4E8\">, buf) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[userns] gid_map: 0 ‚Üí </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_gid);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Filesystem isolation (from Milestone 2 ‚Äî abbreviated)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> set_mounts_private</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_REC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_PRIVATE, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> mount</span><span style=\"color:#E1E4E8\">(rootfs, rootfs, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_REC, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> ?</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> :</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> do_pivot_root</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> old_root</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(old_root), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/.pivot_old\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mkdir</span><span style=\"color:#E1E4E8\">(old_root, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">700</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_pivot_root, rootfs, old_root) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pivot_root\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    chdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">umount2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">, MNT_DETACH) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"umount2\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    rmdir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/.pivot_old\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> mount_pseudofs</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"/proc\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"proc\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NODEV, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/sys\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"sysfs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NOEXEC </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_NODEV </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_RDONLY, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/dev\"</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#9ECBFF\">\"tmpfs\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">          MS_NOSUID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MS_STRICTATIME, </span><span style=\"color:#9ECBFF\">\"mode=755,size=65536k\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">devs</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#9ECBFF\">\"null\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"zero\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"random\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"urandom\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> src</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">dst</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#FFAB70\">devs</span><span style=\"color:#E1E4E8\">[i]; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(src, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(src), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        snprintf</span><span style=\"color:#E1E4E8\">(dst, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(dst), </span><span style=\"color:#9ECBFF\">\"/dev/</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">devs</span><span style=\"color:#E1E4E8\">[i]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> fd </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> open</span><span style=\"color:#E1E4E8\">(dst, O_CREAT </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> O_WRONLY, </span><span style=\"color:#F97583\">0</span><span style=\"color:#79B8FF\">666</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (fd </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">close</span><span style=\"color:#E1E4E8\">(fd);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        mount</span><span style=\"color:#E1E4E8\">(src, dst, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, MS_BIND, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container-side network setup (from Milestone 3)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_container_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set lo up\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)                               </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, CONTAINER_CIDR, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)                   </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip route add default via </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            CONTAINER_GW, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)                          </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Capability verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> verify_capabilities</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> __user_cap_header_struct hdr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .version </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> _LINUX_CAPABILITY_VERSION_3,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> __user_cap_data_struct </span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#E1E4E8\">(SYS_capget, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">hdr, data) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"capget\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> has_sys_admin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].effective </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 21</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> has_net_admin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">data</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].effective </span><span style=\"color:#F97583\">>></span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] UID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> GID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">  CAP_SYS_ADMIN=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> CAP_NET_ADMIN=</span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           getuid</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">getgid</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           has_sys_admin </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           has_net_admin </span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\"> \"YES\"</span><span style=\"color:#F97583\"> :</span><span style=\"color:#9ECBFF\"> \"NO\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Zombie reaper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> reap_zombies</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> pid;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> ((pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, WNOHANG)) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[init] reaped PID </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Container init ‚Äî PID 1 inside all namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> container_init</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">arg</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">container_config_t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)arg;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Block until host has written UID/GID maps and completed setup.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Before the maps are written, getuid() would return 65534 (\"nobody\").</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#E1E4E8\"> ready;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">read</span><span style=\"color:#E1E4E8\">(cfg->sync_pipe_read, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">ready, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[container] sync pipe read failed</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(cfg->sync_pipe_read);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Maps are now written. We are UID 0 inside the user namespace.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // We hold a full effective capability set ‚Äî scoped to our namespaces.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    verify_capabilities</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Filesystem isolation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">set_mounts_private</span><span style=\"color:#E1E4E8\">()        </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">bind_mount_rootfs</span><span style=\"color:#E1E4E8\">(cfg->rootfs) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">do_pivot_root</span><span style=\"color:#E1E4E8\">(cfg->rootfs)  </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Identity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    sethostname</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME, </span><span style=\"color:#B392F0\">strlen</span><span style=\"color:#E1E4E8\">(CONTAINER_HOSTNAME));</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Pseudo-filesystems (inside our new root)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mount_pseudofs</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Network (veth already moved to our namespace by host)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NOTE: rootless networking limitations discussed below.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If VETH_CONT is present (privileged host), configure it.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If running fully rootless (no host-side root), skip or use slirp4netns.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">access</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/sys/class/net/\"</span><span style=\"color:#E1E4E8\"> VETH_CONT, F_OK) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        setup_container_network</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] veth not present ‚Äî rootless network not configured</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] For network access, use slirp4netns externally</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[container] PID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> UID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> GID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> hostname=</span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">           getpid</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">getuid</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">getgid</span><span style=\"color:#E1E4E8\">(), CONTAINER_HOSTNAME);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Spawn user command (fork so PID 1 stays alive as reaper)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fork</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"fork\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (child </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        execvp</span><span style=\"color:#E1E4E8\">(cfg->argv[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], cfg->argv);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"execvp\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">127</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Init reaper loop</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pid_t</span><span style=\"color:#E1E4E8\"> exited </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> waitpid</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> child) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            reap_zombies</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[init] reaped orphan </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, exited);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ECHILD) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> (exited </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EINTR) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Host-side network setup ‚Äî still requires host root for veth/bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (rootless alternative: slirp4netns ‚Äî see discussion below)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> setup_host_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">outbound_iface</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link add name </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type bridge 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip addr add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dev </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, BRIDGE_CIDR, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link add </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> type veth peer name </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_HOST, VETH_CONT) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> master </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_HOST, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> up\"</span><span style=\"color:#E1E4E8\">, VETH_HOST);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link set </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> netns </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, VETH_CONT, container_pid) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"sysctl -w net.ipv4.ip_forward=1 -q\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -t nat -A POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/24 -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_IP, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_NAME, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -A FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -m state \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        outbound_iface, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> void</span><span style=\"color:#B392F0\"> cleanup_network</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">outbound_iface</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link del </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, VETH_HOST);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ip link del </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> 2>/dev/null\"</span><span style=\"color:#E1E4E8\">, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -t nat -D POSTROUTING -s </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/24 -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j MASQUERADE 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_IP, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -D FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -j ACCEPT 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        BRIDGE_NAME, outbound_iface);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    run</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"iptables -D FORWARD -i </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -o </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> -m state \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        outbound_iface, BRIDGE_NAME);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> write_resolv_conf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#FFAB70\">rootfs</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> path</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(path), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/etc/resolv.conf\"</span><span style=\"color:#E1E4E8\">, rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FILE </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">f </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fopen</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#9ECBFF\">\"w\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">f) </span><span style=\"color:#F97583\">return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fprintf</span><span style=\"color:#E1E4E8\">(f, </span><span style=\"color:#9ECBFF\">\"nameserver 8.8.8.8</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">nameserver 1.1.1.1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">options ndots:0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    fclose</span><span style=\"color:#E1E4E8\">(f);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Main ‚Äî runs as unprivileged user (no sudo required for core namespaces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">int</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">int</span><span style=\"color:#FFAB70\"> argc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> **</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (argc </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"Usage: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> &#x3C;rootfs> &#x3C;outbound-iface> &#x3C;command> [args...]</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Run as a normal user ‚Äî no sudo required!</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  (Network setup still needs host-side root for veth.)</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"  Example: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs eth0 /bin/sh</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">rootfs       </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    const</span><span style=\"color:#F97583\"> char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">outbound_if  </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\">      **</span><span style=\"color:#E1E4E8\">cmd          </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#FFAB70\">argv</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Capture the real (unprivileged) UID and GID BEFORE any namespace creation.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // After clone(CLONE_NEWUSER), getuid() inside the child would return 65534.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    uid_t</span><span style=\"color:#E1E4E8\"> real_uid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> getuid</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    gid_t</span><span style=\"color:#E1E4E8\"> real_gid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> getgid</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Running as UID=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> GID=</span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)real_uid, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)real_gid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Write DNS config to rootfs (as unprivileged user ‚Äî just file I/O)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write_resolv_conf</span><span style=\"color:#E1E4E8\">(rootfs);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Sync pipe: container blocks until host completes setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">pipe</span><span style=\"color:#E1E4E8\">(sync_pipe) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"pipe\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Child stack allocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> mmap</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, STACK_SIZE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       PROT_READ </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> PROT_WRITE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       MAP_PRIVATE </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_ANONYMOUS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> MAP_STACK,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                       -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (stack </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> MAP_FAILED) { </span><span style=\"color:#B392F0\">perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"mmap\"</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#F97583\">return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    mprotect</span><span style=\"color:#E1E4E8\">(stack, </span><span style=\"color:#79B8FF\">4096</span><span style=\"color:#E1E4E8\">, PROT_NONE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">stack_top </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stack </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> STACK_SIZE;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    container_config_t</span><span style=\"color:#E1E4E8\"> cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .rootfs          </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)rootfs,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .argv            </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cmd,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .outbound_iface  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">)outbound_if,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .sync_pipe_read  </span><span style=\"color:#F97583\">=</span><span style=\"color:#FFAB70\"> sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .host_uid        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> real_uid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .host_gid        </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> real_gid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .cgroup_name     </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"mycontainer\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ clone() with CLONE_NEWUSER added to all previous namespace flags ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CLONE_NEWUSER must be included ‚Äî it's what allows an unprivileged</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // user to create the other namespaces (PID, UTS, NS, NET).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Important: CLONE_NEWUSER can be combined with other CLONE_NEW* flags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // in a single clone() call; the user namespace is established first.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Creating container with user namespace (no root required)...</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pid_t</span><span style=\"color:#E1E4E8\"> container_pid </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> clone</span><span style=\"color:#E1E4E8\">(container_init, stack_top,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWUSER </span><span style=\"color:#F97583\">|</span><span style=\"color:#6A737D\">   // ‚Üê NEW: user namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWPID  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWUTS  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNS   </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                CLONE_NEWNET  </span><span style=\"color:#F97583\">|</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                SIGCHLD,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                &#x26;</span><span style=\"color:#E1E4E8\">cfg);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (container_pid </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"clone\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (errno </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> EPERM) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"Hint: check /proc/sys/kernel/unprivileged_userns_clone</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"      On Debian/Ubuntu: sysctl -w \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                            \"kernel.unprivileged_userns_clone=1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container host PID: </span><span style=\"color:#79B8FF\">%d\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parent no longer needs read end of sync pipe</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 1: Write UID/GID maps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // MUST happen before the container proceeds. Maps grant capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is the FIRST thing the host does after clone().</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">write_uid_gid_maps</span><span style=\"color:#E1E4E8\">(container_pid, real_uid, real_gid) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host] UID/GID map write failed ‚Äî killing container</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        kill</span><span style=\"color:#E1E4E8\">(container_pid, SIGKILL);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 2: Cgroup setup (requires root ‚Äî a real-world limitation) ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // NOTE: Cgroup setup in Milestone 4 uses /sys/fs/cgroup which requires</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // root UNLESS cgroup delegation is configured (see Knowledge Cascade).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For a fully rootless container, either:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   (a) skip cgroups (no resource limits), or</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   (b) use systemd cgroup delegation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Here we attempt cgroup setup and continue if it fails.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // (In practice: run the whole binary with sudo, or use delegation.)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    cgroup_config_t</span><span style=\"color:#E1E4E8\"> cg_cfg </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .memory_limit_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .cpu_quota_us       </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .cpu_period_us      </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .pids_max           </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">cgroup_setup</span><span style=\"color:#E1E4E8\">(cfg.cgroup_name, container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">cg_cfg) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        fprintf</span><span style=\"color:#E1E4E8\">(stderr, </span><span style=\"color:#9ECBFF\">\"[host] Cgroup setup failed (need root or delegation) \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                        \"‚Äî continuing without resource limits</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 3: Host network setup (requires root for veth/bridge) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is the other rootless limitation: cross-namespace veth creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // requires CAP_NET_ADMIN in the INITIAL network namespace (host).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For true rootless networking, use slirp4netns (see Knowledge Cascade).</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> net_ok </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">geteuid</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Running with host root (e.g., via sudo) ‚Äî set up veth normally</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">setup_host_network</span><span style=\"color:#E1E4E8\">(container_pid, outbound_if) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            net_ok </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] No host root ‚Äî skipping veth setup</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] For rootless networking, use slirp4netns:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host]   slirp4netns --configure --mtu=1500 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">               container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Step 4: Signal container ‚Äî all setup complete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    write</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    close</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">sync_pipe</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container unblocked ‚Äî running as UID 0 inside namespace</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    int</span><span style=\"color:#E1E4E8\"> status;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    waitpid</span><span style=\"color:#E1E4E8\">(container_pid, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">status, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"[host] Container exited</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (net_ok) </span><span style=\"color:#B392F0\">cleanup_network</span><span style=\"color:#E1E4E8\">(outbound_if);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cgroup_cleanup</span><span style=\"color:#E1E4E8\">(cfg.cgroup_name);</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    munmap</span><span style=\"color:#E1E4E8\">(stack, STACK_SIZE);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WIFEXITED</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">?</span><span style=\"color:#B392F0\"> WEXITSTATUS</span><span style=\"color:#E1E4E8\">(status) </span><span style=\"color:#F97583\">:</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p>Compile and run:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">gcc</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> container_m5</span><span style=\"color:#9ECBFF\"> container_m5.c</span><span style=\"color:#79B8FF\"> -Wall</span><span style=\"color:#79B8FF\"> -Wextra</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run WITHOUT sudo ‚Äî user namespace creation is unprivileged</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container_m5</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [host] Running as UID=1000 GID=1000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [host] Creating container with user namespace (no root required)...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [host] Container host PID: 47832</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [userns] uid_map: 0 ‚Üí 1000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [userns] gid_map: 0 ‚Üí 1000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [container] UID=0 GID=0  CAP_SYS_ADMIN=YES CAP_NET_ADMIN=YES</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># [container] PID=1 UID=0 GID=0 hostname=mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># / #        ‚Üê shell prompt inside container, as \"root\"</span></span></code></pre></div>\n<hr>\n<h2 id=\"the-capability-scoping-model-how-the-kernel-decides\">The Capability Scoping Model: How the Kernel Decides</h2>\n<p>When the container process (running as UID 0 inside the user namespace, host UID 1000) attempts an operation like <code>mount()</code>, the kernel performs this check:</p>\n<ol>\n<li><strong>Which capability is required?</strong> <code>mount()</code> requires <code>CAP_SYS_ADMIN</code>.</li>\n<li><strong>Does the process have it?</strong> Check the process&#39;s effective capability set inside its user namespace ‚Üí yes, the full set was granted when the UID map was written.</li>\n<li><strong>Does the user namespace own the target resource?</strong> The mount namespace was created by this user namespace (via <code>CLONE_NEWNS</code> from the same <code>clone()</code> call) ‚Üí yes, the user namespace is the owner.</li>\n<li><strong>Is the check in the owning user namespace?</strong> Yes.</li>\n<li><strong>Decision: permitted.</strong>\nNow consider the same process trying <code>mount(&quot;/dev/sda1&quot;, &quot;/mnt&quot;, &quot;ext4&quot;, 0, NULL)</code> to mount the host&#39;s disk:</li>\n<li><code>mount()</code> requires <code>CAP_SYS_ADMIN</code>.</li>\n<li>Process has <code>CAP_SYS_ADMIN</code> in its user namespace ‚Üí check passes.</li>\n<li>But <code>/dev/sda1</code> is a block device in the <strong>initial</strong> (host) user namespace. The check for mounting a real block device requires <code>CAP_SYS_ADMIN</code> in the <strong>initial</strong> user namespace.</li>\n<li>The container&#39;s user namespace is NOT the initial namespace.</li>\n<li><strong>Decision: EPERM.</strong>\nThis is the mechanism that makes user namespaces secure. The capability check is not just &quot;do you have the capability?&quot; but &quot;do you have the capability in the namespace that owns the resource you&#39;re trying to manipulate?&quot; Container escapes that achieve only the container&#39;s user namespace capabilities cannot mount host disks, modify host iptables, or kill host processes ‚Äî because those resources are owned by the initial user namespace, where the container has no capabilities.</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-capability-scoping.svg\" alt=\"Capability Scoping Across User Namespaces\"></p>\n<hr>\n<h2 id=\"verifying-the-security-boundary-from-both-sides\">Verifying the Security Boundary From Both Sides</h2>\n<p>After launching your container, verify the fundamental promise: root inside, unprivileged outside.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ Inside the container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You appear as root:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># uid=0(root) gid=0(root) groups=0(root)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You can do root-like things within your namespaces:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> /tmp</span><span style=\"color:#6A737D\">       # Works ‚Äî you have CAP_SYS_ADMIN in your mount ns</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span><span style=\"color:#9ECBFF\"> isolation-test</span><span style=\"color:#6A737D\">          # Works ‚Äî you have CAP_SYS_ADMIN in your UTS ns</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#6A737D\">                          # Works ‚Äî you have CAP_NET_ADMIN in your net ns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You CANNOT do host-level root things:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (Try to mount a real block device ‚Äî requires host CAP_SYS_ADMIN)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#9ECBFF\"> /dev/sda1</span><span style=\"color:#9ECBFF\"> /mnt</span><span style=\"color:#F97583\"> 2>&#x26;1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mount: permission denied (or: operation not permitted)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># You cannot see host processes:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /proc/</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> wc</span><span style=\"color:#79B8FF\"> -l</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ~5 (only container PIDs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ On the host ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The container process appears as your unprivileged UID:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> container_m5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># yourusername  47832  ...  container_init  ‚Üê UID 1000, NOT root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify via /proc status:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -E</span><span style=\"color:#9ECBFF\"> \"Uid:|Gid:|NSpid:|CapEff\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Uid:    1000    1000    1000    1000   ‚Üê real/effective/saved/filesystem UIDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Gid:    1000    1000    1000    1000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># NSpid:  47832   1                      ‚Üê host PID 47832, namespace PID 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># CapEff: 0000000000000000               ‚Üê NO effective capabilities on HOST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Read the user namespace ID:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/47832/ns/user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># user -> user:[4026532847]  ‚Üê different from host's user namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compare with host's user namespace:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/self/ns/user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># user -> user:[4026531837]  ‚Üê different inode number ‚Üí different namespace</span></span></code></pre></div>\n<h2 id=\"the-capeff-0000000000000000-line-in-procltpidgtstatus-is-the-definitive-proof-from-the-host39s-perspective-this-process-has-zero-effective-capabilities-no-cap_sys_admin-no-cap_net_admin-nothing-if-this-process-escapes-the-container-it-has-the-privilege-level-of-any-unprivileged-user-compare-this-to-a-rootful-container-escape-where-capeff-would-show-0000003fffffffff-full-capabilities-on-the-host\">The <code>CapEff: 0000000000000000</code> line in <code>/proc/&lt;pid&gt;/status</code> is the definitive proof: from the host&#39;s perspective, this process has zero effective capabilities. No <code>CAP_SYS_ADMIN</code>, no <code>CAP_NET_ADMIN</code>, nothing. If this process escapes the container, it has the privilege level of any unprivileged user. Compare this to a rootful container escape, where <code>CapEff</code> would show <code>0000003fffffffff</code> ‚Äî full capabilities on the host.</h2>\n<h2 id=\"the-rootless-networking-boundary-where-user-namespaces-end\">The Rootless Networking Boundary: Where User Namespaces End</h2>\n<p>User namespaces grant capabilities scoped to namespace-owned resources. The problem with networking: creating veth pairs and moving them between namespaces requires <code>CAP_NET_ADMIN</code> in the <strong>initial</strong> network namespace ‚Äî the host. The host&#39;s network namespace is owned by the initial user namespace. Your container&#39;s user namespace has no power there.\nThis is the hard boundary of rootless containers: <strong>cross-namespace veth operations require host-level network capabilities.</strong> This is not a bug or limitation in the implementation ‚Äî it&#39;s a correct security property. If unprivileged user namespaces could create interfaces on the host&#39;s network stack, any user could manipulate the host&#39;s routing table, creating a privilege escalation vector.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-rootless-networking-alternatives.svg\" alt=\"Rootless Networking ‚Äî slirp4netns vs pasta vs Host Network\"></p>\n<p>The practical solutions that production rootless container runtimes use:</p>\n<h3 id=\"slirp4netns-user-space-tcpip-stack\">slirp4netns: User-Space TCP/IP Stack</h3>\n<p><code>slirp4netns</code> (and its successor <code>pasta</code>) implements a full TCP/IP stack entirely in userspace. Instead of creating kernel-level veth pairs, it:</p>\n<ol>\n<li>Creates a tap device inside the container&#39;s network namespace (no host root required ‚Äî the user namespace owns the network namespace)</li>\n<li>Runs a user-space TCP/IP implementation that receives packets from the tap device</li>\n<li>Makes actual network calls on the host using the unprivileged user&#39;s regular socket access</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Install: apt install slirp4netns (Ubuntu) or apk add slirp4netns (Alpine)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After launching the container (while it's blocking on sync pipe):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">slirp4netns</span><span style=\"color:#79B8FF\"> --configure</span><span style=\"color:#79B8FF\"> --mtu=1500</span><span style=\"color:#79B8FF\"> --disable-host-loopback</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    $CONTAINER_PID </span><span style=\"color:#9ECBFF\">eth0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># This creates networking inside the container's net namespace WITHOUT host root.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The container gets 10.0.2.0/24 (slirp's default subnet).</span></span></code></pre></div>\n<p>The performance cost: <code>slirp4netns</code> routes every packet through a user-space TCP/IP stack, which means an extra context switch and memcpy per packet compared to kernel veth. Measured overhead: ~40-80% lower throughput than veth+bridge for bulk transfers, ~2-4x higher latency for small packets. This is acceptable for most developer and CI workloads. For production performance, <code>pasta</code> (a newer alternative from the same author) achieves significantly better throughput by using a smarter architecture.\n[[EXPLAIN:tap-device-and-user-space-networking-(slirp-model)|TAP device and user-space networking ‚Äî how slirp4netns creates a virtual network interface that feeds into a user-space TCP/IP stack]]</p>\n<h3 id=\"the-capability-delegation-pattern\">The Capability Delegation Pattern</h3>\n<h2 id=\"for-production-rootless-environments-a-common-pattern-is-capability-delegation-a-privileged-helper-process-a-small-setuid-binary-or-a-systemd-socket-activated-service-performs-only-the-specific-host-level-operations-that-require-root-then-drops-all-privileges-podman-uses-pasta-or-slirp4netns-for-networking-and-newuidmapnewgidmap-for-extended-uid-mappings-this-keeps-the-container-runtime-itself-unprivileged-while-enabling-full-functionality\">For production rootless environments, a common pattern is capability delegation: a privileged helper process (a small setuid binary or a systemd socket-activated service) performs only the specific host-level operations that require root, then drops all privileges. Podman uses <code>pasta</code> or <code>slirp4netns</code> for networking and <code>newuidmap</code>/<code>newgidmap</code> for extended UID mappings. This keeps the container runtime itself unprivileged while enabling full functionality.</h2>\n<h2 id=\"subordinate-uid-ranges-supporting-full-user-id-spaces\">Subordinate UID Ranges: Supporting Full User ID Spaces</h2>\n<p>The single <code>0 1000 1</code> mapping (one UID) is sufficient for simple containers, but many real container images rely on multiple UIDs. An nginx image runs as UID 101 (the <code>nginx</code> user). A database image may use UID 999 for <code>postgres</code>. If your UID map only covers UID 0, the container process running as UID 101 would have an unmapped UID ‚Äî it appears as UID 65534 (&quot;nobody&quot;) inside the container, and file ownership breaks.\nThe solution is subordinate UID ranges (<code>/etc/subuid</code> and <code>/etc/subgid</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># /etc/subuid format: username:start:count</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /etc/subuid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># alice:100000:65536    ‚Üê Alice can use UIDs 100000-165535 as subordinate UIDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># /etc/subgid ‚Äî same format for GIDs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /etc/subgid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># alice:100000:65536</span></span></code></pre></div>\n<p>A broader UID map using the subordinate range:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>0  100000  65536</code></pre></div>\n<p>This maps UIDs 0-65535 inside the container to UIDs 100000-165535 on the host. The entire user ID space of a standard Linux system fits within the container. Files created by <code>nginx</code> (UID 101 inside the container) are stored on disk as owned by UID 100101 ‚Äî safely in the subordinate range, not overlapping with any real host user.\nThe <code>newuidmap</code> and <code>newgidmap</code> setuid helper binaries (part of the <code>shadow-utils</code> package) perform the map write securely, enforcing that the requested ranges are within the caller&#39;s subordinate allocation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Using newuidmap/newgidmap for extended mappings:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (newuidmap and newgidmap are setuid binaries that validate /etc/subuid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> write_extended_uid_map</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">pid_t</span><span style=\"color:#FFAB70\"> container_pid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   uid_t</span><span style=\"color:#FFAB70\"> host_uid</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   uid_t</span><span style=\"color:#FFAB70\"> subuid_start</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                                   int</span><span style=\"color:#FFAB70\">   subuid_count</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> pid_str</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#FFAB70\">map_entry</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(pid_str, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(pid_str), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, container_pid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Map: UID 0 inside ‚Üí host_uid outside (1 UID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //      UID 1 inside ‚Üí subuid_start outside (subuid_count UIDs)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    snprintf</span><span style=\"color:#E1E4E8\">(map_entry, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(map_entry),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">             \"0 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> 1 1 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#79B8FF\"> %d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">             (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)host_uid, (</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">)subuid_start, subuid_count);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">args</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#9ECBFF\">\"newuidmap\"</span><span style=\"color:#E1E4E8\">, pid_str, </span><span style=\"color:#9ECBFF\">\"0\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NULL</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // In practice: exec(\"newuidmap\", pid, \"0\", host_uid_str, \"1\",</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //                                    \"1\", subuid_start_str, count_str, NULL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // newuidmap validates against /etc/subuid and writes the map atomically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    (</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">)map_entry;</span><span style=\"color:#6A737D\"> // simplified for illustration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span><span style=\"color:#6A737D\"> // exec newuidmap with appropriate arguments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<hr>\n<h2 id=\"hardware-soul-what-the-kernel-does-during-user-namespace-creation\">Hardware Soul: What the Kernel Does During User Namespace Creation</h2>\n<p>When <code>clone(CLONE_NEWUSER | ...)</code> executes, the kernel performs these operations in <code>copy_process()</code>:</p>\n<ol>\n<li><strong>Allocate <code>struct user_namespace</code></strong> (~400 bytes): contains the UID/GID maps (arrays of <code>uid_gid_map_entry</code> structs), a reference count, the owning credential, and the parent namespace pointer.</li>\n<li><strong>Set the new namespace&#39;s owner</strong>: the user namespace is initially owned by the creating user (UID 1000 in our case). The initial capability set is empty until the UID map is written.</li>\n<li><strong>Write the UID map</strong> (when <code>proc_write</code> runs from the parent): the kernel validates the mapping, stores it in the <code>user_namespace</code> struct&#39;s <code>uid_map</code> array, and then ‚Äî this is the key event ‚Äî <strong>elevates the child&#39;s effective capability set to the full set</strong>. This elevation is atomic with the map write.\n<strong>Cache behavior</strong>: The <code>user_namespace</code> struct and <code>uid_gid_map_entry</code> arrays are small and fit within two or three cache lines. Accessing them during a capability check (which happens on every privileged syscall) adds one or two pointer dereferences to the existing capability check path. On hot paths (frequent <code>mount()</code> calls, network operations), this adds approximately 3-10 ns ‚Äî negligible.\n<strong>The UID translation path on every <code>stat()</code></strong>: When a container process calls <code>stat()</code> on a file, the kernel:</li>\n</ol>\n<ul>\n<li>Reads the file&#39;s on-disk <code>uid_t</code> (e.g., 100000)</li>\n<li>Walks the <code>uid_map</code> array of the process&#39;s user namespace (linear scan, typically 1-3 entries)</li>\n<li>Returns the mapped UID (e.g., 0) to userspace\nWith one mapping entry, this is a single comparison ‚Äî effectively free. With 340 entries (the maximum), it&#39;s a short linear scan. The kernel doesn&#39;t use a hash table for UID mapping because the typical case is 1-3 entries, and cache-friendly linear scan beats hash table overhead for such small sets.\n<strong>TLB impact</strong>: User namespace creation doesn&#39;t directly affect the TLB. The address space (page tables) is cloned normally. The UID mapping adds no new virtual memory. The only TLB-relevant change: if the container process accesses files in a new filesystem after <code>pivot_root()</code>, the new page mappings require TLB entries ‚Äî but this is identical to any exec().</li>\n</ul>\n<hr>\n<h2 id=\"pitfall-compendium-the-ordering-constraints-that-will-cost-you-days\">Pitfall Compendium: The Ordering Constraints That Will Cost You Days</h2>\n<h3 id=\"pitfall-1-writing-uid_map-after-the-container-has-already-proceeded\">Pitfall 1: Writing uid_map After the Container Has Already Proceeded</h3>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>‚ùå WRONG TIMELINE:\n   clone(CLONE_NEWUSER) ‚Üí write sync pipe &quot;1&quot; ‚Üí container exec()s\n   ‚Üí then write uid_map on host\n   Effect: container ran as UID 65534 (nobody), all mounts/pivots failed\n‚úÖ CORRECT TIMELINE:\n   clone(CLONE_NEWUSER) ‚Üí write uid_map ‚Üí write gid_map ‚Üí write sync pipe &quot;1&quot;\n   ‚Üí container reads pipe ‚Üí container now has capabilities ‚Üí mount/pivot succeed</code></pre></div>\n<p>The sync pipe exists precisely to enforce this ordering. Never signal the container until all host-side setup is complete.</p>\n<h3 id=\"pitfall-2-writing-gid_map-before-setgroups\">Pitfall 2: Writing gid_map Before setgroups</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG ‚Äî writing gid_map before setgroups:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"gid_map\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0 1000 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // EPERM for unprivileged users</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"setgroups\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"deny\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        // Too late ‚Äî already failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ CORRECT ‚Äî mandatory ordering:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"uid_map\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0 1000 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // uid_map first (no setgroups dependency)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"setgroups\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"deny\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">        // MUST precede gid_map</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"gid_map\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0 1000 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">   // Now succeeds</span></span></code></pre></div>\n<p>The error is <code>EPERM</code> with no further explanation ‚Äî the kernel simply refuses the write. Debugging this without knowing the setgroups requirement is very difficult because the error appears to be a permissions issue, not an ordering issue.</p>\n<h3 id=\"pitfall-3-clone_newuser-must-come-first-in-the-flags\">Pitfall 3: CLONE_NEWUSER Must Come First in the Flags</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå MIGHT FAIL on some kernel versions ‚Äî CLONE_NEWNET before CLONE_NEWUSER:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">clone</span><span style=\"color:#E1E4E8\">(fn, stack_top, CLONE_NEWNET </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWUSER </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SIGCHLD, arg);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ‚úÖ SAFE ‚Äî CLONE_NEWUSER with others (kernel processes NEWUSER first regardless of order):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">clone</span><span style=\"color:#E1E4E8\">(fn, stack_top, CLONE_NEWUSER </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWPID </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNS </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> CLONE_NEWNET </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> SIGCHLD, arg);</span></span></code></pre></div>\n<p>In practice, the kernel processes <code>CLONE_NEWUSER</code> before other namespace flags regardless of bitmask order ‚Äî but explicitly placing <code>CLONE_NEWUSER</code> first documents the intent clearly and avoids confusion.</p>\n<h3 id=\"pitfall-4-uid_map-written-twice\">Pitfall 4: uid_map Written Twice</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ‚ùå WRONG ‚Äî writing uid_map twice:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"uid_map\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0 1000 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ... realize you made a mistake ...</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">proc_write</span><span style=\"color:#E1E4E8\">(pid, </span><span style=\"color:#9ECBFF\">\"uid_map\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"0 1000 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">);</span><span style=\"color:#6A737D\">  // EPERM ‚Äî cannot write twice</span></span></code></pre></div>\n<p>The kernel allows <code>uid_map</code> to be written exactly once. The second write returns <code>EPERM</code> regardless of content. If you need a different mapping, you must kill the container and start over. Design your mapping correctly before the first write.</p>\n<h3 id=\"pitfall-5-unprivileged-userns_clone-disabled-debianubuntu\">Pitfall 5: Unprivileged userns_clone Disabled (Debian/Ubuntu)</h3>\n<p>Some distributions (notably Debian and Ubuntu before Ubuntu 23.10) disable unprivileged user namespace creation via a kernel parameter:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#9ECBFF\"> kernel.unprivileged_userns_clone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># kernel.unprivileged_userns_clone = 0  ‚Üê DISABLED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Enable (requires root, persists until reboot):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#79B8FF\"> -w</span><span style=\"color:#9ECBFF\"> kernel.unprivileged_userns_clone=</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Permanent fix:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"kernel.unprivileged_userns_clone=1\"</span><span style=\"color:#F97583\"> >></span><span style=\"color:#9ECBFF\"> /etc/sysctl.conf</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sysctl</span><span style=\"color:#79B8FF\"> -p</span></span></code></pre></div>\n<p>The error from <code>clone(CLONE_NEWUSER)</code> without this is <code>EPERM</code>. This is a distribution-level security policy ‚Äî some administrators disable unprivileged user namespaces to reduce kernel attack surface (user namespaces do expose more kernel code paths to unprivileged users). Production systems must decide whether the container benefits outweigh the increased kernel attack surface.</p>\n<h3 id=\"pitfall-6-id-mapped-mount-permission-confusion\">Pitfall 6: ID-Mapped Mount Permission Confusion</h3>\n<p>After <code>pivot_root()</code> with a user namespace, file ownership in the container rootfs may appear wrong. If the rootfs was created by root (UID 0 on the host) and your container maps UID 0 inside to UID 1000 outside:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /etc/passwd</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># -rw-r--r--  1 nobody  nobody  ...  ‚Üê owned by nobody, not root!</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Why? The file is owned by UID 0 on disk (host root created it).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The container's UID map says: 0 inside ‚Üí 1000 outside.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># The REVERSE lookup: 0 on disk ‚Üí not in map (0 is not 1000) ‚Üí \"nobody\" (65534).</span></span></code></pre></div>\n<p>The fix for containers using the single <code>0 1000 1</code> mapping: your rootfs files should be owned by UID 1000 on the host (your real UID), not by root. When extracting a container image tarball:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Extract rootfs as yourself (not root) ‚Äî files will be owned by your UID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">tar</span><span style=\"color:#79B8FF\"> --same-owner</span><span style=\"color:#79B8FF\"> -xf</span><span style=\"color:#9ECBFF\"> alpine-rootfs.tar.gz</span><span style=\"color:#79B8FF\"> -C</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Or: use fakeroot to extract with remapped ownership</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">fakeroot</span><span style=\"color:#9ECBFF\"> tar</span><span style=\"color:#79B8FF\"> -xf</span><span style=\"color:#9ECBFF\"> alpine-rootfs.tar.gz</span><span style=\"color:#79B8FF\"> -C</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span></span></code></pre></div>\n<h2 id=\"the-deeper-solution-is-id-mapped-mounts-linux-512-a-kernel-feature-that-applies-uid-mapping-at-the-mount-level-transparently-remapping-file-ownership-on-the-fly-during-filesystem-operations-this-eliminates-the-need-to-pre-chown-the-rootfs-see-the-knowledge-cascade-for-details\">The deeper solution is <strong>ID-mapped mounts</strong> (Linux 5.12+) ‚Äî a kernel feature that applies UID mapping at the mount level, transparently remapping file ownership on-the-fly during filesystem operations. This eliminates the need to pre-chown the rootfs. See the Knowledge Cascade for details.</h2>\n<h2 id=\"verification-checklist\">Verification Checklist</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 1. Verify no root required ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">whoami</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># alice  (not root)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container_m5</span><span style=\"color:#9ECBFF\"> ./alpine-rootfs</span><span style=\"color:#9ECBFF\"> eth0</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should launch without sudo (ignoring cgroup/veth which may need root)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 2. Verify inside UID is 0 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># uid=0(root) gid=0(root) groups=0(root)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 3. Verify outside UID is unprivileged ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host (replace 47832 with actual container PID):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"^Uid:\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Uid:    1000    1000    1000    1000   ‚Üê unprivileged on host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 4. Verify NSpid shows both views ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> NSpid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># NSpid:  47832   1   ‚Üê host PID, namespace PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 5. Verify no effective capabilities on host ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> CapEff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># CapEff: 0000000000000000   ‚Üê zero caps on host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 6. Verify full capabilities inside namespace ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/self/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> CapEff</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># CapEff: 000001ffffffffff   ‚Üê full cap set (or similar non-zero value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 7. Verify user namespace is distinct from host ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/47832/ns/user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># user -> user:[4026532847]</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /proc/self/ns/user</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># user -> user:[4026531837]  ‚Üê different inode = different namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 8. Verify UID map was written correctly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/uid_map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 0    1000    1   ‚Üê inside 0, outside 1000, count 1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/gid_map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 0    1000    1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 9. Verify setgroups is denied ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /proc/47832/setgroups</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># deny</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 10. Verify mount works inside namespace (CAP_SYS_ADMIN is real) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> tmpfs</span><span style=\"color:#9ECBFF\"> /tmp</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"mount succeeded\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mount succeeded   ‚Üê real capability, real mount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 11. Verify pivot_root isolation still works ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Shows container rootfs, NOT host filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 12. Verify PID namespace isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Shows only container processes (PIDs 1, 2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 13. Verify host filesystem is inaccessible ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container (attempt to mount a block device ‚Äî should fail):</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#9ECBFF\"> /dev/sda1</span><span style=\"color:#9ECBFF\"> /mnt</span><span style=\"color:#F97583\"> 2>&#x26;1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mount: permission denied  ‚Üê correctly blocked (host's block dev, host's user ns)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ‚îÄ‚îÄ 14. Verify hostname isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># mycontainer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># On host:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># (unchanged ‚Äî original hostname)</span></span></code></pre></div>\n<hr>\n<h2 id=\"knowledge-cascade-what-user-namespaces-unlock\">Knowledge Cascade: What User Namespaces Unlock</h2>\n<h3 id=\"1-rootless-containers-are-more-secure-than-rootful\">1. Rootless Containers Are MORE Secure Than Rootful</h3>\n<p>The conventional wisdom in security is: &quot;less functionality = more security.&quot; User namespaces seem to fit this: they limit what containers can do, so surely they&#39;re less capable but safer.\nThe reality inverts this: rootless containers with user namespaces are <strong>more</strong> secure than rootful containers for the specific threat of container escapes, while providing equivalent isolation.\nIn a rootful container escape:</p>\n<ul>\n<li>The escaped process has <code>CAP_SYS_ADMIN</code> on the host</li>\n<li>It can load kernel modules (potential kernel code execution)</li>\n<li>It can mount arbitrary block devices (filesystem access)</li>\n<li>It can kill any process on the host</li>\n<li>It has complete read/write access to host files\nIn a rootless container escape:</li>\n<li>The escaped process has UID 1000 and zero capabilities on the host</li>\n<li>It can access only files readable by UID 1000</li>\n<li>It cannot modify kernel state, load modules, or kill other users&#39; processes</li>\n<li>The blast radius is bounded to the user&#39;s own account\nThe additional attack surface of user namespaces (more kernel code paths reachable by unprivileged users) is real ‚Äî there have been kernel CVEs involving user namespace privilege escalations. But the security community&#39;s consensus, supported by distros like Fedora and Ubuntu 23.10+ enabling unprivileged user namespaces by default, is that the defense-in-depth benefit of rootless containers outweighs the marginal kernel attack surface increase.\nThis is why the Kubernetes security community considers Pods running with <code>securityContext.runAsNonRoot: true</code> and appropriate user namespace configuration as a best practice ‚Äî not just a compliance checkbox.</li>\n</ul>\n<h3 id=\"2-kubernetes-rootless-nodes-and-user-namespace-pod-support\">2. Kubernetes Rootless Nodes and User Namespace Pod Support</h3>\n<p>[[EXPLAIN:kubernetes-pod-level-user-namespace-support-(hostuserns,-userns-field)|Kubernetes pod-level user namespace support ‚Äî the userns field and hostUserNS]]\nKubernetes 1.25 introduced alpha support for user namespaces in pods (KEP-127), promoted to stable in Kubernetes 1.30. The pod spec gains a <code>hostUsers</code> field:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">apiVersion</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">v1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">Pod</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">spec</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  hostUsers</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#6A737D\">   # Create a user namespace for this pod</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  containers</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#85E89D\">name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">app</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    securityContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      runAsUser</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#6A737D\">   # UID 0 inside the pod's user namespace</span></span></code></pre></div>\n<p>With <code>hostUsers: false</code>, the kubelet creates a user namespace for the pod with a UID mapping allocated from the node&#39;s subordinate UID range (configured per node). Pod UID 0 maps to a unique node-level subordinate UID ‚Äî two different pods both running as &quot;root&quot; inside their containers map to different host UIDs, preventing cross-pod privilege escalation.\nThe <code>runAsNonRoot: true</code> security context setting is related but different: it requires the container&#39;s primary process to not be UID 0, enforced by the container runtime reading the image&#39;s <code>USER</code> directive. User namespace support is a stronger guarantee: even if the container runs as UID 0, that UID has no host-level capabilities.</p>\n<h3 id=\"3-id-mapped-mounts-linux-512-extending-uid-mapping-to-filesystems\">3. ID-Mapped Mounts (Linux 5.12+): Extending UID Mapping to Filesystems</h3>\n<p>[[EXPLAIN:id-mapped-mounts-(linux-5.12)-and-how-they-extend-user-namespace-uid-remapping-to-persistent-filesystems|ID-mapped mounts ‚Äî applying UID remapping at the filesystem mount level]]\nThe UID mapping in user namespaces works for <code>/proc/self/status</code> (kernel translates UIDs in kernel objects) but has a gap for persistent filesystems: files stored on disk have a <code>uid_t</code> in their inode. When a container&#39;s UID 0 creates a file in an <code>overlayfs</code>, that file is stored as UID 100000 on the host (using subordinate UID mapping). When the container exits and you examine the file on the host, it&#39;s owned by UID 100000 ‚Äî which may confuse host-side tools.\nID-mapped mounts solve this at the VFS level. When mounting a filesystem with an ID mapping:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Mount a filesystem with UID remapping applied to all file ownership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// (Simplified ‚Äî actual API uses mount_setattr with MOUNT_ATTR_IDMAP)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Effect: file owned by host UID 0 appears as UID 1000 inside the container,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//         and vice versa ‚Äî transparently, at the VFS layer</span></span></code></pre></div>\n<p>This means container images built with root-owned files can be used directly without pre-chowning, and files created by the container appear correctly owned from the host&#39;s perspective. This is the technology that makes rootless container image layers interoperable with the host filesystem without ownership confusion. Podman 4.0+ uses ID-mapped mounts when available (kernel ‚â• 5.12).</p>\n<h3 id=\"4-nested-containers-docker-in-docker-and-ci-environments\">4. Nested Containers: Docker-in-Docker and CI Environments</h3>\n<p>[[EXPLAIN:nested-user-namespaces-and-uid-map-composition|Nested user namespaces ‚Äî how UID mappings compose across levels and the 32-level kernel limit]]\nUser namespaces can be nested: a process inside a user namespace can create a child user namespace. The kernel supports up to 32 nesting levels. Each level adds a UID mapping translation.\nIf the outer container maps UID 0 (inside) ‚Üí UID 1000 (outside), and the inner container maps UID 0 (inside) ‚Üí UID 0 (outer), the kernel composes these translations: inner UID 0 ‚Üí outer UID 0 ‚Üí host UID 1000. The innermost process appears as host UID 1000, even though it sees itself as UID 0 in two nested layers.\nThis is the mechanism that makes Docker-in-Docker (DinD) work in CI environments without host root. The outer container (the CI runner) creates a user namespace; the inner container (the Docker daemon and its containers) creates a nested user namespace. The kernel correctly composes the UID translations, ensuring the innermost containers have no host-level capabilities.\nGitHub Actions, GitLab CI, and Jenkins all support rootless container runners using this nested namespace model. Understanding the UID composition explains why files created inside a CI container appear as a specific user on the host&#39;s artifact storage ‚Äî the nested UID mapping translates all the way through.</p>\n<h3 id=\"5-the-seccomp-connection-defense-in-depth\">5. The seccomp Connection: Defense in Depth</h3>\n<p>User namespaces significantly reduce the blast radius of container escapes. <code>seccomp</code> (Secure Computing Mode) filters reduce the kernel attack surface available to container processes. Together, they form complementary layers of defense:</p>\n<ul>\n<li><strong>User namespaces</strong>: limit privilege (even if you escape, you have no capabilities on host)</li>\n<li><strong>seccomp</strong>: limit syscall access (even if you have a kernel exploit, you can&#39;t reach the vulnerable code path)\n<code>seccomp</code> is configured via <code>prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, ...)</code> with a BPF filter that specifies which syscalls are allowed, denied, or should result in a signal. Docker&#39;s default seccomp profile blocks ~44 syscalls (including <code>kexec_load</code>, <code>mount</code> outside namespaces, <code>ptrace</code> in some configurations). Adding seccomp to your container runtime:</li>\n</ul>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;sys/prctl.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/seccomp.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/filter.h></span></span>\n<span class=\"line\"><span style=\"color:#F97583\">#include</span><span style=\"color:#9ECBFF\"> &#x3C;linux/audit.h></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Apply a minimal seccomp whitelist ‚Äî allow only common syscalls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// In practice, use libseccomp for easier rule management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">static</span><span style=\"color:#F97583\"> int</span><span style=\"color:#B392F0\"> apply_seccomp_filter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">void</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This is a sketch ‚Äî a complete filter needs allow rules for</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // all syscalls the container might legitimately use</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sock_filter filter</span><span style=\"color:#F97583\">[]</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Load syscall number</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        BPF_STMT</span><span style=\"color:#E1E4E8\">(BPF_LD </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> BPF_W </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> BPF_ABS,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">                 offsetof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> seccomp_data, nr)),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allow known-safe syscalls (would be a full list in production)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Deny everything else with SIGKILL</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        BPF_STMT</span><span style=\"color:#E1E4E8\">(BPF_RET </span><span style=\"color:#F97583\">|</span><span style=\"color:#E1E4E8\"> BPF_K, SECCOMP_RET_KILL),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    struct</span><span style=\"color:#E1E4E8\"> sock_fprog prog </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .len </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(filter) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> sizeof</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filter</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        .filter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> filter,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">prctl</span><span style=\"color:#E1E4E8\">(PR_SET_NO_NEW_PRIVS, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"prctl NO_NEW_PRIVS\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#B392F0\">prctl</span><span style=\"color:#E1E4E8\">(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">prog) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        perror</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"prctl SECCOMP\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n<p><code>PR_SET_NO_NEW_PRIVS</code> is required before <code>seccomp</code> for unprivileged processes ‚Äî it ensures that exec&#39;d processes cannot gain more privileges than the current process (prevents setuid escalation through exec). This is another example of the defense-in-depth layering that makes rootless containers with user namespaces a genuinely strong security boundary.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-container-escape-taxonomy.svg\" alt=\"Container Escape Vectors ‚Äî Attack Surface Map\"></p>\n<hr>\n<h2 id=\"the-complete-container-creation-sequence-full-syscall-view\">The Complete Container Creation Sequence: Full Syscall View</h2>\n<p>With all five milestones integrated, here is the complete sequence of kernel interactions that creates a fully isolated, resource-limited, rootless container:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HOST (unprivileged, UID 1000)             CONTAINER (user namespace, UID 0)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1.  pipe(sync_pipe)                        \n2.  mmap(STACK_SIZE, MAP_STACK)            \n3.  clone(CLONE_NEWUSER|NEWPID|NEWUTS|    \n          NEWNS|NEWNET|SIGCHLD)           ‚îÄ‚îÄ‚Üí  (born into 5 new namespaces)\n    returns container_pid                       getuid() ‚Üí 65534 (unmapped)\n                                                read(sync_pipe[0]) ‚Üí BLOCKS\n4.  write(&quot;/proc/$PID/uid_map&quot;,&quot;0 1000 1&quot;)\n5.  write(&quot;/proc/$PID/setgroups&quot;,&quot;deny&quot;)\n6.  write(&quot;/proc/$PID/gid_map&quot;,&quot;0 1000 1&quot;)\n    (container now has full caps in its userns)\n7.  mkdir(&quot;/sys/fs/cgroup/mycontainer&quot;)\n8.  write(&quot;.../cgroup.procs&quot;, container_pid)\n9.  write(&quot;.../memory.max&quot;, 104857600)\n10. write(&quot;.../cpu.max&quot;, &quot;50000 100000&quot;)\n11. write(&quot;.../pids.max&quot;, 32)\n12. ip link add veth_h0 type veth peer veth_c0\n13. ip link set veth_c0 netns $container_pid\n14. ip link set veth_h0 master ctr0; ip link set ctr0 up\n15. iptables MASQUERADE for 172.20.0.0/24\n16. write(sync_pipe[1], &quot;1&quot;)             ‚îÄ‚îÄ‚Üí  read(sync_pipe[0]) ‚Üí &quot;1&quot;\n                                                getuid() ‚Üí 0 (mapped!)\n                                                mount(&quot;/&quot;,&quot;&quot;,MS_PRIVATE|REC)\n                                                mount(rootfs,rootfs,MS_BIND)\n                                                pivot_root(rootfs, .pivot_old)\n                                                chdir(&quot;/&quot;)\n                                                umount2(&quot;.pivot_old&quot;,MNT_DETACH)\n                                                sethostname(&quot;mycontainer&quot;)\n                                                mount(&quot;proc&quot;,&quot;/proc&quot;,&quot;proc&quot;)\n                                                mount(&quot;sysfs&quot;,&quot;/sys&quot;,&quot;sysfs&quot;)\n                                                mount(&quot;tmpfs&quot;,&quot;/dev&quot;,&quot;tmpfs&quot;)\n                                                ip link set lo up\n                                                ip addr add 172.20.0.2/24 veth_c0\n                                                ip route add default via 172.20.0.1\n                                                fork() ‚Üí child execvp(command)\n                                                waitpid(-1, ...) ‚Üí reaper loop\n17. waitpid(container_pid, ...)          \n18. (container exits ‚Üí kernel SIGKILLs  \n     all namespace members)             \n19. rmdir(&quot;/sys/fs/cgroup/mycontainer&quot;)\n20. ip link del veth_h0  \n21. ip link del ctr0\n22. iptables -D MASQUERADE ...\n23. munmap(stack, STACK_SIZE)</code></pre></div>\n\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-full-container-creation-sequence.svg\" alt=\"Complete Container Creation ‚Äî Full Syscall Sequence\"></p>\n<p>This sequence ‚Äî 23 steps spanning five kernel subsystems (process management, user namespaces, cgroups, networking, filesystems) ‚Äî is what runs every time you execute <code>docker run</code>. Docker&#39;s codebase (via containerd and runc) executes an OCI-specified version of this exact sequence. The abstractions are richer, the error handling is more robust, the OCI spec adds seccomp, AppArmor, and capability dropping ‚Äî but the kernel interactions are these same syscalls in this same order.\nYou have built a container runtime from scratch. You understand not just what it does, but why every step exists, what breaks if you skip it, and how it maps to the kernel primitives that make isolation real.</p>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fdiag-satellite-map.svg\" alt=\"Container Runtime Architecture ‚Äî Satellite Map\"></p>\n<hr>\n<!-- END_MS -->\n\n\n<h2 id=\"system-overview\">System Overview</h2>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"System Overview\"></p>\n<h1 id=\"tdd\">TDD</h1>\n<p>A ground-up container runtime built from raw Linux kernel primitives. Each milestone adds one isolation dimension to a single clone() call, culminating in a fully rootless, resource-limited, network-connected container. The architecture is a single container_init() function that accumulates namespace flags, a sync pipe for host-child coordination, and a cgroup manager on the host side. Every design decision is traceable to a kernel data structure, a syscall, or a hardware constraint.</p>\n<!-- TDD_MOD_ID: container-basic-m1 -->\n<h1 id=\"technical-design-specification-pid-and-uts-namespace-isolation-container-basic-m1\">TECHNICAL DESIGN SPECIFICATION: PID and UTS Namespace Isolation (container-basic-m1)</h1>\n<h2 id=\"1-module-charter\">1. MODULE CHARTER</h2>\n<p>This module implements the primary entry point for the container runtime, establishing the first two layers of isolation: the <strong>PID Namespace</strong> and the <strong>UTS Namespace</strong>. It is responsible for the transition from a host-level process to a &quot;Namespace-Local PID 1&quot; (Init) process. </p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Orchestration of the <code>clone(2)</code> system call with <code>CLONE_NEWPID</code> and <code>CLONE_NEWUTS</code>.</li>\n<li>Safe management of the child stack memory using <code>mmap(2)</code> and <code>mprotect(2)</code> (guard pages).</li>\n<li>Implementation of the <strong>PID 1 Responsibility Loop</strong>: signal handling and orphan process reaping using <code>waitpid(2)</code>.</li>\n<li>Virtualization of the system identity via <code>sethostname(2)</code>.</li>\n</ul>\n<p><strong>Non-Scope:</strong></p>\n<ul>\n<li>Filesystem isolation (Mount NS), Network isolation (Net NS), or Resource Limits (Cgroups).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The process returned by <code>clone()</code> must observe its own PID as 1 via <code>getpid()</code>.</li>\n<li>Host-level hostname must remain unchanged after the container&#39;s <code>sethostname()</code> call.</li>\n<li>All orphaned children inside the namespace must be reaped to prevent zombie accumulation.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. FILE STRUCTURE</h2>\n<p>The implementation follows a strict sequential creation order. The reader should create/modify files in the following order:</p>\n<ol>\n<li><code>src/common.h</code>: Shared macros, includes, and error wrappers.</li>\n<li><code>src/container.h</code>: Struct definitions and function prototypes.</li>\n<li><code>src/reaper.c</code>: Implementation of zombie reaping logic.</li>\n<li><code>src/init.c</code>: The container&#39;s internal entry point (PID 1 logic).</li>\n<li><code>src/main.c</code>: Host-side orchestration, stack allocation, and <code>clone()</code> invocation.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. COMPLETE DATA MODEL</h2>\n<h3 id=\"31-containerconfig-struct\">3.1 ContainerConfig Struct</h3>\n<p>This structure is passed across the <code>clone()</code> boundary from the parent (host) to the child (container).</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>argv</code></td>\n<td align=\"left\"><code>char**</code></td>\n<td align=\"left\">Null-terminated array of strings for <code>execvp</code>. (8 bytes)</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>hostname</code></td>\n<td align=\"left\"><code>char[64]</code></td>\n<td align=\"left\">The desired hostname for the UTS namespace. (64 bytes)</td>\n</tr>\n<tr>\n<td align=\"left\">0x48</td>\n<td align=\"left\"><code>stack</code></td>\n<td align=\"left\"><code>void*</code></td>\n<td align=\"left\">Pointer to the base of the allocated stack. (8 bytes)</td>\n</tr>\n<tr>\n<td align=\"left\">0x50</td>\n<td align=\"left\"><code>stack_size</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">Total size of the allocated stack. (8 bytes)</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> 88 bytes (aligned to 8-byte boundary).</p>\n<h3 id=\"32-child-stack-layout-x86-64-physical-memory\">3.2 Child Stack Layout (x86-64 Physical Memory)</h3>\n<p>The stack is allocated via <code>mmap</code>. On x86-64, the stack grows <strong>downward</strong>.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Address Range</th>\n<th align=\"left\">Logic Name</th>\n<th align=\"left\">Protection</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[base, base + 4KB)</code></td>\n<td align=\"left\">Guard Page</td>\n<td align=\"left\"><code>PROT_NONE</code></td>\n<td align=\"left\">Catches stack overflow via SIGSEGV.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[base + 4KB, base + 1MB)</code></td>\n<td align=\"left\">Usable Stack</td>\n<td align=\"left\"><code>PROT_READ|WRITE</code></td>\n<td align=\"left\">Stack frames for child execution.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>base + 1MB</code></td>\n<td align=\"left\"><strong>stack_top</strong></td>\n<td align=\"left\">N/A</td>\n<td align=\"left\"><strong>Initial RSP passed to clone()</strong>.</td>\n</tr>\n</tbody></table>\n<h3 id=\"33-cache-line-analysis-64-byte-lines\">3.3 Cache Line Analysis (64-byte lines)</h3>\n<ul>\n<li><code>ContainerConfig</code> spans exactly two cache lines (64B + 24B).</li>\n<li>To prevent false sharing in future multi-threaded milestones, ensure <code>ContainerConfig</code> is allocated via <code>posix_memalign</code> to a 64-byte boundary.</li>\n</ul>\n<hr>\n<h2 id=\"4-hardware-soul-physical-constraints\">4. HARDWARE SOUL: PHYSICAL CONSTRAINTS</h2>\n<p>Every namespace operation negotiates with specific hardware subsystems:</p>\n<ul>\n<li><strong>The TLB and Context Switches</strong>: Calling <code>clone()</code> triggers a context switch. While namespaces are lightweight, the hardware TLB (Translation Lookaside Buffer) entries for the parent process are not valid for the new child if Address Space Layout Randomization (ASLR) creates distinct mappings. However, since the child shares the parent&#39;s memory initially (until <code>exec</code>), many L1i/L1d cache lines remain &quot;hot.&quot;</li>\n<li><strong>Stack Alignment</strong>: The <code>stack_top</code> passed to <code>clone()</code> <strong>MUST</strong> be 16-byte aligned to satisfy the x86-64 ABI requirements. Failure to align leads to crashes in SSE/AVX instructions within the child.</li>\n<li><strong>Cache Locality</strong>: The <code>argv</code> array should be copied into the <code>ContainerConfig</code> to ensure that when the child process boots, the pointers it needs are likely in L1/L2 cache, minimizing initial cold-start latency.</li>\n<li><strong>Branch Prediction</strong>: The PID 1 reaper loop (<code>while(1)</code>) is highly predictable for the CPU branch predictor. The <code>waitpid</code> call with <code>WNOHANG</code> will likely return <code>-ECHILD</code> most cycles; the CPU will speculative execute the &quot;sleep&quot; or &quot;continue&quot; path.</li>\n</ul>\n<hr>\n<h2 id=\"5-interface-contracts\">5. INTERFACE CONTRACTS</h2>\n<h3 id=\"51-int-container_initvoid-arg\">5.1 <code>int container_init(void* arg)</code></h3>\n<p>The entry point for the child process.</p>\n<ul>\n<li><strong>Input:</strong> Pointer to <code>ContainerConfig</code>.</li>\n<li><strong>Pre-condition:</strong> Process is running in new PID/UTS namespaces.</li>\n<li><strong>Post-condition:</strong> Hostname is set; user command is forked; orphans are reaped.</li>\n<li><strong>Errors:</strong> <ul>\n<li>Returns <code>1</code> if <code>sethostname</code> fails.</li>\n<li>Returns <code>1</code> if <code>fork</code> for the primary task fails.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"52-void-reap_zombiesvoid\">5.2 <code>void reap_zombies(void)</code></h3>\n<p>Non-blocking collector for orphaned children.</p>\n<ul>\n<li><strong>Logic:</strong> Calls <code>waitpid(-1, &amp;status, WNOHANG)</code> in a loop until it returns 0 or -1.</li>\n<li><strong>Invariant:</strong> Must be called whenever a child process in the namespace exits.</li>\n</ul>\n<h3 id=\"53-void-prepare_stacksize_t-size\">5.3 <code>void* prepare_stack(size_t size)</code></h3>\n<p>Allocates the memory for the child.</p>\n<ul>\n<li><strong>Input:</strong> 1 MiB.</li>\n<li><strong>Logic:</strong> <code>mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0)</code>.</li>\n<li><strong>Logic:</strong> <code>mprotect(ptr, 4096, PROT_NONE)</code> on the bottom page.</li>\n<li><strong>Returns:</strong> Pointer to the <strong>top</strong> of the stack (<code>ptr + size</code>).</li>\n</ul>\n<hr>\n<h2 id=\"6-algorithm-specification\">6. ALGORITHM SPECIFICATION</h2>\n<h3 id=\"61-the-clone-orchestration-parent-side\">6.1 The Clone Orchestration (Parent Side)</h3>\n<ol>\n<li>Initialize <code>ContainerConfig</code> with <code>argv</code> and <code>hostname</code>.</li>\n<li><code>stack_low = mmap(...)</code>.</li>\n<li><code>stack_top = stack_low + STACK_SIZE</code>.</li>\n<li><code>container_pid = clone(container_init, stack_top, CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD, &amp;cfg)</code>.</li>\n<li>Check <code>container_pid == -1</code>. On error, check <code>errno</code>:<ul>\n<li><code>EPERM</code>: User lacks <code>CAP_SYS_ADMIN</code>.</li>\n<li><code>ENOMEM</code>: Stack allocation failed.</li>\n</ul>\n</li>\n<li>Call <code>waitpid(container_pid, &amp;status, 0)</code> to block until container exit.</li>\n</ol>\n<h3 id=\"62-the-pid-1-init-loop-child-side\">6.2 The PID 1 Init Loop (Child Side)</h3>\n<p>The Child process becomes PID 1. It must manage the lifecycle of the actual workload.</p>\n<ol>\n<li><code>sethostname(cfg-&gt;hostname)</code>.</li>\n<li><code>pid_t main_task = fork()</code>.</li>\n<li><strong>If <code>main_task == 0</code></strong>: <ul>\n<li><code>execvp(cfg-&gt;argv[0], cfg-&gt;argv)</code>.</li>\n<li>Exit on failure.</li>\n</ul>\n</li>\n<li><strong>If <code>main_task &gt; 0</code> (The Reaper Phase)</strong>:<ul>\n<li>Enter <code>while(1)</code> loop.</li>\n<li>Call <code>pid_t exited_pid = waitpid(-1, &amp;status, 0)</code>. (Blocking wait for any child).</li>\n<li>If <code>exited_pid == main_task</code>:<ul>\n<li>The primary workload is done.</li>\n<li>Call <code>reap_zombies()</code> one last time.</li>\n<li><code>exit(WEXITSTATUS(status))</code>.</li>\n</ul>\n</li>\n<li>If <code>exited_pid &gt; 0</code> (An orphan died):<ul>\n<li>Log the event.</li>\n<li>Continue reaping.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Ftdd-diag-1.svg\" alt=\"PID Namespace Dual View ‚Äî Same Process, Two PIDs\">\n (Init Process State Machine)</p>\n<hr>\n<h2 id=\"7-error-handling-matrix\">7. ERROR HANDLING MATRIX</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error Condition</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery Action</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>clone()</code> returns -1</td>\n<td align=\"left\"><code>main()</code></td>\n<td align=\"left\">Log <code>perror</code>, free stack, exit 1.</td>\n<td align=\"left\">Yes (<code>Operation not permitted</code>)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>sethostname()</code> fails</td>\n<td align=\"left\"><code>container_init()</code></td>\n<td align=\"left\">Return 1 to <code>clone</code> exit code.</td>\n<td align=\"left\">Yes (Logs in stderr)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>waitpid()</code> returns <code>EINTR</code></td>\n<td align=\"left\"><code>container_init()</code></td>\n<td align=\"left\">Retry <code>waitpid</code> immediately.</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Stack Overflow</td>\n<td align=\"left\">Hardware MMU</td>\n<td align=\"left\">Process receives <code>SIGSEGV</code>.</td>\n<td align=\"left\">Yes (Crashes container)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>execvp()</code> fails</td>\n<td align=\"left\">Child of Init</td>\n<td align=\"left\"><code>perror</code>, <code>exit(127)</code>.</td>\n<td align=\"left\">Yes (Command not found)</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"8-implementation-path-checkpoints\">8. IMPLEMENTATION PATH (CHECKPOINTS)</h2>\n<h3 id=\"phase-1-the-foundation-2-hours\">Phase 1: The Foundation (2 hours)</h3>\n<ul>\n<li>Implement <code>prepare_stack</code> with <code>mmap</code> and the guard page.</li>\n<li>Set up a dummy <code>container_init</code> that just prints <code>getpid()</code>.</li>\n<li><strong>Checkpoint:</strong> Run binary. It should print <code>Inside container, PID: 1</code> and <code>Host PID: [some_large_number]</code>.</li>\n</ul>\n<h3 id=\"phase-2-system-identity-1-hour\">Phase 2: System Identity (1 hour)</h3>\n<ul>\n<li>Implement <code>CLONE_NEWUTS</code>.</li>\n<li>Call <code>sethostname</code> in <code>container_init</code>.</li>\n<li><strong>Checkpoint:</strong> Run container with <code>/bin/bash</code>. Inside bash, run <code>hostname</code>. It should match your config. Outside (in host), run <code>hostname</code>. It must remain unchanged.</li>\n</ul>\n<h3 id=\"phase-3-the-reaper-2-hours\">Phase 3: The Reaper (2 hours)</h3>\n<ul>\n<li>Implement the <code>fork()</code> and <code>execvp()</code> logic within <code>container_init</code>.</li>\n<li>Implement the <code>while(1)</code> loop with <code>waitpid</code>.</li>\n<li>Add a test script that spawns background processes and exits (orphans).</li>\n<li><strong>Checkpoint:</strong> Use <code>ps aux</code> on host while container runs. Kill a background process in the container. Verify it does not stay in <code>&lt;defunct&gt;</code> (Z) state.</li>\n</ul>\n<h3 id=\"phase-4-formal-verification-1-hour\">Phase 4: Formal Verification (1 hour)</h3>\n<ul>\n<li>Implement <code>verify_pid_namespace</code> by parsing <code>/proc/self/status</code>.</li>\n<li>Extract the <code>NSpid</code> field.</li>\n<li><strong>Checkpoint:</strong> Output should confirm <code>NSpid: 47832 1</code> (Host PID and Namespace PID).</li>\n</ul>\n<hr>\n<h2 id=\"9-test-specification\">9. TEST SPECIFICATION</h2>\n<h3 id=\"91-test-case-pid-1-confirmation\">9.1 Test Case: PID 1 Confirmation</h3>\n<ul>\n<li><strong>Action:</strong> Launch container with <code>echo $$</code>.</li>\n<li><strong>Expectation:</strong> Output is <code>1</code>.</li>\n</ul>\n<h3 id=\"92-test-case-hostname-isolation\">9.2 Test Case: Hostname Isolation</h3>\n<ul>\n<li><strong>Action:</strong> Launch container, call <code>sethostname(&quot;isolated-node&quot;)</code>.</li>\n<li><strong>Expectation:</strong> <code>gethostname()</code> returns <code>isolated-node</code> inside, host returns original hostname.</li>\n</ul>\n<h3 id=\"93-test-case-zombie-collection\">9.3 Test Case: Zombie Collection</h3>\n<ul>\n<li><strong>Action:</strong> Inside container, run <code>sh -c &#39;sleep 100 &amp; exit&#39;</code>. </li>\n<li><strong>Observation:</strong> The <code>sleep</code> process is re-parented to PID 1.</li>\n<li><strong>Action:</strong> Kill the <code>sleep</code> process from the host.</li>\n<li><strong>Expectation:</strong> PID 1 reaps the process. <code>ps</code> on host shows the process is gone.</li>\n</ul>\n<hr>\n<h2 id=\"10-performance-targets\">10. PERFORMANCE TARGETS</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Namespace Creation</td>\n<td align=\"left\">&lt; 100 Œºs</td>\n<td align=\"left\"><code>clock_gettime(CLOCK_MONOTONIC)</code> around <code>clone()</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">PID Lookup Latency</td>\n<td align=\"left\">&lt; 500 ns</td>\n<td align=\"left\">1,000,000 iterations of <code>getpid()</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Memory Footprint</td>\n<td align=\"left\">&lt; 2 MiB</td>\n<td align=\"left\"><code>Vmrss</code> in <code>/proc/[pid]/status</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Stack Overhead</td>\n<td align=\"left\">1 MiB (Fixed)</td>\n<td align=\"left\">Static allocation size.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-memory-layout-containerconfig\">11. MEMORY LAYOUT (ContainerConfig)</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Byte alignment: 8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Total size: 88 bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">typedef</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char**</span><span style=\"color:#E1E4E8\"> argv;</span><span style=\"color:#6A737D\">           // 0x00 - Ptr to char* array</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    char</span><span style=\"color:#FFAB70\"> hostname</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span><span style=\"color:#6A737D\">     // 0x08 - Hostname string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    void*</span><span style=\"color:#E1E4E8\"> stack_base;</span><span style=\"color:#6A737D\">      // 0x48 - Pointer to mmap base</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    size_t</span><span style=\"color:#E1E4E8\"> stack_size;</span><span style=\"color:#6A737D\">     // 0x50 - Total size of stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} ContainerConfig;</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m2 -->\n<h1 id=\"technical-design-specification-mount-namespace-and-filesystem-isolation-container-basic-m2\">TECHNICAL DESIGN SPECIFICATION: Mount Namespace and Filesystem Isolation (container-basic-m2)</h1>\n<h2 id=\"1-module-charter\">1. MODULE CHARTER</h2>\n<p>This module extends the container runtime to provide complete filesystem isolation. While Milestone 1 isolated the process tree and hostname, the container still shared the host&#39;s root filesystem. Milestone 2 implements a private <strong>Mount Namespace</strong> (<code>CLONE_NEWNS</code>) and utilizes the <code>pivot_root(2)</code> system call to swap the root filesystem atomically.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Extension of the <code>clone()</code> call to include the <code>CLONE_NEWNS</code> flag.</li>\n<li>Resetting mount propagation to <code>MS_PRIVATE</code> to prevent &quot;leakage&quot; of mount events to the host.</li>\n<li>Preparation of the new root filesystem (<code>rootfs</code>) including bind-mounting it onto itself to satisfy kernel mount-point requirements.</li>\n<li>Execution of the <code>pivot_root</code> sequence: swapping roots, changing directory, and lazy-unmounting the host root.</li>\n<li>Mounting essential kernel pseudo-filesystems (<code>/proc</code>, <code>/sys</code>, <code>/dev</code>) with security-conscious flags.</li>\n<li>Population of a minimal <code>/dev</code> via bind-mounts of host character devices.</li>\n</ul>\n<p><strong>Non-Scope:</strong></p>\n<ul>\n<li>Network namespace configuration (Milestone 3).</li>\n<li>Cgroup resource enforcement (Milestone 4).</li>\n<li>User namespace UID/GID mapping (Milestone 5).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>After <code>do_pivot_root</code>, the process must be unable to resolve any path leading to the host&#39;s original root filesystem.</li>\n<li>The <code>/proc</code> filesystem inside the container must only reflect processes within the container&#39;s PID namespace.</li>\n<li>All mount operations performed inside the container must be invisible to the host mount namespace.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. FILE STRUCTURE</h2>\n<p>The implementation follows a strict sequential order. The user should modify the Milestone 1 files and add the new filesystem logic as follows:</p>\n<ol>\n<li><code>src/common.h</code>: Add <code>MS_REC</code>, <code>MS_PRIVATE</code>, <code>MS_BIND</code>, and <code>SYS_pivot_root</code> related headers.</li>\n<li><code>src/filesystem.c</code>: <strong>(NEW)</strong> Core logic for mount propagation, pivoting, and pseudo-fs mounting.</li>\n<li><code>src/container.h</code>: Update <code>ContainerConfig</code> struct to include <code>rootfs</code> path.</li>\n<li><code>src/init.c</code>: Integrate filesystem setup calls into the <code>container_init</code> sequence.</li>\n<li><code>src/main.c</code>: Update <code>clone()</code> flags and command-line argument parsing for <code>rootfs</code>.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. COMPLETE DATA MODEL</h2>\n<h3 id=\"31-containerconfig-struct-updated\">3.1 ContainerConfig Struct (Updated)</h3>\n<p>The structure is expanded to handle the path to the rootfs directory. All strings are passed as pointers to host-allocated memory.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>argv</code></td>\n<td align=\"left\"><code>char**</code></td>\n<td align=\"left\">Null-terminated array of strings for <code>execvp</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>hostname</code></td>\n<td align=\"left\"><code>char[64]</code></td>\n<td align=\"left\">Desired hostname for UTS namespace.</td>\n</tr>\n<tr>\n<td align=\"left\">0x48</td>\n<td align=\"left\"><code>rootfs</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\"><strong>(NEW)</strong> Absolute path to the container root directory.</td>\n</tr>\n<tr>\n<td align=\"left\">0x50</td>\n<td align=\"left\"><code>stack_base</code></td>\n<td align=\"left\"><code>void*</code></td>\n<td align=\"left\">Pointer to the base of the allocated stack.</td>\n</tr>\n<tr>\n<td align=\"left\">0x58</td>\n<td align=\"left\"><code>stack_size</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">Total size of the allocated stack.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> 96 bytes (aligned to 8-byte boundary).</p>\n<h3 id=\"32-mount-flag-bitmasks\">3.2 Mount Flag Bitmasks</h3>\n<p>We utilize the following standard Linux mount flags defined in <code>&lt;sys/mount.h&gt;</code> and <code>&lt;linux/fs.h&gt;</code>:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Flag</th>\n<th align=\"left\">Value</th>\n<th align=\"left\">Purpose in this Module</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>MS_REC</code></td>\n<td align=\"left\"><code>0x4000</code></td>\n<td align=\"left\">Apply operation recursively to the entire subtree.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MS_PRIVATE</code></td>\n<td align=\"left\"><code>0x40000</code></td>\n<td align=\"left\">Decouple mount events from other namespaces.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MS_BIND</code></td>\n<td align=\"left\"><code>0x1000</code></td>\n<td align=\"left\">Create a bind mount (required for pivot_root).</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MS_NOSUID</code></td>\n<td align=\"left\"><code>0x0002</code></td>\n<td align=\"left\">Ignore set-user-ID and set-group-ID bits.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MS_NODEV</code></td>\n<td align=\"left\"><code>0x0004</code></td>\n<td align=\"left\">Disallow access to device special files on this FS.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MS_NOEXEC</code></td>\n<td align=\"left\"><code>0x0008</code></td>\n<td align=\"left\">Disallow program execution from this FS.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>MNT_DETACH</code></td>\n<td align=\"left\"><code>0x0002</code></td>\n<td align=\"left\">Perform &quot;lazy&quot; unmount (detach from tree immediately).</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-hardware-soul-physical-constraints\">4. HARDWARE SOUL: PHYSICAL CONSTRAINTS</h2>\n<h3 id=\"41-vfs-tree-and-kernel-memory\">4.1 VFS Tree and Kernel Memory</h3>\n<p>The Linux kernel manages mounts as a tree of <code>struct mount</code> objects in the VFS (Virtual Filesystem) layer. </p>\n<ul>\n<li><strong>Memory Footprint</strong>: Each mount entry consumes approximately 200-300 bytes of kernel slab memory. Creating a container with 10-15 mounts (root, proc, sys, dev, plus 5-6 device binds) adds ~4KB of kernel overhead.</li>\n<li><strong>Latency</strong>: <code>pivot_root</code> is a metadata-only operation. It performs &quot;pointer surgery&quot; on the <code>namespace_lock</code>-protected global mount list. It does not touch the physical disk. Latency is typically <strong>2-10 microseconds</strong>.</li>\n</ul>\n<h3 id=\"42-tlb-and-path-resolution\">4.2 TLB and Path Resolution</h3>\n<p>Path resolution (walking <code>/etc/passwd</code>) involves the dentry cache (dcache). </p>\n<ul>\n<li><strong>Physical Tension</strong>: When we <code>pivot_root</code>, we invalidate the path-lookup cache for the calling process. The next <code>open()</code> call will incur a &quot;cold start&quot; in the dcache, requiring the kernel to re-traverse the directory entries of the <em>new</em> rootfs from the underlying storage (SSD/HDD).</li>\n<li><strong>Instruction Cache</strong>: Sycall wrappers like <code>mount()</code> and <code>umount2()</code> are part of the kernel hot-path. Calling them in rapid succession during container boot ensures the kernel code for VFS management is warm in the L1i cache.</li>\n</ul>\n<hr>\n<h2 id=\"5-interface-contracts\">5. INTERFACE CONTRACTS</h2>\n<h3 id=\"51-int-set_mounts_privatevoid\">5.1 <code>int set_mounts_private(void)</code></h3>\n<p><strong>Logic:</strong> <code>mount(NULL, &quot;/&quot;, NULL, MS_REC | MS_PRIVATE, NULL)</code></p>\n<ul>\n<li><strong>Goal:</strong> Resets the propagation of the entire host mount tree within the new namespace.</li>\n<li><strong>Error:</strong> Returns <code>-1</code> if called outside a mount namespace.</li>\n</ul>\n<h3 id=\"52-int-bind_mount_rootfsconst-char-rootfs\">5.2 <code>int bind_mount_rootfs(const char* rootfs)</code></h3>\n<p><strong>Logic:</strong> <code>mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL)</code></p>\n<ul>\n<li><strong>Constraint:</strong> <code>pivot_root</code> requires the <code>new_root</code> to be a mount point. A standard directory is not a mount point; bind-mounting it to itself creates a mount entry in the kernel&#39;s table.</li>\n</ul>\n<h3 id=\"53-int-do_pivot_rootconst-char-rootfs\">5.3 <code>int do_pivot_root(const char* rootfs)</code></h3>\n<p><strong>Logic:</strong></p>\n<ol>\n<li><code>mkdir(&quot;.pivot_old&quot;)</code> inside <code>rootfs</code>.</li>\n<li><code>syscall(SYS_pivot_root, rootfs, &quot;.pivot_old&quot;)</code>.</li>\n<li><code>chdir(&quot;/&quot;)</code>.</li>\n<li><code>umount2(&quot;/.pivot_old&quot;, MNT_DETACH)</code>.</li>\n<li><code>rmdir(&quot;/.pivot_old&quot;)</code>.</li>\n</ol>\n<h3 id=\"54-int-mount_pseudofsvoid\">5.4 <code>int mount_pseudofs(void)</code></h3>\n<p><strong>Logic:</strong></p>\n<ul>\n<li><code>mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, MS_NOSUID|MS_NOEXEC|MS_NODEV, NULL)</code>.</li>\n<li><code>mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_RDONLY, NULL)</code>.</li>\n<li><code>mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID|MS_STRICTATIME, &quot;mode=755&quot;)</code>.</li>\n</ul>\n<hr>\n<h2 id=\"6-algorithm-specification-the-pivot-sequence\">6. ALGORITHM SPECIFICATION: THE PIVOT SEQUENCE</h2>\n<p>The kernel enforces 7 strict checks for <code>pivot_root(new, old)</code>. Failure to follow this sequence results in <code>EINVAL</code>.</p>\n<ol>\n<li><strong>Preparation Phase</strong>: Create the target directory inside the new rootfs (e.g., <code>mkdir(rootfs + &quot;/.pivot_old&quot;)</code>).</li>\n<li><strong>Mount Point Creation</strong>: Perform the &quot;bind-mount-to-self&quot; trick on <code>rootfs</code>. This satisfies the requirement that <code>new_root</code> must be a mount point.</li>\n<li><strong>Atomic Swap</strong>: Call <code>pivot_root</code>. This moves the current root mount to <code>old</code>, and makes <code>new</code> the new root mount for the namespace.</li>\n<li><strong>Reference Correction</strong>: Call <code>chdir(&quot;/&quot;)</code>. Even though the root has changed, the process&#39;s Current Working Directory (CWD) still points to the old root&#39;s inode. <code>chdir(&quot;/&quot;)</code> snaps the CWD to the new root.</li>\n<li><strong>Host Detachment</strong>: Call <code>umount2(&quot;/.pivot_old&quot;, MNT_DETACH)</code>. <ul>\n<li><em>Why MNT_DETACH?</em> If any background process or kernel thread has a transient handle on the old root, a standard <code>umount</code> will fail with <code>EBUSY</code>. <code>MNT_DETACH</code> detaches the mount from the tree immediately while allowing existing handles to close gracefully.</li>\n</ul>\n</li>\n<li><strong>Cleanup</strong>: <code>rmdir(&quot;/.pivot_old&quot;)</code>. This is only possible after the unmount.</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Ftdd-diag-9.svg\" alt=\"pivot_root() Atomic Root Swap ‚Äî Mount Namespace Before and After\">\n (Filesystem Isolation Flow)</p>\n<hr>\n<h2 id=\"7-error-handling-matrix\">7. ERROR HANDLING MATRIX</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Cause</th>\n<th align=\"left\">Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EINVAL</code></td>\n<td align=\"left\"><code>pivot_root</code></td>\n<td align=\"left\"><code>new_root</code> is not a mount point.</td>\n<td align=\"left\">Verify <code>MS_BIND</code> was successful.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EINVAL</code></td>\n<td align=\"left\"><code>pivot_root</code></td>\n<td align=\"left\"><code>put_old</code> is not underneath <code>new_root</code>.</td>\n<td align=\"left\">Check <code>mkdir</code> path construction.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EBUSY</code></td>\n<td align=\"left\"><code>umount2</code></td>\n<td align=\"left\">Filesystem is being used by the kernel.</td>\n<td align=\"left\">Use <code>MNT_DETACH</code> to force lazy-unmount.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOENT</code></td>\n<td align=\"left\"><code>mount</code></td>\n<td align=\"left\"><code>/proc</code> or <code>/sys</code> missing in rootfs.</td>\n<td align=\"left\"><code>mkdir</code> the mountpoints before mounting.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EPERM</code></td>\n<td align=\"left\"><code>mount</code></td>\n<td align=\"left\">Missing <code>CAP_SYS_ADMIN</code>.</td>\n<td align=\"left\">Must run as root (until Milestone 5).</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS</h2>\n<h3 id=\"phase-1-preparation-1-hour\">Phase 1: Preparation (1 hour)</h3>\n<ol>\n<li>Update <code>main.c</code> to accept a rootfs path as the first argument.</li>\n<li>Update <code>clone()</code> to include <code>CLONE_NEWNS</code>.</li>\n<li>Implement <code>create_rootfs_dirs</code> to ensure <code>proc</code>, <code>sys</code>, <code>dev</code>, and <code>.pivot_old</code> exist.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Run with <code>sudo ./container ./myrootfs /bin/ls</code>. It should still show host files because pivoting isn&#39;t active.</li>\n</ul>\n<h3 id=\"phase-2-the-pivot-2-hours\">Phase 2: The Pivot (2 hours)</h3>\n<ol>\n<li>Implement <code>set_mounts_private</code> and <code>bind_mount_rootfs</code>.</li>\n<li>Implement <code>do_pivot_root</code> using <code>syscall(SYS_pivot_root, ...)</code>.</li>\n<li>Add <code>chdir(&quot;/&quot;)</code> and the <code>umount2</code> sequence.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Run <code>/bin/ls /</code>. It should now show only the contents of <code>myrootfs</code>. <code>ls /home</code> should return <code>No such file or directory</code>.</li>\n</ul>\n<h3 id=\"phase-3-pseudo-filesystems-1-hour\">Phase 3: Pseudo-Filesystems (1 hour)</h3>\n<ol>\n<li>Implement <code>mount_pseudofs</code>.</li>\n<li>Ensure <code>/proc</code> is mounted with <code>MS_NOSUID | MS_NOEXEC | MS_NODEV</code>.</li>\n<li>Mount <code>/dev</code> as a <code>tmpfs</code>.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Run <code>/bin/ps aux</code>. It should only show PID 1 (your init) and the <code>ps</code> command itself.</li>\n</ul>\n<h3 id=\"phase-4-device-population-1-hour\">Phase 4: Device Population (1 hour)</h3>\n<ol>\n<li>Implement the loop to bind-mount <code>/dev/null</code>, <code>/dev/zero</code>, and <code>/dev/urandom</code> from the host.</li>\n<li>Create empty files in the container&#39;s <code>/dev</code> to act as mount targets.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Run <code>cat /dev/urandom | head -c 10</code>. It should produce random output inside the container.</li>\n</ul>\n<hr>\n<h2 id=\"9-test-specification\">9. TEST SPECIFICATION</h2>\n<h3 id=\"91-test-host-isolation\">9.1 Test: Host Isolation</h3>\n<ul>\n<li><strong>Action</strong>: Launch container. Run <code>ls /etc/shadow</code>.</li>\n<li><strong>Requirement</strong>: If the container&#39;s rootfs doesn&#39;t have an <code>etc/shadow</code>, it must return <code>ENOENT</code>. It must <strong>not</strong> see the host&#39;s shadow file.</li>\n</ul>\n<h3 id=\"92-test-procfs-scoping\">9.2 Test: Procfs Scoping</h3>\n<ul>\n<li><strong>Action</strong>: Run <code>sleep 999 &amp;</code> on the host. Launch container. Run <code>ps aux | grep sleep</code>.</li>\n<li><strong>Requirement</strong>: Output must be empty. The container&#39;s <code>/proc</code> is restricted to its own PID namespace.</li>\n</ul>\n<h3 id=\"93-test-mount-propagation\">9.3 Test: Mount Propagation</h3>\n<ul>\n<li><strong>Action</strong>: Inside the container, run <code>mount -t tmpfs tmpfs /mnt</code>.</li>\n<li><strong>Action</strong>: On the host, run <code>cat /proc/mounts | grep /mnt</code>.</li>\n<li><strong>Requirement</strong>: The host must <strong>not</strong> see the container&#39;s <code>/mnt</code> mount.</li>\n</ul>\n<hr>\n<h2 id=\"10-performance-targets\">10. PERFORMANCE TARGETS</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>pivot_root</code> Latency</td>\n<td align=\"left\">&lt; 50 Œºs</td>\n<td align=\"left\"><code>clock_gettime</code> around syscall.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>/proc</code> Mount Time</td>\n<td align=\"left\">&lt; 500 Œºs</td>\n<td align=\"left\">Kernel overhead for superblock creation.</td>\n</tr>\n<tr>\n<td align=\"left\">Total FS Isolation</td>\n<td align=\"left\">&lt; 2 ms</td>\n<td align=\"left\">Time from <code>container_init</code> start to <code>execvp</code>.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-concurrency-specification\">11. CONCURRENCY SPECIFICATION</h2>\n<p><strong>Locking Strategy:</strong></p>\n<ul>\n<li>All filesystem operations in this milestone are performed by a single thread (the container&#39;s PID 1) during the startup phase.</li>\n<li>No mutexes are required in userspace. </li>\n<li>The kernel handles concurrency via the <code>namespace_lock</code> (read/write semaphore) which prevents other processes from modifying the mount table while <code>pivot_root</code> is in progress.</li>\n</ul>\n<p><strong>Execution Order (STRICT):</strong></p>\n<ol>\n<li><code>unshare(CLONE_NEWNS)</code> (via <code>clone</code>)</li>\n<li><code>mount(NULL, &quot;/&quot;, NULL, MS_REC | MS_PRIVATE, NULL)</code></li>\n<li><code>mount(rootfs, rootfs, NULL, MS_BIND, NULL)</code></li>\n<li><code>pivot_root(...)</code></li>\n<li><code>mount(&quot;proc&quot;, ...)</code></li>\n</ol>\n<p><em>Any reordering of 2, 3, and 4 will result in an insecure state or syscall failure.</em></p>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m3 -->\n<h1 id=\"technical-design-specification-network-namespace-and-container-networking-container-basic-m3\">TECHNICAL DESIGN SPECIFICATION: Network Namespace and Container Networking (container-basic-m3)</h1>\n<h2 id=\"1-module-charter\">1. MODULE CHARTER</h2>\n<p>This module establishes the connectivity layer for the container runtime. While Milestones 1 and 2 provide process and filesystem isolation, the container remains attached to the host&#39;s network stack by default. Milestone 3 implements a private <strong>Network Namespace</strong> (<code>CLONE_NEWNET</code>) and constructs a virtualized L2/L3 topology to enable isolated yet routed communication.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Extension of the <code>clone()</code> orchestration to include <code>CLONE_NEWNET</code>.</li>\n<li>Implementation of a <strong>Two-Phase Synchronization Protocol</strong> using a Unix pipe to coordinate network setup between the host (parent) and container (child).</li>\n<li>Host-side infrastructure: Creation of a Linux Bridge (<code>ctr0</code>), a Virtual Ethernet (<code>veth</code>) pair, and the atomic migration of one <code>veth</code> end into the child&#39;s namespace.</li>\n<li>Routing and NAT: Configuration of <code>ip_forward</code> and <code>iptables MASQUERADE</code> rules to enable outbound internet access via the host&#39;s egress interface.</li>\n<li>Container-side configuration: Activation of the loopback interface (<code>lo</code>), static IP assignment for the container-side <code>veth</code>, and default gateway routing.</li>\n<li>Static DNS injection via <code>/etc/resolv.conf</code>.</li>\n</ul>\n<p><strong>Non-Scope:</strong></p>\n<ul>\n<li>Cgroup resource limits (Milestone 4).</li>\n<li>User Namespace UID/GID mapping (Milestone 5).</li>\n<li>Software-Defined Networking (SDN) overlays (VXLAN/Geneve).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The container must have a private <code>lo</code> interface; failure to bring it up results in local socket binding errors.</li>\n<li>The host <code>veth</code> end must be attached to the bridge before the container is unblocked.</li>\n<li>The container must not be able to sniff host network traffic or bind to host ports.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. FILE STRUCTURE</h2>\n<p>The implementation requires a coordinated sequence across the following files:</p>\n<ol>\n<li><code>src/common.h</code>: Add networking-specific macros (IP ranges, interface names).</li>\n<li><code>src/net_host.c</code>: <strong>(NEW)</strong> Host-side logic for bridge, veth, and iptables.</li>\n<li><code>src/net_container.c</code>: <strong>(NEW)</strong> Container-side logic for interface activation and routing.</li>\n<li><code>src/container.h</code>: Update <code>ContainerConfig</code> with <code>outbound_iface</code> and <code>sync_pipe_read</code>.</li>\n<li><code>src/init.c</code>: Update <code>container_init</code> to implement the blocking read on the sync pipe.</li>\n<li><code>src/main.c</code>: Orchestrate the pipe creation, network setup calls, and cleanup.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. COMPLETE DATA MODEL</h2>\n<h3 id=\"31-containerconfig-struct-updated\">3.1 ContainerConfig Struct (Updated)</h3>\n<p>The structure now includes fields for network synchronization and host-egress discovery.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>argv</code></td>\n<td align=\"left\"><code>char**</code></td>\n<td align=\"left\">Null-terminated array of strings for <code>execvp</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>hostname</code></td>\n<td align=\"left\"><code>char[64]</code></td>\n<td align=\"left\">Desired hostname for UTS namespace.</td>\n</tr>\n<tr>\n<td align=\"left\">0x48</td>\n<td align=\"left\"><code>rootfs</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\">Absolute path to the container root directory.</td>\n</tr>\n<tr>\n<td align=\"left\">0x50</td>\n<td align=\"left\"><code>outbound_iface</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\">Host interface for NAT (e.g., &quot;eth0&quot;, &quot;enp3s0&quot;).</td>\n</tr>\n<tr>\n<td align=\"left\">0x58</td>\n<td align=\"left\"><code>sync_pipe_read</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">File descriptor for the read end of the sync pipe.</td>\n</tr>\n<tr>\n<td align=\"left\">0x60</td>\n<td align=\"left\"><code>stack_base</code></td>\n<td align=\"left\"><code>void*</code></td>\n<td align=\"left\">Pointer to the base of the allocated stack.</td>\n</tr>\n<tr>\n<td align=\"left\">0x68</td>\n<td align=\"left\"><code>stack_size</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">Total size of the allocated stack.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> 112 bytes (aligned to 8-byte boundary).</p>\n<h3 id=\"32-network-topology-constants\">3.2 Network Topology Constants</h3>\n<p>To ensure reproducibility, we use a fixed subnet for the container bridge.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Constant</th>\n<th align=\"left\">Value</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>BRIDGE_NAME</code></td>\n<td align=\"left\"><code>&quot;ctr0&quot;</code></td>\n<td align=\"left\">The virtual switch hub on the host.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>BRIDGE_IP</code></td>\n<td align=\"left\"><code>&quot;172.20.0.1&quot;</code></td>\n<td align=\"left\">Gateway address for the container.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>BRIDGE_NET</code></td>\n<td align=\"left\"><code>&quot;172.20.0.1/24&quot;</code></td>\n<td align=\"left\">Subnet mask for the bridge.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>CONT_IP</code></td>\n<td align=\"left\"><code>&quot;172.20.0.2&quot;</code></td>\n<td align=\"left\">Fixed IP for the container veth.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>VETH_HOST</code></td>\n<td align=\"left\"><code>&quot;veth_h0&quot;</code></td>\n<td align=\"left\">Host-side endpoint of the veth pair.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>VETH_CONT</code></td>\n<td align=\"left\"><code>&quot;veth_c0&quot;</code></td>\n<td align=\"left\">Container-side endpoint of the veth pair.</td>\n</tr>\n</tbody></table>\n<h3 id=\"33-cache-line-analysis-64b\">3.3 Cache Line Analysis (64B)</h3>\n<ul>\n<li><code>ContainerConfig</code> now spans <strong>two full cache lines</strong> (112 bytes). </li>\n<li><strong>MANDATORY</strong>: The <code>sync_pipe_read</code> field (at 0x58) and <code>outbound_iface</code> (at 0x50) sit on the same cache line. In a multi-container start scenario, contention on this cache line during <code>clone()</code> argument reading may occur. However, since the struct is read-only after <code>clone()</code>, it will be cached as &quot;Shared&quot; across CPU cores.</li>\n</ul>\n<hr>\n<h2 id=\"4-hardware-soul-physical-constraints\">4. HARDWARE SOUL: PHYSICAL CONSTRAINTS</h2>\n<h3 id=\"41-packet-path-and-namespace-crossing\">4.1 Packet Path and Namespace Crossing</h3>\n<p>When a packet travels from the container to the internet:</p>\n<ol>\n<li><strong>Context Switch</strong>: The packet starts in the container&#39;s network namespace. </li>\n<li><strong>The veth Bridge</strong>: The kernel&#39;s <code>veth_xmit()</code> function is called. It does <strong>not</strong> copy data; it moves the <code>sk_buff</code> (socket buffer) pointer from the container&#39;s TX queue to the peer&#39;s RX queue. </li>\n<li><strong>Instruction Cache Pressure</strong>: The packet traverses the kernel network stack <strong>twice</strong> (once for each namespace). This increases the instruction cache (L1i) pressure as the <code>ip_rcv</code> and <code>netif_receive_skb</code> functions are called twice for every outbound segment.</li>\n<li><strong>Hardware Offloading</strong>: Because the <code>veth</code> is virtual, features like TSO (TCP Segmentation Offload) and Checksum Offloading are handled in software. This consumes more CPU cycles than a physical NIC would.</li>\n</ol>\n<h3 id=\"42-latency-and-pipeline-stalls\">4.2 Latency and Pipeline Stalls</h3>\n<ul>\n<li><strong>Syscall Overhead</strong>: Spawning <code>ip</code> and <code>iptables</code> via <code>system()</code> or <code>fork/exec</code> is expensive (~10-50ms). This is a &quot;Cold Path&quot; operation that occurs during container boot.</li>\n<li><strong>Memory Access</strong>: Netfilter (iptables) rules are stored in a contiguous linear array. For every packet, the CPU must fetch these rules. If the rule set is large, this causes L2/L3 cache misses.</li>\n</ul>\n<hr>\n<h2 id=\"5-interface-contracts\">5. INTERFACE CONTRACTS</h2>\n<h3 id=\"51-int-setup_host_networkpid_t-container_pid-const-char-outbound_iface\">5.1 <code>int setup_host_network(pid_t container_pid, const char* outbound_iface)</code></h3>\n<p><strong>Logic:</strong></p>\n<ol>\n<li><code>ip link add name ctr0 type bridge</code>.</li>\n<li><code>ip addr add 172.20.0.1/24 dev ctr0</code>.</li>\n<li><code>ip link add veth_h0 type veth peer name veth_c0</code>.</li>\n<li><code>ip link set veth_h0 master ctr0</code>.</li>\n<li><code>ip link set veth_c0 netns &lt;container_pid&gt;</code>.</li>\n<li><code>iptables -t nat -A POSTROUTING -s 172.20.0.0/24 -o &lt;outbound_iface&gt; -j MASQUERADE</code>.</li>\n</ol>\n<h3 id=\"52-int-setup_container_networkvoid\">5.2 <code>int setup_container_network(void)</code></h3>\n<p><strong>Logic (Executed inside child):</strong></p>\n<ol>\n<li><code>ip link set lo up</code>.</li>\n<li><code>ip addr add 172.20.0.2/24 dev veth_c0</code>.</li>\n<li><code>ip link set veth_c0 up</code>.</li>\n<li><code>ip route add default via 172.20.0.1</code>.</li>\n</ol>\n<h3 id=\"53-int-write_resolv_confconst-char-rootfs\">5.3 <code>int write_resolv_conf(const char* rootfs)</code></h3>\n<p><strong>Logic:</strong> Writes <code>nameserver 8.8.8.8</code> to <code>&lt;rootfs&gt;/etc/resolv.conf</code>.</p>\n<ul>\n<li><strong>Constraint</strong>: Must be done before <code>pivot_root</code>.</li>\n</ul>\n<hr>\n<h2 id=\"6-algorithm-specification-the-sync-pipe-protocol\">6. ALGORITHM SPECIFICATION: THE SYNC PIPE PROTOCOL</h2>\n<p>The &quot;Two-Phase Dance&quot; is required because <code>veth_c0</code> cannot be moved into a namespace that doesn&#39;t exist yet, and the child cannot configure an interface that hasn&#39;t been moved in yet.</p>\n<ol>\n<li><strong>Parent</strong>: <code>pipe(sync_pipe)</code>.</li>\n<li><strong>Parent</strong>: <code>clone(..., CLONE_NEWNET, &amp;cfg)</code>. <code>cfg.sync_pipe_read</code> is passed to the child.</li>\n<li><strong>Child (<code>container_init</code>)</strong>: Immediately calls <code>read(cfg.sync_pipe_read, &amp;buf, 1)</code>. This <strong>blocks</strong> the child.</li>\n<li><strong>Parent</strong>: Receives <code>child_pid</code>. </li>\n<li><strong>Parent</strong>: Performs <code>setup_host_network</code>. This creates the <code>veth</code> pair and &quot;pushes&quot; <code>veth_c0</code> into the child&#39;s namespace using the <code>child_pid</code>.</li>\n<li><strong>Parent</strong>: <code>write(sync_pipe[1], &quot;1&quot;, 1)</code>.</li>\n<li><strong>Child</strong>: The <code>read()</code> call unblocks. The child proceeds to <code>setup_container_network</code>.</li>\n<li><strong>Child</strong>: <code>veth_c0</code> is now visible inside the child&#39;s <code>ip link</code>.</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Ftdd-diag-15.svg\" alt=\"Container Networking Topology ‚Äî veth Pair + Bridge + NAT Full Map\">\n (The Network Sync Sequence)</p>\n<hr>\n<h2 id=\"7-error-handling-matrix\">7. ERROR HANDLING MATRIX</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Cause</th>\n<th align=\"left\">Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EADDRNOTAVAIL</code></td>\n<td align=\"left\">Child (Socket bind)</td>\n<td align=\"left\"><code>lo</code> interface is DOWN.</td>\n<td align=\"left\">Ensure <code>ip link set lo up</code> is called first.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOENT</code> (veth_c0)</td>\n<td align=\"left\">Child (<code>ip addr</code>)</td>\n<td align=\"left\">Host failed to move <code>veth_c0</code> in.</td>\n<td align=\"left\">Parent must check <code>ip link set netns</code> return code.</td>\n</tr>\n<tr>\n<td align=\"left\">No Internet</td>\n<td align=\"left\">Child (<code>ping 8.8.8.8</code>)</td>\n<td align=\"left\"><code>ip_forward</code> is 0 on host.</td>\n<td align=\"left\">Parent must <code>sysctl -w net.ipv4.ip_forward=1</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EEXIST</code></td>\n<td align=\"left\">Parent (<code>ip link add</code>)</td>\n<td align=\"left\">Bridge or veth from previous run exists.</td>\n<td align=\"left\"><code>cleanup_network</code> must be robust; use <code>ip link del</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">DNS Timeout</td>\n<td align=\"left\">Child (<code>nslookup</code>)</td>\n<td align=\"left\"><code>/etc/resolv.conf</code> missing.</td>\n<td align=\"left\">Verify <code>write_resolv_conf</code> path relative to <code>rootfs</code>.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS</h2>\n<h3 id=\"phase-1-coordination-scaffolding-1-hour\">Phase 1: Coordination Scaffolding (1 hour)</h3>\n<ol>\n<li>Create the <code>pipe(sync_pipe)</code> in <code>main()</code>.</li>\n<li>Add the blocking <code>read()</code> to the top of <code>container_init</code>.</li>\n<li>Add the <code>write()</code> to <code>main()</code> after <code>clone()</code>.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Run the container. The child should wait indefinitely until you manually press enter or the parent writes.</li>\n</ul>\n<h3 id=\"phase-2-host-infrastructure-2-hours\">Phase 2: Host Infrastructure (2 hours)</h3>\n<ol>\n<li>Implement <code>setup_bridge</code> and <code>create_veth_pair</code>.</li>\n<li>Implement the Netlink-equivalent <code>ip link set veth_c0 netns &lt;pid&gt;</code>.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Run container. From a second terminal on the host, run <code>ip netns identify &lt;pid&gt;</code>. Run <code>ip link</code> on host; <code>veth_c0</code> should be gone.</li>\n</ul>\n<h3 id=\"phase-3-nat-and-forwarding-1-hour\">Phase 3: NAT and Forwarding (1 hour)</h3>\n<ol>\n<li>Implement <code>enable_ip_forwarding</code>.</li>\n<li>Implement <code>setup_nat</code> using <code>iptables</code>.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: From the host, verify <code>iptables -t nat -L</code> shows the <code>MASQUERADE</code> rule.</li>\n</ul>\n<h3 id=\"phase-4-container-configuration-1-hour\">Phase 4: Container Configuration (1 hour)</h3>\n<ol>\n<li>Implement <code>setup_container_network</code> inside <code>container_init</code>.</li>\n<li>Bring up <code>lo</code> and <code>veth_c0</code>.</li>\n</ol>\n<ul>\n<li><strong>Checkpoint</strong>: Inside the container, run <code>ip addr</code>. You should see <code>172.20.0.2</code>. You should be able to <code>ping 172.20.0.1</code> (the host gateway).</li>\n</ul>\n<hr>\n<h2 id=\"9-test-specification\">9. TEST SPECIFICATION</h2>\n<h3 id=\"91-test-localhost-binding\">9.1 Test: Localhost Binding</h3>\n<ul>\n<li><strong>Action</strong>: Inside container, run <code>nc -l -p 8080 -s 127.0.0.1</code>.</li>\n<li><strong>Requirement</strong>: Must succeed. If <code>lo</code> is down, this fails with <code>Cannot assign requested address</code>.</li>\n</ul>\n<h3 id=\"92-test-egress-connectivity\">9.2 Test: Egress Connectivity</h3>\n<ul>\n<li><strong>Action</strong>: Inside container, run <code>ping -c 1 8.8.8.8</code>.</li>\n<li><strong>Requirement</strong>: 0% packet loss. Confirms veth -&gt; bridge -&gt; host eth0 -&gt; NAT pipeline.</li>\n</ul>\n<h3 id=\"93-test-port-isolation\">9.3 Test: Port Isolation</h3>\n<ul>\n<li><strong>Action</strong>: Inside container, listen on port 9999.</li>\n<li><strong>Action</strong>: On host, run <code>nc -z 127.0.0.1 9999</code>.</li>\n<li><strong>Requirement</strong>: Connection must fail/timeout. The host&#39;s loopback is distinct from the container&#39;s.</li>\n</ul>\n<hr>\n<h2 id=\"10-performance-targets\">10. PERFORMANCE TARGETS</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Cross-Namespace RTT</td>\n<td align=\"left\">&lt; 50 Œºs</td>\n<td align=\"left\"><code>ping 172.20.0.1</code> from container.</td>\n</tr>\n<tr>\n<td align=\"left\">NAT Throughput Hit</td>\n<td align=\"left\">&lt; 10%</td>\n<td align=\"left\"><code>iperf3</code> comparison (Host vs Container).</td>\n</tr>\n<tr>\n<td align=\"left\">Netlink Assignment</td>\n<td align=\"left\">&lt; 5 ms</td>\n<td align=\"left\">Time to move interface into namespace.</td>\n</tr>\n<tr>\n<td align=\"left\">Setup Duration</td>\n<td align=\"left\">&lt; 200 ms</td>\n<td align=\"left\">Total time for <code>setup_host_network</code>.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-concurrency-amp-cleanup-specification\">11. CONCURRENCY &amp; CLEANUP SPECIFICATION</h2>\n<h3 id=\"111-atexit-cleanup\">11.1 atexit() Cleanup</h3>\n<p>Network resources (<code>veth</code>, <code>bridge</code>, <code>iptables</code> rules) persist in the kernel even if the userspace process dies. </p>\n<ul>\n<li><strong>MANDATORY</strong>: Register a cleanup function using <code>atexit()</code> in the parent.</li>\n<li><strong>Logic</strong>: <ol>\n<li><code>iptables -t nat -D POSTROUTING ...</code></li>\n<li><code>ip link del ctr0</code></li>\n<li><code>ip link del veth_h0</code> (deleting the host end automatically destroys the peer in the container namespace).</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"112-syscall-list-reference\">11.2 Syscall List (Reference)</h3>\n<p>The implementation will rely on these primary syscalls:</p>\n<ul>\n<li><code>pipe(2)</code> / <code>read(2)</code> / <code>write(2)</code>: Synchronization.</li>\n<li><code>system(3)</code> or <code>execve(2)</code>: Invoking <code>ip</code> and <code>iptables</code> utilities.</li>\n<li><code>clone(2)</code>: With <code>CLONE_NEWNET</code>.</li>\n</ul>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m4 -->\n<h1 id=\"technical-design-specification-cgroups-resource-limits-container-basic-m4\">TECHNICAL DESIGN SPECIFICATION: Cgroups Resource Limits (container-basic-m4)</h1>\n<h2 id=\"1-module-charter\">1. MODULE CHARTER</h2>\n<p>This module implements the resource accounting and enforcement layer of the container runtime using Linux Control Groups (cgroups). While namespaces provide visibility isolation, cgroups ensure that a containerized process cannot exhaust host physical resources, preventing &quot;noisy neighbor&quot; effects and Denial-of-Service (DoS) attacks like fork bombs.</p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Automatic detection of the host cgroup version (v1 vs. v2 unified hierarchy).</li>\n<li>Abstraction of cgroup filesystem operations (<code>mkdir</code>, <code>write</code>, <code>read</code>, <code>rmdir</code>) via robust helper functions.</li>\n<li>Implementation of the <strong>Cgroup v2 Subtree Control</strong> delegation pattern to enable memory, cpu, and pids controllers for child groups.</li>\n<li>Enforcement of <strong>Memory Limits</strong>: Hard caps on Resident Set Size (RSS) and total disablement of swap to ensure predictable OOM behavior.</li>\n<li>Enforcement of <strong>CPU Bandwidth</strong>: Configuration of the CFS (Completely Fair Scheduler) quota and period to throttle CPU usage.</li>\n<li>Enforcement of <strong>Process Limits</strong>: Capping the total number of tasks to prevent PID exhaustion.</li>\n<li>Integration with the Milestone 3 synchronization pipe to apply limits in the critical window between <code>clone()</code> and <code>exec()</code>.</li>\n</ul>\n<p><strong>Non-Scope:</strong></p>\n<ul>\n<li>User namespace integration (handled in Milestone 5).</li>\n<li>I/O weight/bandwidth limits (blkio).</li>\n<li>Network priority cgroups (net_cls).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>A process must be assigned to the cgroup (<code>cgroup.procs</code>) <em>before</em> the synchronization pipe unblocks the child for <code>exec()</code>.</li>\n<li>The <code>memory.swap.max</code> (v2) or <code>memory.memsw.limit_in_bytes</code> (v1) must be set to the same value as the memory limit (or 0) to prevent swap evasion.</li>\n<li>Cgroup cleanup (<code>rmdir</code>) must only occur after <code>waitpid()</code> confirms all processes in the namespace have terminated.</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. FILE STRUCTURE</h2>\n<p>The implementation follows a modular structure to handle the divergence between v1 and v2 APIs.</p>\n<ol>\n<li><code>src/cgroup.h</code>: Type definitions and public API signatures.</li>\n<li><code>src/cg_utils.c</code>: Low-level filesystem wrappers (open/write/read) for <code>/sys/fs/cgroup</code>.</li>\n<li><code>src/cg_v2.c</code>: Implementation of the Unified Hierarchy logic.</li>\n<li><code>src/cg_v1.c</code>: Fallback implementation for Legacy Hierarchies.</li>\n<li><code>src/main.c</code>: Updated to call <code>cgroup_setup</code> before signaling the child.</li>\n<li><code>tests/stress_mem.c</code>: Test binary to trigger OOM.</li>\n<li><code>tests/stress_cpu.c</code>: Test binary to verify throttling.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. COMPLETE DATA MODEL</h2>\n<h3 id=\"31-cgroupconfig-struct\">3.1 CgroupConfig Struct</h3>\n<p>This structure defines the resource envelope for the container.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>memory_limit_bytes</code></td>\n<td align=\"left\"><code>int64_t</code></td>\n<td align=\"left\">Hard limit for RAM. -1 for unlimited.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>cpu_quota_us</code></td>\n<td align=\"left\"><code>int64_t</code></td>\n<td align=\"left\">CPU time allowed (Œºs) per period.</td>\n</tr>\n<tr>\n<td align=\"left\">0x10</td>\n<td align=\"left\"><code>cpu_period_us</code></td>\n<td align=\"left\"><code>int64_t</code></td>\n<td align=\"left\">The CFS period length (Œºs), usually 100,000.</td>\n</tr>\n<tr>\n<td align=\"left\">0x18</td>\n<td align=\"left\"><code>pids_max</code></td>\n<td align=\"left\"><code>int32_t</code></td>\n<td align=\"left\">Max processes in the cgroup. -1 for unlimited.</td>\n</tr>\n<tr>\n<td align=\"left\">0x1C</td>\n<td align=\"left\">(padding)</td>\n<td align=\"left\"><code>uint8_t[4]</code></td>\n<td align=\"left\">Padding for 8-byte alignment.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> 32 bytes.</p>\n<h3 id=\"32-internal-cgroup-state\">3.2 Internal Cgroup State</h3>\n<p>The runtime maintains internal state for cleanup purposes.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>cgroup_version</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">1 or 2, detected at runtime.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\"><code>char[256]</code></td>\n<td align=\"left\">Unique identifier for the cgroup directory.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>root_path</code></td>\n<td align=\"left\"><code>char[512]</code></td>\n<td align=\"left\">Base mount point (e.g., <code>/sys/fs/cgroup</code>).</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-hardware-soul-physical-constraints\">4. HARDWARE SOUL: PHYSICAL CONSTRAINTS</h2>\n<h3 id=\"41-memory-charging-and-page-faults\">4.1 Memory Charging and Page Faults</h3>\n<p>Memory limits are enforced during the <strong>Page Fault</strong> hardware exception path.</p>\n<ul>\n<li><strong>Tension</strong>: Software allocates via <code>malloc()</code> (virtual), but the hardware MMU only cares about physical pages.</li>\n<li><strong>Physical Impact</strong>: When the process touches a page, the kernel‚Äôs <code>do_page_fault</code> handler is invoked. Before the kernel assigns a physical frame, it calls <code>mem_cgroup_charge</code>. </li>\n<li><strong>Latency</strong>: This adds approximately <strong>50-200 ns</strong> to the page fault. If <code>memory.max</code> is reached, the CPU enters a direct reclaim path, which can stall the process for <strong>milliseconds</strong> while the kernel searches for pages to evict to disk.</li>\n</ul>\n<h3 id=\"42-cfs-scheduler-and-pipeline-stalls\">4.2 CFS Scheduler and Pipeline Stalls</h3>\n<p>CPU limits are enforced via the <strong>CFS Bandwidth Controller</strong>.</p>\n<ul>\n<li><strong>The Mechanism</strong>: The kernel maintains a <code>runtime_remaining</code> counter for the cgroup. Every time the hardware timer interrupt fires, the scheduler decrements this counter based on actual CPU cycles consumed by the container&#39;s processes.</li>\n<li><strong>Throttling</strong>: If the counter hits zero, the kernel removes the process from the CPU&#39;s run-queue. It remains in a &quot;wait&quot; state until the next <code>cpu_period_us</code> starts.</li>\n<li><strong>Cache Locality</strong>: Throttling causes severe pipeline flushes and L1/L2 cache cold-starts. When a throttled process is finally resumed, its data is likely evicted from cache, leading to a &quot;sawtooth&quot; performance profile.</li>\n</ul>\n<h3 id=\"43-atomic-pid-counting\">4.3 Atomic PID Counting</h3>\n<p>The <code>pids.max</code> check occurs in the <code>copy_process()</code> kernel path during <code>fork()</code> or <code>clone()</code>.</p>\n<ul>\n<li><strong>Constraint</strong>: It is a single atomic integer increment/comparison.</li>\n<li><strong>Hardware Performance</strong>: Cost is <strong>&lt; 20 ns</strong>. It is the most lightweight resource check in the kernel.</li>\n</ul>\n<hr>\n<h2 id=\"5-interface-contracts\">5. INTERFACE CONTRACTS</h2>\n<h3 id=\"51-int-detect_cgroup_versionvoid\">5.1 <code>int detect_cgroup_version(void)</code></h3>\n<ul>\n<li><strong>Logic</strong>: Performs <code>stat()</code> on <code>/sys/fs/cgroup/cgroup.controllers</code>. </li>\n<li><strong>Return</strong>: <code>2</code> if file exists (v2), <code>1</code> if <code>/sys/fs/cgroup/memory</code> exists (v1), <code>-1</code> on total failure.</li>\n</ul>\n<h3 id=\"52-int-cgroup_setupconst-char-name-pid_t-pid-cgroupconfig-cfg\">5.2 <code>int cgroup_setup(const char* name, pid_t pid, CgroupConfig* cfg)</code></h3>\n<ul>\n<li><strong>Input</strong>: The container&#39;s host-visible PID and the desired limits.</li>\n<li><strong>Logic</strong>:<ol>\n<li>Detect version.</li>\n<li>Create directory <code>/sys/fs/cgroup/&lt;name&gt;</code>.</li>\n<li>If v2: Enable controllers in parent <code>cgroup.subtree_control</code>.</li>\n<li>Write <code>pid</code> to <code>cgroup.procs</code>.</li>\n<li>Write limits to corresponding version-specific files.</li>\n</ol>\n</li>\n<li><strong>Errors</strong>: Returns <code>EINVAL</code> if controllers cannot be enabled; <code>EPERM</code> if not root.</li>\n</ul>\n<h3 id=\"53-int-cgroup_cleanupconst-char-name\">5.3 <code>int cgroup_cleanup(const char* name)</code></h3>\n<ul>\n<li><strong>Logic</strong>: Recursively calls <code>rmdir()</code> on the created paths.</li>\n<li><strong>Invariant</strong>: Will return <code>EBUSY</code> if the process has not been reaped by <code>waitpid()</code> first.</li>\n</ul>\n<hr>\n<h2 id=\"6-algorithm-specification\">6. ALGORITHM SPECIFICATION</h2>\n<h3 id=\"61-subtree-control-enablement-cgroups-v2\">6.1 Subtree Control Enablement (Cgroups v2)</h3>\n<p>In v2, child groups do not inherit controllers automatically. The parent must delegate.</p>\n<ol>\n<li>Open <code>/sys/fs/cgroup/cgroup.subtree_control</code>.</li>\n<li>Write <code>&quot;+memory +cpu +pids&quot;</code>.</li>\n<li>This must be done <strong>before</strong> <code>mkdir</code> of the child cgroup to ensure the child group&#39;s files (e.g., <code>memory.max</code>) are generated by the kernel.</li>\n</ol>\n<h3 id=\"62-the-procs-assignment-window\">6.2 The Procs Assignment Window</h3>\n<p>The assignment to <code>cgroup.procs</code> is the most time-sensitive operation.</p>\n<ol>\n<li>Host calls <code>clone()</code>.</li>\n<li>Host receives <code>container_pid</code>.</li>\n<li>Host writes <code>container_pid</code> to <code>/sys/fs/cgroup/mycontainer/cgroup.procs</code>.</li>\n<li><strong>ONLY THEN</strong> Host writes to <code>sync_pipe[1]</code>.</li>\n<li>Child reads <code>sync_pipe[0]</code>, proceeds to <code>execvp()</code>.\n<em>Result</em>: The first instruction of the target binary executes with limits already applied.</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Ftdd-diag-21.svg\" alt=\"cgroups v2 Unified Hierarchy ‚Äî Filesystem Layout\">\n (Cgroup Setup Synchronization)</p>\n<hr>\n<h2 id=\"7-error-handling-matrix\">7. ERROR HANDLING MATRIX</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error Condition</th>\n<th align=\"left\">Detection</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EINVAL</code> on <code>memory.max</code></td>\n<td align=\"left\"><code>cg_write_long</code></td>\n<td align=\"left\">Check <code>cgroup.subtree_control</code> in parent.</td>\n<td align=\"left\">Yes (&quot;Invalid argument&quot;)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EBUSY</code> on <code>rmdir</code></td>\n<td align=\"left\"><code>cgroup_cleanup</code></td>\n<td align=\"left\"><code>waitpid()</code> loop in <code>main</code> must complete first.</td>\n<td align=\"left\">Yes (&quot;Device or resource busy&quot;)</td>\n</tr>\n<tr>\n<td align=\"left\">OOM Killer triggered</td>\n<td align=\"left\">Kernel (Host)</td>\n<td align=\"left\">The child receives <code>SIGKILL</code>.</td>\n<td align=\"left\">Yes (<code>Killed</code> in terminal)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EPERM</code> on write</td>\n<td align=\"left\"><code>open()</code></td>\n<td align=\"left\">Verify <code>sudo</code> or cgroup delegation.</td>\n<td align=\"left\">Yes (&quot;Permission denied&quot;)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOENT</code> on <code>cpu.max</code></td>\n<td align=\"left\"><code>open()</code></td>\n<td align=\"left\">Controller <code>cpu</code> not enabled/available.</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS</h2>\n<h3 id=\"phase-1-detection-amp-helpers-1-hour\">Phase 1: Detection &amp; Helpers (1 hour)</h3>\n<ul>\n<li>Implement <code>detect_cgroup_version()</code>.</li>\n<li>Implement <code>cg_write_str</code> and <code>cg_write_long</code> using <code>snprintf</code> and <code>write()</code>.</li>\n<li><strong>Checkpoint</strong>: Run a standalone test that creates a folder in <code>/sys/fs/cgroup/</code> and writes the current shell&#39;s PID to <code>cgroup.procs</code>. Verify with <code>cat /proc/self/cgroup</code>.</li>\n</ul>\n<h3 id=\"phase-2-memory-amp-pid-limits-15-hours\">Phase 2: Memory &amp; PID Limits (1.5 hours)</h3>\n<ul>\n<li>Implement <code>memory.max</code> (v2) / <code>memory.limit_in_bytes</code> (v1).</li>\n<li><strong>MANDATORY</strong>: Implement <code>memory.swap.max = 0</code> to prevent bypass.</li>\n<li>Implement <code>pids.max</code>.</li>\n<li><strong>Checkpoint</strong>: Launch container with <code>memory_limit_bytes = 50MB</code>. Run a C program that <code>mallocs</code> 100MB and <code>memsets</code> it. Container must be killed by OOM killer.</li>\n</ul>\n<h3 id=\"phase-3-cpu-bandwidth-15-hours\">Phase 3: CPU Bandwidth (1.5 hours)</h3>\n<ul>\n<li>Implement <code>cpu.max</code> parsing for v2 (<code>quota period</code> space-separated).</li>\n<li>Implement v1 fallback (<code>cpu.cfs_quota_us</code> and <code>cpu.cfs_period_us</code>).</li>\n<li><strong>Checkpoint</strong>: Launch container with <code>quota=50000</code>, <code>period=100000</code> (50% CPU). Run a tight <code>while(1)</code> loop. Use <code>top</code> on host; process must stay at ~50.0% CPU.</li>\n</ul>\n<h3 id=\"phase-4-observability-amp-cleanup-1-hour\">Phase 4: Observability &amp; Cleanup (1 hour)</h3>\n<ul>\n<li>Implement <code>cgroup_report_v2</code> to read <code>memory.current</code> and <code>cpu.stat</code>.</li>\n<li>Implement <code>rmdir</code> cleanup.</li>\n<li><strong>Checkpoint</strong>: Ensure cgroup directory is removed from <code>/sys/fs/cgroup/</code> after container exits.</li>\n</ul>\n<hr>\n<h2 id=\"9-test-specification\">9. TEST SPECIFICATION</h2>\n<h3 id=\"91-test-fork-bomb-containment\">9.1 Test: Fork Bomb Containment</h3>\n<ul>\n<li><strong>Config</strong>: <code>pids_max = 20</code>.</li>\n<li><strong>Action</strong>: Run <code>:(){ :|:&amp; };:</code> inside container.</li>\n<li><strong>Requirement</strong>: Container survives. Shell reports <code>fork: Resource temporarily unavailable</code>. Host remains stable.</li>\n</ul>\n<h3 id=\"92-test-memory-hard-limit\">9.2 Test: Memory Hard Limit</h3>\n<ul>\n<li><strong>Config</strong>: <code>memory_limit_bytes = 64MB</code>, <code>swap = 0</code>.</li>\n<li><strong>Action</strong>: <code>dd if=/dev/zero of=/dev/shm/test bs=1M count=128</code>.</li>\n<li><strong>Requirement</strong>: Process killed. <code>dmesg</code> confirms <code>oom-kill:constraint=CONSTRAINT_MEMCG</code>.</li>\n</ul>\n<h3 id=\"93-test-cpu-throttling\">9.3 Test: CPU Throttling</h3>\n<ul>\n<li><strong>Config</strong>: <code>quota = 10000</code>, <code>period = 100000</code> (10% CPU).</li>\n<li><strong>Action</strong>: Run <code>sha256sum /dev/zero</code>.</li>\n<li><strong>Requirement</strong>: Host <code>top</code> shows process restricted to 10% utilization. <code>cpu.stat</code> shows <code>nr_throttled &gt; 0</code>.</li>\n</ul>\n<hr>\n<h2 id=\"10-performance-targets\">10. PERFORMANCE TARGETS</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Cgroup Setup Latency</td>\n<td align=\"left\">&lt; 50 ms</td>\n<td align=\"left\"><code>gettimeofday</code> from host start to pipe signal.</td>\n</tr>\n<tr>\n<td align=\"left\">Page Fault Overhead</td>\n<td align=\"left\">&lt; 300 ns</td>\n<td align=\"left\"><code>lat_pagefault</code> from lmbench inside/outside.</td>\n</tr>\n<tr>\n<td align=\"left\">Memory usage read</td>\n<td align=\"left\">&lt; 20 Œºs</td>\n<td align=\"left\"><code>time cat /sys/fs/cgroup/.../memory.current</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Task migration</td>\n<td align=\"left\">&lt; 100 Œºs</td>\n<td align=\"left\">Time to write PID to <code>cgroup.procs</code>.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-concurrency-specification\">11. CONCURRENCY SPECIFICATION</h2>\n<p><strong>Single-Writer Model:</strong></p>\n<ul>\n<li>Only the host process (parent) writes to cgroup control files.</li>\n<li>The child process may <em>read</em> from its own <code>/sys/fs/cgroup/</code> entry for self-monitoring but must never attempt to write (this would require <code>CAP_SYS_ADMIN</code> in the host namespace).</li>\n</ul>\n<p><strong>Thread Safety:</strong></p>\n<ul>\n<li>If the monitor (report) function runs in a separate host thread, it must use a read-only file descriptor to <code>cpu.stat</code> and <code>memory.current</code> to avoid blocking the main execution path.</li>\n</ul>\n<p><strong>Zombie Reaping Order:</strong></p>\n<ol>\n<li>Container Process exits.</li>\n<li>Host <code>waitpid()</code> returns.</li>\n<li>Host calls <code>cgroup_cleanup()</code>.\n<em>If 3 occurs before 2, <code>rmdir</code> will fail with <code>EBUSY</code> because the zombie process is still a member of the cgroup.</em></li>\n</ol>\n<hr>\n<h2 id=\"12-wire-format-cgroup-v2-cpumax\">12. WIRE FORMAT: CGROUP V2 CPU.MAX</h2>\n<p>The <code>cpu.max</code> file uses a specific space-separated string format.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example construction for 50% CPU limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> quota </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 50000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">long</span><span style=\"color:#E1E4E8\"> period </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">snprintf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf), </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%ld</span><span style=\"color:#79B8FF\"> %ld</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, quota, period);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Written as: \"50000 100000\"</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m5 -->\n<h1 id=\"technical-design-specification-user-namespace-and-rootless-containers-container-basic-m5\">TECHNICAL DESIGN SPECIFICATION: User Namespace and Rootless Containers (container-basic-m5)</h1>\n<h2 id=\"1-module-charter\">1. MODULE CHARTER</h2>\n<p>This module implements the final and most critical security layer: the <strong>User Namespace</strong> (<code>CLONE_NEWUSER</code>). This allows the container runtime to function without <code>sudo</code> (root privileges) by remapping the container&#39;s internal <code>root</code> user (UID 0) to an unprivileged user on the host (e.g., UID 1000). </p>\n<p><strong>Scope:</strong></p>\n<ul>\n<li>Integration of <code>CLONE_NEWUSER</code> into the atomic <code>clone(2)</code> call.</li>\n<li>Implementation of the <strong>Parent-Side ID Mapping</strong> sequence: writing to <code>/proc/&lt;pid&gt;/uid_map</code> and <code>/proc/&lt;pid&gt;/gid_map</code>.</li>\n<li>Enforcement of the kernel-mandated <code>setgroups=deny</code> write before <code>gid_map</code> for unprivileged creators.</li>\n<li>Verification of the <strong>Capability Scoping</strong> model: checking for <code>CAP_SYS_ADMIN</code> and <code>CAP_NET_ADMIN</code> inside the namespace using <code>capget(2)</code>.</li>\n<li>Implementation of <code>set_oom_score_adj</code> to allow host-side priority management.</li>\n<li>Documentation and integration of <strong>Rootless Networking</strong> constraints (handling the transition from kernel <code>veth</code> to userspace <code>slirp4netns</code>).</li>\n</ul>\n<p><strong>Invariants:</strong></p>\n<ul>\n<li>The host process must observe a zero-capability set (<code>CapEff: 0000000000000000</code>) for the child via <code>/proc/&lt;pid&gt;/status</code>.</li>\n<li>The child process must observe its UID as 0 via <code>getuid()</code>.</li>\n<li>The synchronization pipe must block the child until the parent has completed the mapping write; otherwise, the child enters an &quot;unmapped&quot; state (UID 65534).</li>\n</ul>\n<hr>\n<h2 id=\"2-file-structure\">2. FILE STRUCTURE</h2>\n<p>The implementation follows a sequential enhancement of the existing runtime. </p>\n<ol>\n<li><code>src/common.h</code>: Add capability-related headers and bitmasks.</li>\n<li><code>src/userns.c</code>: <strong>(NEW)</strong> Core logic for UID/GID mapping and capability verification.</li>\n<li><code>src/container.h</code>: Update <code>ContainerConfig</code> with <code>host_uid</code> and <code>host_gid</code>.</li>\n<li><code>src/init.c</code>: Update <code>container_init</code> to verify identity and capabilities after unblocking.</li>\n<li><code>src/main.c</code>: The master orchestration: capture real UIDs, call <code>clone()</code> without root, and perform mapping.</li>\n</ol>\n<hr>\n<h2 id=\"3-complete-data-model\">3. COMPLETE DATA MODEL</h2>\n<h3 id=\"31-containerconfig-struct-extended\">3.1 ContainerConfig Struct (Extended)</h3>\n<p>The config struct is expanded to pass the host&#39;s real identity into the namespace for mapping.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>argv</code></td>\n<td align=\"left\"><code>char**</code></td>\n<td align=\"left\">Command to exec.</td>\n</tr>\n<tr>\n<td align=\"left\">0x08</td>\n<td align=\"left\"><code>hostname</code></td>\n<td align=\"left\"><code>char[64]</code></td>\n<td align=\"left\">UTS identity.</td>\n</tr>\n<tr>\n<td align=\"left\">0x48</td>\n<td align=\"left\"><code>rootfs</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\">FS path.</td>\n</tr>\n<tr>\n<td align=\"left\">0x50</td>\n<td align=\"left\"><code>outbound_if</code></td>\n<td align=\"left\"><code>char*</code></td>\n<td align=\"left\">Network interface.</td>\n</tr>\n<tr>\n<td align=\"left\">0x58</td>\n<td align=\"left\"><code>sync_pipe</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Read end of pipe.</td>\n</tr>\n<tr>\n<td align=\"left\">0x5C</td>\n<td align=\"left\"><code>host_uid</code></td>\n<td align=\"left\"><code>uid_t</code></td>\n<td align=\"left\"><strong>(NEW)</strong> Real UID of the caller (usually 1000).</td>\n</tr>\n<tr>\n<td align=\"left\">0x60</td>\n<td align=\"left\"><code>host_gid</code></td>\n<td align=\"left\"><code>gid_t</code></td>\n<td align=\"left\"><strong>(NEW)</strong> Real GID of the caller.</td>\n</tr>\n<tr>\n<td align=\"left\">0x68</td>\n<td align=\"left\"><code>stack_base</code></td>\n<td align=\"left\"><code>void*</code></td>\n<td align=\"left\">Child stack.</td>\n</tr>\n<tr>\n<td align=\"left\">0x70</td>\n<td align=\"left\"><code>stack_size</code></td>\n<td align=\"left\"><code>size_t</code></td>\n<td align=\"left\">Stack size.</td>\n</tr>\n</tbody></table>\n<p><strong>Total Size:</strong> 120 bytes (aligned to 8-byte boundary).</p>\n<h3 id=\"32-capability-struct-layout-level-3-hardwarekernel\">3.2 Capability Struct Layout (Level 3 - Hardware/Kernel)</h3>\n<p>We interface with the kernel&#39;s capability bitmask directly via <code>capget</code>.</p>\n<p><strong>struct __user_cap_header_struct:</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Offset</th>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0x00</td>\n<td align=\"left\"><code>version</code></td>\n<td align=\"left\"><code>uint32_t</code></td>\n<td align=\"left\"><code>_LINUX_CAPABILITY_VERSION_3</code> (0x20080522).</td>\n</tr>\n<tr>\n<td align=\"left\">0x04</td>\n<td align=\"left\"><code>pid</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Process ID to query (0 for current).</td>\n</tr>\n</tbody></table>\n<p><strong>struct __user_cap_data_struct (effective[0]):</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Bit</th>\n<th align=\"left\">Name</th>\n<th align=\"left\">Hex Mask</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">12</td>\n<td align=\"left\"><code>CAP_NET_ADMIN</code></td>\n<td align=\"left\"><code>0x00001000</code></td>\n<td align=\"left\">Network config rights.</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\"><code>CAP_SYS_ADMIN</code></td>\n<td align=\"left\"><code>0x00200000</code></td>\n<td align=\"left\">General &quot;root&quot; rights (mount, etc.).</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\"><code>CAP_MKNOD</code></td>\n<td align=\"left\"><code>0x08000000</code></td>\n<td align=\"left\">Create special device files.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"4-hardware-soul-physical-constraints\">4. HARDWARE SOUL: PHYSICAL CONSTRAINTS</h2>\n<h3 id=\"41-uid-translation-overhead\">4.1 UID Translation Overhead</h3>\n<p>Every time the container calls <code>stat(2)</code> or <code>getuid(2)</code>, the kernel performs a translation.</p>\n<ul>\n<li><strong>Physical Tension</strong>: The kernel stores UIDs as raw 32-bit integers in the <code>inode</code> or <code>task_struct</code>.</li>\n<li><strong>Complexity</strong>: The translation is a <strong>linear scan</strong> of the <code>uid_gid_map_entry</code> array in the <code>user_namespace</code> struct.</li>\n<li><strong>Latency</strong>: For our <code>0 1000 1</code> mapping (1 entry), the overhead is <strong>~3-10 ns</strong>. On hardware with a large L1 cache, this stays within the pipeline. If a namespace had 340 entries (the max), cache misses would start impacting VFS heavy-workloads.</li>\n</ul>\n<h3 id=\"42-cache-line-alignment\">4.2 Cache Line Alignment</h3>\n<p><code>ContainerConfig</code> is now 120 bytes. </p>\n<ul>\n<li><strong>MANDATORY</strong>: The struct spans <strong>two 64-byte cache lines</strong>. </li>\n<li><strong>Optimization</strong>: Place the <code>sync_pipe</code> and <code>host_uid</code> near the top of the struct (Line 1) to ensure the child process fetches the most critical &quot;startup&quot; variables in a single burst from L3 cache to L1.</li>\n</ul>\n<hr>\n<h2 id=\"5-interface-contracts\">5. INTERFACE CONTRACTS</h2>\n<h3 id=\"51-int-proc_writepid_t-pid-const-char-file-const-char-content\">5.1 <code>int proc_write(pid_t pid, const char* file, const char* content)</code></h3>\n<ul>\n<li><strong>Logic</strong>: <code>open(&quot;/proc/&lt;pid&gt;/&lt;file&gt;&quot;, O_WRONLY)</code>, <code>write()</code>, <code>close()</code>.</li>\n<li><strong>Constraint</strong>: Must use a <strong>single write()</strong> call. The kernel&#39;s <code>proc_set_id_map</code> handler rejects partial or multi-stage writes to these specific files.</li>\n<li><strong>Error</strong>: Returns <code>EPERM</code> if the mapping has already been written.</li>\n</ul>\n<h3 id=\"52-int-write_uid_gid_mapspid_t-pid-uid_t-host_uid-gid_t-host_gid\">5.2 <code>int write_uid_gid_maps(pid_t pid, uid_t host_uid, gid_t host_gid)</code></h3>\n<ul>\n<li><strong>Mandatory Order</strong>:<ol>\n<li>Write <code>&quot;0 &lt;host_uid&gt; 1&quot;</code> to <code>uid_map</code>.</li>\n<li>Write <code>&quot;deny&quot;</code> to <code>setgroups</code>.</li>\n<li>Write <code>&quot;0 &lt;host_gid&gt; 1&quot;</code> to <code>gid_map</code>.</li>\n</ol>\n</li>\n<li><strong>Failure</strong>: If step 2 is skipped, step 3 returns <code>EPERM</code> for unprivileged users.</li>\n</ul>\n<h3 id=\"53-void-verify_capabilitiesvoid\">5.3 <code>void verify_capabilities(void)</code></h3>\n<ul>\n<li><strong>Logic</strong>: Call <code>syscall(SYS_capget, &amp;hdr, &amp;data)</code>.</li>\n<li><strong>Verification</strong>: Ensure <code>(data[0].effective &amp; (1 &lt;&lt; CAP_SYS_ADMIN))</code> is true.</li>\n</ul>\n<hr>\n<h2 id=\"6-algorithm-specification-the-rootless-handshake\">6. ALGORITHM SPECIFICATION: THE ROOTLESS HANDSHAKE</h2>\n<ol>\n<li><strong>Main (Host)</strong>: Call <code>getuid()</code> and <code>getgid()</code> to capture the unprivileged identity.</li>\n<li><strong>Main (Host)</strong>: Call <code>clone(CLONE_NEWUSER | CLONE_NEWPID | ...)</code> without <code>sudo</code>.</li>\n<li><strong>Child (Container)</strong>: Enters <code>container_init</code>, calls <code>read(sync_pipe)</code> and <strong>blocks</strong>. Its effective UID is <code>65534</code> (nobody) and its capability set is empty.</li>\n<li><strong>Main (Host)</strong>: <ul>\n<li>Writes <code>uid_map</code> (0 inside -&gt; 1000 outside).</li>\n<li>Writes <code>setgroups=deny</code>.</li>\n<li>Writes <code>gid_map</code> (0 inside -&gt; 1000 outside).</li>\n<li><em>Note</em>: Atomic with the <code>gid_map</code> write completion, the kernel <strong>elevates</strong> the child&#39;s capability set to full effective privileges.</li>\n</ul>\n</li>\n<li><strong>Main (Host)</strong>: Attempts <code>cgroup_setup</code>. <ul>\n<li><em>Edge Case</em>: If host-root or delegation isn&#39;t present, this fails. Log warning and continue (Resource limits are best-effort in rootless).</li>\n</ul>\n</li>\n<li><strong>Main (Host)</strong>: <code>write(sync_pipe, &quot;1&quot;)</code>.</li>\n<li><strong>Child (Container)</strong>: Unblocks. <code>getuid()</code> now returns <code>0</code>. Full capabilities are active. Proceed to <code>pivot_root</code>.</li>\n</ol>\n<p><img src=\"/api/project/container-basic/architecture-doc/asset?path=diagrams%2Ftdd-diag-28.svg\" alt=\"UID/GID Mapping ‚Äî Inside vs Outside Translation Table\">\n (The Unprivileged Mapping Protocol)</p>\n<hr>\n<h2 id=\"7-error-handling-matrix\">7. ERROR HANDLING MATRIX</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Error</th>\n<th align=\"left\">Detected By</th>\n<th align=\"left\">Recovery</th>\n<th align=\"left\">User-Visible?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>EPERM</code> on <code>clone</code></td>\n<td align=\"left\"><code>main</code></td>\n<td align=\"left\"><code>sysctl -w kernel.unprivileged_userns_clone=1</code>.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EPERM</code> on <code>gid_map</code></td>\n<td align=\"left\"><code>proc_write</code></td>\n<td align=\"left\">Fix ordering (write <code>setgroups=deny</code> first).</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>UID 65534</code> in Child</td>\n<td align=\"left\"><code>container_init</code></td>\n<td align=\"left\">Host failed to write maps before signaling.</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\"><code>EACCES</code> on <code>cgroups</code></td>\n<td align=\"left\"><code>main</code></td>\n<td align=\"left\">Skip cgroups or use <code>systemd-run</code>.</td>\n<td align=\"left\">Yes (Warning)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ENOENT</code> on <code>uid_map</code></td>\n<td align=\"left\"><code>proc_write</code></td>\n<td align=\"left\">Child exited prematurely.</td>\n<td align=\"left\">No</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"8-implementation-sequence-with-checkpoints\">8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS</h2>\n<h3 id=\"phase-1-the-helper-1-hour\">Phase 1: The Helper (1 hour)</h3>\n<ul>\n<li>Implement <code>proc_write</code>. Use <code>O_WRONLY</code> and a single <code>write()</code> call.</li>\n<li>Implement <code>write_uid_gid_maps</code> with the strict <code>uid -&gt; setgroups -&gt; gid</code> sequence.</li>\n<li><strong>Checkpoint</strong>: Standalone test that forks a child, writes a mapping, and the child prints <code>getuid() == 0</code>.</li>\n</ul>\n<h3 id=\"phase-2-rootless-clone-05-hours\">Phase 2: Rootless Clone (0.5 hours)</h3>\n<ul>\n<li>Update <code>clone()</code> flags to include <code>CLONE_NEWUSER</code>.</li>\n<li>Remove the <code>geteuid() == 0</code> check from your runtime.</li>\n<li><strong>Checkpoint</strong>: Run without <code>sudo</code>. Syscall should succeed, but child will block on the sync pipe.</li>\n</ul>\n<h3 id=\"phase-3-synchronized-elevation-1-hour\">Phase 3: Synchronized Elevation (1 hour)</h3>\n<ul>\n<li>Integrate the map-writing logic into <code>main.c</code> immediately after <code>clone</code>.</li>\n<li><strong>Checkpoint</strong>: Inside the container, <code>id</code> command should report <code>uid=0(root)</code>. Host <code>ps aux</code> should report the same process as your unprivileged user.</li>\n</ul>\n<h3 id=\"phase-4-capability-verification-1-hour\">Phase 4: Capability Verification (1 hour)</h3>\n<ul>\n<li>Implement <code>verify_capabilities</code> using raw <code>syscall(SYS_capget, ...)</code>.</li>\n<li>Check bits 21 (<code>CAP_SYS_ADMIN</code>) and 12 (<code>CAP_NET_ADMIN</code>).</li>\n<li><strong>Checkpoint</strong>: Container log should print <code>CAP_SYS_ADMIN: YES</code>.</li>\n</ul>\n<h3 id=\"phase-5-filesystem-amp-network-integration-1-hour\">Phase 5: Filesystem &amp; Network Integration (1 hour)</h3>\n<ul>\n<li>Run the full suite (mount, network, pivot).</li>\n<li><strong>Note</strong>: <code>veth</code> creation will still fail without <code>sudo</code>.</li>\n<li><strong>Checkpoint</strong>: Container should successfully <code>pivot_root</code> (proving <code>CAP_SYS_ADMIN</code> in userns) but fail network setup (proving lack of global <code>CAP_NET_ADMIN</code>).</li>\n</ul>\n<hr>\n<h2 id=\"9-test-specification\">9. TEST SPECIFICATION</h2>\n<h3 id=\"91-test-uid-mapping-verification\">9.1 Test: UID Mapping Verification</h3>\n<ul>\n<li><strong>Inside</strong>: <code>whoami</code> -&gt; <code>root</code>.</li>\n<li><strong>Outside</strong>: <code>ps -p &lt;pid&gt; -o user</code> -&gt; <code>&lt;your_username&gt;</code>.</li>\n<li><strong>Requirement</strong>: Mapping <code>0 -&gt; 1000</code> is verified.</li>\n</ul>\n<h3 id=\"92-test-capability-scoping-negative-test\">9.2 Test: Capability Scoping (Negative Test)</h3>\n<ul>\n<li><strong>Inside</strong>: <code>mount /dev/sda1 /mnt</code>.</li>\n<li><strong>Requirement</strong>: Must return <code>EPERM</code>. Even though the container has <code>CAP_SYS_ADMIN</code> in its userns, it does NOT have it in the initial userns required to mount physical block devices.</li>\n</ul>\n<h3 id=\"93-test-rootless-mount\">9.3 Test: Rootless Mount</h3>\n<ul>\n<li><strong>Inside</strong>: <code>mount -t tmpfs tmpfs /tmp</code>.</li>\n<li><strong>Requirement</strong>: Must succeed. The userns grants rights to its own mount namespace.</li>\n</ul>\n<hr>\n<h2 id=\"10-performance-targets\">10. PERFORMANCE TARGETS</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Operation</th>\n<th align=\"left\">Target</th>\n<th align=\"left\">Measurement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>clone(CLONE_NEWUSER)</code></td>\n<td align=\"left\">&lt; 100 Œºs</td>\n<td align=\"left\">Time to allocate <code>user_namespace</code>.</td>\n</tr>\n<tr>\n<td align=\"left\">Map Write Latency</td>\n<td align=\"left\">&lt; 30 Œºs</td>\n<td align=\"left\">Parent-side latency to elevate child.</td>\n</tr>\n<tr>\n<td align=\"left\">UID translation</td>\n<td align=\"left\">&lt; 10 ns</td>\n<td align=\"left\">Per-access overhead in VFS lookup.</td>\n</tr>\n<tr>\n<td align=\"left\">Config Struct Size</td>\n<td align=\"left\">120 Bytes</td>\n<td align=\"left\"><code>sizeof(ContainerConfig)</code>.</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"11-concurrency-specification\">11. CONCURRENCY SPECIFICATION</h2>\n<p><strong>Parent-Child Sync Invariants:</strong></p>\n<ol>\n<li><strong>No self-mapping</strong>: The child cannot write its own <code>uid_map</code>.</li>\n<li><strong>Atomic Capability Elevation</strong>: The kernel raises the child&#39;s caps the instant the map files are closed by the parent.</li>\n<li><strong>Single Writer</strong>: Exactly one process (the parent) writes to <code>/proc/&lt;pid&gt;/uid_map</code>. Any second attempt (even from a monitor thread) returns <code>EPERM</code>.</li>\n</ol>\n<hr>\n<h2 id=\"12-wire-format-procuid_map\">12. WIRE FORMAT: /proc/<pid>/uid_map</h2>\n<p>The map content must be a space-separated string.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">c</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Correct Format: \"inside_uid outside_uid count\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">char</span><span style=\"color:#FFAB70\"> buf</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">snprintf</span><span style=\"color:#E1E4E8\">(buf, </span><span style=\"color:#F97583\">sizeof</span><span style=\"color:#E1E4E8\">(buf), </span><span style=\"color:#9ECBFF\">\"0 </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, host_uid);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Result: \"0 1000 1\\n\"</span></span></code></pre></div>\n<!-- END_TDD_MOD -->\n\n\n<h1 id=\"project-structure-container-basic\">Project Structure: Container (Basic)</h1>\n<h2 id=\"directory-tree\">Directory Tree</h2>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-basic/\n‚îú‚îÄ‚îÄ src/                    # Core source files\n‚îÇ   ‚îú‚îÄ‚îÄ common.h            # Shared macros, includes, and error wrappers (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ container.h         # ContainerConfig struct and function prototypes (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ main.c              # Host-side orchestration, clone(), and cleanup (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ init.c              # Container PID 1 entry point and setup sequence (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ reaper.c            # Zombie process collection and orphan management (M1)\n‚îÇ   ‚îú‚îÄ‚îÄ filesystem.c        # Mount propagation, pivot_root, and pseudo-fs logic (M2)\n‚îÇ   ‚îú‚îÄ‚îÄ net_host.c          # Host-side bridge, veth, and NAT/iptables setup (M3)\n‚îÇ   ‚îú‚îÄ‚îÄ net_container.c     # Child-side interface activation and routing (M3)\n‚îÇ   ‚îú‚îÄ‚îÄ cgroup.h            # Cgroup abstraction layer and type definitions (M4)\n‚îÇ   ‚îú‚îÄ‚îÄ cg_utils.c          # Low-level cgroup filesystem (read/write) helpers (M4)\n‚îÇ   ‚îú‚îÄ‚îÄ cg_v1.c             # Legacy Cgroups v1 implementation (M4)\n‚îÇ   ‚îú‚îÄ‚îÄ cg_v2.c             # Modern Unified Cgroups v2 implementation (M4)\n‚îÇ   ‚îî‚îÄ‚îÄ userns.c            # UID/GID mapping and capability verification (M5)\n‚îú‚îÄ‚îÄ tests/                  # Validation and stress tests\n‚îÇ   ‚îú‚îÄ‚îÄ stress_mem.c        # Triggers OOM killer for cgroup verification (M4)\n‚îÇ   ‚îî‚îÄ‚îÄ stress_cpu.c        # Verifies CFS throttling via tight loops (M4)\n‚îú‚îÄ‚îÄ Makefile                # Build system (standard C compilation)\n‚îú‚îÄ‚îÄ .gitignore              # Ignores build/ and binary artifacts\n‚îî‚îÄ‚îÄ README.md               # Project setup and usage instructions</code></pre></div>\n\n<h2 id=\"creation-order\">Creation Order</h2>\n<ol>\n<li><p><strong>Skeleton &amp; PID Isolation (M1)</strong></p>\n<ul>\n<li><code>src/common.h</code>, <code>src/container.h</code></li>\n<li><code>src/reaper.c</code>: Implement zombie reaping.</li>\n<li><code>src/init.c</code>: Implement <code>container_init</code> with basic PID check.</li>\n<li><code>src/main.c</code>: Implement stack allocation and <code>clone()</code> with <code>CLONE_NEWPID | CLONE_NEWUTS</code>.</li>\n</ul>\n</li>\n<li><p><strong>Filesystem Isolation (M2)</strong></p>\n<ul>\n<li><code>src/filesystem.c</code>: Implement <code>set_mounts_private</code>, <code>do_pivot_root</code>, and <code>mount_pseudofs</code>.</li>\n<li>Update <code>src/init.c</code> to call the pivot sequence.</li>\n<li>Update <code>src/main.c</code> to accept a rootfs argument and use <code>CLONE_NEWNS</code>.</li>\n</ul>\n</li>\n<li><p><strong>Networking Layer (M3)</strong></p>\n<ul>\n<li><code>src/net_host.c</code>: Implement bridge and veth pair creation.</li>\n<li><code>src/net_container.c</code>: Implement child interface/route setup.</li>\n<li>Update <code>src/main.c</code> to create the synchronization pipe and configure the host network.</li>\n<li>Update <code>src/init.c</code> to block on the pipe and call <code>setup_container_network</code>.</li>\n</ul>\n</li>\n<li><p><strong>Resource Constraints (M4)</strong></p>\n<ul>\n<li><code>src/cgroup.h</code>, <code>src/cg_utils.c</code>.</li>\n<li><code>src/cg_v1.c</code> and <code>src/cg_v2.c</code>: Implement version-specific limit writing.</li>\n<li><code>tests/stress_mem.c</code>, <code>tests/stress_cpu.c</code>: Create test binaries.</li>\n<li>Update <code>src/main.c</code> to apply cgroup limits before unblocking the child.</li>\n</ul>\n</li>\n<li><p><strong>Rootless Execution (M5)</strong></p>\n<ul>\n<li><code>src/userns.c</code>: Implement <code>write_uid_gid_maps</code> and capability checks.</li>\n<li>Update <code>src/main.c</code> to use <code>CLONE_NEWUSER</code>, capture host UIDs, and write maps.</li>\n<li>Update <code>src/init.c</code> to verify <code>UID 0</code> status after unblocking.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"file-count-summary\">File Count Summary</h2>\n<ul>\n<li><strong>Total files</strong>: 15 (13 <code>.c</code>/<code>.h</code>, 1 <code>Makefile</code>, 1 <code>README.md</code>)</li>\n<li><strong>Directories</strong>: 2 (<code>src/</code>, <code>tests/</code>)</li>\n<li><strong>Estimated lines of code</strong>: ~1,200 - 1,500 lines of C.</li>\n</ul>\n","toc":[{"level":1,"text":"üéØ Project Charter: Container (Basic)","id":"-project-charter-container-basic"},{"level":2,"text":"What You Are Building","id":"what-you-are-building"},{"level":2,"text":"Why This Project Exists","id":"why-this-project-exists"},{"level":2,"text":"What You Will Be Able to Do When Done","id":"what-you-will-be-able-to-do-when-done"},{"level":2,"text":"Final Deliverable","id":"final-deliverable"},{"level":2,"text":"Is This Project For You?","id":"is-this-project-for-you"},{"level":2,"text":"Estimated Effort","id":"estimated-effort"},{"level":2,"text":"Definition of Done","id":"definition-of-done"},{"level":3,"text":"Stack Allocation for clone()","id":"stack-allocation-for-clone"},{"level":2,"text":"What Happens Inside the Child","id":"what-happens-inside-the-child"},{"level":2,"text":"The child is PID 1 inside its namespace. The parent received the host PID from clone() ‚Äî perhaps 47832.\nBut being PID 1 is not just a number. This is the revelation.","id":"the-child-is-pid-1-inside-its-namespace-the-parent-received-the-host-pid-from-clone-perhaps-47832-but-being-pid-1-is-not-just-a-number-this-is-the-revelation"},{"level":2,"text":"The Revelation: PID 1 Is Not Just a Label","id":"the-revelation-pid-1-is-not-just-a-label"},{"level":3,"text":"1. Signal Immunity","id":"1-signal-immunity"},{"level":3,"text":"2. Orphan Adoption (The Zombie Problem)","id":"2-orphan-adoption-the-zombie-problem"},{"level":3,"text":"3. Namespace Death","id":"3-namespace-death"},{"level":2,"text":"Building the PID Namespace: Complete Implementation","id":"building-the-pid-namespace-complete-implementation"},{"level":2,"text":"Verifying Isolation: The /proc/self/status NSpid Field","id":"verifying-isolation-the-procselfstatus-nspid-field"},{"level":2,"text":"The UTS Namespace: Independent Hostname","id":"the-uts-namespace-independent-hostname"},{"level":2,"text":"The kernel implementation: each UTS namespace contains a copy of the new_utsname struct (64 bytes: nodename[65], sysname[65], etc.). sethostname() writes to the struct of the calling process&#39;s UTS namespace. Since the container has its own namespace, its sethostname() call writes to a different struct than the host&#39;s.","id":"the-kernel-implementation-each-uts-namespace-contains-a-copy-of-the-new_utsname-struct-64-bytes-nodename65-sysname65-etc-sethostname-writes-to-the-struct-of-the-calling-process39s-uts-namespace-since-the-container-has-its-own-namespace-its-sethostname-call-writes-to-a-different-struct-than-the-host39s"},{"level":2,"text":"The unshare() Alternative","id":"the-unshare-alternative"},{"level":2,"text":"The clone() approach is cleaner for container runtimes because you get the namespace creation and child process in one atomic call. The unshare() approach is used by the unshare(1) command-line tool and by Kubernetes when a pod shares namespaces between containers.","id":"the-clone-approach-is-cleaner-for-container-runtimes-because-you-get-the-namespace-creation-and-child-process-in-one-atomic-call-the-unshare-approach-is-used-by-the-unshare1-command-line-tool-and-by-kubernetes-when-a-pod-shares-namespaces-between-containers"},{"level":2,"text":"Hardware Soul: What the Kernel Is Actually Doing","id":"hardware-soul-what-the-kernel-is-actually-doing"},{"level":2,"text":"Pitfall Compendium: The Mistakes That Will Cost You Hours","id":"pitfall-compendium-the-mistakes-that-will-cost-you-hours"},{"level":3,"text":"Pitfall 1: Passing Stack Bottom Instead of Stack Top","id":"pitfall-1-passing-stack-bottom-instead-of-stack-top"},{"level":3,"text":"Pitfall 2: SIGCHLD Missing from clone() Flags","id":"pitfall-2-sigchld-missing-from-clone-flags"},{"level":3,"text":"Pitfall 3: Not Running as Root (EPERM)","id":"pitfall-3-not-running-as-root-eperm"},{"level":3,"text":"Pitfall 4: The exec() Trap in PID 1","id":"pitfall-4-the-exec-trap-in-pid-1"},{"level":3,"text":"Pitfall 5: unshare(CLONE_NEWPID) Without Subsequent fork()","id":"pitfall-5-unshareclone_newpid-without-subsequent-fork"},{"level":2,"text":"Verification Checklist","id":"verification-checklist"},{"level":2,"text":"Understanding the Process Tree","id":"understanding-the-process-tree"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. Why Docker Uses tini","id":"1-why-docker-uses-tini"},{"level":3,"text":"2. Signal Delivery Across Namespace Boundaries","id":"2-signal-delivery-across-namespace-boundaries"},{"level":3,"text":"3. Kubernetes Pod Pause Containers","id":"3-kubernetes-pod-pause-containers"},{"level":3,"text":"4. clone() Flag Composition Is Additive and Atomic","id":"4-clone-flag-composition-is-additive-and-atomic"},{"level":3,"text":"5. /proc as the Namespace Debugging Interface","id":"5-proc-as-the-namespace-debugging-interface"},{"level":2,"text":"The numbers in brackets are namespace inode numbers. Two processes in the same namespace have the same inode number for that namespace type. This is how nsenter(1) finds and joins existing namespaces ‚Äî it opens the symlink and calls setns() with the file descriptor.","id":"the-numbers-in-brackets-are-namespace-inode-numbers-two-processes-in-the-same-namespace-have-the-same-inode-number-for-that-namespace-type-this-is-how-nsenter1-finds-and-joins-existing-namespaces-it-opens-the-symlink-and-calls-setns-with-the-file-descriptor"},{"level":2,"text":"Looking Ahead","id":"looking-ahead"},{"level":2,"text":"You now have a container that isolates its process tree and hostname. But if you run ls / inside your container, you see the host&#39;s filesystem. If you run ip addr, you see the host&#39;s network interfaces. If you spawn 10,000 processes inside your container, they consume host PIDs.\nThe next milestone (Mount Namespace and Filesystem Isolation) adds CLONE_NEWNS to your clone() call and uses pivot_root() to swap the container&#39;s root filesystem. You&#39;ll finally see a truly isolated filesystem view ‚Äî and understand why chroot is weaker than pivot_root from a security standpoint.\nThe CLONE_NEWPID | CLONE_NEWUTS pair you&#39;ve built is the foundation. Every subsequent namespace flags into the same clone() call. The architecture you&#39;ve established ‚Äî container_init as PID 1, zombie reaper loop, config struct passed through clone() ‚Äî is the skeleton the rest of the milestones flesh out.","id":"you-now-have-a-container-that-isolates-its-process-tree-and-hostname-but-if-you-run-ls-inside-your-container-you-see-the-host39s-filesystem-if-you-run-ip-addr-you-see-the-host39s-network-interfaces-if-you-spawn-10000-processes-inside-your-container-they-consume-host-pids-the-next-milestone-mount-namespace-and-filesystem-isolation-adds-clone_newns-to-your-clone-call-and-uses-pivot_root-to-swap-the-container39s-root-filesystem-you39ll-finally-see-a-truly-isolated-filesystem-view-and-understand-why-chroot-is-weaker-than-pivot_root-from-a-security-standpoint-the-clone_newpid-clone_newuts-pair-you39ve-built-is-the-foundation-every-subsequent-namespace-flags-into-the-same-clone-call-the-architecture-you39ve-established-container_init-as-pid-1-zombie-reaper-loop-config-struct-passed-through-clone-is-the-skeleton-the-rest-of-the-milestones-flesh-out"},{"level":1,"text":"Milestone 2: Mount Namespace and Filesystem Isolation","id":"milestone-2-mount-namespace-and-filesystem-isolation"},{"level":2,"text":"The Illusion You Are About to Shatter","id":"the-illusion-you-are-about-to-shatter"},{"level":2,"text":"The Fundamental Tension: Shared Filesystem, Multiple Worlds","id":"the-fundamental-tension-shared-filesystem-multiple-worlds"},{"level":2,"text":"Why chroot() Is Not Enough: The Revelation","id":"why-chroot-is-not-enough-the-revelation"},{"level":2,"text":"Mount Namespaces: The Foundation","id":"mount-namespaces-the-foundation"},{"level":2,"text":"CLONE_NEWNS is historically named ‚Äî &quot;NS&quot; originally referred only to mount namespaces because they were the first namespace type added to Linux (2.4.19, 2002). All other namespace flags were added later with more descriptive names (CLONE_NEWPID, CLONE_NEWNET, etc.).\nWhen the child process starts with CLONE_NEWNS, it receives a copy of the parent&#39;s mount table. Initially, the child&#39;s mount namespace looks identical to the host&#39;s ‚Äî same filesystems, same mount points. The isolation begins when the child makes mount/unmount operations: those changes are invisible to the host, and the host&#39;s subsequent mounts are invisible to the child.\nBut there&#39;s a critical subtlety: even with a private mount namespace, if mount events can propagate between namespaces, you lose isolation. This is where mount propagation types become essential.","id":"clone_newns-is-historically-named-quotnsquot-originally-referred-only-to-mount-namespaces-because-they-were-the-first-namespace-type-added-to-linux-2419-2002-all-other-namespace-flags-were-added-later-with-more-descriptive-names-clone_newpid-clone_newnet-etc-when-the-child-process-starts-with-clone_newns-it-receives-a-copy-of-the-parent39s-mount-table-initially-the-child39s-mount-namespace-looks-identical-to-the-host39s-same-filesystems-same-mount-points-the-isolation-begins-when-the-child-makes-mountunmount-operations-those-changes-are-invisible-to-the-host-and-the-host39s-subsequent-mounts-are-invisible-to-the-child-but-there39s-a-critical-subtlety-even-with-a-private-mount-namespace-if-mount-events-can-propagate-between-namespaces-you-lose-isolation-this-is-where-mount-propagation-types-become-essential"},{"level":2,"text":"Mount Propagation: The Hidden Complexity","id":"mount-propagation-the-hidden-complexity"},{"level":2,"text":"Building the New Root Filesystem","id":"building-the-new-root-filesystem"},{"level":2,"text":"The pivot_root() Sequence: Step by Step","id":"the-pivot_root-sequence-step-by-step"},{"level":3,"text":"What Happens at Each Step in the Kernel","id":"what-happens-at-each-step-in-the-kernel"},{"level":3,"text":"1. What it IS","id":"1-what-it-is"},{"level":3,"text":"2. WHY you need it right now","id":"2-why-you-need-it-right-now"},{"level":3,"text":"3. ONE key insight or mental model","id":"3-one-key-insight-or-mental-model"},{"level":2,"text":"Remember: It provides immediate invisibility but delayed destruction.\n deserves explanation: it performs a lazy unmount. The mount point becomes immediately invisible and unreachable from new path lookups. However, if any process has an open file descriptor pointing into that filesystem (e.g., a file from the old root is still open), the kernel keeps the filesystem alive until those descriptors are closed. Only then is the memory freed. This is safer than a &quot;force&quot; unmount (MNT_FORCE) which would close those file descriptors forcibly ‚Äî potentially corrupting data. For our use case, the container&#39;s init process shouldn&#39;t have open files in the old root, so MNT_DETACH completes effectively immediately.","id":"remember-it-provides-immediate-invisibility-but-delayed-destruction-deserves-explanation-it-performs-a-lazy-unmount-the-mount-point-becomes-immediately-invisible-and-unreachable-from-new-path-lookups-however-if-any-process-has-an-open-file-descriptor-pointing-into-that-filesystem-eg-a-file-from-the-old-root-is-still-open-the-kernel-keeps-the-filesystem-alive-until-those-descriptors-are-closed-only-then-is-the-memory-freed-this-is-safer-than-a-quotforcequot-unmount-mnt_force-which-would-close-those-file-descriptors-forcibly-potentially-corrupting-data-for-our-use-case-the-container39s-init-process-shouldn39t-have-open-files-in-the-old-root-so-mnt_detach-completes-effectively-immediately"},{"level":2,"text":"Mounting Essential Pseudo-Filesystems","id":"mounting-essential-pseudo-filesystems"},{"level":3,"text":"/proc ‚Äî Process and Kernel Information","id":"proc-process-and-kernel-information"},{"level":3,"text":"/sys ‚Äî Kernel and Device Parameters","id":"sys-kernel-and-device-parameters"},{"level":3,"text":"/dev ‚Äî Device Nodes","id":"dev-device-nodes"},{"level":2,"text":"The bind-mount approach (Option A) is what Docker and runc use for most scenarios ‚Äî it avoids requiring CAP_MKNOD by inheriting device nodes from the host where they already exist, then making them individually visible inside the container.","id":"the-bind-mount-approach-option-a-is-what-docker-and-runc-use-for-most-scenarios-it-avoids-requiring-cap_mknod-by-inheriting-device-nodes-from-the-host-where-they-already-exist-then-making-them-individually-visible-inside-the-container"},{"level":2,"text":"Complete Implementation: Filesystem Isolation","id":"complete-implementation-filesystem-isolation"},{"level":2,"text":"The Order of Operations: Why Sequence Matters","id":"the-order-of-operations-why-sequence-matters"},{"level":2,"text":"Common mistake: mounting /proc before pivot_root. If you mount /proc in the new namespace while still at the host root, /proc is mounted at the host&#39;s /proc. After pivot_root, the new root doesn&#39;t have /proc ‚Äî you&#39;d need to mount it again inside the container. Worse, if mount propagation wasn&#39;t set to private yet, you might have accidentally modified the host&#39;s /proc mount (if any parent mount was shared). Always pivot_root first, then mount pseudo-filesystems.\nCommon mistake: forgetting MS_PRIVATE before any mounts. If you call MS_BIND on the rootfs before setting MS_PRIVATE on /, the bind-mount event may propagate back to the host through shared propagation. The host gains a new mount entry it didn&#39;t expect. In a containerized environment with many containers, this leaks mount events between containers ‚Äî a security and operational issue.","id":"common-mistake-mounting-proc-before-pivot_root-if-you-mount-proc-in-the-new-namespace-while-still-at-the-host-root-proc-is-mounted-at-the-host39s-proc-after-pivot_root-the-new-root-doesn39t-have-proc-you39d-need-to-mount-it-again-inside-the-container-worse-if-mount-propagation-wasn39t-set-to-private-yet-you-might-have-accidentally-modified-the-host39s-proc-mount-if-any-parent-mount-was-shared-always-pivot_root-first-then-mount-pseudo-filesystems-common-mistake-forgetting-ms_private-before-any-mounts-if-you-call-ms_bind-on-the-rootfs-before-setting-ms_private-on-the-bind-mount-event-may-propagate-back-to-the-host-through-shared-propagation-the-host-gains-a-new-mount-entry-it-didn39t-expect-in-a-containerized-environment-with-many-containers-this-leaks-mount-events-between-containers-a-security-and-operational-issue"},{"level":2,"text":"Pitfall Compendium: What Will Break and Why","id":"pitfall-compendium-what-will-break-and-why"},{"level":3,"text":"Pitfall 1: pivot_root Fails with EINVAL","id":"pitfall-1-pivot_root-fails-with-einval"},{"level":3,"text":"Pitfall 2: Mounting /proc Without a PID Namespace","id":"pitfall-2-mounting-proc-without-a-pid-namespace"},{"level":3,"text":"Pitfall 3: Host Filesystem Accessible via Open File Descriptors","id":"pitfall-3-host-filesystem-accessible-via-open-file-descriptors"},{"level":3,"text":"Pitfall 4: tmpfs Size Limit on /dev","id":"pitfall-4-tmpfs-size-limit-on-dev"},{"level":3,"text":"Pitfall 5: Missing MS_REC on Propagation Change","id":"pitfall-5-missing-ms_rec-on-propagation-change"},{"level":3,"text":"Pitfall 6: chdir() After pivot_root is Mandatory","id":"pitfall-6-chdir-after-pivot_root-is-mandatory"},{"level":2,"text":"After pivot_root(), the process&#39;s working directory (cwd) still points to the old root&#39;s directory entry. Relative path operations behave unexpectedly because the cwd is now in the detached old root. The chdir(&quot;/&quot;) call immediately after pivot_root() resets the cwd to the new root. Missing this step produces confusing ENOENT errors in subsequent operations.","id":"after-pivot_root-the-process39s-working-directory-cwd-still-points-to-the-old-root39s-directory-entry-relative-path-operations-behave-unexpectedly-because-the-cwd-is-now-in-the-detached-old-root-the-chdirquotquot-call-immediately-after-pivot_root-resets-the-cwd-to-the-new-root-missing-this-step-produces-confusing-enoent-errors-in-subsequent-operations"},{"level":2,"text":"Hardware Soul: What the Kernel Is Actually Doing","id":"hardware-soul-what-the-kernel-is-actually-doing"},{"level":3,"text":"Cache Behavior During pivot_root()","id":"cache-behavior-during-pivot_root"},{"level":3,"text":"TLB and Page Table Impact","id":"tlb-and-page-table-impact"},{"level":3,"text":"Memory Access Pattern","id":"memory-access-pattern"},{"level":2,"text":"The bind-mount-to-self (MS_BIND) copies the source mount&#39;s mount struct and adds it to the namespace&#39;s mount list. This is a sequential write into kernel memory ‚Äî cache-friendly. The pivot_root() operation is a tree rotation in the mount list ‚Äî O(1) pointer operations, all in already-hot cache lines.","id":"the-bind-mount-to-self-ms_bind-copies-the-source-mount39s-mount-struct-and-adds-it-to-the-namespace39s-mount-list-this-is-a-sequential-write-into-kernel-memory-cache-friendly-the-pivot_root-operation-is-a-tree-rotation-in-the-mount-list-o1-pointer-operations-all-in-already-hot-cache-lines"},{"level":2,"text":"Knowledge Cascade: Mount Namespaces Unlock Everything","id":"knowledge-cascade-mount-namespaces-unlock-everything"},{"level":3,"text":"1. Docker&#39;s overlay2 Storage Driver","id":"1-docker39s-overlay2-storage-driver"},{"level":3,"text":"2. The Leaky Vessels CVE (2024): Container Escape via Incomplete pivot_root","id":"2-the-leaky-vessels-cve-2024-container-escape-via-incomplete-pivot_root"},{"level":3,"text":"3. Kubernetes hostPath Mounts and Bidirectional Propagation","id":"3-kubernetes-hostpath-mounts-and-bidirectional-propagation"},{"level":3,"text":"4. Distroless Images and Minimal rootfs","id":"4-distroless-images-and-minimal-rootfs"},{"level":3,"text":"5. setns() and Joining Existing Namespaces","id":"5-setns-and-joining-existing-namespaces"},{"level":2,"text":"The inverse of creating a mount namespace is joining an existing one. setns(fd, CLONE_NEWNS) switches the calling process into the mount namespace referenced by fd (obtained by open(&quot;/proc/&lt;pid&gt;/ns/mnt&quot;, O_RDONLY)). This is how docker exec works: it opens the running container&#39;s namespace descriptors from /proc/&lt;container_pid&gt;/ns/* and joins each one using setns(), then exec()s the user&#39;s command in the container&#39;s environment.\nNow you understand why docker exec can run commands inside a running container without restarting it ‚Äî it&#39;s joining the existing namespaces at runtime, including the mount namespace with pivot_root()&#39;d rootfs still in effect.","id":"the-inverse-of-creating-a-mount-namespace-is-joining-an-existing-one-setnsfd-clone_newns-switches-the-calling-process-into-the-mount-namespace-referenced-by-fd-obtained-by-openquotprocltpidgtnsmntquot-o_rdonly-this-is-how-docker-exec-works-it-opens-the-running-container39s-namespace-descriptors-from-procltcontainer_pidgtns-and-joins-each-one-using-setns-then-execs-the-user39s-command-in-the-container39s-environment-now-you-understand-why-docker-exec-can-run-commands-inside-a-running-container-without-restarting-it-it39s-joining-the-existing-namespaces-at-runtime-including-the-mount-namespace-with-pivot_root39d-rootfs-still-in-effect"},{"level":2,"text":"Verification Checklist","id":"verification-checklist"},{"level":2,"text":"Looking Ahead","id":"looking-ahead"},{"level":2,"text":"Your container now has genuine filesystem isolation. pivot_root() has atomically swapped the root filesystem, umount2(MNT_DETACH) has removed the host filesystem from the kernel&#39;s path resolution, and pseudo-filesystems provide the minimal infrastructure the container process needs.\nBut if you run ip addr inside the container, you see the host&#39;s network interfaces ‚Äî eth0, wlan0, all of it. The container can open network connections on behalf of the host&#39;s network stack, listen on ports that appear on the host, and enumerate the host&#39;s network configuration.\nThe next milestone (Network Namespace and Container Networking) adds CLONE_NEWNET to the growing list of namespace flags. The pattern is now clear: CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWNET | SIGCHLD ‚Äî all atomic in a single clone() call. Each namespace flag adds another dimension of isolation. By Milestone 4 (cgroups), you&#39;ll also enforce resource limits ‚Äî not just visibility limits. And by Milestone 5 (user namespaces), you&#39;ll remove the sudo requirement entirely.\nThe container_init architecture you&#39;ve been building ‚Äî clone() with accumulated flags, PID 1 reaper loop, sequential isolation setup inside the child ‚Äî is the skeleton every container runtime follows. runc (the OCI runtime used by Docker) does exactly this sequence, with additional complexity around OCI spec compliance, seccomp filters, and capability management. You&#39;ve now built the core.","id":"your-container-now-has-genuine-filesystem-isolation-pivot_root-has-atomically-swapped-the-root-filesystem-umount2mnt_detach-has-removed-the-host-filesystem-from-the-kernel39s-path-resolution-and-pseudo-filesystems-provide-the-minimal-infrastructure-the-container-process-needs-but-if-you-run-ip-addr-inside-the-container-you-see-the-host39s-network-interfaces-eth0-wlan0-all-of-it-the-container-can-open-network-connections-on-behalf-of-the-host39s-network-stack-listen-on-ports-that-appear-on-the-host-and-enumerate-the-host39s-network-configuration-the-next-milestone-network-namespace-and-container-networking-adds-clone_newnet-to-the-growing-list-of-namespace-flags-the-pattern-is-now-clear-clone_newpid-clone_newuts-clone_newns-clone_newnet-sigchld-all-atomic-in-a-single-clone-call-each-namespace-flag-adds-another-dimension-of-isolation-by-milestone-4-cgroups-you39ll-also-enforce-resource-limits-not-just-visibility-limits-and-by-milestone-5-user-namespaces-you39ll-remove-the-sudo-requirement-entirely-the-container_init-architecture-you39ve-been-building-clone-with-accumulated-flags-pid-1-reaper-loop-sequential-isolation-setup-inside-the-child-is-the-skeleton-every-container-runtime-follows-runc-the-oci-runtime-used-by-docker-does-exactly-this-sequence-with-additional-complexity-around-oci-spec-compliance-seccomp-filters-and-capability-management-you39ve-now-built-the-core"},{"level":1,"text":"Milestone 3: Network Namespace and Container Networking","id":"milestone-3-network-namespace-and-container-networking"},{"level":2,"text":"The Illusion You Are About to Demystify","id":"the-illusion-you-are-about-to-demystify"},{"level":2,"text":"The Tension: One Network Stack, Many Isolated Worlds","id":"the-tension-one-network-stack-many-isolated-worlds"},{"level":2,"text":"Concept 1: The Virtual Ethernet Pair","id":"concept-1-the-virtual-ethernet-pair"},{"level":2,"text":"Concept 2: The Linux Bridge","id":"concept-2-the-linux-bridge"},{"level":2,"text":"The bridge is created with ARPHRD_ETHER type and given an IP address. The IP serves as the container gateway ‚Äî containers send their default route traffic to this IP, and the bridge (being on the host network stack) can forward it onward.","id":"the-bridge-is-created-with-arphrd_ether-type-and-given-an-ip-address-the-ip-serves-as-the-container-gateway-containers-send-their-default-route-traffic-to-this-ip-and-the-bridge-being-on-the-host-network-stack-can-forward-it-onward"},{"level":2,"text":"Building the Network Topology: Complete Plan","id":"building-the-network-topology-complete-plan"},{"level":2,"text":"The Two-Phase Implementation","id":"the-two-phase-implementation"},{"level":2,"text":"This is the same technique used by runc and containerd ‚Äî they call it the &quot;init pipe&quot; or &quot;sync socket&quot;. The OCI runtime spec formalizes this two-phase initialization exactly because network setup requires the split-second coordination between parent and child.","id":"this-is-the-same-technique-used-by-runc-and-containerd-they-call-it-the-quotinit-pipequot-or-quotsync-socketquot-the-oci-runtime-spec-formalizes-this-two-phase-initialization-exactly-because-network-setup-requires-the-split-second-coordination-between-parent-and-child"},{"level":2,"text":"Phase 1: Host-Side Network Setup","id":"phase-1-host-side-network-setup"},{"level":3,"text":"Step 1: Create the Linux Bridge","id":"step-1-create-the-linux-bridge"},{"level":3,"text":"Step 2: Create the veth Pair","id":"step-2-create-the-veth-pair"},{"level":3,"text":"Step 3: Attach Host-Side to Bridge","id":"step-3-attach-host-side-to-bridge"},{"level":3,"text":"Step 4: Move Container-Side veth Into the Container Namespace","id":"step-4-move-container-side-veth-into-the-container-namespace"},{"level":3,"text":"Step 5: Enable IP Forwarding and NAT","id":"step-5-enable-ip-forwarding-and-nat"},{"level":2,"text":"MASQUERADE is a special case of SNAT (Source NAT). SNAT requires you to specify the replacement IP explicitly. MASQUERADE automatically uses whatever IP is currently assigned to the outbound interface ‚Äî useful when the host has a dynamic IP (DHCP). The kernel&#39;s nf_nat_masquerade.c looks up the outbound interface&#39;s current IP at packet-send time and substitutes it as the source.\n[[EXPLAIN:netfilter-hook-points-and-iptables-chain-traversal|Netfilter hook points and iptables FORWARD/POSTROUTING chain traversal]]","id":"masquerade-is-a-special-case-of-snat-source-nat-snat-requires-you-to-specify-the-replacement-ip-explicitly-masquerade-automatically-uses-whatever-ip-is-currently-assigned-to-the-outbound-interface-useful-when-the-host-has-a-dynamic-ip-dhcp-the-kernel39s-nf_nat_masqueradec-looks-up-the-outbound-interface39s-current-ip-at-packet-send-time-and-substitutes-it-as-the-source-explainnetfilter-hook-points-and-iptables-chain-traversalnetfilter-hook-points-and-iptables-forwardpostrouting-chain-traversal"},{"level":2,"text":"Phase 2: Container-Side Network Setup","id":"phase-2-container-side-network-setup"},{"level":3,"text":"DNS Configuration","id":"dns-configuration"},{"level":2,"text":"Complete Implementation: Everything Together","id":"complete-implementation-everything-together"},{"level":2,"text":"Extension: Raw Netlink Interface","id":"extension-raw-netlink-interface"},{"level":2,"text":"[[EXPLAIN:rtnetlink-message-construction-and-nested-attributes|rtnetlink Netlink message structure and nested attribute encoding]]\nThe libmnl library provides a cleaner C API for Netlink message construction and is used by iproute2 itself. For a production container runtime, use libmnl rather than raw Netlink socket construction.","id":"explainrtnetlink-message-construction-and-nested-attributesrtnetlink-netlink-message-structure-and-nested-attribute-encoding-the-libmnl-library-provides-a-cleaner-c-api-for-netlink-message-construction-and-is-used-by-iproute2-itself-for-a-production-container-runtime-use-libmnl-rather-than-raw-netlink-socket-construction"},{"level":2,"text":"The Packet Walk: Container to Internet","id":"the-packet-walk-container-to-internet"},{"level":2,"text":"The conntrack (connection tracking) table is the invisible glue that makes stateful NAT work. The kernel records every outbound connection translation and automatically applies the reverse translation to incoming responses. Without conntrack, NAT would require explicit DNAT rules for every outbound connection ‚Äî which is obviously impractical.","id":"the-conntrack-connection-tracking-table-is-the-invisible-glue-that-makes-stateful-nat-work-the-kernel-records-every-outbound-connection-translation-and-automatically-applies-the-reverse-translation-to-incoming-responses-without-conntrack-nat-would-require-explicit-dnat-rules-for-every-outbound-connection-which-is-obviously-impractical"},{"level":2,"text":"Hardware Soul: What the Kernel Is Actually Doing","id":"hardware-soul-what-the-kernel-is-actually-doing"},{"level":3,"text":"veth Packet Transmission Latency","id":"veth-packet-transmission-latency"},{"level":3,"text":"iptables MASQUERADE Performance","id":"iptables-masquerade-performance"},{"level":3,"text":"TLB and Page Table Impact","id":"tlb-and-page-table-impact"},{"level":2,"text":"Network namespaces don&#39;t directly create new address spaces ‚Äî they&#39;re kernel data structures, not process address spaces. The TLB is not affected by namespace creation or packet forwarding.\nThe one TLB-relevant operation: when the kernel switches between the container&#39;s network namespace and the host&#39;s (during bridge forwarding), it accesses different struct net objects. These objects are typically in different cache lines and may not be hot. First-packet latency for a new connection from a container that hasn&#39;t recently sent traffic will be slightly higher (cold cache) ‚Äî subsequent packets benefit from the warm cache.","id":"network-namespaces-don39t-directly-create-new-address-spaces-they39re-kernel-data-structures-not-process-address-spaces-the-tlb-is-not-affected-by-namespace-creation-or-packet-forwarding-the-one-tlb-relevant-operation-when-the-kernel-switches-between-the-container39s-network-namespace-and-the-host39s-during-bridge-forwarding-it-accesses-different-struct-net-objects-these-objects-are-typically-in-different-cache-lines-and-may-not-be-hot-first-packet-latency-for-a-new-connection-from-a-container-that-hasn39t-recently-sent-traffic-will-be-slightly-higher-cold-cache-subsequent-packets-benefit-from-the-warm-cache"},{"level":2,"text":"Pitfall Compendium","id":"pitfall-compendium"},{"level":3,"text":"Pitfall 1: Creating veth Pair Before Container Namespace Exists","id":"pitfall-1-creating-veth-pair-before-container-namespace-exists"},{"level":3,"text":"Pitfall 2: Forgetting to Bring Up Loopback","id":"pitfall-2-forgetting-to-bring-up-loopback"},{"level":3,"text":"Pitfall 3: IP Forwarding Not Enabled on Host","id":"pitfall-3-ip-forwarding-not-enabled-on-host"},{"level":3,"text":"Pitfall 4: veth Pair Left Behind After Container Exit","id":"pitfall-4-veth-pair-left-behind-after-container-exit"},{"level":3,"text":"Pitfall 5: NAT Rule Duplication","id":"pitfall-5-nat-rule-duplication"},{"level":3,"text":"Pitfall 6: DNS Resolution Fails Silently","id":"pitfall-6-dns-resolution-fails-silently"},{"level":2,"text":"Always write /etc/resolv.conf before pivot_root(). After pivot_root(), the container&#39;s /etc/ is in the container rootfs ‚Äî writes go there. But the write_resolv_conf() function in our implementation writes to &lt;rootfs&gt;/etc/resolv.conf from the host, before the container starts. This is the correct sequence.","id":"always-write-etcresolvconf-before-pivot_root-after-pivot_root-the-container39s-etc-is-in-the-container-rootfs-writes-go-there-but-the-write_resolv_conf-function-in-our-implementation-writes-to-ltrootfsgtetcresolvconf-from-the-host-before-the-container-starts-this-is-the-correct-sequence"},{"level":2,"text":"Verification Checklist","id":"verification-checklist"},{"level":2,"text":"Knowledge Cascade: What This Unlocks","id":"knowledge-cascade-what-this-unlocks"},{"level":3,"text":"1. Kubernetes Networking Model (Cross-Domain)","id":"1-kubernetes-networking-model-cross-domain"},{"level":3,"text":"2. Service Mesh Data Plane (Istio/Envoy)","id":"2-service-mesh-data-plane-istioenvoy"},{"level":3,"text":"3. Network Performance: veth vs Host vs macvlan","id":"3-network-performance-veth-vs-host-vs-macvlan"},{"level":3,"text":"4. DNS Resolution ‚Äî The #1 Container Networking Bug","id":"4-dns-resolution-the-1-container-networking-bug"},{"level":3,"text":"5. Network Policy Enforcement (Calico/Cilium)","id":"5-network-policy-enforcement-calicocilium"},{"level":2,"text":"Cilium with eBPF: attaches eBPF programs to the TC (Traffic Control) hook on the veth interface ‚Äî earlier in the packet path than iptables, lower overhead, O(1) policy lookup via eBPF hash maps instead of iptables linear scan.\nThe veth interface is the natural policy enforcement point: it&#39;s the first kernel touch point for packets entering or leaving a container. Everything that flows to/from a container must cross the veth. This is why CNI plugins attach hooks there ‚Äî there&#39;s no way to bypass it without bypassing the entire network namespace model.\nUnderstanding this: when a Kubernetes network policy says &quot;deny all ingress to pod A except from pods with label app=frontend,&quot; that rule is an iptables chain (or eBPF program) on the veth interface that connects pod A&#39;s namespace to the host. Every packet entering pod A&#39;s veth from the bridge is evaluated against this rule.","id":"cilium-with-ebpf-attaches-ebpf-programs-to-the-tc-traffic-control-hook-on-the-veth-interface-earlier-in-the-packet-path-than-iptables-lower-overhead-o1-policy-lookup-via-ebpf-hash-maps-instead-of-iptables-linear-scan-the-veth-interface-is-the-natural-policy-enforcement-point-it39s-the-first-kernel-touch-point-for-packets-entering-or-leaving-a-container-everything-that-flows-tofrom-a-container-must-cross-the-veth-this-is-why-cni-plugins-attach-hooks-there-there39s-no-way-to-bypass-it-without-bypassing-the-entire-network-namespace-model-understanding-this-when-a-kubernetes-network-policy-says-quotdeny-all-ingress-to-pod-a-except-from-pods-with-label-appfrontendquot-that-rule-is-an-iptables-chain-or-ebpf-program-on-the-veth-interface-that-connects-pod-a39s-namespace-to-the-host-every-packet-entering-pod-a39s-veth-from-the-bridge-is-evaluated-against-this-rule"},{"level":2,"text":"The One-Line Summary","id":"the-one-line-summary"},{"level":1,"text":"Milestone 4: Cgroups Resource Limits","id":"milestone-4-cgroups-resource-limits"},{"level":2,"text":"The Illusion You Are About to Break","id":"the-illusion-you-are-about-to-break"},{"level":2,"text":"Watch ps aux on the host. Your container is spawning thousands of processes, consuming host PIDs, potentially making the entire system unresponsive. There&#39;s no wall. There&#39;s no limit. The &quot;container&quot; has a view restriction but no resource restriction.\nThis is the gap that cgroups fills. But before we get to the implementation, you need to shed a misconception that&#39;s so natural it will feel correct even after you&#39;ve read this sentence.","id":"watch-ps-aux-on-the-host-your-container-is-spawning-thousands-of-processes-consuming-host-pids-potentially-making-the-entire-system-unresponsive-there39s-no-wall-there39s-no-limit-the-quotcontainerquot-has-a-view-restriction-but-no-resource-restriction-this-is-the-gap-that-cgroups-fills-but-before-we-get-to-the-implementation-you-need-to-shed-a-misconception-that39s-so-natural-it-will-feel-correct-even-after-you39ve-read-this-sentence"},{"level":2,"text":"The Revelation: Cgroups Don&#39;t Prevent ‚Äî They React","id":"the-revelation-cgroups-don39t-prevent-they-react"},{"level":2,"text":"This throttling is the source of one of Kubernetes&#39;s most common and frustrating performance problems: a container that sets CPU limits too low experiences latency spikes at the period boundary, even when the node has plenty of spare CPU capacity. The metric that reveals this is cpu.stat&#39;s throttled_usec counter ‚Äî a number that most developers never look at until something is mysteriously slow.\nYou are about to build the machinery that causes these behaviors. Understanding what you&#39;re building is more important than the implementation itself.","id":"this-throttling-is-the-source-of-one-of-kubernetes39s-most-common-and-frustrating-performance-problems-a-container-that-sets-cpu-limits-too-low-experiences-latency-spikes-at-the-period-boundary-even-when-the-node-has-plenty-of-spare-cpu-capacity-the-metric-that-reveals-this-is-cpustat39s-throttled_usec-counter-a-number-that-most-developers-never-look-at-until-something-is-mysteriously-slow-you-are-about-to-build-the-machinery-that-causes-these-behaviors-understanding-what-you39re-building-is-more-important-than-the-implementation-itself"},{"level":2,"text":"What Cgroups Are: The Kernel&#39;s Resource Accounting Ledger","id":"what-cgroups-are-the-kernel39s-resource-accounting-ledger"},{"level":2,"text":"The hierarchy is also a filesystem directory tree. Child cgroups inherit constraints from parents but can set tighter (never looser) limits. This is why Kubernetes&#39;s --cgroup-parent flag works: Kubernetes creates a parent cgroup for each pod, and individual container cgroups live inside it. Resource limits cascade.","id":"the-hierarchy-is-also-a-filesystem-directory-tree-child-cgroups-inherit-constraints-from-parents-but-can-set-tighter-never-looser-limits-this-is-why-kubernetes39s-cgroup-parent-flag-works-kubernetes-creates-a-parent-cgroup-for-each-pod-and-individual-container-cgroups-live-inside-it-resource-limits-cascade"},{"level":2,"text":"cgroups v1 vs v2: The Architectural Schism You Must Detect","id":"cgroups-v1-vs-v2-the-architectural-schism-you-must-detect"},{"level":2,"text":"Modern Ubuntu (22.04+), Fedora (33+), Debian (11+), and Alpine (3.16+) all default to cgroups v2. If you&#39;re running a production system from 2019 or earlier, you may still have v1. Our implementation handles both, but optimizes for clarity on v2.","id":"modern-ubuntu-2204-fedora-33-debian-11-and-alpine-316-all-default-to-cgroups-v2-if-you39re-running-a-production-system-from-2019-or-earlier-you-may-still-have-v1-our-implementation-handles-both-but-optimizes-for-clarity-on-v2"},{"level":2,"text":"The Controller Enablement Problem: The Subtlety That Breaks Everyone","id":"the-controller-enablement-problem-the-subtlety-that-breaks-everyone"},{"level":2,"text":"Building the Cgroup Manager: Complete Implementation","id":"building-the-cgroup-manager-complete-implementation"},{"level":2,"text":"Cleanup: You Cannot rmdir a Live Cgroup","id":"cleanup-you-cannot-rmdir-a-live-cgroup"},{"level":2,"text":"Resource Observability: Reading the Cgroup Meters","id":"resource-observability-reading-the-cgroup-meters"},{"level":2,"text":"The most revealing field in cpu.stat is throttled_usec. If this number is non-zero and growing, your container is being CPU-throttled ‚Äî processes are spending time waiting for the next CFS period to begin rather than actually executing. A container with throttled_usec growing at 1 second per 10 seconds of wall time is experiencing ~10% CPU throttling, which will appear as 10% longer response times for every request that runs through that CPU period boundary.","id":"the-most-revealing-field-in-cpustat-is-throttled_usec-if-this-number-is-non-zero-and-growing-your-container-is-being-cpu-throttled-processes-are-spending-time-waiting-for-the-next-cfs-period-to-begin-rather-than-actually-executing-a-container-with-throttled_usec-growing-at-1-second-per-10-seconds-of-wall-time-is-experiencing-10-cpu-throttling-which-will-appear-as-10-longer-response-times-for-every-request-that-runs-through-that-cpu-period-boundary"},{"level":2,"text":"Integrating Cgroups Into the Container Runtime","id":"integrating-cgroups-into-the-container-runtime"},{"level":2,"text":"Verifying Memory Limits: Triggering the OOM Killer","id":"verifying-memory-limits-triggering-the-oom-killer"},{"level":2,"text":"Verifying CPU Throttling: The CFS Quota Mechanism","id":"verifying-cpu-throttling-the-cfs-quota-mechanism"},{"level":2,"text":"This is the Kubernetes throttling problem in miniature. A Kubernetes pod with resources.limits.cpu: &quot;0.5&quot; (half a core) gets cpu.max = &quot;50000 100000&quot;. If the pod runs a bursty workload ‚Äî periodic HTTP requests each doing 80ms of CPU work ‚Äî those requests will be throttled at the period boundary even when the node has 15 spare CPU cores. The fix is to either raise the limit, switch to cpu.weight (requests-only, no hard limit), or increase the period. We&#39;ll explore these in the Knowledge Cascade.","id":"this-is-the-kubernetes-throttling-problem-in-miniature-a-kubernetes-pod-with-resourceslimitscpu-quot05quot-half-a-core-gets-cpumax-quot50000-100000quot-if-the-pod-runs-a-bursty-workload-periodic-http-requests-each-doing-80ms-of-cpu-work-those-requests-will-be-throttled-at-the-period-boundary-even-when-the-node-has-15-spare-cpu-cores-the-fix-is-to-either-raise-the-limit-switch-to-cpuweight-requests-only-no-hard-limit-or-increase-the-period-we39ll-explore-these-in-the-knowledge-cascade"},{"level":2,"text":"Verifying Fork Bomb Containment","id":"verifying-fork-bomb-containment"},{"level":2,"text":"After the fork bomb processes die (they exit quickly since they have nothing to do), pids.current drops back to the baseline container process count.","id":"after-the-fork-bomb-processes-die-they-exit-quickly-since-they-have-nothing-to-do-pidscurrent-drops-back-to-the-baseline-container-process-count"},{"level":2,"text":"Hardware Soul: What the Kernel Is Actually Doing","id":"hardware-soul-what-the-kernel-is-actually-doing"},{"level":3,"text":"Memory Accounting: The Page Fault Path","id":"memory-accounting-the-page-fault-path"},{"level":3,"text":"CFS Scheduler: The Bandwidth Controller","id":"cfs-scheduler-the-bandwidth-controller"},{"level":3,"text":"pids.max: Atomic Fork Count","id":"pidsmax-atomic-fork-count"},{"level":2,"text":"The check is a single atomic comparison. On an unconstrained cgroup (pids.max = &quot;max&quot;), this comparison is skipped entirely ‚Äî no overhead. On a constrained cgroup, it&#39;s one atomic load plus one comparison ‚Äî on the order of 5-20 ns depending on cache state. Negligible.\nThe EAGAIN return code propagates back to fork() in userspace, which sets errno = EAGAIN. This is why you see fork: Resource temporarily unavailable in the fork bomb output ‚Äî EAGAIN is &quot;resource temporarily unavailable&quot; in the POSIX error space.","id":"the-check-is-a-single-atomic-comparison-on-an-unconstrained-cgroup-pidsmax-quotmaxquot-this-comparison-is-skipped-entirely-no-overhead-on-a-constrained-cgroup-it39s-one-atomic-load-plus-one-comparison-on-the-order-of-5-20-ns-depending-on-cache-state-negligible-the-eagain-return-code-propagates-back-to-fork-in-userspace-which-sets-errno-eagain-this-is-why-you-see-fork-resource-temporarily-unavailable-in-the-fork-bomb-output-eagain-is-quotresource-temporarily-unavailablequot-in-the-posix-error-space"},{"level":2,"text":"Pitfall Compendium: The Mistakes That Will Ruin Your Weekend","id":"pitfall-compendium-the-mistakes-that-will-ruin-your-weekend"},{"level":3,"text":"Pitfall 1: Writing to cgroup.procs After exec()","id":"pitfall-1-writing-to-cgroupprocs-after-exec"},{"level":3,"text":"Pitfall 2: Not Writing to memory.swap.max","id":"pitfall-2-not-writing-to-memoryswapmax"},{"level":3,"text":"Pitfall 3: Forgetting cgroup.subtree_control on v2","id":"pitfall-3-forgetting-cgroupsubtree_control-on-v2"},{"level":3,"text":"Pitfall 4: Cleanup Order ‚Äî rmdir Before Processes Exit","id":"pitfall-4-cleanup-order-rmdir-before-processes-exit"},{"level":3,"text":"Pitfall 5: CPU Period Too Large or Too Small","id":"pitfall-5-cpu-period-too-large-or-too-small"},{"level":3,"text":"Pitfall 6: The v1 Memory + Swap Accounting Split","id":"pitfall-6-the-v1-memory-swap-accounting-split"},{"level":2,"text":"In cgroups v1, memory and swap accounting are separate controllers, and the combined limit is memory.memsw.limit_in_bytes ‚Äî a different file than memory.limit_in_bytes. If you only set memory.limit_in_bytes in v1, the container can exceed the limit via swap. The v1 code above shows the correct approach: set both.\nIn v2, memory.max and memory.swap.max are separate but both must be set for strict containment. The semantic is cleaner in v2.","id":"in-cgroups-v1-memory-and-swap-accounting-are-separate-controllers-and-the-combined-limit-is-memorymemswlimit_in_bytes-a-different-file-than-memorylimit_in_bytes-if-you-only-set-memorylimit_in_bytes-in-v1-the-container-can-exceed-the-limit-via-swap-the-v1-code-above-shows-the-correct-approach-set-both-in-v2-memorymax-and-memoryswapmax-are-separate-but-both-must-be-set-for-strict-containment-the-semantic-is-cleaner-in-v2"},{"level":2,"text":"Knowledge Cascade: From Container to Cluster","id":"knowledge-cascade-from-container-to-cluster"},{"level":3,"text":"1. Kubernetes Resource Requests vs. Limits: The Invisible Performance Knob","id":"1-kubernetes-resource-requests-vs-limits-the-invisible-performance-knob"},{"level":3,"text":"2. OOM Killer Scoring and Kubernetes QoS","id":"2-oom-killer-scoring-and-kubernetes-qos"},{"level":3,"text":"3. Memory Accounting Subtleties: The Page Cache Trap","id":"3-memory-accounting-subtleties-the-page-cache-trap"},{"level":3,"text":"4. cgroup Delegation for Rootless Containers","id":"4-cgroup-delegation-for-rootless-containers"},{"level":3,"text":"5. Container Observability: The cgroup Filesystem as Metrics Source","id":"5-container-observability-the-cgroup-filesystem-as-metrics-source"},{"level":2,"text":"The Three-Level View: A Resource-Limited malloc()","id":"the-three-level-view-a-resource-limited-malloc"},{"level":2,"text":"Compilation and Testing: Running the Complete Stack","id":"compilation-and-testing-running-the-complete-stack"},{"level":2,"text":"Verification Checklist","id":"verification-checklist"},{"level":2,"text":"Looking Ahead","id":"looking-ahead"},{"level":2,"text":"Your container is running as root. Not effective root inside a namespace ‚Äî actual root on the host. If there&#39;s a container escape vulnerability (a bug in your pivot_root sequence, a missing seccomp filter, a suid binary in the rootfs), the escaping process has full root access on the host.\nMilestone 5 (User Namespaces and Rootless Containers) solves this by creating a user namespace where the container process appears to be root inside the container, but maps to an unprivileged UID on the host. The UID 0 inside the container becomes UID 1000 on the host. An escaped process has only the privileges of UID 1000 ‚Äî not root.\nUser namespace creation is also the key that removes the sudo requirement from your entire container runtime. With CLONE_NEWUSER, unprivileged users can create network namespaces, mount namespaces, and PID namespaces ‚Äî capabilities that currently require CAP_SYS_ADMIN. The kernel&#39;s reasoning: if you can only affect your own namespaced resources, you&#39;re not actually gaining privileges that affect anyone else.\nThe CLONE_NEWUSER flag slots directly into your existing clone() call alongside the other namespace flags. The complication is the UID/GID mapping write sequence ‚Äî a precise ordering requirement enforced by the kernel that causes confusing EPERM errors if violated. We&#39;ll dissect that sequence carefully in Milestone 5.","id":"your-container-is-running-as-root-not-effective-root-inside-a-namespace-actual-root-on-the-host-if-there39s-a-container-escape-vulnerability-a-bug-in-your-pivot_root-sequence-a-missing-seccomp-filter-a-suid-binary-in-the-rootfs-the-escaping-process-has-full-root-access-on-the-host-milestone-5-user-namespaces-and-rootless-containers-solves-this-by-creating-a-user-namespace-where-the-container-process-appears-to-be-root-inside-the-container-but-maps-to-an-unprivileged-uid-on-the-host-the-uid-0-inside-the-container-becomes-uid-1000-on-the-host-an-escaped-process-has-only-the-privileges-of-uid-1000-not-root-user-namespace-creation-is-also-the-key-that-removes-the-sudo-requirement-from-your-entire-container-runtime-with-clone_newuser-unprivileged-users-can-create-network-namespaces-mount-namespaces-and-pid-namespaces-capabilities-that-currently-require-cap_sys_admin-the-kernel39s-reasoning-if-you-can-only-affect-your-own-namespaced-resources-you39re-not-actually-gaining-privileges-that-affect-anyone-else-the-clone_newuser-flag-slots-directly-into-your-existing-clone-call-alongside-the-other-namespace-flags-the-complication-is-the-uidgid-mapping-write-sequence-a-precise-ordering-requirement-enforced-by-the-kernel-that-causes-confusing-eperm-errors-if-violated-we39ll-dissect-that-sequence-carefully-in-milestone-5"},{"level":1,"text":"Milestone 5: User Namespace and Rootless Containers","id":"milestone-5-user-namespace-and-rootless-containers"},{"level":2,"text":"The Misconception You Carry Into This Milestone","id":"the-misconception-you-carry-into-this-milestone"},{"level":2,"text":"The Problem User Namespaces Solve: Privilege Without Exposure","id":"the-problem-user-namespaces-solve-privilege-without-exposure"},{"level":2,"text":"This is why the security research community considers user namespace-based rootless containers categorically more secure than rootful containers, despite providing the same isolation guarantees. The comparison target: Podman&#39;s rootless mode, enabled by default since Podman 1.0 (2018), is built entirely on user namespaces.","id":"this-is-why-the-security-research-community-considers-user-namespace-based-rootless-containers-categorically-more-secure-than-rootful-containers-despite-providing-the-same-isolation-guarantees-the-comparison-target-podman39s-rootless-mode-enabled-by-default-since-podman-10-2018-is-built-entirely-on-user-namespaces"},{"level":2,"text":"How User Namespace UID Mapping Works: The Core Mechanism","id":"how-user-namespace-uid-mapping-works-the-core-mechanism"},{"level":3,"text":"The Mapping File Format in Detail","id":"the-mapping-file-format-in-detail"},{"level":2,"text":"Multiple lines are allowed (up to 340 entries, a kernel limit). Each line must be a non-overlapping range. The kernel validates the mapping when written and rejects invalid configurations with EINVAL.\nThe write must happen from outside the namespace ‚Äî specifically, from a process in the parent user namespace. The container process itself cannot write its own UID map. This is a security invariant: the entity granting capabilities cannot self-grant them. The parent (which you control) writes the mapping that determines what capabilities the child namespace has.","id":"multiple-lines-are-allowed-up-to-340-entries-a-kernel-limit-each-line-must-be-a-non-overlapping-range-the-kernel-validates-the-mapping-when-written-and-rejects-invalid-configurations-with-einval-the-write-must-happen-from-outside-the-namespace-specifically-from-a-process-in-the-parent-user-namespace-the-container-process-itself-cannot-write-its-own-uid-map-this-is-a-security-invariant-the-entity-granting-capabilities-cannot-self-grant-them-the-parent-which-you-control-writes-the-mapping-that-determines-what-capabilities-the-child-namespace-has"},{"level":2,"text":"The setgroups Requirement: A Security Fix Made Permanent","id":"the-setgroups-requirement-a-security-fix-made-permanent"},{"level":2,"text":"Building the UID/GID Map Writer: Complete Implementation","id":"building-the-uidgid-map-writer-complete-implementation"},{"level":2,"text":"The Synchronization Challenge: Mapping Must Precede exec()","id":"the-synchronization-challenge-mapping-must-precede-exec"},{"level":2,"text":"The container process must not proceed to any privileged operation (mounting, sethostname, etc.) until the UID/GID maps are written. Before the mapping is set, the container process has an effectively unmapped UID ‚Äî attempts to call privileged syscalls fail with EPERM because the capability check finds no valid user namespace mapping.\nThe sync pipe naturally enforces this. The container blocks at read(sync_pipe_read, ...). The host writes the maps (step 2), configures cgroups (step 3), sets up networking (step 4), then unblocks the container (step 5). By the time the container reads from the pipe, its namespace is fully configured.","id":"the-container-process-must-not-proceed-to-any-privileged-operation-mounting-sethostname-etc-until-the-uidgid-maps-are-written-before-the-mapping-is-set-the-container-process-has-an-effectively-unmapped-uid-attempts-to-call-privileged-syscalls-fail-with-eperm-because-the-capability-check-finds-no-valid-user-namespace-mapping-the-sync-pipe-naturally-enforces-this-the-container-blocks-at-readsync_pipe_read-the-host-writes-the-maps-step-2-configures-cgroups-step-3-sets-up-networking-step-4-then-unblocks-the-container-step-5-by-the-time-the-container-reads-from-the-pipe-its-namespace-is-fully-configured"},{"level":2,"text":"What Changes Inside container_init() with User Namespaces","id":"what-changes-inside-container_init-with-user-namespaces"},{"level":3,"text":"Verifying Capabilities Inside the Namespace","id":"verifying-capabilities-inside-the-namespace"},{"level":2,"text":"Complete Rootless Runtime: Full Integration","id":"complete-rootless-runtime-full-integration"},{"level":2,"text":"The Capability Scoping Model: How the Kernel Decides","id":"the-capability-scoping-model-how-the-kernel-decides"},{"level":2,"text":"Verifying the Security Boundary From Both Sides","id":"verifying-the-security-boundary-from-both-sides"},{"level":2,"text":"The CapEff: 0000000000000000 line in /proc/&lt;pid&gt;/status is the definitive proof: from the host&#39;s perspective, this process has zero effective capabilities. No CAP_SYS_ADMIN, no CAP_NET_ADMIN, nothing. If this process escapes the container, it has the privilege level of any unprivileged user. Compare this to a rootful container escape, where CapEff would show 0000003fffffffff ‚Äî full capabilities on the host.","id":"the-capeff-0000000000000000-line-in-procltpidgtstatus-is-the-definitive-proof-from-the-host39s-perspective-this-process-has-zero-effective-capabilities-no-cap_sys_admin-no-cap_net_admin-nothing-if-this-process-escapes-the-container-it-has-the-privilege-level-of-any-unprivileged-user-compare-this-to-a-rootful-container-escape-where-capeff-would-show-0000003fffffffff-full-capabilities-on-the-host"},{"level":2,"text":"The Rootless Networking Boundary: Where User Namespaces End","id":"the-rootless-networking-boundary-where-user-namespaces-end"},{"level":3,"text":"slirp4netns: User-Space TCP/IP Stack","id":"slirp4netns-user-space-tcpip-stack"},{"level":3,"text":"The Capability Delegation Pattern","id":"the-capability-delegation-pattern"},{"level":2,"text":"For production rootless environments, a common pattern is capability delegation: a privileged helper process (a small setuid binary or a systemd socket-activated service) performs only the specific host-level operations that require root, then drops all privileges. Podman uses pasta or slirp4netns for networking and newuidmap/newgidmap for extended UID mappings. This keeps the container runtime itself unprivileged while enabling full functionality.","id":"for-production-rootless-environments-a-common-pattern-is-capability-delegation-a-privileged-helper-process-a-small-setuid-binary-or-a-systemd-socket-activated-service-performs-only-the-specific-host-level-operations-that-require-root-then-drops-all-privileges-podman-uses-pasta-or-slirp4netns-for-networking-and-newuidmapnewgidmap-for-extended-uid-mappings-this-keeps-the-container-runtime-itself-unprivileged-while-enabling-full-functionality"},{"level":2,"text":"Subordinate UID Ranges: Supporting Full User ID Spaces","id":"subordinate-uid-ranges-supporting-full-user-id-spaces"},{"level":2,"text":"Hardware Soul: What the Kernel Does During User Namespace Creation","id":"hardware-soul-what-the-kernel-does-during-user-namespace-creation"},{"level":2,"text":"Pitfall Compendium: The Ordering Constraints That Will Cost You Days","id":"pitfall-compendium-the-ordering-constraints-that-will-cost-you-days"},{"level":3,"text":"Pitfall 1: Writing uid_map After the Container Has Already Proceeded","id":"pitfall-1-writing-uid_map-after-the-container-has-already-proceeded"},{"level":3,"text":"Pitfall 2: Writing gid_map Before setgroups","id":"pitfall-2-writing-gid_map-before-setgroups"},{"level":3,"text":"Pitfall 3: CLONE_NEWUSER Must Come First in the Flags","id":"pitfall-3-clone_newuser-must-come-first-in-the-flags"},{"level":3,"text":"Pitfall 4: uid_map Written Twice","id":"pitfall-4-uid_map-written-twice"},{"level":3,"text":"Pitfall 5: Unprivileged userns_clone Disabled (Debian/Ubuntu)","id":"pitfall-5-unprivileged-userns_clone-disabled-debianubuntu"},{"level":3,"text":"Pitfall 6: ID-Mapped Mount Permission Confusion","id":"pitfall-6-id-mapped-mount-permission-confusion"},{"level":2,"text":"The deeper solution is ID-mapped mounts (Linux 5.12+) ‚Äî a kernel feature that applies UID mapping at the mount level, transparently remapping file ownership on-the-fly during filesystem operations. This eliminates the need to pre-chown the rootfs. See the Knowledge Cascade for details.","id":"the-deeper-solution-is-id-mapped-mounts-linux-512-a-kernel-feature-that-applies-uid-mapping-at-the-mount-level-transparently-remapping-file-ownership-on-the-fly-during-filesystem-operations-this-eliminates-the-need-to-pre-chown-the-rootfs-see-the-knowledge-cascade-for-details"},{"level":2,"text":"Verification Checklist","id":"verification-checklist"},{"level":2,"text":"Knowledge Cascade: What User Namespaces Unlock","id":"knowledge-cascade-what-user-namespaces-unlock"},{"level":3,"text":"1. Rootless Containers Are MORE Secure Than Rootful","id":"1-rootless-containers-are-more-secure-than-rootful"},{"level":3,"text":"2. Kubernetes Rootless Nodes and User Namespace Pod Support","id":"2-kubernetes-rootless-nodes-and-user-namespace-pod-support"},{"level":3,"text":"3. ID-Mapped Mounts (Linux 5.12+): Extending UID Mapping to Filesystems","id":"3-id-mapped-mounts-linux-512-extending-uid-mapping-to-filesystems"},{"level":3,"text":"4. Nested Containers: Docker-in-Docker and CI Environments","id":"4-nested-containers-docker-in-docker-and-ci-environments"},{"level":3,"text":"5. The seccomp Connection: Defense in Depth","id":"5-the-seccomp-connection-defense-in-depth"},{"level":2,"text":"The Complete Container Creation Sequence: Full Syscall View","id":"the-complete-container-creation-sequence-full-syscall-view"},{"level":2,"text":"System Overview","id":"system-overview"},{"level":1,"text":"TDD","id":"tdd"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: PID and UTS Namespace Isolation (container-basic-m1)","id":"technical-design-specification-pid-and-uts-namespace-isolation-container-basic-m1"},{"level":2,"text":"1. MODULE CHARTER","id":"1-module-charter"},{"level":2,"text":"2. FILE STRUCTURE","id":"2-file-structure"},{"level":2,"text":"3. COMPLETE DATA MODEL","id":"3-complete-data-model"},{"level":3,"text":"3.1 ContainerConfig Struct","id":"31-containerconfig-struct"},{"level":3,"text":"3.2 Child Stack Layout (x86-64 Physical Memory)","id":"32-child-stack-layout-x86-64-physical-memory"},{"level":3,"text":"3.3 Cache Line Analysis (64-byte lines)","id":"33-cache-line-analysis-64-byte-lines"},{"level":2,"text":"4. HARDWARE SOUL: PHYSICAL CONSTRAINTS","id":"4-hardware-soul-physical-constraints"},{"level":2,"text":"5. INTERFACE CONTRACTS","id":"5-interface-contracts"},{"level":3,"text":"5.1 int container_init(void* arg)","id":"51-int-container_initvoid-arg"},{"level":3,"text":"5.2 void reap_zombies(void)","id":"52-void-reap_zombiesvoid"},{"level":3,"text":"5.3 void* prepare_stack(size_t size)","id":"53-void-prepare_stacksize_t-size"},{"level":2,"text":"6. ALGORITHM SPECIFICATION","id":"6-algorithm-specification"},{"level":3,"text":"6.1 The Clone Orchestration (Parent Side)","id":"61-the-clone-orchestration-parent-side"},{"level":3,"text":"6.2 The PID 1 Init Loop (Child Side)","id":"62-the-pid-1-init-loop-child-side"},{"level":2,"text":"7. ERROR HANDLING MATRIX","id":"7-error-handling-matrix"},{"level":2,"text":"8. IMPLEMENTATION PATH (CHECKPOINTS)","id":"8-implementation-path-checkpoints"},{"level":3,"text":"Phase 1: The Foundation (2 hours)","id":"phase-1-the-foundation-2-hours"},{"level":3,"text":"Phase 2: System Identity (1 hour)","id":"phase-2-system-identity-1-hour"},{"level":3,"text":"Phase 3: The Reaper (2 hours)","id":"phase-3-the-reaper-2-hours"},{"level":3,"text":"Phase 4: Formal Verification (1 hour)","id":"phase-4-formal-verification-1-hour"},{"level":2,"text":"9. TEST SPECIFICATION","id":"9-test-specification"},{"level":3,"text":"9.1 Test Case: PID 1 Confirmation","id":"91-test-case-pid-1-confirmation"},{"level":3,"text":"9.2 Test Case: Hostname Isolation","id":"92-test-case-hostname-isolation"},{"level":3,"text":"9.3 Test Case: Zombie Collection","id":"93-test-case-zombie-collection"},{"level":2,"text":"10. PERFORMANCE TARGETS","id":"10-performance-targets"},{"level":2,"text":"11. MEMORY LAYOUT (ContainerConfig)","id":"11-memory-layout-containerconfig"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Mount Namespace and Filesystem Isolation (container-basic-m2)","id":"technical-design-specification-mount-namespace-and-filesystem-isolation-container-basic-m2"},{"level":2,"text":"1. MODULE CHARTER","id":"1-module-charter"},{"level":2,"text":"2. FILE STRUCTURE","id":"2-file-structure"},{"level":2,"text":"3. COMPLETE DATA MODEL","id":"3-complete-data-model"},{"level":3,"text":"3.1 ContainerConfig Struct (Updated)","id":"31-containerconfig-struct-updated"},{"level":3,"text":"3.2 Mount Flag Bitmasks","id":"32-mount-flag-bitmasks"},{"level":2,"text":"4. HARDWARE SOUL: PHYSICAL CONSTRAINTS","id":"4-hardware-soul-physical-constraints"},{"level":3,"text":"4.1 VFS Tree and Kernel Memory","id":"41-vfs-tree-and-kernel-memory"},{"level":3,"text":"4.2 TLB and Path Resolution","id":"42-tlb-and-path-resolution"},{"level":2,"text":"5. INTERFACE CONTRACTS","id":"5-interface-contracts"},{"level":3,"text":"5.1 int set_mounts_private(void)","id":"51-int-set_mounts_privatevoid"},{"level":3,"text":"5.2 int bind_mount_rootfs(const char* rootfs)","id":"52-int-bind_mount_rootfsconst-char-rootfs"},{"level":3,"text":"5.3 int do_pivot_root(const char* rootfs)","id":"53-int-do_pivot_rootconst-char-rootfs"},{"level":3,"text":"5.4 int mount_pseudofs(void)","id":"54-int-mount_pseudofsvoid"},{"level":2,"text":"6. ALGORITHM SPECIFICATION: THE PIVOT SEQUENCE","id":"6-algorithm-specification-the-pivot-sequence"},{"level":2,"text":"7. ERROR HANDLING MATRIX","id":"7-error-handling-matrix"},{"level":2,"text":"8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Preparation (1 hour)","id":"phase-1-preparation-1-hour"},{"level":3,"text":"Phase 2: The Pivot (2 hours)","id":"phase-2-the-pivot-2-hours"},{"level":3,"text":"Phase 3: Pseudo-Filesystems (1 hour)","id":"phase-3-pseudo-filesystems-1-hour"},{"level":3,"text":"Phase 4: Device Population (1 hour)","id":"phase-4-device-population-1-hour"},{"level":2,"text":"9. TEST SPECIFICATION","id":"9-test-specification"},{"level":3,"text":"9.1 Test: Host Isolation","id":"91-test-host-isolation"},{"level":3,"text":"9.2 Test: Procfs Scoping","id":"92-test-procfs-scoping"},{"level":3,"text":"9.3 Test: Mount Propagation","id":"93-test-mount-propagation"},{"level":2,"text":"10. PERFORMANCE TARGETS","id":"10-performance-targets"},{"level":2,"text":"11. CONCURRENCY SPECIFICATION","id":"11-concurrency-specification"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Network Namespace and Container Networking (container-basic-m3)","id":"technical-design-specification-network-namespace-and-container-networking-container-basic-m3"},{"level":2,"text":"1. MODULE CHARTER","id":"1-module-charter"},{"level":2,"text":"2. FILE STRUCTURE","id":"2-file-structure"},{"level":2,"text":"3. COMPLETE DATA MODEL","id":"3-complete-data-model"},{"level":3,"text":"3.1 ContainerConfig Struct (Updated)","id":"31-containerconfig-struct-updated"},{"level":3,"text":"3.2 Network Topology Constants","id":"32-network-topology-constants"},{"level":3,"text":"3.3 Cache Line Analysis (64B)","id":"33-cache-line-analysis-64b"},{"level":2,"text":"4. HARDWARE SOUL: PHYSICAL CONSTRAINTS","id":"4-hardware-soul-physical-constraints"},{"level":3,"text":"4.1 Packet Path and Namespace Crossing","id":"41-packet-path-and-namespace-crossing"},{"level":3,"text":"4.2 Latency and Pipeline Stalls","id":"42-latency-and-pipeline-stalls"},{"level":2,"text":"5. INTERFACE CONTRACTS","id":"5-interface-contracts"},{"level":3,"text":"5.1 int setup_host_network(pid_t container_pid, const char* outbound_iface)","id":"51-int-setup_host_networkpid_t-container_pid-const-char-outbound_iface"},{"level":3,"text":"5.2 int setup_container_network(void)","id":"52-int-setup_container_networkvoid"},{"level":3,"text":"5.3 int write_resolv_conf(const char* rootfs)","id":"53-int-write_resolv_confconst-char-rootfs"},{"level":2,"text":"6. ALGORITHM SPECIFICATION: THE SYNC PIPE PROTOCOL","id":"6-algorithm-specification-the-sync-pipe-protocol"},{"level":2,"text":"7. ERROR HANDLING MATRIX","id":"7-error-handling-matrix"},{"level":2,"text":"8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Coordination Scaffolding (1 hour)","id":"phase-1-coordination-scaffolding-1-hour"},{"level":3,"text":"Phase 2: Host Infrastructure (2 hours)","id":"phase-2-host-infrastructure-2-hours"},{"level":3,"text":"Phase 3: NAT and Forwarding (1 hour)","id":"phase-3-nat-and-forwarding-1-hour"},{"level":3,"text":"Phase 4: Container Configuration (1 hour)","id":"phase-4-container-configuration-1-hour"},{"level":2,"text":"9. TEST SPECIFICATION","id":"9-test-specification"},{"level":3,"text":"9.1 Test: Localhost Binding","id":"91-test-localhost-binding"},{"level":3,"text":"9.2 Test: Egress Connectivity","id":"92-test-egress-connectivity"},{"level":3,"text":"9.3 Test: Port Isolation","id":"93-test-port-isolation"},{"level":2,"text":"10. PERFORMANCE TARGETS","id":"10-performance-targets"},{"level":2,"text":"11. CONCURRENCY &amp; CLEANUP SPECIFICATION","id":"11-concurrency-amp-cleanup-specification"},{"level":3,"text":"11.1 atexit() Cleanup","id":"111-atexit-cleanup"},{"level":3,"text":"11.2 Syscall List (Reference)","id":"112-syscall-list-reference"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: Cgroups Resource Limits (container-basic-m4)","id":"technical-design-specification-cgroups-resource-limits-container-basic-m4"},{"level":2,"text":"1. MODULE CHARTER","id":"1-module-charter"},{"level":2,"text":"2. FILE STRUCTURE","id":"2-file-structure"},{"level":2,"text":"3. COMPLETE DATA MODEL","id":"3-complete-data-model"},{"level":3,"text":"3.1 CgroupConfig Struct","id":"31-cgroupconfig-struct"},{"level":3,"text":"3.2 Internal Cgroup State","id":"32-internal-cgroup-state"},{"level":2,"text":"4. HARDWARE SOUL: PHYSICAL CONSTRAINTS","id":"4-hardware-soul-physical-constraints"},{"level":3,"text":"4.1 Memory Charging and Page Faults","id":"41-memory-charging-and-page-faults"},{"level":3,"text":"4.2 CFS Scheduler and Pipeline Stalls","id":"42-cfs-scheduler-and-pipeline-stalls"},{"level":3,"text":"4.3 Atomic PID Counting","id":"43-atomic-pid-counting"},{"level":2,"text":"5. INTERFACE CONTRACTS","id":"5-interface-contracts"},{"level":3,"text":"5.1 int detect_cgroup_version(void)","id":"51-int-detect_cgroup_versionvoid"},{"level":3,"text":"5.2 int cgroup_setup(const char* name, pid_t pid, CgroupConfig* cfg)","id":"52-int-cgroup_setupconst-char-name-pid_t-pid-cgroupconfig-cfg"},{"level":3,"text":"5.3 int cgroup_cleanup(const char* name)","id":"53-int-cgroup_cleanupconst-char-name"},{"level":2,"text":"6. ALGORITHM SPECIFICATION","id":"6-algorithm-specification"},{"level":3,"text":"6.1 Subtree Control Enablement (Cgroups v2)","id":"61-subtree-control-enablement-cgroups-v2"},{"level":3,"text":"6.2 The Procs Assignment Window","id":"62-the-procs-assignment-window"},{"level":2,"text":"7. ERROR HANDLING MATRIX","id":"7-error-handling-matrix"},{"level":2,"text":"8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: Detection &amp; Helpers (1 hour)","id":"phase-1-detection-amp-helpers-1-hour"},{"level":3,"text":"Phase 2: Memory &amp; PID Limits (1.5 hours)","id":"phase-2-memory-amp-pid-limits-15-hours"},{"level":3,"text":"Phase 3: CPU Bandwidth (1.5 hours)","id":"phase-3-cpu-bandwidth-15-hours"},{"level":3,"text":"Phase 4: Observability &amp; Cleanup (1 hour)","id":"phase-4-observability-amp-cleanup-1-hour"},{"level":2,"text":"9. TEST SPECIFICATION","id":"9-test-specification"},{"level":3,"text":"9.1 Test: Fork Bomb Containment","id":"91-test-fork-bomb-containment"},{"level":3,"text":"9.2 Test: Memory Hard Limit","id":"92-test-memory-hard-limit"},{"level":3,"text":"9.3 Test: CPU Throttling","id":"93-test-cpu-throttling"},{"level":2,"text":"10. PERFORMANCE TARGETS","id":"10-performance-targets"},{"level":2,"text":"11. CONCURRENCY SPECIFICATION","id":"11-concurrency-specification"},{"level":2,"text":"12. WIRE FORMAT: CGROUP V2 CPU.MAX","id":"12-wire-format-cgroup-v2-cpumax"},{"level":1,"text":"TECHNICAL DESIGN SPECIFICATION: User Namespace and Rootless Containers (container-basic-m5)","id":"technical-design-specification-user-namespace-and-rootless-containers-container-basic-m5"},{"level":2,"text":"1. MODULE CHARTER","id":"1-module-charter"},{"level":2,"text":"2. FILE STRUCTURE","id":"2-file-structure"},{"level":2,"text":"3. COMPLETE DATA MODEL","id":"3-complete-data-model"},{"level":3,"text":"3.1 ContainerConfig Struct (Extended)","id":"31-containerconfig-struct-extended"},{"level":3,"text":"3.2 Capability Struct Layout (Level 3 - Hardware/Kernel)","id":"32-capability-struct-layout-level-3-hardwarekernel"},{"level":2,"text":"4. HARDWARE SOUL: PHYSICAL CONSTRAINTS","id":"4-hardware-soul-physical-constraints"},{"level":3,"text":"4.1 UID Translation Overhead","id":"41-uid-translation-overhead"},{"level":3,"text":"4.2 Cache Line Alignment","id":"42-cache-line-alignment"},{"level":2,"text":"5. INTERFACE CONTRACTS","id":"5-interface-contracts"},{"level":3,"text":"5.1 int proc_write(pid_t pid, const char* file, const char* content)","id":"51-int-proc_writepid_t-pid-const-char-file-const-char-content"},{"level":3,"text":"5.2 int write_uid_gid_maps(pid_t pid, uid_t host_uid, gid_t host_gid)","id":"52-int-write_uid_gid_mapspid_t-pid-uid_t-host_uid-gid_t-host_gid"},{"level":3,"text":"5.3 void verify_capabilities(void)","id":"53-void-verify_capabilitiesvoid"},{"level":2,"text":"6. ALGORITHM SPECIFICATION: THE ROOTLESS HANDSHAKE","id":"6-algorithm-specification-the-rootless-handshake"},{"level":2,"text":"7. ERROR HANDLING MATRIX","id":"7-error-handling-matrix"},{"level":2,"text":"8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS","id":"8-implementation-sequence-with-checkpoints"},{"level":3,"text":"Phase 1: The Helper (1 hour)","id":"phase-1-the-helper-1-hour"},{"level":3,"text":"Phase 2: Rootless Clone (0.5 hours)","id":"phase-2-rootless-clone-05-hours"},{"level":3,"text":"Phase 3: Synchronized Elevation (1 hour)","id":"phase-3-synchronized-elevation-1-hour"},{"level":3,"text":"Phase 4: Capability Verification (1 hour)","id":"phase-4-capability-verification-1-hour"},{"level":3,"text":"Phase 5: Filesystem &amp; Network Integration (1 hour)","id":"phase-5-filesystem-amp-network-integration-1-hour"},{"level":2,"text":"9. TEST SPECIFICATION","id":"9-test-specification"},{"level":3,"text":"9.1 Test: UID Mapping Verification","id":"91-test-uid-mapping-verification"},{"level":3,"text":"9.2 Test: Capability Scoping (Negative Test)","id":"92-test-capability-scoping-negative-test"},{"level":3,"text":"9.3 Test: Rootless Mount","id":"93-test-rootless-mount"},{"level":2,"text":"10. PERFORMANCE TARGETS","id":"10-performance-targets"},{"level":2,"text":"11. CONCURRENCY SPECIFICATION","id":"11-concurrency-specification"},{"level":2,"text":"12. WIRE FORMAT: /proc//uid_map","id":"12-wire-format-procuid_map"},{"level":1,"text":"Project Structure: Container (Basic)","id":"project-structure-container-basic"},{"level":2,"text":"Directory Tree","id":"directory-tree"},{"level":2,"text":"Creation Order","id":"creation-order"},{"level":2,"text":"File Count Summary","id":"file-count-summary"}],"title":"üéØ Project Charter: Container (Basic)","markdown":"# üéØ Project Charter: Container (Basic)\n\n## What You Are Building\nA minimal Linux container runtime from scratch that implements the core primitives used by Docker and runc. You will build a systems-level tool that uses the `clone()` and `unshare()` system calls to create isolated process environments, `pivot_root()` to swap filesystems, and Linux bridges to establish networking. By the end, you will have a binary that can pull an Alpine Linux rootfs and execute a shell inside a sandbox where the host‚Äôs files, processes, and network interfaces are completely invisible.\n\n## Why This Project Exists\nMost developers use containers daily but treat them as \"Lightweight Virtual Machines,\" leading to confusion during debugging and security configuration. Building a container from raw kernel primitives shatters this illusion, revealing that a container is simply an ordinary process with a restricted view of the kernel's global data structures. Learning to manipulate namespaces and cgroups directly is the best way to understand container escape vulnerabilities and production orchestration.\n\n## What You Will Be Able to Do When Done\n- **Implement Process Isolation:** Use PID and UTS namespaces to make a containerized process believe it is PID 1 on a uniquely named host.\n- **Enforce Filesystem Boundaries:** Use `pivot_root` and mount namespaces to provide a private root filesystem, making the host‚Äôs `/etc` and `/root` unreachable.\n- **Construct Virtual Networks:** Create `veth` pairs and Linux bridges to route traffic from an isolated network namespace to the internet via NAT.\n- **Apply Resource Constraints:** Manually configure Cgroup v2 controllers to trigger OOM kills for memory-hungry processes and throttle CPU-intensive tasks.\n- **Enable Rootless Execution:** Map internal root privileges to unprivileged host UIDs using User Namespaces, allowing the container to run without `sudo`.\n\n## Final Deliverable\nA functional container runtime (approx. 800‚Äì1,200 lines of C, Rust, or Go) comprised of a single binary. It will be able to launch an isolated shell that:\n- Runs as a mapped \"root\" user but has no host-level privileges.\n- Has a private IP address and functional DNS resolution.\n- Is strictly limited to defined CPU and Memory quotas.\n- Resides in a directory-based rootfs with no access to host files.\n\n## Is This Project For You?\n**You should start this if you:**\n- Are comfortable with C-style systems programming (manual memory management, pointers).\n- Understand the Linux process lifecycle (`fork`, `exec`, `wait`, `exit`).\n- Have a basic grasp of networking concepts like IP addresses, gateways, and bridges.\n- Want to know exactly what happens inside the kernel when you run `docker run`.\n\n**Come back after you've learned:**\n- [Linux System Programming Basics](https://man7.org/tlpi/) (specifically file descriptors and signals).\n- Basic shell networking commands (`ip link`, `iptables`).\n\n## Estimated Effort\n| Phase | Time |\n|-------|------|\n| PID and UTS Namespace Isolation | ~5 hours |\n| Mount Namespace and `pivot_root` | ~6 hours |\n| Network Namespace and veth Bridge | ~7 hours |\n| Cgroups v2 Resource Limits | ~6 hours |\n| User Namespace and Rootless Setup | ~6 hours |\n| **Total** | **~30 hours** |\n\n## Definition of Done\nThe project is complete when:\n- Running `ps aux` inside the container shows the init process as PID 1 and no host processes.\n- The command `ls /` inside the container shows only the Alpine rootfs; the host filesystem is inaccessible.\n- The container successfully executes `ping 8.8.8.8` and resolves hostnames via `/etc/resolv.conf`.\n- A \"fork bomb\" or memory-exhaustion script run inside the container is terminated by the kernel without crashing the host.\n- The runtime launches the container successfully when executed by a non-root user.\n```\n\n---\n\n# üìö Before You Read This: Prerequisites & Further Reading\n\n> **Read these first.** The Atlas assumes you are familiar with the foundations below.\n> Resources are ordered by when you should encounter them ‚Äî some before you start, some at specific milestones.\n\n### üõ†Ô∏è Core Primitives: Clone & Namespaces\n*   **Spec**: [man 7 namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)\n*   **Code**: [runc/libcontainer/namespaces_linux.go](https://github.com/opencontainers/runc/blob/main/libcontainer/namespaces_linux.go) ‚Äî See how production runtimes map OCI specs to `CLONE_NEW*` flags.\n*   **Best Explanation**: [Namespaces in Operation](https://lwn.net/Articles/531114/) by Michael Kerrisk. Read the \"Introduction\" and \"PID Namespaces\" sections.\n*   **Why**: This series by the man-page maintainer is the definitive technical history of how namespaces were integrated into the kernel.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 1** to understand the \"Why\" behind the bitmask flags you are about to use.\n\n### üßü PID 1 & The Zombie Problem\n*   **Code**: [krallin/tini/src/tini.c](https://github.com/krallin/tini/blob/master/src/tini.c) ‚Äî Specifically the `wait_and_forward_signal` loop.\n*   **Best Explanation**: [Docker and the PID 1 Zombie Reaping Problem](https://blog.phusion.nl/2015/01/20/docker-and-the-pid-1-zombie-reaping-problem/) by Phusion.\n*   **Why**: It explains the Unix process lifecycle transitions (orphaning/reaping) that cause real-world production leaks in containers.\n*   **Pedagogical Timing**: Read **AFTER Milestone 1** to appreciate why your `while(1)` reaper loop is a critical stability feature, not just boilerplate.\n\n### üìÇ Filesystem Isolation: Pivot_root\n*   **Spec**: [man 2 pivot_root](https://man7.org/linux/man-pages/man2/pivot_root.2.html) ‚Äî Read the \"Notes\" section regarding the 7 kernel checks.\n*   **Code**: [runc/libcontainer/rootfs_linux.go](https://github.com/opencontainers/runc/blob/main/libcontainer/rootfs_linux.go) ‚Äî Look for the `pivotRoot` function.\n*   **Best Explanation**: [Path resolution: the kernel's perspective](https://lwn.net/Articles/649115/) by Neil Brown.\n*   **Why**: Understanding how the kernel walks a path is the only way to truly grasp how `pivot_root` physically disconnects the process from the host.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 2** to avoid the \"Invalid Argument\" errors caused by failing the kernel's mount-point requirements.\n\n### üåê Networking: Veth & Bridges\n*   **Code**: [linux/drivers/net/veth.c](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c) ‚Äî See `veth_xmit` to confirm it‚Äôs just a pointer handoff.\n*   **Best Explanation**: [Container Networking From Scratch](https://iximiuz.com/en/posts/container-networking-is-simple/) by Ivan Velichko.\n*   **Why**: It provides the best visual mental model of how packets cross namespace boundaries via virtual wires.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 3** to visualize the \"Two-Phase Dance\" before you implement the synchronization pipe.\n\n### ‚öñÔ∏è Resource Control: Cgroups v2\n*   **Spec**: [Control Group v2 Documentation](https://www.kernel.org/doc/Documentation/admin-guide/cgroup-v2.rst)\n*   **Code**: [systemd/src/core/cgroup.c](https://github.com/systemd/systemd/blob/main/src/core/cgroup.c) ‚Äî How the world's most common init system manages the unified hierarchy.\n*   **Best Explanation**: [Understanding Cgroups v2](https://facebookmicrosites.github.io/cgroup2/docs/overview.html) by Facebook Engineering.\n*   **Why**: Facebook (Meta) was the primary driver for v2; this guide explains the \"No Internal Process\" rule which is the biggest architectural shift from v1.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 4** to understand why you must enable controllers in the `subtree_control` file.\n\n### ‚è±Ô∏è CPU Scheduling: CFS Bandwidth\n*   **Paper**: [Design of the CFS Bandwidth Controller](https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html) (Kernel Docs).\n*   **Best Explanation**: [Demystifying Kubernetes CPU Limits](https://itnext.io/demystifying-kubernetes-cpu-limits-7ed847895088) by Omkar Birade.\n*   **Why**: It explains the \"Sawtooth\" performance degradation caused by period/quota mismatches.\n*   **Pedagogical Timing**: Read **DURING Milestone 4** while you are running the `cpu_stress` test to interpret your `cpu.stat` results.\n\n### üë§ Identity: User Namespaces\n*   **Best Explanation**: [User Namespaces: A Practical Guide](https://lwn.net/Articles/532593/) by Michael Kerrisk.\n*   **Code**: [shadow-utils/src/newuidmap.c](https://github.com/shadow-utils/shadow-utils/blob/master/src/newuidmap.c) ‚Äî The privileged helper that validates `/etc/subuid`.\n*   **Why**: It clarifies the \"Scoped Capabilities\" model which is counter-intuitive to traditional Unix security.\n*   **Pedagogical Timing**: Read **BEFORE Milestone 5** to understand why your container has `CAP_SYS_ADMIN` inside but `EPERM` on the host.\n\n### üõ°Ô∏è Security: Capabilities & Seccomp\n*   **Spec**: [man 7 capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html)\n*   **Best Explanation**: [Container Security: A Guide to User Namespaces and Capabilities](https://sysdig.com/blog/linux-capabilities-docker/) by Sysdig.\n*   **Why**: This resource bridges the gap between raw kernel bits and how Docker/Kubernetes use \"Capability Dropping\" for hardening.\n*   **Pedagogical Timing**: Read **AFTER Milestone 5** to round out your understanding of the container's security profile.\n\n### üê≥ The Production Standard: OCI & Runc\n*   **Spec**: [OCI Runtime Specification](https://github.com/opencontainers/runtime-spec)\n*   **Why**: This is the industry standard that defines exactly how the variables you've built (rootfs, namespaces, cgroups) should be formatted in a `config.json`.\n*   **Pedagogical Timing**: Read **AFTER finishing the project** to see how your \"basic\" container matches the industrial-grade specification.\n\n---\n\n# Container (Basic): Linux Namespace Isolation, Cgroups, and Rootless Containers from Scratch\n\nThis project builds a minimal container runtime from scratch using raw Linux kernel primitives ‚Äî no Docker, no runc, no abstraction layers. You will invoke clone(), unshare(), pivot_root(), and write to cgroup filesystem entries directly, constructing process isolation (PID namespace), filesystem isolation (mount namespace + pivot_root), network isolation (network namespace + veth pairs + bridge), resource limits (cgroups v2), and unprivileged execution (user namespaces) piece by piece.\n\nThe journey reveals that containers are not lightweight VMs ‚Äî they are carefully orchestrated kernel namespace boundaries combined with resource accounting. Every milestone peels back a layer of the illusion that Docker presents, exposing the syscalls, the /proc filesystem mechanics, and the security boundaries that production container runtimes depend on. By the end, you'll have a working container runtime that can isolate a process tree, limit its resources, give it its own network stack, and run without root privileges.\n\nThis is intermediate-level systems programming: you need comfort with fork/exec/wait and basic Linux filesystem concepts, but we'll teach the namespace-specific syscall semantics, mount propagation subtleties, and cgroup filesystem conventions as we go.\n\n\n\n<!-- MS_ID: container-basic-m1 -->\n# Milestone 1: PID and UTS Namespace Isolation\n## The Illusion You Are About to Build\nDocker runs a process. You type `ps aux` inside the container and see one process with PID 1. You type `ps aux` on the host and see that same process with PID 47832. Same process, two different PIDs, two different realities.\nThis isn't virtualization. There's no hypervisor, no emulated CPU, no separate kernel. The process is running natively on your CPU, in your kernel, with your scheduler. The kernel is simply maintaining *two simultaneous views* of the same process tree ‚Äî one for the host, one for the container ‚Äî and each view reports a different PID for the same physical process.\nThat mechanism is called a **PID namespace**, and by the end of this milestone, you will have built it from scratch.\nBut there's a twist. When you clone a process into a new PID namespace, the child doesn't just get a different number ‚Äî it becomes something fundamentally different at the kernel level. It becomes PID 1. And PID 1 has responsibilities that most processes never have to think about.\n\n![PID Namespace Dual View ‚Äî Inside vs Outside](./diagrams/diag-pid-ns-dual-view.svg)\n\n---\n## The Tension: Why Namespaces Exist\n[[EXPLAIN:linux-namespace-concept-‚Äî-what-kernel-resources-are-virtualized|Linux namespace concept ‚Äî what kernel resources are virtualized]]\nImagine running two applications on the same machine. Application A spawns 50 worker processes. Application B also spawns workers. Without isolation, they share:\n- **The PID space**: App A's process might be PID 1000, App B's might be PID 1001. If App B wants to send a signal to its own worker by PID, it must be careful not to accidentally target App A's processes.\n- **The hostname**: If App A calls `sethostname(\"web-server-a\")`, that change is instantly visible to App B. Both apps now think they're on a machine called \"web-server-a.\"\n- **The filesystem mount table**: If App A mounts a secret volume at `/data`, App B can see it.\n- **The network interfaces**: App A can listen on port 80 or sniff App B's network traffic.\nThe traditional Unix answer to this was: \"run as different users and use permissions.\" But permissions are coarse. They prevent *access*, not *awareness*. App B still sees App A's processes in `ps`. They still share a hostname.\nThe Linux kernel answer, developed from 2006 onward, is **namespaces**: partition the kernel's global data structures so each process group sees its own private view. The kernel maintains one process table, one routing table, one mount table ‚Äî but namespace wrappers filter which entries each process can see.\n| Namespace | Flag | Virtualizes |\n|-----------|------|-------------|\n| PID | `CLONE_NEWPID` | Process IDs and process tree |\n| UTS | `CLONE_NEWUTS` | Hostname and NIS domain name |\n| Mount | `CLONE_NEWNS` | Filesystem mount table |\n| Network | `CLONE_NEWNET` | Network interfaces, routing, iptables |\n| User | `CLONE_NEWUSER` | UIDs, GIDs, capabilities |\n| IPC | `CLONE_NEWIPC` | System V IPC, POSIX message queues |\n| Cgroup | `CLONE_NEWCGROUP` | Cgroup root view |\nYou're implementing PID and UTS namespaces in this milestone. Each is created with a single flag passed to `clone()`.\n\n![Linux Namespace Taxonomy ‚Äî What Each Namespace Virtualizes](./diagrams/diag-namespace-taxonomy.svg)\n\n---\n## The Syscall That Makes It Happen: `clone()`\n[[EXPLAIN:clone()-syscall-and-its-relationship-to-fork()|clone() syscall and its relationship to fork()]]\n`fork()` creates a child process that is a copy of the parent, inheriting all the parent's namespaces. That's fine for normal processes ‚Äî but useless for containers, where you *want* the child to live in different namespaces.\n`clone()` is `fork()`'s lower-level cousin. It creates a new process (or thread) with precise control over what is shared and what is separated. Where `fork()` has a fixed behavior, `clone()` takes a `flags` argument that is a bitmask of decisions:\n```c\n#include <sched.h>\n// fork() equivalent in clone():\npid_t pid = clone(child_fn, stack_top, SIGCHLD, arg);\n// Container child with new PID and UTS namespaces:\npid_t pid = clone(child_fn, stack_top,\n                  CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD,\n                  arg);\n```\nThe `SIGCHLD` flag at the end tells the kernel to send SIGCHLD to the parent when the child exits ‚Äî this is what makes `waitpid()` work on the returned PID. Without it, the parent won't get notified of child exit.\nThe key difference from `fork()`: `clone()` requires you to provide a **child stack**. This is where the design gets hardware-specific.\n\n![clone() vs fork() vs unshare()+fork() ‚Äî Syscall Comparison](./diagrams/diag-clone-fork-comparison.svg)\n\n### Stack Allocation for `clone()`\n[[EXPLAIN:stack-allocation-for-clone()-‚Äî-mmap-+-stack-direction|Stack allocation for clone() ‚Äî mmap + stack direction]]\nOn x86-64 Linux, the stack grows **downward** ‚Äî from high addresses toward low addresses. When you call a function, the stack pointer (`rsp`) decreases. When the function returns, it increases.\n`clone()` needs you to hand it a stack for the child to use. The signature says `void *stack` ‚Äî but this means the **bottom** of the allocated memory region, and you must pass the **top** (highest address) to `clone()` as the child's starting stack pointer.\n```c\n#include <sys/mman.h>\n#include <sched.h>\n#define STACK_SIZE (1024 * 1024)  // 1 MiB stack\n// Allocate stack memory using mmap (not malloc ‚Äî mmap gives page-aligned memory\n// with guard page support if you add PROT_NONE at the bottom)\nchar *stack = mmap(NULL, STACK_SIZE,\n                   PROT_READ | PROT_WRITE,\n                   MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n                   -1, 0);\nif (stack == MAP_FAILED) {\n    perror(\"mmap stack\");\n    exit(1);\n}\n// CRITICAL: pass the TOP of the stack (stack + STACK_SIZE),\n// not the bottom. x86-64 stack grows downward.\nchar *stack_top = stack + STACK_SIZE;\npid_t child_pid = clone(container_fn, stack_top,\n                        CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD,\n                        &config);\n```\n`MAP_STACK` is a hint to the kernel that this region will be used as a stack ‚Äî on Linux it's currently a no-op, but it's the correct semantic flag to use. `MAP_ANONYMOUS` means the memory isn't backed by a file. `MAP_PRIVATE` means writes aren't visible to other processes.\nWhy `mmap` instead of `malloc`? Two reasons:\n1. `mmap` returns page-aligned memory (4 KiB alignment), which the kernel requires for stack regions.\n2. You can add a guard page ‚Äî a `PROT_NONE` page at the bottom ‚Äî that causes a segfault if the stack overflows, rather than silent memory corruption.\n```c\n// Optional but recommended: add a guard page at the bottom\n// to catch stack overflows\nmprotect(stack, 4096, PROT_NONE);\n// Then stack_top is still stack + STACK_SIZE\n// The usable stack is [stack + 4096, stack + STACK_SIZE)\n```\n\n![clone() Stack Allocation ‚Äî Memory Layout](./diagrams/diag-clone-stack-layout.svg)\n\n---\n## What Happens Inside the Child\nWhen `clone()` executes with `CLONE_NEWPID`, the child process starts executing `container_fn`. From inside `container_fn`:\n```c\nint container_fn(void *arg) {\n    // This process's PID inside the namespace: 1\n    // This process's PID on the host: whatever clone() returned to the parent\n    printf(\"Inside container, PID = %d\\n\", getpid());\n    // Prints: Inside container, PID = 1\n    // ...\n    return 0;\n}\n```\nThe child is PID 1 inside its namespace. The parent received the host PID from `clone()` ‚Äî perhaps 47832.\nBut being PID 1 is not just a number. This is the revelation.\n---\n## The Revelation: PID 1 Is Not Just a Label\nHere is what most developers assume: PID 1 inside a container is cosmetic. The process is identical to any other child process ‚Äî it just happens to report PID 1 when it calls `getpid()`. The namespace is a labeling system.\n**This assumption is wrong. The kernel treats namespace-PID-1 as a true init process.**\nThree behaviors distinguish PID 1 in any PID namespace from every other process:\n### 1. Signal Immunity\nOn the host, you cannot kill PID 1 (the system's `init`/`systemd`) with `SIGKILL` or `SIGTERM` unless you're root and the process has explicitly registered a signal handler. The same applies to PID 1 inside a namespace: **the kernel will not deliver SIGKILL or SIGTERM to PID 1 from outside the namespace unless that process has installed a handler for those signals.**\nThis is why `docker stop` sends SIGTERM, waits for a grace period (default 10 seconds), then sends SIGKILL. The SIGTERM goes to the container's PID 1. If that process doesn't handle SIGTERM, it won't stop ‚Äî and SIGKILL finally forces it. If your container's entrypoint is a shell script, the script (as PID 1) typically doesn't handle SIGTERM at all, which is why the app inside the script takes 10 seconds to stop.\nTools like `tini` and `dumb-init` exist specifically to be a proper PID 1: they handle signals correctly and forward them to child processes.\n### 2. Orphan Adoption (The Zombie Problem)\nWhen any process dies, its children don't die with it ‚Äî they become **orphans**. The kernel re-parents orphaned processes to PID 1 of their PID namespace. PID 1's job is to call `waitpid()` on these adopted children to collect their exit status and remove their entries from the process table. If PID 1 doesn't do this, the dead children remain in the process table as **zombies** ‚Äî consuming a PID slot and a process table entry.\nIn a container, if your entrypoint launches worker processes and those workers die before the entrypoint calls `wait()`, they become zombies. At scale ‚Äî thousands of containers, each leaking zombie PIDs ‚Äî you can exhaust the kernel's PID limit (default 32,768 on most systems) and prevent any new processes from spawning. This is a real production bug in containers that use naive shell scripts as entrypoints.\nYour implementation must include a zombie reaper.\n### 3. Namespace Death\nWhen PID 1 of a namespace exits, **the kernel kills every other process in that namespace with SIGKILL.** There's no grace period, no cleanup opportunity for those processes ‚Äî they're terminated immediately. This is why your container exits when its main process exits. The kernel isn't \"watching\" for the last process ‚Äî it triggers on the death of exactly PID 1.\n\n![PID 1 Init Responsibilities ‚Äî Zombie Reaping Flow](./diagrams/diag-pid1-init-responsibilities.svg)\n\n---\n## Building the PID Namespace: Complete Implementation\nHere is a complete, working implementation that demonstrates PID namespace creation, UTS namespace creation, PID verification, and zombie reaping:\n```c\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <errno.h>\n#define STACK_SIZE (1024 * 1024)  // 1 MiB\n#define CONTAINER_HOSTNAME \"mycontainer\"\n// Configuration passed to the container's init function\ntypedef struct {\n    char **argv;  // Command to run inside the container\n} container_config_t;\n// Zombie reaper: non-blocking collection of all dead children.\n// Called periodically by the container's PID 1 to prevent zombie accumulation.\n// WNOHANG makes waitpid() return immediately if no child has exited.\nstatic void reap_zombies(void) {\n    int status;\n    pid_t pid;\n    // Loop until waitpid returns 0 (no more dead children)\n    // or -1 (no children at all)\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        if (WIFEXITED(status)) {\n            fprintf(stderr, \"[container-init] reaped PID %d (exit %d)\\n\",\n                    pid, WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            fprintf(stderr, \"[container-init] reaped PID %d (signal %d)\\n\",\n                    pid, WTERMSIG(status));\n        }\n    }\n}\n// The container's init process (PID 1 inside the namespace).\n// This function runs inside the new PID and UTS namespaces.\nstatic int container_init(void *arg) {\n    container_config_t *cfg = (container_config_t *)arg;\n    // ‚îÄ‚îÄ Step 1: Set the container hostname ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // We're inside CLONE_NEWUTS, so this does NOT affect the host.\n    if (sethostname(CONTAINER_HOSTNAME, strlen(CONTAINER_HOSTNAME)) != 0) {\n        perror(\"sethostname\");\n        return 1;\n    }\n    printf(\"[container] hostname set to: %s\\n\", CONTAINER_HOSTNAME);\n    // ‚îÄ‚îÄ Step 2: Verify we are PID 1 inside the namespace ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    printf(\"[container] PID inside namespace: %d\\n\", getpid());\n    // Should print: 1\n    // ‚îÄ‚îÄ Step 3: Spawn the user's requested command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // We fork() here because exec() would replace us ‚Äî and we ARE PID 1.\n    // If PID 1 exec()s and then exits, the namespace dies. We must stay alive.\n    pid_t child = fork();\n    if (child < 0) {\n        perror(\"fork\");\n        return 1;\n    }\n    if (child == 0) {\n        // Child process: run the requested command\n        execvp(cfg->argv[0], cfg->argv);\n        // execvp only returns on error\n        perror(\"execvp\");\n        exit(127);\n    }\n    // ‚îÄ‚îÄ Step 4: Init process event loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // PID 1 must stay alive and reap children.\n    // We wait for the main child to exit, then clean up.\n    while (1) {\n        int status;\n        pid_t exited = waitpid(-1, &status, 0);  // blocking wait for any child\n        if (exited == child) {\n            // Our main process exited ‚Äî time to exit the namespace.\n            // First, reap any lingering zombies.\n            reap_zombies();\n            if (WIFEXITED(status)) {\n                printf(\"[container] main process exited with status %d\\n\",\n                       WEXITSTATUS(status));\n                return WEXITSTATUS(status);\n            } else if (WIFSIGNALED(status)) {\n                printf(\"[container] main process killed by signal %d\\n\",\n                       WTERMSIG(status));\n                return 1;\n            }\n        } else if (exited > 0) {\n            // An adopted orphan child died ‚Äî reap it.\n            fprintf(stderr, \"[container-init] reaped orphan PID %d\\n\", exited);\n        } else if (exited == -1 && errno == ECHILD) {\n            // No more children ‚Äî all done.\n            break;\n        } else if (exited == -1 && errno == EINTR) {\n            // waitpid was interrupted by a signal ‚Äî retry.\n            continue;\n        }\n    }\n    return 0;\n}\nint main(int argc, char **argv) {\n    if (argc < 2) {\n        fprintf(stderr, \"Usage: %s <command> [args...]\\n\", argv[0]);\n        fprintf(stderr, \"Example: %s /bin/sh\\n\", argv[0]);\n        return 1;\n    }\n    // ‚îÄ‚îÄ Allocate child stack ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // clone() requires us to provide a stack for the child.\n    // x86-64: stack grows downward, so we pass stack + STACK_SIZE (the top).\n    char *stack = mmap(NULL, STACK_SIZE,\n                       PROT_READ | PROT_WRITE,\n                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n                       -1, 0);\n    if (stack == MAP_FAILED) {\n        perror(\"mmap\");\n        return 1;\n    }\n    // Guard page: catch stack overflows before they corrupt memory silently\n    if (mprotect(stack, 4096, PROT_NONE) != 0) {\n        perror(\"mprotect guard page\");\n        // Non-fatal: continue without guard page\n    }\n    char *stack_top = stack + STACK_SIZE;\n    // ‚îÄ‚îÄ Configure the container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    container_config_t cfg = {\n        .argv = &argv[1],  // The command the container should run\n    };\n    // ‚îÄ‚îÄ Create the namespaces with clone() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // CLONE_NEWPID: child gets new PID namespace, sees itself as PID 1\n    // CLONE_NEWUTS: child gets new UTS namespace, independent hostname\n    // SIGCHLD: parent receives SIGCHLD when child exits (needed for waitpid)\n    printf(\"[host] Creating container with PID and UTS namespaces...\\n\");\n    pid_t container_pid = clone(container_init, stack_top,\n                                CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD,\n                                &cfg);\n    if (container_pid == -1) {\n        perror(\"clone\");\n        // Common error: EPERM means you need root (or user namespace first)\n        if (errno == EPERM) {\n            fprintf(stderr, \"Hint: run as root or add CAP_SYS_ADMIN capability\\n\");\n        }\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    printf(\"[host] Container running with host PID: %d\\n\", container_pid);\n    printf(\"[host] Inside the container, that process sees PID: 1\\n\");\n    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    int status;\n    if (waitpid(container_pid, &status, 0) == -1) {\n        perror(\"waitpid\");\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    printf(\"[host] Container exited\\n\");\n    // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    munmap(stack, STACK_SIZE);\n    return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n}\n```\nCompile and run:\n```bash\ngcc -o container_m1 container_m1.c\nsudo ./container_m1 /bin/bash\n```\n> **Why `sudo`?** Creating PID namespaces requires `CAP_SYS_ADMIN` ‚Äî a Linux capability that allows privileged operations. Without user namespace support (Milestone 5), you need root. We'll remove this requirement when we implement `CLONE_NEWUSER`.\n---\n## Verifying Isolation: The `/proc/self/status` NSpid Field\nThe kernel exposes namespace PID information through `/proc`. Every process's `/proc/self/status` file contains a line called `NSpid` that lists the process's PID in each nested namespace, from outermost to innermost.\n```bash\n# Inside the container:\ncat /proc/self/status | grep NSpid\n# NSpid:  1\n# Outside the container (replace 47832 with the actual host PID):\ncat /proc/47832/status | grep NSpid\n# NSpid:  47832   1\n```\nThe `NSpid` field shows PIDs separated by tabs. From outside (the host), the container's init process has two PIDs: its host PID (47832) and its namespace-local PID (1). From inside the container, you only see the innermost namespace's view: `1`.\nThis is exactly how container monitoring tools like cAdvisor and Prometheus node-exporter correlate container metrics to host processes ‚Äî they read `/proc/<host_pid>/status` and extract the NSpid field to map between container PID and host PID.\nAdd this verification to your `container_init` function:\n```c\n// Verification: read and display our NSpid from /proc\nstatic void verify_pid_namespace(void) {\n    FILE *f = fopen(\"/proc/self/status\", \"r\");\n    if (!f) {\n        perror(\"fopen /proc/self/status\");\n        return;\n    }\n    char line[256];\n    while (fgets(line, sizeof(line), f)) {\n        // NSpid line format: \"NSpid:\\t<pid1>\\t<pid2>\\t...\\n\"\n        if (strncmp(line, \"NSpid:\", 6) == 0) {\n            printf(\"[container] %s\", line);\n            // Should show: NSpid:\t1\n            break;\n        }\n    }\n    fclose(f);\n}\n```\nCall `verify_pid_namespace()` at the top of `container_init` to see the PID namespace isolation confirmed.\n\n![/proc Filesystem for Container Debugging ‚Äî Key Files](./diagrams/diag-proc-filesystem-container-debugging.svg)\n\n---\n## The UTS Namespace: Independent Hostname\nUTS stands for \"Unix Time-sharing System\" ‚Äî a historical artifact from the `utsname` struct defined in POSIX, which stores the hostname and NIS domain name. The name is obscure; the functionality is simple: each UTS namespace has its own hostname that's writable independently.\n\n![UTS Namespace Hostname Isolation ‚Äî Before/After](./diagrams/diag-uts-hostname-isolation.svg)\n\nWith `CLONE_NEWUTS` in your `clone()` call:\n```c\n// Inside the container (runs in CLONE_NEWUTS):\nsethostname(\"mycontainer\", 11);  // Affects ONLY this namespace\nchar hostname[256];\ngethostname(hostname, sizeof(hostname));\nprintf(\"Container hostname: %s\\n\", hostname);  // mycontainer\n// On the host simultaneously:\n// gethostname() still returns the original host hostname\n// The kernel maintains two separate copies of the hostname string\n```\nVerify from the outside:\n```bash\n# After launching your container:\nhostname\n# your-actual-host\n# Inside the container:\nhostname\n# mycontainer\n# The host hostname is unchanged ‚Äî UTS namespace is working\n```\nThe kernel implementation: each UTS namespace contains a copy of the `new_utsname` struct (64 bytes: nodename[65], sysname[65], etc.). `sethostname()` writes to the struct of the calling process's UTS namespace. Since the container has its own namespace, its `sethostname()` call writes to a different struct than the host's.\n---\n## The `unshare()` Alternative\n`clone()` creates a *new process* in new namespaces. But sometimes you want to move the *current process* into new namespaces without creating a child. That's `unshare()`:\n```c\n#include <sched.h>\n// Current process enters new namespaces\nunshare(CLONE_NEWUTS);  // Now this process is in a new UTS namespace\nsethostname(\"isolated\", 8);  // Only affects this namespace\n```\n**Critical gotcha with `unshare(CLONE_NEWPID)`**: `unshare()` creates the new PID namespace but the *calling process* does NOT move into it. The calling process remains in its original PID namespace. The new namespace becomes active for **children** of the calling process. So after `unshare(CLONE_NEWPID)`, you must `fork()` to get a process that's actually PID 1 inside the new namespace.\n```c\n// Using unshare + fork to create PID namespace:\nunshare(CLONE_NEWPID | CLONE_NEWUTS);\npid_t child = fork();\nif (child == 0) {\n    // Child is PID 1 in the new namespace\n    printf(\"PID: %d\\n\", getpid());  // Prints: 1\n    // ... container init logic ...\n} else {\n    // Parent is still in the original namespace\n    waitpid(child, NULL, 0);\n}\n```\nThe `clone()` approach is cleaner for container runtimes because you get the namespace creation and child process in one atomic call. The `unshare()` approach is used by the `unshare(1)` command-line tool and by Kubernetes when a pod shares namespaces between containers.\n---\n## Hardware Soul: What the Kernel Is Actually Doing\nEvery time your container calls `getpid()`, the kernel executes this path:\n1. `getpid()` ‚Üí `syscall(SYS_getpid)` ‚Üí trap into kernel\n2. Kernel looks up `current->nsproxy->pid_ns_for_children`\n3. Walks the namespace chain to find the PID in the innermost namespace\n4. Returns that PID to userspace\n**Cache behavior**: The `task_struct` (kernel's process descriptor, ~7 KB on modern kernels) is typically cold on first access after a context switch ‚Äî it won't be in L1 cache. The namespace pointer chain adds 2-3 pointer dereferences. On a context switch, the TLB is partially flushed (PCID optimization reduces this), and the first access to the task's memory will incur TLB misses.\nFor `getpid()`: ~50-100 ns on a warm cache, ~500 ns on a cold cache with TLB misses. This is negligible for container overhead ‚Äî namespaces themselves add essentially zero CPU cost to process execution.\n**The `clone()` call itself**: Creating a PID namespace is a kernel-side operation that:\n- Allocates a new `pid_namespace` struct (~200 bytes)\n- Initializes an `idr` (ID radix tree) for PID allocation within the namespace\n- Sets up the namespace's PID 1 slot\n- Copies the parent's signal handlers (with `CLONE_NEWPID`, signals are *not* shared)\n- Allocates the `task_struct` for the child\nTotal cost: one `clone()` with `CLONE_NEWPID | CLONE_NEWUTS` takes approximately 20-50 Œºs on modern hardware ‚Äî comparable to a normal `fork()`. This is why containers start in milliseconds while VMs take seconds: there's no hardware initialization, no firmware, no boot sequence.\n---\n## Pitfall Compendium: The Mistakes That Will Cost You Hours\n### Pitfall 1: Passing Stack Bottom Instead of Stack Top\n```c\n// ‚ùå WRONG: passes the bottom of the stack\npid_t pid = clone(fn, stack, flags, arg);\n// ‚úÖ CORRECT: passes the top (x86-64 stack grows downward)\npid_t pid = clone(fn, stack + STACK_SIZE, flags, arg);\n```\nPassing the wrong end causes immediate memory corruption. The child will write its first stack frame into whatever is below `stack` ‚Äî likely your program's heap or code. The resulting crash is often mysterious: a SIGSEGV in a totally unrelated part of the code, or silent data corruption that causes wrong behavior minutes later.\n### Pitfall 2: `SIGCHLD` Missing from `clone()` Flags\n```c\n// ‚ùå WRONG: parent can't waitpid() without SIGCHLD\npid_t pid = clone(fn, stack_top, CLONE_NEWPID | CLONE_NEWUTS, arg);\n// ‚úÖ CORRECT: SIGCHLD enables the parent to use waitpid()\npid_t pid = clone(fn, stack_top, CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD, arg);\n```\nWithout `SIGCHLD`, `waitpid()` in the parent returns -1 with `ECHILD`. The child becomes an orphan that the host's `init` (systemd) will eventually reap.\n### Pitfall 3: Not Running as Root (EPERM)\n`CLONE_NEWPID` requires `CAP_SYS_ADMIN`. Without root:\n```c\nerrno == EPERM  // \"Operation not permitted\"\n```\nSolution for this milestone: run with `sudo`. Solution for production: combine with `CLONE_NEWUSER` (Milestone 5) to create user namespaces first, which allows unprivileged namespace creation.\n### Pitfall 4: The `exec()` Trap in PID 1\nIf your container's init function directly calls `exec()` (replacing itself), *it* becomes the user process. When that user process exits, PID 1 exits, and the kernel kills the entire namespace. This is fine for single-process containers, but breaks multi-process scenarios. The correct pattern is `fork()` then `exec()` in the child, while the init stays alive as the reaper. This is exactly what Docker does ‚Äî and why `tini` exists as a minimal init that does nothing but the fork-exec-reap loop.\n### Pitfall 5: `unshare(CLONE_NEWPID)` Without Subsequent `fork()`\n```c\n// ‚ùå WRONG: calling process does NOT enter the new PID namespace\nunshare(CLONE_NEWPID);\nprintf(\"PID: %d\\n\", getpid());  // Still shows original PID, not 1\n// ‚úÖ CORRECT: fork() after unshare to get PID 1 in new namespace\nunshare(CLONE_NEWPID);\npid_t child = fork();\nif (child == 0) {\n    printf(\"PID: %d\\n\", getpid());  // Now prints 1\n}\n```\n---\n## Verification Checklist\nAfter implementing and running your code, verify each criterion manually:\n```bash\n# 1. Inside the container, verify PID 1:\necho $$\n# Should print: 1 (if shell is direct child) or close to 1\n# 2. Verify NSpid field shows dual PIDs from outside:\n# From the host, where $HOST_PID is what clone() returned:\ncat /proc/$HOST_PID/status | grep NSpid\n# Should show: NSpid:   <host_pid>    1\n# 3. Verify hostname isolation:\n# Inside container:\nhostname\n# mycontainer\n# On host (new terminal):\nhostname\n# your-original-hostname  (unchanged)\n# 4. Test zombie reaping: inside container, run:\nsleep 100 &   # Start a background process\nkill %1       # Kill it\nps aux        # Should NOT show a zombie (Z state) if reaping works\n# 5. Test namespace death: exit PID 1:\n# Exit the container ‚Äî verify all container processes stop on the host\n# ps aux | grep <command_you_ran>  # Should show nothing\n```\n---\n## Understanding the Process Tree\nWhen your container is running, the host sees:\n```\nsystemd (PID 1)\n‚îî‚îÄ‚îÄ sudo (PID 47830)\n    ‚îî‚îÄ‚îÄ ./container_m1 (PID 47831)  ‚Üê your runtime\n        ‚îî‚îÄ‚îÄ container_init (PID 47832) ‚Üê PID 1 inside namespace\n            ‚îî‚îÄ‚îÄ /bin/bash (PID 47833) ‚Üê PID 2 inside namespace\n```\nInside the container:\n```\ncontainer_init (PID 1)  ‚Üê same process as host's 47832\n‚îî‚îÄ‚îÄ /bin/bash (PID 2)   ‚Üê same process as host's 47833\n```\nThe kernel maintains both views simultaneously. The host sees the real PIDs. The namespace members see the virtualized PIDs. The PID table has entries for both mappings.\n\n![clone() vs fork() vs unshare()+fork() ‚Äî Syscall Comparison](./diagrams/diag-clone-fork-comparison.svg)\n\n---\n## Knowledge Cascade: What This Unlocks\nUnderstanding PID namespaces and init process behavior is a seed that grows into a forest of systems knowledge:\n### 1. Why Docker Uses `tini`\nThe `--init` flag in `docker run --init` injects `tini` as PID 1. `tini` does exactly three things: installs signal handlers, `fork()`s your entrypoint as a child, and loops on `waitpid(-1, ...)`. Without it, if your application forks workers (as Node.js, Python multiprocessing, and Java do), the workers become zombies when they die. At scale ‚Äî thousands of requests, thousands of short-lived workers ‚Äî you exhaust the PID space. `tini`'s entire codebase is ~200 lines of C doing exactly the init loop you just wrote.\n### 2. Signal Delivery Across Namespace Boundaries\nWhen you run `docker kill <container_id>`, Docker's daemon calls `kill(host_pid, SIGTERM)` on the host. The kernel delivers this to the process identified by that host PID ‚Äî which is the container's PID 1. Inside the namespace, PID 1 receives the signal. If PID 1 handles SIGTERM by forwarding it to children, your application gets graceful shutdown. If not, after Docker's grace period, SIGKILL arrives and the namespace forcibly terminates. This is the entire reason for `docker stop`'s 10-second default timeout ‚Äî it's not arbitrary, it's \"how long we give PID 1 to forward SIGTERM and shut down gracefully.\"\n### 3. Kubernetes Pod Pause Containers\nEvery Kubernetes pod has an invisible \"pause\" container that runs `/pause` ‚Äî a binary that does nothing except call `pause()` (wait forever for a signal). This pause container is created first and holds the PID namespace. All other containers in the pod join this namespace via `setns(CLONE_NEWPID)`. The pause container is the pod's PID 1 and zombie reaper. This is why all containers in a pod share a process tree, can see each other's processes with `ps`, and why killing the pause container kills the entire pod. You just learned the mechanism that makes Kubernetes pod semantics work.\n### 4. `clone()` Flag Composition Is Additive and Atomic\n`CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUSER` ‚Äî you can compose any combination in a single `clone()` call. Real container runtimes (`runc`, used by Docker and Kubernetes) create all namespaces atomically in one `clone()` call. This atomicity matters: there's no window between namespace creations where the process is in a partial state. Next milestone (mount namespaces), you'll add `CLONE_NEWNS` to this call and everything composes cleanly.\n### 5. `/proc` as the Namespace Debugging Interface\n`/proc/<pid>/ns/` directory contains symbolic links for each namespace the process belongs to:\n```bash\nls -la /proc/47832/ns/\n# pid -> pid:[4026532189]\n# uts -> uts:[4026532190]\n# mnt -> mnt:[4026531840]  (still host's mount namespace ‚Äî next milestone!)\n```\nThe numbers in brackets are namespace inode numbers. Two processes in the same namespace have the same inode number for that namespace type. This is how `nsenter(1)` finds and joins existing namespaces ‚Äî it opens the symlink and calls `setns()` with the file descriptor.\n---\n## Looking Ahead\nYou now have a container that isolates its process tree and hostname. But if you run `ls /` inside your container, you see the host's filesystem. If you run `ip addr`, you see the host's network interfaces. If you spawn 10,000 processes inside your container, they consume host PIDs.\nThe next milestone (Mount Namespace and Filesystem Isolation) adds `CLONE_NEWNS` to your `clone()` call and uses `pivot_root()` to swap the container's root filesystem. You'll finally see a truly isolated filesystem view ‚Äî and understand why `chroot` is weaker than `pivot_root` from a security standpoint.\nThe `CLONE_NEWPID | CLONE_NEWUTS` pair you've built is the foundation. Every subsequent namespace flags into the same `clone()` call. The architecture you've established ‚Äî `container_init` as PID 1, zombie reaper loop, config struct passed through `clone()` ‚Äî is the skeleton the rest of the milestones flesh out.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m2 -->\n<!-- MS_ID: container-basic-m2 -->\n# Milestone 2: Mount Namespace and Filesystem Isolation\n## The Illusion You Are About to Shatter\nRun your container from Milestone 1. Inside the shell, type `ls /`. You'll see the host's root filesystem ‚Äî `/etc`, `/home`, `/var`, `/root`. Every file on your machine is accessible. Your \"container\" is a lie.\nThe process tree is isolated. The hostname is isolated. But the filesystem is completely open. A process inside your container can read `/etc/passwd`, write to `/tmp`, and ‚Äî if it has the right permissions ‚Äî modify files that affect the host system. That's not a container. That's a renamed terminal window.\nThis milestone closes that gap. You will give the container its own root filesystem, one that contains only what you choose to put there. The host's filesystem will not just be hidden ‚Äî it will be genuinely inaccessible, unreachable through any path, invisible to the kernel's path resolution engine for processes inside the container.\nThe mechanism that makes this real is called `pivot_root()`. But before we get there, you need to understand why the obvious solution ‚Äî `chroot()` ‚Äî is not good enough, and why every production container runtime from Docker to Kubernetes uses `pivot_root()` instead.\n\n![chroot() vs pivot_root() Security Comparison](./diagrams/diag-chroot-vs-pivot-root.svg)\n\n---\n## The Fundamental Tension: Shared Filesystem, Multiple Worlds\n[[EXPLAIN:linux-namespace-concept-‚Äî-what-kernel-resources-are-virtualized|Linux namespace concept ‚Äî what kernel resources are virtualized]]\nThe Linux filesystem is a single global tree rooted at `/`. Every file, directory, device, and pseudo-filesystem hangs from that single root. The kernel maintains a **mount table** ‚Äî a data structure that maps directory paths to filesystem objects. When you open `/etc/passwd`, the kernel walks this table, finds which filesystem is mounted at `/` or `/etc`, and reads from it.\nMultiple processes on the same machine share this mount table. When you run `mount /dev/sdb1 /mnt/disk`, every process on the system immediately sees the new filesystem at `/mnt/disk`. Mount operations are global ‚Äî or at least they were, until Linux 2.4.19 introduced mount namespaces in 2002.\nThe constraint: **you cannot give a process its own private filesystem view without either hardware virtualization (a hypervisor with emulated disks) or kernel namespace machinery.** Hardware virtualization is expensive ‚Äî it requires copying entire filesystem images and booting a kernel. Namespace machinery is essentially free ‚Äî it's a pointer in the kernel's process descriptor.\nThe solution the kernel offers: give each process group its own mount table ‚Äî a **mount namespace**. Operations in one namespace don't affect others. A process in namespace A can mount and unmount filesystems freely; namespace B is untouched. Combined with a root directory swap (pivot_root), the container gets its own root ‚Äî and the host's filesystem disappears.\n\n![Mount Propagation Types ‚Äî Shared, Private, Slave](./diagrams/diag-mount-propagation-types.svg)\n\n---\n## Why `chroot()` Is Not Enough: The Revelation\nHere is what most developers believe when they first encounter container isolation: `chroot()` provides real filesystem isolation. If you `chroot(\"/container/rootfs\")`, the process can't escape to the host filesystem because `/` now points to `/container/rootfs`. The host's `/etc` is unreachable.\n**This belief is wrong.** `chroot()` is security theater for anything running with elevated privileges.\n`chroot()` does exactly one thing: it changes the **path resolution starting point** for the calling process. The kernel sets `task_struct->fs->root` to the new directory. When the process calls `open(\"/etc/passwd\")`, the kernel starts path resolution at the new root instead of the real root. That's the entire implementation ‚Äî a pointer change.\nWhat `chroot()` does *not* do:\n1. It does not create a new mount namespace. The process still has access to the same mount table as the host.\n2. It does not remove the kernel's reference to the real root filesystem.\n3. It does not prevent a privileged process from escaping.\nThe classic `chroot()` escape ‚Äî known for decades, present in every security textbook ‚Äî works like this for a process with `CAP_SYS_CHROOT`:\n```c\n// Classic chroot escape (educational ‚Äî shows why chroot is insufficient)\n// This works because chroot() only changes a pointer, not actual namespace boundaries\n// Step 1: We're chrooted to /container/rootfs\n// Step 2: Create a temporary directory to chroot into\nmkdir(\"escape_tmp\", 0755);\n// Step 3: Chroot into our temporary directory (moving root \"forward\")\nchroot(\"escape_tmp\");\n// Step 4: Walk up the directory tree past the original chroot boundary\n// Because chroot() didn't change the mount namespace, \"..\" still works\n// across the original chroot boundary if you chroot to a subdirectory\nfor (int i = 0; i < 256; i++) {\n    chdir(\"..\");\n}\n// Step 5: Chroot to the current directory ‚Äî which is now the real /\nchroot(\".\");\n// We're now unchrooted. Host filesystem fully accessible.\n// open(\"/etc/shadow\", O_RDONLY) ‚Äî works.\n```\nThis escape works because `chroot()` is a *per-process* path resolution change, not a *namespace* change. The mount table is still shared. The kernel's VFS (Virtual Filesystem Switch) layer still has references to the real root. A sufficiently privileged process can navigate above the chroot boundary by abusing the still-shared mount namespace.\n[[EXPLAIN:pivot_root()-vs-chroot()-security-guarantees|pivot_root() vs chroot() security guarantees]]\n`pivot_root()` is categorically different. It operates at the **mount namespace level**. It atomically:\n1. Makes the new root directory the root mount point of the current mount namespace\n2. Moves the old root to a subdirectory you specify (so you can unmount it)\n3. Optionally allows you to completely unmount the old root ‚Äî removing every kernel reference to it\nAfter `pivot_root()` followed by `umount2(old_root, MNT_DETACH)`, there is no path the container can walk to reach the host filesystem. There's no `..` trick, no `chroot` escape, no file descriptor inheritance trick that works ‚Äî because the kernel literally has no mount namespace entry pointing to the host's filesystem tree. It's not hidden. It's *gone* from the container's perspective.\nThis is why Docker, containerd, runc, LXC, podman, and every serious container runtime use `pivot_root()`. `chroot()` is a 1979 Unix feature. `pivot_root()` is a 2001 Linux feature built specifically for containers (and Linux-VServer before that).\nThe Leaky Vessels CVE (2024) exploited a container runtime that didn't properly complete the old-root unmount sequence ‚Äî leaving a kernel reference to the host filesystem accessible through a specific file descriptor path. Understanding the `pivot_root()` + `umount2(MNT_DETACH)` sequence exactly is not academic. It's the difference between a container and a container escape.\n---\n## Mount Namespaces: The Foundation\nBefore `pivot_root()` can work, you need a mount namespace. A mount namespace is a private copy of the mount table ‚Äî the kernel's mapping of directory paths to filesystem objects.\nCreating one is simple: add `CLONE_NEWNS` to your `clone()` call:\n```c\npid_t container_pid = clone(container_init, stack_top,\n                            CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | SIGCHLD,\n                            &cfg);\n```\n`CLONE_NEWNS` is historically named ‚Äî \"NS\" originally referred only to mount namespaces because they were the first namespace type added to Linux (2.4.19, 2002). All other namespace flags were added later with more descriptive names (`CLONE_NEWPID`, `CLONE_NEWNET`, etc.).\nWhen the child process starts with `CLONE_NEWNS`, it receives a **copy** of the parent's mount table. Initially, the child's mount namespace looks identical to the host's ‚Äî same filesystems, same mount points. The isolation begins when the child makes mount/unmount operations: those changes are invisible to the host, and the host's subsequent mounts are invisible to the child.\nBut there's a critical subtlety: even with a private mount namespace, if mount events can **propagate** between namespaces, you lose isolation. This is where mount propagation types become essential.\n---\n## Mount Propagation: The Hidden Complexity\n[[EXPLAIN:mount-propagation-types-(shared,-private,-slave)|Mount propagation types (shared, private, slave)]]\nLinux mounts have a propagation mode that determines whether mount/unmount events in one namespace (or peer group) propagate to other namespaces. There are four modes:\n| Mode | Flag | Behavior |\n|------|------|----------|\n| **Shared** | `MS_SHARED` | Mount events propagate to all peer mounts in the same peer group, and new mounts in the subtree are shared |\n| **Private** | `MS_PRIVATE` | Mount events are completely isolated ‚Äî no propagation in or out |\n| **Slave** | `MS_SLAVE` | Mount events propagate FROM the master TO this mount, but not in reverse |\n| **Unbindable** | `MS_UNBINDABLE` | Private + cannot be bind-mounted |\nOn a typical Linux system, the root filesystem is mounted as **shared** (`MS_SHARED`). This means if you create a mount namespace with `CLONE_NEWNS`, your copy of the mount table inherits the shared propagation type. Any mount operation you perform inside the container **immediately propagates to the host's mount namespace**.\nThis is the subtle trap: `CLONE_NEWNS` gives you a copy of the mount table, but not isolation from propagation. If you mount `/proc` inside your container (for the container's process list) and the root is still shared, that mount event propagates back to the host. The host's `/proc` doesn't change (because the bind would fail due to path differences), but the propagation attempt happens ‚Äî and in more complex scenarios, it causes real leaks.\nThe fix: immediately after entering the new mount namespace, make the root private:\n```c\n// Inside container_init, FIRST thing after entering the mount namespace:\n// MS_REC ensures the flag applies recursively to all submounts\nif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL) != 0) {\n    perror(\"mount MS_PRIVATE\");\n    return 1;\n}\n```\nThis `mount()` call doesn't mount anything new. The `NULL` source and `MS_PRIVATE` flag with `MS_REC` recursively change the propagation type of every existing mount in the namespace to private. From this point forward, no mount event in the container leaks to the host, and no host mount event propagates into the container.\n**Why `MS_REC`?** The mount table is a tree. `/` might be shared, but `/proc` has its own mount entry, `/sys` has its own, and so on. Without `MS_REC`, you'd only make `/` private ‚Äî all sub-mounts would remain shared. `MS_REC` walks the entire tree recursively.\n\n![Mount Propagation Types ‚Äî Shared, Private, Slave](./diagrams/diag-mount-propagation-types.svg)\n\n> **Connection: Docker Volumes and Bind Mounts**\n> This propagation model is exactly why `docker run -v /host/data:/container/data` works selectively. The bind mount uses `MS_SHARED` propagation on the specific mount point ‚Äî so changes to `/host/data` are visible inside the container and vice versa. But the container's other mounts remain private. This is also why Kubernetes `hostPath` mounts with `MountPropagation: Bidirectional` are considered dangerous ‚Äî they create shared-propagation mounts that allow the container to affect the host's filesystem namespace.\n---\n## Building the New Root Filesystem\nBefore `pivot_root()`, you need something to pivot to: a new root filesystem with the minimal structure a container process needs.\n\n![Minimal Container Root Filesystem ‚Äî Directory Layout](./diagrams/diag-container-rootfs-structure.svg)\n\nThe minimal directory structure:\n```\n/newroot/\n‚îú‚îÄ‚îÄ proc/          # For mounting /proc (container process list)\n‚îú‚îÄ‚îÄ sys/           # For mounting /sys (kernel parameters)\n‚îú‚îÄ‚îÄ dev/           # For device nodes\n‚îÇ   ‚îú‚îÄ‚îÄ null       # /dev/null (programs write garbage here)\n‚îÇ   ‚îú‚îÄ‚îÄ zero       # /dev/zero (source of zero bytes)\n‚îÇ   ‚îú‚îÄ‚îÄ random     # /dev/random (entropy source)\n‚îÇ   ‚îî‚îÄ‚îÄ urandom    # /dev/urandom (non-blocking entropy)\n‚îú‚îÄ‚îÄ etc/\n‚îÇ   ‚îî‚îÄ‚îÄ resolv.conf  # DNS configuration\n‚îú‚îÄ‚îÄ tmp/           # Temporary files\n‚îú‚îÄ‚îÄ .pivot_old/    # Staging directory for old root during pivot\n‚îî‚îÄ‚îÄ [your container's rootfs content]\n```\nFor testing, you can use a minimal Alpine Linux rootfs or a directory tree you construct manually. For the purposes of this implementation, we'll assume you have a rootfs directory at a known path.\nCreate the structure in your setup:\n```c\n#define _GNU_SOURCE\n#include <sys/stat.h>\n#include <sys/types.h>\n// Create essential directories in the new rootfs\nstatic int create_rootfs_dirs(const char *rootfs) {\n    const char *dirs[] = {\n        \"proc\", \"sys\", \"dev\", \"etc\", \"tmp\", \".pivot_old\", NULL\n    };\n    char path[1024];\n    for (int i = 0; dirs[i] != NULL; i++) {\n        snprintf(path, sizeof(path), \"%s/%s\", rootfs, dirs[i]);\n        if (mkdir(path, 0755) != 0 && errno != EEXIST) {\n            perror(path);\n            return -1;\n        }\n    }\n    return 0;\n}\n```\n---\n## The `pivot_root()` Sequence: Step by Step\n`pivot_root()` has precise requirements. Violating any of them returns `EINVAL` ‚Äî a frustratingly generic error code. Let's understand each requirement before writing the code.\n\n![pivot_root() Atomic Root Swap ‚Äî Step-by-Step](./diagrams/diag-pivot-root-sequence.svg)\n\n**Requirement 1: The new root must be a mount point.**\n`pivot_root()` operates on mount points ‚Äî entries in the mount table ‚Äî not arbitrary directories. A directory that isn't a mount point isn't tracked by the mount table, so `pivot_root()` can't swap it in as root.\nHow do you make a directory a mount point without mounting a separate filesystem onto it? The **bind-mount-to-self** trick:\n```c\n// Bind-mount newroot onto itself ‚Äî now it IS a mount point\nif (mount(rootfs_path, rootfs_path, NULL, MS_BIND | MS_REC, NULL) != 0) {\n    perror(\"bind-mount rootfs to itself\");\n    return -1;\n}\n```\n`MS_BIND` creates a bind mount ‚Äî it makes a directory accessible at another path (or the same path in this case). The source and destination are the same path. The effect: the kernel creates a new mount table entry pointing to the same filesystem block device, but at this specific path. Now the directory is a mount point. `MS_REC` ensures any nested mounts within the directory are also bind-mounted.\n**Requirement 2: The new root and the current root must be on different filesystems** (or the new root must be a bind mount, which satisfies this in practice).\nThe bind-mount-to-self satisfies this because the bind mount is a *new mount point* ‚Äî even though it points to the same underlying filesystem, it's a distinct entry in the mount table with a new mount ID.\n**Requirement 3: The old root destination must exist inside the new root.**\n`pivot_root(new_root, put_old)` moves the old root to `put_old`. This directory must exist inside `new_root`. In our case: `rootfs/.pivot_old`.\n**The complete `pivot_root()` sequence:**\n```c\nstatic int pivot_to_rootfs(const char *rootfs) {\n    char old_root[1024];\n    snprintf(old_root, sizeof(old_root), \"%s/.pivot_old\", rootfs);\n    // ‚îÄ‚îÄ Step 1: Bind-mount rootfs to itself to make it a mount point ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL) != 0) {\n        perror(\"bind-mount rootfs to self\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 2: pivot_root ‚Äî atomically swap root filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // new_root: our container rootfs\n    // put_old:  where to mount the current root (must be inside new_root)\n    if (syscall(SYS_pivot_root, rootfs, old_root) != 0) {\n        perror(\"pivot_root\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 3: Change working directory to new root ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // After pivot_root, cwd might be in the old root ‚Äî cd to / to fix this\n    if (chdir(\"/\") != 0) {\n        perror(\"chdir /\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 4: Unmount the old root with MNT_DETACH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // MNT_DETACH: lazy unmount ‚Äî the filesystem becomes unreachable\n    // immediately, but the kernel waits for all open file descriptors\n    // on it to close before freeing the memory.\n    if (umount2(\"/.pivot_old\", MNT_DETACH) != 0) {\n        perror(\"umount2 old root\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 5: Remove the staging directory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (rmdir(\"/.pivot_old\") != 0) {\n        // Non-fatal ‚Äî the unmount succeeded, this is cosmetic cleanup\n        perror(\"rmdir .pivot_old\");\n    }\n    return 0;\n}\n```\n> **Note on `syscall(SYS_pivot_root, ...)`**: The `pivot_root()` system call is not wrapped by glibc in a standard header-accessible function (unlike `mount()`, `clone()`, etc.). You must call it via `syscall()` directly. Include `<sys/syscall.h>` and `<unistd.h>`.\n### What Happens at Each Step in the Kernel\n**Before pivot_root**: Mount namespace contains:\n```\n/          ‚Üí host root filesystem (device sda1)\n/proc      ‚Üí procfs\n/sys       ‚Üí sysfs\n/container/rootfs  ‚Üí (bind mount of ext4 filesystem)\n```\n**After `pivot_root(rootfs, rootfs/.pivot_old)`**: Mount namespace contains:\n```\n/             ‚Üí container rootfs (what was /container/rootfs)\n/.pivot_old   ‚Üí old host root filesystem\n/.pivot_old/proc   ‚Üí host procfs\n/.pivot_old/sys    ‚Üí host sysfs\n```\n**After `umount2(\"/.pivot_old\", MNT_DETACH)`**: Mount namespace contains:\n```\n/             ‚Üí container rootfs only\n```\nThe host filesystem is gone from the mount table. The kernel's VFS layer has no path entry leading to it. `open(\"/etc/shadow\")` resolves to the container's `/etc/shadow` ‚Äî if there is one. If not, `ENOENT`. The host's `/etc/shadow` is unreachable.\n`MNT_DETACH` \n> **üîë Foundation: MNT_DETACH lazy unmount**\n> \n> ### 1. What it IS\n`MNT_DETACH` (often called a \"lazy\" unmount) is a flag for the `umount2` system call that allows you to unmount a filesystem even if it is currently \"busy\"‚Äîmeaning processes still have open file descriptors or are using a directory on that mount as their current working directory. \n\nIn a standard unmount, the system checks if any process is using the mount; if so, it returns a `Device or resource busy` error. With `MNT_DETACH`, the kernel immediately performs a \"partial\" unmount: it removes the mount point from the shared directory hierarchy (the mount namespace). To any new process, the directory looks empty or disconnected. However, the kernel keeps the actual filesystem alive in the background until the very last process using it closes its files or exits.\n\n### 2. WHY you need it right now\nIn modern system architecture‚Äîparticularly involving containers, namespaces, or automated cleanup scripts‚Äîyou often encounter the \"Busy\" error. For example, if a container crashes but a background logging process still holds a file handle on its volume, a standard `umount` will fail, leaving your system in a messy, inconsistent state.\n\n`MNT_DETACH` allows you to \"fire and forget.\" You can signal that a mount should no longer be part of the system's accessible pathing, ensuring that no *new* processes can enter that filesystem, while allowing existing processes to finish their work gracefully without causing your cleanup script to hang or error out.\n\n### 3. ONE key insight or mental model\n**The \"Ghost\" Filesystem:** Think of `MNT_DETACH` as making a building invisible and removing its address from the city map, while allowing the people already inside to finish their business and leave through the back door. Once the last person leaves, the building finally vanishes. \n\n**Remember:** It provides **immediate invisibility** but **delayed destruction**.\n deserves explanation: it performs a **lazy unmount**. The mount point becomes immediately invisible and unreachable from new path lookups. However, if any process has an open file descriptor pointing into that filesystem (e.g., a file from the old root is still open), the kernel keeps the filesystem alive until those descriptors are closed. Only then is the memory freed. This is safer than a \"force\" unmount (`MNT_FORCE`) which would close those file descriptors forcibly ‚Äî potentially corrupting data. For our use case, the container's init process shouldn't have open files in the old root, so `MNT_DETACH` completes effectively immediately.\n---\n## Mounting Essential Pseudo-Filesystems\nAfter `pivot_root()`, the container's process tree is completely disconnected from the host filesystem. But several pseudo-filesystems need to be re-mounted inside the container for basic functionality.\nThese are not real filesystems on disk. They are **kernel interfaces** exposed as a filesystem API. The kernel generates their contents dynamically in response to reads and writes.\n\n![/proc Mount and PID Namespace Interaction](./diagrams/diag-proc-mount-pid-ns-interaction.svg)\n\n### `/proc` ‚Äî Process and Kernel Information\n`/proc` is not files on disk. It's the kernel exposing its internal data structures as a filesystem. When you read `/proc/self/status`, the kernel doesn't read from disk ‚Äî it formats the current process's `task_struct` into text and returns it. When you read `/proc/cpuinfo`, the kernel reads CPU registers and formats them.\n**Critical interaction with PID namespaces**: when you mount `/proc` inside a container that has `CLONE_NEWPID`, the resulting `/proc` shows only the processes in that PID namespace. From inside the container, `ls /proc/` shows only the container's PIDs (1, 2, etc.). The host processes are invisible.\nIf you mount `/proc` *without* a PID namespace, the container would see the host's entire process tree. This is a real mistake: running a container with a mount namespace but *without* a PID namespace, then mounting `/proc`, gives the container a window into all host processes.\n```c\nstatic int mount_proc(void) {\n    // Mount a fresh procfs at /proc inside our new root\n    // MS_NOSUID: prevent setuid execution through proc paths\n    // MS_NOEXEC: prevent executing files through proc paths\n    // MS_NODEV: prevent device access through proc paths\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL) != 0) {\n        perror(\"mount /proc\");\n        return -1;\n    }\n    return 0;\n}\n```\nThe first argument `\"proc\"` is the source ‚Äî for pseudo-filesystems, this is typically the filesystem type name used as a conventional label (not a device path). The third argument `\"proc\"` is the filesystem type. The kernel looks up the registered `proc_fs_type` and creates a fresh procfs instance scoped to the current PID namespace.\n### `/sys` ‚Äî Kernel and Device Parameters\n`/sys` (sysfs) exposes the kernel's internal device model ‚Äî PCI buses, block devices, network interfaces, power management. Like `/proc`, it's kernel memory exposed as a filesystem.\n```c\nstatic int mount_sysfs(void) {\n    if (mount(\"sysfs\", \"/sys\", \"sysfs\",\n              MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_RDONLY, NULL) != 0) {\n        perror(\"mount /sys\");\n        return -1;\n    }\n    return 0;\n}\n```\n`MS_RDONLY` is worth discussing: making `/sys` read-only inside the container prevents the container from modifying kernel parameters (e.g., writing to `/sys/kernel/mm/transparent_hugepage/enabled`). Production containers almost always mount `/sys` read-only. Docker uses a read-only `/sys` with specific paths bind-mounted writable for cgroup operations.\n### `/dev` ‚Äî Device Nodes\nDevice nodes are special files that the kernel uses to communicate with device drivers. `/dev/null`, `/dev/zero`, `/dev/urandom` are not files on disk ‚Äî they're kernel objects that implement the `file_operations` interface.\nA freshly `pivot_root()`'d container has an empty `/dev`. Programs that call `open(\"/dev/null\", ...)` get `ENOENT`. You have two options:\n**Option A: `tmpfs` + bind-mount specific devices**\n```c\nstatic int mount_dev(void) {\n    // Mount a tmpfs at /dev ‚Äî an in-memory filesystem for device nodes\n    if (mount(\"tmpfs\", \"/dev\", \"tmpfs\",\n              MS_NOSUID | MS_STRICTATIME,\n              \"mode=755,size=65536k\") != 0) {\n        perror(\"mount /dev tmpfs\");\n        return -1;\n    }\n    // Bind-mount essential device nodes from the host\n    // This is safe because we bind specific nodes, not the entire /dev\n    const char *devices[] = {\n        \"null\", \"zero\", \"random\", \"urandom\", \"tty\", \"full\", NULL\n    };\n    char src[1024], dst[1024];\n    for (int i = 0; devices[i] != NULL; i++) {\n        snprintf(src, sizeof(src), \"/dev/%s\", devices[i]);\n        snprintf(dst, sizeof(dst), \"/dev/%s\", devices[i]);\n        // Create the destination file (bind mounts require the target to exist)\n        // Device nodes require open() followed by mknod-equivalent, or just\n        // create an empty file and bind-mount over it\n        int fd = open(dst, O_CREAT | O_WRONLY, 0666);\n        if (fd >= 0) close(fd);\n        if (mount(src, dst, NULL, MS_BIND, NULL) != 0) {\n            perror(src);\n            // Non-fatal: continue with other devices\n        }\n    }\n    return 0;\n}\n```\n**Option B: `mknod()` to create device nodes directly**\nThis requires `CAP_MKNOD` (or user namespace mapping in Milestone 5):\n```c\n// Create /dev/null: character device, major 1, minor 3\nif (mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3)) != 0) {\n    perror(\"mknod /dev/null\");\n}\n// /dev/zero: major 1, minor 5\n// /dev/urandom: major 1, minor 9\n// /dev/random: major 1, minor 8\n```\nThe bind-mount approach (Option A) is what Docker and runc use for most scenarios ‚Äî it avoids requiring `CAP_MKNOD` by inheriting device nodes from the host where they already exist, then making them individually visible inside the container.\n---\n## Complete Implementation: Filesystem Isolation\nHere is the complete implementation of the mount namespace and filesystem isolation, integrated with the Milestone 1 structure:\n```c\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#define STACK_SIZE (1024 * 1024)\n#define CONTAINER_HOSTNAME \"mycontainer\"\ntypedef struct {\n    char  *rootfs;   // Path to the container's root filesystem on the host\n    char **argv;     // Command to execute inside the container\n} container_config_t;\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Filesystem Setup Functions\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Step 1: Make all existing mounts private so container mounts\n// don't propagate to the host (and host mounts don't propagate in).\nstatic int set_mounts_private(void) {\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL) != 0) {\n        perror(\"mount MS_REC|MS_PRIVATE on /\");\n        return -1;\n    }\n    return 0;\n}\n// Step 2: Bind-mount the rootfs directory onto itself.\n// pivot_root() requires new_root to be a mount point.\n// Without this, pivot_root() fails with EINVAL.\nstatic int bind_mount_rootfs(const char *rootfs) {\n    if (mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL) != 0) {\n        perror(\"bind-mount rootfs to self\");\n        return -1;\n    }\n    return 0;\n}\n// Step 3: Atomically swap the root filesystem.\n// old root lands in rootfs/.pivot_old, then we detach it.\nstatic int do_pivot_root(const char *rootfs) {\n    char old_root[1024];\n    snprintf(old_root, sizeof(old_root), \"%s/.pivot_old\", rootfs);\n    // Ensure the staging directory exists\n    if (mkdir(old_root, 0700) != 0 && errno != EEXIST) {\n        perror(\"mkdir .pivot_old\");\n        return -1;\n    }\n    // pivot_root is not in glibc ‚Äî must use syscall directly\n    if (syscall(SYS_pivot_root, rootfs, old_root) != 0) {\n        perror(\"pivot_root\");\n        fprintf(stderr, \"Hint: new_root must be a mountpoint and \"\n                \"different from old_root\\n\");\n        return -1;\n    }\n    // Move our working directory into the new root\n    if (chdir(\"/\") != 0) {\n        perror(\"chdir /\");\n        return -1;\n    }\n    // Lazy-unmount the old root: immediately removes it from path resolution,\n    // defers memory release until all file descriptors into it are closed.\n    if (umount2(\"/.pivot_old\", MNT_DETACH) != 0) {\n        perror(\"umount2 /.pivot_old\");\n        return -1;\n    }\n    // Clean up the now-empty staging directory\n    if (rmdir(\"/.pivot_old\") != 0) {\n        // Non-fatal ‚Äî filesystem is already isolated\n        perror(\"rmdir /.pivot_old (non-fatal)\");\n    }\n    return 0;\n}\n// Step 4: Mount pseudo-filesystems the container needs.\n// These are kernel data structures exposed as filesystem APIs.\nstatic int mount_pseudofs(void) {\n    int ret = 0;\n    // /proc: process information and kernel tunables\n    // Mount AFTER pivot_root so it reflects our PID namespace\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL) != 0) {\n        perror(\"mount /proc\");\n        ret = -1;\n    }\n    // /sys: kernel device model and hardware parameters (read-only)\n    if (mount(\"sysfs\", \"/sys\", \"sysfs\",\n              MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_RDONLY, NULL) != 0) {\n        perror(\"mount /sys\");\n        ret = -1;\n    }\n    // /dev: tmpfs for device node staging\n    if (mount(\"tmpfs\", \"/dev\", \"tmpfs\",\n              MS_NOSUID | MS_STRICTATIME,\n              \"mode=755,size=65536k\") != 0) {\n        perror(\"mount /dev tmpfs\");\n        return -1;  // Fatal ‚Äî /dev is required\n    }\n    // Bind essential device nodes from host into container /dev\n    // We need the bind mounts before pivot but the target files after,\n    // so we do this in two passes: create target, then bind.\n    struct {\n        const char *name;\n        mode_t      mode;  // for creating the target file\n    } devnodes[] = {\n        { \"null\",    0666 },\n        { \"zero\",    0666 },\n        { \"random\",  0666 },\n        { \"urandom\", 0666 },\n        { \"tty\",     0666 },\n        { NULL, 0 }\n    };\n    char host_dev[256], cont_dev[256];\n    for (int i = 0; devnodes[i].name != NULL; i++) {\n        snprintf(host_dev, sizeof(host_dev), \"/dev/%s\", devnodes[i].name);\n        snprintf(cont_dev, sizeof(cont_dev), \"/dev/%s\", devnodes[i].name);\n        // Create an empty file as the bind-mount target\n        int fd = open(cont_dev, O_CREAT | O_WRONLY, devnodes[i].mode);\n        if (fd >= 0) close(fd);\n        if (mount(host_dev, cont_dev, NULL, MS_BIND, NULL) != 0) {\n            fprintf(stderr, \"Warning: bind-mount %s failed: %s\\n\",\n                    host_dev, strerror(errno));\n        }\n    }\n    return ret;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Zombie Reaper\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic void reap_zombies(void) {\n    int status;\n    pid_t pid;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n        fprintf(stderr, \"[container-init] reaped PID %d\\n\", pid);\n    }\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Container Init ‚Äî PID 1 inside the namespace\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int container_init(void *arg) {\n    container_config_t *cfg = (container_config_t *)arg;\n    // ‚îÄ‚îÄ Phase 1: Filesystem Isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // 1a. Make all mounts private ‚Äî no propagation in or out\n    if (set_mounts_private() != 0) return 1;\n    // 1b. Bind-mount rootfs to itself ‚Äî create the required mount point\n    if (bind_mount_rootfs(cfg->rootfs) != 0) return 1;\n    // 1c. Atomically swap root filesystem\n    if (do_pivot_root(cfg->rootfs) != 0) return 1;\n    // ‚îÄ‚îÄ Phase 2: Identity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (sethostname(CONTAINER_HOSTNAME, strlen(CONTAINER_HOSTNAME)) != 0) {\n        perror(\"sethostname\");\n        return 1;\n    }\n    // ‚îÄ‚îÄ Phase 3: Mount pseudo-filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Must happen AFTER pivot_root so they mount inside the container root\n    if (mount_pseudofs() != 0) return 1;\n    // ‚îÄ‚îÄ Phase 4: Verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    printf(\"[container] Filesystem isolation active\\n\");\n    printf(\"[container] PID: %d (should be 1)\\n\", getpid());\n    printf(\"[container] Root: \");\n    // List the new root to confirm isolation\n    system(\"ls /\");\n    // ‚îÄ‚îÄ Phase 5: Spawn user command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    pid_t child = fork();\n    if (child < 0) { perror(\"fork\"); return 1; }\n    if (child == 0) {\n        execvp(cfg->argv[0], cfg->argv);\n        perror(\"execvp\");\n        exit(127);\n    }\n    // ‚îÄ‚îÄ Phase 6: Init reaper loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    while (1) {\n        int status;\n        pid_t exited = waitpid(-1, &status, 0);\n        if (exited == child) {\n            reap_zombies();\n            return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n        } else if (exited > 0) {\n            fprintf(stderr, \"[init] reaped orphan PID %d\\n\", exited);\n        } else if (exited == -1 && errno == ECHILD) {\n            break;\n        } else if (exited == -1 && errno == EINTR) {\n            continue;\n        }\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Main ‚Äî Host Side\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nint main(int argc, char **argv) {\n    if (argc < 3) {\n        fprintf(stderr, \"Usage: %s <rootfs-path> <command> [args...]\\n\", argv[0]);\n        fprintf(stderr, \"Example: %s ./alpine-rootfs /bin/sh\\n\", argv[0]);\n        return 1;\n    }\n    // Allocate child stack (x86-64: stack grows down, pass stack top)\n    char *stack = mmap(NULL, STACK_SIZE,\n                       PROT_READ | PROT_WRITE,\n                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n                       -1, 0);\n    if (stack == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    // Guard page at the bottom: segfault on stack overflow (not silent corruption)\n    mprotect(stack, 4096, PROT_NONE);\n    char *stack_top = stack + STACK_SIZE;\n    container_config_t cfg = {\n        .rootfs = argv[1],\n        .argv   = &argv[2],\n    };\n    // Create new PID, UTS, and Mount namespaces atomically\n    pid_t container_pid = clone(container_init, stack_top,\n                                CLONE_NEWPID  |\n                                CLONE_NEWUTS  |\n                                CLONE_NEWNS   |  // ‚Üê NEW: mount namespace\n                                SIGCHLD,\n                                &cfg);\n    if (container_pid == -1) {\n        perror(\"clone\");\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    printf(\"[host] Container running, host PID: %d\\n\", container_pid);\n    int status;\n    waitpid(container_pid, &status, 0);\n    printf(\"[host] Container exited\\n\");\n    munmap(stack, STACK_SIZE);\n    return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n}\n```\nCompile and run:\n```bash\ngcc -o container_m2 container_m2.c\n# You'll need a rootfs to pivot into. Get Alpine Linux minimal rootfs:\nmkdir alpine-rootfs\ncurl -L https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-minirootfs-3.19.0-x86_64.tar.gz | \\\n    tar -xz -C alpine-rootfs\n# Create the .pivot_old staging directory\nmkdir -p alpine-rootfs/.pivot_old\n# Run the container\nsudo ./container_m2 ./alpine-rootfs /bin/sh\n```\nInside the container, verify isolation:\n```sh\n# Should show Alpine's filesystem, NOT the host's\nls /\n# bin  dev  etc  home  lib  media  mnt  opt  proc  root  run  srv  sys  tmp  usr  var\n# Should NOT show host processes (only container processes)\nls /proc/\n# 1  self  ...  (only container PIDs)\n# Host filesystem completely inaccessible\nls /.pivot_old\n# ls: cannot access '/.pivot_old': No such file or directory\n# Confirm we're seeing our process tree\ncat /proc/self/status | grep NSpid\n# NSpid:\t1\n```\n---\n## The Order of Operations: Why Sequence Matters\nThe sequence of operations in `container_init` is not arbitrary. Each step creates a precondition for the next. Getting the order wrong produces mysterious failures.\n```\n1. CLONE_NEWNS          ‚Üê Must be in clone() flags ‚Äî can't create after the fact\n        ‚Üì\n2. MS_REC | MS_PRIVATE  ‚Üê Must happen BEFORE any mounts; stops propagation leaks\n        ‚Üì\n3. MS_BIND on rootfs    ‚Üê Creates mount point; must happen before pivot_root\n        ‚Üì\n4. pivot_root()         ‚Üê Must happen before pseudo-fs mounts (they go inside new root)\n        ‚Üì\n5. umount2(MNT_DETACH)  ‚Üê Must happen immediately after pivot_root\n        ‚Üì\n6. mount /proc          ‚Üê Must happen after pivot_root (inside new root, new namespace)\n        ‚Üì\n7. mount /sys, /dev     ‚Üê Same: after pivot_root\n        ‚Üì\n8. fork() + exec()      ‚Üê User command runs with full isolation in place\n```\n**Common mistake: mounting /proc before pivot_root.** If you `mount /proc` in the new namespace while still at the host root, `/proc` is mounted at the *host's* `/proc`. After `pivot_root`, the new root doesn't have `/proc` ‚Äî you'd need to mount it again inside the container. Worse, if mount propagation wasn't set to private yet, you might have accidentally modified the host's `/proc` mount (if any parent mount was shared). Always `pivot_root` first, then mount pseudo-filesystems.\n**Common mistake: forgetting `MS_PRIVATE` before any mounts.** If you call `MS_BIND` on the rootfs before setting `MS_PRIVATE` on `/`, the bind-mount event may propagate back to the host through shared propagation. The host gains a new mount entry it didn't expect. In a containerized environment with many containers, this leaks mount events between containers ‚Äî a security and operational issue.\n---\n## Pitfall Compendium: What Will Break and Why\n### Pitfall 1: `pivot_root` Fails with `EINVAL`\nThe most common failure. Causes:\n- New root is not a mount point ‚Üí bind-mount-to-self was skipped or failed\n- New root and current root are on the same filesystem without a new mount entry ‚Üí bind-mount-to-self wasn't actually a bind mount\n- `.pivot_old` directory doesn't exist inside the new root\n- Not inside a mount namespace (`CLONE_NEWNS` was forgotten)\nDebug: check `dmesg` ‚Äî the kernel often prints a more specific reason. Verify the mount point with `findmnt` on the host, or `cat /proc/self/mountinfo` from inside the namespace.\n### Pitfall 2: Mounting `/proc` Without a PID Namespace\n```c\n// ‚ùå WRONG: If you're not in a PID namespace, /proc shows HOST processes\n// Container can now read /proc/<host_pid>/maps, /proc/<host_pid>/mem, etc.\nmount(\"proc\", \"/proc\", \"proc\", 0, NULL);\n// ‚úÖ CORRECT: CLONE_NEWPID in clone() ensures /proc shows only container PIDs\n// Mount /proc AFTER pivot_root, INSIDE the PID namespace\n```\nIf you're testing mount namespace isolation independently of PID namespace isolation (which you shouldn't be in production), be aware that `/proc` will expose host processes. This is a real information-disclosure vulnerability in misconfigured containers.\n### Pitfall 3: Host Filesystem Accessible via Open File Descriptors\nIf the container runtime (the parent, on the host) has open file descriptors pointing into the host filesystem when the container starts, those descriptors are inherited by the child process before `exec()`. The child can use those file descriptors to access host files even after `pivot_root()`.\nFix: close all file descriptors above a threshold before `exec()` in the container, or use `O_CLOEXEC` on all host-side file opens:\n```c\n// Close all file descriptors except stdin/stdout/stderr before exec\nfor (int fd = 3; fd < 1024; fd++) {\n    close(fd);  // Ignore errors ‚Äî most aren't open\n}\n// Or: use close_range() syscall (Linux 5.9+)\nsyscall(SYS_close_range, 3, UINT_MAX, 0);\n```\n### Pitfall 4: `tmpfs` Size Limit on `/dev`\nThe `size=65536k` option on the `/dev` tmpfs is a sensible limit, but some container workloads create many large device nodes (e.g., GPU containers with `/dev/nvidia*`). If you're building a GPU-capable container, increase this or omit the size limit. An unbounded tmpfs is bounded by physical RAM ‚Äî on modern systems, that's fine for `/dev` which contains only small files.\n### Pitfall 5: Missing `MS_REC` on Propagation Change\n```c\n// ‚ùå WRONG: Only changes propagation of /, not submounts\nmount(NULL, \"/\", NULL, MS_PRIVATE, NULL);\n// ‚úÖ CORRECT: Recursively changes all submounts (proc, sys, dev on host, etc.)\nmount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL);\n```\nWithout `MS_REC`, submounts (`/proc`, `/sys`, `/dev`, any `/mnt/*`) retain their original propagation type. A subsequent bind-mount inside the container that happens to overlap with a shared submount can still propagate. Always use `MS_REC`.\n### Pitfall 6: `chdir()` After `pivot_root` is Mandatory\nAfter `pivot_root()`, the process's working directory (cwd) still points to the old root's directory entry. Relative path operations behave unexpectedly because the cwd is now in the detached old root. The `chdir(\"/\")` call immediately after `pivot_root()` resets the cwd to the new root. Missing this step produces confusing `ENOENT` errors in subsequent operations.\n---\n## Hardware Soul: What the Kernel Is Actually Doing\n### Cache Behavior During `pivot_root()`\n`pivot_root()` is a kernel-side metadata operation. It modifies the mount namespace's mount table ‚Äî a doubly-linked list of `mount` structs in kernel memory. The actual filesystem data (file contents) is not touched. The operation involves:\n1. **Lock acquisition**: `namespace_lock()` takes a write lock on the mount namespace. This is a kernel semaphore, not a user-visible lock.\n2. **Pointer surgery**: The kernel swaps `ns->root` to point to the new root mount. The old root mount gets re-parented to the `put_old` directory entry.\n3. **Lock release**: The operation completes.\n**Cache impact**: The `mount` structs are small (~200 bytes each) and frequently accessed. They're typically hot in L2/L3 cache. `pivot_root()` on a namespace with ~20 mounts (typical Docker container) touches maybe 4-5 KB of kernel data structures ‚Äî fits easily in L1 cache (32-64 KB typical). The operation is **not** I/O-bound, not memory-bound, and barely CPU-bound.\n**Latency**: `pivot_root()` takes approximately 2-10 Œºs on modern hardware, including the lock acquire and release. The dominant cost is the lock contention if many namespaces are being created simultaneously ‚Äî which is why container orchestration systems (Kubernetes) pipeline container creation rather than batching it serially.\n### TLB and Page Table Impact\nMount namespace operations don't directly affect the TLB or page tables. The container's address space (page tables, TLB entries) is unchanged by `pivot_root()`. What changes is the VFS pathname resolution ‚Äî a pure kernel data structure operation.\n`mount()` calls for pseudo-filesystems (`/proc`, `/sys`, `/dev`) allocate kernel memory for superblock objects and inode caches. For procfs, the kernel allocates one `proc_inode` per `/proc/<pid>` entry ‚Äî about 256 bytes each. With 10 container processes, that's ~2.5 KB of kernel memory per container for procfs ‚Äî negligible.\n### Memory Access Pattern\nThe bind-mount-to-self (`MS_BIND`) copies the source mount's `mount` struct and adds it to the namespace's mount list. This is a sequential write into kernel memory ‚Äî cache-friendly. The `pivot_root()` operation is a tree rotation in the mount list ‚Äî O(1) pointer operations, all in already-hot cache lines.\n---\n## Knowledge Cascade: Mount Namespaces Unlock Everything\n### 1. Docker's `overlay2` Storage Driver\nWhen you pull a Docker image, Docker doesn't store one copy per container ‚Äî it uses overlay filesystems. Each image layer is a directory (the \"lower\" layer). The container gets a writable \"upper\" layer. The overlay filesystem presents a merged view: reads fall through upper ‚Üí lower layers, writes go to upper only. The lower layers are never modified.\nHow does this connect to `pivot_root()`? Docker uses the overlay-merged directory as the new root. `pivot_root()` swaps the root filesystem to this overlaid view. The container sees a writable root that's actually a union of immutable image layers. When the container exits, Docker discards the upper (writable) layer ‚Äî the image layers are untouched. Ten containers running the same image share the same read-only lower layers ‚Äî only their upper (diff) layers are separate.\n\n![Docker Image Layers to Container Rootfs ‚Äî Overlay Mount](./diagrams/diag-mount-namespace-overlay-layers.svg)\n\nUnderstanding `pivot_root()` explains why Docker images are copy-on-write, why `docker diff` shows only modified files, and why multi-stage builds reduce image size (fewer layers = smaller lower layer footprint).\n### 2. The Leaky Vessels CVE (2024): Container Escape via Incomplete `pivot_root`\nCVE-2024-21626 (Leaky Vessels) affected runc, the container runtime used by Docker and Kubernetes. The vulnerability: a file descriptor (`/proc/self/fd/...`) pointing into the host filesystem was inherited by the container process *after* `pivot_root()` but *before* the fd was closed. The container could use this fd to access and write to host filesystem paths ‚Äî a full container escape with write access to the host.\nThe fix: close all file descriptors into the host namespace before executing the container's process. The vulnerable code path opened an fd for a cgroup-related directory lookup during container setup, then forgot to close it before `exec()`.\nThis is exactly the \"open file descriptor inheritance\" pitfall described above. The `pivot_root()` sequence is correct ‚Äî the mistake was in fd management before `exec()`. Understanding the sequence tells you exactly where to look for this class of vulnerability.\n### 3. Kubernetes `hostPath` Mounts and Bidirectional Propagation\nKubernetes allows `hostPath` volumes ‚Äî mounting a host directory directly into a container. The `MountPropagation` field controls how mount events propagate:\n- `None` (default): MS_PRIVATE ‚Äî container mounts don't reach host\n- `HostToContainer`: MS_SLAVE ‚Äî host mounts propagate in, container mounts stay out\n- `Bidirectional`: MS_SHARED ‚Äî mounts propagate both ways\n`Bidirectional` requires the pod to be privileged. When a privileged pod mounts something inside a `hostPath` with `Bidirectional` propagation, that mount becomes visible on the host and to other containers sharing the `hostPath`. This is how legitimate use cases (CSI drivers) work ‚Äî but it's also why `Bidirectional` is a security concern. A compromised privileged pod can mount things onto the host.\nUnderstanding `MS_SHARED`, `MS_SLAVE`, and `MS_PRIVATE` from this milestone gives you the vocabulary to reason about Kubernetes storage security policies precisely.\n### 4. Distroless Images and Minimal rootfs\nGoogle's distroless images contain only the application and its runtime dependencies ‚Äî no shell, no package manager, no `/usr/bin/id`. The container's rootfs is constructed by `pivot_root()`'ing into a carefully curated directory tree.\nUnderstanding what a container actually *needs* in its rootfs (from this milestone):\n- `/proc`, `/sys`, `/dev` (pseudo-filesystems, mounted at runtime ‚Äî not needed in the image)\n- Shared libraries (`/lib`, `/lib64`) for the binary to link against\n- `/etc/resolv.conf`, `/etc/passwd`, `/etc/hosts` for network and identity\n- The application binary itself\nEverything else ‚Äî shells, compilers, debug tools ‚Äî is optional. Distroless images remove them. A compromised distroless container has no shell to drop into, no `curl` to exfiltrate data, no `chmod` to escalate. Understanding `pivot_root()` explains why this works: the container is literally running inside a rootfs that doesn't contain those tools. There's no path to them, because the host filesystem is inaccessible.\n### 5. `setns()` and Joining Existing Namespaces\nThe inverse of creating a mount namespace is joining an existing one. `setns(fd, CLONE_NEWNS)` switches the calling process into the mount namespace referenced by `fd` (obtained by `open(\"/proc/<pid>/ns/mnt\", O_RDONLY)`). This is how `docker exec` works: it opens the running container's namespace descriptors from `/proc/<container_pid>/ns/*` and joins each one using `setns()`, then `exec()`s the user's command in the container's environment.\nNow you understand why `docker exec` can run commands inside a running container without restarting it ‚Äî it's joining the existing namespaces at runtime, including the mount namespace with `pivot_root()`'d rootfs still in effect.\n---\n## Verification Checklist\n```bash\n# ‚îÄ‚îÄ 1. Verify mount namespace isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container: mount operations don't appear on host\nmount -t tmpfs tmpfs /tmp      # Inside container\n# On host: cat /proc/mounts | grep tmpfs  ‚Äî should NOT show container's tmpfs\n# ‚îÄ‚îÄ 2. Verify root filesystem isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nls /\n# Should show ONLY your container rootfs contents\n# Try to reach host filesystem:\nls /etc/shadow      # Should show CONTAINER's /etc/shadow (if any), not host's\nls /.pivot_old      # ENOENT ‚Äî old root is gone\n# ‚îÄ‚îÄ 3. Verify /proc shows only container processes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nls /proc/\n# Should show: 1  2  self  ... (only container PIDs, not thousands of host PIDs)\ncat /proc/1/cmdline  # Should show your container_init binary\n# ‚îÄ‚îÄ 4. Verify /sys is read-only ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\necho 1 > /sys/kernel/mm/transparent_hugepage/enabled\n# Permission denied ‚Äî /sys is MS_RDONLY\n# ‚îÄ‚îÄ 5. Verify /dev has essential devices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\necho \"test\" > /dev/null    # Should succeed silently\ncat /dev/urandom | head -c 4 | xxd  # Should produce random bytes\n# ‚îÄ‚îÄ 6. Verify hostname isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nhostname\n# mycontainer (not the host's hostname)\n# ‚îÄ‚îÄ 7. Verify host can still see container via host PID ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# On HOST (replace 12345 with actual host PID from clone() output):\ncat /proc/12345/mountinfo | head -5\n# Should show container's mount namespace entries (/ ‚Üí container rootfs)\ncat /proc/12345/ns/mnt\n# mnt:[4026532345]  (different inode from host's mnt namespace)\ncat /proc/self/ns/mnt\n# mnt:[4026531840]  (host's mount namespace ‚Äî different number)\n```\n---\n## Looking Ahead\nYour container now has genuine filesystem isolation. `pivot_root()` has atomically swapped the root filesystem, `umount2(MNT_DETACH)` has removed the host filesystem from the kernel's path resolution, and pseudo-filesystems provide the minimal infrastructure the container process needs.\nBut if you run `ip addr` inside the container, you see the host's network interfaces ‚Äî `eth0`, `wlan0`, all of it. The container can open network connections on behalf of the host's network stack, listen on ports that appear on the host, and enumerate the host's network configuration.\nThe next milestone (Network Namespace and Container Networking) adds `CLONE_NEWNET` to the growing list of namespace flags. The pattern is now clear: `CLONE_NEWPID | CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWNET | SIGCHLD` ‚Äî all atomic in a single `clone()` call. Each namespace flag adds another dimension of isolation. By Milestone 4 (cgroups), you'll also enforce *resource* limits ‚Äî not just visibility limits. And by Milestone 5 (user namespaces), you'll remove the `sudo` requirement entirely.\nThe `container_init` architecture you've been building ‚Äî `clone()` with accumulated flags, PID 1 reaper loop, sequential isolation setup inside the child ‚Äî is the skeleton every container runtime follows. `runc` (the OCI runtime used by Docker) does exactly this sequence, with additional complexity around OCI spec compliance, seccomp filters, and capability management. You've now built the core.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m3 -->\n<!-- MS_ID: container-basic-m3 -->\n# Milestone 3: Network Namespace and Container Networking\n## The Illusion You Are About to Demystify\nRun your container from Milestone 2. Inside the shell, type `ip addr`. You see the host's network interfaces ‚Äî `eth0`, `lo`, `wlan0`, every interface on your machine. Your container has perfect filesystem isolation and process isolation, but its network stack is completely exposed to the host.\nType `ip route` inside your container. You see the host's routing table. Type `ss -tlnp` ‚Äî you see every port the host is listening on. Your container could open a socket on port 80, and that socket would appear on the host's interface. That's not isolation. That's a namespace sticker placed over a window that's still wide open.\nBut here's the misconception worth shattering first: many developers assume that container networking involves specialized kernel modules, hardware-level NIC virtualization, or some kind of complex SDN (Software Defined Networking) magic. The mental model is: *Docker networking must be complicated ‚Äî it routes packets between containers, across hosts, through overlays. This can't be simple.*\n**It is simple.** Docker's default bridge network ‚Äî the `docker0` bridge you see on any Docker host ‚Äî is built from exactly three kernel primitives that have existed since Linux 2.x:\n1. A **network namespace** creates an empty, isolated network stack.\n2. A **veth pair** is a virtual ethernet cable connecting two namespaces.\n3. A **Linux bridge** is a virtual L2 switch connecting multiple veth endpoints.\nAdd one `iptables MASQUERADE` rule for NAT, and you have Docker's default bridge network. Literally. The same architecture. The same kernel objects. By the end of this milestone, you will have built `docker0` from scratch.\n\n![Container Networking Topology ‚Äî veth Pairs + Bridge](./diagrams/diag-veth-pair-bridge-topology.svg)\n\n---\n## The Tension: One Network Stack, Many Isolated Worlds\nThe Linux kernel maintains a single global network stack. Every socket, every routing table entry, every network interface ‚Äî they all live in one shared namespace. Without isolation:\n- Container A binds port 8080. Container B tries to bind port 8080. `EADDRINUSE`. They fight over port space.\n- Container A can call `socket(AF_PACKET, ...)` and sniff every packet on `eth0`. Your containers are eavesdropping on each other.\n- Container A can modify the host's routing table with `ip route add`. It can redirect traffic. It can ARP-poison the network.\n- `iptables` rules are global. Container A's firewall rules affect Container B's traffic.\nThe kernel's answer ‚Äî as you now know from the PID and mount namespaces ‚Äî is to partition the global data structure. A **network namespace** (`CLONE_NEWNET`) gives each container its own:\n- Network interfaces (visible with `ip link`)\n- Routing tables (`ip route`)\n- `iptables` / `nftables` rules\n- Sockets and connection tracking table\n- Port space (container A and B can both bind port 8080 simultaneously)\nBut an isolated network stack is useless without connectivity. A container that can't reach the internet or other containers is an island. This is the fundamental tension in container networking: **you want complete isolation AND selective connectivity.** \nThe solution ‚Äî veth pairs and bridges ‚Äî threads this needle precisely. You get isolation by default, and you punch selective holes through namespace boundaries exactly where you choose.\n---\n## Concept 1: The Virtual Ethernet Pair\n[[EXPLAIN:virtual-ethernet-(veth)-pair-model|Virtual ethernet (veth) pair model]]\nA veth pair is the most elegant network primitive in the Linux kernel. It's created as a single unit ‚Äî two virtual network interfaces permanently linked together. Whatever you send into one end comes out the other, exactly like a physical ethernet cable.\n```\n[veth0] ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ wire ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí [veth1]\n```\nBut unlike a physical cable, these two ends can live in **different network namespaces**. That's the key. You create the pair in the host namespace, then move one end into the container's network namespace. Now the container's network interface is directly connected to the host ‚Äî via the veth wire ‚Äî even though they're in separate namespaces.\n\n![Network Namespace Empty State ‚Äî Before and After veth](./diagrams/diag-net-ns-empty-state.svg)\n\nThe kernel implementation: when a packet is `xmit`'d on one veth end, the kernel's `veth_xmit()` function pushes the skb (socket buffer ‚Äî the kernel's packet representation) directly to the receive queue of the other end. No actual hardware, no DMA, no interrupt ‚Äî just a function call that moves a pointer from one queue to another. This is why veth pairs are fast: the \"network\" traversal is pure software.\nHowever, this single-hop path still traverses the full kernel network stack twice ‚Äî once on transmit (sender's namespace) and once on receive (receiver's namespace). That's two invocations of `netif_rx()`, two routing lookups, two sets of netfilter hooks. This is the measurable overhead: roughly 5-15% additional latency compared to host networking for small packets, measurable with `netperf` or `iperf3`. We'll quantify this in the Hardware Soul section.\nCreating a veth pair from userspace uses the `rtnetlink` socket API ‚Äî the same API that the `ip` command uses. In C, this requires constructing Netlink messages. For clarity, we'll wrap the `ip` command using `system()` in the implementation and then show the raw Netlink approach as an extension.\n\n![veth Pair Creation and Namespace Assignment ‚Äî Step Sequence](./diagrams/diag-veth-creation-sequence.svg)\n\n---\n## Concept 2: The Linux Bridge\n[[EXPLAIN:linux-bridge-as-a-virtual-l2-switch|Linux bridge as a virtual L2 switch]]\nA Linux bridge (`br_netfilter` kernel module, interface type `ARPHRD_ETHER`) behaves like a hardware L2 Ethernet switch: it forwards frames between attached interfaces based on MAC addresses, maintains an FDB (Forwarding Database) mapping MAC addresses to ports, and broadcasts frames for unknown destinations.\nIn our topology, the bridge serves as the hub that connects all container veth endpoints to each other and to the host's outbound interface. Each container's \"host-side\" veth end is attached to the bridge as a port. The bridge gets an IP address ‚Äî this becomes the **gateway** that all containers route through.\n```\n[ ctr0 bridge: 172.20.0.1/24 ]\n        |          |\n    [veth_h0]  [veth_h1]   ‚Üê host-side veth ends (bridge ports)\n        |          |\n    [veth_c0]  [veth_c1]   ‚Üê container-side veth ends\n        |          |\n  [container0]  [container1]\n```\nThe bridge is created with `ARPHRD_ETHER` type and given an IP address. The IP serves as the container gateway ‚Äî containers send their default route traffic to this IP, and the bridge (being on the host network stack) can forward it onward.\n---\n## Building the Network Topology: Complete Plan\nBefore writing any code, map the full topology you're about to construct:\n```\nHost Network Stack:\n‚îú‚îÄ‚îÄ eth0 (or enp3s0, etc.) ‚Äî host's outbound interface, e.g., 192.168.1.100/24\n‚îú‚îÄ‚îÄ ctr0 bridge ‚Äî 172.20.0.1/24 (container gateway)\n‚îÇ   ‚îî‚îÄ‚îÄ veth_h0 ‚Äî bridge port (host side of veth pair)\n‚îÇ\nContainer Network Namespace:\n‚îî‚îÄ‚îÄ veth_c0 ‚Äî 172.20.0.2/24 (container's interface)\n    ‚îî‚îÄ‚îÄ default route via 172.20.0.1 (the bridge)\niptables NAT:\n‚îî‚îÄ‚îÄ POSTROUTING MASQUERADE on eth0 ‚Äî rewrites container IPs to host IP for outbound\n```\nIP subnet: `172.20.0.0/24` ‚Äî chosen to avoid conflict with common home networks (`192.168.0.0/24`, `10.0.0.0/8`). Docker uses `172.17.0.0/16` by default.\nInterface naming:\n- `ctr0` ‚Äî the bridge (analogous to Docker's `docker0`)\n- `veth_h0` ‚Äî host-side veth (attached to bridge)\n- `veth_c0` ‚Äî container-side veth (inside container namespace)\n\n![Packet Walk: Container ‚Üí Bridge ‚Üí NAT ‚Üí Internet](./diagrams/diag-packet-walk-container-to-internet.svg)\n\n---\n## The Two-Phase Implementation\nNetwork namespace setup requires coordination between two sides: the **host side** (parent process, runs before `clone()` and after) and the **container side** (child process, `container_init()`). This split exists because:\n1. veth pairs must be created on the **host** ‚Äî you can't create a veth pair from inside a new empty network namespace that has no interfaces yet.\n2. Moving one end of the veth into the container namespace requires knowing the container's PID ‚Äî which only exists after `clone()` returns.\n3. Interface configuration inside the container must happen **inside** the container's network namespace.\nThe timing sequence:\n```\nHOST                                    CONTAINER (after clone)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1. clone(CLONE_NEWNET | ...) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  (network namespace is empty)\n   returns container_pid\n2. create veth pair (veth_h0/veth_c0)  (waiting for network setup signal)\n3. ip link set veth_c0 netns $pid ‚îÄ‚îÄ‚Üí  (veth_c0 appears in container)\n4. configure veth_h0 + bridge          \n5. signal container to continue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí 6. bring up lo\n                                        7. assign IP to veth_c0\n                                        8. add default route\n                                        9. exec user command\n```\nThis is a classic parent-child synchronization problem. We'll use a `pipe()` ‚Äî the parent writes one byte to signal the container that network setup is complete; the container blocks reading from the pipe until that byte arrives.\n```c\n// Synchronization via pipe\nint sync_pipe[2];\npipe(sync_pipe);\n// Parent: after network setup, write one byte\nwrite(sync_pipe[1], \"1\", 1);\n// Container: block until parent writes\nchar ready;\nread(sync_pipe[0], &ready, 1);\n```\nThis is the same technique used by `runc` and `containerd` ‚Äî they call it the \"init pipe\" or \"sync socket\". The OCI runtime spec formalizes this two-phase initialization exactly because network setup requires the split-second coordination between parent and child.\n---\n## Phase 1: Host-Side Network Setup\nAll of the following runs in the **host** process (parent), after `clone()` returns the container PID.\n### Step 1: Create the Linux Bridge\n```c\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#define BRIDGE_NAME   \"ctr0\"\n#define BRIDGE_IP     \"172.20.0.1\"\n#define BRIDGE_CIDR   \"172.20.0.1/24\"\n#define CONTAINER_IP  \"172.20.0.2\"\n#define CONTAINER_CIDR \"172.20.0.2/24\"\n#define CONTAINER_GW  \"172.20.0.1\"\n#define VETH_HOST     \"veth_h0\"\n#define VETH_CONT     \"veth_c0\"\n// Execute a shell command; die on failure.\n// Production code would use rtnetlink directly ‚Äî see the Netlink extension below.\nstatic int run(const char *fmt, ...) {\n    char cmd[1024];\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(cmd, sizeof(cmd), fmt, ap);\n    va_end(ap);\n    int ret = system(cmd);\n    if (ret != 0) {\n        fprintf(stderr, \"[host-net] FAILED (%d): %s\\n\", ret, cmd);\n        return -1;\n    }\n    return 0;\n}\n// Create the bridge ctr0 and assign it an IP.\n// This is the container gateway ‚Äî the virtual switch hub.\nstatic int setup_bridge(void) {\n    // Create bridge interface\n    if (run(\"ip link add name %s type bridge\", BRIDGE_NAME) != 0) {\n        // Bridge may already exist from a previous run ‚Äî try to continue\n        fprintf(stderr, \"[host-net] Bridge may already exist, continuing\\n\");\n    }\n    // Assign IP ‚Äî this becomes the container's default gateway\n    run(\"ip addr add %s dev %s\", BRIDGE_CIDR, BRIDGE_NAME);\n    // Bring it up\n    run(\"ip link set %s up\", BRIDGE_NAME);\n    return 0;\n}\n```\n### Step 2: Create the veth Pair\n```c\n// Create a veth pair: veth_h0 <--> veth_c0\n// Both start in the host namespace; we'll move veth_c0 into the container.\nstatic int create_veth_pair(void) {\n    return run(\"ip link add %s type veth peer name %s\",\n               VETH_HOST, VETH_CONT);\n}\n```\nThe `ip link add ... type veth peer name ...` command creates both ends atomically. After this call, the host network namespace contains two new interfaces: `veth_h0` and `veth_c0`, both DOWN and with no IP addresses.\n### Step 3: Attach Host-Side to Bridge\n```c\n// Attach the host-side veth end to the bridge.\n// The bridge acts as the L2 switch; veth_h0 is now one of its ports.\nstatic int attach_veth_to_bridge(void) {\n    if (run(\"ip link set %s master %s\", VETH_HOST, BRIDGE_NAME) != 0)\n        return -1;\n    // Bring the host-side veth up (bridge port must be up to forward)\n    return run(\"ip link set %s up\", VETH_HOST);\n}\n```\n### Step 4: Move Container-Side veth Into the Container Namespace\n```c\n// Move veth_c0 into the container's network namespace.\n// After this call, veth_c0 disappears from the host and appears inside the container.\n// container_pid is the PID returned by clone() ‚Äî the host-visible PID of the container init.\nstatic int move_veth_to_container(pid_t container_pid) {\n    return run(\"ip link set %s netns %d\", VETH_CONT, container_pid);\n}\n```\nThis is the magic step. `ip link set <iface> netns <pid>` uses `IFLA_NET_NS_PID` in a Netlink `RTM_SETLINK` message to move the interface's ownership from the current namespace to the namespace of the process with that PID. After this:\n- `ip link show` on the **host** no longer shows `veth_c0`\n- `ip link show` inside the **container** now shows `veth_c0`\nThe interface physically \"moved\" ‚Äî the kernel's `struct net_device` changed which `struct net` (network namespace) it belongs to.\n### Step 5: Enable IP Forwarding and NAT\n```c\n// Enable IP forwarding on the host.\n// Without this, the kernel drops packets that arrive on one interface\n// (from the container via the bridge) destined for another interface (eth0).\n// The kernel's default is to NOT forward ‚Äî it assumes it's a host, not a router.\nstatic int enable_ip_forwarding(void) {\n    return run(\"sysctl -w net.ipv4.ip_forward=1\");\n}\n// Add iptables MASQUERADE rule for outbound NAT.\n// When a container packet leaves via the host's outbound interface,\n// MASQUERADE rewrites the source IP from 172.20.0.2 to the host's IP.\n// Without this, the internet sees packets from 172.20.0.2 ‚Äî a private address\n// that responses can't be routed back to.\n//\n// The FORWARD rule allows the kernel to forward packets from the bridge\n// subnet to the outbound interface.\nstatic int setup_nat(const char *outbound_iface) {\n    // Allow forwarding from container subnet to internet\n    run(\"iptables -A FORWARD -i %s -o %s -j ACCEPT\",\n        BRIDGE_NAME, outbound_iface);\n    run(\"iptables -A FORWARD -i %s -o %s -m state --state RELATED,ESTABLISHED -j ACCEPT\",\n        outbound_iface, BRIDGE_NAME);\n    // Masquerade outbound container traffic ‚Äî rewrite source IP to host IP\n    return run(\"iptables -t nat -A POSTROUTING -s %s/24 -o %s -j MASQUERADE\",\n               BRIDGE_IP, outbound_iface);\n}\n```\n\n![iptables NAT Rules ‚Äî MASQUERADE and FORWARD Chains](./diagrams/diag-nat-iptables-rules.svg)\n\n`MASQUERADE` is a special case of SNAT (Source NAT). SNAT requires you to specify the replacement IP explicitly. MASQUERADE automatically uses whatever IP is currently assigned to the outbound interface ‚Äî useful when the host has a dynamic IP (DHCP). The kernel's `nf_nat_masquerade.c` looks up the outbound interface's current IP at packet-send time and substitutes it as the source.\n[[EXPLAIN:netfilter-hook-points-and-iptables-chain-traversal|Netfilter hook points and iptables FORWARD/POSTROUTING chain traversal]]\n---\n## Phase 2: Container-Side Network Setup\nThis runs inside `container_init()`, after the synchronization pipe signals that the host has completed network setup.\n```c\n// Configure the container's network interfaces.\n// Called from container_init() after the host signals network setup is complete.\nstatic int setup_container_network(void) {\n    // ‚îÄ‚îÄ Step 1: Bring up loopback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Loopback MUST be up. Without it:\n    // - Connections to 127.0.0.1 fail\n    // - Many server processes bind to 127.0.0.1 first and fail to start\n    // - DNS resolution via 127.0.0.1 (local resolver) fails silently\n    if (run(\"ip link set lo up\") != 0) {\n        fprintf(stderr, \"[container-net] Failed to bring up loopback\\n\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 2: Assign IP to container veth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (run(\"ip addr add %s dev %s\", CONTAINER_CIDR, VETH_CONT) != 0) {\n        fprintf(stderr, \"[container-net] Failed to assign IP to %s\\n\", VETH_CONT);\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 3: Bring up container veth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (run(\"ip link set %s up\", VETH_CONT) != 0) {\n        fprintf(stderr, \"[container-net] Failed to bring up %s\\n\", VETH_CONT);\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 4: Add default route ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // All traffic not destined for the local subnet goes through the gateway.\n    // The gateway is the bridge's IP on the host side.\n    if (run(\"ip route add default via %s dev %s\", CONTAINER_GW, VETH_CONT) != 0) {\n        fprintf(stderr, \"[container-net] Failed to add default route\\n\");\n        return -1;\n    }\n    printf(\"[container-net] Network configured: %s, gateway %s\\n\",\n           CONTAINER_CIDR, CONTAINER_GW);\n    return 0;\n}\n```\n### DNS Configuration\nA freshly isolated container has an empty `/etc`. There's no `/etc/resolv.conf`. Every DNS lookup returns `EAI_AGAIN` or hangs. This is the #1 silent failure in container networking ‚Äî applications look like they're \"broken\" when actually they simply can't resolve hostnames.\n[[EXPLAIN:dns-resolv.conf-mechanics-and-resolver-library-behavior|DNS resolv.conf mechanics ‚Äî how glibc resolver reads /etc/resolv.conf]]\n\n![Container DNS Resolution ‚Äî /etc/resolv.conf Configuration](./diagrams/diag-dns-resolution-in-container.svg)\n\nThere are three approaches to DNS in a container:\n**Option A: Bind-mount `/etc/resolv.conf` from host**\n```c\n// Copy host DNS configuration into container rootfs before pivot_root,\n// or bind-mount the host file into the container.\n// Simple, inherits host DNS settings.\nstatic int configure_dns_bind_mount(const char *rootfs) {\n    char dest[512];\n    snprintf(dest, sizeof(dest), \"%s/etc/resolv.conf\", rootfs);\n    // Create the destination file if it doesn't exist\n    int fd = open(dest, O_CREAT | O_WRONLY | O_TRUNC, 0644);\n    if (fd >= 0) close(fd);\n    // Bind-mount the host's resolv.conf into the container rootfs\n    // This must happen BEFORE pivot_root (we reference the container path)\n    return mount(\"/etc/resolv.conf\", dest, NULL, MS_BIND, NULL);\n}\n```\n**Option B: Write a static `/etc/resolv.conf` into the rootfs**\n```c\n// Write a known-good DNS configuration directly into the container rootfs.\n// Use a public resolver (8.8.8.8 = Google, 1.1.1.1 = Cloudflare).\nstatic int configure_dns_static(const char *rootfs) {\n    char path[512];\n    snprintf(path, sizeof(path), \"%s/etc/resolv.conf\", rootfs);\n    FILE *f = fopen(path, \"w\");\n    if (!f) {\n        perror(\"fopen resolv.conf\");\n        return -1;\n    }\n    fprintf(f, \"nameserver 8.8.8.8\\n\");\n    fprintf(f, \"nameserver 1.1.1.1\\n\");\n    fprintf(f, \"options ndots:0\\n\");  // Disable search domain expansion\n    fclose(f);\n    return 0;\n}\n```\n**Option C: Generate from container network configuration**\nWrite `nameserver <gateway_ip>` and run a DNS forwarder on the host at the gateway IP. This is what Kubernetes does ‚Äî `kube-dns`/`CoreDNS` runs at a known cluster IP, and every pod's `/etc/resolv.conf` points to that IP.\nFor this milestone, Option B (static configuration with public resolvers) is simplest. Production container runtimes use Option C for cluster DNS. We'll use Option B and note the Kubernetes connection in the Knowledge Cascade.\n```c\n// Call this before pivot_root in Milestone 2's setup sequence\nstatic int setup_dns(const char *rootfs) {\n    return configure_dns_static(rootfs);\n}\n```\n---\n## Complete Implementation: Everything Together\nHere is the full implementation integrating network namespace support into the container runtime built in Milestones 1 and 2:\n```c\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#define STACK_SIZE       (1024 * 1024)\n#define CONTAINER_HOSTNAME \"mycontainer\"\n// ‚îÄ‚îÄ Network Configuration Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#define BRIDGE_NAME    \"ctr0\"\n#define BRIDGE_IP      \"172.20.0.1\"\n#define BRIDGE_CIDR    \"172.20.0.1/24\"\n#define CONTAINER_IP   \"172.20.0.2\"\n#define CONTAINER_CIDR \"172.20.0.2/24\"\n#define CONTAINER_GW   \"172.20.0.1\"\n#define VETH_HOST      \"veth_h0\"\n#define VETH_CONT      \"veth_c0\"\n// ‚îÄ‚îÄ Configuration passed through clone() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ntypedef struct {\n    char  *rootfs;\n    char **argv;\n    char  *outbound_iface;  // Host's outbound interface (e.g., \"eth0\")\n    int    sync_pipe_read;  // Container reads from this fd to wait for host setup\n} container_config_t;\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Utility: execute shell command\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int run(const char *fmt, ...) {\n    char cmd[1024];\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(cmd, sizeof(cmd), fmt, ap);\n    va_end(ap);\n    int ret = system(cmd);\n    if (ret != 0)\n        fprintf(stderr, \"[net] FAILED (%d): %s\\n\", ret, cmd);\n    return ret == 0 ? 0 : -1;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Filesystem isolation (from Milestone 2 ‚Äî abbreviated for space)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int set_mounts_private(void) {\n    return mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL) == 0 ? 0 : -1;\n}\nstatic int bind_mount_rootfs(const char *rootfs) {\n    return mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL) == 0 ? 0 : -1;\n}\nstatic int do_pivot_root(const char *rootfs) {\n    char old_root[1024];\n    snprintf(old_root, sizeof(old_root), \"%s/.pivot_old\", rootfs);\n    mkdir(old_root, 0700);\n    if (syscall(SYS_pivot_root, rootfs, old_root) != 0) {\n        perror(\"pivot_root\"); return -1;\n    }\n    chdir(\"/\");\n    if (umount2(\"/.pivot_old\", MNT_DETACH) != 0) {\n        perror(\"umount2 /.pivot_old\"); return -1;\n    }\n    rmdir(\"/.pivot_old\");\n    return 0;\n}\nstatic int mount_pseudofs(void) {\n    mount(\"proc\",  \"/proc\", \"proc\",  MS_NOSUID|MS_NOEXEC|MS_NODEV, NULL);\n    mount(\"sysfs\", \"/sys\",  \"sysfs\", MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_RDONLY, NULL);\n    mount(\"tmpfs\", \"/dev\",  \"tmpfs\", MS_NOSUID|MS_STRICTATIME, \"mode=755,size=65536k\");\n    const char *devs[] = { \"null\", \"zero\", \"random\", \"urandom\", \"tty\", NULL };\n    char src[256], dst[256];\n    for (int i = 0; devs[i]; i++) {\n        snprintf(src, sizeof(src), \"/dev/%s\", devs[i]);\n        snprintf(dst, sizeof(dst), \"/dev/%s\", devs[i]);\n        int fd = open(dst, O_CREAT|O_WRONLY, 0666);\n        if (fd >= 0) close(fd);\n        mount(src, dst, NULL, MS_BIND, NULL);\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Container-side network setup\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int setup_container_network(void) {\n    // Loopback: without this, connections to 127.0.0.1 fail silently\n    if (run(\"ip link set lo up\") != 0) return -1;\n    // Assign IP to our veth end\n    if (run(\"ip addr add %s dev %s\", CONTAINER_CIDR, VETH_CONT) != 0) return -1;\n    // Bring the interface up\n    if (run(\"ip link set %s up\", VETH_CONT) != 0) return -1;\n    // Default route: all non-local traffic goes through the bridge/gateway\n    if (run(\"ip route add default via %s dev %s\", CONTAINER_GW, VETH_CONT) != 0)\n        return -1;\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Zombie reaper\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic void reap_zombies(void) {\n    int status;\n    pid_t pid;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0)\n        fprintf(stderr, \"[init] reaped PID %d\\n\", pid);\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Container init ‚Äî PID 1 inside the namespace\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int container_init(void *arg) {\n    container_config_t *cfg = (container_config_t *)arg;\n    // ‚îÄ‚îÄ Phase 1: Wait for host to complete network setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Block until parent writes to the sync pipe, confirming veth has been\n    // moved into this namespace and the bridge is ready.\n    char ready;\n    if (read(cfg->sync_pipe_read, &ready, 1) != 1) {\n        fprintf(stderr, \"[container] Sync pipe read failed\\n\");\n        return 1;\n    }\n    close(cfg->sync_pipe_read);\n    // ‚îÄ‚îÄ Phase 2: Filesystem isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (set_mounts_private() != 0)     return 1;\n    if (bind_mount_rootfs(cfg->rootfs) != 0) return 1;\n    if (do_pivot_root(cfg->rootfs) != 0)     return 1;\n    // ‚îÄ‚îÄ Phase 3: Identity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    sethostname(CONTAINER_HOSTNAME, strlen(CONTAINER_HOSTNAME));\n    // ‚îÄ‚îÄ Phase 4: Pseudo-filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    mount_pseudofs();\n    // ‚îÄ‚îÄ Phase 5: Container-side network configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // veth_c0 is already in our namespace (host moved it before signaling us).\n    // We configure it: IP address, bring up, default route.\n    if (setup_container_network() != 0) {\n        fprintf(stderr, \"[container] Network setup failed\\n\");\n        return 1;\n    }\n    // ‚îÄ‚îÄ Phase 6: Verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    printf(\"[container] PID: %d\\n\", getpid());\n    printf(\"[container] Network interfaces:\\n\");\n    system(\"ip addr\");\n    printf(\"[container] Routing table:\\n\");\n    system(\"ip route\");\n    // ‚îÄ‚îÄ Phase 7: Spawn user command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    pid_t child = fork();\n    if (child < 0) { perror(\"fork\"); return 1; }\n    if (child == 0) {\n        execvp(cfg->argv[0], cfg->argv);\n        perror(\"execvp\");\n        exit(127);\n    }\n    // ‚îÄ‚îÄ Phase 8: Init reaper loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    while (1) {\n        int status;\n        pid_t exited = waitpid(-1, &status, 0);\n        if (exited == child) {\n            reap_zombies();\n            return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n        } else if (exited > 0) {\n            fprintf(stderr, \"[init] reaped orphan PID %d\\n\", exited);\n        } else if (exited == -1 && errno == ECHILD) {\n            break;\n        } else if (exited == -1 && errno == EINTR) {\n            continue;\n        }\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Host-side network setup (called from main, after clone)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int setup_host_network(pid_t container_pid, const char *outbound_iface) {\n    // 1. Create bridge (idempotent ‚Äî ignore error if already exists)\n    run(\"ip link add name %s type bridge 2>/dev/null\", BRIDGE_NAME);\n    run(\"ip addr add %s dev %s 2>/dev/null\", BRIDGE_CIDR, BRIDGE_NAME);\n    run(\"ip link set %s up\", BRIDGE_NAME);\n    // 2. Create veth pair\n    if (run(\"ip link add %s type veth peer name %s\", VETH_HOST, VETH_CONT) != 0) {\n        fprintf(stderr, \"[host-net] veth pair creation failed\\n\");\n        return -1;\n    }\n    // 3. Attach host-side veth to bridge\n    run(\"ip link set %s master %s\", VETH_HOST, BRIDGE_NAME);\n    run(\"ip link set %s up\", VETH_HOST);\n    // 4. Move container-side veth into container's network namespace\n    // This is the cross-namespace handoff: after this, veth_c0 is gone from host\n    if (run(\"ip link set %s netns %d\", VETH_CONT, container_pid) != 0) {\n        fprintf(stderr, \"[host-net] Failed to move veth to container namespace\\n\");\n        return -1;\n    }\n    // 5. IP forwarding: allow kernel to route packets between interfaces\n    run(\"sysctl -w net.ipv4.ip_forward=1 -q\");\n    // 6. NAT: MASQUERADE containers' private IPs as host IP for outbound traffic\n    // FORWARD rules: allow traffic to flow bridge <-> outbound interface\n    run(\"iptables -C FORWARD -i %s -o %s -j ACCEPT 2>/dev/null || \"\n        \"iptables -A FORWARD -i %s -o %s -j ACCEPT\",\n        BRIDGE_NAME, outbound_iface, BRIDGE_NAME, outbound_iface);\n    run(\"iptables -C FORWARD -i %s -o %s -m state \"\n        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || \"\n        \"iptables -A FORWARD -i %s -o %s -m state \"\n        \"--state RELATED,ESTABLISHED -j ACCEPT\",\n        outbound_iface, BRIDGE_NAME, outbound_iface, BRIDGE_NAME);\n    // POSTROUTING MASQUERADE: rewrite source IP for outbound packets\n    run(\"iptables -t nat -C POSTROUTING -s %s/24 -o %s -j MASQUERADE 2>/dev/null || \"\n        \"iptables -t nat -A POSTROUTING -s %s/24 -o %s -j MASQUERADE\",\n        BRIDGE_IP, outbound_iface, BRIDGE_IP, outbound_iface);\n    printf(\"[host-net] Network setup complete. Container IP: %s, Gateway: %s\\n\",\n           CONTAINER_IP, BRIDGE_IP);\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Cleanup: remove network resources on container exit\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic void cleanup_network(const char *outbound_iface) {\n    // veth_h0 is deleted automatically when its peer (veth_c0) is deleted\n    // or when the container namespace is destroyed. Explicit cleanup:\n    run(\"ip link del %s 2>/dev/null\", VETH_HOST);\n    run(\"ip link del %s 2>/dev/null\", BRIDGE_NAME);\n    run(\"iptables -t nat -D POSTROUTING -s %s/24 -o %s -j MASQUERADE 2>/dev/null\",\n        BRIDGE_IP, outbound_iface);\n    run(\"iptables -D FORWARD -i %s -o %s -j ACCEPT 2>/dev/null\",\n        BRIDGE_NAME, outbound_iface);\n    run(\"iptables -D FORWARD -i %s -o %s -m state \"\n        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\",\n        outbound_iface, BRIDGE_NAME);\n    printf(\"[host-net] Network resources cleaned up\\n\");\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Write DNS configuration before pivot_root\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int write_resolv_conf(const char *rootfs) {\n    char path[512];\n    snprintf(path, sizeof(path), \"%s/etc/resolv.conf\", rootfs);\n    FILE *f = fopen(path, \"w\");\n    if (!f) {\n        perror(\"fopen resolv.conf\");\n        return -1;\n    }\n    // Public DNS resolvers ‚Äî reachable once NAT is configured\n    fprintf(f, \"nameserver 8.8.8.8\\n\");\n    fprintf(f, \"nameserver 1.1.1.1\\n\");\n    fprintf(f, \"options ndots:0\\n\");\n    fclose(f);\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Main ‚Äî Host Side\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nint main(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr, \"Usage: %s <rootfs> <outbound-iface> <command> [args...]\\n\",\n                argv[0]);\n        fprintf(stderr, \"Example: %s ./alpine-rootfs eth0 /bin/sh\\n\", argv[0]);\n        return 1;\n    }\n    const char *rootfs        = argv[1];\n    const char *outbound_if   = argv[2];\n    char      **container_cmd = &argv[3];\n    // ‚îÄ‚îÄ Write DNS config before pivot_root ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (write_resolv_conf(rootfs) != 0) {\n        fprintf(stderr, \"Warning: DNS configuration failed\\n\");\n    }\n    // ‚îÄ‚îÄ Create sync pipe: parent signals container when network is ready ‚îÄ‚îÄ\n    int sync_pipe[2];\n    if (pipe(sync_pipe) != 0) {\n        perror(\"pipe\");\n        return 1;\n    }\n    // ‚îÄ‚îÄ Allocate child stack ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    char *stack = mmap(NULL, STACK_SIZE,\n                       PROT_READ | PROT_WRITE,\n                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n                       -1, 0);\n    if (stack == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    mprotect(stack, 4096, PROT_NONE);  // Guard page\n    char *stack_top = stack + STACK_SIZE;\n    // ‚îÄ‚îÄ Configure container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    container_config_t cfg = {\n        .rootfs          = (char *)rootfs,\n        .argv            = container_cmd,\n        .outbound_iface  = (char *)outbound_if,\n        .sync_pipe_read  = sync_pipe[0],\n    };\n    // ‚îÄ‚îÄ Clone with all namespace flags accumulated so far ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // CLONE_NEWNET: child gets empty network namespace\n    printf(\"[host] Creating container namespaces...\\n\");\n    pid_t container_pid = clone(container_init, stack_top,\n                                CLONE_NEWPID  |\n                                CLONE_NEWUTS  |\n                                CLONE_NEWNS   |\n                                CLONE_NEWNET  |   // ‚Üê NEW: network namespace\n                                SIGCHLD,\n                                &cfg);\n    if (container_pid == -1) {\n        perror(\"clone\");\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    printf(\"[host] Container host PID: %d\\n\", container_pid);\n    // Parent no longer needs the read end of sync pipe\n    close(sync_pipe[0]);\n    // ‚îÄ‚îÄ Host-side network setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // The container is blocked reading from sync_pipe[0], waiting for us.\n    if (setup_host_network(container_pid, outbound_if) != 0) {\n        fprintf(stderr, \"[host] Network setup failed ‚Äî terminating container\\n\");\n        kill(container_pid, SIGKILL);\n        waitpid(container_pid, NULL, 0);\n        close(sync_pipe[1]);\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    // ‚îÄ‚îÄ Signal container that network setup is complete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // This unblocks the container's read() in container_init().\n    write(sync_pipe[1], \"1\", 1);\n    close(sync_pipe[1]);\n    printf(\"[host] Signaled container ‚Äî network ready\\n\");\n    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    int status;\n    waitpid(container_pid, &status, 0);\n    printf(\"[host] Container exited\\n\");\n    // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    cleanup_network(outbound_if);\n    munmap(stack, STACK_SIZE);\n    return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n}\n```\nCompile and run:\n```bash\ngcc -o container_m3 container_m3.c\n# Ensure Alpine rootfs exists from Milestone 2:\nsudo ./container_m3 ./alpine-rootfs eth0 /bin/sh\n```\n> **Finding your outbound interface**: run `ip route | grep default` on the host. The `dev` field is your outbound interface (commonly `eth0`, `enp3s0`, `wlan0`, etc.).\n---\n## Extension: Raw Netlink Interface\nThe `system()` + `ip` command approach above is clear and correct, but production container runtimes use the **rtnetlink** socket API directly ‚Äî the same API that `iproute2` (`ip` command) uses internally. Using Netlink avoids the overhead of spawning a shell for each operation and gives you precise error handling.\nThe key operations via Netlink:\n```c\n#include <linux/rtnetlink.h>\n#include <linux/if_link.h>\n#include <linux/veth.h>\n#include <net/if.h>\n#include <sys/socket.h>\n// Helper: open a Netlink socket for rtnetlink operations\nstatic int nl_socket_open(void) {\n    int fd = socket(AF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);\n    if (fd < 0) {\n        perror(\"netlink socket\");\n        return -1;\n    }\n    struct sockaddr_nl sa = {\n        .nl_family = AF_NETLINK,\n    };\n    if (bind(fd, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n        perror(\"netlink bind\");\n        close(fd);\n        return -1;\n    }\n    return fd;\n}\n// Create a veth pair via Netlink RTM_NEWLINK message.\n// This is what 'ip link add veth_h0 type veth peer name veth_c0' does internally.\n// Full implementation requires constructing nested Netlink attributes ‚Äî\n// see linux/if_link.h for IFLA_LINKINFO, IFLA_INFO_KIND, IFLA_INFO_DATA.\n// The structure:\n//   RTM_NEWLINK\n//   ‚îî‚îÄ‚îÄ IFLA_IFNAME: \"veth_h0\"\n//   ‚îî‚îÄ‚îÄ IFLA_LINKINFO\n//       ‚îî‚îÄ‚îÄ IFLA_INFO_KIND: \"veth\"\n//       ‚îî‚îÄ‚îÄ IFLA_INFO_DATA\n//           ‚îî‚îÄ‚îÄ VETH_INFO_PEER\n//               ‚îî‚îÄ‚îÄ ifinfomsg (for veth_c0)\n//               ‚îî‚îÄ‚îÄ IFLA_IFNAME: \"veth_c0\"\n```\n[[EXPLAIN:rtnetlink-message-construction-and-nested-attributes|rtnetlink Netlink message structure and nested attribute encoding]]\nThe `libmnl` library provides a cleaner C API for Netlink message construction and is used by `iproute2` itself. For a production container runtime, use `libmnl` rather than raw Netlink socket construction.\n---\n## The Packet Walk: Container to Internet\nUnderstanding what happens to a single packet as it travels from container to internet solidifies the entire topology. Follow a `curl https://example.com` packet step by step:\n```\n1. Container process calls connect(fd, 93.184.216.34:443)\n   ‚îÇ\n   ‚îî‚îÄ‚îÄ Kernel creates TCP SYN packet\n       Source IP:  172.20.0.2 (container's veth_c0 IP)\n       Source Port: 54321 (ephemeral)\n       Dest IP:    93.184.216.34\n2. Routing lookup in container's namespace:\n   Route: default via 172.20.0.1 dev veth_c0\n   ‚Üí Next hop: 172.20.0.1, send out veth_c0\n3. veth_c0 ‚Üí kernel's veth_xmit() ‚Üí packet arrives at veth_h0\n   (This is the namespace boundary crossing ‚Äî pure function call in kernel)\n4. veth_h0 is a bridge port ‚Üí Linux bridge receives packet\n   Bridge FDB lookup: 172.20.0.1 ‚Üí local (bridge owns this IP)\n   Packet delivered to bridge interface (ctr0)\n5. ctr0 is in the host network namespace ‚Üí kernel routing in HOST namespace\n   Host routing table: 93.184.216.34 ‚Üí via <gateway> dev eth0\n   ‚Üí Next hop: send out eth0\n6. Before leaving eth0: netfilter POSTROUTING chain\n   Rule: -t nat -A POSTROUTING -s 172.20.0.0/24 -o eth0 -j MASQUERADE\n   ‚Üí MASQUERADE fires: source IP rewritten 172.20.0.2 ‚Üí host's eth0 IP (e.g., 192.168.1.100)\n   ‚Üí Connection tracked: (172.20.0.2:54321) ‚Üî (192.168.1.100:54321) saved in conntrack table\n7. Packet leaves eth0 with source 192.168.1.100:54321\n   Destination server responds to 192.168.1.100:54321\n8. Response arrives at host eth0\n   Netfilter PREROUTING: conntrack lookup finds 192.168.1.100:54321\n   ‚Üí DNAT: destination rewritten to 172.20.0.2:54321\n9. Kernel routes to 172.20.0.2 ‚Üí bridge ctr0 ‚Üí veth_h0 ‚Üí veth_c0 ‚Üí container\n```\n\n![Packet Walk: Container ‚Üí Bridge ‚Üí NAT ‚Üí Internet](./diagrams/diag-packet-walk-container-to-internet.svg)\n\nThe conntrack (connection tracking) table is the invisible glue that makes stateful NAT work. The kernel records every outbound connection translation and automatically applies the reverse translation to incoming responses. Without conntrack, NAT would require explicit DNAT rules for every outbound connection ‚Äî which is obviously impractical.\n---\n## Hardware Soul: What the Kernel Is Actually Doing\n### veth Packet Transmission Latency\nWhen a packet crosses a veth pair, the kernel calls `veth_xmit()` in `drivers/net/veth.c`:\n```c\n// Simplified veth_xmit() ‚Äî what happens when you send a packet into a veth\nstatic netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev) {\n    struct veth_priv *rcv_priv = netdev_priv(rcv); // peer interface\n    // RX on the peer ‚Äî push skb into peer's receive queue\n    if (likely(veth_forward_skb(rcv, skb, rq, use_napi) == NET_RX_SUCCESS)) {\n        // ...\n    }\n    return NETDEV_TX_OK;\n}\n```\nThe sk_buff (socket buffer) ‚Äî Linux's packet representation ‚Äî contains:\n- A pointer to the packet data (typically in DMA-accessible memory)\n- Header pointers (network layer, transport layer)\n- Metadata: timestamps, checksum offload flags, mark bits\n`veth_xmit()` moves the sk_buff pointer from the transmit queue of one veth end to the receive queue of the other ‚Äî no memory copy, no hardware DMA, no interrupt. It's O(1) in data size.\n**Cache behavior**:\n- The sk_buff itself is ~200 bytes ‚Äî fits in one or two cache lines\n- The packet data is a separate allocation (typically 2-4 KB for a full MTU packet)\n- `veth_xmit()` touches: the sk_buff header (hot), the peer's receive queue spinlock (potentially contended), the peer's NAPI poll list (cold on first access)\n**Measured latency** (same-host container-to-container via veth+bridge):\n- Typical: 15-40 Œºs RTT (microseconds) for a 64-byte UDP ping\n- Compare: host-to-host on localhost (`lo`): 5-10 Œºs RTT\n- Compare: hardware NIC round trip (same switch): 80-200 Œºs RTT\nThe veth overhead (~10-30 Œºs over loopback) comes from:\n1. Two full kernel network stack traversals (TX path + RX path, each namespace)\n2. Netfilter hook evaluation (iptables rules checked at each hook point)\n3. Bridge FDB lookup (MAC table scan ‚Äî O(1) with hash table, but cache miss if cold)\n**Why host networking is faster**: `--network=host` in Docker bypasses veth entirely. The container process uses the host's network stack directly, same as a non-containerized process. No extra traversal, no bridge, no NAT. Used for latency-sensitive workloads: high-frequency trading, game servers, DPDK-based applications.\n### iptables MASQUERADE Performance\nEvery outbound packet from the container traverses the netfilter POSTROUTING hook. The kernel evaluates the iptables rule:\n```\n-t nat -A POSTROUTING -s 172.20.0.0/24 -o eth0 -j MASQUERADE\n```\nRule evaluation is linear scan through the rule chain (for iptables; `nftables` and eBPF use hash maps for O(1)). With one rule, this is negligible. With thousands of rules (large Kubernetes clusters with many services and policies), iptables rule evaluation becomes measurable overhead ‚Äî the famous iptables scaling problem that motivated `ipvs` mode in `kube-proxy` and ultimately eBPF-based solutions (Cilium).\nFor our single-container runtime: MASQUERADE costs approximately 200-500 ns per packet (conntrack lookup + rule match + source IP rewrite). For bulk data transfer, the per-packet overhead amortizes across large segments. For small-packet workloads (many tiny writes), it's measurable.\n### TLB and Page Table Impact\nNetwork namespaces don't directly create new address spaces ‚Äî they're kernel data structures, not process address spaces. The TLB is not affected by namespace creation or packet forwarding.\nThe one TLB-relevant operation: when the kernel switches between the container's network namespace and the host's (during bridge forwarding), it accesses different `struct net` objects. These objects are typically in different cache lines and may not be hot. First-packet latency for a new connection from a container that hasn't recently sent traffic will be slightly higher (cold cache) ‚Äî subsequent packets benefit from the warm cache.\n---\n## Pitfall Compendium\n### Pitfall 1: Creating veth Pair Before Container Namespace Exists\n```\n‚ùå WRONG approach (conceptual):\n   1. Create veth pair\n   2. clone(CLONE_NEWNET)\n   3. Try to move veth into container ‚Äî but what is the container's PID?\n      You don't know it yet, and the namespace doesn't exist yet.\n‚úÖ CORRECT approach (what we implemented):\n   1. clone(CLONE_NEWNET) ‚Üí get container_pid\n   2. Create veth pair on host\n   3. ip link set veth_c0 netns <container_pid>\n   4. Signal container to proceed\n```\nThe container's network namespace exists the moment `clone()` returns ‚Äî the child process is created with an empty network namespace. The host can then \"inject\" the veth interface into it using `ip link set ... netns <pid>`.\n### Pitfall 2: Forgetting to Bring Up Loopback\nThis is the most common silent failure. Applications that bind to `127.0.0.1` (many server processes bind loopback first as a health-check port) fail with `EADDRNOTAVAIL` if loopback is down. `ss -tlnp` inside the container won't show any issue ‚Äî the interface is just down.\n```bash\n# Verify loopback is up inside container:\nip link show lo\n# Should show: UP LOWER_UP (not DOWN)\n# Test loopback:\nping 127.0.0.1 -c 1\n```\n### Pitfall 3: IP Forwarding Not Enabled on Host\n```bash\n# Check current setting:\nsysctl net.ipv4.ip_forward\n# net.ipv4.ip_forward = 0   ‚Üê BLOCKED. Packets dropped at FORWARD chain.\n# Enable temporarily (lost on reboot):\nsysctl -w net.ipv4.ip_forward=1\n# Enable permanently:\necho \"net.ipv4.ip_forward=1\" >> /etc/sysctl.conf\nsysctl -p\n```\nWithout IP forwarding, the FORWARD iptables chain is never reached ‚Äî packets arriving on `ctr0` (from the container) destined for `eth0` are silently dropped. The container can ping the gateway (`172.20.0.1`) but cannot reach anything beyond it. This is a maddening debugging scenario because the symptom is \"can ping gateway, cannot ping internet\" which looks like a routing issue, but it's actually a kernel forwarding policy issue.\n### Pitfall 4: veth Pair Left Behind After Container Exit\nThe veth pair and bridge persist after the container exits unless explicitly deleted. Running the container a second time fails because `veth_h0` and `veth_c0` already exist. The cleanup function in our implementation handles this, but it must run even when the container exits abnormally (signal, kill). Use `atexit()` or a signal handler:\n```c\n// Register cleanup at program start\nstatic const char *g_outbound_if = NULL;\nstatic void cleanup_on_exit(void) {\n    if (g_outbound_if)\n        cleanup_network(g_outbound_if);\n}\n// In main():\ng_outbound_if = outbound_if;\natexit(cleanup_on_exit);\n```\n### Pitfall 5: NAT Rule Duplication\nThe idempotent check in our `setup_nat()` (using `iptables -C` to check before `-A` to add) prevents duplicates within a single run. But if the program crashes without cleanup, NAT rules accumulate on subsequent runs. The `cleanup_network()` function uses `iptables -D` (delete) to remove them ‚Äî but multiple accumulated rules require multiple `-D` invocations.\nFor robust cleanup: use `iptables -F` (flush chain) or better, use **named iptables chains** that can be created/deleted atomically:\n```bash\n# Create a named chain for our container's NAT rules\niptables -t nat -N CONTAINER_NAT\niptables -t nat -A POSTROUTING -j CONTAINER_NAT\niptables -t nat -A CONTAINER_NAT -s 172.20.0.0/24 -o eth0 -j MASQUERADE\n# Cleanup: flush and delete the chain\niptables -t nat -F CONTAINER_NAT\niptables -t nat -D POSTROUTING -j CONTAINER_NAT\niptables -t nat -X CONTAINER_NAT\n```\nThis is exactly what Docker does ‚Äî `docker0` has its own iptables chain (`DOCKER`, `DOCKER-USER`, `DOCKER-ISOLATION-STAGE-1`, `DOCKER-ISOLATION-STAGE-2`).\n### Pitfall 6: DNS Resolution Fails Silently\n```bash\n# Inside container after pivot_root ‚Äî try DNS:\nnslookup google.com\n# ;; connection timed out; no servers could be reached\n# Debug:\ncat /etc/resolv.conf\n# (empty or missing)\n# Test with explicit nameserver:\nnslookup google.com 8.8.8.8\n# Works! ‚Äî confirms NAT is functional, only resolv.conf was missing\n```\nAlways write `/etc/resolv.conf` before `pivot_root()`. After `pivot_root()`, the container's `/etc/` is in the container rootfs ‚Äî writes go there. But the `write_resolv_conf()` function in our implementation writes to `<rootfs>/etc/resolv.conf` *from the host*, before the container starts. This is the correct sequence.\n---\n## Verification Checklist\n```bash\n# ‚îÄ‚îÄ 1. Verify network namespace isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container: only lo and veth_c0 should be visible\nip link show\n# Should show: lo (UP) and veth_c0 (UP) ‚Äî NOT eth0, wlan0, etc.\n# ‚îÄ‚îÄ 2. Verify IP assignment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nip addr show veth_c0\n# Should show: 172.20.0.2/24\n# ‚îÄ‚îÄ 3. Verify routing table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nip route\n# Should show:\n# default via 172.20.0.1 dev veth_c0\n# 172.20.0.0/24 dev veth_c0  proto kernel  scope link  src 172.20.0.2\n# ‚îÄ‚îÄ 4. Verify loopback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nping 127.0.0.1 -c 1\n# 1 packets transmitted, 1 received\n# ‚îÄ‚îÄ 5. Verify gateway reachability ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nping 172.20.0.1 -c 3\n# Should get replies from the host bridge IP\n# ‚îÄ‚îÄ 6. Verify internet connectivity (requires NAT to be working) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nping 8.8.8.8 -c 3\n# Replies from Google's DNS server\n# ‚îÄ‚îÄ 7. Verify DNS resolution ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /etc/resolv.conf\n# nameserver 8.8.8.8\n# nameserver 1.1.1.1\nnslookup google.com\n# Non-authoritative answer: google.com address 142.250.x.x\n# ‚îÄ‚îÄ 8. Verify port isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nnc -l 0.0.0.0 8080 &\n# On host: try to connect to container IP on 8080\nnc -z 172.20.0.2 8080  # Should succeed (bridge routes to it)\n# On host: verify host's 0.0.0.0:8080 is NOT bound\nss -tlnp | grep 8080   # Should show nothing ‚Äî container's port is isolated\n# ‚îÄ‚îÄ 9. Verify host-side bridge and veth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# On host:\nip link show ctr0\n# ctr0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue\nip link show veth_h0\n# veth_h0: master ctr0 state UP\n# ‚îÄ‚îÄ 10. Verify cleanup on exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# After container exits:\nip link show ctr0 2>&1\n# Device \"ctr0\" does not exist ‚Äî cleaned up\niptables -t nat -L POSTROUTING -n | grep 172.20.0\n# (empty) ‚Äî NAT rule removed\n```\n---\n## Knowledge Cascade: What This Unlocks\n### 1. Kubernetes Networking Model (Cross-Domain)\nEvery Kubernetes pod gets its own network namespace ‚Äî created using exactly the same `CLONE_NEWNET` + veth pair mechanism you just built. The pod's \"pause container\" holds the network namespace; all other containers in the pod join it via `setns()`. This is why all containers in a pod share a network stack ‚Äî they share one network namespace.\nA **CNI (Container Network Interface) plugin** is called after pod creation to configure the network namespace. The CNI plugin creates veth pairs, attaches them to a bridge (or VXLAN overlay, or BGP-routed interface), assigns pod IPs, and configures routes ‚Äî exactly the same operations you just implemented. Calico, Flannel, Cilium, Weave ‚Äî they all do the same thing at this level. Their differences are in:\n- **Flannel**: simple VXLAN overlay (encapsulates pod packets in UDP for cross-node routing)\n- **Calico**: BGP routing of pod CIDR blocks, no overlay needed in routed networks\n- **Cilium**: eBPF programs instead of iptables for O(1) policy enforcement\nWhen you debug \"pod cannot reach service\" in Kubernetes:\n```bash\n# Check the pod's veth pair:\nip link show | grep veth\n# Check the bridge/CNI interface:\nip link show cni0  # Flannel's bridge (equivalent to our ctr0)\n# Check iptables rules (kube-proxy's service rules):\niptables -t nat -L -n | grep <service-cluster-ip>\n# Enter the pod's network namespace directly:\nnsenter --net=/proc/<pod-pid>/ns/net ip addr\nnsenter --net=/proc/<pod-pid>/ns/net ip route\n```\nYou now have the vocabulary to do this effectively. The abstractions (CNI, kube-proxy, services) are built on exactly what you just implemented.\n### 2. Service Mesh Data Plane (Istio/Envoy)\nWhen Istio injects an Envoy sidecar into your pod, it adds an `iptables` rule **inside the pod's network namespace**:\n```\niptables -t nat -A OUTPUT -p tcp -j REDIRECT --to-port 15001\n```\nThis rule redirects all outbound TCP traffic from the application to Envoy's port 15001, before it leaves the pod. Envoy then applies mTLS, retries, circuit breaking, and telemetry ‚Äî transparently, without the application knowing.\nThis is the same `iptables REDIRECT` mechanism as MASQUERADE, operating in the same netfilter framework, inside the same network namespace you just created. The \"magic\" of transparent proxying in service meshes is: `iptables` rules in the pod's network namespace, configured by the init container before the application starts. Understanding your `iptables MASQUERADE` rule directly translates to understanding Istio's traffic interception model.\n### 3. Network Performance: veth vs Host vs macvlan\nThe ~10-30 Œºs veth overhead matters for latency-sensitive workloads. Three alternatives exist:\n| Mode | Mechanism | Latency | Use Case |\n|------|-----------|---------|----------|\n| **veth+bridge** | Two NS traversals | 15-40 Œºs RTT | Default Docker, Kubernetes |\n| **host networking** | No NS, no NAT | 5-10 Œºs RTT | High-perf, monitoring agents |\n| **macvlan** | Direct NIC sub-interface | 8-15 Œºs RTT | Bare-metal performance |\n| **SR-IOV** | Hardware vNIC | 3-8 Œºs RTT | Telco, HPC |\n`macvlan` creates a sub-interface directly on a physical NIC ‚Äî each container gets a MAC address on the physical network. No bridge, no NAT, packets go directly through the NIC. The tradeoff: macvlan interfaces can't communicate with their parent interface (the host). Kubernetes uses macvlan via `macvlan` CNI for cases where pod IPs need to be routeable on the physical network directly.\nUnderstanding veth overhead explains why database containers, message queues, and caches often use `--network=host` in performance-critical deployments ‚Äî and why Kubernetes `hostNetwork: true` exists.\n### 4. DNS Resolution ‚Äî The #1 Container Networking Bug\nDNS inside containers fails in three distinct, confusing ways:\n**Scenario A**: `/etc/resolv.conf` missing ‚Üí immediate `SERVFAIL` on first lookup. Obvious from `cat /etc/resolv.conf`.\n**Scenario B**: `resolv.conf` present but points to a DNS server unreachable from inside the container (e.g., `127.0.0.53` ‚Äî systemd-resolved's stub listener on the host). The container can't reach `127.0.0.53` because that's the host's loopback. Symptom: DNS timeouts, not `SERVFAIL`.\n**Scenario C** (Kubernetes-specific): `resolv.conf` points to `kube-dns` service IP (`10.96.0.10` in default clusters). kube-dns is itself a pod. If the kube-dns pod is down, all DNS in the cluster fails ‚Äî cascading failure that looks like \"my application is broken\" rather than \"DNS is broken.\" This is called a **DNS split-brain** failure and it's the most common production Kubernetes incident.\nThe debugging ladder:\n```bash\n# Step 1: Can I reach the nameserver at all?\nping $(grep nameserver /etc/resolv.conf | head -1 | awk '{print $2}')\n# Step 2: Can the nameserver answer?\nnslookup google.com <nameserver-ip>\n# Step 3: Is the failure DNS-specific or network-general?\ncurl https://8.8.8.8 --resolve google.com:443:8.8.8.8\n# Uses explicit IP ‚Äî bypasses DNS\n```\nUnderstanding that `/etc/resolv.conf` is a static file written during container creation (not dynamically updated) explains why Kubernetes's `dnsPolicy: ClusterFirst` and `ndots: 5` setting causes performance issues: `ndots:5` means 5-dot search expansion, turning `http://myservice` into 6 DNS queries before resolving. Production clusters tune this to `ndots: 2` or `1`.\n### 5. Network Policy Enforcement (Calico/Cilium)\nContainer network policy (Kubernetes `NetworkPolicy` objects) is enforced by attaching rules at the veth interface level. Where exactly?\n**Calico with iptables**: programs `iptables` rules on the host at the veth interface:\n```bash\n# Calico creates chains like:\niptables -A cali-from-wl-dispatch -i cali<hash> -j cali-from-wl-<endpoint>\n```\n**Cilium with eBPF**: attaches eBPF programs to the TC (Traffic Control) hook on the veth interface ‚Äî earlier in the packet path than iptables, lower overhead, O(1) policy lookup via eBPF hash maps instead of iptables linear scan.\nThe veth interface is the natural policy enforcement point: it's the first kernel touch point for packets entering or leaving a container. Everything that flows to/from a container must cross the veth. This is why CNI plugins attach hooks there ‚Äî there's no way to bypass it without bypassing the entire network namespace model.\nUnderstanding this: when a Kubernetes network policy says \"deny all ingress to pod A except from pods with label app=frontend,\" that rule is an iptables chain (or eBPF program) on the veth interface that connects pod A's namespace to the host. Every packet entering pod A's veth from the bridge is evaluated against this rule.\n---\n## The One-Line Summary\nContainer networking is: `CLONE_NEWNET` (isolate) + veth pair (connect) + bridge (switch) + iptables MASQUERADE (route). Every container runtime from Docker to Kubernetes CNI is built from these four primitives. You've now built them from scratch.\n\n![Container Runtime Architecture ‚Äî Satellite Map](./diagrams/diag-satellite-map.svg)\n\n---\n<!-- END_MS -->\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m4 -->\n<!-- MS_ID: container-basic-m4 -->\n# Milestone 4: Cgroups Resource Limits\n## The Illusion You Are About to Break\nYour container from Milestone 3 has genuine isolation: its own process tree, its own filesystem, its own network stack. But open a shell inside it and run this:\n```bash\n# Inside your container ‚Äî watch this exhaust host memory\nwhile true; do\n    dd if=/dev/zero of=/tmp/blob bs=1M count=100\ndone\n```\nLet it run for thirty seconds. Check your host's `free -m`. The host is running out of memory ‚Äî because your \"isolated\" container is consuming shared physical RAM with no limit. The isolation you've built so far is **visibility isolation**: the container can't *see* host processes, can't *see* host files, can't *see* host network interfaces. But it can *consume* host resources without any restraint.\nNow try this:\n```bash\n# A classic fork bomb ‚Äî inside your container\n:(){ :|:& };:\n```\nWatch `ps aux` on the host. Your container is spawning thousands of processes, consuming host PIDs, potentially making the entire system unresponsive. There's no wall. There's no limit. The \"container\" has a view restriction but no resource restriction.\nThis is the gap that **cgroups** fills. But before we get to the implementation, you need to shed a misconception that's so natural it will feel correct even after you've read this sentence.\n---\n## The Revelation: Cgroups Don't Prevent ‚Äî They React\nHere is what most developers believe when they first set a memory limit:\n> \"I've set `memory.max = 100MB`. The container now has exactly 100MB of memory available. When it tries to allocate the 101st megabyte, the allocation will fail ‚Äî `malloc()` will return `NULL`, the process will handle the error, and life will continue.\"\nThis model is wrong in almost every detail.\nHere's what actually happens:\nThe kernel's memory accounting is **lazy and retrospective**. The kernel tracks how much memory is attributed to each cgroup ‚Äî RSS (resident set size, meaning pages actually in RAM), anonymous memory, and page cache ‚Äî and compares that running total against `memory.max`. But it doesn't check this limit *before* every allocation. It checks it *during page fault handling*, after the physical page has been assigned.\nWhen the cgroup's memory usage exceeds `memory.max`, the kernel doesn't return a failure code to the allocating process. Instead, it invokes the **OOM killer** (Out-of-Memory killer) ‚Äî a kernel subsystem that selects a process *inside the cgroup* and sends it `SIGKILL`. The selection is not random. The OOM killer uses a scoring algorithm based on `oom_score_adj` (a tunable per-process value) and memory usage to select the most expendable process.\n\n![Memory Limit ‚Üí OOM Kill Sequence](./diagrams/diag-memory-limit-oom-sequence.svg)\n\nThe implication: **a memory-limited container can appear healthy for a long time while slowly accumulating memory, then suddenly and without warning get killed.** From the container's perspective ‚Äî and from the perspective of whatever monitoring you have ‚Äî everything is fine until it isn't. There's no \"allocation failed\" error. There's no graceful degradation. There's just a `SIGKILL` arriving at some process, often not even the one that was doing the allocating.\nThis is the root cause of one of the most frustrating classes of production incidents: \"the container just dies randomly.\"\nCPU limits contain an equally important surprise. Setting `cpu.max = '50000 100000'` (which reads as \"50,000 microseconds of CPU time per 100,000 microsecond period\") does *not* give the container 50% of a CPU core continuously. It gives the container *50 milliseconds of CPU time per 100-millisecond period* ‚Äî and when those 50ms are consumed, the container's processes are **throttled** (forcibly paused by the CFS scheduler) until the next period begins, even if the host CPU is sitting at 5% utilization overall.\n\n![CFS CPU Throttling ‚Äî Quota/Period Timeline](./diagrams/diag-cpu-throttling-timeline.svg)\n\nThis throttling is the source of one of Kubernetes's most common and frustrating performance problems: a container that sets CPU limits too low experiences **latency spikes** at the period boundary, even when the node has plenty of spare CPU capacity. The metric that reveals this is `cpu.stat`'s `throttled_usec` counter ‚Äî a number that most developers never look at until something is mysteriously slow.\nYou are about to build the machinery that causes these behaviors. Understanding what you're building is more important than the implementation itself.\n---\n## What Cgroups Are: The Kernel's Resource Accounting Ledger\n\n> **üîë Foundation: cgroups v2 unified hierarchy filesystem interface**\n> \n> **1. What it IS**\nControl Groups (cgroups) version 2 is the Linux kernel feature used to organize processes into a tree structure to manage and monitor resource usage (CPU, memory, I/O). The \"unified hierarchy\" means that, unlike version 1 which had separate trees for each resource, v2 forces all resource controllers into a single, consistent directory structure located at `/sys/fs/cgroup`. The \"filesystem interface\" refers to the fact that you manage these groups by simply creating directories and reading/writing plain text files within that path.\n\n**2. WHY the reader needs it right now**\nModern container runtimes (like containerd and CRI-O) and Kubernetes (since version 1.25) have transitioned to cgroups v2 as the default. If you are debugging why a container is being throttled or why memory limits aren't behaving as expected, you need to look at the unified hierarchy. The files you used to check in v1 (like `memory.limit_in_bytes`) have been renamed and moved (to `memory.max`).\n\n**3. ONE key insight or mental model**\n**\"The Single-Writer Rule.\"** In cgroups v2, a process cannot belong to two different groups at once, and a directory cannot both contain processes and have child groups that also contain processes (except at the root). This eliminates the \"spaghetti\" logic of v1 where a process could be in one group for CPU and a completely different group for RAM.\n\nA **cgroup** (control group) is a kernel data structure that associates a set of processes with a set of resource controllers. A **resource controller** (also called a subsystem) is a kernel module that tracks and enforces limits on a specific resource: memory, CPU time, I/O bandwidth, or process count.\nThe interaction model is unusual: cgroups are configured entirely through a **pseudo-filesystem** mounted at `/sys/fs/cgroup`. There are no special syscalls for cgroup operations. Creating a cgroup is `mkdir`. Assigning a process to it is `write(pid)`. Setting limits is `write(value)`. Reading usage is `read(file)`. The filesystem interface *is* the API.\n```bash\n# This is how you create a cgroup:\nmkdir /sys/fs/cgroup/mycontainer\n# This is how you assign a process (PID 1234) to it:\necho 1234 > /sys/fs/cgroup/mycontainer/cgroup.procs\n# This is how you set a 100MB memory limit:\necho $((100 * 1024 * 1024)) > /sys/fs/cgroup/mycontainer/memory.max\n# This is how you read current memory usage:\ncat /sys/fs/cgroup/mycontainer/memory.current\n```\nThat's the entire interface. No library, no syscall wrapper, no special header file. Read and write to files.\n\n![cgroups v2 Unified Hierarchy ‚Äî Filesystem Layout](./diagrams/diag-cgroups-v2-hierarchy.svg)\n\nThe hierarchy is also a filesystem directory tree. Child cgroups inherit constraints from parents but can set tighter (never looser) limits. This is why Kubernetes's `--cgroup-parent` flag works: Kubernetes creates a parent cgroup for each pod, and individual container cgroups live inside it. Resource limits cascade.\n---\n## cgroups v1 vs v2: The Architectural Schism You Must Detect\nLinux shipped cgroups v1 starting with kernel 2.6.24 (2008). The design was decentralized: each controller (memory, cpu, pids) had its own independent hierarchy, mounted at separate paths:\n```\n/sys/fs/cgroup/memory/mycontainer/    # v1 memory controller\n/sys/fs/cgroup/cpu/mycontainer/       # v1 CPU controller\n/sys/fs/cgroup/pids/mycontainer/      # v1 PID controller\n```\nA process could belong to different cgroups in each controller hierarchy simultaneously ‚Äî which sounds flexible but caused nightmarish consistency problems. The memory controller thought a process was in group A; the CPU controller thought it was in group B. Coordinating between controllers required keeping multiple hierarchies in sync manually.\ncgroups v2 arrived in Linux 4.5 (2016) and became the default on most distributions around 2020-2021. It uses a **unified hierarchy**: one directory tree under `/sys/fs/cgroup`, and a process belongs to exactly one cgroup in that tree. All controllers operate on that same cgroup. Consistency is structural, not maintained manually.\n\n![cgroups v1 vs v2 ‚Äî Architecture Comparison](./diagrams/diag-cgroup-v1-vs-v2.svg)\n\nThe file names changed between versions:\n| Operation | v1 file | v2 file |\n|-----------|---------|---------|\n| Assign process | `cgroup.procs` (same) | `cgroup.procs` (same) |\n| Memory limit | `memory.limit_in_bytes` | `memory.max` |\n| Memory usage | `memory.usage_in_bytes` | `memory.current` |\n| CPU quota | `cpu.cfs_quota_us` + `cpu.cfs_period_us` | `cpu.max` (combined) |\n| CPU usage | `cpuacct.usage` (separate subsystem) | `cpu.stat` |\n| PID limit | `pids.max` (same) | `pids.max` (same) |\nYour code must detect which version is active before performing any cgroup operations. The detection is simple: cgroups v2 exposes a `cgroup.controllers` file at the root; v1 does not.\n```c\n// Returns: 2 for v2, 1 for v1, -1 on error\nstatic int detect_cgroup_version(void) {\n    struct stat st;\n    // cgroups v2 unified hierarchy: the root exposes cgroup.controllers\n    if (stat(\"/sys/fs/cgroup/cgroup.controllers\", &st) == 0) {\n        return 2;\n    }\n    // cgroups v1: the root has per-subsystem directories\n    if (stat(\"/sys/fs/cgroup/memory\", &st) == 0) {\n        return 1;\n    }\n    return -1;\n}\n```\nModern Ubuntu (22.04+), Fedora (33+), Debian (11+), and Alpine (3.16+) all default to cgroups v2. If you're running a production system from 2019 or earlier, you may still have v1. Our implementation handles both, but optimizes for clarity on v2.\n---\n## The Controller Enablement Problem: The Subtlety That Breaks Everyone\nHere is the gotcha that derails almost every first cgroups v2 implementation:\nIn cgroups v2, resource controllers are **not automatically available** in newly created child cgroups. Before you can use the `memory` or `cpu` controller in a child cgroup, you must explicitly enable it in the *parent* cgroup's `cgroup.subtree_control` file.\n```bash\n# Enable memory, cpu, and pids controllers for children of root cgroup\necho \"+memory +cpu +pids\" > /sys/fs/cgroup/cgroup.subtree_control\n# NOW you can create a child cgroup that uses these controllers\nmkdir /sys/fs/cgroup/mycontainer\n# WITHOUT the above step, writing to memory.max gives: EINVAL\necho 104857600 > /sys/fs/cgroup/mycontainer/memory.max\n# write: Invalid argument  ‚Üê confusing error if you don't know about subtree_control\n```\nThe `cgroup.subtree_control` file governs which controllers are available to *child* cgroups. The parent cgroup must delegate the controller to its children. This cascades: if you want a grandchild cgroup to have the memory controller, both the root and the intermediate parent must have `+memory` in their `subtree_control`.\nOn systemd-based systems (the vast majority of modern Linux), systemd manages the root cgroup and has already enabled the common controllers. But if you're running in a container already (a container inside a container), or on a minimal system, you may need to enable them yourself.\n```c\n// Enable controllers in the parent cgroup before creating the container's cgroup.\n// This is idempotent: enabling an already-enabled controller is not an error.\nstatic int enable_controllers_v2(const char *parent_cgroup_path) {\n    char path[512];\n    snprintf(path, sizeof(path), \"%s/cgroup.subtree_control\", parent_cgroup_path);\n    int fd = open(path, O_WRONLY);\n    if (fd < 0) {\n        perror(\"open cgroup.subtree_control\");\n        return -1;\n    }\n    // Enable memory, cpu, and pids controllers\n    const char *controllers = \"+memory +cpu +pids\";\n    if (write(fd, controllers, strlen(controllers)) < 0) {\n        perror(\"write cgroup.subtree_control\");\n        close(fd);\n        return -1;\n    }\n    close(fd);\n    return 0;\n}\n```\n---\n## Building the Cgroup Manager: Complete Implementation\nNow you have all the conceptual groundwork. Let's build the cgroup management layer that integrates with the container runtime from the previous milestones.\nThe architecture: the host process (the container runtime, running as root) creates and configures the cgroup *before* signaling the container to proceed. The container PID is written to `cgroup.procs` after `clone()` but before the container calls `exec()`. The synchronization pipe from Milestone 3 gives us the natural hook: host writes to sync pipe only after cgroup setup is complete.\n\n![Cgroup Lifecycle ‚Äî Create, Assign, Monitor, Cleanup](./diagrams/diag-cgroup-lifecycle.svg)\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Cgroup configuration ‚Äî what resource limits to apply\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ntypedef struct {\n    long  memory_limit_bytes;  // -1 means \"no limit\" (write \"max\" to memory.max)\n    long  cpu_quota_us;        // CFS quota in microseconds per period; -1 = unlimited\n    long  cpu_period_us;       // CFS period in microseconds (default: 100000 = 100ms)\n    int   pids_max;            // Maximum number of processes; -1 = unlimited\n} cgroup_config_t;\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Internal helpers: write a string or integer to a cgroup file\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int cg_write_str(const char *dir, const char *file, const char *value) {\n    char path[512];\n    snprintf(path, sizeof(path), \"%s/%s\", dir, file);\n    int fd = open(path, O_WRONLY);\n    if (fd < 0) {\n        fprintf(stderr, \"cgroup: open(%s): %s\\n\", path, strerror(errno));\n        return -1;\n    }\n    ssize_t n = write(fd, value, strlen(value));\n    int err = errno;\n    close(fd);\n    if (n < 0) {\n        fprintf(stderr, \"cgroup: write(%s, '%s'): %s\\n\", path, value, strerror(err));\n        return -1;\n    }\n    return 0;\n}\nstatic int cg_write_long(const char *dir, const char *file, long value) {\n    char buf[64];\n    snprintf(buf, sizeof(buf), \"%ld\", value);\n    return cg_write_str(dir, file, buf);\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Read a cgroup file ‚Äî used for reporting and verification\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int cg_read_str(const char *dir, const char *file,\n                        char *buf, size_t bufsz) {\n    char path[512];\n    snprintf(path, sizeof(path), \"%s/%s\", dir, file);\n    int fd = open(path, O_RDONLY);\n    if (fd < 0) return -1;\n    ssize_t n = read(fd, buf, bufsz - 1);\n    close(fd);\n    if (n < 0) return -1;\n    buf[n] = '\\0';\n    // Trim trailing newline for clean display\n    if (n > 0 && buf[n-1] == '\\n') buf[n-1] = '\\0';\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// cgroups v2: configure a single unified cgroup\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#define CGROOT_V2  \"/sys/fs/cgroup\"\nstatic int cgroup_setup_v2(const char *cgroup_name,\n                            pid_t container_pid,\n                            const cgroup_config_t *cfg) {\n    char cg_path[512];\n    snprintf(cg_path, sizeof(cg_path), \"%s/%s\", CGROOT_V2, cgroup_name);\n    // ‚îÄ‚îÄ Step 1: Enable controllers in the root cgroup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Allow child cgroups to use memory, cpu, and pids controllers.\n    // This is idempotent; harmless if already enabled.\n    if (enable_controllers_v2(CGROOT_V2) != 0) {\n        fprintf(stderr, \"cgroup: failed to enable controllers in root\\n\");\n        // Continue ‚Äî may already be enabled by systemd\n    }\n    // ‚îÄ‚îÄ Step 2: Create the cgroup directory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (mkdir(cg_path, 0755) != 0 && errno != EEXIST) {\n        perror(\"cgroup: mkdir\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 3: Write container PID to cgroup.procs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // This is the most critical step: it moves the container process into\n    // this cgroup. All resource limits now apply to it.\n    // Must happen BEFORE exec() runs in the container.\n    if (cg_write_long(cg_path, \"cgroup.procs\", (long)container_pid) != 0) {\n        fprintf(stderr, \"cgroup: failed to assign PID %d to cgroup\\n\",\n                container_pid);\n        return -1;\n    }\n    printf(\"[cgroup] Assigned PID %d to cgroup: %s\\n\", container_pid, cg_path);\n    // ‚îÄ‚îÄ Step 4: Memory limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (cfg->memory_limit_bytes > 0) {\n        if (cg_write_long(cg_path, \"memory.max\",\n                          cfg->memory_limit_bytes) != 0) {\n            return -1;\n        }\n        printf(\"[cgroup] Memory limit: %ld bytes (%.1f MB)\\n\",\n               cfg->memory_limit_bytes,\n               cfg->memory_limit_bytes / (1024.0 * 1024.0));\n        // Also set memory.swap.max to 0 to prevent the container from\n        // evading the memory limit via swap. Without this, the kernel\n        // can swap container pages to disk, allowing it to exceed\n        // memory.max in terms of virtual memory consumption.\n        cg_write_str(cg_path, \"memory.swap.max\", \"0\");\n    } else {\n        cg_write_str(cg_path, \"memory.max\", \"max\");\n    }\n    // ‚îÄ‚îÄ Step 5: CPU limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // v2 format: \"quota_us period_us\"\n    // Example: \"50000 100000\" = 50ms per 100ms = 50% of one CPU core\n    if (cfg->cpu_quota_us > 0) {\n        char cpu_max[64];\n        long period = cfg->cpu_period_us > 0 ? cfg->cpu_period_us : 100000;\n        snprintf(cpu_max, sizeof(cpu_max), \"%ld %ld\",\n                 cfg->cpu_quota_us, period);\n        if (cg_write_str(cg_path, \"cpu.max\", cpu_max) != 0) return -1;\n        printf(\"[cgroup] CPU limit: %ldus quota / %ldus period (%.1f%% of 1 core)\\n\",\n               cfg->cpu_quota_us, period,\n               100.0 * cfg->cpu_quota_us / period);\n    } else {\n        cg_write_str(cg_path, \"cpu.max\", \"max 100000\");\n    }\n    // ‚îÄ‚îÄ Step 6: Process count limit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (cfg->pids_max > 0) {\n        if (cg_write_long(cg_path, \"pids.max\",\n                          (long)cfg->pids_max) != 0) {\n            return -1;\n        }\n        printf(\"[cgroup] PID limit: %d processes\\n\", cfg->pids_max);\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// cgroups v1: configure separate controller hierarchies\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#define CGROOT_V1_MEM   \"/sys/fs/cgroup/memory\"\n#define CGROOT_V1_CPU   \"/sys/fs/cgroup/cpu\"\n#define CGROOT_V1_PIDS  \"/sys/fs/cgroup/pids\"\nstatic int cgroup_setup_v1(const char *cgroup_name,\n                            pid_t container_pid,\n                            const cgroup_config_t *cfg) {\n    char mem_path[512], cpu_path[512], pids_path[512];\n    snprintf(mem_path,  sizeof(mem_path),  \"%s/%s\", CGROOT_V1_MEM,  cgroup_name);\n    snprintf(cpu_path,  sizeof(cpu_path),  \"%s/%s\", CGROOT_V1_CPU,  cgroup_name);\n    snprintf(pids_path, sizeof(pids_path), \"%s/%s\", CGROOT_V1_PIDS, cgroup_name);\n    // Create cgroup directories in each controller hierarchy\n    mkdir(mem_path,  0755);\n    mkdir(cpu_path,  0755);\n    mkdir(pids_path, 0755);\n    // Assign PID to each controller (must do all three)\n    cg_write_long(mem_path,  \"cgroup.procs\", (long)container_pid);\n    cg_write_long(cpu_path,  \"cgroup.procs\", (long)container_pid);\n    cg_write_long(pids_path, \"cgroup.procs\", (long)container_pid);\n    // Memory limit: v1 uses limit_in_bytes\n    if (cfg->memory_limit_bytes > 0) {\n        cg_write_long(mem_path, \"memory.limit_in_bytes\", cfg->memory_limit_bytes);\n        // Disable swap separately in v1\n        cg_write_long(mem_path, \"memory.memsw.limit_in_bytes\",\n                      cfg->memory_limit_bytes);\n    }\n    // CPU quota: v1 uses separate quota and period files\n    if (cfg->cpu_quota_us > 0) {\n        long period = cfg->cpu_period_us > 0 ? cfg->cpu_period_us : 100000;\n        cg_write_long(cpu_path, \"cpu.cfs_period_us\", period);\n        cg_write_long(cpu_path, \"cpu.cfs_quota_us\", cfg->cpu_quota_us);\n    }\n    // PID limit: same file name in v1 and v2\n    if (cfg->pids_max > 0) {\n        cg_write_long(pids_path, \"pids.max\", (long)cfg->pids_max);\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Public API: detect version and dispatch\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nint cgroup_setup(const char *cgroup_name,\n                 pid_t container_pid,\n                 const cgroup_config_t *cfg) {\n    int version = detect_cgroup_version();\n    printf(\"[cgroup] Detected cgroups v%d\\n\", version);\n    if (version == 2) {\n        return cgroup_setup_v2(cgroup_name, container_pid, cfg);\n    } else if (version == 1) {\n        return cgroup_setup_v1(cgroup_name, container_pid, cfg);\n    } else {\n        fprintf(stderr, \"cgroup: cannot detect cgroup version\\n\");\n        return -1;\n    }\n}\n```\n---\n## Cleanup: You Cannot `rmdir` a Live Cgroup\nCgroup lifecycle has a rule that bites every first implementation:\n**You cannot remove a cgroup directory with `rmdir()` while any process is assigned to it.**\nThe kernel returns `EBUSY` if the cgroup has any live processes. The cleanup sequence must be:\n1. Wait for all container processes to exit (your existing `waitpid()` loop handles this)\n2. Then `rmdir()` the cgroup directory\nBut there's a subtlety: zombie processes still count as \"live\" in the kernel's cgroup accounting until they're reaped with `waitpid()`. Your PID 1 reaper from Milestone 1 ensures orphans are reaped, but you must call `waitpid()` on the container init process itself before attempting cleanup.\n```c\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Cleanup: remove cgroup directory after all processes have exited\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nvoid cgroup_cleanup(const char *cgroup_name) {\n    int version = detect_cgroup_version();\n    char path[512];\n    if (version == 2) {\n        snprintf(path, sizeof(path), \"%s/%s\", CGROOT_V2, cgroup_name);\n        if (rmdir(path) != 0) {\n            fprintf(stderr, \"[cgroup] cleanup: rmdir(%s): %s\\n\",\n                    path, strerror(errno));\n            if (errno == EBUSY) {\n                fprintf(stderr, \"[cgroup] cleanup: processes still in cgroup \"\n                                \"(zombie not reaped?)\\n\");\n            }\n        } else {\n            printf(\"[cgroup] Cleaned up: %s\\n\", path);\n        }\n    } else if (version == 1) {\n        // Must rmdir each controller hierarchy separately\n        const char *roots[] = {\n            CGROOT_V1_MEM, CGROOT_V1_CPU, CGROOT_V1_PIDS, NULL\n        };\n        for (int i = 0; roots[i]; i++) {\n            snprintf(path, sizeof(path), \"%s/%s\", roots[i], cgroup_name);\n            rmdir(path);  // Best-effort; log but don't abort\n        }\n    }\n}\n```\n---\n## Resource Observability: Reading the Cgroup Meters\nThe cgroup filesystem exposes live resource usage as readable files. These are the exact files that cAdvisor and the kubelet read to feed Prometheus metrics ‚Äî and you can read them directly with `cat` or `open()`/`read()` in C.\n```c\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Report current resource usage for a v2 cgroup\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nvoid cgroup_report_v2(const char *cgroup_name) {\n    char cg_path[512];\n    snprintf(cg_path, sizeof(cg_path), \"%s/%s\", CGROOT_V2, cgroup_name);\n    char buf[4096];\n    // ‚îÄ‚îÄ Memory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (cg_read_str(cg_path, \"memory.current\", buf, sizeof(buf)) == 0) {\n        long mem_bytes = atol(buf);\n        printf(\"[cgroup] memory.current: %ld bytes (%.1f MB)\\n\",\n               mem_bytes, mem_bytes / (1024.0 * 1024.0));\n    }\n    if (cg_read_str(cg_path, \"memory.max\", buf, sizeof(buf)) == 0) {\n        printf(\"[cgroup] memory.max: %s\\n\", buf);\n    }\n    // ‚îÄ‚îÄ CPU ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // cpu.stat contains multiple fields: usage_usec, user_usec, system_usec,\n    // throttled_usec (how long processes were paused due to CFS throttling),\n    // throttled_periods (how many 100ms periods had throttling)\n    if (cg_read_str(cg_path, \"cpu.stat\", buf, sizeof(buf)) == 0) {\n        printf(\"[cgroup] cpu.stat:\\n\");\n        // Parse and display each line\n        char *line = strtok(buf, \"\\n\");\n        while (line) {\n            printf(\"         %s\\n\", line);\n            line = strtok(NULL, \"\\n\");\n        }\n    }\n    // ‚îÄ‚îÄ PIDs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (cg_read_str(cg_path, \"pids.current\", buf, sizeof(buf)) == 0) {\n        printf(\"[cgroup] pids.current: %s\\n\", buf);\n    }\n    if (cg_read_str(cg_path, \"pids.max\", buf, sizeof(buf)) == 0) {\n        printf(\"[cgroup] pids.max: %s\\n\", buf);\n    }\n}\n```\nThe most revealing field in `cpu.stat` is `throttled_usec`. If this number is non-zero and growing, your container is being CPU-throttled ‚Äî processes are spending time waiting for the next CFS period to begin rather than actually executing. A container with `throttled_usec` growing at 1 second per 10 seconds of wall time is experiencing ~10% CPU throttling, which will appear as 10% longer response times for every request that runs through that CPU period boundary.\n---\n## Integrating Cgroups Into the Container Runtime\nHere is the complete integration point with the container runtime from Milestones 1-3. The key change: cgroup setup happens on the **host side**, after `clone()` returns the container PID but before the sync pipe signals the container to proceed.\n```c\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Updated main() ‚Äî integrates cgroup resource limits\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nint main(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr,\n            \"Usage: %s <rootfs> <outbound-iface> <command> [args...]\\n\",\n            argv[0]);\n        return 1;\n    }\n    const char *rootfs       = argv[1];\n    const char *outbound_if  = argv[2];\n    char      **container_cmd = &argv[3];\n    // ‚îÄ‚îÄ Cgroup configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // 100MB memory, 50% of one CPU core, max 32 processes\n    cgroup_config_t cg_cfg = {\n        .memory_limit_bytes = 100 * 1024 * 1024,  // 100 MB\n        .cpu_quota_us       = 50000,               // 50ms\n        .cpu_period_us      = 100000,              // per 100ms period\n        .pids_max           = 32,\n    };\n    const char *cgroup_name = \"mycontainer\";\n    // ‚îÄ‚îÄ DNS, sync pipe, stack allocation (from Milestone 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    write_resolv_conf(rootfs);\n    int sync_pipe[2];\n    if (pipe(sync_pipe) != 0) { perror(\"pipe\"); return 1; }\n    char *stack = mmap(NULL, STACK_SIZE,\n                       PROT_READ | PROT_WRITE,\n                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n                       -1, 0);\n    if (stack == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    mprotect(stack, 4096, PROT_NONE);\n    char *stack_top = stack + STACK_SIZE;\n    container_config_t cfg = {\n        .rootfs         = (char *)rootfs,\n        .argv           = container_cmd,\n        .outbound_iface = (char *)outbound_if,\n        .sync_pipe_read = sync_pipe[0],\n    };\n    // ‚îÄ‚îÄ clone() with all namespace flags ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    pid_t container_pid = clone(container_init, stack_top,\n                                CLONE_NEWPID  |\n                                CLONE_NEWUTS  |\n                                CLONE_NEWNS   |\n                                CLONE_NEWNET  |\n                                SIGCHLD,\n                                &cfg);\n    if (container_pid == -1) {\n        perror(\"clone\");\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    printf(\"[host] Container host PID: %d\\n\", container_pid);\n    close(sync_pipe[0]);\n    // ‚îÄ‚îÄ Cgroup setup ‚Äî BEFORE signaling container to proceed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // The container is blocked on read(sync_pipe_read).\n    // This is our window to apply resource limits before exec() runs.\n    if (cgroup_setup(cgroup_name, container_pid, &cg_cfg) != 0) {\n        fprintf(stderr, \"[host] Cgroup setup failed ‚Äî terminating\\n\");\n        kill(container_pid, SIGKILL);\n        waitpid(container_pid, NULL, 0);\n        close(sync_pipe[1]);\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    // ‚îÄ‚îÄ Network setup (from Milestone 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (setup_host_network(container_pid, outbound_if) != 0) {\n        fprintf(stderr, \"[host] Network setup failed\\n\");\n        kill(container_pid, SIGKILL);\n        waitpid(container_pid, NULL, 0);\n        close(sync_pipe[1]);\n        cgroup_cleanup(cgroup_name);\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    // ‚îÄ‚îÄ Signal container: all setup complete, proceed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    write(sync_pipe[1], \"1\", 1);\n    close(sync_pipe[1]);\n    printf(\"[host] Container ready. Resources limited.\\n\");\n    // ‚îÄ‚îÄ Monitor loop: print resource usage every 5 seconds ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // In a real runtime, this would be a separate thread.\n    // Here we fork a simple monitor process.\n    pid_t monitor_pid = fork();\n    if (monitor_pid == 0) {\n        // Monitor child: poll cgroup stats until container exits\n        while (1) {\n            sleep(5);\n            cgroup_report_v2(cgroup_name);\n        }\n        exit(0);\n    }\n    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    int status;\n    waitpid(container_pid, &status, 0);\n    printf(\"[host] Container exited\\n\");\n    // Terminate monitor\n    if (monitor_pid > 0) kill(monitor_pid, SIGKILL);\n    // ‚îÄ‚îÄ Cleanup: network, then cgroup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // ORDER MATTERS: clean network first (no process dependency),\n    // then cgroup (requires all processes to have exited ‚Äî waitpid above\n    // ensures the init process has exited, and since it's PID 1, all\n    // namespace processes were killed when it exited).\n    cleanup_network(outbound_if);\n    cgroup_cleanup(cgroup_name);\n    munmap(stack, STACK_SIZE);\n    return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n}\n```\n---\n## Verifying Memory Limits: Triggering the OOM Killer\nThe best way to understand the OOM killer is to trigger it. Here is a small C program that allocates memory in a tight loop and touches every page (forcing it to be resident ‚Äî allocated but not touched doesn't consume physical memory in Linux's overcommitted allocator):\n```c\n// oom_test.c ‚Äî allocate memory until killed\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\nint main(void) {\n    size_t total = 0;\n    size_t chunk = 10 * 1024 * 1024;  // 10 MB per step\n    printf(\"PID %d starting memory allocation...\\n\", getpid());\n    while (1) {\n        char *p = malloc(chunk);\n        if (!p) {\n            fprintf(stderr, \"malloc failed at %.1f MB total\\n\",\n                    total / (1024.0 * 1024.0));\n            sleep(60);  // Stay alive so we can observe zombie state\n            return 1;\n        }\n        // CRITICAL: memset forces the kernel to actually allocate physical pages.\n        // Without this, malloc succeeds via overcommit but RSS stays low.\n        memset(p, 0xAA, chunk);\n        total += chunk;\n        printf(\"Allocated %.1f MB total\\n\", total / (1024.0 * 1024.0));\n        sleep(1);\n    }\n}\n```\nCompile this and put it in your container rootfs:\n```bash\ngcc -o alpine-rootfs/bin/oom_test oom_test.c\n```\nRun the container with a 100MB memory limit and execute `oom_test` inside it:\n```bash\nsudo ./container_m4 ./alpine-rootfs eth0 /bin/oom_test\n```\nExpected output:\n```\n[cgroup] Detected cgroups v2\n[cgroup] Assigned PID 12345 to cgroup: /sys/fs/cgroup/mycontainer\n[cgroup] Memory limit: 104857600 bytes (100.0 MB)\n...\nInside container, /bin/oom_test:\nAllocated 10.0 MB total\nAllocated 20.0 MB total\n...\nAllocated 90.0 MB total\nAllocated 100.0 MB total\nKilled                    ‚Üê OOM killer sent SIGKILL\n[host] Container exited\n```\nNotice: the process doesn't gracefully fail. It doesn't receive a catchable signal. `SIGKILL` cannot be handled or ignored ‚Äî the process simply stops. From the process's perspective, nothing happened. It was allocating memory, and then it ceased to exist.\nYou can observe the OOM event from the host:\n```bash\ndmesg | tail -20 | grep -i oom\n# [12345.678] oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),\n#             cpuset=mycontainer,mems_allowed=0,oom_memcg=/mycontainer,\n#             task_memcg=/mycontainer,task=oom_test,pid=12346,uid=0\n# [12345.678] Memory cgroup out of memory: Killed process 12346 (oom_test)\n#             total-vm:105472kB, anon-rss:103424kB, file-rss:1024kB\n```\nThe kernel's `oom-kill` message tells you exactly which cgroup triggered the OOM kill, which process was selected, and how much memory it was using.\n\n> **üîë Foundation: Linux OOM killer process selection algorithm and oom_score_adj**\n> \n> **1. What it IS**\nThe Out-Of-Memory (OOM) Killer is the kernel's \"emergency janitor.\" When the system's RAM is completely exhausted, the OOM Killer selects a process to terminate to save the system from crashing. It uses a scoring algorithm (`oom_score`) ranging from 0 to 1000. This score is primarily based on the percentage of allowed memory the process is using, which is then adjusted by the `oom_score_adj` (a value from -1000 to +1000) provided by the user or orchestrator.\n\n**2. WHY the reader needs it right now**\nIn Kubernetes, \"OOMKilled\" is a common pod status. To prevent your critical database from being killed instead of a background worker, you must understand how Kubernetes manipulates the `oom_score_adj`. If you don't set your resource requests and limits correctly, the kernel might see your most important application as the \"best\" candidate for termination during a memory crunch.\n\n**3. ONE key insight or mental model**\n**\"The Bad Neighbor Calculation.\"** Think of the OOM Killer as looking for the process that is \"taking more than its fair share.\" A process using 90% of its limit with a high adjustment score will always be killed before a process using 10% of its limit with a low adjustment score.\n\n---\n## Verifying CPU Throttling: The CFS Quota Mechanism\nCPU throttling is more subtle than OOM kills because the process doesn't die ‚Äî it just becomes sluggish in a way that's difficult to distinguish from a slow algorithm.\nA stress test to demonstrate throttling:\n```c\n// cpu_stress.c ‚Äî burn CPU and report throughput\n#include <stdio.h>\n#include <time.h>\n#include <stdint.h>\nint main(void) {\n    printf(\"PID %d burning CPU...\\n\", getpid());\n    while (1) {\n        struct timespec start, end;\n        clock_gettime(CLOCK_MONOTONIC, &start);\n        // Do 100 million iterations of arithmetic\n        volatile uint64_t sum = 0;\n        for (uint64_t i = 0; i < 100000000ULL; i++) {\n            sum += i;\n        }\n        clock_gettime(CLOCK_MONOTONIC, &end);\n        double elapsed = (end.tv_sec - start.tv_sec) +\n                         (end.tv_nsec - start.tv_nsec) / 1e9;\n        printf(\"100M iterations in %.3fs (%.1fM iter/sec), sum=%lu\\n\",\n               elapsed, 100.0 / elapsed, (unsigned long)sum);\n    }\n}\n```\nRun this in your container with a 50% CPU limit (`cpu_quota_us=50000, cpu_period_us=100000`). Compare:\n```\n# Without CPU limit (full core available):\n100M iterations in 0.089s (1123.6M iter/sec)\n100M iterations in 0.088s (1136.4M iter/sec)\n# With 50% CPU limit (50ms quota per 100ms period):\n100M iterations in 0.178s (561.8M iter/sec)    ‚Üê ~2x slower (as expected)\n100M iterations in 0.210s (476.2M iter/sec)    ‚Üê sometimes slower due to period boundary\n100M iterations in 0.165s (606.1M iter/sec)    ‚Üê variability from throttling boundary timing\n```\nThe variability is the tell: without throttling, throughput is consistent. With throttling, iterations that straddle a period boundary take longer ‚Äî the process was mid-computation when its quota ran out and it was forced to sleep until the next period.\nNow read the throttling statistics:\n```bash\n# From the HOST, while the container is running:\ncat /sys/fs/cgroup/mycontainer/cpu.stat\n# usage_usec 1234567        ‚Üê total CPU time consumed (microseconds)\n# user_usec 1100000         ‚Üê time in user space\n# system_usec 134567        ‚Üê time in kernel space\n# nr_periods 1532           ‚Üê number of 100ms periods elapsed\n# nr_throttled 847          ‚Üê periods where the cgroup was throttled\n# throttled_usec 42350000   ‚Üê total microseconds spent throttled\n```\n`nr_throttled / nr_periods` gives you the throttle ratio. In this case: `847 / 1532 ‚âà 55%` ‚Äî more than half of all periods hit the quota limit. `throttled_usec / nr_periods` gives the average throttle time per period: `42350000 / 1532 ‚âà 27.6ms` ‚Äî meaning the process waited an average of 27.6ms per period even though the host CPU was otherwise idle.\n\n![CFS CPU Throttling ‚Äî Quota/Period Timeline](./diagrams/diag-cpu-throttling-timeline.svg)\n\nThis is the Kubernetes throttling problem in miniature. A Kubernetes pod with `resources.limits.cpu: \"0.5\"` (half a core) gets `cpu.max = \"50000 100000\"`. If the pod runs a bursty workload ‚Äî periodic HTTP requests each doing 80ms of CPU work ‚Äî those requests will be throttled at the period boundary even when the node has 15 spare CPU cores. The fix is to either raise the limit, switch to `cpu.weight` (requests-only, no hard limit), or increase the period. We'll explore these in the Knowledge Cascade.\n---\n## Verifying Fork Bomb Containment\nThe fork bomb test is the most viscerally satisfying verification because you can feel the difference between a contained and uncontained explosion:\n```bash\n# Inside the container with pids.max=32:\n:(){ :|:& };:\n# bash: fork: Resource temporarily unavailable\n# bash: fork: Resource temporarily unavailable\n# ... (a dozen times, then stops)\n# The shell survives. The host is unaffected.\n```\nWithout `pids.max`, this command would exhaust the kernel's global PID limit (default 4,194,304 on modern kernels, often 32,768 on older ones), making it impossible for any new process to start anywhere on the host until the zombie processes are cleared.\nWith `pids.max=32`, the kernel counts processes assigned to the cgroup. When any `fork()` or `clone()` in the cgroup would cause the count to exceed 32, the syscall returns `EAGAIN` (\"try again\" ‚Äî but there's no point trying). The fork bomb starts, saturates the limit at 32, and stalls. The container's shell process survives because it was already running.\n\n![pids.max Fork Bomb Containment](./diagrams/diag-pids-max-fork-bomb.svg)\n\nRead the current process count from the host:\n```bash\ncat /sys/fs/cgroup/mycontainer/pids.current\n# 28     ‚Üê 28 processes (the fork bomb hit the ceiling)\ncat /sys/fs/cgroup/mycontainer/pids.max\n# 32\n```\nAfter the fork bomb processes die (they exit quickly since they have nothing to do), `pids.current` drops back to the baseline container process count.\n---\n## Hardware Soul: What the Kernel Is Actually Doing\n### Memory Accounting: The Page Fault Path\nEvery time your container process accesses a new virtual memory page for the first time (which triggers a **page fault**), the kernel's memory allocator attributes that page to the cgroup. Here's the path:\n1. Process accesses unmapped address ‚Üí CPU raises `#PF` exception\n2. Kernel's `do_page_fault()` ‚Üí `handle_pte_fault()` ‚Üí `do_anonymous_page()`\n3. `do_anonymous_page()` calls `mem_cgroup_charge()` before allocating the physical page\n4. `mem_cgroup_charge()` checks the cgroup's current usage against `memory.max`\n5. If limit exceeded: `try_charge_memcg()` ‚Üí triggers memory reclaim ‚Üí may invoke OOM killer\n6. If limit not exceeded: page is charged to the cgroup, physical frame allocated\n7. Page table updated, execution resumes\n**Cache behavior**: The cgroup memory accounting structures live in kernel memory. The hot path for a page fault that doesn't hit the limit is approximately:\n- 2-3 pointer dereferences into the `mem_cgroup` struct\n- Atomic increment of the memory counter (cache line bounce if multi-threaded ‚Äî every concurrent allocation from the same cgroup contends on this counter)\n- The counter is 8 bytes, fits in one cache line, but that cache line is exclusively owned by the accounting logic\n**Latency impact**: Normal page fault handling takes approximately 1-3 Œºs. Memory accounting (the cgroup charge check) adds roughly 50-200 ns on an uncontested cache line. Under heavy multi-threaded allocation from the same cgroup, the counter contention adds more. This is why memory-intensive workloads sometimes show slightly higher allocation latency when running inside cgroup-limited containers compared to unconstrained processes.\n### CFS Scheduler: The Bandwidth Controller\n[[EXPLAIN:completely-fair-scheduler-(cfs)-and-bandwidth-controller|Linux CFS scheduler bandwidth controller ‚Äî quota, period, and throttle mechanism]]\nThe CPU limit is enforced by the **CFS bandwidth controller** ‚Äî a component of the Completely Fair Scheduler. The kernel maintains a per-cgroup runtime budget:\n```\nruntime_remaining = cpu.max quota (e.g., 50000 Œºs)\n```\nEach time a thread in the cgroup runs, the elapsed CPU time is subtracted from `runtime_remaining`. When `runtime_remaining` reaches zero, every runnable thread in the cgroup is removed from the scheduler's run queues and placed in a \"throttle\" list. A high-resolution timer (`hrtimer`) fires at the next period boundary, refills `runtime_remaining` to the quota value, and unthrottles all threads ‚Äî they go back on the run queues.\n**The bandwidth accounting is per-CPU but with a global pool**. Each CPU core maintains a local sub-quota (called a \"slice\") to reduce contention. When a CPU's slice is exhausted, it borrows more from the global pool. When the global pool is exhausted, all CPUs in the cgroup are throttled together. This design reduces the contention on the global counter (which would otherwise be a scalability bottleneck on NUMA systems with many cores).\n**Memory access pattern**: The throttle list is a linked list of task structs. Unthrottling involves walking this list and re-inserting each task into its CPU's run queue. For a cgroup with 32 processes all throttled simultaneously, this is 32 list operations at period boundary ‚Äî sequential pointer traversal, likely in L2/L3 cache since these structs were recently accessed.\n**Latency floor**: Even if a cgroup has quota remaining, the minimum scheduler granularity is `sysctl_sched_min_granularity_ns` (typically 750 Œºs - 6 ms depending on system load). A cgroup process cannot get less than one granularity slice of CPU time per scheduling decision. This means very low CPU limits (e.g., `cpu.max = \"1000 100000\"` for 1% of a core) cause very frequent context switches and high scheduling overhead relative to useful work.\n### pids.max: Atomic Fork Count\nThe PID limit check is the simplest of the three controllers. In `kernel/fork.c`'s `copy_process()` function (which is called by both `fork()` and `clone()`):\n```c\n// Simplified kernel code path (conceptual ‚Äî not actual kernel source)\nif (task_pids_current(cgroup) >= pids_max_for_cgroup(cgroup)) {\n    return ERR_PTR(-EAGAIN);\n}\natomic_inc(&cgroup->pids.events_count);\n// ... proceed with process creation\n```\nThe check is a single atomic comparison. On an unconstrained cgroup (`pids.max = \"max\"`), this comparison is skipped entirely ‚Äî no overhead. On a constrained cgroup, it's one atomic load plus one comparison ‚Äî on the order of 5-20 ns depending on cache state. Negligible.\nThe `EAGAIN` return code propagates back to `fork()` in userspace, which sets `errno = EAGAIN`. This is why you see `fork: Resource temporarily unavailable` in the fork bomb output ‚Äî `EAGAIN` is \"resource temporarily unavailable\" in the POSIX error space.\n---\n## Pitfall Compendium: The Mistakes That Will Ruin Your Weekend\n### Pitfall 1: Writing to cgroup.procs After exec()\n```\n‚ùå WRONG timeline:\n   clone() ‚Üí exec() runs inside container ‚Üí (container now running your binary)\n            ‚Üí write PID to cgroup.procs ‚Üê WRONG: the exec'd binary is running unconstrained\n‚úÖ CORRECT timeline:\n   clone() ‚Üí write PID to cgroup.procs ‚Üí signal container via pipe\n            ‚Üí container reads pipe, proceeds ‚Üí exec() runs inside cgroup\n```\nThe window between `clone()` and `exec()` is your only opportunity to apply cgroup limits before any user code runs. The sync pipe from Milestone 3 creates this window precisely for this purpose. If you write to `cgroup.procs` after `exec()`, the user process has been running without resource limits ‚Äî it may have already allocated memory above your limit, and the OOM kill might be immediate and surprising.\n### Pitfall 2: Not Writing to `memory.swap.max`\n```c\n// ‚ùå INCOMPLETE: memory.max alone doesn't prevent swap usage\ncg_write_long(cg_path, \"memory.max\", 100 * 1024 * 1024);\n// ‚úÖ COMPLETE: also cap swap to 0 for strict memory containment\ncg_write_long(cg_path, \"memory.max\", 100 * 1024 * 1024);\ncg_write_str(cg_path, \"memory.swap.max\", \"0\");\n```\nWithout `memory.swap.max = 0`, a container that hits its memory limit doesn't immediately get OOM killed. The kernel first tries to reclaim memory by swapping pages out to disk. The container's RSS drops below `memory.max`, the OOM killer backs off, and the container continues running ‚Äî but with every memory access now going through disk I/O (swap reads/writes cost 10-100ms each vs. 100ns for RAM). The container appears \"alive\" but is actually in a death spiral of swapping, becoming 100-10,000x slower. Setting `memory.swap.max = 0` ensures the OOM killer fires immediately when RSS exceeds the limit, which is usually the right behavior for containers.\n### Pitfall 3: Forgetting `cgroup.subtree_control` on v2\nThe symptom: `write(memory.max)` returns `EINVAL`. The cause: the `memory` controller is not enabled in the parent cgroup's `subtree_control`. This is the most common first-time cgroups v2 error because v1 had no equivalent concept.\n```bash\n# Diagnosis:\ncat /sys/fs/cgroup/cgroup.subtree_control\n# cpu io memory pids    ‚Üê if memory is here, it's enabled\n# If memory is missing:\necho \"+memory\" > /sys/fs/cgroup/cgroup.subtree_control\n```\nOn systemd systems, the common controllers are pre-enabled. On minimal systems (Alpine running from RAM, embedded Linux), you may need to enable them yourself.\n### Pitfall 4: Cleanup Order ‚Äî rmdir Before Processes Exit\n```c\n// ‚ùå WRONG: cgroup still has processes; rmdir returns EBUSY\nkill(container_pid, SIGKILL);  // Signal sent but not necessarily delivered yet\ncgroup_cleanup(cgroup_name);   // EBUSY ‚Äî container_pid may still be alive\n// ‚úÖ CORRECT: wait for process to actually exit\nkill(container_pid, SIGKILL);\nwaitpid(container_pid, &status, 0);  // Blocks until process is dead AND reaped\ncgroup_cleanup(cgroup_name);   // Safe ‚Äî all processes gone\n```\n`SIGKILL` delivery is asynchronous. Sending the signal doesn't mean the process has exited ‚Äî it means the signal has been queued. The process must be scheduled, receive the signal, and have its exit handled by the kernel before `rmdir` can succeed. `waitpid()` blocks until all of this has happened and the process's resources are fully released.\n### Pitfall 5: CPU Period Too Large or Too Small\n```c\n// ‚ùå TOO SMALL period: high scheduling overhead, poor throughput\n.cpu_quota_us  = 5000,    // 5ms quota\n.cpu_period_us = 10000,   // per 10ms period\n// 50% of a core, but the scheduler must context-switch every 10ms minimum\n// ‚ùå TOO LARGE period: poor responsiveness and bursty behavior\n.cpu_quota_us  = 5000000,  // 5 seconds of CPU\n.cpu_period_us = 10000000, // per 10-second period\n// Container can use 5 full seconds of CPU, then is throttled for 5 seconds\n// Latency spikes of up to 5 seconds!\n// ‚úÖ STANDARD period: good balance of overhead and responsiveness\n.cpu_quota_us  = 50000,   // 50ms quota\n.cpu_period_us = 100000,  // per 100ms period (Kubernetes default)\n```\nThe 100ms period (`100000 Œºs`) is the Kubernetes default and a good general-purpose choice. It's small enough that throttling causes at most 100ms latency spikes (acceptable for most services) and large enough that scheduler overhead is negligible. High-frequency trading systems and hard real-time workloads use smaller periods (1-10ms) or bypass CFS entirely with `SCHED_FIFO`.\n### Pitfall 6: The v1 Memory + Swap Accounting Split\nIn cgroups v1, memory and swap accounting are separate controllers, and the combined limit is `memory.memsw.limit_in_bytes` ‚Äî a different file than `memory.limit_in_bytes`. If you only set `memory.limit_in_bytes` in v1, the container can exceed the limit via swap. The v1 code above shows the correct approach: set both.\nIn v2, `memory.max` and `memory.swap.max` are separate but both must be set for strict containment. The semantic is cleaner in v2.\n---\n## Knowledge Cascade: From Container to Cluster\n### 1. Kubernetes Resource Requests vs. Limits: The Invisible Performance Knob\nKubernetes has two resource fields for CPU: `requests` and `limits`. They map to different cgroup mechanisms:\n- **`resources.requests.cpu: \"500m\"`** (500 millicores = 0.5 core) ‚Üí sets `cpu.weight` (cgroups v2) or `cpu.shares` (v1). This is **proportional sharing**: if the node has spare capacity, the container can use more than 500m. `cpu.weight` is a relative priority ‚Äî a container with weight 100 gets twice the CPU of one with weight 50 when both are CPU-hungry. When the node is idle, a container with `requests: 100m` can burst to 100% of a core.\n- **`resources.limits.cpu: \"500m\"`** ‚Üí sets `cpu.max = \"50000 100000\"`. This is a **hard ceiling**: the container will be throttled even if the node has 15 idle cores. The container cannot burst above this limit, ever.\nThe implication: setting CPU limits in Kubernetes trades burst capacity for predictability. A container with only `requests` (no `limits`) can burst when the node has spare capacity, which is usually what you want. A container with tight `limits` will be throttled ‚Äî causing the latency spikes you saw in the verification section ‚Äî even when the node is completely idle.\n\n> **üîë Foundation: Kubernetes Quality of Service**\n> \n> **1. What it IS**\nKubernetes assigns every Pod a Quality of Service (QoS) class‚Äî**Guaranteed**, **Burstable**, or **BestEffort**‚Äîbased on its `requests` and `limits`. Kubernetes then maps these classes to specific cgroup configurations. For example, a \"Guaranteed\" pod gets an `oom_score_adj` of -997 (making it nearly impossible to kill), while a \"BestEffort\" pod gets a +1000 (making it the first to die). It also maps CPU requests to cgroup \"weights\" to ensure fair sharing during CPU contention.\n\n**2. WHY the reader needs it right now**\nYou cannot manually set cgroup values in Kubernetes; you can only influence them via the QoS class. Understanding this mapping is the only way to predict how your application will behave under pressure. If you have a \"Burstable\" pod with a large gap between request and limit, it is at high risk of being killed if the node runs out of memory, even if it hasn't hit its own limit yet.\n\n**3. ONE key insight or mental model**\n**\"Priority as a Safety Net.\"** QoS classes are the translation layer between your YAML intent and the Linux kernel's enforcement. Your Pod's YAML manifest is essentially a request for a specific \"survival priority\" in the eyes of the Linux kernel.\n\nThe Kubernetes community has an ongoing debate: [should you set CPU limits at all?](https://home.robusta.dev/blog/stop-using-cpu-limits) The answer is nuanced: limits prevent one runaway container from starving others on the same node, but limits set too low cause `throttled_usec` to grow and latency to spike. The right answer is: set `requests` accurately (the scheduler uses this for placement), set `limits` conservatively above the p99 CPU usage (not the average), and monitor `throttled_usec` in production.\n### 2. OOM Killer Scoring and Kubernetes QoS\nWhen the OOM killer selects a process to kill inside a cgroup (or system-wide when the host is under memory pressure), it uses an **`oom_score`** ‚Äî a number from 0 to 1000 that represents how \"killable\" the process is. Higher score = killed first.\n`oom_score` is calculated from:\n- Process memory usage (higher usage ‚Üí higher score)\n- `oom_score_adj` ‚Äî a tunable from -1000 to 1000 written to `/proc/<pid>/oom_score_adj`\nKubernetes sets `oom_score_adj` based on the pod's QoS class:\n| Kubernetes QoS Class | Condition | `oom_score_adj` | Behavior under pressure |\n|---------------------|-----------|-----------------|------------------------|\n| **Guaranteed** | requests == limits for all resources | -997 | Last to be killed |\n| **Burstable** | requests set, limits set but != requests | proportional to memory % | Killed in middle |\n| **BestEffort** | no requests or limits | 1000 | First to be killed |\nA BestEffort pod has `oom_score_adj = 1000`, meaning the OOM killer selects it first when the node runs out of memory. This is intentional: BestEffort pods have made no resource claims and get no guarantees. Guaranteed pods have `oom_score_adj = -997`, meaning the OOM killer almost never selects them (only if truly nothing else is available to kill).\nYou can read and set `oom_score_adj` directly in C:\n```c\n// Set the container's OOM priority (called from container_init() before exec)\nstatic int set_oom_score_adj(int adj) {\n    // adj: -1000 (never kill) to 1000 (kill first)\n    FILE *f = fopen(\"/proc/self/oom_score_adj\", \"w\");\n    if (!f) {\n        perror(\"fopen oom_score_adj\");\n        return -1;\n    }\n    fprintf(f, \"%d\\n\", adj);\n    fclose(f);\n    return 0;\n}\n// In container_init(), before exec:\nset_oom_score_adj(0);   // Neutral ‚Äî system default behavior\n// Or: set_oom_score_adj(500) for a lower-priority container (killed sooner)\n// Or: set_oom_score_adj(-500) for a higher-priority container (killed later)\n```\n### 3. Memory Accounting Subtleties: The Page Cache Trap\nHere's a surprise that bites production deployments: **reading files counts against the cgroup's memory limit**, even though the process has no explicit allocation for that data.\nWhen a process calls `read(fd, buf, n)` or `mmap()`s a file, the kernel satisfies the read from the **page cache** ‚Äî a kernel-managed cache of disk file contents. These cached pages are attributed to the cgroup of the process that read them. If your 100MB-limited container reads 150MB of log files (perhaps via `grep`), those 150MB of cache pages push the cgroup's `memory.current` over 100MB, and the OOM killer fires.\nThe container's actual application heap (the data it explicitly `malloc()`'d) might only be 5MB. But the page cache attribution causes the OOM kill.\nThe kernel's memory reclaim algorithm does handle this: when a cgroup approaches its limit, the kernel first tries to reclaim **page cache pages** (since they can be re-read from disk). Only if reclaim fails to bring usage below the limit does the OOM killer run. But reclaim takes time, and during reclaim, every memory access that would normally be a cache hit becomes a disk read ‚Äî causing a temporary performance cliff before the OOM kill.\nMonitoring `memory.stat` (a more detailed version of the summary you get from `memory.current`) reveals the breakdown:\n```bash\ncat /sys/fs/cgroup/mycontainer/memory.stat\n# anon 52428800      ‚Üê anonymous memory (heap, stack) = 50MB\n# file 58720256      ‚Üê page cache = 56MB\n# total = ~108MB ‚Üí over a 100MB limit despite the heap being only 50MB\n```\nProduction containers serving files or reading large datasets should set their `memory.max` to account for realistic page cache usage, not just heap usage. Alternatively, use `POSIX_FADV_DONTNEED` hints (`posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED)`) to tell the kernel to release cached pages after reading.\n### 4. cgroup Delegation for Rootless Containers\nMilestone 5 will implement user namespaces for rootless containers. But rootless containers have a resource limiting problem: writing to cgroup files requires write permission on those files, which normally requires root.\nThe solution is **cgroup delegation**: a privileged process (typically systemd) creates a subtree of the cgroup hierarchy and grants ownership of it to an unprivileged user. The user can then create child cgroups within that subtree and apply resource limits ‚Äî without root.\n```bash\n# Systemd can delegate a cgroup slice to a user:\nloginctl enable-linger $USER  # Allow user's systemd slice to persist\n# systemd automatically creates:\n# /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/\n# owned by UID 1000 ‚Äî writable without root\n```\nRootless Podman and rootless Docker use this delegation mechanism. When you run `podman run --memory=100m` as a non-root user, Podman creates a cgroup under the delegated subtree and applies the limit ‚Äî no root required. The kernel enforces the resource limit just the same.\nThis delegation is why the Milestone 5 implementation note about \"cgroup delegation for rootless\" exists: to run cgroup operations without root, you need systemd (or another privileged process) to have pre-delegated a cgroup subtree to your user. Your user namespace alone doesn't grant cgroup write permission ‚Äî delegation is a separate mechanism.\n### 5. Container Observability: The cgroup Filesystem as Metrics Source\n\n> **üîë Foundation: How cAdvisor reads cgroup files to produce Prometheus metrics for Kubernetes**\n> \n> **1. What it IS**\ncAdvisor (Container Advisor) is an open-source agent integrated into the Kubelet binary. It acts as a bridge between the Linux kernel and monitoring tools. It \"walks\" the cgroup filesystem tree (e.g., `/sys/fs/cgroup/kubepods.slice/...`), reads the raw binary/text counters provided by the kernel, aggregates them, and exports them as Prometheus-formatted metrics via the `/metrics/cadvisor` endpoint on the Kubelet.\n\n**2. WHY the reader needs it right now**\nWhen you use `kubectl top`, Prometheus, or Datadog, you aren't looking at \"live\" data directly from the container; you are looking at a snapshot processed by this pipeline. If metrics are missing or delayed, the bottleneck is usually here. Knowing this pipeline exists helps you trace issues from the \"Metric\" (e.g., `container_cpu_usage_seconds_total`) back to the \"Source\" (the cgroup file `cpu.stat`).\n\n**3. ONE key insight or mental model**\n**\"The Translator.\"** cAdvisor is a specialized file-parser. It doesn't \"ask\" the container how much memory it's using; it reads the kernel's internal accounting books (cgroup files) and translates that \"kernel-speak\" into \"human-observable metrics.\"\n\nEvery metric you see in a Kubernetes dashboard ‚Äî container CPU usage, container memory usage, container process count ‚Äî originates from reading the cgroup filesystem files you just implemented. The pipeline:\n1. **kubelet** (the per-node Kubernetes agent) embeds **cAdvisor** (Container Advisor)\n2. cAdvisor scans `/sys/fs/cgroup/` periodically (default: 15s)\n3. For each container's cgroup directory, it reads:\n   - `memory.current` ‚Üí `container_memory_working_set_bytes` in Prometheus\n   - `cpu.stat` (specifically `usage_usec`) ‚Üí `container_cpu_usage_seconds_total`\n   - `cpu.stat` (specifically `throttled_usec`) ‚Üí `container_cpu_cfs_throttled_seconds_total`\n   - `pids.current` ‚Üí `container_processes`\n4. cAdvisor exposes these as Prometheus metrics on port 8080 (`/metrics/cadvisor`)\n5. Prometheus scrapes these metrics and stores them\n6. Grafana queries Prometheus and renders dashboards\nWhen you're debugging a Kubernetes performance issue and you query `container_cpu_cfs_throttled_seconds_total`, you're reading a derived value from the same `throttled_usec` field in `cpu.stat` that you just learned to read with `cat`. The metric has a Prometheus name, a nice Grafana panel, and elaborate alert rules ‚Äî but at the bottom of the stack, it's a 64-bit integer in a file at `/sys/fs/cgroup/<pod>/<container>/cpu.stat`. \nYou can bypass the entire monitoring stack and read it directly:\n```bash\n# On a Kubernetes node, find the container's cgroup:\nCONTAINER_ID=$(crictl ps | grep myapp | awk '{print $1}')\nCGROUP_PATH=$(find /sys/fs/cgroup -name \"cgroup.procs\" | \\\n    xargs grep -l $(crictl inspect $CONTAINER_ID | jq -r '.info.pid') 2>/dev/null | \\\n    head -1 | xargs dirname)\n# Read CPU throttling directly:\ncat $CGROUP_PATH/cpu.stat | grep throttled_usec\n```\nThis is one of the most powerful debugging techniques for Kubernetes performance: bypass the monitoring abstraction and read the ground truth directly from the kernel.\n\n![Cgroup Lifecycle ‚Äî Create, Assign, Monitor, Cleanup](./diagrams/diag-cgroup-lifecycle.svg)\n\n---\n## The Three-Level View: A Resource-Limited `malloc()`\nWhen your container calls `malloc(10 * 1024 * 1024)` ‚Äî allocating 10MB ‚Äî and then touches every byte with `memset()`, here's what happens at all three levels:\n**Level 1 ‚Äî Application (your container process)**:\n- `malloc(10MB)` ‚Üí `mmap(NULL, 10MB, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)`\n- Returns a virtual address range. The memory is \"allocated\" but not yet backed by physical pages.\n- `memset(ptr, 0, 10MB)` ‚Üí touching each byte triggers page faults.\n**Level 2 ‚Äî OS/Kernel**:\n- Each page fault calls `do_page_fault()` ‚Üí `handle_mm_fault()` ‚Üí `do_anonymous_page()`\n- `mem_cgroup_charge()` is called: atomically increment the cgroup's `memory.current` counter\n- If `memory.current > memory.max`: trigger memory reclaim. If reclaim fails: invoke OOM killer ‚Üí `SIGKILL` to selected process.\n- If within limit: allocate a physical frame, update page tables, return to user.\n**Level 3 ‚Äî Hardware**:\n- The page fault is raised by the CPU's Memory Management Unit (MMU) when it finds no valid Page Table Entry (PTE) for the virtual address.\n- The kernel sets the PTE to point to the newly allocated physical frame.\n- The TLB (Translation Lookaside Buffer ‚Äî the CPU's cache of virtual-to-physical address translations) is updated with the new mapping.\n- On NUMA (Non-Uniform Memory Access) systems with multiple CPU sockets, the kernel tries to allocate the physical frame on the NUMA node closest to the CPU that triggered the fault ‚Äî \"local\" allocation. If the local NUMA node's memory is full, it falls back to \"remote\" allocation from another node, which costs 2-3x more latency (60ns local vs. 120-200ns remote for DRAM access).\nThe cgroup accounting layer (Level 2) adds roughly 50-200ns to each page fault. For an application that triggers millions of page faults per second (large `malloc`/`memset` loops), this overhead is measurable. For normal workloads, it's negligible.\n---\n## Compilation and Testing: Running the Complete Stack\n```bash\n# Compile the full container runtime with cgroup support\ngcc -o container_m4 container_m4.c -Wall -Wextra\n# Ensure Alpine rootfs is available\nls ./alpine-rootfs/bin/ >/dev/null 2>&1 || {\n    mkdir -p alpine-rootfs\n    curl -L https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/\\\nalpine-minirootfs-3.19.0-x86_64.tar.gz | tar -xz -C alpine-rootfs\n}\n# Compile test binaries and install them in the rootfs\ngcc -O2 -o alpine-rootfs/bin/oom_test oom_test.c\ngcc -O2 -o alpine-rootfs/bin/cpu_stress cpu_stress.c\n# Run with 100MB memory limit, 50% CPU, 32 max processes\nsudo ./container_m4 ./alpine-rootfs eth0 /bin/sh\n# Inside the container ‚Äî test OOM:\n/bin/oom_test\n# Inside the container ‚Äî test CPU throttling:\n/bin/cpu_stress &\n# From the HOST (while container is running):\ncat /sys/fs/cgroup/mycontainer/cpu.stat\ncat /sys/fs/cgroup/mycontainer/memory.current\n# Inside the container ‚Äî test fork bomb containment:\n:(){ :|:& };:\n# Should fail with \"Resource temporarily unavailable\" after ~32 processes\n```\n---\n## Verification Checklist\n```bash\n# ‚îÄ‚îÄ 1. Detect cgroup version correctly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nls /sys/fs/cgroup/cgroup.controllers 2>/dev/null && echo \"v2\" || echo \"v1\"\n# ‚îÄ‚îÄ 2. Verify cgroup directory was created ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nls /sys/fs/cgroup/mycontainer/      # Should exist while container runs\n# ‚îÄ‚îÄ 3. Verify container PID is in the cgroup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /sys/fs/cgroup/mycontainer/cgroup.procs\n# Should show the container's host PID (e.g., 12345)\n# ‚îÄ‚îÄ 4. Verify memory limit is set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /sys/fs/cgroup/mycontainer/memory.max\n# Should show: 104857600  (100 * 1024 * 1024)\n# ‚îÄ‚îÄ 5. Verify CPU limit is set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /sys/fs/cgroup/mycontainer/cpu.max\n# Should show: 50000 100000\n# ‚îÄ‚îÄ 6. Verify PID limit is set ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /sys/fs/cgroup/mycontainer/pids.max\n# Should show: 32\n# ‚îÄ‚îÄ 7. OOM kill verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Run oom_test inside container; it should be killed before reaching 110MB\ndmesg | tail -5 | grep -i \"oom\\|memory cgroup\"\n# Should show OOM kill event for the container's cgroup\n# ‚îÄ‚îÄ 8. CPU throttling verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Run cpu_stress inside container for 30 seconds, then:\ncat /sys/fs/cgroup/mycontainer/cpu.stat | grep throttled\n# nr_throttled should be > 0\n# throttled_usec should be > 0\n# ‚îÄ‚îÄ 9. Fork bomb containment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Run fork bomb inside container; verify pids.current never exceeds pids.max\nwatch -n 0.5 'cat /sys/fs/cgroup/mycontainer/pids.current'\n# Should stabilize at ‚â§32, not grow unboundedly\n# ‚îÄ‚îÄ 10. Cgroup cleanup after container exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# After container exits:\nls /sys/fs/cgroup/mycontainer/ 2>&1\n# Should give: ls: cannot access '/sys/fs/cgroup/mycontainer/': No such file or directory\n# ‚îÄ‚îÄ 11. Resource usage reporting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# While container is running:\ncat /sys/fs/cgroup/mycontainer/memory.current  # Live memory usage in bytes\ncat /sys/fs/cgroup/mycontainer/cpu.stat        # Detailed CPU statistics\ncat /sys/fs/cgroup/mycontainer/pids.current    # Current process count\n```\n---\n## Looking Ahead\nYou now have a container that isolates its process tree, filesystem, network stack, and resource consumption. The cgroup layer is the last resource enforcement mechanism ‚Äî the container cannot exceed its CPU allocation, cannot consume unlimited memory, and cannot spawn unlimited processes.\nBut if you run `id` inside the container:\n```\nuid=0(root) gid=0(root)\n```\nYour container is running as root. Not effective root inside a namespace ‚Äî actual root on the host. If there's a container escape vulnerability (a bug in your `pivot_root` sequence, a missing seccomp filter, a suid binary in the rootfs), the escaping process has full root access on the host.\nMilestone 5 (User Namespaces and Rootless Containers) solves this by creating a user namespace where the container process *appears* to be root inside the container, but maps to an unprivileged UID on the host. The `UID 0` inside the container becomes `UID 1000` on the host. An escaped process has only the privileges of UID 1000 ‚Äî not root.\nUser namespace creation is also the key that removes the `sudo` requirement from your entire container runtime. With `CLONE_NEWUSER`, unprivileged users can create network namespaces, mount namespaces, and PID namespaces ‚Äî capabilities that currently require `CAP_SYS_ADMIN`. The kernel's reasoning: if you can only affect your own namespaced resources, you're not actually gaining privileges that affect anyone else.\nThe `CLONE_NEWUSER` flag slots directly into your existing `clone()` call alongside the other namespace flags. The complication is the UID/GID mapping write sequence ‚Äî a precise ordering requirement enforced by the kernel that causes confusing `EPERM` errors if violated. We'll dissect that sequence carefully in Milestone 5.\n---\n<!-- END_MS -->\n\n\n<!-- MS_ID: container-basic-m5 -->\n<!-- MS_ID: container-basic-m5 -->\n# Milestone 5: User Namespace and Rootless Containers\n## The Misconception You Carry Into This Milestone\nEvery container you've built so far requires `sudo`. Every `clone()` call with `CLONE_NEWPID`, `CLONE_NEWNS`, `CLONE_NEWNET` demands `CAP_SYS_ADMIN` ‚Äî the Linux capability that grants sweeping kernel-level access. You've been running as root.\nThis feels inevitable. After all, you're manipulating kernel data structures, swapping root filesystems, creating virtual network interfaces. Surely this requires elevated privileges?\nNow here's the misconception worth dismantling:\n> \"Rootless containers are a security theater compromise. UID 0 inside a user namespace is 'fake root' ‚Äî a cosmetic label with no real capabilities. Rootless containers severely limit what containers can do, sacrificing real functionality for the marketing claim of 'no root required.'\"\n**This is wrong in almost every detail.**\nHere is what actually happens when you create a user namespace:\nThe kernel grants the process inside the user namespace a **full capability set** ‚Äî `CAP_SYS_ADMIN`, `CAP_NET_ADMIN`, `CAP_SYS_CHROOT`, `CAP_MKNOD`, the full set of 41 capabilities defined in `<linux/capability.h>`. Not a subset. Not a crippled version. The complete capability set.\nBut those capabilities are **scoped** to the resources owned by the user namespace. The kernel's capability check asks a different question: not \"does this process have the capability?\" but \"does this process have the capability *in the user namespace that owns the target resource*?\"\nThis distinction is everything. A process with `CAP_SYS_ADMIN` inside a user namespace can:\n- Mount filesystems *inside its own mount namespace*\n- Create PID, UTS, and network namespaces *owned by its user namespace*\n- Perform `pivot_root()` *within its own mount namespace*\n- Write to cgroup files *within delegated cgroup subtrees*\nBut the same process **cannot**:\n- Write to `/etc/passwd` on the host (the host's filesystem is owned by the initial user namespace)\n- Load kernel modules (affects the host kernel, outside the namespace's scope)\n- Modify host network interfaces (owned by the initial network namespace)\n- Send signals to arbitrary host processes (outside the PID namespace)\nThis is not a hack. This is the Linux kernel's designed security model for capability scoping ‚Äî and it is the foundation of Podman's rootless mode that runs millions of container workloads in production. By the end of this milestone, you'll remove `sudo` from your container runtime entirely, and your containers will be more secure than the rootful versions you've been building.\n\n![Capability Scoping Across User Namespaces](./diagrams/diag-capability-scoping.svg)\n\n---\n## The Problem User Namespaces Solve: Privilege Without Exposure\n[[EXPLAIN:linux-capabilities-model-(cap_sys_admin,-cap_net_admin)|Linux capabilities model (CAP_SYS_ADMIN, CAP_NET_ADMIN)]]\nBefore user namespaces (pre-Linux 3.8), container runtimes faced an inescapable dilemma:\n- Creating namespaces requires `CAP_SYS_ADMIN` ‚Äî which requires running as root or with a setuid binary\n- Running as root means that a container escape vulnerability gives the attacker **full host root access**\n- The attack surface for container escapes was enormous: pivot_root bugs, mount namespace escapes, overlayfs vulnerabilities, cgroup misconfigurations\nThe choice was: \"give the container runtime root, and hope nothing goes wrong\" versus \"don't use containers.\" Neither is acceptable in a security-conscious environment.\nUser namespaces resolve this dilemma by making the privilege grant *scoped* rather than *global*. The kernel's security model shifts from \"you either have the capability or you don't\" to \"you have the capability within the scope of resources your namespace owns.\" An escaping container process has only the capabilities of the unprivileged host user ‚Äî not root. The blast radius of any escape drops from \"full host compromise\" to \"unprivileged user account on the host.\"\n\n![Rootful vs Rootless Container Stack ‚Äî Security Comparison](./diagrams/diag-rootless-vs-rootful-comparison.svg)\n\nThis is why the security research community considers user namespace-based rootless containers categorically more secure than rootful containers, despite providing the same isolation guarantees. The comparison target: Podman's rootless mode, enabled by default since Podman 1.0 (2018), is built entirely on user namespaces.\n---\n## How User Namespace UID Mapping Works: The Core Mechanism\n[[EXPLAIN:user-namespace-uid/gid-mapping-semantics|User namespace UID/GID mapping semantics]]\nA user namespace creates a private mapping between **inside UIDs** and **outside UIDs**. The mapping is a set of translation rules written to two files: `/proc/<pid>/uid_map` and `/proc/<pid>/gid_map`.\nEach line in these files is a triple:\n```\n<inside_start>  <outside_start>  <count>\n```\nThis means: \"UIDs from `inside_start` to `inside_start + count - 1` inside the namespace map to UIDs from `outside_start` to `outside_start + count - 1` outside.\"\nThe simplest and most common mapping for container use:\n```\n0  1000  1\n```\nThis says: \"UID 0 inside the namespace maps to UID 1000 outside.\" The container sees itself as root. The host sees it as the normal user with UID 1000. One UID mapped, in both directions.\nA broader mapping for supporting more UIDs inside the container (important for multi-user container images):\n```\n0  100000  65536\n```\nThis maps UIDs 0-65535 inside the container to UIDs 100000-165535 on the host. The container can have 65,536 distinct users ‚Äî root, daemon, nobody, and application-specific UIDs ‚Äî all mapped to a safe range of subordinate UIDs on the host that no real person uses.\n\n![User Namespace UID Mapping ‚Äî Inside vs Outside View](./diagrams/diag-user-ns-uid-mapping.svg)\n\nThe kernel enforces this translation transparently. When a container process calls `getuid()`, the kernel translates the process's real UID (1000 on the host) through the mapping to return 0. When the container creates a file owned by UID 0, the kernel stores it on disk as owned by UID 1000 (or 100000 in the broader mapping). When a host process reads that file's ownership, it sees UID 1000. This translation happens in the kernel's VFS layer on every `stat()`, `chown()`, `open()`, and file creation operation.\nThe security property: a container running as UID 0 inside its namespace, creating files in a `tmpfs` or `overlayfs`, stores those files owned by the subordinate UID range on disk. If the container escapes and tries to access files owned by real UIDs (root's files, other users' files), the translation reveals that the escaped process has no special privileges ‚Äî it's just UID 1000.\n### The Mapping File Format in Detail\nThe exact syntax matters. The files accept whitespace-separated triples, one per line:\n```\n# /proc/<pid>/uid_map ‚Äî inside_uid  outside_uid  count\n0 1000 1         # UID 0 inside ‚Üí UID 1000 outside (1 UID mapped)\n```\nMultiple lines are allowed (up to 340 entries, a kernel limit). Each line must be a non-overlapping range. The kernel validates the mapping when written and rejects invalid configurations with `EINVAL`.\nThe write must happen from **outside** the namespace ‚Äî specifically, from a process in the **parent** user namespace. The container process itself cannot write its own UID map. This is a security invariant: the entity granting capabilities cannot self-grant them. The parent (which you control) writes the mapping that determines what capabilities the child namespace has.\n---\n## The setgroups Requirement: A Security Fix Made Permanent\nBefore writing `gid_map`, you must write `\"deny\"` to `/proc/<pid>/setgroups`. This is not optional. If you skip it, writing to `gid_map` as an unprivileged user returns `EPERM`.\nHere's why this requirement exists:\nThe `setgroups()` syscall allows a process to change its supplementary group IDs. Historically, a user could call `setgroups()` to *drop* their supplementary groups ‚Äî giving up privileges. User namespaces created a problem: if an unprivileged user (UID 1000) creates a user namespace and writes a GID map that maps their GID to GID 0 (root), they could then call `setgroups()` to *add* group 0 to their supplementary groups ‚Äî even though no privilege grant was intended. This was CVE-2014-8989, a privilege escalation bug.\nThe kernel's fix: before an unprivileged user can write `gid_map`, they must declare whether `setgroups()` is allowed in this namespace. Writing `\"deny\"` disables `setgroups()` for all processes in the namespace, eliminating the attack vector. Writing `\"allow\"` permits `setgroups()` but then requires the caller to have `CAP_SETGID` in the parent namespace (which an unprivileged user doesn't have, so they can't write `gid_map` at all).\nThe consequence: **all unprivileged user namespace creation must write `\"deny\"` to `setgroups` before writing `gid_map`**. This has been required since Linux 3.19 (2015).\n```c\n// The mandatory sequence (order is enforced by kernel):\n// 1. Write \"deny\" to setgroups\n// 2. Write gid_map\n// If you reverse steps 1 and 2 for an unprivileged user, step 2 returns EPERM.\n```\n---\n## Building the UID/GID Map Writer: Complete Implementation\nThe map writing code runs in the **parent process** (your container runtime, the host side), after `clone()` returns the container PID but before the container proceeds past the sync pipe.\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/types.h>\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Write a string to a /proc/<pid>/<file> entry.\n// These files have specific write semantics: they accept exactly one write()\n// call (not multiple writes to the same fd). Write the entire content at once.\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int proc_write(pid_t pid, const char *file, const char *content) {\n    char path[256];\n    snprintf(path, sizeof(path), \"/proc/%d/%s\", pid, file);\n    // O_WRONLY only ‚Äî these files don't support O_RDWR\n    int fd = open(path, O_WRONLY);\n    if (fd < 0) {\n        fprintf(stderr, \"proc_write: open(%s): %s\\n\", path, strerror(errno));\n        return -1;\n    }\n    // Write the entire content in one write() call.\n    // The kernel requires this for uid_map/gid_map ‚Äî partial writes are rejected.\n    ssize_t n = write(fd, content, strlen(content));\n    int err = errno;\n    close(fd);\n    if (n < 0) {\n        fprintf(stderr, \"proc_write: write(%s, '%s'): %s\\n\",\n                path, content, strerror(err));\n        return -1;\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Configure UID/GID mappings for a newly created user namespace.\n//\n// Parameters:\n//   container_pid   ‚Äî host PID of the container's init process\n//   host_uid        ‚Äî the unprivileged UID on the host (your real UID)\n//   host_gid        ‚Äî the unprivileged GID on the host (your real GID)\n//\n// Mapping chosen: 0 ‚Üí host_uid (1 UID mapped)\n// This makes UID 0 inside the container appear as host_uid outside.\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nint write_uid_gid_maps(pid_t container_pid, uid_t host_uid, gid_t host_gid) {\n    char map_content[64];\n    // ‚îÄ‚îÄ Step 1: Write uid_map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Format: \"<inside_uid> <outside_uid> <count>\\n\"\n    // \"0 <host_uid> 1\" means: UID 0 inside = host_uid outside, 1 UID mapped\n    snprintf(map_content, sizeof(map_content), \"0 %d 1\\n\", (int)host_uid);\n    if (proc_write(container_pid, \"uid_map\", map_content) != 0) {\n        fprintf(stderr, \"write_uid_gid_maps: uid_map write failed\\n\");\n        return -1;\n    }\n    printf(\"[userns] uid_map written: 0 ‚Üí %d (1 UID)\\n\", (int)host_uid);\n    // ‚îÄ‚îÄ Step 2: Write \"deny\" to setgroups BEFORE gid_map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // MANDATORY for unprivileged user namespace creation (since Linux 3.19).\n    // Prevents privilege escalation via setgroups() within the namespace.\n    // This MUST happen before gid_map is written; reverse order returns EPERM.\n    if (proc_write(container_pid, \"setgroups\", \"deny\") != 0) {\n        fprintf(stderr, \"write_uid_gid_maps: setgroups deny failed\\n\");\n        return -1;\n    }\n    // ‚îÄ‚îÄ Step 3: Write gid_map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Same format as uid_map. GID 0 inside = host_gid outside.\n    snprintf(map_content, sizeof(map_content), \"0 %d 1\\n\", (int)host_gid);\n    if (proc_write(container_pid, \"gid_map\", map_content) != 0) {\n        fprintf(stderr, \"write_uid_gid_maps: gid_map write failed\\n\");\n        return -1;\n    }\n    printf(\"[userns] gid_map written: 0 ‚Üí %d (1 GID)\\n\", (int)host_gid);\n    return 0;\n}\n```\n\n![UID/GID Map Write Sequence ‚Äî Timing and Ordering](./diagrams/diag-uid-gid-map-write-sequence.svg)\n\n---\n## The Synchronization Challenge: Mapping Must Precede exec()\nAdding user namespace support introduces a new timing constraint on top of the synchronization pipe from Milestone 3. The full ordering requirement is:\n```\nHOST SIDE                                   CONTAINER SIDE\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1. clone(CLONE_NEWUSER | ...) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  (born into new user namespace)\n   returns container_pid                     (UID is \"nobody\" ‚Äî mapping not yet set)\n                                             (blocks reading from sync_pipe_read[0])\n2. write_uid_gid_maps(container_pid, ...)   \n   ‚Üë MUST happen before container proceeds ‚Üë\n3. cgroup_setup(cgroup_name, container_pid)\n4. setup_host_network(container_pid, if)\n5. write sync_pipe \"1\" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí  6. reads \"1\" from sync_pipe\n                                             7. (now UID 0 inside namespace)\n                                             8. mounts, pivot_root, network config\n                                             9. exec() user command\n```\nThe container process must not proceed to any privileged operation (mounting, sethostname, etc.) until the UID/GID maps are written. Before the mapping is set, the container process has an effectively unmapped UID ‚Äî attempts to call privileged syscalls fail with `EPERM` because the capability check finds no valid user namespace mapping.\nThe sync pipe naturally enforces this. The container blocks at `read(sync_pipe_read, ...)`. The host writes the maps (step 2), configures cgroups (step 3), sets up networking (step 4), then unblocks the container (step 5). By the time the container reads from the pipe, its namespace is fully configured.\n---\n## What Changes Inside `container_init()` with User Namespaces\nWith user namespace support, the container init function gains two important changes:\n1. **It no longer needs to be called from a root process.** The calling process (main) runs as an unprivileged user. `clone(CLONE_NEWUSER | ...)` is permitted by unprivileged users ‚Äî this is the specific exception the kernel makes.\n2. **After the UID map is written, the container process holds real kernel capabilities.** The `cap_effective`, `cap_permitted`, and `cap_inheritable` sets for the container's PID 1 are all fully populated ‚Äî the process can mount filesystems, call `pivot_root()`, configure network interfaces (within the network namespace it owns), and perform all the operations from previous milestones.\n```c\nstatic int container_init(void *arg) {\n    container_config_t *cfg = (container_config_t *)arg;\n    // ‚îÄ‚îÄ Phase 1: Wait for UID/GID maps and host setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // At this point, we're in a new user namespace but our UID map hasn't\n    // been written yet. We're in an unmapped state ‚Äî getuid() returns 65534\n    // (the kernel's \"nobody\" UID for unmapped processes).\n    // Block until the host writes the maps AND signals us.\n    char ready;\n    if (read(cfg->sync_pipe_read, &ready, 1) != 1) {\n        fprintf(stderr, \"[container] sync pipe read failed\\n\");\n        return 1;\n    }\n    close(cfg->sync_pipe_read);\n    // ‚îÄ‚îÄ Verify we are now UID 0 inside the namespace ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    printf(\"[container] UID inside namespace: %d (should be 0)\\n\", getuid());\n    printf(\"[container] GID inside namespace: %d (should be 0)\\n\", getgid());\n    // ‚îÄ‚îÄ Phase 2: Filesystem isolation (identical to Milestone 2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // We now have CAP_SYS_ADMIN scoped to our user namespace ‚Äî\n    // sufficient for mount() and pivot_root() within our mount namespace.\n    if (set_mounts_private() != 0)        return 1;\n    if (bind_mount_rootfs(cfg->rootfs) != 0) return 1;\n    if (do_pivot_root(cfg->rootfs) != 0)     return 1;\n    // ‚îÄ‚îÄ Phase 3: Identity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // sethostname() requires CAP_SYS_ADMIN in the UTS namespace's\n    // owning user namespace ‚Äî which is our user namespace. Permitted.\n    sethostname(CONTAINER_HOSTNAME, strlen(CONTAINER_HOSTNAME));\n    // ‚îÄ‚îÄ Phase 4: Pseudo-filesystems ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // mount(\"proc\", \"/proc\", \"proc\", ...) requires CAP_SYS_ADMIN in the\n    // user namespace that owns the mount namespace. That's us.\n    mount_pseudofs();\n    // ‚îÄ‚îÄ Phase 5: Container-side network configuration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // Note: veth interface was moved into our network namespace by the host.\n    // Configuring it (ip addr add, ip route add) only requires\n    // CAP_NET_ADMIN in OUR network namespace's owning user namespace.\n    setup_container_network();\n    // ‚îÄ‚îÄ Phase 6: Verification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    printf(\"[container] PID: %d\\n\", getpid());\n    printf(\"[container] UID: %d, GID: %d\\n\", getuid(), getgid());\n    // Read our capabilities ‚Äî should show full set inside the namespace\n    verify_capabilities();\n    // ‚îÄ‚îÄ Phase 7: Spawn user command ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    pid_t child = fork();\n    if (child < 0) { perror(\"fork\"); return 1; }\n    if (child == 0) {\n        execvp(cfg->argv[0], cfg->argv);\n        perror(\"execvp\");\n        exit(127);\n    }\n    // ‚îÄ‚îÄ Phase 8: Init reaper loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    while (1) {\n        int status;\n        pid_t exited = waitpid(-1, &status, 0);\n        if (exited == child) {\n            reap_zombies();\n            return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n        } else if (exited > 0) {\n            fprintf(stderr, \"[init] reaped orphan %d\\n\", exited);\n        } else if (exited == -1 && errno == ECHILD) {\n            break;\n        } else if (exited == -1 && errno == EINTR) {\n            continue;\n        }\n    }\n    return 0;\n}\n```\n### Verifying Capabilities Inside the Namespace\n```c\n#include <sys/prctl.h>\n#include <linux/capability.h>\n// Read and display the effective capability set.\n// After UID mapping, this should show a full capability bitmask.\nstatic void verify_capabilities(void) {\n    struct __user_cap_header_struct hdr = {\n        .version = _LINUX_CAPABILITY_VERSION_3,\n        .pid = 0,  // 0 means \"current process\"\n    };\n    struct __user_cap_data_struct data[2] = {0};\n    if (syscall(SYS_capget, &hdr, data) != 0) {\n        perror(\"capget\");\n        return;\n    }\n    // Effective capabilities are a bitmask across two 32-bit words\n    // (64 capabilities total in the Linux capability model)\n    printf(\"[container] Capabilities:\\n\");\n    printf(\"  effective[0]: 0x%08x\\n\", data[0].effective);\n    printf(\"  effective[1]: 0x%08x\\n\", data[1].effective);\n    // Check specific capabilities relevant to container operations\n    // CAP_SYS_ADMIN = bit 21 in word 0\n    int has_sys_admin = (data[0].effective >> 21) & 1;\n    // CAP_NET_ADMIN = bit 12 in word 0\n    int has_net_admin = (data[0].effective >> 12) & 1;\n    // CAP_MKNOD = bit 27 in word 0\n    int has_mknod = (data[0].effective >> 27) & 1;\n    printf(\"  CAP_SYS_ADMIN: %s\\n\", has_sys_admin ? \"YES\" : \"NO\");\n    printf(\"  CAP_NET_ADMIN: %s\\n\", has_net_admin ? \"YES\" : \"NO\");\n    printf(\"  CAP_MKNOD:     %s\\n\", has_mknod    ? \"YES\" : \"NO\");\n    if (has_sys_admin && has_net_admin) {\n        printf(\"  ‚Üí Full capability set confirmed inside user namespace\\n\");\n    }\n}\n```\n---\n## Complete Rootless Runtime: Full Integration\nHere is the complete container runtime integrating all five milestones. The key difference from the previous version: **main() no longer requires root**. Run it as a normal user.\n```c\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <linux/capability.h>\n#define STACK_SIZE          (1024 * 1024)\n#define CONTAINER_HOSTNAME  \"mycontainer\"\n// ‚îÄ‚îÄ Network constants (from Milestone 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n#define BRIDGE_NAME    \"ctr0\"\n#define BRIDGE_IP      \"172.20.0.1\"\n#define BRIDGE_CIDR    \"172.20.0.1/24\"\n#define CONTAINER_IP   \"172.20.0.2\"\n#define CONTAINER_CIDR \"172.20.0.2/24\"\n#define CONTAINER_GW   \"172.20.0.1\"\n#define VETH_HOST      \"veth_h0\"\n#define VETH_CONT      \"veth_c0\"\ntypedef struct {\n    char  *rootfs;\n    char **argv;\n    char  *outbound_iface;\n    int    sync_pipe_read;\n    // User namespace configuration\n    uid_t  host_uid;\n    gid_t  host_gid;\n    // Cgroup name (for resource limits)\n    char  *cgroup_name;\n} container_config_t;\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Utility\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int run(const char *fmt, ...) {\n    char cmd[1024];\n    va_list ap;\n    va_start(ap, fmt);\n    vsnprintf(cmd, sizeof(cmd), fmt, ap);\n    va_end(ap);\n    int ret = system(cmd);\n    if (ret != 0)\n        fprintf(stderr, \"[net] FAILED (%d): %s\\n\", ret, cmd);\n    return ret == 0 ? 0 : -1;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// UID/GID map writing (runs on HOST SIDE, PARENT process)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int proc_write(pid_t pid, const char *file, const char *content) {\n    char path[256];\n    snprintf(path, sizeof(path), \"/proc/%d/%s\", pid, file);\n    int fd = open(path, O_WRONLY);\n    if (fd < 0) {\n        fprintf(stderr, \"proc_write(%s): %s\\n\", path, strerror(errno));\n        return -1;\n    }\n    ssize_t n = write(fd, content, strlen(content));\n    int err = errno;\n    close(fd);\n    if (n < 0) {\n        fprintf(stderr, \"proc_write write(%s): %s\\n\", path, strerror(err));\n        return -1;\n    }\n    return 0;\n}\nstatic int write_uid_gid_maps(pid_t container_pid,\n                               uid_t host_uid, gid_t host_gid) {\n    char buf[64];\n    // uid_map: UID 0 inside ‚Üí host_uid outside\n    snprintf(buf, sizeof(buf), \"0 %d 1\\n\", (int)host_uid);\n    if (proc_write(container_pid, \"uid_map\", buf) != 0) return -1;\n    printf(\"[userns] uid_map: 0 ‚Üí %d\\n\", (int)host_uid);\n    // setgroups MUST be denied before gid_map for unprivileged callers\n    if (proc_write(container_pid, \"setgroups\", \"deny\") != 0) return -1;\n    // gid_map: GID 0 inside ‚Üí host_gid outside\n    snprintf(buf, sizeof(buf), \"0 %d 1\\n\", (int)host_gid);\n    if (proc_write(container_pid, \"gid_map\", buf) != 0) return -1;\n    printf(\"[userns] gid_map: 0 ‚Üí %d\\n\", (int)host_gid);\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Filesystem isolation (from Milestone 2 ‚Äî abbreviated)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int set_mounts_private(void) {\n    return mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL) == 0 ? 0 : -1;\n}\nstatic int bind_mount_rootfs(const char *rootfs) {\n    return mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL) == 0 ? 0 : -1;\n}\nstatic int do_pivot_root(const char *rootfs) {\n    char old_root[1024];\n    snprintf(old_root, sizeof(old_root), \"%s/.pivot_old\", rootfs);\n    mkdir(old_root, 0700);\n    if (syscall(SYS_pivot_root, rootfs, old_root) != 0) {\n        perror(\"pivot_root\"); return -1;\n    }\n    chdir(\"/\");\n    if (umount2(\"/.pivot_old\", MNT_DETACH) != 0) {\n        perror(\"umount2\"); return -1;\n    }\n    rmdir(\"/.pivot_old\");\n    return 0;\n}\nstatic int mount_pseudofs(void) {\n    mount(\"proc\",  \"/proc\", \"proc\",\n          MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL);\n    mount(\"sysfs\", \"/sys\",  \"sysfs\",\n          MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_RDONLY, NULL);\n    mount(\"tmpfs\", \"/dev\",  \"tmpfs\",\n          MS_NOSUID | MS_STRICTATIME, \"mode=755,size=65536k\");\n    const char *devs[] = { \"null\", \"zero\", \"random\", \"urandom\", NULL };\n    char src[256], dst[256];\n    for (int i = 0; devs[i]; i++) {\n        snprintf(src, sizeof(src), \"/dev/%s\", devs[i]);\n        snprintf(dst, sizeof(dst), \"/dev/%s\", devs[i]);\n        int fd = open(dst, O_CREAT | O_WRONLY, 0666);\n        if (fd >= 0) close(fd);\n        mount(src, dst, NULL, MS_BIND, NULL);\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Container-side network setup (from Milestone 3)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int setup_container_network(void) {\n    if (run(\"ip link set lo up\") != 0)                               return -1;\n    if (run(\"ip addr add %s dev %s\", CONTAINER_CIDR, VETH_CONT) != 0) return -1;\n    if (run(\"ip link set %s up\", VETH_CONT) != 0)                   return -1;\n    if (run(\"ip route add default via %s dev %s\",\n            CONTAINER_GW, VETH_CONT) != 0)                          return -1;\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Capability verification\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic void verify_capabilities(void) {\n    struct __user_cap_header_struct hdr = {\n        .version = _LINUX_CAPABILITY_VERSION_3,\n        .pid = 0,\n    };\n    struct __user_cap_data_struct data[2] = {0};\n    if (syscall(SYS_capget, &hdr, data) != 0) { perror(\"capget\"); return; }\n    int has_sys_admin = (data[0].effective >> 21) & 1;\n    int has_net_admin = (data[0].effective >> 12) & 1;\n    printf(\"[container] UID=%d GID=%d  CAP_SYS_ADMIN=%s CAP_NET_ADMIN=%s\\n\",\n           getuid(), getgid(),\n           has_sys_admin ? \"YES\" : \"NO\",\n           has_net_admin ? \"YES\" : \"NO\");\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Zombie reaper\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic void reap_zombies(void) {\n    int status;\n    pid_t pid;\n    while ((pid = waitpid(-1, &status, WNOHANG)) > 0)\n        fprintf(stderr, \"[init] reaped PID %d\\n\", pid);\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Container init ‚Äî PID 1 inside all namespaces\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int container_init(void *arg) {\n    container_config_t *cfg = (container_config_t *)arg;\n    // Block until host has written UID/GID maps and completed setup.\n    // Before the maps are written, getuid() would return 65534 (\"nobody\").\n    char ready;\n    if (read(cfg->sync_pipe_read, &ready, 1) != 1) {\n        fprintf(stderr, \"[container] sync pipe read failed\\n\");\n        return 1;\n    }\n    close(cfg->sync_pipe_read);\n    // Maps are now written. We are UID 0 inside the user namespace.\n    // We hold a full effective capability set ‚Äî scoped to our namespaces.\n    verify_capabilities();\n    // Filesystem isolation\n    if (set_mounts_private()        != 0) return 1;\n    if (bind_mount_rootfs(cfg->rootfs) != 0) return 1;\n    if (do_pivot_root(cfg->rootfs)  != 0) return 1;\n    // Identity\n    sethostname(CONTAINER_HOSTNAME, strlen(CONTAINER_HOSTNAME));\n    // Pseudo-filesystems (inside our new root)\n    mount_pseudofs();\n    // Network (veth already moved to our namespace by host)\n    // NOTE: rootless networking limitations discussed below.\n    // If VETH_CONT is present (privileged host), configure it.\n    // If running fully rootless (no host-side root), skip or use slirp4netns.\n    if (access(\"/sys/class/net/\" VETH_CONT, F_OK) == 0) {\n        setup_container_network();\n    } else {\n        printf(\"[container] veth not present ‚Äî rootless network not configured\\n\");\n        printf(\"[container] For network access, use slirp4netns externally\\n\");\n    }\n    printf(\"[container] PID=%d UID=%d GID=%d hostname=%s\\n\",\n           getpid(), getuid(), getgid(), CONTAINER_HOSTNAME);\n    // Spawn user command (fork so PID 1 stays alive as reaper)\n    pid_t child = fork();\n    if (child < 0) { perror(\"fork\"); return 1; }\n    if (child == 0) {\n        execvp(cfg->argv[0], cfg->argv);\n        perror(\"execvp\");\n        exit(127);\n    }\n    // Init reaper loop\n    while (1) {\n        int status;\n        pid_t exited = waitpid(-1, &status, 0);\n        if (exited == child) {\n            reap_zombies();\n            return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n        } else if (exited > 0) {\n            fprintf(stderr, \"[init] reaped orphan %d\\n\", exited);\n        } else if (exited == -1 && errno == ECHILD) {\n            break;\n        } else if (exited == -1 && errno == EINTR) {\n            continue;\n        }\n    }\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Host-side network setup ‚Äî still requires host root for veth/bridge\n// (rootless alternative: slirp4netns ‚Äî see discussion below)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstatic int setup_host_network(pid_t container_pid, const char *outbound_iface) {\n    run(\"ip link add name %s type bridge 2>/dev/null\", BRIDGE_NAME);\n    run(\"ip addr add %s dev %s 2>/dev/null\", BRIDGE_CIDR, BRIDGE_NAME);\n    run(\"ip link set %s up\", BRIDGE_NAME);\n    if (run(\"ip link add %s type veth peer name %s\", VETH_HOST, VETH_CONT) != 0)\n        return -1;\n    run(\"ip link set %s master %s\", VETH_HOST, BRIDGE_NAME);\n    run(\"ip link set %s up\", VETH_HOST);\n    if (run(\"ip link set %s netns %d\", VETH_CONT, container_pid) != 0)\n        return -1;\n    run(\"sysctl -w net.ipv4.ip_forward=1 -q\");\n    run(\"iptables -t nat -A POSTROUTING -s %s/24 -o %s -j MASQUERADE 2>/dev/null\",\n        BRIDGE_IP, outbound_iface);\n    run(\"iptables -A FORWARD -i %s -o %s -j ACCEPT 2>/dev/null\",\n        BRIDGE_NAME, outbound_iface);\n    run(\"iptables -A FORWARD -i %s -o %s -m state \"\n        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\",\n        outbound_iface, BRIDGE_NAME);\n    return 0;\n}\nstatic void cleanup_network(const char *outbound_iface) {\n    run(\"ip link del %s 2>/dev/null\", VETH_HOST);\n    run(\"ip link del %s 2>/dev/null\", BRIDGE_NAME);\n    run(\"iptables -t nat -D POSTROUTING -s %s/24 -o %s -j MASQUERADE 2>/dev/null\",\n        BRIDGE_IP, outbound_iface);\n    run(\"iptables -D FORWARD -i %s -o %s -j ACCEPT 2>/dev/null\",\n        BRIDGE_NAME, outbound_iface);\n    run(\"iptables -D FORWARD -i %s -o %s -m state \"\n        \"--state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null\",\n        outbound_iface, BRIDGE_NAME);\n}\nstatic int write_resolv_conf(const char *rootfs) {\n    char path[512];\n    snprintf(path, sizeof(path), \"%s/etc/resolv.conf\", rootfs);\n    FILE *f = fopen(path, \"w\");\n    if (!f) return -1;\n    fprintf(f, \"nameserver 8.8.8.8\\nnameserver 1.1.1.1\\noptions ndots:0\\n\");\n    fclose(f);\n    return 0;\n}\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Main ‚Äî runs as unprivileged user (no sudo required for core namespaces)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nint main(int argc, char **argv) {\n    if (argc < 4) {\n        fprintf(stderr,\n            \"Usage: %s <rootfs> <outbound-iface> <command> [args...]\\n\",\n            argv[0]);\n        fprintf(stderr, \"  Run as a normal user ‚Äî no sudo required!\\n\");\n        fprintf(stderr, \"  (Network setup still needs host-side root for veth.)\\n\");\n        fprintf(stderr, \"  Example: %s ./alpine-rootfs eth0 /bin/sh\\n\", argv[0]);\n        return 1;\n    }\n    const char *rootfs       = argv[1];\n    const char *outbound_if  = argv[2];\n    char      **cmd          = &argv[3];\n    // Capture the real (unprivileged) UID and GID BEFORE any namespace creation.\n    // After clone(CLONE_NEWUSER), getuid() inside the child would return 65534.\n    uid_t real_uid = getuid();\n    gid_t real_gid = getgid();\n    printf(\"[host] Running as UID=%d GID=%d\\n\", (int)real_uid, (int)real_gid);\n    // Write DNS config to rootfs (as unprivileged user ‚Äî just file I/O)\n    write_resolv_conf(rootfs);\n    // Sync pipe: container blocks until host completes setup\n    int sync_pipe[2];\n    if (pipe(sync_pipe) != 0) { perror(\"pipe\"); return 1; }\n    // Child stack allocation\n    char *stack = mmap(NULL, STACK_SIZE,\n                       PROT_READ | PROT_WRITE,\n                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK,\n                       -1, 0);\n    if (stack == MAP_FAILED) { perror(\"mmap\"); return 1; }\n    mprotect(stack, 4096, PROT_NONE);\n    char *stack_top = stack + STACK_SIZE;\n    container_config_t cfg = {\n        .rootfs          = (char *)rootfs,\n        .argv            = cmd,\n        .outbound_iface  = (char *)outbound_if,\n        .sync_pipe_read  = sync_pipe[0],\n        .host_uid        = real_uid,\n        .host_gid        = real_gid,\n        .cgroup_name     = \"mycontainer\",\n    };\n    // ‚îÄ‚îÄ clone() with CLONE_NEWUSER added to all previous namespace flags ‚îÄ‚îÄ\n    // CLONE_NEWUSER must be included ‚Äî it's what allows an unprivileged\n    // user to create the other namespaces (PID, UTS, NS, NET).\n    // Important: CLONE_NEWUSER can be combined with other CLONE_NEW* flags\n    // in a single clone() call; the user namespace is established first.\n    printf(\"[host] Creating container with user namespace (no root required)...\\n\");\n    pid_t container_pid = clone(container_init, stack_top,\n                                CLONE_NEWUSER |   // ‚Üê NEW: user namespace\n                                CLONE_NEWPID  |\n                                CLONE_NEWUTS  |\n                                CLONE_NEWNS   |\n                                CLONE_NEWNET  |\n                                SIGCHLD,\n                                &cfg);\n    if (container_pid == -1) {\n        perror(\"clone\");\n        if (errno == EPERM) {\n            fprintf(stderr, \"Hint: check /proc/sys/kernel/unprivileged_userns_clone\\n\");\n            fprintf(stderr, \"      On Debian/Ubuntu: sysctl -w \"\n                            \"kernel.unprivileged_userns_clone=1\\n\");\n        }\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    printf(\"[host] Container host PID: %d\\n\", container_pid);\n    // Parent no longer needs read end of sync pipe\n    close(sync_pipe[0]);\n    // ‚îÄ‚îÄ Step 1: Write UID/GID maps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // MUST happen before the container proceeds. Maps grant capabilities.\n    // This is the FIRST thing the host does after clone().\n    if (write_uid_gid_maps(container_pid, real_uid, real_gid) != 0) {\n        fprintf(stderr, \"[host] UID/GID map write failed ‚Äî killing container\\n\");\n        kill(container_pid, SIGKILL);\n        waitpid(container_pid, NULL, 0);\n        close(sync_pipe[1]);\n        munmap(stack, STACK_SIZE);\n        return 1;\n    }\n    // ‚îÄ‚îÄ Step 2: Cgroup setup (requires root ‚Äî a real-world limitation) ‚îÄ‚îÄ‚îÄ‚îÄ\n    // NOTE: Cgroup setup in Milestone 4 uses /sys/fs/cgroup which requires\n    // root UNLESS cgroup delegation is configured (see Knowledge Cascade).\n    // For a fully rootless container, either:\n    //   (a) skip cgroups (no resource limits), or\n    //   (b) use systemd cgroup delegation\n    // Here we attempt cgroup setup and continue if it fails.\n    // (In practice: run the whole binary with sudo, or use delegation.)\n    cgroup_config_t cg_cfg = {\n        .memory_limit_bytes = 100 * 1024 * 1024,\n        .cpu_quota_us       = 50000,\n        .cpu_period_us      = 100000,\n        .pids_max           = 32,\n    };\n    if (cgroup_setup(cfg.cgroup_name, container_pid, &cg_cfg) != 0) {\n        fprintf(stderr, \"[host] Cgroup setup failed (need root or delegation) \"\n                        \"‚Äî continuing without resource limits\\n\");\n    }\n    // ‚îÄ‚îÄ Step 3: Host network setup (requires root for veth/bridge) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    // This is the other rootless limitation: cross-namespace veth creation\n    // requires CAP_NET_ADMIN in the INITIAL network namespace (host).\n    // For true rootless networking, use slirp4netns (see Knowledge Cascade).\n    int net_ok = 0;\n    if (geteuid() == 0) {\n        // Running with host root (e.g., via sudo) ‚Äî set up veth normally\n        if (setup_host_network(container_pid, outbound_if) == 0)\n            net_ok = 1;\n    } else {\n        printf(\"[host] No host root ‚Äî skipping veth setup\\n\");\n        printf(\"[host] For rootless networking, use slirp4netns:\\n\");\n        printf(\"[host]   slirp4netns --configure --mtu=1500 %d eth0\\n\",\n               container_pid);\n    }\n    // ‚îÄ‚îÄ Step 4: Signal container ‚Äî all setup complete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    write(sync_pipe[1], \"1\", 1);\n    close(sync_pipe[1]);\n    printf(\"[host] Container unblocked ‚Äî running as UID 0 inside namespace\\n\");\n    // ‚îÄ‚îÄ Wait for container to exit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    int status;\n    waitpid(container_pid, &status, 0);\n    printf(\"[host] Container exited\\n\");\n    // ‚îÄ‚îÄ Cleanup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    if (net_ok) cleanup_network(outbound_if);\n    cgroup_cleanup(cfg.cgroup_name);\n    munmap(stack, STACK_SIZE);\n    return WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n}\n```\nCompile and run:\n```bash\ngcc -o container_m5 container_m5.c -Wall -Wextra\n# Run WITHOUT sudo ‚Äî user namespace creation is unprivileged\n./container_m5 ./alpine-rootfs eth0 /bin/sh\n# Expected output:\n# [host] Running as UID=1000 GID=1000\n# [host] Creating container with user namespace (no root required)...\n# [host] Container host PID: 47832\n# [userns] uid_map: 0 ‚Üí 1000\n# [userns] gid_map: 0 ‚Üí 1000\n# [container] UID=0 GID=0  CAP_SYS_ADMIN=YES CAP_NET_ADMIN=YES\n# [container] PID=1 UID=0 GID=0 hostname=mycontainer\n# / #        ‚Üê shell prompt inside container, as \"root\"\n```\n---\n## The Capability Scoping Model: How the Kernel Decides\nWhen the container process (running as UID 0 inside the user namespace, host UID 1000) attempts an operation like `mount()`, the kernel performs this check:\n1. **Which capability is required?** `mount()` requires `CAP_SYS_ADMIN`.\n2. **Does the process have it?** Check the process's effective capability set inside its user namespace ‚Üí yes, the full set was granted when the UID map was written.\n3. **Does the user namespace own the target resource?** The mount namespace was created by this user namespace (via `CLONE_NEWNS` from the same `clone()` call) ‚Üí yes, the user namespace is the owner.\n4. **Is the check in the owning user namespace?** Yes.\n5. **Decision: permitted.**\nNow consider the same process trying `mount(\"/dev/sda1\", \"/mnt\", \"ext4\", 0, NULL)` to mount the host's disk:\n1. `mount()` requires `CAP_SYS_ADMIN`.\n2. Process has `CAP_SYS_ADMIN` in its user namespace ‚Üí check passes.\n3. But `/dev/sda1` is a block device in the **initial** (host) user namespace. The check for mounting a real block device requires `CAP_SYS_ADMIN` in the **initial** user namespace.\n4. The container's user namespace is NOT the initial namespace.\n5. **Decision: EPERM.**\nThis is the mechanism that makes user namespaces secure. The capability check is not just \"do you have the capability?\" but \"do you have the capability in the namespace that owns the resource you're trying to manipulate?\" Container escapes that achieve only the container's user namespace capabilities cannot mount host disks, modify host iptables, or kill host processes ‚Äî because those resources are owned by the initial user namespace, where the container has no capabilities.\n\n![Capability Scoping Across User Namespaces](./diagrams/diag-capability-scoping.svg)\n\n---\n## Verifying the Security Boundary From Both Sides\nAfter launching your container, verify the fundamental promise: root inside, unprivileged outside.\n```bash\n# ‚îÄ‚îÄ Inside the container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# You appear as root:\nid\n# uid=0(root) gid=0(root) groups=0(root)\n# You can do root-like things within your namespaces:\nmount -t tmpfs tmpfs /tmp       # Works ‚Äî you have CAP_SYS_ADMIN in your mount ns\nhostname isolation-test          # Works ‚Äî you have CAP_SYS_ADMIN in your UTS ns\nip link                          # Works ‚Äî you have CAP_NET_ADMIN in your net ns\n# You CANNOT do host-level root things:\n# (Try to mount a real block device ‚Äî requires host CAP_SYS_ADMIN)\nmount /dev/sda1 /mnt 2>&1\n# mount: permission denied (or: operation not permitted)\n# You cannot see host processes:\nls /proc/ | wc -l\n# ~5 (only container PIDs)\n# ‚îÄ‚îÄ On the host ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# The container process appears as your unprivileged UID:\nps aux | grep container_m5\n# yourusername  47832  ...  container_init  ‚Üê UID 1000, NOT root\n# Verify via /proc status:\ncat /proc/47832/status | grep -E \"Uid:|Gid:|NSpid:|CapEff\"\n# Uid:    1000    1000    1000    1000   ‚Üê real/effective/saved/filesystem UIDs\n# Gid:    1000    1000    1000    1000\n# NSpid:  47832   1                      ‚Üê host PID 47832, namespace PID 1\n# CapEff: 0000000000000000               ‚Üê NO effective capabilities on HOST\n# Read the user namespace ID:\nls -la /proc/47832/ns/user\n# user -> user:[4026532847]  ‚Üê different from host's user namespace\n# Compare with host's user namespace:\nls -la /proc/self/ns/user\n# user -> user:[4026531837]  ‚Üê different inode number ‚Üí different namespace\n```\nThe `CapEff: 0000000000000000` line in `/proc/<pid>/status` is the definitive proof: from the host's perspective, this process has zero effective capabilities. No `CAP_SYS_ADMIN`, no `CAP_NET_ADMIN`, nothing. If this process escapes the container, it has the privilege level of any unprivileged user. Compare this to a rootful container escape, where `CapEff` would show `0000003fffffffff` ‚Äî full capabilities on the host.\n---\n## The Rootless Networking Boundary: Where User Namespaces End\nUser namespaces grant capabilities scoped to namespace-owned resources. The problem with networking: creating veth pairs and moving them between namespaces requires `CAP_NET_ADMIN` in the **initial** network namespace ‚Äî the host. The host's network namespace is owned by the initial user namespace. Your container's user namespace has no power there.\nThis is the hard boundary of rootless containers: **cross-namespace veth operations require host-level network capabilities.** This is not a bug or limitation in the implementation ‚Äî it's a correct security property. If unprivileged user namespaces could create interfaces on the host's network stack, any user could manipulate the host's routing table, creating a privilege escalation vector.\n\n![Rootless Networking ‚Äî slirp4netns vs pasta vs Host Network](./diagrams/diag-rootless-networking-alternatives.svg)\n\nThe practical solutions that production rootless container runtimes use:\n### slirp4netns: User-Space TCP/IP Stack\n`slirp4netns` (and its successor `pasta`) implements a full TCP/IP stack entirely in userspace. Instead of creating kernel-level veth pairs, it:\n1. Creates a tap device inside the container's network namespace (no host root required ‚Äî the user namespace owns the network namespace)\n2. Runs a user-space TCP/IP implementation that receives packets from the tap device\n3. Makes actual network calls on the host using the unprivileged user's regular socket access\n```bash\n# Install: apt install slirp4netns (Ubuntu) or apk add slirp4netns (Alpine)\n# After launching the container (while it's blocking on sync pipe):\nslirp4netns --configure --mtu=1500 --disable-host-loopback \\\n    $CONTAINER_PID eth0\n# This creates networking inside the container's net namespace WITHOUT host root.\n# The container gets 10.0.2.0/24 (slirp's default subnet).\n```\nThe performance cost: `slirp4netns` routes every packet through a user-space TCP/IP stack, which means an extra context switch and memcpy per packet compared to kernel veth. Measured overhead: ~40-80% lower throughput than veth+bridge for bulk transfers, ~2-4x higher latency for small packets. This is acceptable for most developer and CI workloads. For production performance, `pasta` (a newer alternative from the same author) achieves significantly better throughput by using a smarter architecture.\n[[EXPLAIN:tap-device-and-user-space-networking-(slirp-model)|TAP device and user-space networking ‚Äî how slirp4netns creates a virtual network interface that feeds into a user-space TCP/IP stack]]\n### The Capability Delegation Pattern\nFor production rootless environments, a common pattern is capability delegation: a privileged helper process (a small setuid binary or a systemd socket-activated service) performs only the specific host-level operations that require root, then drops all privileges. Podman uses `pasta` or `slirp4netns` for networking and `newuidmap`/`newgidmap` for extended UID mappings. This keeps the container runtime itself unprivileged while enabling full functionality.\n---\n## Subordinate UID Ranges: Supporting Full User ID Spaces\nThe single `0 1000 1` mapping (one UID) is sufficient for simple containers, but many real container images rely on multiple UIDs. An nginx image runs as UID 101 (the `nginx` user). A database image may use UID 999 for `postgres`. If your UID map only covers UID 0, the container process running as UID 101 would have an unmapped UID ‚Äî it appears as UID 65534 (\"nobody\") inside the container, and file ownership breaks.\nThe solution is subordinate UID ranges (`/etc/subuid` and `/etc/subgid`):\n```bash\n# /etc/subuid format: username:start:count\ncat /etc/subuid\n# alice:100000:65536    ‚Üê Alice can use UIDs 100000-165535 as subordinate UIDs\n# /etc/subgid ‚Äî same format for GIDs\ncat /etc/subgid\n# alice:100000:65536\n```\nA broader UID map using the subordinate range:\n```\n0  100000  65536\n```\nThis maps UIDs 0-65535 inside the container to UIDs 100000-165535 on the host. The entire user ID space of a standard Linux system fits within the container. Files created by `nginx` (UID 101 inside the container) are stored on disk as owned by UID 100101 ‚Äî safely in the subordinate range, not overlapping with any real host user.\nThe `newuidmap` and `newgidmap` setuid helper binaries (part of the `shadow-utils` package) perform the map write securely, enforcing that the requested ranges are within the caller's subordinate allocation:\n```c\n// Using newuidmap/newgidmap for extended mappings:\n// (newuidmap and newgidmap are setuid binaries that validate /etc/subuid)\nstatic int write_extended_uid_map(pid_t container_pid,\n                                   uid_t host_uid,\n                                   uid_t subuid_start,\n                                   int   subuid_count) {\n    char pid_str[32], map_entry[256];\n    snprintf(pid_str, sizeof(pid_str), \"%d\", container_pid);\n    // Map: UID 0 inside ‚Üí host_uid outside (1 UID)\n    //      UID 1 inside ‚Üí subuid_start outside (subuid_count UIDs)\n    snprintf(map_entry, sizeof(map_entry),\n             \"0 %d 1 1 %d %d\",\n             (int)host_uid, (int)subuid_start, subuid_count);\n    char *args[] = { \"newuidmap\", pid_str, \"0\", NULL, \"1\", NULL, NULL, NULL };\n    // In practice: exec(\"newuidmap\", pid, \"0\", host_uid_str, \"1\",\n    //                                    \"1\", subuid_start_str, count_str, NULL)\n    // newuidmap validates against /etc/subuid and writes the map atomically\n    (void)map_entry; // simplified for illustration\n    return 0; // exec newuidmap with appropriate arguments\n}\n```\n---\n## Hardware Soul: What the Kernel Does During User Namespace Creation\nWhen `clone(CLONE_NEWUSER | ...)` executes, the kernel performs these operations in `copy_process()`:\n1. **Allocate `struct user_namespace`** (~400 bytes): contains the UID/GID maps (arrays of `uid_gid_map_entry` structs), a reference count, the owning credential, and the parent namespace pointer.\n2. **Set the new namespace's owner**: the user namespace is initially owned by the creating user (UID 1000 in our case). The initial capability set is empty until the UID map is written.\n3. **Write the UID map** (when `proc_write` runs from the parent): the kernel validates the mapping, stores it in the `user_namespace` struct's `uid_map` array, and then ‚Äî this is the key event ‚Äî **elevates the child's effective capability set to the full set**. This elevation is atomic with the map write.\n**Cache behavior**: The `user_namespace` struct and `uid_gid_map_entry` arrays are small and fit within two or three cache lines. Accessing them during a capability check (which happens on every privileged syscall) adds one or two pointer dereferences to the existing capability check path. On hot paths (frequent `mount()` calls, network operations), this adds approximately 3-10 ns ‚Äî negligible.\n**The UID translation path on every `stat()`**: When a container process calls `stat()` on a file, the kernel:\n- Reads the file's on-disk `uid_t` (e.g., 100000)\n- Walks the `uid_map` array of the process's user namespace (linear scan, typically 1-3 entries)\n- Returns the mapped UID (e.g., 0) to userspace\nWith one mapping entry, this is a single comparison ‚Äî effectively free. With 340 entries (the maximum), it's a short linear scan. The kernel doesn't use a hash table for UID mapping because the typical case is 1-3 entries, and cache-friendly linear scan beats hash table overhead for such small sets.\n**TLB impact**: User namespace creation doesn't directly affect the TLB. The address space (page tables) is cloned normally. The UID mapping adds no new virtual memory. The only TLB-relevant change: if the container process accesses files in a new filesystem after `pivot_root()`, the new page mappings require TLB entries ‚Äî but this is identical to any exec().\n---\n## Pitfall Compendium: The Ordering Constraints That Will Cost You Days\n### Pitfall 1: Writing uid_map After the Container Has Already Proceeded\n```\n‚ùå WRONG TIMELINE:\n   clone(CLONE_NEWUSER) ‚Üí write sync pipe \"1\" ‚Üí container exec()s\n   ‚Üí then write uid_map on host\n   Effect: container ran as UID 65534 (nobody), all mounts/pivots failed\n‚úÖ CORRECT TIMELINE:\n   clone(CLONE_NEWUSER) ‚Üí write uid_map ‚Üí write gid_map ‚Üí write sync pipe \"1\"\n   ‚Üí container reads pipe ‚Üí container now has capabilities ‚Üí mount/pivot succeed\n```\nThe sync pipe exists precisely to enforce this ordering. Never signal the container until all host-side setup is complete.\n### Pitfall 2: Writing gid_map Before setgroups\n```c\n// ‚ùå WRONG ‚Äî writing gid_map before setgroups:\nproc_write(pid, \"gid_map\", \"0 1000 1\\n\");   // EPERM for unprivileged users\nproc_write(pid, \"setgroups\", \"deny\");        // Too late ‚Äî already failed\n// ‚úÖ CORRECT ‚Äî mandatory ordering:\nproc_write(pid, \"uid_map\", \"0 1000 1\\n\");   // uid_map first (no setgroups dependency)\nproc_write(pid, \"setgroups\", \"deny\");        // MUST precede gid_map\nproc_write(pid, \"gid_map\", \"0 1000 1\\n\");   // Now succeeds\n```\nThe error is `EPERM` with no further explanation ‚Äî the kernel simply refuses the write. Debugging this without knowing the setgroups requirement is very difficult because the error appears to be a permissions issue, not an ordering issue.\n### Pitfall 3: CLONE_NEWUSER Must Come First in the Flags\n```c\n// ‚ùå MIGHT FAIL on some kernel versions ‚Äî CLONE_NEWNET before CLONE_NEWUSER:\nclone(fn, stack_top, CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWUSER | SIGCHLD, arg);\n// ‚úÖ SAFE ‚Äî CLONE_NEWUSER with others (kernel processes NEWUSER first regardless of order):\nclone(fn, stack_top, CLONE_NEWUSER | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | SIGCHLD, arg);\n```\nIn practice, the kernel processes `CLONE_NEWUSER` before other namespace flags regardless of bitmask order ‚Äî but explicitly placing `CLONE_NEWUSER` first documents the intent clearly and avoids confusion.\n### Pitfall 4: uid_map Written Twice\n```c\n// ‚ùå WRONG ‚Äî writing uid_map twice:\nproc_write(pid, \"uid_map\", \"0 1000 1\\n\");\n// ... realize you made a mistake ...\nproc_write(pid, \"uid_map\", \"0 1000 1\\n\");  // EPERM ‚Äî cannot write twice\n```\nThe kernel allows `uid_map` to be written exactly once. The second write returns `EPERM` regardless of content. If you need a different mapping, you must kill the container and start over. Design your mapping correctly before the first write.\n### Pitfall 5: Unprivileged userns_clone Disabled (Debian/Ubuntu)\nSome distributions (notably Debian and Ubuntu before Ubuntu 23.10) disable unprivileged user namespace creation via a kernel parameter:\n```bash\n# Check:\nsysctl kernel.unprivileged_userns_clone\n# kernel.unprivileged_userns_clone = 0  ‚Üê DISABLED\n# Enable (requires root, persists until reboot):\nsysctl -w kernel.unprivileged_userns_clone=1\n# Permanent fix:\necho \"kernel.unprivileged_userns_clone=1\" >> /etc/sysctl.conf\nsysctl -p\n```\nThe error from `clone(CLONE_NEWUSER)` without this is `EPERM`. This is a distribution-level security policy ‚Äî some administrators disable unprivileged user namespaces to reduce kernel attack surface (user namespaces do expose more kernel code paths to unprivileged users). Production systems must decide whether the container benefits outweigh the increased kernel attack surface.\n### Pitfall 6: ID-Mapped Mount Permission Confusion\nAfter `pivot_root()` with a user namespace, file ownership in the container rootfs may appear wrong. If the rootfs was created by root (UID 0 on the host) and your container maps UID 0 inside to UID 1000 outside:\n```bash\n# Inside container:\nls -la /etc/passwd\n# -rw-r--r--  1 nobody  nobody  ...  ‚Üê owned by nobody, not root!\n# Why? The file is owned by UID 0 on disk (host root created it).\n# The container's UID map says: 0 inside ‚Üí 1000 outside.\n# The REVERSE lookup: 0 on disk ‚Üí not in map (0 is not 1000) ‚Üí \"nobody\" (65534).\n```\nThe fix for containers using the single `0 1000 1` mapping: your rootfs files should be owned by UID 1000 on the host (your real UID), not by root. When extracting a container image tarball:\n```bash\n# Extract rootfs as yourself (not root) ‚Äî files will be owned by your UID\ntar --same-owner -xf alpine-rootfs.tar.gz -C ./alpine-rootfs\n# Or: use fakeroot to extract with remapped ownership\nfakeroot tar -xf alpine-rootfs.tar.gz -C ./alpine-rootfs\n```\nThe deeper solution is **ID-mapped mounts** (Linux 5.12+) ‚Äî a kernel feature that applies UID mapping at the mount level, transparently remapping file ownership on-the-fly during filesystem operations. This eliminates the need to pre-chown the rootfs. See the Knowledge Cascade for details.\n---\n## Verification Checklist\n```bash\n# ‚îÄ‚îÄ 1. Verify no root required ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nwhoami\n# alice  (not root)\n./container_m5 ./alpine-rootfs eth0 /bin/sh\n# Should launch without sudo (ignoring cgroup/veth which may need root)\n# ‚îÄ‚îÄ 2. Verify inside UID is 0 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nid\n# uid=0(root) gid=0(root) groups=0(root)\n# ‚îÄ‚îÄ 3. Verify outside UID is unprivileged ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# On host (replace 47832 with actual container PID):\ncat /proc/47832/status | grep \"^Uid:\"\n# Uid:    1000    1000    1000    1000   ‚Üê unprivileged on host\n# ‚îÄ‚îÄ 4. Verify NSpid shows both views ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /proc/47832/status | grep NSpid\n# NSpid:  47832   1   ‚Üê host PID, namespace PID\n# ‚îÄ‚îÄ 5. Verify no effective capabilities on host ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /proc/47832/status | grep CapEff\n# CapEff: 0000000000000000   ‚Üê zero caps on host\n# ‚îÄ‚îÄ 6. Verify full capabilities inside namespace ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\ncat /proc/self/status | grep CapEff\n# CapEff: 000001ffffffffff   ‚Üê full cap set (or similar non-zero value)\n# ‚îÄ‚îÄ 7. Verify user namespace is distinct from host ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nls -la /proc/47832/ns/user\n# user -> user:[4026532847]\nls -la /proc/self/ns/user\n# user -> user:[4026531837]  ‚Üê different inode = different namespace\n# ‚îÄ‚îÄ 8. Verify UID map was written correctly ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /proc/47832/uid_map\n# 0    1000    1   ‚Üê inside 0, outside 1000, count 1\ncat /proc/47832/gid_map\n# 0    1000    1\n# ‚îÄ‚îÄ 9. Verify setgroups is denied ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncat /proc/47832/setgroups\n# deny\n# ‚îÄ‚îÄ 10. Verify mount works inside namespace (CAP_SYS_ADMIN is real) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nmount -t tmpfs tmpfs /tmp && echo \"mount succeeded\"\n# mount succeeded   ‚Üê real capability, real mount\n# ‚îÄ‚îÄ 11. Verify pivot_root isolation still works ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nls /\n# Shows container rootfs, NOT host filesystem\n# ‚îÄ‚îÄ 12. Verify PID namespace isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nps aux\n# Shows only container processes (PIDs 1, 2)\n# ‚îÄ‚îÄ 13. Verify host filesystem is inaccessible ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container (attempt to mount a block device ‚Äî should fail):\nmount /dev/sda1 /mnt 2>&1\n# mount: permission denied  ‚Üê correctly blocked (host's block dev, host's user ns)\n# ‚îÄ‚îÄ 14. Verify hostname isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n# Inside container:\nhostname\n# mycontainer\n# On host:\nhostname\n# (unchanged ‚Äî original hostname)\n```\n---\n## Knowledge Cascade: What User Namespaces Unlock\n### 1. Rootless Containers Are MORE Secure Than Rootful\nThe conventional wisdom in security is: \"less functionality = more security.\" User namespaces seem to fit this: they limit what containers can do, so surely they're less capable but safer.\nThe reality inverts this: rootless containers with user namespaces are **more** secure than rootful containers for the specific threat of container escapes, while providing equivalent isolation.\nIn a rootful container escape:\n- The escaped process has `CAP_SYS_ADMIN` on the host\n- It can load kernel modules (potential kernel code execution)\n- It can mount arbitrary block devices (filesystem access)\n- It can kill any process on the host\n- It has complete read/write access to host files\nIn a rootless container escape:\n- The escaped process has UID 1000 and zero capabilities on the host\n- It can access only files readable by UID 1000\n- It cannot modify kernel state, load modules, or kill other users' processes\n- The blast radius is bounded to the user's own account\nThe additional attack surface of user namespaces (more kernel code paths reachable by unprivileged users) is real ‚Äî there have been kernel CVEs involving user namespace privilege escalations. But the security community's consensus, supported by distros like Fedora and Ubuntu 23.10+ enabling unprivileged user namespaces by default, is that the defense-in-depth benefit of rootless containers outweighs the marginal kernel attack surface increase.\nThis is why the Kubernetes security community considers Pods running with `securityContext.runAsNonRoot: true` and appropriate user namespace configuration as a best practice ‚Äî not just a compliance checkbox.\n### 2. Kubernetes Rootless Nodes and User Namespace Pod Support\n[[EXPLAIN:kubernetes-pod-level-user-namespace-support-(hostuserns,-userns-field)|Kubernetes pod-level user namespace support ‚Äî the userns field and hostUserNS]]\nKubernetes 1.25 introduced alpha support for user namespaces in pods (KEP-127), promoted to stable in Kubernetes 1.30. The pod spec gains a `hostUsers` field:\n```yaml\napiVersion: v1\nkind: Pod\nspec:\n  hostUsers: false   # Create a user namespace for this pod\n  containers:\n  - name: app\n    securityContext:\n      runAsUser: 0   # UID 0 inside the pod's user namespace\n```\nWith `hostUsers: false`, the kubelet creates a user namespace for the pod with a UID mapping allocated from the node's subordinate UID range (configured per node). Pod UID 0 maps to a unique node-level subordinate UID ‚Äî two different pods both running as \"root\" inside their containers map to different host UIDs, preventing cross-pod privilege escalation.\nThe `runAsNonRoot: true` security context setting is related but different: it requires the container's primary process to not be UID 0, enforced by the container runtime reading the image's `USER` directive. User namespace support is a stronger guarantee: even if the container runs as UID 0, that UID has no host-level capabilities.\n### 3. ID-Mapped Mounts (Linux 5.12+): Extending UID Mapping to Filesystems\n[[EXPLAIN:id-mapped-mounts-(linux-5.12)-and-how-they-extend-user-namespace-uid-remapping-to-persistent-filesystems|ID-mapped mounts ‚Äî applying UID remapping at the filesystem mount level]]\nThe UID mapping in user namespaces works for `/proc/self/status` (kernel translates UIDs in kernel objects) but has a gap for persistent filesystems: files stored on disk have a `uid_t` in their inode. When a container's UID 0 creates a file in an `overlayfs`, that file is stored as UID 100000 on the host (using subordinate UID mapping). When the container exits and you examine the file on the host, it's owned by UID 100000 ‚Äî which may confuse host-side tools.\nID-mapped mounts solve this at the VFS level. When mounting a filesystem with an ID mapping:\n```c\n// Mount a filesystem with UID remapping applied to all file ownership\n// (Simplified ‚Äî actual API uses mount_setattr with MOUNT_ATTR_IDMAP)\n// Effect: file owned by host UID 0 appears as UID 1000 inside the container,\n//         and vice versa ‚Äî transparently, at the VFS layer\n```\nThis means container images built with root-owned files can be used directly without pre-chowning, and files created by the container appear correctly owned from the host's perspective. This is the technology that makes rootless container image layers interoperable with the host filesystem without ownership confusion. Podman 4.0+ uses ID-mapped mounts when available (kernel ‚â• 5.12).\n### 4. Nested Containers: Docker-in-Docker and CI Environments\n[[EXPLAIN:nested-user-namespaces-and-uid-map-composition|Nested user namespaces ‚Äî how UID mappings compose across levels and the 32-level kernel limit]]\nUser namespaces can be nested: a process inside a user namespace can create a child user namespace. The kernel supports up to 32 nesting levels. Each level adds a UID mapping translation.\nIf the outer container maps UID 0 (inside) ‚Üí UID 1000 (outside), and the inner container maps UID 0 (inside) ‚Üí UID 0 (outer), the kernel composes these translations: inner UID 0 ‚Üí outer UID 0 ‚Üí host UID 1000. The innermost process appears as host UID 1000, even though it sees itself as UID 0 in two nested layers.\nThis is the mechanism that makes Docker-in-Docker (DinD) work in CI environments without host root. The outer container (the CI runner) creates a user namespace; the inner container (the Docker daemon and its containers) creates a nested user namespace. The kernel correctly composes the UID translations, ensuring the innermost containers have no host-level capabilities.\nGitHub Actions, GitLab CI, and Jenkins all support rootless container runners using this nested namespace model. Understanding the UID composition explains why files created inside a CI container appear as a specific user on the host's artifact storage ‚Äî the nested UID mapping translates all the way through.\n### 5. The seccomp Connection: Defense in Depth\nUser namespaces significantly reduce the blast radius of container escapes. `seccomp` (Secure Computing Mode) filters reduce the kernel attack surface available to container processes. Together, they form complementary layers of defense:\n- **User namespaces**: limit privilege (even if you escape, you have no capabilities on host)\n- **seccomp**: limit syscall access (even if you have a kernel exploit, you can't reach the vulnerable code path)\n`seccomp` is configured via `prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, ...)` with a BPF filter that specifies which syscalls are allowed, denied, or should result in a signal. Docker's default seccomp profile blocks ~44 syscalls (including `kexec_load`, `mount` outside namespaces, `ptrace` in some configurations). Adding seccomp to your container runtime:\n```c\n#include <sys/prctl.h>\n#include <linux/seccomp.h>\n#include <linux/filter.h>\n#include <linux/audit.h>\n// Apply a minimal seccomp whitelist ‚Äî allow only common syscalls\n// In practice, use libseccomp for easier rule management\nstatic int apply_seccomp_filter(void) {\n    // This is a sketch ‚Äî a complete filter needs allow rules for\n    // all syscalls the container might legitimately use\n    struct sock_filter filter[] = {\n        // Load syscall number\n        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n                 offsetof(struct seccomp_data, nr)),\n        // Allow known-safe syscalls (would be a full list in production)\n        // Deny everything else with SIGKILL\n        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),\n    };\n    struct sock_fprog prog = {\n        .len = sizeof(filter) / sizeof(filter[0]),\n        .filter = filter,\n    };\n    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) != 0) {\n        perror(\"prctl NO_NEW_PRIVS\");\n        return -1;\n    }\n    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0) {\n        perror(\"prctl SECCOMP\");\n        return -1;\n    }\n    return 0;\n}\n```\n`PR_SET_NO_NEW_PRIVS` is required before `seccomp` for unprivileged processes ‚Äî it ensures that exec'd processes cannot gain more privileges than the current process (prevents setuid escalation through exec). This is another example of the defense-in-depth layering that makes rootless containers with user namespaces a genuinely strong security boundary.\n\n![Container Escape Vectors ‚Äî Attack Surface Map](./diagrams/diag-container-escape-taxonomy.svg)\n\n---\n## The Complete Container Creation Sequence: Full Syscall View\nWith all five milestones integrated, here is the complete sequence of kernel interactions that creates a fully isolated, resource-limited, rootless container:\n```\nHOST (unprivileged, UID 1000)             CONTAINER (user namespace, UID 0)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1.  pipe(sync_pipe)                        \n2.  mmap(STACK_SIZE, MAP_STACK)            \n3.  clone(CLONE_NEWUSER|NEWPID|NEWUTS|    \n          NEWNS|NEWNET|SIGCHLD)           ‚îÄ‚îÄ‚Üí  (born into 5 new namespaces)\n    returns container_pid                       getuid() ‚Üí 65534 (unmapped)\n                                                read(sync_pipe[0]) ‚Üí BLOCKS\n4.  write(\"/proc/$PID/uid_map\",\"0 1000 1\")\n5.  write(\"/proc/$PID/setgroups\",\"deny\")\n6.  write(\"/proc/$PID/gid_map\",\"0 1000 1\")\n    (container now has full caps in its userns)\n7.  mkdir(\"/sys/fs/cgroup/mycontainer\")\n8.  write(\".../cgroup.procs\", container_pid)\n9.  write(\".../memory.max\", 104857600)\n10. write(\".../cpu.max\", \"50000 100000\")\n11. write(\".../pids.max\", 32)\n12. ip link add veth_h0 type veth peer veth_c0\n13. ip link set veth_c0 netns $container_pid\n14. ip link set veth_h0 master ctr0; ip link set ctr0 up\n15. iptables MASQUERADE for 172.20.0.0/24\n16. write(sync_pipe[1], \"1\")             ‚îÄ‚îÄ‚Üí  read(sync_pipe[0]) ‚Üí \"1\"\n                                                getuid() ‚Üí 0 (mapped!)\n                                                mount(\"/\",\"\",MS_PRIVATE|REC)\n                                                mount(rootfs,rootfs,MS_BIND)\n                                                pivot_root(rootfs, .pivot_old)\n                                                chdir(\"/\")\n                                                umount2(\".pivot_old\",MNT_DETACH)\n                                                sethostname(\"mycontainer\")\n                                                mount(\"proc\",\"/proc\",\"proc\")\n                                                mount(\"sysfs\",\"/sys\",\"sysfs\")\n                                                mount(\"tmpfs\",\"/dev\",\"tmpfs\")\n                                                ip link set lo up\n                                                ip addr add 172.20.0.2/24 veth_c0\n                                                ip route add default via 172.20.0.1\n                                                fork() ‚Üí child execvp(command)\n                                                waitpid(-1, ...) ‚Üí reaper loop\n17. waitpid(container_pid, ...)          \n18. (container exits ‚Üí kernel SIGKILLs  \n     all namespace members)             \n19. rmdir(\"/sys/fs/cgroup/mycontainer\")\n20. ip link del veth_h0  \n21. ip link del ctr0\n22. iptables -D MASQUERADE ...\n23. munmap(stack, STACK_SIZE)\n```\n\n![Complete Container Creation ‚Äî Full Syscall Sequence](./diagrams/diag-full-container-creation-sequence.svg)\n\nThis sequence ‚Äî 23 steps spanning five kernel subsystems (process management, user namespaces, cgroups, networking, filesystems) ‚Äî is what runs every time you execute `docker run`. Docker's codebase (via containerd and runc) executes an OCI-specified version of this exact sequence. The abstractions are richer, the error handling is more robust, the OCI spec adds seccomp, AppArmor, and capability dropping ‚Äî but the kernel interactions are these same syscalls in this same order.\nYou have built a container runtime from scratch. You understand not just what it does, but why every step exists, what breaks if you skip it, and how it maps to the kernel primitives that make isolation real.\n\n![Container Runtime Architecture ‚Äî Satellite Map](./diagrams/diag-satellite-map.svg)\n\n---\n<!-- END_MS -->\n\n\n## System Overview\n\n![System Overview](./diagrams/system-overview.svg)\n\n\n\n\n# TDD\n\nA ground-up container runtime built from raw Linux kernel primitives. Each milestone adds one isolation dimension to a single clone() call, culminating in a fully rootless, resource-limited, network-connected container. The architecture is a single container_init() function that accumulates namespace flags, a sync pipe for host-child coordination, and a cgroup manager on the host side. Every design decision is traceable to a kernel data structure, a syscall, or a hardware constraint.\n\n\n\n<!-- TDD_MOD_ID: container-basic-m1 -->\n# TECHNICAL DESIGN SPECIFICATION: PID and UTS Namespace Isolation (container-basic-m1)\n\n## 1. MODULE CHARTER\n\nThis module implements the primary entry point for the container runtime, establishing the first two layers of isolation: the **PID Namespace** and the **UTS Namespace**. It is responsible for the transition from a host-level process to a \"Namespace-Local PID 1\" (Init) process. \n\n**Scope:**\n- Orchestration of the `clone(2)` system call with `CLONE_NEWPID` and `CLONE_NEWUTS`.\n- Safe management of the child stack memory using `mmap(2)` and `mprotect(2)` (guard pages).\n- Implementation of the **PID 1 Responsibility Loop**: signal handling and orphan process reaping using `waitpid(2)`.\n- Virtualization of the system identity via `sethostname(2)`.\n\n**Non-Scope:**\n- Filesystem isolation (Mount NS), Network isolation (Net NS), or Resource Limits (Cgroups).\n\n**Invariants:**\n- The process returned by `clone()` must observe its own PID as 1 via `getpid()`.\n- Host-level hostname must remain unchanged after the container's `sethostname()` call.\n- All orphaned children inside the namespace must be reaped to prevent zombie accumulation.\n\n---\n\n## 2. FILE STRUCTURE\n\nThe implementation follows a strict sequential creation order. The reader should create/modify files in the following order:\n\n1.  `src/common.h`: Shared macros, includes, and error wrappers.\n2.  `src/container.h`: Struct definitions and function prototypes.\n3.  `src/reaper.c`: Implementation of zombie reaping logic.\n4.  `src/init.c`: The container's internal entry point (PID 1 logic).\n5.  `src/main.c`: Host-side orchestration, stack allocation, and `clone()` invocation.\n\n---\n\n## 3. COMPLETE DATA MODEL\n\n### 3.1 ContainerConfig Struct\nThis structure is passed across the `clone()` boundary from the parent (host) to the child (container).\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `argv` | `char**` | Null-terminated array of strings for `execvp`. (8 bytes) |\n| 0x08 | `hostname` | `char[64]` | The desired hostname for the UTS namespace. (64 bytes) |\n| 0x48 | `stack` | `void*` | Pointer to the base of the allocated stack. (8 bytes) |\n| 0x50 | `stack_size` | `size_t` | Total size of the allocated stack. (8 bytes) |\n\n**Total Size:** 88 bytes (aligned to 8-byte boundary).\n\n### 3.2 Child Stack Layout (x86-64 Physical Memory)\nThe stack is allocated via `mmap`. On x86-64, the stack grows **downward**.\n\n| Address Range | Logic Name | Protection | Description |\n| :--- | :--- | :--- | :--- |\n| `[base, base + 4KB)` | Guard Page | `PROT_NONE` | Catches stack overflow via SIGSEGV. |\n| `[base + 4KB, base + 1MB)` | Usable Stack | `PROT_READ\\|WRITE` | Stack frames for child execution. |\n| `base + 1MB` | **stack_top** | N/A | **Initial RSP passed to clone()**. |\n\n### 3.3 Cache Line Analysis (64-byte lines)\n- `ContainerConfig` spans exactly two cache lines (64B + 24B).\n- To prevent false sharing in future multi-threaded milestones, ensure `ContainerConfig` is allocated via `posix_memalign` to a 64-byte boundary.\n\n---\n\n## 4. HARDWARE SOUL: PHYSICAL CONSTRAINTS\n\nEvery namespace operation negotiates with specific hardware subsystems:\n\n- **The TLB and Context Switches**: Calling `clone()` triggers a context switch. While namespaces are lightweight, the hardware TLB (Translation Lookaside Buffer) entries for the parent process are not valid for the new child if Address Space Layout Randomization (ASLR) creates distinct mappings. However, since the child shares the parent's memory initially (until `exec`), many L1i/L1d cache lines remain \"hot.\"\n- **Stack Alignment**: The `stack_top` passed to `clone()` **MUST** be 16-byte aligned to satisfy the x86-64 ABI requirements. Failure to align leads to crashes in SSE/AVX instructions within the child.\n- **Cache Locality**: The `argv` array should be copied into the `ContainerConfig` to ensure that when the child process boots, the pointers it needs are likely in L1/L2 cache, minimizing initial cold-start latency.\n- **Branch Prediction**: The PID 1 reaper loop (`while(1)`) is highly predictable for the CPU branch predictor. The `waitpid` call with `WNOHANG` will likely return `-ECHILD` most cycles; the CPU will speculative execute the \"sleep\" or \"continue\" path.\n\n---\n\n## 5. INTERFACE CONTRACTS\n\n### 5.1 `int container_init(void* arg)`\nThe entry point for the child process.\n- **Input:** Pointer to `ContainerConfig`.\n- **Pre-condition:** Process is running in new PID/UTS namespaces.\n- **Post-condition:** Hostname is set; user command is forked; orphans are reaped.\n- **Errors:** \n    - Returns `1` if `sethostname` fails.\n    - Returns `1` if `fork` for the primary task fails.\n\n### 5.2 `void reap_zombies(void)`\nNon-blocking collector for orphaned children.\n- **Logic:** Calls `waitpid(-1, &status, WNOHANG)` in a loop until it returns 0 or -1.\n- **Invariant:** Must be called whenever a child process in the namespace exits.\n\n### 5.3 `void* prepare_stack(size_t size)`\nAllocates the memory for the child.\n- **Input:** 1 MiB.\n- **Logic:** `mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0)`.\n- **Logic:** `mprotect(ptr, 4096, PROT_NONE)` on the bottom page.\n- **Returns:** Pointer to the **top** of the stack (`ptr + size`).\n\n---\n\n## 6. ALGORITHM SPECIFICATION\n\n### 6.1 The Clone Orchestration (Parent Side)\n1.  Initialize `ContainerConfig` with `argv` and `hostname`.\n2.  `stack_low = mmap(...)`.\n3.  `stack_top = stack_low + STACK_SIZE`.\n4.  `container_pid = clone(container_init, stack_top, CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD, &cfg)`.\n5.  Check `container_pid == -1`. On error, check `errno`:\n    - `EPERM`: User lacks `CAP_SYS_ADMIN`.\n    - `ENOMEM`: Stack allocation failed.\n6.  Call `waitpid(container_pid, &status, 0)` to block until container exit.\n\n### 6.2 The PID 1 Init Loop (Child Side)\nThe Child process becomes PID 1. It must manage the lifecycle of the actual workload.\n1.  `sethostname(cfg->hostname)`.\n2.  `pid_t main_task = fork()`.\n3.  **If `main_task == 0`**: \n    - `execvp(cfg->argv[0], cfg->argv)`.\n    - Exit on failure.\n4.  **If `main_task > 0` (The Reaper Phase)**:\n    - Enter `while(1)` loop.\n    - Call `pid_t exited_pid = waitpid(-1, &status, 0)`. (Blocking wait for any child).\n    - If `exited_pid == main_task`:\n        - The primary workload is done.\n        - Call `reap_zombies()` one last time.\n        - `exit(WEXITSTATUS(status))`.\n    - If `exited_pid > 0` (An orphan died):\n        - Log the event.\n        - Continue reaping.\n\n\n![PID Namespace Dual View ‚Äî Same Process, Two PIDs](./diagrams/tdd-diag-1.svg)\n (Init Process State Machine)\n\n---\n\n## 7. ERROR HANDLING MATRIX\n\n| Error Condition | Detected By | Recovery Action | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `clone()` returns -1 | `main()` | Log `perror`, free stack, exit 1. | Yes (`Operation not permitted`) |\n| `sethostname()` fails | `container_init()` | Return 1 to `clone` exit code. | Yes (Logs in stderr) |\n| `waitpid()` returns `EINTR` | `container_init()` | Retry `waitpid` immediately. | No |\n| Stack Overflow | Hardware MMU | Process receives `SIGSEGV`. | Yes (Crashes container) |\n| `execvp()` fails | Child of Init | `perror`, `exit(127)`. | Yes (Command not found) |\n\n---\n\n## 8. IMPLEMENTATION PATH (CHECKPOINTS)\n\n### Phase 1: The Foundation (2 hours)\n- Implement `prepare_stack` with `mmap` and the guard page.\n- Set up a dummy `container_init` that just prints `getpid()`.\n- **Checkpoint:** Run binary. It should print `Inside container, PID: 1` and `Host PID: [some_large_number]`.\n\n### Phase 2: System Identity (1 hour)\n- Implement `CLONE_NEWUTS`.\n- Call `sethostname` in `container_init`.\n- **Checkpoint:** Run container with `/bin/bash`. Inside bash, run `hostname`. It should match your config. Outside (in host), run `hostname`. It must remain unchanged.\n\n### Phase 3: The Reaper (2 hours)\n- Implement the `fork()` and `execvp()` logic within `container_init`.\n- Implement the `while(1)` loop with `waitpid`.\n- Add a test script that spawns background processes and exits (orphans).\n- **Checkpoint:** Use `ps aux` on host while container runs. Kill a background process in the container. Verify it does not stay in `<defunct>` (Z) state.\n\n### Phase 4: Formal Verification (1 hour)\n- Implement `verify_pid_namespace` by parsing `/proc/self/status`.\n- Extract the `NSpid` field.\n- **Checkpoint:** Output should confirm `NSpid: 47832 1` (Host PID and Namespace PID).\n\n---\n\n## 9. TEST SPECIFICATION\n\n### 9.1 Test Case: PID 1 Confirmation\n- **Action:** Launch container with `echo $$`.\n- **Expectation:** Output is `1`.\n\n### 9.2 Test Case: Hostname Isolation\n- **Action:** Launch container, call `sethostname(\"isolated-node\")`.\n- **Expectation:** `gethostname()` returns `isolated-node` inside, host returns original hostname.\n\n### 9.3 Test Case: Zombie Collection\n- **Action:** Inside container, run `sh -c 'sleep 100 & exit'`. \n- **Observation:** The `sleep` process is re-parented to PID 1.\n- **Action:** Kill the `sleep` process from the host.\n- **Expectation:** PID 1 reaps the process. `ps` on host shows the process is gone.\n\n---\n\n## 10. PERFORMANCE TARGETS\n\n| Operation | Target | Measurement Method |\n| :--- | :--- | :--- |\n| Namespace Creation | < 100 Œºs | `clock_gettime(CLOCK_MONOTONIC)` around `clone()`. |\n| PID Lookup Latency | < 500 ns | 1,000,000 iterations of `getpid()`. |\n| Memory Footprint | < 2 MiB | `Vmrss` in `/proc/[pid]/status`. |\n| Stack Overhead | 1 MiB (Fixed) | Static allocation size. |\n\n---\n\n## 11. MEMORY LAYOUT (ContainerConfig)\n\n```c\n// Byte alignment: 8 bytes\n// Total size: 88 bytes\ntypedef struct {\n    char** argv;           // 0x00 - Ptr to char* array\n    char hostname[64];     // 0x08 - Hostname string\n    void* stack_base;      // 0x48 - Pointer to mmap base\n    size_t stack_size;     // 0x50 - Total size of stack\n} ContainerConfig;\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m2 -->\n# TECHNICAL DESIGN SPECIFICATION: Mount Namespace and Filesystem Isolation (container-basic-m2)\n\n## 1. MODULE CHARTER\n\nThis module extends the container runtime to provide complete filesystem isolation. While Milestone 1 isolated the process tree and hostname, the container still shared the host's root filesystem. Milestone 2 implements a private **Mount Namespace** (`CLONE_NEWNS`) and utilizes the `pivot_root(2)` system call to swap the root filesystem atomically.\n\n**Scope:**\n- Extension of the `clone()` call to include the `CLONE_NEWNS` flag.\n- Resetting mount propagation to `MS_PRIVATE` to prevent \"leakage\" of mount events to the host.\n- Preparation of the new root filesystem (`rootfs`) including bind-mounting it onto itself to satisfy kernel mount-point requirements.\n- Execution of the `pivot_root` sequence: swapping roots, changing directory, and lazy-unmounting the host root.\n- Mounting essential kernel pseudo-filesystems (`/proc`, `/sys`, `/dev`) with security-conscious flags.\n- Population of a minimal `/dev` via bind-mounts of host character devices.\n\n**Non-Scope:**\n- Network namespace configuration (Milestone 3).\n- Cgroup resource enforcement (Milestone 4).\n- User namespace UID/GID mapping (Milestone 5).\n\n**Invariants:**\n- After `do_pivot_root`, the process must be unable to resolve any path leading to the host's original root filesystem.\n- The `/proc` filesystem inside the container must only reflect processes within the container's PID namespace.\n- All mount operations performed inside the container must be invisible to the host mount namespace.\n\n---\n\n## 2. FILE STRUCTURE\n\nThe implementation follows a strict sequential order. The user should modify the Milestone 1 files and add the new filesystem logic as follows:\n\n1.  `src/common.h`: Add `MS_REC`, `MS_PRIVATE`, `MS_BIND`, and `SYS_pivot_root` related headers.\n2.  `src/filesystem.c`: **(NEW)** Core logic for mount propagation, pivoting, and pseudo-fs mounting.\n3.  `src/container.h`: Update `ContainerConfig` struct to include `rootfs` path.\n4.  `src/init.c`: Integrate filesystem setup calls into the `container_init` sequence.\n5.  `src/main.c`: Update `clone()` flags and command-line argument parsing for `rootfs`.\n\n---\n\n## 3. COMPLETE DATA MODEL\n\n### 3.1 ContainerConfig Struct (Updated)\nThe structure is expanded to handle the path to the rootfs directory. All strings are passed as pointers to host-allocated memory.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `argv` | `char**` | Null-terminated array of strings for `execvp`. |\n| 0x08 | `hostname` | `char[64]` | Desired hostname for UTS namespace. |\n| 0x48 | `rootfs` | `char*` | **(NEW)** Absolute path to the container root directory. |\n| 0x50 | `stack_base` | `void*` | Pointer to the base of the allocated stack. |\n| 0x58 | `stack_size` | `size_t` | Total size of the allocated stack. |\n\n**Total Size:** 96 bytes (aligned to 8-byte boundary).\n\n### 3.2 Mount Flag Bitmasks\nWe utilize the following standard Linux mount flags defined in `<sys/mount.h>` and `<linux/fs.h>`:\n\n| Flag | Value | Purpose in this Module |\n| :--- | :--- | :--- |\n| `MS_REC` | `0x4000` | Apply operation recursively to the entire subtree. |\n| `MS_PRIVATE` | `0x40000` | Decouple mount events from other namespaces. |\n| `MS_BIND` | `0x1000` | Create a bind mount (required for pivot_root). |\n| `MS_NOSUID` | `0x0002` | Ignore set-user-ID and set-group-ID bits. |\n| `MS_NODEV` | `0x0004` | Disallow access to device special files on this FS. |\n| `MS_NOEXEC` | `0x0008` | Disallow program execution from this FS. |\n| `MNT_DETACH` | `0x0002` | Perform \"lazy\" unmount (detach from tree immediately). |\n\n---\n\n## 4. HARDWARE SOUL: PHYSICAL CONSTRAINTS\n\n### 4.1 VFS Tree and Kernel Memory\nThe Linux kernel manages mounts as a tree of `struct mount` objects in the VFS (Virtual Filesystem) layer. \n- **Memory Footprint**: Each mount entry consumes approximately 200-300 bytes of kernel slab memory. Creating a container with 10-15 mounts (root, proc, sys, dev, plus 5-6 device binds) adds ~4KB of kernel overhead.\n- **Latency**: `pivot_root` is a metadata-only operation. It performs \"pointer surgery\" on the `namespace_lock`-protected global mount list. It does not touch the physical disk. Latency is typically **2-10 microseconds**.\n\n### 4.2 TLB and Path Resolution\nPath resolution (walking `/etc/passwd`) involves the dentry cache (dcache). \n- **Physical Tension**: When we `pivot_root`, we invalidate the path-lookup cache for the calling process. The next `open()` call will incur a \"cold start\" in the dcache, requiring the kernel to re-traverse the directory entries of the *new* rootfs from the underlying storage (SSD/HDD).\n- **Instruction Cache**: Sycall wrappers like `mount()` and `umount2()` are part of the kernel hot-path. Calling them in rapid succession during container boot ensures the kernel code for VFS management is warm in the L1i cache.\n\n---\n\n## 5. INTERFACE CONTRACTS\n\n### 5.1 `int set_mounts_private(void)`\n**Logic:** `mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)`\n- **Goal:** Resets the propagation of the entire host mount tree within the new namespace.\n- **Error:** Returns `-1` if called outside a mount namespace.\n\n### 5.2 `int bind_mount_rootfs(const char* rootfs)`\n**Logic:** `mount(rootfs, rootfs, NULL, MS_BIND | MS_REC, NULL)`\n- **Constraint:** `pivot_root` requires the `new_root` to be a mount point. A standard directory is not a mount point; bind-mounting it to itself creates a mount entry in the kernel's table.\n\n### 5.3 `int do_pivot_root(const char* rootfs)`\n**Logic:**\n1. `mkdir(\".pivot_old\")` inside `rootfs`.\n2. `syscall(SYS_pivot_root, rootfs, \".pivot_old\")`.\n3. `chdir(\"/\")`.\n4. `umount2(\"/.pivot_old\", MNT_DETACH)`.\n5. `rmdir(\"/.pivot_old\")`.\n\n### 5.4 `int mount_pseudofs(void)`\n**Logic:**\n- `mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID|MS_NOEXEC|MS_NODEV, NULL)`.\n- `mount(\"sysfs\", \"/sys\", \"sysfs\", MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_RDONLY, NULL)`.\n- `mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID|MS_STRICTATIME, \"mode=755\")`.\n\n---\n\n## 6. ALGORITHM SPECIFICATION: THE PIVOT SEQUENCE\n\nThe kernel enforces 7 strict checks for `pivot_root(new, old)`. Failure to follow this sequence results in `EINVAL`.\n\n1.  **Preparation Phase**: Create the target directory inside the new rootfs (e.g., `mkdir(rootfs + \"/.pivot_old\")`).\n2.  **Mount Point Creation**: Perform the \"bind-mount-to-self\" trick on `rootfs`. This satisfies the requirement that `new_root` must be a mount point.\n3.  **Atomic Swap**: Call `pivot_root`. This moves the current root mount to `old`, and makes `new` the new root mount for the namespace.\n4.  **Reference Correction**: Call `chdir(\"/\")`. Even though the root has changed, the process's Current Working Directory (CWD) still points to the old root's inode. `chdir(\"/\")` snaps the CWD to the new root.\n5.  **Host Detachment**: Call `umount2(\"/.pivot_old\", MNT_DETACH)`. \n    - *Why MNT_DETACH?* If any background process or kernel thread has a transient handle on the old root, a standard `umount` will fail with `EBUSY`. `MNT_DETACH` detaches the mount from the tree immediately while allowing existing handles to close gracefully.\n6.  **Cleanup**: `rmdir(\"/.pivot_old\")`. This is only possible after the unmount.\n\n\n![pivot_root() Atomic Root Swap ‚Äî Mount Namespace Before and After](./diagrams/tdd-diag-9.svg)\n (Filesystem Isolation Flow)\n\n---\n\n## 7. ERROR HANDLING MATRIX\n\n| Error | Detected By | Cause | Recovery |\n| :--- | :--- | :--- | :--- |\n| `EINVAL` | `pivot_root` | `new_root` is not a mount point. | Verify `MS_BIND` was successful. |\n| `EINVAL` | `pivot_root` | `put_old` is not underneath `new_root`. | Check `mkdir` path construction. |\n| `EBUSY` | `umount2` | Filesystem is being used by the kernel. | Use `MNT_DETACH` to force lazy-unmount. |\n| `ENOENT` | `mount` | `/proc` or `/sys` missing in rootfs. | `mkdir` the mountpoints before mounting. |\n| `EPERM` | `mount` | Missing `CAP_SYS_ADMIN`. | Must run as root (until Milestone 5). |\n\n---\n\n## 8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS\n\n### Phase 1: Preparation (1 hour)\n1. Update `main.c` to accept a rootfs path as the first argument.\n2. Update `clone()` to include `CLONE_NEWNS`.\n3. Implement `create_rootfs_dirs` to ensure `proc`, `sys`, `dev`, and `.pivot_old` exist.\n- **Checkpoint**: Run with `sudo ./container ./myrootfs /bin/ls`. It should still show host files because pivoting isn't active.\n\n### Phase 2: The Pivot (2 hours)\n1. Implement `set_mounts_private` and `bind_mount_rootfs`.\n2. Implement `do_pivot_root` using `syscall(SYS_pivot_root, ...)`.\n3. Add `chdir(\"/\")` and the `umount2` sequence.\n- **Checkpoint**: Run `/bin/ls /`. It should now show only the contents of `myrootfs`. `ls /home` should return `No such file or directory`.\n\n### Phase 3: Pseudo-Filesystems (1 hour)\n1. Implement `mount_pseudofs`.\n2. Ensure `/proc` is mounted with `MS_NOSUID | MS_NOEXEC | MS_NODEV`.\n3. Mount `/dev` as a `tmpfs`.\n- **Checkpoint**: Run `/bin/ps aux`. It should only show PID 1 (your init) and the `ps` command itself.\n\n### Phase 4: Device Population (1 hour)\n1. Implement the loop to bind-mount `/dev/null`, `/dev/zero`, and `/dev/urandom` from the host.\n2. Create empty files in the container's `/dev` to act as mount targets.\n- **Checkpoint**: Run `cat /dev/urandom | head -c 10`. It should produce random output inside the container.\n\n---\n\n## 9. TEST SPECIFICATION\n\n### 9.1 Test: Host Isolation\n- **Action**: Launch container. Run `ls /etc/shadow`.\n- **Requirement**: If the container's rootfs doesn't have an `etc/shadow`, it must return `ENOENT`. It must **not** see the host's shadow file.\n\n### 9.2 Test: Procfs Scoping\n- **Action**: Run `sleep 999 &` on the host. Launch container. Run `ps aux | grep sleep`.\n- **Requirement**: Output must be empty. The container's `/proc` is restricted to its own PID namespace.\n\n### 9.3 Test: Mount Propagation\n- **Action**: Inside the container, run `mount -t tmpfs tmpfs /mnt`.\n- **Action**: On the host, run `cat /proc/mounts | grep /mnt`.\n- **Requirement**: The host must **not** see the container's `/mnt` mount.\n\n---\n\n## 10. PERFORMANCE TARGETS\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| `pivot_root` Latency | < 50 Œºs | `clock_gettime` around syscall. |\n| `/proc` Mount Time | < 500 Œºs | Kernel overhead for superblock creation. |\n| Total FS Isolation | < 2 ms | Time from `container_init` start to `execvp`. |\n\n---\n\n## 11. CONCURRENCY SPECIFICATION\n\n**Locking Strategy:**\n- All filesystem operations in this milestone are performed by a single thread (the container's PID 1) during the startup phase.\n- No mutexes are required in userspace. \n- The kernel handles concurrency via the `namespace_lock` (read/write semaphore) which prevents other processes from modifying the mount table while `pivot_root` is in progress.\n\n**Execution Order (STRICT):**\n1. `unshare(CLONE_NEWNS)` (via `clone`)\n2. `mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)`\n3. `mount(rootfs, rootfs, NULL, MS_BIND, NULL)`\n4. `pivot_root(...)`\n5. `mount(\"proc\", ...)`\n\n*Any reordering of 2, 3, and 4 will result in an insecure state or syscall failure.*\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m3 -->\n# TECHNICAL DESIGN SPECIFICATION: Network Namespace and Container Networking (container-basic-m3)\n\n## 1. MODULE CHARTER\n\nThis module establishes the connectivity layer for the container runtime. While Milestones 1 and 2 provide process and filesystem isolation, the container remains attached to the host's network stack by default. Milestone 3 implements a private **Network Namespace** (`CLONE_NEWNET`) and constructs a virtualized L2/L3 topology to enable isolated yet routed communication.\n\n**Scope:**\n- Extension of the `clone()` orchestration to include `CLONE_NEWNET`.\n- Implementation of a **Two-Phase Synchronization Protocol** using a Unix pipe to coordinate network setup between the host (parent) and container (child).\n- Host-side infrastructure: Creation of a Linux Bridge (`ctr0`), a Virtual Ethernet (`veth`) pair, and the atomic migration of one `veth` end into the child's namespace.\n- Routing and NAT: Configuration of `ip_forward` and `iptables MASQUERADE` rules to enable outbound internet access via the host's egress interface.\n- Container-side configuration: Activation of the loopback interface (`lo`), static IP assignment for the container-side `veth`, and default gateway routing.\n- Static DNS injection via `/etc/resolv.conf`.\n\n**Non-Scope:**\n- Cgroup resource limits (Milestone 4).\n- User Namespace UID/GID mapping (Milestone 5).\n- Software-Defined Networking (SDN) overlays (VXLAN/Geneve).\n\n**Invariants:**\n- The container must have a private `lo` interface; failure to bring it up results in local socket binding errors.\n- The host `veth` end must be attached to the bridge before the container is unblocked.\n- The container must not be able to sniff host network traffic or bind to host ports.\n\n---\n\n## 2. FILE STRUCTURE\n\nThe implementation requires a coordinated sequence across the following files:\n\n1.  `src/common.h`: Add networking-specific macros (IP ranges, interface names).\n2.  `src/net_host.c`: **(NEW)** Host-side logic for bridge, veth, and iptables.\n3.  `src/net_container.c`: **(NEW)** Container-side logic for interface activation and routing.\n4.  `src/container.h`: Update `ContainerConfig` with `outbound_iface` and `sync_pipe_read`.\n5.  `src/init.c`: Update `container_init` to implement the blocking read on the sync pipe.\n6.  `src/main.c`: Orchestrate the pipe creation, network setup calls, and cleanup.\n\n---\n\n## 3. COMPLETE DATA MODEL\n\n### 3.1 ContainerConfig Struct (Updated)\nThe structure now includes fields for network synchronization and host-egress discovery.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `argv` | `char**` | Null-terminated array of strings for `execvp`. |\n| 0x08 | `hostname` | `char[64]` | Desired hostname for UTS namespace. |\n| 0x48 | `rootfs` | `char*` | Absolute path to the container root directory. |\n| 0x50 | `outbound_iface` | `char*` | Host interface for NAT (e.g., \"eth0\", \"enp3s0\"). |\n| 0x58 | `sync_pipe_read` | `int` | File descriptor for the read end of the sync pipe. |\n| 0x60 | `stack_base` | `void*` | Pointer to the base of the allocated stack. |\n| 0x68 | `stack_size` | `size_t` | Total size of the allocated stack. |\n\n**Total Size:** 112 bytes (aligned to 8-byte boundary).\n\n### 3.2 Network Topology Constants\nTo ensure reproducibility, we use a fixed subnet for the container bridge.\n\n| Constant | Value | Description |\n| :--- | :--- | :--- |\n| `BRIDGE_NAME` | `\"ctr0\"` | The virtual switch hub on the host. |\n| `BRIDGE_IP` | `\"172.20.0.1\"` | Gateway address for the container. |\n| `BRIDGE_NET` | `\"172.20.0.1/24\"` | Subnet mask for the bridge. |\n| `CONT_IP` | `\"172.20.0.2\"` | Fixed IP for the container veth. |\n| `VETH_HOST` | `\"veth_h0\"` | Host-side endpoint of the veth pair. |\n| `VETH_CONT` | `\"veth_c0\"` | Container-side endpoint of the veth pair. |\n\n### 3.3 Cache Line Analysis (64B)\n- `ContainerConfig` now spans **two full cache lines** (112 bytes). \n- **MANDATORY**: The `sync_pipe_read` field (at 0x58) and `outbound_iface` (at 0x50) sit on the same cache line. In a multi-container start scenario, contention on this cache line during `clone()` argument reading may occur. However, since the struct is read-only after `clone()`, it will be cached as \"Shared\" across CPU cores.\n\n---\n\n## 4. HARDWARE SOUL: PHYSICAL CONSTRAINTS\n\n### 4.1 Packet Path and Namespace Crossing\nWhen a packet travels from the container to the internet:\n1.  **Context Switch**: The packet starts in the container's network namespace. \n2.  **The veth Bridge**: The kernel's `veth_xmit()` function is called. It does **not** copy data; it moves the `sk_buff` (socket buffer) pointer from the container's TX queue to the peer's RX queue. \n3.  **Instruction Cache Pressure**: The packet traverses the kernel network stack **twice** (once for each namespace). This increases the instruction cache (L1i) pressure as the `ip_rcv` and `netif_receive_skb` functions are called twice for every outbound segment.\n4.  **Hardware Offloading**: Because the `veth` is virtual, features like TSO (TCP Segmentation Offload) and Checksum Offloading are handled in software. This consumes more CPU cycles than a physical NIC would.\n\n### 4.2 Latency and Pipeline Stalls\n- **Syscall Overhead**: Spawning `ip` and `iptables` via `system()` or `fork/exec` is expensive (~10-50ms). This is a \"Cold Path\" operation that occurs during container boot.\n- **Memory Access**: Netfilter (iptables) rules are stored in a contiguous linear array. For every packet, the CPU must fetch these rules. If the rule set is large, this causes L2/L3 cache misses.\n\n---\n\n## 5. INTERFACE CONTRACTS\n\n### 5.1 `int setup_host_network(pid_t container_pid, const char* outbound_iface)`\n**Logic:**\n1.  `ip link add name ctr0 type bridge`.\n2.  `ip addr add 172.20.0.1/24 dev ctr0`.\n3.  `ip link add veth_h0 type veth peer name veth_c0`.\n4.  `ip link set veth_h0 master ctr0`.\n5.  `ip link set veth_c0 netns <container_pid>`.\n6.  `iptables -t nat -A POSTROUTING -s 172.20.0.0/24 -o <outbound_iface> -j MASQUERADE`.\n\n### 5.2 `int setup_container_network(void)`\n**Logic (Executed inside child):**\n1.  `ip link set lo up`.\n2.  `ip addr add 172.20.0.2/24 dev veth_c0`.\n3.  `ip link set veth_c0 up`.\n4.  `ip route add default via 172.20.0.1`.\n\n### 5.3 `int write_resolv_conf(const char* rootfs)`\n**Logic:** Writes `nameserver 8.8.8.8` to `<rootfs>/etc/resolv.conf`.\n- **Constraint**: Must be done before `pivot_root`.\n\n---\n\n## 6. ALGORITHM SPECIFICATION: THE SYNC PIPE PROTOCOL\n\nThe \"Two-Phase Dance\" is required because `veth_c0` cannot be moved into a namespace that doesn't exist yet, and the child cannot configure an interface that hasn't been moved in yet.\n\n1.  **Parent**: `pipe(sync_pipe)`.\n2.  **Parent**: `clone(..., CLONE_NEWNET, &cfg)`. `cfg.sync_pipe_read` is passed to the child.\n3.  **Child (`container_init`)**: Immediately calls `read(cfg.sync_pipe_read, &buf, 1)`. This **blocks** the child.\n4.  **Parent**: Receives `child_pid`. \n5.  **Parent**: Performs `setup_host_network`. This creates the `veth` pair and \"pushes\" `veth_c0` into the child's namespace using the `child_pid`.\n6.  **Parent**: `write(sync_pipe[1], \"1\", 1)`.\n7.  **Child**: The `read()` call unblocks. The child proceeds to `setup_container_network`.\n8.  **Child**: `veth_c0` is now visible inside the child's `ip link`.\n\n\n![Container Networking Topology ‚Äî veth Pair + Bridge + NAT Full Map](./diagrams/tdd-diag-15.svg)\n (The Network Sync Sequence)\n\n---\n\n## 7. ERROR HANDLING MATRIX\n\n| Error | Detected By | Cause | Recovery |\n| :--- | :--- | :--- | :--- |\n| `EADDRNOTAVAIL` | Child (Socket bind) | `lo` interface is DOWN. | Ensure `ip link set lo up` is called first. |\n| `ENOENT` (veth_c0) | Child (`ip addr`) | Host failed to move `veth_c0` in. | Parent must check `ip link set netns` return code. |\n| No Internet | Child (`ping 8.8.8.8`) | `ip_forward` is 0 on host. | Parent must `sysctl -w net.ipv4.ip_forward=1`. |\n| `EEXIST` | Parent (`ip link add`) | Bridge or veth from previous run exists. | `cleanup_network` must be robust; use `ip link del`. |\n| DNS Timeout | Child (`nslookup`) | `/etc/resolv.conf` missing. | Verify `write_resolv_conf` path relative to `rootfs`. |\n\n---\n\n## 8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS\n\n### Phase 1: Coordination Scaffolding (1 hour)\n1. Create the `pipe(sync_pipe)` in `main()`.\n2. Add the blocking `read()` to the top of `container_init`.\n3. Add the `write()` to `main()` after `clone()`.\n- **Checkpoint**: Run the container. The child should wait indefinitely until you manually press enter or the parent writes.\n\n### Phase 2: Host Infrastructure (2 hours)\n1. Implement `setup_bridge` and `create_veth_pair`.\n2. Implement the Netlink-equivalent `ip link set veth_c0 netns <pid>`.\n- **Checkpoint**: Run container. From a second terminal on the host, run `ip netns identify <pid>`. Run `ip link` on host; `veth_c0` should be gone.\n\n### Phase 3: NAT and Forwarding (1 hour)\n1. Implement `enable_ip_forwarding`.\n2. Implement `setup_nat` using `iptables`.\n- **Checkpoint**: From the host, verify `iptables -t nat -L` shows the `MASQUERADE` rule.\n\n### Phase 4: Container Configuration (1 hour)\n1. Implement `setup_container_network` inside `container_init`.\n2. Bring up `lo` and `veth_c0`.\n- **Checkpoint**: Inside the container, run `ip addr`. You should see `172.20.0.2`. You should be able to `ping 172.20.0.1` (the host gateway).\n\n---\n\n## 9. TEST SPECIFICATION\n\n### 9.1 Test: Localhost Binding\n- **Action**: Inside container, run `nc -l -p 8080 -s 127.0.0.1`.\n- **Requirement**: Must succeed. If `lo` is down, this fails with `Cannot assign requested address`.\n\n### 9.2 Test: Egress Connectivity\n- **Action**: Inside container, run `ping -c 1 8.8.8.8`.\n- **Requirement**: 0% packet loss. Confirms veth -> bridge -> host eth0 -> NAT pipeline.\n\n### 9.3 Test: Port Isolation\n- **Action**: Inside container, listen on port 9999.\n- **Action**: On host, run `nc -z 127.0.0.1 9999`.\n- **Requirement**: Connection must fail/timeout. The host's loopback is distinct from the container's.\n\n---\n\n## 10. PERFORMANCE TARGETS\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| Cross-Namespace RTT | < 50 Œºs | `ping 172.20.0.1` from container. |\n| NAT Throughput Hit | < 10% | `iperf3` comparison (Host vs Container). |\n| Netlink Assignment | < 5 ms | Time to move interface into namespace. |\n| Setup Duration | < 200 ms | Total time for `setup_host_network`. |\n\n---\n\n## 11. CONCURRENCY & CLEANUP SPECIFICATION\n\n### 11.1 atexit() Cleanup\nNetwork resources (`veth`, `bridge`, `iptables` rules) persist in the kernel even if the userspace process dies. \n- **MANDATORY**: Register a cleanup function using `atexit()` in the parent.\n- **Logic**: \n    1. `iptables -t nat -D POSTROUTING ...`\n    2. `ip link del ctr0`\n    3. `ip link del veth_h0` (deleting the host end automatically destroys the peer in the container namespace).\n\n### 11.2 Syscall List (Reference)\nThe implementation will rely on these primary syscalls:\n- `pipe(2)` / `read(2)` / `write(2)`: Synchronization.\n- `system(3)` or `execve(2)`: Invoking `ip` and `iptables` utilities.\n- `clone(2)`: With `CLONE_NEWNET`.\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m4 -->\n# TECHNICAL DESIGN SPECIFICATION: Cgroups Resource Limits (container-basic-m4)\n\n## 1. MODULE CHARTER\n\nThis module implements the resource accounting and enforcement layer of the container runtime using Linux Control Groups (cgroups). While namespaces provide visibility isolation, cgroups ensure that a containerized process cannot exhaust host physical resources, preventing \"noisy neighbor\" effects and Denial-of-Service (DoS) attacks like fork bombs.\n\n**Scope:**\n- Automatic detection of the host cgroup version (v1 vs. v2 unified hierarchy).\n- Abstraction of cgroup filesystem operations (`mkdir`, `write`, `read`, `rmdir`) via robust helper functions.\n- Implementation of the **Cgroup v2 Subtree Control** delegation pattern to enable memory, cpu, and pids controllers for child groups.\n- Enforcement of **Memory Limits**: Hard caps on Resident Set Size (RSS) and total disablement of swap to ensure predictable OOM behavior.\n- Enforcement of **CPU Bandwidth**: Configuration of the CFS (Completely Fair Scheduler) quota and period to throttle CPU usage.\n- Enforcement of **Process Limits**: Capping the total number of tasks to prevent PID exhaustion.\n- Integration with the Milestone 3 synchronization pipe to apply limits in the critical window between `clone()` and `exec()`.\n\n**Non-Scope:**\n- User namespace integration (handled in Milestone 5).\n- I/O weight/bandwidth limits (blkio).\n- Network priority cgroups (net_cls).\n\n**Invariants:**\n- A process must be assigned to the cgroup (`cgroup.procs`) *before* the synchronization pipe unblocks the child for `exec()`.\n- The `memory.swap.max` (v2) or `memory.memsw.limit_in_bytes` (v1) must be set to the same value as the memory limit (or 0) to prevent swap evasion.\n- Cgroup cleanup (`rmdir`) must only occur after `waitpid()` confirms all processes in the namespace have terminated.\n\n---\n\n## 2. FILE STRUCTURE\n\nThe implementation follows a modular structure to handle the divergence between v1 and v2 APIs.\n\n1.  `src/cgroup.h`: Type definitions and public API signatures.\n2.  `src/cg_utils.c`: Low-level filesystem wrappers (open/write/read) for `/sys/fs/cgroup`.\n3.  `src/cg_v2.c`: Implementation of the Unified Hierarchy logic.\n4.  `src/cg_v1.c`: Fallback implementation for Legacy Hierarchies.\n5.  `src/main.c`: Updated to call `cgroup_setup` before signaling the child.\n6.  `tests/stress_mem.c`: Test binary to trigger OOM.\n7.  `tests/stress_cpu.c`: Test binary to verify throttling.\n\n---\n\n## 3. COMPLETE DATA MODEL\n\n### 3.1 CgroupConfig Struct\nThis structure defines the resource envelope for the container.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `memory_limit_bytes` | `int64_t` | Hard limit for RAM. -1 for unlimited. |\n| 0x08 | `cpu_quota_us` | `int64_t` | CPU time allowed (Œºs) per period. |\n| 0x10 | `cpu_period_us` | `int64_t` | The CFS period length (Œºs), usually 100,000. |\n| 0x18 | `pids_max` | `int32_t` | Max processes in the cgroup. -1 for unlimited. |\n| 0x1C | (padding) | `uint8_t[4]` | Padding for 8-byte alignment. |\n\n**Total Size:** 32 bytes.\n\n### 3.2 Internal Cgroup State\nThe runtime maintains internal state for cleanup purposes.\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `cgroup_version` | `int` | 1 or 2, detected at runtime. |\n| `name` | `char[256]` | Unique identifier for the cgroup directory. |\n| `root_path` | `char[512]` | Base mount point (e.g., `/sys/fs/cgroup`). |\n\n---\n\n## 4. HARDWARE SOUL: PHYSICAL CONSTRAINTS\n\n### 4.1 Memory Charging and Page Faults\nMemory limits are enforced during the **Page Fault** hardware exception path.\n- **Tension**: Software allocates via `malloc()` (virtual), but the hardware MMU only cares about physical pages.\n- **Physical Impact**: When the process touches a page, the kernel‚Äôs `do_page_fault` handler is invoked. Before the kernel assigns a physical frame, it calls `mem_cgroup_charge`. \n- **Latency**: This adds approximately **50-200 ns** to the page fault. If `memory.max` is reached, the CPU enters a direct reclaim path, which can stall the process for **milliseconds** while the kernel searches for pages to evict to disk.\n\n### 4.2 CFS Scheduler and Pipeline Stalls\nCPU limits are enforced via the **CFS Bandwidth Controller**.\n- **The Mechanism**: The kernel maintains a `runtime_remaining` counter for the cgroup. Every time the hardware timer interrupt fires, the scheduler decrements this counter based on actual CPU cycles consumed by the container's processes.\n- **Throttling**: If the counter hits zero, the kernel removes the process from the CPU's run-queue. It remains in a \"wait\" state until the next `cpu_period_us` starts.\n- **Cache Locality**: Throttling causes severe pipeline flushes and L1/L2 cache cold-starts. When a throttled process is finally resumed, its data is likely evicted from cache, leading to a \"sawtooth\" performance profile.\n\n### 4.3 Atomic PID Counting\nThe `pids.max` check occurs in the `copy_process()` kernel path during `fork()` or `clone()`.\n- **Constraint**: It is a single atomic integer increment/comparison.\n- **Hardware Performance**: Cost is **< 20 ns**. It is the most lightweight resource check in the kernel.\n\n---\n\n## 5. INTERFACE CONTRACTS\n\n### 5.1 `int detect_cgroup_version(void)`\n- **Logic**: Performs `stat()` on `/sys/fs/cgroup/cgroup.controllers`. \n- **Return**: `2` if file exists (v2), `1` if `/sys/fs/cgroup/memory` exists (v1), `-1` on total failure.\n\n### 5.2 `int cgroup_setup(const char* name, pid_t pid, CgroupConfig* cfg)`\n- **Input**: The container's host-visible PID and the desired limits.\n- **Logic**:\n    1. Detect version.\n    2. Create directory `/sys/fs/cgroup/<name>`.\n    3. If v2: Enable controllers in parent `cgroup.subtree_control`.\n    4. Write `pid` to `cgroup.procs`.\n    5. Write limits to corresponding version-specific files.\n- **Errors**: Returns `EINVAL` if controllers cannot be enabled; `EPERM` if not root.\n\n### 5.3 `int cgroup_cleanup(const char* name)`\n- **Logic**: Recursively calls `rmdir()` on the created paths.\n- **Invariant**: Will return `EBUSY` if the process has not been reaped by `waitpid()` first.\n\n---\n\n## 6. ALGORITHM SPECIFICATION\n\n### 6.1 Subtree Control Enablement (Cgroups v2)\nIn v2, child groups do not inherit controllers automatically. The parent must delegate.\n1.  Open `/sys/fs/cgroup/cgroup.subtree_control`.\n2.  Write `\"+memory +cpu +pids\"`.\n3.  This must be done **before** `mkdir` of the child cgroup to ensure the child group's files (e.g., `memory.max`) are generated by the kernel.\n\n### 6.2 The Procs Assignment Window\nThe assignment to `cgroup.procs` is the most time-sensitive operation.\n1.  Host calls `clone()`.\n2.  Host receives `container_pid`.\n3.  Host writes `container_pid` to `/sys/fs/cgroup/mycontainer/cgroup.procs`.\n4.  **ONLY THEN** Host writes to `sync_pipe[1]`.\n5.  Child reads `sync_pipe[0]`, proceeds to `execvp()`.\n*Result*: The first instruction of the target binary executes with limits already applied.\n\n\n![cgroups v2 Unified Hierarchy ‚Äî Filesystem Layout](./diagrams/tdd-diag-21.svg)\n (Cgroup Setup Synchronization)\n\n---\n\n## 7. ERROR HANDLING MATRIX\n\n| Error Condition | Detection | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `EINVAL` on `memory.max` | `cg_write_long` | Check `cgroup.subtree_control` in parent. | Yes (\"Invalid argument\") |\n| `EBUSY` on `rmdir` | `cgroup_cleanup` | `waitpid()` loop in `main` must complete first. | Yes (\"Device or resource busy\") |\n| OOM Killer triggered | Kernel (Host) | The child receives `SIGKILL`. | Yes (`Killed` in terminal) |\n| `EPERM` on write | `open()` | Verify `sudo` or cgroup delegation. | Yes (\"Permission denied\") |\n| `ENOENT` on `cpu.max` | `open()` | Controller `cpu` not enabled/available. | Yes |\n\n---\n\n## 8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS\n\n### Phase 1: Detection & Helpers (1 hour)\n- Implement `detect_cgroup_version()`.\n- Implement `cg_write_str` and `cg_write_long` using `snprintf` and `write()`.\n- **Checkpoint**: Run a standalone test that creates a folder in `/sys/fs/cgroup/` and writes the current shell's PID to `cgroup.procs`. Verify with `cat /proc/self/cgroup`.\n\n### Phase 2: Memory & PID Limits (1.5 hours)\n- Implement `memory.max` (v2) / `memory.limit_in_bytes` (v1).\n- **MANDATORY**: Implement `memory.swap.max = 0` to prevent bypass.\n- Implement `pids.max`.\n- **Checkpoint**: Launch container with `memory_limit_bytes = 50MB`. Run a C program that `mallocs` 100MB and `memsets` it. Container must be killed by OOM killer.\n\n### Phase 3: CPU Bandwidth (1.5 hours)\n- Implement `cpu.max` parsing for v2 (`quota period` space-separated).\n- Implement v1 fallback (`cpu.cfs_quota_us` and `cpu.cfs_period_us`).\n- **Checkpoint**: Launch container with `quota=50000`, `period=100000` (50% CPU). Run a tight `while(1)` loop. Use `top` on host; process must stay at ~50.0% CPU.\n\n### Phase 4: Observability & Cleanup (1 hour)\n- Implement `cgroup_report_v2` to read `memory.current` and `cpu.stat`.\n- Implement `rmdir` cleanup.\n- **Checkpoint**: Ensure cgroup directory is removed from `/sys/fs/cgroup/` after container exits.\n\n---\n\n## 9. TEST SPECIFICATION\n\n### 9.1 Test: Fork Bomb Containment\n- **Config**: `pids_max = 20`.\n- **Action**: Run `:(){ :|:& };:` inside container.\n- **Requirement**: Container survives. Shell reports `fork: Resource temporarily unavailable`. Host remains stable.\n\n### 9.2 Test: Memory Hard Limit\n- **Config**: `memory_limit_bytes = 64MB`, `swap = 0`.\n- **Action**: `dd if=/dev/zero of=/dev/shm/test bs=1M count=128`.\n- **Requirement**: Process killed. `dmesg` confirms `oom-kill:constraint=CONSTRAINT_MEMCG`.\n\n### 9.3 Test: CPU Throttling\n- **Config**: `quota = 10000`, `period = 100000` (10% CPU).\n- **Action**: Run `sha256sum /dev/zero`.\n- **Requirement**: Host `top` shows process restricted to 10% utilization. `cpu.stat` shows `nr_throttled > 0`.\n\n---\n\n## 10. PERFORMANCE TARGETS\n\n| Operation | Target | Measurement Method |\n| :--- | :--- | :--- |\n| Cgroup Setup Latency | < 50 ms | `gettimeofday` from host start to pipe signal. |\n| Page Fault Overhead | < 300 ns | `lat_pagefault` from lmbench inside/outside. |\n| Memory usage read | < 20 Œºs | `time cat /sys/fs/cgroup/.../memory.current`. |\n| Task migration | < 100 Œºs | Time to write PID to `cgroup.procs`. |\n\n---\n\n## 11. CONCURRENCY SPECIFICATION\n\n**Single-Writer Model:**\n- Only the host process (parent) writes to cgroup control files.\n- The child process may *read* from its own `/sys/fs/cgroup/` entry for self-monitoring but must never attempt to write (this would require `CAP_SYS_ADMIN` in the host namespace).\n\n**Thread Safety:**\n- If the monitor (report) function runs in a separate host thread, it must use a read-only file descriptor to `cpu.stat` and `memory.current` to avoid blocking the main execution path.\n\n**Zombie Reaping Order:**\n1. Container Process exits.\n2. Host `waitpid()` returns.\n3. Host calls `cgroup_cleanup()`.\n*If 3 occurs before 2, `rmdir` will fail with `EBUSY` because the zombie process is still a member of the cgroup.*\n\n---\n\n## 12. WIRE FORMAT: CGROUP V2 CPU.MAX\n\nThe `cpu.max` file uses a specific space-separated string format.\n\n```c\n// Example construction for 50% CPU limit\nchar buf[64];\nlong quota = 50000;\nlong period = 100000;\nsnprintf(buf, sizeof(buf), \"%ld %ld\", quota, period);\n// Written as: \"50000 100000\"\n```\n<!-- END_TDD_MOD -->\n\n\n<!-- TDD_MOD_ID: container-basic-m5 -->\n# TECHNICAL DESIGN SPECIFICATION: User Namespace and Rootless Containers (container-basic-m5)\n\n## 1. MODULE CHARTER\n\nThis module implements the final and most critical security layer: the **User Namespace** (`CLONE_NEWUSER`). This allows the container runtime to function without `sudo` (root privileges) by remapping the container's internal `root` user (UID 0) to an unprivileged user on the host (e.g., UID 1000). \n\n**Scope:**\n- Integration of `CLONE_NEWUSER` into the atomic `clone(2)` call.\n- Implementation of the **Parent-Side ID Mapping** sequence: writing to `/proc/<pid>/uid_map` and `/proc/<pid>/gid_map`.\n- Enforcement of the kernel-mandated `setgroups=deny` write before `gid_map` for unprivileged creators.\n- Verification of the **Capability Scoping** model: checking for `CAP_SYS_ADMIN` and `CAP_NET_ADMIN` inside the namespace using `capget(2)`.\n- Implementation of `set_oom_score_adj` to allow host-side priority management.\n- Documentation and integration of **Rootless Networking** constraints (handling the transition from kernel `veth` to userspace `slirp4netns`).\n\n**Invariants:**\n- The host process must observe a zero-capability set (`CapEff: 0000000000000000`) for the child via `/proc/<pid>/status`.\n- The child process must observe its UID as 0 via `getuid()`.\n- The synchronization pipe must block the child until the parent has completed the mapping write; otherwise, the child enters an \"unmapped\" state (UID 65534).\n\n---\n\n## 2. FILE STRUCTURE\n\nThe implementation follows a sequential enhancement of the existing runtime. \n\n1. `src/common.h`: Add capability-related headers and bitmasks.\n2. `src/userns.c`: **(NEW)** Core logic for UID/GID mapping and capability verification.\n3. `src/container.h`: Update `ContainerConfig` with `host_uid` and `host_gid`.\n4. `src/init.c`: Update `container_init` to verify identity and capabilities after unblocking.\n5. `src/main.c`: The master orchestration: capture real UIDs, call `clone()` without root, and perform mapping.\n\n---\n\n## 3. COMPLETE DATA MODEL\n\n### 3.1 ContainerConfig Struct (Extended)\nThe config struct is expanded to pass the host's real identity into the namespace for mapping.\n\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `argv` | `char**` | Command to exec. |\n| 0x08 | `hostname` | `char[64]` | UTS identity. |\n| 0x48 | `rootfs` | `char*` | FS path. |\n| 0x50 | `outbound_if` | `char*` | Network interface. |\n| 0x58 | `sync_pipe` | `int` | Read end of pipe. |\n| 0x5C | `host_uid` | `uid_t` | **(NEW)** Real UID of the caller (usually 1000). |\n| 0x60 | `host_gid` | `gid_t` | **(NEW)** Real GID of the caller. |\n| 0x68 | `stack_base` | `void*` | Child stack. |\n| 0x70 | `stack_size` | `size_t` | Stack size. |\n\n**Total Size:** 120 bytes (aligned to 8-byte boundary).\n\n### 3.2 Capability Struct Layout (Level 3 - Hardware/Kernel)\nWe interface with the kernel's capability bitmask directly via `capget`.\n\n**struct __user_cap_header_struct:**\n| Offset | Field | Type | Description |\n| :--- | :--- | :--- | :--- |\n| 0x00 | `version` | `uint32_t` | `_LINUX_CAPABILITY_VERSION_3` (0x20080522). |\n| 0x04 | `pid` | `int` | Process ID to query (0 for current). |\n\n**struct __user_cap_data_struct (effective[0]):**\n| Bit | Name | Hex Mask | Description |\n| :--- | :--- | :--- | :--- |\n| 12 | `CAP_NET_ADMIN` | `0x00001000` | Network config rights. |\n| 21 | `CAP_SYS_ADMIN` | `0x00200000` | General \"root\" rights (mount, etc.). |\n| 27 | `CAP_MKNOD` | `0x08000000` | Create special device files. |\n\n---\n\n## 4. HARDWARE SOUL: PHYSICAL CONSTRAINTS\n\n### 4.1 UID Translation Overhead\nEvery time the container calls `stat(2)` or `getuid(2)`, the kernel performs a translation.\n- **Physical Tension**: The kernel stores UIDs as raw 32-bit integers in the `inode` or `task_struct`.\n- **Complexity**: The translation is a **linear scan** of the `uid_gid_map_entry` array in the `user_namespace` struct.\n- **Latency**: For our `0 1000 1` mapping (1 entry), the overhead is **~3-10 ns**. On hardware with a large L1 cache, this stays within the pipeline. If a namespace had 340 entries (the max), cache misses would start impacting VFS heavy-workloads.\n\n### 4.2 Cache Line Alignment\n`ContainerConfig` is now 120 bytes. \n- **MANDATORY**: The struct spans **two 64-byte cache lines**. \n- **Optimization**: Place the `sync_pipe` and `host_uid` near the top of the struct (Line 1) to ensure the child process fetches the most critical \"startup\" variables in a single burst from L3 cache to L1.\n\n---\n\n## 5. INTERFACE CONTRACTS\n\n### 5.1 `int proc_write(pid_t pid, const char* file, const char* content)`\n- **Logic**: `open(\"/proc/<pid>/<file>\", O_WRONLY)`, `write()`, `close()`.\n- **Constraint**: Must use a **single write()** call. The kernel's `proc_set_id_map` handler rejects partial or multi-stage writes to these specific files.\n- **Error**: Returns `EPERM` if the mapping has already been written.\n\n### 5.2 `int write_uid_gid_maps(pid_t pid, uid_t host_uid, gid_t host_gid)`\n- **Mandatory Order**:\n    1. Write `\"0 <host_uid> 1\"` to `uid_map`.\n    2. Write `\"deny\"` to `setgroups`.\n    3. Write `\"0 <host_gid> 1\"` to `gid_map`.\n- **Failure**: If step 2 is skipped, step 3 returns `EPERM` for unprivileged users.\n\n### 5.3 `void verify_capabilities(void)`\n- **Logic**: Call `syscall(SYS_capget, &hdr, &data)`.\n- **Verification**: Ensure `(data[0].effective & (1 << CAP_SYS_ADMIN))` is true.\n\n---\n\n## 6. ALGORITHM SPECIFICATION: THE ROOTLESS HANDSHAKE\n\n1.  **Main (Host)**: Call `getuid()` and `getgid()` to capture the unprivileged identity.\n2.  **Main (Host)**: Call `clone(CLONE_NEWUSER | CLONE_NEWPID | ...)` without `sudo`.\n3.  **Child (Container)**: Enters `container_init`, calls `read(sync_pipe)` and **blocks**. Its effective UID is `65534` (nobody) and its capability set is empty.\n4.  **Main (Host)**: \n    - Writes `uid_map` (0 inside -> 1000 outside).\n    - Writes `setgroups=deny`.\n    - Writes `gid_map` (0 inside -> 1000 outside).\n    - *Note*: Atomic with the `gid_map` write completion, the kernel **elevates** the child's capability set to full effective privileges.\n5.  **Main (Host)**: Attempts `cgroup_setup`. \n    - *Edge Case*: If host-root or delegation isn't present, this fails. Log warning and continue (Resource limits are best-effort in rootless).\n6.  **Main (Host)**: `write(sync_pipe, \"1\")`.\n7.  **Child (Container)**: Unblocks. `getuid()` now returns `0`. Full capabilities are active. Proceed to `pivot_root`.\n\n\n![UID/GID Mapping ‚Äî Inside vs Outside Translation Table](./diagrams/tdd-diag-28.svg)\n (The Unprivileged Mapping Protocol)\n\n---\n\n## 7. ERROR HANDLING MATRIX\n\n| Error | Detected By | Recovery | User-Visible? |\n| :--- | :--- | :--- | :--- |\n| `EPERM` on `clone` | `main` | `sysctl -w kernel.unprivileged_userns_clone=1`. | Yes |\n| `EPERM` on `gid_map` | `proc_write` | Fix ordering (write `setgroups=deny` first). | Yes |\n| `UID 65534` in Child | `container_init` | Host failed to write maps before signaling. | Yes |\n| `EACCES` on `cgroups` | `main` | Skip cgroups or use `systemd-run`. | Yes (Warning) |\n| `ENOENT` on `uid_map` | `proc_write` | Child exited prematurely. | No |\n\n---\n\n## 8. IMPLEMENTATION SEQUENCE WITH CHECKPOINTS\n\n### Phase 1: The Helper (1 hour)\n- Implement `proc_write`. Use `O_WRONLY` and a single `write()` call.\n- Implement `write_uid_gid_maps` with the strict `uid -> setgroups -> gid` sequence.\n- **Checkpoint**: Standalone test that forks a child, writes a mapping, and the child prints `getuid() == 0`.\n\n### Phase 2: Rootless Clone (0.5 hours)\n- Update `clone()` flags to include `CLONE_NEWUSER`.\n- Remove the `geteuid() == 0` check from your runtime.\n- **Checkpoint**: Run without `sudo`. Syscall should succeed, but child will block on the sync pipe.\n\n### Phase 3: Synchronized Elevation (1 hour)\n- Integrate the map-writing logic into `main.c` immediately after `clone`.\n- **Checkpoint**: Inside the container, `id` command should report `uid=0(root)`. Host `ps aux` should report the same process as your unprivileged user.\n\n### Phase 4: Capability Verification (1 hour)\n- Implement `verify_capabilities` using raw `syscall(SYS_capget, ...)`.\n- Check bits 21 (`CAP_SYS_ADMIN`) and 12 (`CAP_NET_ADMIN`).\n- **Checkpoint**: Container log should print `CAP_SYS_ADMIN: YES`.\n\n### Phase 5: Filesystem & Network Integration (1 hour)\n- Run the full suite (mount, network, pivot).\n- **Note**: `veth` creation will still fail without `sudo`.\n- **Checkpoint**: Container should successfully `pivot_root` (proving `CAP_SYS_ADMIN` in userns) but fail network setup (proving lack of global `CAP_NET_ADMIN`).\n\n---\n\n## 9. TEST SPECIFICATION\n\n### 9.1 Test: UID Mapping Verification\n- **Inside**: `whoami` -> `root`.\n- **Outside**: `ps -p <pid> -o user` -> `<your_username>`.\n- **Requirement**: Mapping `0 -> 1000` is verified.\n\n### 9.2 Test: Capability Scoping (Negative Test)\n- **Inside**: `mount /dev/sda1 /mnt`.\n- **Requirement**: Must return `EPERM`. Even though the container has `CAP_SYS_ADMIN` in its userns, it does NOT have it in the initial userns required to mount physical block devices.\n\n### 9.3 Test: Rootless Mount\n- **Inside**: `mount -t tmpfs tmpfs /tmp`.\n- **Requirement**: Must succeed. The userns grants rights to its own mount namespace.\n\n---\n\n## 10. PERFORMANCE TARGETS\n\n| Operation | Target | Measurement |\n| :--- | :--- | :--- |\n| `clone(CLONE_NEWUSER)` | < 100 Œºs | Time to allocate `user_namespace`. |\n| Map Write Latency | < 30 Œºs | Parent-side latency to elevate child. |\n| UID translation | < 10 ns | Per-access overhead in VFS lookup. |\n| Config Struct Size | 120 Bytes | `sizeof(ContainerConfig)`. |\n\n---\n\n## 11. CONCURRENCY SPECIFICATION\n\n**Parent-Child Sync Invariants:**\n1.  **No self-mapping**: The child cannot write its own `uid_map`.\n2.  **Atomic Capability Elevation**: The kernel raises the child's caps the instant the map files are closed by the parent.\n3.  **Single Writer**: Exactly one process (the parent) writes to `/proc/<pid>/uid_map`. Any second attempt (even from a monitor thread) returns `EPERM`.\n\n---\n\n## 12. WIRE FORMAT: /proc/<pid>/uid_map\nThe map content must be a space-separated string.\n\n```c\n// Correct Format: \"inside_uid outside_uid count\\n\"\nchar buf[32];\nsnprintf(buf, sizeof(buf), \"0 %d 1\\n\", host_uid);\n// Result: \"0 1000 1\\n\"\n```\n<!-- END_TDD_MOD -->\n\n\n# Project Structure: Container (Basic)\n\n## Directory Tree\n\n```\ncontainer-basic/\n‚îú‚îÄ‚îÄ src/                    # Core source files\n‚îÇ   ‚îú‚îÄ‚îÄ common.h            # Shared macros, includes, and error wrappers (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ container.h         # ContainerConfig struct and function prototypes (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ main.c              # Host-side orchestration, clone(), and cleanup (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ init.c              # Container PID 1 entry point and setup sequence (M1-M5)\n‚îÇ   ‚îú‚îÄ‚îÄ reaper.c            # Zombie process collection and orphan management (M1)\n‚îÇ   ‚îú‚îÄ‚îÄ filesystem.c        # Mount propagation, pivot_root, and pseudo-fs logic (M2)\n‚îÇ   ‚îú‚îÄ‚îÄ net_host.c          # Host-side bridge, veth, and NAT/iptables setup (M3)\n‚îÇ   ‚îú‚îÄ‚îÄ net_container.c     # Child-side interface activation and routing (M3)\n‚îÇ   ‚îú‚îÄ‚îÄ cgroup.h            # Cgroup abstraction layer and type definitions (M4)\n‚îÇ   ‚îú‚îÄ‚îÄ cg_utils.c          # Low-level cgroup filesystem (read/write) helpers (M4)\n‚îÇ   ‚îú‚îÄ‚îÄ cg_v1.c             # Legacy Cgroups v1 implementation (M4)\n‚îÇ   ‚îú‚îÄ‚îÄ cg_v2.c             # Modern Unified Cgroups v2 implementation (M4)\n‚îÇ   ‚îî‚îÄ‚îÄ userns.c            # UID/GID mapping and capability verification (M5)\n‚îú‚îÄ‚îÄ tests/                  # Validation and stress tests\n‚îÇ   ‚îú‚îÄ‚îÄ stress_mem.c        # Triggers OOM killer for cgroup verification (M4)\n‚îÇ   ‚îî‚îÄ‚îÄ stress_cpu.c        # Verifies CFS throttling via tight loops (M4)\n‚îú‚îÄ‚îÄ Makefile                # Build system (standard C compilation)\n‚îú‚îÄ‚îÄ .gitignore              # Ignores build/ and binary artifacts\n‚îî‚îÄ‚îÄ README.md               # Project setup and usage instructions\n```\n\n## Creation Order\n\n1.  **Skeleton & PID Isolation (M1)**\n    *   `src/common.h`, `src/container.h`\n    *   `src/reaper.c`: Implement zombie reaping.\n    *   `src/init.c`: Implement `container_init` with basic PID check.\n    *   `src/main.c`: Implement stack allocation and `clone()` with `CLONE_NEWPID | CLONE_NEWUTS`.\n\n2.  **Filesystem Isolation (M2)**\n    *   `src/filesystem.c`: Implement `set_mounts_private`, `do_pivot_root`, and `mount_pseudofs`.\n    *   Update `src/init.c` to call the pivot sequence.\n    *   Update `src/main.c` to accept a rootfs argument and use `CLONE_NEWNS`.\n\n3.  **Networking Layer (M3)**\n    *   `src/net_host.c`: Implement bridge and veth pair creation.\n    *   `src/net_container.c`: Implement child interface/route setup.\n    *   Update `src/main.c` to create the synchronization pipe and configure the host network.\n    *   Update `src/init.c` to block on the pipe and call `setup_container_network`.\n\n4.  **Resource Constraints (M4)**\n    *   `src/cgroup.h`, `src/cg_utils.c`.\n    *   `src/cg_v1.c` and `src/cg_v2.c`: Implement version-specific limit writing.\n    *   `tests/stress_mem.c`, `tests/stress_cpu.c`: Create test binaries.\n    *   Update `src/main.c` to apply cgroup limits before unblocking the child.\n\n5.  **Rootless Execution (M5)**\n    *   `src/userns.c`: Implement `write_uid_gid_maps` and capability checks.\n    *   Update `src/main.c` to use `CLONE_NEWUSER`, capture host UIDs, and write maps.\n    *   Update `src/init.c` to verify `UID 0` status after unblocking.\n\n## File Count Summary\n- **Total files**: 15 (13 `.c`/`.h`, 1 `Makefile`, 1 `README.md`)\n- **Directories**: 2 (`src/`, `tests/`)\n- **Estimated lines of code**: ~1,200 - 1,500 lines of C.\n"}