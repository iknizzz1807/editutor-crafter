{"html":"<h1 id=\"container-runtime-design-document\">Container Runtime: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a minimal container runtime that provides process isolation using Linux namespaces, resource control through cgroups, and layered filesystem support via overlayfs. The key architectural challenge is orchestrating multiple kernel isolation mechanisms while maintaining clean abstractions and handling complex failure modes across namespace boundaries.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section provides foundational understanding for all milestones, establishing the conceptual framework for process isolation, resource control, and filesystem layering.</p>\n</blockquote>\n<p>Modern software deployment relies heavily on containerization, yet many developers treat containers as black boxes—they understand how to use Docker commands but lack insight into the fundamental isolation mechanisms that make containers possible. Building a container runtime from scratch reveals the elegant interplay between Linux kernel features: namespaces for process isolation, cgroups for resource control, and overlay filesystems for efficient image layering. This educational journey transforms abstract concepts like &quot;process isolation&quot; into concrete understanding of system calls, kernel interfaces, and the intricate choreography required to create truly isolated execution environments.</p>\n<p>The core challenge in container runtime design lies not in any single isolation mechanism, but in orchestrating multiple kernel subsystems to work together harmoniously. A container must simultaneously exist in its own process tree (PID namespace), have its own filesystem view (mount namespace), control its resource consumption (cgroups), and maintain network connectivity (network namespace)—all while appearing to be a normal process from the host&#39;s perspective. This coordination requires deep understanding of Linux kernel interfaces, careful error handling across subsystem boundaries, and robust cleanup procedures when things go wrong.</p>\n<h3 id=\"mental-model-apartments-in-a-building\">Mental Model: Apartments in a Building</h3>\n<p>Before diving into technical details, consider this mental model: <strong>containers are like apartments in a large apartment building, where each apartment provides complete living isolation while sharing the building&#39;s infrastructure</strong>.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"Container Runtime System Architecture\"></p>\n<p>In this apartment building analogy:</p>\n<p><strong>The Building (Host System)</strong> represents the physical machine running Linux. The building provides shared infrastructure: electricity (CPU), water and heating (memory and I/O), structural support (kernel), and external connectivity (network). All apartments rely on this shared foundation, but each apartment gets its own allocated portion of these resources.</p>\n<p><strong>Individual Apartments (Containers)</strong> are completely isolated living spaces. From inside apartment 3B, you cannot see into apartment 2A&#39;s living room, rummage through their belongings, or use up all the hot water and leave them with cold showers. Each apartment has its own address (IP address), its own thermostat controls (resource limits), and its own locked door (security boundaries). The residents of apartment 3B might not even know that apartment 2A exists—they see their apartment as if it were a standalone house.</p>\n<p><strong>The Building Management (Runtime Manager)</strong> handles apartment lifecycle: creating new apartments when tenants move in, setting up utilities connections, enforcing building rules about noise and resource usage, handling maintenance requests, and cleaning up when tenants move out. Management also handles the complex coordination between different building systems—ensuring the electrical system, plumbing, HVAC, and security all work together for each apartment.</p>\n<p><strong>Utility Connections (Namespaces)</strong> provide each apartment with isolated access to building services. Each apartment gets its own electrical meter (PID namespace), its own water pressure (mount namespace), its own mail delivery (network namespace), and its own thermostat zone (UTS namespace). These systems are carefully isolated—a power surge in apartment 2A doesn&#39;t affect apartment 3B&#39;s electricity, and a plumbing leak in 3B doesn&#39;t contaminate 2A&#39;s water supply.</p>\n<p><strong>Resource Allocation (Cgroups)</strong> ensures fair sharing of building resources. Management enforces rules: apartment 2A gets 30% of the building&#39;s heating capacity, apartment 3B gets 40% of the available hot water, and no single apartment can use more than 25% of the total electrical capacity. When apartment 2A tries to exceed its heating allowance, the system automatically regulates their usage rather than letting them freeze out their neighbors.</p>\n<p><strong>Shared Infrastructure Layers (Overlay Filesystem)</strong> allow apartments to share common elements efficiently while maintaining isolation. All apartments share the same basic floor plan and fixtures (base image layers), but each apartment can customize their space with their own furniture and decorations (writable layer). When a tenant in 3B paints their walls red, it doesn&#39;t affect the walls in 2A—each apartment&#39;s customizations exist in their own layer.</p>\n<blockquote>\n<p>The key insight is that <strong>isolation is not about physical separation—it&#39;s about controlled sharing</strong>. Apartments share the same building, electrical grid, and water supply, but each apartment gets its own controlled interface to these shared resources.</p>\n</blockquote>\n<p>This mental model illuminates the fundamental challenge of container runtime design: orchestrating multiple isolation mechanisms (utility connections, resource allocation, space management) to create the illusion of independent environments while efficiently sharing underlying infrastructure. Just as building management must coordinate electricians, plumbers, HVAC technicians, and security to make apartments work, a container runtime must coordinate namespace creation, cgroup configuration, filesystem mounting, and network setup to make containers work.</p>\n<h3 id=\"existing-container-runtime-approaches\">Existing Container Runtime Approaches</h3>\n<p>Understanding the design space of container runtimes requires examining how different implementations approach the fundamental challenges of process isolation, resource control, and filesystem management. Each runtime makes different trade-offs between simplicity, performance, security, and feature richness, providing valuable insights into architectural decisions we&#39;ll face in our own implementation.</p>\n<blockquote>\n<p><strong>Decision: Runtime Architecture Comparison</strong></p>\n<ul>\n<li><strong>Context</strong>: Container runtimes exist at different abstraction levels, from low-level kernel interface wrappers to high-level developer platforms. Understanding this landscape helps us position our educational runtime and learn from proven approaches.</li>\n<li><strong>Options Considered</strong>: Build using existing runtime as foundation, implement OCI-compatible runtime, create minimal educational runtime</li>\n<li><strong>Decision</strong>: Create minimal educational runtime that implements core concepts directly</li>\n<li><strong>Rationale</strong>: Direct implementation of kernel interfaces maximizes learning value by exposing all underlying mechanisms without abstraction layers hiding the complexity</li>\n<li><strong>Consequences</strong>: Higher implementation effort but deeper understanding of fundamental isolation primitives and their interactions</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Runtime</th>\n<th>Architecture Level</th>\n<th>Primary Focus</th>\n<th>Implementation Language</th>\n<th>Key Design Philosophy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Docker</td>\n<td>High-level Platform</td>\n<td>Developer Experience</td>\n<td>Go</td>\n<td>Integrated toolchain with registry, build system, and runtime</td>\n</tr>\n<tr>\n<td>containerd</td>\n<td>Mid-level Daemon</td>\n<td>Industry Standard</td>\n<td>Go</td>\n<td>Modular architecture with pluggable components</td>\n</tr>\n<tr>\n<td>runc</td>\n<td>Low-level Runtime</td>\n<td>OCI Compliance</td>\n<td>Go</td>\n<td>Minimal implementation of OCI runtime specification</td>\n</tr>\n<tr>\n<td>crun</td>\n<td>Low-level Runtime</td>\n<td>Performance</td>\n<td>C</td>\n<td>Fast startup times with lower memory overhead</td>\n</tr>\n<tr>\n<td>kata-containers</td>\n<td>High-security Runtime</td>\n<td>Hardware Isolation</td>\n<td>Rust/Go</td>\n<td>VM-based containers for enhanced security boundaries</td>\n</tr>\n</tbody></table>\n<p><strong>Docker: Integrated Developer Platform</strong></p>\n<p>Docker pioneered the modern container experience by providing a complete developer toolchain that abstracts away kernel complexity. The Docker architecture consists of multiple layers: the Docker CLI communicates with the Docker daemon, which manages container lifecycles by delegating to containerd, which in turn uses runc for actual container creation. This layered approach prioritizes developer experience—running <code>docker run nginx</code> hides the complexity of namespace creation, cgroup configuration, and overlay filesystem mounting behind a simple command.</p>\n<p>The Docker approach teaches us that <strong>developer experience often requires architectural complexity</strong>. Docker&#39;s multi-daemon architecture (dockerd → containerd → runc) introduces latency and resource overhead but provides features like image building, registry integration, volume management, and networking that developers expect. For our educational runtime, we&#39;ll implement these kernel interfaces directly rather than layering abstractions, maximizing learning value even at the cost of developer convenience.</p>\n<p><strong>containerd: Modular Industry Standard</strong></p>\n<p>containerd represents the industry&#39;s attempt to create a standard, modular container runtime that can serve as a foundation for higher-level tools. Originally extracted from Docker, containerd focuses on the core container lifecycle: image management, container execution, storage management, and network attachment. It provides a gRPC API that tools like Docker and Kubernetes use for container operations.</p>\n<p>containerd&#39;s architecture demonstrates <strong>separation of concerns through well-defined interfaces</strong>. The containerd daemon manages container metadata and coordinates between specialized subsystems: the image store handles layer management, the snapshotter manages filesystem layers, the runtime manager handles container execution, and the network plugins handle connectivity. Each subsystem can be replaced or extended without affecting others.</p>\n<p>Our educational runtime will adopt containerd&#39;s principle of component separation while implementing everything in a single process to avoid the complexity of inter-process communication during the learning phase.</p>\n<p><strong>runc: OCI-Compliant Minimal Runtime</strong></p>\n<p>runc implements the Open Container Initiative (OCI) runtime specification, providing the lowest-level container execution without daemon overhead. It takes a JSON configuration file describing desired container properties (namespaces, cgroups, filesystem mounts, process arguments) and executes the specified process in an isolated environment. runc demonstrates that container creation can be reduced to a deterministic sequence of system calls.</p>\n<p>The runc approach reveals that <strong>containers are just processes with fancy isolation</strong>. When you execute <code>runc run container-id</code>, runc performs this sequence: creates namespaces via clone() system call, sets up cgroup limits, mounts the overlay filesystem, configures networking interfaces, and finally execv() the target process. The target process becomes PID 1 in its own PID namespace, completely unaware that it&#39;s running in a container.</p>\n<p>Our implementation will follow runc&#39;s principle of deterministic container creation while exposing each step explicitly for educational purposes rather than hiding them behind a configuration file.</p>\n<p><strong>crun: Performance-Optimized Runtime</strong></p>\n<p>crun reimplements the OCI runtime specification in C rather than Go, achieving significantly faster container startup times and lower memory overhead. This design choice illustrates the performance trade-offs inherent in container runtime implementation. Go&#39;s garbage collector and higher-level abstractions provide development productivity but introduce latency that becomes significant when orchestrators like Kubernetes start thousands of containers per minute.</p>\n<p>crun&#39;s performance focus teaches us that <strong>system call overhead dominates container creation performance</strong>. The fundamental operations—namespace creation, cgroup setup, filesystem mounting—involve expensive kernel transitions. Optimizing these operations requires careful attention to system call batching, memory allocation patterns, and avoiding unnecessary filesystem operations.</p>\n<p>For our educational runtime, we&#39;ll prioritize code clarity over performance optimization, but understanding these trade-offs helps explain why production runtimes make certain architectural choices.</p>\n<p><strong>Container Runtime Interface (CRI) Integration</strong></p>\n<p>Modern container runtimes must integrate with orchestration systems like Kubernetes through the Container Runtime Interface (CRI). CRI defines a gRPC API that Kubernetes uses to manage container lifecycles: <code>RunPodSandbox</code> creates isolated environments, <code>CreateContainer</code> prepares container specifications, <code>StartContainer</code> begins process execution, and <code>StopContainer</code> terminates processes cleanly.</p>\n<table>\n<thead>\n<tr>\n<th>CRI Operation</th>\n<th>Runtime Responsibilities</th>\n<th>Kernel Interfaces Used</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RunPodSandbox</td>\n<td>Create shared namespace environment for pod containers</td>\n<td>clone() with namespace flags, mount() for shared volumes</td>\n</tr>\n<tr>\n<td>CreateContainer</td>\n<td>Prepare container filesystem and configuration</td>\n<td>mount() for overlayfs, cgroup filesystem writes</td>\n</tr>\n<tr>\n<td>StartContainer</td>\n<td>Execute container process in isolated environment</td>\n<td>execve() after namespace/cgroup setup</td>\n</tr>\n<tr>\n<td>StopContainer</td>\n<td>Terminate process and cleanup resources</td>\n<td>kill() signal delivery, umount(), cgroup cleanup</td>\n</tr>\n<tr>\n<td>RemoveContainer</td>\n<td>Clean up container metadata and temporary files</td>\n<td>filesystem cleanup, cgroup removal</td>\n</tr>\n</tbody></table>\n<p>Understanding CRI integration reveals that <strong>container runtimes are ultimately process lifecycle managers</strong>. They coordinate kernel isolation mechanisms to create the illusion of independent machines while providing APIs that higher-level tools can use programmatically.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: All container runtimes, regardless of their high-level architecture, ultimately perform the same fundamental operations: process isolation through namespaces, resource control through cgroups, filesystem layering through overlay mounts, and network connectivity through virtual interfaces. The differences lie in how they package these operations, what additional features they provide, and how they balance performance, security, and usability trade-offs.</p>\n</blockquote>\n<p>Our educational runtime will implement these core operations directly, providing deep understanding of the kernel interfaces that production runtimes build upon. By understanding these fundamentals, developers gain the knowledge needed to debug container issues, optimize containerized applications, and make informed decisions about runtime selection in production environments.</p>\n<p>The journey from understanding container concepts to implementing kernel interfaces reveals why containerization became so transformative: it provides process isolation and resource control that previously required separate virtual machines, but with much lower overhead and faster startup times. This efficiency comes from clever use of Linux kernel features that already existed—containers didn&#39;t require new kernel functionality, just creative orchestration of existing isolation primitives.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides concrete technology choices and starter code to begin building your container runtime while focusing learning effort on the core isolation mechanisms rather than peripheral infrastructure.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Our Choice</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP API</td>\n<td>Standard library net/http with JSON</td>\n<td>gRPC with Protocol Buffers</td>\n<td>Standard library (learning focus)</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON files with encoding/json</td>\n<td>YAML with third-party parser</td>\n<td>JSON (minimal dependencies)</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard library log package</td>\n<td>Structured logging (logrus/zap)</td>\n<td>Standard library (simplicity)</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td>os/exec with direct system calls</td>\n<td>Third-party process libraries</td>\n<td>os/exec + unix package (direct kernel access)</td>\n</tr>\n<tr>\n<td>Filesystem Operations</td>\n<td>Standard library os and filepath</td>\n<td>Third-party filesystem abstractions</td>\n<td>Standard library (transparency)</td>\n</tr>\n<tr>\n<td>Network Configuration</td>\n<td>Direct netlink system calls</td>\n<td>Third-party network libraries</td>\n<td>golang.org/x/sys/unix (learning kernel interfaces)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-runtime/\n├── cmd/\n│   ├── runtime/\n│   │   └── main.go                    ← CLI entry point\n│   └── daemon/\n│       └── main.go                    ← Daemon mode entry point\n├── internal/\n│   ├── runtime/\n│   │   ├── manager.go                 ← Runtime Manager (orchestrates components)\n│   │   ├── container.go               ← Container specification and state\n│   │   └── manager_test.go\n│   ├── namespace/\n│   │   ├── namespace.go               ← Namespace Handler component\n│   │   ├── mount.go                   ← Mount namespace operations\n│   │   ├── pid.go                     ← PID namespace operations\n│   │   └── namespace_test.go\n│   ├── cgroup/\n│   │   ├── controller.go              ← Cgroup Controller component\n│   │   ├── memory.go                  ← Memory controller operations\n│   │   ├── cpu.go                     ← CPU controller operations\n│   │   └── controller_test.go\n│   ├── filesystem/\n│   │   ├── overlay.go                 ← Filesystem Manager component\n│   │   ├── layers.go                  ← Layer management operations\n│   │   └── overlay_test.go\n│   ├── network/\n│   │   ├── manager.go                 ← Network Manager component\n│   │   ├── bridge.go                  ← Bridge networking setup\n│   │   ├── veth.go                    ← Virtual ethernet operations\n│   │   └── manager_test.go\n│   └── utils/\n│       ├── syscalls.go                ← System call wrappers\n│       └── paths.go                   ← Path utilities\n├── pkg/\n│   └── api/\n│       ├── types.go                   ← Public API types\n│       └── client.go                  ← Client library\n├── configs/\n│   └── runtime.json                   ← Default configuration\n├── scripts/\n│   ├── setup-cgroups.sh             ← System setup helpers\n│   └── cleanup-test-env.sh           ← Test cleanup utilities\n└── docs/\n    ├── design/\n    └── examples/</code></pre></div>\n\n<p><strong>Infrastructure Starter Code:</strong></p>\n<p>Since our focus is learning container runtime concepts rather than building JSON parsers or HTTP servers, here&#39;s complete starter code for peripheral infrastructure:</p>\n<p><strong>Configuration Management (<code>internal/runtime/container.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerSpec defines what a container should look like</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"image\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Command     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"command\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Environment </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"environment\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"working_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Memory      </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">    `json:\"memory\"`</span><span style=\"color:#6A737D\">        // bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUShares   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">    `json:\"cpu_shares\"`</span><span style=\"color:#6A737D\">    // relative weight</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUQuota    </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">    `json:\"cpu_quota\"`</span><span style=\"color:#6A737D\">     // microseconds per period</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Networking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkMode </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"network_mode\"`</span><span style=\"color:#6A737D\">  // \"bridge\", \"host\", \"none\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `json:\"port_mappings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostPort      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"host_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"container_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Protocol      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"protocol\"`</span><span style=\"color:#6A737D\">  // \"tcp\" or \"udp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerState tracks runtime information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"status\"`</span><span style=\"color:#6A737D\">  // \"created\", \"running\", \"stopped\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PID         </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"pid\"`</span><span style=\"color:#6A737D\">     // container process PID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExitCode    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"exit_code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource handles for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NamespacePath </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"namespace_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CgroupPath    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"cgroup_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OverlayPath   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"overlay_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkNS     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"network_ns\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadContainerSpec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(path)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> spec </span><span style=\"color:#B392F0\">ContainerSpec</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">spec); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">spec, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SaveToFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">MarshalIndent</span><span style=\"color:#E1E4E8\">(s, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"  \"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(path, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>System Call Utilities (<code>internal/utils/syscalls.go</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> utils</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">unsafe</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NamespaceType represents different Linux namespace types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NamespaceType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLONE_NEWPID</span><span style=\"color:#F97583\">   =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">20000000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLONE_NEWNS</span><span style=\"color:#F97583\">    =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">00020000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLONE_NEWNET</span><span style=\"color:#F97583\">   =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">40000000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLONE_NEWUTS</span><span style=\"color:#F97583\">   =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">04000000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLONE_NEWIPC</span><span style=\"color:#F97583\">   =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">08000000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CLONE_NEWUSER</span><span style=\"color:#F97583\">  =</span><span style=\"color:#F97583\"> 0x</span><span style=\"color:#79B8FF\">10000000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateNamespaces creates new namespaces for container isolation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CreateNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">namespaces</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> flags </span><span style=\"color:#F97583\">uintptr</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, ns </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> namespaces {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#F97583\"> uintptr</span><span style=\"color:#E1E4E8\">(ns)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, _, errno </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">RawSyscall</span><span style=\"color:#E1E4E8\">(syscall.SYS_UNSHARE, flags, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errno </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unshare failed: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, errno)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MountOverlayFS mounts overlayfs with specified layers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> MountOverlayFS</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">lowerDirs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">upperDir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">workDir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build overlay mount options</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lowers </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, dir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> lowerDirs {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lowers </span><span style=\"color:#F97583\">+=</span><span style=\"color:#9ECBFF\"> \":\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lowers </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> dir</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    options </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"lowerdir=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">,upperdir=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">,workdir=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          lowers, upperDir, workDir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> syscall.</span><span style=\"color:#B392F0\">Mount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"overlay\"</span><span style=\"color:#E1E4E8\">, target, </span><span style=\"color:#9ECBFF\">\"overlay\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, options)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteToFile is a helper for writing to cgroup control files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WriteToFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(path, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(value), </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EnsureDir creates directory if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> EnsureDir</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(path, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton:</strong></p>\n<p>For the main Runtime Manager, provide skeleton with detailed TODOs mapping to the design concepts:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager orchestrates all container runtime components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerStore </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupRoot     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overlayRoot    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bridgeName     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupRoot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">overlayRoot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bridgeName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        containerStore: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cgroupRoot:     cgroupRoot,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        overlayRoot:    overlayRoot,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bridgeName:     bridgeName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainer sets up container environment without starting process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container specification (check required fields, resource limits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create container state directory structure under /var/lib/container-runtime/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up overlay filesystem layers (lower dirs from image, upper dir for container)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create cgroup hierarchy for container resource control</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Prepare network namespace (create veth pair, attach to bridge)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Save container state to persistent storage for later operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Don't start the container process yet - that's StartContainer's job</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartContainer begins execution of container process in isolated environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container state and validate it's in \"created\" status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Clone new process with namespace isolation flags (CLONE_NEWPID, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: In child process: pivot to new root filesystem, mount /proc, setup environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: In child process: join container cgroup, drop to non-root user if specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: In child process: exec the container command (this replaces clone child)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: In parent process: update container state to \"running\", save PID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use cmd.SysProcAttr to set namespace clone flags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StopContainer terminates container process and performs cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find container state and validate it's running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send SIGTERM to container process, wait for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If process doesn't exit in 10 seconds, send SIGKILL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for process to exit and capture exit code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update container state to \"stopped\" with exit code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clean up temporary resources (but keep overlay layers for restart)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveContainer performs full cleanup of stopped container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify container is stopped (not running)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Unmount overlay filesystem layers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove cgroup directory (this also kills any remaining processes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Clean up network namespace and veth interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove container state directory and all associated files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Remove container from in-memory store</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<p><strong>Go System Call Interface:</strong></p>\n<ul>\n<li>Use <code>golang.org/x/sys/unix</code> package for low-level system calls rather than the standard <code>syscall</code> package</li>\n<li>Container process creation requires <code>exec.Cmd</code> with <code>SysProcAttr.Cloneflags</code> set to namespace flags</li>\n<li>File descriptor handling: always defer close() calls and check for errors</li>\n<li>Cgroup operations are just filesystem writes to <code>/sys/fs/cgroup/</code> - no special API needed</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Wrap system call errors with context: <code>fmt.Errorf(&quot;failed to mount overlay: %w&quot;, err)</code></li>\n<li>For cleanup operations, continue cleanup even if individual steps fail, but accumulate errors</li>\n<li>Use <code>defer</code> functions for resource cleanup, but handle errors explicitly</li>\n</ul>\n<p><strong>Concurrency Considerations:</strong></p>\n<ul>\n<li>Container operations can be concurrent, but individual container state changes should be atomic</li>\n<li>Use <code>sync.Mutex</code> to protect the container store map from concurrent access</li>\n<li>Child processes inherit parent&#39;s file descriptors - be careful about resource leaks</li>\n</ul>\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After implementing each component, verify functionality with these concrete tests:</p>\n<p><strong>Milestone 1 Checkpoint (Namespaces):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test PID namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --spec</span><span style=\"color:#9ECBFF\"> examples/busybox.json</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/runtime/main.go</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> busybox-test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container, 'ps aux' should show only container processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Container PID 1 should be your container command, not init</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test mount namespace isolation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container, 'mount' should show only container mounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Host filesystem should not be visible except through overlay</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint (Cgroups):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test memory limits</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> '{\"memory\": 134217728}'</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> test-config.json</span><span style=\"color:#6A737D\">  # 128MB limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --spec</span><span style=\"color:#9ECBFF\"> test-config.json</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify limit: cat /sys/fs/cgroup/container-test/memory.max should show 134217728</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test CPU limits  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run CPU-intensive process in container, verify it doesn't exceed quota</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Host 'top' should show container process respecting CPU limits</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint (Overlay Filesystem):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test copy-on-write behavior</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/runtime/main.go</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> test-container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container: echo \"test\" > /usr/local/test-file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># After container stops, base image should be unchanged</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check upper layer contains the new file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> /var/lib/container-runtime/overlay/test-container/upper/usr/local/</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint (Networking):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test container connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --network</span><span style=\"color:#9ECBFF\"> bridge</span><span style=\"color:#79B8FF\"> --ports</span><span style=\"color:#9ECBFF\"> 8080:80</span><span style=\"color:#9ECBFF\"> web-test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/runtime/main.go</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> web-test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Container should get IP address in bridge subnet</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Port 8080 on host should forward to port 80 in container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080</span><span style=\"color:#6A737D\">  # should reach container service</span></span></code></pre></div>\n\n<p><strong>Common Debugging Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Command</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Operation not permitted&quot; on namespace creation</td>\n<td>Missing CAP_SYS_ADMIN capability</td>\n<td><code>getcap $(which your-runtime)</code></td>\n<td>Run with sudo or set capabilities</td>\n</tr>\n<tr>\n<td>Container sees host processes</td>\n<td>PID namespace not created properly</td>\n<td><code>ls -la /proc/self/ns/pid</code> in container</td>\n<td>Check clone flags include CLONE_NEWPID</td>\n</tr>\n<tr>\n<td>&quot;No such file or directory&quot; after pivot_root</td>\n<td>New root is not a mount point</td>\n<td><code>mount | grep new_root</code></td>\n<td>Bind mount new root to itself first</td>\n</tr>\n<tr>\n<td>Overlay mount fails</td>\n<td>Work directory not empty</td>\n<td><code>ls -la workdir/</code></td>\n<td>Ensure work directory is empty before mount</td>\n</tr>\n<tr>\n<td>Network namespace setup fails</td>\n<td>Bridge interface doesn&#39;t exist</td>\n<td><code>ip link show docker0</code></td>\n<td>Create bridge interface first</td>\n</tr>\n<tr>\n<td>Container process becomes zombie</td>\n<td>Parent not reaping child</td>\n<td><code>ps aux | grep defunct</code></td>\n<td>Add proper signal handling and wait()</td>\n</tr>\n</tbody></table>\n<p>This implementation guidance provides working infrastructure code and detailed skeleton functions that map directly to the conceptual understanding built in the main design sections. Focus your learning effort on implementing the TODO sections rather than building peripheral infrastructure from scratch.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the scope and boundaries for all milestones (1-4), defining what capabilities our container runtime will implement and what advanced features are intentionally excluded.</p>\n</blockquote>\n<h3 id=\"mental-model-building-a-studio-apartment-vs-a-luxury-hotel\">Mental Model: Building a Studio Apartment vs. a Luxury Hotel</h3>\n<p>Think of our container runtime project like deciding between building a studio apartment versus a luxury hotel. A studio apartment has everything you need to live comfortably—a bed, kitchen, bathroom, and living space—but it doesn&#39;t have a concierge, room service, or a swimming pool. Similarly, our minimal container runtime will provide all the essential isolation and resource management features that make containers work, but we&#39;re deliberately excluding the complex operational features that production container platforms require.</p>\n<p>This analogy helps frame our decision-making: every feature request gets evaluated with &quot;Is this essential plumbing (like water and electricity in an apartment) or is this a luxury amenity (like a hotel spa)?&quot; Essential plumbing goes in; luxury amenities are explicitly excluded to keep the learning focused on core concepts.</p>\n<p>The key insight is that understanding how to build the studio apartment—the fundamental isolation primitives—gives you the knowledge to later understand how luxury hotels work. But trying to build the hotel first would overwhelm you with operational complexity before you understand why containers need isolation in the first place.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>Our container runtime will implement four core capabilities that demonstrate the fundamental mechanisms underlying all container systems. These align directly with our four milestones and represent the minimum viable functionality for process isolation, resource control, filesystem layering, and network connectivity.</p>\n<h4 id=\"process-isolation-through-namespaces\">Process Isolation Through Namespaces</h4>\n<p>The runtime will create isolated process environments using Linux namespaces, demonstrating how containers achieve the illusion of running on separate machines while sharing the same kernel. This capability forms the foundation of container security and process isolation.</p>\n<table>\n<thead>\n<tr>\n<th>Namespace Type</th>\n<th>Isolation Provided</th>\n<th>Implementation Goal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID</td>\n<td>Process ID space</td>\n<td>Container sees itself as PID 1, cannot see host processes</td>\n</tr>\n<tr>\n<td>Mount</td>\n<td>Filesystem view</td>\n<td>Container has isolated filesystem tree, cannot access host mounts</td>\n</tr>\n<tr>\n<td>Network</td>\n<td>Network interfaces and routing</td>\n<td>Container has private network stack with virtual interfaces</td>\n</tr>\n<tr>\n<td>UTS</td>\n<td>Hostname and domain name</td>\n<td>Container can set its own hostname without affecting host</td>\n</tr>\n<tr>\n<td>User</td>\n<td>User and group ID mapping</td>\n<td>Container processes run with mapped UIDs for security</td>\n</tr>\n<tr>\n<td>IPC</td>\n<td>Inter-process communication</td>\n<td>Container has isolated message queues and shared memory</td>\n</tr>\n</tbody></table>\n<p>The runtime will handle the complex namespace creation sequence, including proper ordering (user namespace must be created first), filesystem pivoting using <code>pivot_root</code>, and the critical <code>/proc</code> remounting that many container tutorials skip. This goal specifically targets understanding how processes can have completely different views of the same system resources.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> Process isolation is not about virtualization—it&#39;s about perspective. The same kernel and hardware serve multiple isolated views of system resources. Understanding this perspective-based isolation is crucial for grasping container security models.</p>\n</blockquote>\n<h4 id=\"resource-control-using-cgroups\">Resource Control Using Cgroups</h4>\n<p>The runtime will enforce CPU, memory, and I/O limits using cgroups v2, demonstrating how containers prevent resource starvation and ensure predictable performance. This capability shows how multi-tenant systems maintain isolation not just for security, but for performance and reliability.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Control Mechanism</th>\n<th>Enforcement Goal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory</td>\n<td><code>memory.max</code> hard limit</td>\n<td>Container killed if it exceeds allocated memory</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td><code>cpu.max</code> quota and period</td>\n<td>Container CPU time limited to specified percentage</td>\n</tr>\n<tr>\n<td>I/O</td>\n<td><code>io.max</code> bandwidth limits</td>\n<td>Container disk I/O throttled to prevent interference</td>\n</tr>\n<tr>\n<td>PIDs</td>\n<td><code>pids.max</code> process limit</td>\n<td>Container cannot fork-bomb the host system</td>\n</tr>\n</tbody></table>\n<p>The implementation will include resource usage monitoring through cgroup statistics files, graceful out-of-memory handling with configurable OOM behavior, and proper cgroup hierarchy management. This goal specifically targets understanding how the kernel enforces resource boundaries and how containers achieve predictable performance isolation.</p>\n<h4 id=\"filesystem-layering-with-overlayfs\">Filesystem Layering with OverlayFS</h4>\n<p>The runtime will implement copy-on-write filesystem semantics using overlayfs, demonstrating how container images achieve efficient storage and fast startup times. This capability shows how containers can share base images while maintaining isolated filesystem changes.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Foverlayfs-structure.svg\" alt=\"OverlayFS Layer Structure\"></p>\n<table>\n<thead>\n<tr>\n<th>Layer Type</th>\n<th>Purpose</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Base Image Layers</td>\n<td>Read-only image content</td>\n<td>Shared across containers, never modified</td>\n</tr>\n<tr>\n<td>Upper Layer</td>\n<td>Container modifications</td>\n<td>Captures all file changes during container lifetime</td>\n</tr>\n<tr>\n<td>Work Directory</td>\n<td>OverlayFS metadata</td>\n<td>Temporary space for overlay operations</td>\n</tr>\n<tr>\n<td>Merged View</td>\n<td>Combined filesystem</td>\n<td>What the container process sees as its root filesystem</td>\n</tr>\n</tbody></table>\n<p>The implementation will handle multiple image layer stacking, proper mount option configuration for overlayfs, and complete cleanup of overlay mounts and directories when containers are removed. This goal specifically targets understanding how modern container systems achieve both efficiency (shared layers) and isolation (private changes).</p>\n<h4 id=\"basic-container-networking\">Basic Container Networking</h4>\n<p>The runtime will provide network connectivity using bridge networking with port mapping, demonstrating how containers communicate with each other and the external world while maintaining network namespace isolation. This capability shows how containers achieve network isolation without sacrificing connectivity.</p>\n<table>\n<thead>\n<tr>\n<th>Network Component</th>\n<th>Function</th>\n<th>Implementation Goal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>veth Pair</td>\n<td>Container-to-host connection</td>\n<td>Virtual ethernet cable connecting container to host</td>\n</tr>\n<tr>\n<td>Bridge</td>\n<td>Inter-container networking</td>\n<td>Virtual switch allowing containers to communicate</td>\n</tr>\n<tr>\n<td>IP Assignment</td>\n<td>Container addressing</td>\n<td>Automatic IP allocation from configurable subnet</td>\n</tr>\n<tr>\n<td>Port Forwarding</td>\n<td>External access</td>\n<td>NAT rules mapping host ports to container services</td>\n</tr>\n<tr>\n<td>DNS Resolution</td>\n<td>Name resolution</td>\n<td>Configurable nameserver settings for container</td>\n</tr>\n</tbody></table>\n<p>The implementation will create and manage veth pairs, configure bridge networking for multi-container communication, implement port mapping using iptables NAT rules, and handle proper cleanup of network interfaces and rules. This goal specifically targets understanding how containers maintain network isolation while enabling controlled connectivity.</p>\n<blockquote>\n<p><strong>Architecture Decision: Bridge Networking Over Host Networking</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers need network connectivity while maintaining isolation from the host network stack</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Host networking (share host network namespace)</li>\n<li>Bridge networking (isolated namespace with virtual bridge)</li>\n<li>Overlay networking (software-defined networking across hosts)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Bridge networking with veth pairs</li>\n<li><strong>Rationale</strong>: Bridge networking provides the right balance of isolation and simplicity for educational purposes. Host networking sacrifices isolation (containers see all host network interfaces), while overlay networking introduces complex distributed systems concepts that distract from core container isolation mechanisms.</li>\n<li><strong>Consequences</strong>: Containers get network isolation and controlled connectivity, but we limit ourselves to single-host networking (no multi-host container communication).</li>\n</ul>\n</blockquote>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Understanding what we will <strong>not</strong> build is equally important for keeping the project focused on learning container fundamentals. These non-goals represent production-grade features that would significantly increase complexity without proportionally increasing understanding of core isolation mechanisms.</p>\n<h4 id=\"image-distribution-and-registry-management\">Image Distribution and Registry Management</h4>\n<p>We will <strong>not</strong> implement image pulling from remote registries, image caching, or image building capabilities. Our runtime will assume container images already exist as local directory structures or tar files that can be extracted locally.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Why Excluded</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Remote image pulling</td>\n<td>Requires HTTP clients, authentication, and error handling for network failures</td>\n<td>Distracts from isolation primitives with network programming</td>\n</tr>\n<tr>\n<td>Image caching</td>\n<td>Requires content-addressable storage and garbage collection</td>\n<td>Adds storage management complexity unrelated to containers</td>\n</tr>\n<tr>\n<td>Image building</td>\n<td>Requires Dockerfile parsing and build context management</td>\n<td>Separate problem domain from runtime execution</td>\n</tr>\n<tr>\n<td>Image signing/verification</td>\n<td>Requires cryptographic libraries and PKI understanding</td>\n<td>Security topic separate from isolation mechanisms</td>\n</tr>\n</tbody></table>\n<p>Students will create simple local images by preparing directory structures with the files they want in their container filesystem. This keeps the focus on how overlayfs combines layers rather than how images are distributed across networks.</p>\n<h4 id=\"container-orchestration-and-scheduling\">Container Orchestration and Scheduling</h4>\n<p>We will <strong>not</strong> implement multi-container coordination, service discovery, rolling updates, or cluster management. Our runtime manages individual containers in isolation without understanding relationships between containers.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Why Excluded</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Service discovery</td>\n<td>Requires distributed coordination and consensus algorithms</td>\n<td>Adds distributed systems complexity</td>\n</tr>\n<tr>\n<td>Load balancing</td>\n<td>Requires traffic routing and health checking</td>\n<td>Network management separate from isolation</td>\n</tr>\n<tr>\n<td>Rolling updates</td>\n<td>Requires deployment strategies and state management</td>\n<td>Operations concern, not isolation primitive</td>\n</tr>\n<tr>\n<td>Resource scheduling</td>\n<td>Requires cluster-wide resource tracking and optimization</td>\n<td>Distributed systems problem</td>\n</tr>\n</tbody></table>\n<p>Students will start containers individually and manage them through direct runtime commands. This keeps the focus on how a single container achieves isolation rather than how multiple containers work together in production systems.</p>\n<h4 id=\"production-grade-security-features\">Production-Grade Security Features</h4>\n<p>We will <strong>not</strong> implement advanced security policies, capability management, or mandatory access controls. Our runtime will use basic user namespace mapping but exclude enterprise security features.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Why Excluded</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SELinux/AppArmor integration</td>\n<td>Requires understanding mandatory access control systems</td>\n<td>Security specialization separate from container basics</td>\n</tr>\n<tr>\n<td>Seccomp filters</td>\n<td>Requires system call filtering and security policy languages</td>\n<td>Advanced security topic</td>\n</tr>\n<tr>\n<td>Capability management</td>\n<td>Requires deep Linux capability system knowledge</td>\n<td>Security detail that obscures main learning objectives</td>\n</tr>\n<tr>\n<td>Runtime security scanning</td>\n<td>Requires vulnerability databases and policy engines</td>\n<td>Operations security concern</td>\n</tr>\n</tbody></table>\n<p>Students will learn how user namespaces provide basic privilege separation, but advanced security policies are left for specialized security courses. This keeps the focus on how isolation works rather than how to secure it against sophisticated attacks.</p>\n<h4 id=\"advanced-networking-features\">Advanced Networking Features</h4>\n<p>We will <strong>not</strong> implement overlay networks, service meshes, or multi-host networking. Our networking will be limited to single-host bridge networking with basic port forwarding.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Why Excluded</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Overlay networks</td>\n<td>Requires distributed networking and tunnel management</td>\n<td>Network virtualization separate from container isolation</td>\n</tr>\n<tr>\n<td>Service mesh integration</td>\n<td>Requires sidecar proxy management and service discovery</td>\n<td>Microservices architecture concern</td>\n</tr>\n<tr>\n<td>CNI plugin support</td>\n<td>Requires plugin architecture and network policy management</td>\n<td>Standardization complexity</td>\n</tr>\n<tr>\n<td>Multi-host networking</td>\n<td>Requires cluster networking and distributed state</td>\n<td>Distributed systems problem</td>\n</tr>\n</tbody></table>\n<p>Students will connect containers through a simple bridge and access them through port forwarding. This demonstrates the core concept of network namespace isolation without the complexity of distributed networking.</p>\n<h4 id=\"performance-optimization-and-scalability\">Performance Optimization and Scalability</h4>\n<p>We will <strong>not</strong> optimize for high-performance container startup, massive container density, or enterprise-scale resource management. Our runtime prioritizes code clarity over performance optimization.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Why Excluded</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fast container startup</td>\n<td>Requires optimization techniques that obscure basic operations</td>\n<td>Performance engineering separate from learning isolation</td>\n</tr>\n<tr>\n<td>High container density</td>\n<td>Requires resource optimization and sharing strategies</td>\n<td>Production scalability concern</td>\n</tr>\n<tr>\n<td>Resource pooling</td>\n<td>Requires complex resource management and sharing algorithms</td>\n<td>Operations optimization</td>\n</tr>\n<tr>\n<td>Monitoring and metrics</td>\n<td>Requires metrics collection and time-series storage</td>\n<td>Observability tooling separate from core function</td>\n</tr>\n</tbody></table>\n<p>Students will focus on correctness and understanding rather than performance. A container that takes 2 seconds to start but clearly demonstrates namespace creation is better for learning than one that starts in 50ms but hides the setup complexity.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> Educational projects require ruthless scope discipline. Every feature that doesn&#39;t directly teach the core concepts is a potential distraction that prevents deep understanding of the fundamentals. Production systems need all these excluded features, but learning systems need focus.</p>\n</blockquote>\n<h4 id=\"backward-compatibility-and-standards-compliance\">Backward Compatibility and Standards Compliance</h4>\n<p>We will <strong>not</strong> implement full OCI (Open Container Initiative) compatibility, Docker API compatibility, or support for legacy container formats. Our runtime will use simple configuration formats optimized for learning rather than industry standards.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Why Excluded</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OCI runtime spec compliance</td>\n<td>Requires implementing complex specification details</td>\n<td>Standards compliance distracts from core concepts</td>\n</tr>\n<tr>\n<td>Docker API compatibility</td>\n<td>Requires REST API implementation and Docker protocol details</td>\n<td>API design separate from isolation mechanisms</td>\n</tr>\n<tr>\n<td>Legacy format support</td>\n<td>Requires supporting multiple image and config formats</td>\n<td>Backward compatibility complexity</td>\n</tr>\n<tr>\n<td>Standardized logging</td>\n<td>Requires structured logging and log driver architecture</td>\n<td>Operational tooling concern</td>\n</tr>\n</tbody></table>\n<p>Students will use simple JSON configuration files and direct command-line interaction with the runtime. This removes the cognitive load of learning industry specifications while focusing on the underlying isolation mechanisms that all standards ultimately implement.</p>\n<h3 id=\"success-criteria-and-validation\">Success Criteria and Validation</h3>\n<p>Our functional goals will be validated through specific behavioral tests that demonstrate successful isolation and resource control. These criteria define what &quot;working&quot; means for each capability.</p>\n<table>\n<thead>\n<tr>\n<th>Goal</th>\n<th>Success Criterion</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process Isolation</td>\n<td>Container process sees itself as PID 1, cannot see host processes</td>\n<td>Run <code>ps aux</code> inside container, verify only container processes visible</td>\n</tr>\n<tr>\n<td>Resource Control</td>\n<td>Container respects memory limit and is killed when exceeded</td>\n<td>Start container with 50MB limit, allocate 100MB, verify OOM kill</td>\n</tr>\n<tr>\n<td>Filesystem Layering</td>\n<td>Changes inside container don&#39;t affect base image</td>\n<td>Modify files in running container, verify base layer unchanged</td>\n</tr>\n<tr>\n<td>Network Connectivity</td>\n<td>Container can reach external network and accept incoming connections</td>\n<td>Ping external host from container, curl container service from host</td>\n</tr>\n</tbody></table>\n<p>These validation methods provide concrete evidence that our runtime successfully implements container isolation without relying on complex testing infrastructure or production-scale scenarios.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the goals and respecting the non-goals throughout the development process.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option (Avoid)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Configuration Format</td>\n<td>JSON files with simple schemas</td>\n<td>YAML with complex validation, OCI specs</td>\n</tr>\n<tr>\n<td>Namespace Creation</td>\n<td>Direct <code>syscall.SyscallN()</code> calls</td>\n<td>High-level abstraction libraries</td>\n</tr>\n<tr>\n<td>Filesystem Operations</td>\n<td><code>os</code> and <code>syscall</code> packages</td>\n<td>Virtual filesystem libraries</td>\n</tr>\n<tr>\n<td>Network Management</td>\n<td><code>netlink</code> package for basic operations</td>\n<td>CNI plugins, complex networking libraries</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Direct cgroup file reading</td>\n<td>Prometheus metrics, complex telemetry</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Simple error returns and logging</td>\n<td>Complex error categorization, retries</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Organize the codebase to reflect the four main functional areas while avoiding the complexity that production systems require:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-runtime/\n├── cmd/\n│   └── container/\n│       └── main.go                    ← Simple CLI interface\n├── internal/\n│   ├── manager/\n│   │   ├── manager.go                 ← ContainerSpec and lifecycle coordination\n│   │   └── manager_test.go\n│   ├── namespace/\n│   │   ├── namespace.go               ← CreateNamespaces and pivot_root logic\n│   │   └── namespace_test.go\n│   ├── cgroup/\n│   │   ├── cgroup.go                  ← Resource limit enforcement\n│   │   └── cgroup_test.go\n│   ├── filesystem/\n│   │   ├── overlay.go                 ← MountOverlayFS implementation\n│   │   └── overlay_test.go\n│   └── network/\n│       ├── bridge.go                  ← veth and bridge management\n│       └── bridge_test.go\n├── examples/\n│   ├── alpine-image/                  ← Simple container image for testing\n│   └── container-config.json          ← Example ContainerSpec\n└── docs/\n    └── debugging-guide.md             ← Common issues and solutions</code></pre></div>\n\n<p>This structure keeps related functionality together while avoiding the multi-layered abstractions that production runtimes use for extensibility.</p>\n<h4 id=\"core-data-structures\">Core Data Structures</h4>\n<p>Define simple, focused data structures that capture the essential information without over-engineering for extensibility:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ContainerSpec represents the desired container configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"image\"`</span><span style=\"color:#6A737D\">          // Local directory path</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Command     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"command\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">            `json:\"workingDir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Environment </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"environment\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Resources   </span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#9ECBFF\">    `json:\"resources\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network     </span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#9ECBFF\">     `json:\"network\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceLimits defines cgroup resource constraints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Memory </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"memory\"`</span><span style=\"color:#6A737D\">  // bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPU    </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"cpu\"`</span><span style=\"color:#6A737D\">     // CPU quota in microseconds per 100ms period</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PIDs   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"pids\"`</span><span style=\"color:#6A737D\">    // maximum number of processes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkConfig specifies container networking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `json:\"portMappings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DNS          []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"dns\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"scope-discipline-implementation\">Scope Discipline Implementation</h4>\n<p>Throughout development, apply these filters to avoid scope creep:</p>\n<p><strong>Filter 1: Core Learning Objective Test</strong></p>\n<blockquote>\n<p>&quot;Does this feature directly teach namespace isolation, resource control, filesystem layering, or basic networking?&quot;</p>\n</blockquote>\n<p>If the answer is no, the feature belongs in the non-goals category.</p>\n<p><strong>Filter 2: Complexity-to-Learning Ratio Test</strong>  </p>\n<blockquote>\n<p>&quot;Does implementing this feature require more than 50 lines of code unrelated to the core isolation mechanisms?&quot;</p>\n</blockquote>\n<p>If yes, consider whether a simpler alternative achieves the same learning objective.</p>\n<p><strong>Filter 3: Production Readiness Test (Reverse Filter)</strong></p>\n<blockquote>\n<p>&quot;Would this feature be required for production use?&quot;</p>\n</blockquote>\n<p>If yes, and it&#39;s not in our functional goals, it likely belongs in non-goals. Our runtime should be educational, not production-ready.</p>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each functional goal, validate success using these concrete checkpoints:</p>\n<p><strong>Milestone 1 Checkpoint - Process Isolation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start container with simple command</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> examples/alpine-image</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container, verify isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#6A737D\">          # Should only show container processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">hostname</span><span style=\"color:#6A737D\">        # Should show container-specific hostname</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#6A737D\">           # Should show isolated mount namespace</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint - Resource Control:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start container with memory limit</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --memory=50MB</span><span style=\"color:#9ECBFF\"> examples/alpine-image</span><span style=\"color:#9ECBFF\"> stress</span><span style=\"color:#79B8FF\"> --vm</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> --vm-bytes</span><span style=\"color:#9ECBFF\"> 100M</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify OOM kill occurs</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $?</span><span style=\"color:#6A737D\">         # Should be non-zero exit code indicating kill</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint - Filesystem Layering:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start container and modify filesystem</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> examples/alpine-image</span><span style=\"color:#9ECBFF\"> /bin/sh</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inside container: echo \"test\" > /tmp/container-file</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify base image unchanged</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> examples/alpine-image/tmp/</span><span style=\"color:#6A737D\">    # Should not contain container-file</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint - Networking:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start container with port mapping</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./container</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#79B8FF\"> --port=8080:80</span><span style=\"color:#9ECBFF\"> examples/alpine-image</span><span style=\"color:#9ECBFF\"> httpd</span><span style=\"color:#79B8FF\"> -f</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> localhost:8080</span><span style=\"color:#6A737D\">             # Should reach container service</span></span></code></pre></div>\n\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Feature Creep Through &quot;Just One More Thing&quot;</strong></p>\n<p>The most common failure mode is gradually adding features that seem &quot;small&quot; but collectively violate the non-goals. Examples include:</p>\n<ul>\n<li>Adding image format auto-detection (&quot;it&#39;s just checking file extensions&quot;)</li>\n<li>Implementing container logs (&quot;it&#39;s just redirecting stdout&quot;)  </li>\n<li>Adding health checks (&quot;it&#39;s just running a command periodically&quot;)</li>\n</ul>\n<p><strong>Fix</strong>: Maintain a strict feature log. Every addition must be explicitly justified against the functional goals and reviewed for scope creep.</p>\n<p>⚠️ <strong>Pitfall: Over-Engineering for Extensibility</strong></p>\n<p>Educational code often becomes too abstract when developers anticipate future features that are in the non-goals list.</p>\n<p><strong>Fix</strong>: Write the simplest code that demonstrates the concept. Prefer concrete implementations over abstract interfaces when the abstraction only serves excluded features.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Non-Goal Documentation</strong></p>\n<p>Teams often agree on non-goals but don&#39;t document them clearly, leading to scope debates during implementation.</p>\n<p><strong>Fix</strong>: For every rejected feature request, add it to the non-goals list with a clear explanation of why it&#39;s excluded. This prevents re-litigation of scope decisions.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> This section establishes the overall system design for all milestones (1-4), showing how the runtime manager orchestrates namespace creation, resource control, filesystem layering, and networking components.</p>\n</blockquote>\n<h3 id=\"mental-model-the-orchestra-conductor\">Mental Model: The Orchestra Conductor</h3>\n<p>Think of our container runtime as an <strong>orchestra conductor</strong> managing a complex performance. Just as a conductor coordinates different instrument sections—strings, brass, woodwinds, and percussion—our runtime manager coordinates different isolation mechanisms: namespaces for process isolation, cgroups for resource limits, overlayfs for filesystem layering, and network components for connectivity.</p>\n<p>The conductor doesn&#39;t play any instruments directly, but ensures each section comes in at the right time, plays in harmony, and follows the overall score. Similarly, our runtime manager doesn&#39;t implement the low-level kernel features directly, but orchestrates when namespaces get created, when cgroups are configured, when filesystems are mounted, and when network interfaces are established.</p>\n<p>Just as a conductor must handle mistakes gracefully—if the violins come in too early or the drums miss their cue—our runtime manager must handle partial failures where some components succeed while others fail, ensuring the entire system reaches a consistent state.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"Container Runtime System Architecture\"></p>\n<p>Our container runtime architecture centers around a <strong>Manager</strong> component that orchestrates four specialized subsystems, each responsible for a different aspect of container isolation and resource management. This design follows the principle of separation of concerns, where each component has a clearly defined responsibility and well-defined interfaces for interaction with other components.</p>\n<p>The architecture addresses the fundamental challenge of container runtimes: <strong>coordinating multiple kernel-level isolation mechanisms</strong> that must be set up in the correct order, configured consistently, and cleaned up properly when containers are removed. Each kernel feature—namespaces, cgroups, overlayfs, and network interfaces—has its own setup requirements, failure modes, and cleanup procedures.</p>\n<blockquote>\n<p><strong>Decision: Component-Based Architecture with Central Orchestration</strong></p>\n<ul>\n<li><strong>Context</strong>: Container creation involves coordinating multiple kernel features that must be configured in a specific sequence, with each step depending on the success of previous steps.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Monolithic design with all logic in a single component</li>\n<li>Component-based design with central orchestrator</li>\n<li>Pipeline design with sequential processing stages</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Component-based design with central Manager orchestrating specialized components</li>\n<li><strong>Rationale</strong>: This approach provides clear separation of concerns, making each component testable in isolation while maintaining centralized control over the complex sequencing requirements. The Manager can implement sophisticated error recovery since it has visibility into all component states.</li>\n<li><strong>Consequences</strong>: Enables easier testing and debugging of individual isolation mechanisms, but requires careful interface design between components and adds complexity to the Manager&#39;s coordination logic.</li>\n</ul>\n</blockquote>\n<p>The following table compares our architectural options:</p>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Monolithic</td>\n<td>Simple control flow, easier debugging</td>\n<td>Hard to test individual features, complex error recovery</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Component-based</td>\n<td>Clear separation, testable components, extensible</td>\n<td>Interface complexity, coordination overhead</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Pipeline</td>\n<td>Natural sequential flow, easy to add stages</td>\n<td>Rigid ordering, limited error recovery options</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h3 id=\"component-responsibilities\">Component Responsibilities</h3>\n<p>Each component in our architecture owns a specific domain of container isolation, with clearly defined responsibilities and interfaces. The <strong>Manager</strong> serves as the central orchestrator, while specialized components handle the technical details of their respective kernel features.</p>\n<h4 id=\"manager-component\">Manager Component</h4>\n<p>The <strong>Manager</strong> component acts as the central orchestrator for all container operations, implementing the primary API that external clients use to manage container lifecycles. It maintains the authoritative state of all active containers and coordinates the complex sequencing required for container creation, startup, shutdown, and cleanup.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Details</th>\n<th>Component Interface</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container Lifecycle</td>\n<td>Manages complete container lifecycle from creation through removal</td>\n<td><code>CreateContainer(spec)</code>, <code>StartContainer(id)</code>, <code>StopContainer(id)</code>, <code>RemoveContainer(id)</code></td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Tracks active containers, their PIDs, resource allocations, and cleanup requirements</td>\n<td><code>GetContainer(id)</code>, <code>ListContainers()</code></td>\n</tr>\n<tr>\n<td>Operation Sequencing</td>\n<td>Ensures components are called in correct order during container operations</td>\n<td>Internal coordination with all components</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Handles partial failures by cleaning up successfully created resources</td>\n<td>Rollback procedures for each operation type</td>\n</tr>\n<tr>\n<td>Configuration Loading</td>\n<td>Loads and validates container specifications from configuration files</td>\n<td><code>LoadContainerSpec(path)</code></td>\n</tr>\n</tbody></table>\n<p>The Manager maintains a <strong>ContainerState</strong> registry that tracks all active containers and their associated resources. This registry serves as the source of truth for cleanup operations and enables the Manager to handle system restarts by detecting orphaned resources.</p>\n<blockquote>\n<p>The critical insight for the Manager design is that container operations are <strong>transactions</strong> across multiple kernel subsystems. Like database transactions, they must either complete fully or be rolled back completely, leaving no partial state that could cause resource leaks or inconsistent behavior.</p>\n</blockquote>\n<h4 id=\"namespace-handler-component\">Namespace Handler Component</h4>\n<p>The <strong>Namespace Handler</strong> specializes in Linux namespace manipulation, creating isolated execution environments for container processes. It understands the subtle requirements and ordering constraints of different namespace types, handling the complex filesystem operations required for mount namespace isolation.</p>\n<table>\n<thead>\n<tr>\n<th>Namespace Type</th>\n<th>Isolation Provided</th>\n<th>Setup Requirements</th>\n<th>Handler Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID</td>\n<td>Process ID space isolation</td>\n<td>Clone with <code>CLONE_NEWPID</code></td>\n<td><code>CreatePIDNamespace()</code>, ensure container process becomes PID 1</td>\n</tr>\n<tr>\n<td>Mount</td>\n<td>Filesystem view isolation</td>\n<td>Pivot root operation, /proc mounting</td>\n<td><code>CreateMountNamespace()</code>, <code>PivotRoot()</code>, mount essential filesystems</td>\n</tr>\n<tr>\n<td>Network</td>\n<td>Network stack isolation</td>\n<td>Create network namespace, configure interfaces</td>\n<td><code>CreateNetworkNamespace()</code>, coordinate with Network Manager</td>\n</tr>\n<tr>\n<td>UTS</td>\n<td>Hostname and domain isolation</td>\n<td>Set container hostname independently</td>\n<td><code>CreateUTSNamespace()</code>, <code>SetHostname()</code></td>\n</tr>\n<tr>\n<td>User</td>\n<td>User ID mapping and capabilities</td>\n<td>Configure UID/GID mapping for unprivileged containers</td>\n<td><code>CreateUserNamespace()</code>, <code>ConfigureUIDMapping()</code></td>\n</tr>\n</tbody></table>\n<p>The Namespace Handler encapsulates the complex requirements for namespace setup, particularly the filesystem operations required for mount namespace isolation. It handles the <strong>pivot_root</strong> system call, which requires careful preparation of mount points and proper sequencing to avoid common failures.</p>\n<h4 id=\"cgroup-controller-component\">Cgroup Controller Component</h4>\n<p>The <strong>Cgroup Controller</strong> manages resource limits and monitoring using Linux cgroups v2, providing fine-grained control over CPU, memory, and I/O resources allocated to containers. It abstracts the complexity of the cgroup filesystem interface and provides high-level resource management operations.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Control Mechanism</th>\n<th>Configuration Parameters</th>\n<th>Controller Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory</td>\n<td>Hard and soft limits, OOM behavior</td>\n<td><code>memory.max</code>, <code>memory.high</code>, <code>memory.oom.group</code></td>\n<td><code>SetMemoryLimit()</code>, <code>GetMemoryUsage()</code>, <code>ConfigureOOMBehavior()</code></td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>Quota and period-based scheduling</td>\n<td><code>cpu.max</code>, <code>cpu.weight</code></td>\n<td><code>SetCPULimit()</code>, <code>GetCPUUsage()</code></td>\n</tr>\n<tr>\n<td>I/O</td>\n<td>Bandwidth and IOPS limits</td>\n<td><code>io.max</code>, <code>io.weight</code></td>\n<td><code>SetIOLimits()</code>, <code>GetIOStats()</code></td>\n</tr>\n<tr>\n<td>PIDs</td>\n<td>Maximum process count</td>\n<td><code>pids.max</code></td>\n<td><code>SetPIDLimit()</code>, <code>GetPIDCount()</code></td>\n</tr>\n</tbody></table>\n<p>The Cgroup Controller handles the hierarchical nature of cgroups, creating per-container cgroup directories under a runtime-managed hierarchy. It provides resource monitoring capabilities that enable the Manager to detect resource pressure and implement proactive management policies.</p>\n<blockquote>\n<p><strong>Decision: Cgroups v2 Unified Hierarchy</strong></p>\n<ul>\n<li><strong>Context</strong>: Linux systems support both cgroups v1 (legacy) and v2 (unified hierarchy), with different interfaces and capabilities.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Support only cgroups v1 for maximum compatibility</li>\n<li>Support only cgroups v2 for modern features</li>\n<li>Dual support with runtime detection</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Target cgroups v2 unified hierarchy exclusively</li>\n<li><strong>Rationale</strong>: Cgroups v2 provides a cleaner interface, better resource isolation, and is the future direction for Linux. Most modern systems support v2, and the complexity of dual support outweighs compatibility benefits for an educational runtime.</li>\n<li><strong>Consequences</strong>: Requires Linux 4.5+ with cgroups v2 enabled, but provides cleaner implementation and better resource control features.</li>\n</ul>\n</blockquote>\n<h4 id=\"filesystem-manager-component\">Filesystem Manager Component</h4>\n<p>The <strong>Filesystem Manager</strong> implements image layering using overlayfs, providing copy-on-write semantics that enable efficient container filesystem isolation. It manages the complex directory structure required by overlayfs and handles layer composition from multiple image layers.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Purpose</th>\n<th>Implementation Details</th>\n<th>Manager Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Layer Preparation</td>\n<td>Extract and prepare image layers</td>\n<td>Create directory structure for lower layers</td>\n<td><code>PrepareImageLayers(imageID)</code></td>\n</tr>\n<tr>\n<td>Overlay Mounting</td>\n<td>Combine layers into unified view</td>\n<td>Mount overlayfs with proper options</td>\n<td><code>MountOverlayFS(layers, target)</code></td>\n</tr>\n<tr>\n<td>Copy-on-Write</td>\n<td>Handle file modifications efficiently</td>\n<td>Ensure changes stay in upper layer</td>\n<td>Transparent through overlayfs</td>\n</tr>\n<tr>\n<td>Cleanup</td>\n<td>Remove overlay mounts and directories</td>\n<td>Unmount and clean up layer directories</td>\n<td><code>CleanupContainer(containerID)</code></td>\n</tr>\n</tbody></table>\n<p>The Filesystem Manager maintains a <strong>layer cache</strong> that tracks extracted image layers, enabling layer reuse across multiple containers that share common base images. This significantly reduces storage overhead and container startup time.</p>\n<p>The component handles the specific requirements of overlayfs, including the need for separate upper, work, and lower directories, and the requirement that the work directory be on the same filesystem as the upper directory for atomic operations.</p>\n<h4 id=\"network-manager-component\">Network Manager Component</h4>\n<p>The <strong>Network Manager</strong> implements container networking using virtual ethernet pairs and bridge networking, providing network isolation while enabling both inter-container communication and external connectivity. It manages IP address allocation and implements port forwarding using iptables NAT rules.</p>\n<table>\n<thead>\n<tr>\n<th>Networking Feature</th>\n<th>Implementation</th>\n<th>Configuration</th>\n<th>Manager Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container Isolation</td>\n<td>Create network namespace per container</td>\n<td>Coordinate with Namespace Handler</td>\n<td><code>CreateContainerNetwork()</code></td>\n</tr>\n<tr>\n<td>Inter-container Communication</td>\n<td>Bridge networking with veth pairs</td>\n<td>Create and configure bridge interface</td>\n<td><code>SetupBridge()</code>, <code>ConnectContainer()</code></td>\n</tr>\n<tr>\n<td>IP Address Management</td>\n<td>Subnet-based IP allocation</td>\n<td>CIDR pool for automatic assignment</td>\n<td><code>AllocateIP()</code>, <code>ReleaseIP()</code></td>\n</tr>\n<tr>\n<td>External Connectivity</td>\n<td>NAT rules for port forwarding</td>\n<td>iptables rules for host-to-container access</td>\n<td><code>ConfigurePortForwarding()</code></td>\n</tr>\n<tr>\n<td>DNS Resolution</td>\n<td>Configure container DNS settings</td>\n<td>Set up /etc/resolv.conf in container</td>\n<td><code>ConfigureDNS()</code></td>\n</tr>\n</tbody></table>\n<p>The Network Manager coordinates closely with the Namespace Handler to ensure network namespaces are created before network interfaces are configured. It maintains an <strong>IP allocation registry</strong> to prevent address conflicts and enable proper cleanup when containers are removed.</p>\n<blockquote>\n<p>The key architectural challenge for networking is that network configuration spans multiple namespaces—host and container—requiring careful coordination of operations that occur in different network contexts.</p>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Component Initialization Order</strong>\nMany developers assume components can be initialized independently, but container creation requires strict ordering. For example, the mount namespace must be created before overlayfs can be mounted, and network namespace must exist before veth pairs can be configured. The Manager must enforce these dependencies explicitly.</p>\n<p>⚠️ <strong>Pitfall: Shared State Between Components</strong>\nComponents that share state directly create tight coupling and make error recovery difficult. Each component should own its state completely, communicating with other components only through the Manager&#39;s coordination layer.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Error Recovery</strong>\nWhen container creation fails partway through, developers often forget to clean up resources created by earlier components. Each component must provide cleanup methods that the Manager can call during error recovery, and these must be idempotent.</p>\n<p>⚠️ <strong>Pitfall: Resource Leak on Manager Restart</strong>\nIf the Manager process crashes, it loses track of active containers and their associated resources (cgroups, mount points, network interfaces). The Manager must implement startup recovery that scans for orphaned resources and either adopts or cleans them up.</p>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>The codebase organization reflects our component-based architecture, with clear module boundaries that align with component responsibilities. This structure makes it easy to develop, test, and maintain each component independently while keeping integration points well-defined.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fcgroup-hierarchy.svg\" alt=\"Cgroup v2 Hierarchy Structure\"></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-runtime/\n├── cmd/\n│   ├── runtime/\n│   │   └── main.go                    # Main runtime daemon entry point\n│   └── cli/\n│       └── main.go                    # Command-line client for runtime API\n├── internal/\n│   ├── manager/\n│   │   ├── manager.go                 # Central orchestrator component\n│   │   ├── container.go               # Container state management\n│   │   ├── config.go                  # Configuration loading and validation\n│   │   └── manager_test.go            # Integration tests for Manager\n│   ├── namespace/\n│   │   ├── handler.go                 # Namespace creation and management\n│   │   ├── mount.go                   # Mount namespace and pivot_root operations\n│   │   ├── types.go                   # Namespace type constants and structures\n│   │   └── handler_test.go            # Namespace operation unit tests\n│   ├── cgroup/\n│   │   ├── controller.go              # Cgroup v2 resource control\n│   │   ├── memory.go                  # Memory controller specific operations\n│   │   ├── cpu.go                     # CPU controller specific operations\n│   │   └── controller_test.go         # Cgroup management unit tests\n│   ├── filesystem/\n│   │   ├── overlay.go                 # OverlayFS mounting and layer management\n│   │   ├── layers.go                  # Image layer extraction and caching\n│   │   ├── cleanup.go                 # Filesystem cleanup operations\n│   │   └── overlay_test.go            # Filesystem operation unit tests\n│   ├── network/\n│   │   ├── manager.go                 # Network setup and configuration\n│   │   ├── bridge.go                  # Bridge networking implementation\n│   │   ├── veth.go                    # Virtual ethernet pair management\n│   │   ├── iptables.go                # NAT rules for port forwarding\n│   │   └── manager_test.go            # Network configuration unit tests\n│   └── types/\n│       ├── container.go               # ContainerSpec and ContainerState definitions\n│       ├── resources.go               # ResourceLimits and monitoring types\n│       └── network.go                 # NetworkConfig and PortMapping types\n├── pkg/\n│   ├── api/\n│   │   ├── runtime.go                 # Public API interfaces\n│   │   └── client.go                  # Client library for runtime API\n│   └── utils/\n│       ├── syscalls.go                # System call wrappers\n│       └── paths.go                   # Path manipulation utilities\n├── configs/\n│   ├── default.yaml                   # Default runtime configuration\n│   └── examples/\n│       ├── alpine.yaml                # Example Alpine container spec\n│       └── nginx.yaml                 # Example Nginx container spec\n├── test/\n│   ├── integration/\n│   │   ├── container_lifecycle_test.go # End-to-end container tests\n│   │   └── networking_test.go          # Multi-container networking tests\n│   └── fixtures/\n│       ├── test-images/               # Test container images\n│       └── configs/                   # Test configuration files\n└── docs/\n    ├── api.md                         # API documentation\n    └── troubleshooting.md             # Common issues and solutions</code></pre></div>\n\n<p>The <strong>internal/</strong> directory contains all implementation components that are not exposed as public APIs. Each component has its own package with clearly defined interfaces, making it easy to develop and test components independently.</p>\n<p>The <strong>types/</strong> package serves as a central location for all data structures shared between components, preventing circular dependencies while ensuring consistent type definitions across the codebase.</p>\n<p>The <strong>pkg/</strong> directory contains public APIs that external clients can use to interact with our runtime, following Go conventions for library organization.</p>\n<blockquote>\n<p><strong>Decision: Internal Package Organization</strong></p>\n<ul>\n<li><strong>Context</strong>: Component interfaces need to be accessible to the Manager for orchestration, but shouldn&#39;t be exposed to external clients.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>All components in single package with public interfaces</li>\n<li>Separate packages with internal interfaces</li>\n<li>Separate packages with public interfaces in pkg/</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate internal packages with shared types package</li>\n<li><strong>Rationale</strong>: This provides clear component boundaries while preventing external dependencies on internal implementation details. The shared types package avoids circular dependencies between component packages.</li>\n<li><strong>Consequences</strong>: Enables independent component development and testing, but requires careful interface design to minimize coupling between packages.</li>\n</ul>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Our component-based architecture requires careful attention to interface design and dependency management. The following guidance helps implement clean component boundaries while maintaining the flexibility needed for container runtime operations.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IPC</td>\n<td>Direct Go method calls within process</td>\n<td>gRPC interfaces for potential distribution</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>YAML files with <code>gopkg.in/yaml.v3</code></td>\n<td>JSON Schema validation with structured configs</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard <code>log</code> package with structured output</td>\n<td><code>github.com/sirupsen/logrus</code> with contextual fields</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Standard Go error handling with wrapped errors</td>\n<td>Custom error types with error codes and recovery hints</td>\n</tr>\n<tr>\n<td>State Storage</td>\n<td>In-memory maps with file-based persistence</td>\n<td>Embedded database like BoltDB for reliable state</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Standard <code>testing</code> package with table-driven tests</td>\n<td><code>github.com/stretchr/testify</code> for assertions and mocks</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-implementation\">File Structure Implementation</h4>\n<p>The recommended file structure supports clean separation between components while maintaining clear integration points. Here&#39;s how to implement the core structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/types/container.go - Central type definitions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerSpec defines the desired state of a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `yaml:\"id\" json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `yaml:\"image\" json:\"image\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Command     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">               `yaml:\"command\" json:\"command\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `yaml:\"workdir\" json:\"workdir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Environment </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `yaml:\"environment\" json:\"environment\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Resources   </span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#9ECBFF\">         `yaml:\"resources\" json:\"resources\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network     </span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#9ECBFF\">          `yaml:\"network\" json:\"network\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerState tracks the runtime state of an active container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spec         </span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#9ECBFF\">    `json:\"spec\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status       </span><span style=\"color:#B392F0\">ContainerStatus</span><span style=\"color:#9ECBFF\">  `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PID          </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">             `json:\"pid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">       `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">      `json:\"started_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CgroupPath   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"cgroup_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OverlayPath  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"overlay_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkNS    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"network_ns\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VethHost     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"veth_host\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VethContainer </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"veth_container\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"ip_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusCreated</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusRunning</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"running\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusStopped</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"stopped\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StatusError</span><span style=\"color:#B392F0\">   ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"error\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceLimits defines resource constraints for containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Memory </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `yaml:\"memory\" json:\"memory\"`</span><span style=\"color:#6A737D\">     // bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPU    </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `yaml:\"cpu\" json:\"cpu\"`</span><span style=\"color:#6A737D\">           // CPU quota in microseconds per 100ms period</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PIDs   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `yaml:\"pids\" json:\"pids\"`</span><span style=\"color:#6A737D\">         // maximum number of processes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkConfig defines networking configuration for containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `yaml:\"port_mappings\" json:\"port_mappings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DNS          []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `yaml:\"dns\" json:\"dns\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PortMapping defines a host-to-container port forward</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostPort      </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"host_port\" json:\"host_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"container_port\" json:\"container_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Protocol      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"protocol\" json:\"protocol\"`</span><span style=\"color:#6A737D\"> // \"tcp\" or \"udp\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/manager/manager.go - Core orchestration component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> manager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container-runtime/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container-runtime/internal/namespace</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container-runtime/internal/cgroup</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container-runtime/internal/filesystem</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container-runtime/internal/network</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager orchestrates container lifecycle operations across all subsystems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nsHandler    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">namespace</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupCtrl   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cgroup</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Controller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fsManager    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">filesystem</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    netManager   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">network</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configDir    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateDir     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewManager creates a new container runtime manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configDir</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">stateDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize all component managers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create necessary directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Load existing container state from persistence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Perform startup recovery for orphaned resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainer prepares a new container environment without starting it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate container specification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check for container ID conflicts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create container state entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Prepare image layers through filesystem manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create and configure cgroup through cgroup controller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create namespaces through namespace handler</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set up network namespace through network manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Mount overlayfs through filesystem manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Persist container state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle errors by cleaning up partial resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartContainer begins execution of a created container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate container exists and is in created state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fork container process in prepared namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add process to cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure network interfaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute container command</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update container state to running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Persist state change</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StopContainer gracefully terminates a running container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate container exists and is running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send SIGTERM to container process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Wait for graceful shutdown with timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send SIGKILL if timeout exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update container state to stopped</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Persist state change</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveContainer cleans up all resources for a stopped container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate container exists and is stopped</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Unmount overlayfs through filesystem manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clean up network configuration through network manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove cgroup through cgroup controller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clean up namespace resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove container state entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clean up persistent state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadContainerSpec loads container specification from YAML file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LoadContainerSpec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Read YAML file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Parse into ContainerSpec struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set default values for optional fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return parsed and validated spec</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"component-interface-contracts\">Component Interface Contracts</h4>\n<p>Each component must implement specific interfaces that the Manager uses for orchestration. This ensures clean separation of concerns while maintaining coordinated behavior:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Component interfaces that each subsystem must implement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NamespaceHandler</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">flags</span><span style=\"color:#B392F0\"> NamespaceFlags</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EnterNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CleanupNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CgroupController</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limits</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AddProcess</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetUsage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceUsage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RemoveCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FilesystemManager</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PrepareContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">imageID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MountOverlayFS</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">layers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CleanupContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkManager</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ConnectContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    DisconnectContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CleanupNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Checkpoint 1: Architecture Setup</strong>\nAfter implementing the basic file structure and Manager skeleton:</p>\n<ul>\n<li>Run <code>go mod tidy &amp;&amp; go build ./cmd/runtime/</code> - should compile without errors</li>\n<li>Create a simple container spec YAML file in <code>configs/test.yaml</code></li>\n<li>Run <code>go test ./internal/types/</code> - basic type validation should pass</li>\n<li>The Manager should be able to load container specs from YAML files</li>\n</ul>\n<p><strong>Checkpoint 2: Component Integration</strong>\nAfter implementing component interfaces:</p>\n<ul>\n<li>Each component package should compile independently</li>\n<li>Run <code>go test ./internal/manager/</code> - Manager should instantiate all components</li>\n<li>Mock implementations of component interfaces should allow testing Manager orchestration logic</li>\n<li>The Manager should be able to coordinate component method calls in proper sequence</li>\n</ul>\n<p><strong>Checkpoint 3: Error Recovery</strong>\nAfter implementing cleanup and error handling:</p>\n<ul>\n<li>Test partial failure scenarios - create resources with some components, then trigger failures</li>\n<li>Verify that Manager properly cleans up resources from successful components</li>\n<li>Check that the system reaches consistent state after any failure</li>\n<li>No resource leaks should remain after failed container creation attempts</li>\n</ul>\n<p>This architecture provides the foundation for implementing each milestone&#39;s specific functionality while maintaining clean component boundaries and coordinated behavior across the entire container runtime system.</p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) rely on this data model. The container specification structures support milestone 1 (namespace configuration), milestone 2 (resource limits), milestone 3 (image and filesystem configuration), and milestone 4 (network configuration). The runtime state structures track the lifecycle and cleanup resources across all milestones.</p>\n</blockquote>\n<p>The data model forms the foundation of our container runtime, defining how we represent container configurations, track runtime state, and manage the complex lifecycle of isolated processes. Think of the data model as the <strong>architectural blueprints</strong> for our container system - just as building blueprints specify every room, door, and utility connection before construction begins, our data structures define every piece of information needed to create, manage, and clean up containers before any code executes.</p>\n<p>The data model serves two critical purposes in container runtime architecture. First, it provides a <strong>declarative specification interface</strong> where users describe what they want (run this command, with these resource limits, using this image) without needing to understand the complex orchestration of namespaces, cgroups, and filesystem operations underneath. Second, it maintains <strong>runtime state tracking</strong> that allows our system to properly manage the lifecycle of containers, ensuring clean startup sequences and comprehensive cleanup when containers terminate.</p>\n<p>Container runtimes must juggle multiple kernel subsystems simultaneously - Linux namespaces for isolation, cgroups for resource control, overlayfs for layered filesystems, and network interfaces for connectivity. Each subsystem has its own configuration parameters, runtime handles, and cleanup requirements. Our data model abstracts this complexity into coherent structures that represent the user&#39;s intent and the system&#39;s current state.</p>\n<h3 id=\"container-specification\">Container Specification</h3>\n<p>The <code>ContainerSpec</code> structure defines the <strong>declarative blueprint</strong> for what a container should look like when running. This represents the user&#39;s intent - the desired end state - rather than the implementation details of how to achieve that state. Think of it as a <strong>recipe card</strong> that specifies all ingredients (image, resources, network settings) and basic instructions (command to run, environment variables) needed to create a container, while leaving the actual cooking process (namespace creation, cgroup setup, filesystem mounting) to the runtime implementation.</p>\n<p>The container specification follows the principle of <strong>immutable configuration</strong> - once created, a spec should not change during the container&#39;s lifetime. This immutability simplifies reasoning about container behavior and enables reliable cleanup, since the runtime can always refer back to the original specification to understand what resources were allocated and need to be released.</p>\n<blockquote>\n<p><strong>Decision: Separate Specification from Runtime State</strong></p>\n<ul>\n<li><strong>Context</strong>: Container management requires both user intent (what should run) and current system state (what is actually running)</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single structure mixing spec and state</li>\n<li>Separate spec and state structures</li>\n<li>Inheritance hierarchy with base container class</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use separate <code>ContainerSpec</code> and <code>ContainerState</code> structures</li>\n<li><strong>Rationale</strong>: Clear separation of concerns allows immutable specifications while enabling mutable state tracking. Simplifies serialization for persistence and makes the API clearer for users.</li>\n<li><strong>Consequences</strong>: Requires careful coordination between spec and state, but provides better encapsulation and testing isolation.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Unique identifier for this container instance. Must be unique across all containers managed by this runtime. Used for filesystem paths, cgroup names, and cleanup tracking.</td>\n</tr>\n<tr>\n<td>Image</td>\n<td>string</td>\n<td>Path to the container image directory or identifier. For our minimal runtime, this points to a directory containing the root filesystem that will become the container&#39;s root.</td>\n</tr>\n<tr>\n<td>Command</td>\n<td>[]string</td>\n<td>Command and arguments to execute inside the container. First element is the executable path (relative to container root), remaining elements are arguments passed to the process.</td>\n</tr>\n<tr>\n<td>WorkingDir</td>\n<td>string</td>\n<td>Working directory path inside the container where the command will be executed. Path is relative to the container&#39;s root filesystem. Defaults to &quot;/&quot; if not specified.</td>\n</tr>\n<tr>\n<td>Environment</td>\n<td>map[string]string</td>\n<td>Environment variables to set in the container process. Maps variable names to their values. These supplement (and can override) any environment variables from the base image.</td>\n</tr>\n<tr>\n<td>Resources</td>\n<td>ResourceLimits</td>\n<td>Resource constraints to apply to this container via cgroups. Defines memory limits, CPU quotas, and process limits that constrain container resource usage.</td>\n</tr>\n<tr>\n<td>Network</td>\n<td>NetworkConfig</td>\n<td>Network configuration specifying how this container connects to networks and exposes services. Includes port mappings and DNS settings.</td>\n</tr>\n</tbody></table>\n<p>The <code>ID</code> field serves as the primary key for all container operations and becomes embedded in filesystem paths, cgroup hierarchies, and network interface names. Container IDs must be valid as directory names (no special characters that would break filesystem operations) and should be reasonably short to avoid hitting path length limits when combined with deep directory structures.</p>\n<p>The <code>Image</code> field in our minimal implementation points to a local directory containing a complete root filesystem. Production container runtimes would extend this to support image references, layer manifests, and remote registries, but for learning purposes we focus on local filesystem images that can be easily inspected and modified during development.</p>\n<p>The <code>Command</code> array follows POSIX conventions where the first element is the executable and subsequent elements are individual arguments. This differs from shell command lines - arguments containing spaces must be separate array elements rather than quoted strings. The runtime does not perform shell expansion or interpretation of the command elements.</p>\n<h3 id=\"resource-limits-structure\">Resource Limits Structure</h3>\n<p>Resource limits define the <strong>resource budget</strong> allocated to a container, implemented through Linux cgroups. Think of resource limits as setting a <strong>spending allowance</strong> for different types of system resources - just as a parent might give a child separate allowances for food, entertainment, and savings, cgroups let us set separate limits for memory consumption, CPU usage, and process creation.</p>\n<blockquote>\n<p><strong>Decision: Explicit Resource Limit Fields vs Generic Map</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to represent different types of resource limits that will be enforced via cgroups</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Typed fields for each resource type (Memory, CPU, PIDs)</li>\n<li>Generic map[string]interface{} for flexibility</li>\n<li>Nested structures per cgroup controller</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use explicit typed fields for core resource types</li>\n<li><strong>Rationale</strong>: Type safety prevents configuration errors, clear API makes resource limits obvious, easier validation and documentation</li>\n<li><strong>Consequences</strong>: Adding new resource types requires schema changes, but provides better user experience and prevents runtime errors</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory</td>\n<td>int64</td>\n<td>Maximum memory usage in bytes. Enforced via cgroup memory.max. Container processes will be killed if they exceed this limit. Zero means no limit.</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>int64</td>\n<td>CPU quota in microseconds per 100ms period. Enforced via cgroup cpu.max. Value of 50000 means container gets 50% of one CPU core. Zero means no limit.</td>\n</tr>\n<tr>\n<td>PIDs</td>\n<td>int64</td>\n<td>Maximum number of processes/threads this container can create. Enforced via cgroup pids.max. Prevents fork bombs and runaway process creation. Zero means no limit.</td>\n</tr>\n</tbody></table>\n<p>The memory limit directly maps to the cgroups v2 <code>memory.max</code> file, which enforces a hard limit on memory usage. When a container approaches this limit, the kernel will start killing processes within the container&#39;s cgroup, typically starting with the most recently started processes. This provides strong isolation but can cause abrupt application failures if limits are set too low.</p>\n<p>CPU limits use the cgroups v2 bandwidth control system, which implements a quota over a fixed period. The period is typically 100 milliseconds (100000 microseconds), and the quota specifies how many microseconds of CPU time the container can use within each period. A quota of 50000 microseconds in a 100000 microsecond period means the container gets 50% of one CPU core.</p>\n<p>Process limits prevent containers from exhausting the system&#39;s process table through fork bombs or poorly written applications that leak processes. The limit applies to the total number of tasks (processes and threads) within the container&#39;s cgroup, providing protection against both accidental and malicious process creation.</p>\n<h3 id=\"network-configuration-structure\">Network Configuration Structure</h3>\n<p>Network configuration defines how a container connects to networks and exposes services to the outside world. Think of network configuration as specifying the <strong>mailing address and phone system</strong> for your container - it determines how other containers and external systems can reach services running inside the container, and how the container reaches external resources.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PortMappings</td>\n<td>[]PortMapping</td>\n<td>List of port forwarding rules that expose container services on host ports. Each mapping creates NAT rules forwarding traffic from a host port to a container port.</td>\n</tr>\n<tr>\n<td>DNS</td>\n<td>[]string</td>\n<td>DNS nameserver IP addresses for container name resolution. These servers will be configured in the container&#39;s /etc/resolv.conf file for hostname lookups.</td>\n</tr>\n</tbody></table>\n<p>The port mappings implement <strong>Network Address Translation (NAT)</strong> using iptables rules that forward traffic from host network interfaces to the container&#39;s network namespace. This allows external clients to connect to services running inside containers by connecting to host ports, with the traffic automatically forwarded to the appropriate container ports.</p>\n<p>DNS configuration ensures that processes inside containers can resolve hostnames to IP addresses. Since containers run in isolated network namespaces, they cannot automatically inherit the host system&#39;s DNS configuration and must have explicit nameserver configuration.</p>\n<h3 id=\"port-mapping-structure\">Port Mapping Structure</h3>\n<p>Port mappings define individual <strong>traffic forwarding rules</strong> that expose container services on the host network. Each port mapping creates a tunnel through the network isolation boundary, allowing external traffic to reach specific services inside containers.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HostPort</td>\n<td>int</td>\n<td>Port number on the host where traffic will be received. Must be available (not already bound by another service). Range 1-65535.</td>\n</tr>\n<tr>\n<td>ContainerPort</td>\n<td>int</td>\n<td>Port number inside the container where the service is listening. This is the destination for forwarded traffic. Range 1-65535.</td>\n</tr>\n<tr>\n<td>Protocol</td>\n<td>string</td>\n<td>Network protocol for this port mapping. Typically &quot;tcp&quot; or &quot;udp&quot;. Determines which iptables rules and traffic types this mapping handles.</td>\n</tr>\n</tbody></table>\n<p>Port mappings create a <strong>bidirectional tunnel</strong> through the network namespace isolation. Inbound traffic to the host port gets forwarded to the container port, and response traffic from the container port gets forwarded back to the original external client. This requires careful iptables rule management to ensure traffic flows correctly in both directions.</p>\n<p>The protocol field determines which type of network traffic this mapping handles. TCP mappings create connection-oriented forwarding suitable for HTTP services, databases, and other stream-based protocols. UDP mappings create connectionless forwarding suitable for DNS, DHCP, and other packet-based protocols.</p>\n<h3 id=\"runtime-state\">Runtime State</h3>\n<p>The <code>ContainerState</code> structure tracks the <strong>current operational status</strong> of a running container, maintaining all the runtime handles, resource paths, and metadata needed to manage and clean up container instances. Think of runtime state as the <strong>active case file</strong> for a container - it contains all the information needed to monitor, interact with, and eventually clean up a running container instance.</p>\n<p>Runtime state is <strong>mutable and ephemeral</strong> - it changes as containers start, run, and stop, and it does not need to persist across system restarts (since containers don&#39;t survive reboots in our minimal implementation). The state structure serves as a central registry of all system resources allocated to a container, enabling systematic cleanup when containers terminate.</p>\n<p>The runtime state maintains <strong>resource ownership tracking</strong> - for every system resource allocated during container creation (cgroup directories, overlay mounts, network interfaces), the state structure records the identifiers and paths needed to clean up those resources. This prevents resource leaks and ensures containers can be completely removed from the system.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Spec</td>\n<td>ContainerSpec</td>\n<td>The original container specification that created this instance. Provides immutable reference to user intent and configuration parameters.</td>\n</tr>\n<tr>\n<td>Status</td>\n<td>ContainerStatus</td>\n<td>Current lifecycle status of this container (Created, Running, Stopped, etc.). Determines which operations are valid and what cleanup is required.</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>int</td>\n<td>Process ID of the main container process in the host PID namespace. Used for process management and cleanup. Zero if container is not running.</td>\n</tr>\n<tr>\n<td>CreatedAt</td>\n<td>time.Time</td>\n<td>Timestamp when container state was first created. Used for logging, monitoring, and container age calculations.</td>\n</tr>\n<tr>\n<td>StartedAt</td>\n<td>*time.Time</td>\n<td>Timestamp when container process was started, or nil if never started. Pointer allows distinction between &quot;never started&quot; and &quot;started at Unix epoch&quot;.</td>\n</tr>\n<tr>\n<td>CgroupPath</td>\n<td>string</td>\n<td>Full filesystem path to this container&#39;s cgroup directory (e.g., &quot;/sys/fs/cgroup/container-123&quot;). Used for resource limit enforcement and cleanup.</td>\n</tr>\n<tr>\n<td>OverlayPath</td>\n<td>string</td>\n<td>Full filesystem path to the overlay mount point for this container&#39;s root filesystem. Must be unmounted during cleanup to prevent resource leaks.</td>\n</tr>\n<tr>\n<td>NetworkNS</td>\n<td>string</td>\n<td>Path to the network namespace file in /proc (e.g., &quot;/proc/123/ns/net&quot;). Used for network operations and cleanup.</td>\n</tr>\n<tr>\n<td>VethHost</td>\n<td>string</td>\n<td>Name of the veth interface in the host network namespace (e.g., &quot;veth123h&quot;). Must be deleted during cleanup.</td>\n</tr>\n<tr>\n<td>VethContainer</td>\n<td>string</td>\n<td>Name of the veth interface inside the container network namespace (e.g., &quot;eth0&quot;). Automatically cleaned up when namespace is destroyed.</td>\n</tr>\n<tr>\n<td>IPAddress</td>\n<td>string</td>\n<td>IP address assigned to this container&#39;s network interface. Used for connectivity and must be returned to the address pool during cleanup.</td>\n</tr>\n</tbody></table>\n<p>The embedded <code>Spec</code> field provides <strong>configuration consistency</strong> - the runtime can always refer back to the original user intent when making decisions about resource management, cleanup, or status reporting. This embedded spec should never be modified after container creation, ensuring that the original configuration remains available throughout the container lifecycle.</p>\n<p>The <code>PID</code> field represents the container&#39;s main process as seen from the host perspective. Even though the process sees itself as PID 1 inside its PID namespace, the host system assigns it a regular PID that we use for process management operations like sending signals or checking process status.</p>\n<p>Path-based fields (<code>CgroupPath</code>, <code>OverlayPath</code>, <code>NetworkNS</code>) provide the <strong>cleanup roadmap</strong> - they contain all the filesystem paths that must be unmounted, removed, or cleaned up when the container terminates. These paths are determined during container creation and remain stable throughout the container&#39;s lifetime.</p>\n<p>Network-related fields (<code>VethHost</code>, <code>VethContainer</code>, <code>IPAddress</code>) track the <strong>network plumbing</strong> created for this container. The host veth interface must be explicitly deleted during cleanup, while the container veth interface is automatically cleaned up when the network namespace is destroyed. The IP address must be returned to the available address pool so it can be reused by future containers.</p>\n<h3 id=\"container-status-enumeration\">Container Status Enumeration</h3>\n<p>Container status represents the current <strong>lifecycle stage</strong> of a container instance, determining which operations are valid and what state transitions are possible. This follows a simple state machine that mirrors the typical container lifecycle from creation through cleanup.</p>\n<table>\n<thead>\n<tr>\n<th>Status Value</th>\n<th>Description</th>\n<th>Valid Transitions</th>\n<th>Cleanup Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Created</td>\n<td>Container resources allocated but process not started</td>\n<td>→ Running, → Stopped</td>\n<td>Full cleanup (cgroups, filesystem, network)</td>\n</tr>\n<tr>\n<td>Running</td>\n<td>Container process actively executing</td>\n<td>→ Stopped</td>\n<td>Process termination + full cleanup</td>\n</tr>\n<tr>\n<td>Stopped</td>\n<td>Container process terminated but resources not cleaned</td>\n<td>→ Removed</td>\n<td>Full cleanup (cgroups, filesystem, network)</td>\n</tr>\n<tr>\n<td>Removed</td>\n<td>Container completely cleaned up and removed</td>\n<td>None (terminal state)</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<p>The status progression typically follows: Created → Running → Stopped → Removed, though containers can transition directly from Created to Stopped if they fail to start, or from Running to Removed if they are forcibly deleted while running.</p>\n<h3 id=\"common-data-model-pitfalls\">Common Data Model Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Mixing Configuration with Runtime State</strong>\nMany developers initially put runtime-specific fields like PIDs and paths directly into the container specification structure. This breaks the separation between user intent (what should run) and system state (what is actually running). Keep the <code>ContainerSpec</code> immutable and put all runtime tracking in <code>ContainerState</code>.</p>\n<p>⚠️ <strong>Pitfall: Forgetting Resource Cleanup Tracking</strong>\nThe runtime state must track every system resource allocated during container creation. Forgetting to record filesystem paths, network interface names, or cgroup paths leads to resource leaks when containers are removed. Always add cleanup tracking fields to <code>ContainerState</code> when introducing new resource types.</p>\n<p>⚠️ <strong>Pitfall: Using Host-Relative Paths in Container Specs</strong>\nContainer specifications should use container-relative paths for working directories and command paths, not host system paths. The <code>WorkingDir</code> field should be &quot;/app&quot; not &quot;/var/lib/containers/container-123/rootfs/app&quot; - the runtime handles the translation to host paths during execution.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Container ID Validation</strong>\nContainer IDs become embedded in filesystem paths and network interface names, so they must be validated to ensure they don&#39;t contain characters that would break these systems. Reject IDs containing &quot;/&quot;, &quot;.&quot;, &quot;..&quot;, or other special characters that could cause path traversal or naming conflicts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation requires careful attention to serialization, validation, and lifecycle management. The structures serve as both API contracts and internal state management, so they need to be robust against invalid input while remaining easy to work with programmatically.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serialization</td>\n<td>JSON with encoding/json package</td>\n<td>Protocol Buffers with schema validation</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Manual field checks in constructors</td>\n<td>Struct tags with validator library</td>\n</tr>\n<tr>\n<td>State Persistence</td>\n<td>In-memory maps with JSON files</td>\n<td>Embedded database like BoltDB</td>\n</tr>\n<tr>\n<td>ID Generation</td>\n<td>UUID v4 with google/uuid</td>\n<td>Collision-resistant with timestamp + random</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  types/\n    container.go           ← Core data structures\n    container_test.go      ← Structure validation tests\n    validation.go          ← Input validation functions\n    validation_test.go     ← Validation test cases\n  runtime/\n    state_manager.go       ← Container state tracking\n    state_manager_test.go  ← State management tests</code></pre></div>\n\n<h4 id=\"core-data-structures\">Core Data Structures</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">regexp</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerSpec defines the desired configuration for a container instance.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This structure is immutable after creation and represents user intent.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ID uniquely identifies this container instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Image specifies the root filesystem for the container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Image </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"image\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Command and arguments to execute in the container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Command []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"command\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // WorkingDir sets the initial working directory (container-relative path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkingDir </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"working_dir,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Environment variables for the container process</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Environment </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"environment,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource limits enforced via cgroups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Resources </span><span style=\"color:#B392F0\">ResourceLimits</span><span style=\"color:#9ECBFF\"> `json:\"resources,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Network configuration for connectivity and port exposure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network </span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#9ECBFF\"> `json:\"network,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceLimits defines cgroup-enforced resource constraints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Memory limit in bytes (0 = no limit)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Memory </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"memory,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CPU quota in microseconds per 100ms period (0 = no limit) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPU </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"cpu,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Maximum number of processes/threads (0 = no limit)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PIDs </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"pids,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkConfig specifies container networking requirements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Port mappings for service exposure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#9ECBFF\"> `json:\"port_mappings,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DNS nameservers for hostname resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DNS []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"dns,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PortMapping defines a single port forwarding rule</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Host port to listen on</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"host_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Container port to forward to</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerPort </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"container_port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Protocol (\"tcp\" or \"udp\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Protocol </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"protocol\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerState tracks the runtime status of a container instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Original specification (immutable reference)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spec </span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#9ECBFF\"> `json:\"spec\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Current lifecycle status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status </span><span style=\"color:#B392F0\">ContainerStatus</span><span style=\"color:#9ECBFF\"> `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Main process ID in host namespace (0 if not running)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PID </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"pid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Creation and start timestamps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">  `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartedAt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"started_at,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource cleanup tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CgroupPath   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"cgroup_path,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OverlayPath  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"overlay_path,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkNS    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"network_ns,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VethHost     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"veth_host,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VethContainer </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"veth_container,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"ip_address,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerStatus represents container lifecycle states</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ContainerCreated</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"created\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ContainerRunning</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"running\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ContainerStopped</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"stopped\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ContainerRemoved</span><span style=\"color:#B392F0\"> ContainerStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"removed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"validation-functions\">Validation Functions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ValidateContainerSpec checks a container specification for common errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateContainerSpec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container ID format (alphanumeric, hyphens, underscores only)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check that Image path exists and is accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate Command has at least one element and first element is not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate WorkingDir is absolute path starting with \"/\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check Environment variable names don't contain \"=\" character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate ResourceLimits are non-negative</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate PortMappings have valid port ranges (1-65535)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Check DNS entries are valid IP addresses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateContainerID ensures ID can safely be used in filesystem paths</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateContainerID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check ID length is between 1 and 64 characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify ID matches pattern: alphanumeric, hyphens, underscores only</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Ensure ID doesn't start or end with hyphen or underscore</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Reject reserved names like \".\", \"..\", or system directory names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidatePortMapping checks a single port mapping for validity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidatePortMapping</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pm</span><span style=\"color:#B392F0\"> PortMapping</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate HostPort is in range 1-65535</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate ContainerPort is in range 1-65535</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check Protocol is either \"tcp\" or \"udp\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify HostPort is not in reserved range (1-1023) unless privileged</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"state-management-helper\">State Management Helper</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> runtime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateManager handles container state persistence and lifecycle tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add fields for state storage (map, file path, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SaveContainerState persists container state to storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SaveContainerState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Serialize state to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Write to persistent storage (file, database, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Ensure atomic write operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle storage errors gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadContainerState retrieves container state from storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LoadContainerState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read state data from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Deserialize JSON to ContainerState struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate loaded data integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return appropriate error if container not found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ListContainers returns all container states matching optional filter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ListContainers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">status</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerStatus</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load all container states from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Filter by status if specified (empty status = return all)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Sort results by creation time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return slice of matching containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DeleteContainerState removes container state from storage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DeleteContainerState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify container exists in storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove state data from persistent storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Clean up any related temporary files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure deletion is atomic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-notes\">Language-Specific Implementation Notes</h4>\n<p><strong>Go-specific considerations:</strong></p>\n<ul>\n<li>Use <code>encoding/json</code> struct tags for API serialization control</li>\n<li>Implement <code>String()</code> methods on enums like <code>ContainerStatus</code> for logging</li>\n<li>Use pointer types (<code>*time.Time</code>) to distinguish between zero values and unset fields</li>\n<li>Consider using <code>sync.RWMutex</code> for concurrent access to state maps</li>\n<li>Validate file paths using <code>filepath.Clean()</code> to prevent directory traversal</li>\n</ul>\n<p><strong>Validation patterns:</strong></p>\n<ul>\n<li>Use regular expressions for ID format validation: <code>^[a-zA-Z0-9]([a-zA-Z0-9_-]*[a-zA-Z0-9])?$</code></li>\n<li>Check port ranges with simple numeric comparisons: <code>port &gt;= 1 &amp;&amp; port &lt;= 65535</code></li>\n<li>Validate IP addresses using <code>net.ParseIP()</code> from standard library</li>\n<li>Use <code>os.Stat()</code> to verify image directory existence and permissions</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the data model structures:</p>\n<ol>\n<li><strong>Run unit tests</strong>: <code>go test ./internal/types/...</code> should pass all validation tests</li>\n<li><strong>Test JSON serialization</strong>: Create a container spec, marshal to JSON, unmarshal back, verify equality</li>\n<li><strong>Validate error handling</strong>: Try invalid container IDs, port ranges, and paths - should get clear error messages</li>\n<li><strong>Check state transitions</strong>: Verify container status can only transition through valid states</li>\n</ol>\n<p>Expected behavior:</p>\n<ul>\n<li>Container specs with valid fields serialize/deserialize correctly</li>\n<li>Invalid container IDs (with special characters) are rejected with descriptive errors</li>\n<li>Port mappings outside 1-65535 range are rejected</li>\n<li>Resource limits accept zero (unlimited) and positive values, reject negative values</li>\n</ul>\n<p>Signs of problems:</p>\n<ul>\n<li>JSON marshaling panics → Check for circular references in embedded structs</li>\n<li>Validation allows invalid input → Add more comprehensive test cases</li>\n<li>File path operations fail → Ensure proper path cleaning and validation</li>\n</ul>\n<h2 id=\"namespace-isolation-component\">Namespace Isolation Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Process Isolation with Namespaces) - This section implements the core isolation mechanisms that allow containers to have their own view of system resources while running on a shared kernel.</p>\n</blockquote>\n<h3 id=\"mental-model-separate-worlds\">Mental Model: Separate Worlds</h3>\n<p>Think of Linux namespaces as creating parallel universes for processes. Imagine you have a magical building where each apartment exists in its own dimension. From inside apartment 3B, the residents can only see their own rooms, their own mailbox labeled &quot;1&quot; (even though it&#39;s really mailbox 3B from the outside), and their own view out the windows. They have no idea that apartments 3A and 3C even exist - they think they&#39;re the only residents in the entire building.</p>\n<p>This is exactly how namespaces work for container processes. When a process runs inside a container, it lives in its own isolated world where:</p>\n<ul>\n<li>It thinks it&#39;s the only process running (PID namespace) and sees itself as process ID 1</li>\n<li>It has its own private filesystem that looks like a complete Linux system (mount namespace) </li>\n<li>It has its own network interfaces and IP addresses (network namespace)</li>\n<li>It can set its own hostname without affecting other containers (UTS namespace)</li>\n<li>It maps its user IDs differently from the host system (user namespace)</li>\n</ul>\n<p>The crucial insight is that these parallel worlds are created by the Linux kernel, not by copying actual resources. The kernel maintains a single set of processes, files, and network interfaces, but it presents different views of these resources to processes in different namespaces. When a container process asks &quot;what processes are running?&quot;, the kernel filters the answer to only show processes in the same PID namespace. When it asks &quot;what files exist in /bin?&quot;, the kernel shows files from the container&#39;s mount namespace, not the host&#39;s /bin directory.</p>\n<p>This isolation is both powerful and lightweight. Unlike virtual machines that duplicate entire operating systems, namespaces share the same kernel while providing complete isolation of the user-space view. The container process genuinely believes it&#39;s running on its own dedicated system, even though dozens of other containers might be running on the same physical machine.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fnamespace-isolation.svg\" alt=\"Namespace Isolation Layers\"></p>\n<h3 id=\"namespace-types-and-setup\">Namespace Types and Setup</h3>\n<p>Linux provides several namespace types, each isolating a different aspect of the system. Our container runtime needs to orchestrate the creation and configuration of multiple namespace types to provide complete process isolation.</p>\n<blockquote>\n<p><strong>Decision: Namespace Combination Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers need isolation across multiple system resources (processes, filesystems, network, hostname, IPC). We must decide whether to create all namespaces together or incrementally.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Create all namespaces atomically in a single system call</li>\n<li>Create namespaces incrementally as needed</li>\n<li>Create base namespaces first, then specialize</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Create all required namespaces atomically using a single <code>clone()</code> or <code>unshare()</code> call with combined flags</li>\n<li><strong>Rationale</strong>: Atomic creation prevents race conditions where a process exists in some namespaces but not others. It also simplifies error handling - either all namespaces are created successfully, or the operation fails completely.</li>\n<li><strong>Consequences</strong>: Simplifies the creation logic and eliminates partial failure states, but requires careful flag combination and may be less flexible for specialized container types.</li>\n</ul>\n</blockquote>\n<h4 id=\"pid-namespace-isolation\">PID Namespace Isolation</h4>\n<p>The <strong>PID namespace</strong> creates an isolated process tree where the container&#39;s first process becomes PID 1. This is fundamental to container isolation because it prevents containers from seeing or signaling processes on the host system.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Implementation Detail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Isolation Scope</td>\n<td>Process visibility and PID assignment</td>\n<td>Container processes only see processes within their PID namespace</td>\n</tr>\n<tr>\n<td>Creation Flag</td>\n<td><code>CLONE_NEWPID</code></td>\n<td>Used with <code>clone()</code>, <code>unshare()</code>, or <code>setns()</code> system calls</td>\n</tr>\n<tr>\n<td>First Process</td>\n<td>Becomes PID 1 in the new namespace</td>\n<td>Critical for proper init semantics and signal handling</td>\n</tr>\n<tr>\n<td>Process Tree</td>\n<td>Complete isolation from host process tree</td>\n<td><code>/proc</code> shows only namespace-local processes</td>\n</tr>\n<tr>\n<td>Signal Delivery</td>\n<td>Signals cannot cross namespace boundaries</td>\n<td>Prevents container processes from killing host processes</td>\n</tr>\n<tr>\n<td>Cleanup Behavior</td>\n<td>Namespace destroyed when last process exits</td>\n<td>Automatic cleanup prevents resource leaks</td>\n</tr>\n</tbody></table>\n<p>When we create a PID namespace, the first process spawned inside it becomes PID 1 from the container&#39;s perspective, even though it has a different PID on the host system. This PID 1 process has special responsibilities - it must reap zombie child processes and handle signals properly. If PID 1 dies, the entire namespace is destroyed and all processes within it are killed.</p>\n<p>The namespace creation sequence follows this algorithm:</p>\n<ol>\n<li>The runtime manager calls <code>clone()</code> with <code>CLONE_NEWPID</code> flag to create a new PID namespace</li>\n<li>The kernel creates a new PID namespace and assigns the cloned process PID 1 within that namespace</li>\n<li>The process mounts a new <code>/proc</code> filesystem to show only namespace-local processes</li>\n<li>Any child processes spawned within the namespace receive PIDs 2, 3, etc. from the container&#39;s perspective</li>\n<li>The namespace persists until the last process within it exits</li>\n</ol>\n<h4 id=\"mount-namespace-isolation\">Mount Namespace Isolation</h4>\n<p>The <strong>mount namespace</strong> provides each container with its own filesystem view, allowing containers to have different root filesystems, mount points, and filesystem hierarchies without affecting the host or other containers.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Implementation Detail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Isolation Scope</td>\n<td>Filesystem mounts and hierarchy</td>\n<td>Each namespace has independent mount table</td>\n</tr>\n<tr>\n<td>Creation Flag</td>\n<td><code>CLONE_NEWNS</code></td>\n<td>First namespace type introduced in Linux</td>\n</tr>\n<tr>\n<td>Root Filesystem</td>\n<td>Container sees its own root directory</td>\n<td>Achieved through <code>pivot_root()</code> or <code>chroot()</code></td>\n</tr>\n<tr>\n<td>Mount Propagation</td>\n<td>Controls how mounts spread between namespaces</td>\n<td>Can be shared, slave, or private</td>\n</tr>\n<tr>\n<td>Filesystem View</td>\n<td>Complete isolation of filesystem tree</td>\n<td>Container <code>/bin</code> different from host <code>/bin</code></td>\n</tr>\n<tr>\n<td>Cleanup Behavior</td>\n<td>Mounts automatically unmounted when namespace dies</td>\n<td>Prevents mount point leaks</td>\n</tr>\n</tbody></table>\n<p>Mount namespaces are particularly complex because they interact with the overlayfs layer management system. The runtime must coordinate between creating the mount namespace, preparing the overlay filesystem layers, and then switching the container&#39;s root filesystem to point to the merged overlay view.</p>\n<p>The mount namespace setup algorithm proceeds as follows:</p>\n<ol>\n<li>Create the mount namespace using <code>CLONE_NEWNS</code> flag during process creation</li>\n<li>Prepare the overlay filesystem by mounting the image layers (handled by the filesystem component)</li>\n<li>Create mount points for essential filesystems (<code>/proc</code>, <code>/sys</code>, <code>/dev</code>, <code>/tmp</code>)</li>\n<li>Execute <code>pivot_root()</code> to switch from the host root to the container root</li>\n<li>Mount essential pseudo-filesystems within the new root</li>\n<li>Unmount the old root filesystem to complete the isolation</li>\n</ol>\n<h4 id=\"network-namespace-isolation\">Network Namespace Isolation</h4>\n<p>The <strong>network namespace</strong> gives each container its own network stack, including network interfaces, IP addresses, routing tables, and firewall rules. This enables containers to have conflicting network configurations without interference.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Implementation Detail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Isolation Scope</td>\n<td>Complete network stack isolation</td>\n<td>Interfaces, routes, iptables rules, sockets</td>\n</tr>\n<tr>\n<td>Creation Flag</td>\n<td><code>CLONE_NEWNET</code></td>\n<td>Creates empty network namespace initially</td>\n</tr>\n<tr>\n<td>Initial State</td>\n<td>Only loopback interface present</td>\n<td>All other interfaces must be added explicitly</td>\n</tr>\n<tr>\n<td>Interface Assignment</td>\n<td>Physical or virtual interfaces moved into namespace</td>\n<td>Typically uses veth pairs</td>\n</tr>\n<tr>\n<td>IP Configuration</td>\n<td>Independent IP addresses and routing</td>\n<td>Configured via netlink or ip command</td>\n</tr>\n<tr>\n<td>Connectivity</td>\n<td>Requires explicit bridge/routing setup</td>\n<td>Handled by network management component</td>\n</tr>\n</tbody></table>\n<p>A new network namespace starts completely empty except for the loopback interface. This means containers have no network connectivity until we explicitly configure interfaces, IP addresses, and routing. The network management component handles creating veth pairs and connecting them to bridge networks.</p>\n<p>Network namespace setup follows this sequence:</p>\n<ol>\n<li>Create network namespace with <code>CLONE_NEWNET</code> during container process creation</li>\n<li>Network management component creates a veth pair (virtual ethernet cable)</li>\n<li>One end of veth pair moved into container namespace, other end remains on host</li>\n<li>Container end configured with IP address from allocated subnet</li>\n<li>Host end connected to bridge network for inter-container communication</li>\n<li>Routing rules configured to enable container network access</li>\n</ol>\n<h4 id=\"uts-namespace-isolation\">UTS Namespace Isolation</h4>\n<p>The <strong>UTS namespace</strong> (UNIX Time Sharing) isolates hostname and domain name, allowing each container to have its own system identity without affecting the host or other containers.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Implementation Detail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Isolation Scope</td>\n<td>Hostname and NIS domain name</td>\n<td>System calls like <code>gethostname()</code> return namespace-local values</td>\n</tr>\n<tr>\n<td>Creation Flag</td>\n<td><code>CLONE_NEWUTS</code></td>\n<td>Lightweight namespace with minimal overhead</td>\n</tr>\n<tr>\n<td>Initial State</td>\n<td>Inherits hostname from parent namespace</td>\n<td>Can be changed independently afterward</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Set via <code>sethostname()</code> system call</td>\n<td>Typically set from container specification</td>\n</tr>\n<tr>\n<td>Use Cases</td>\n<td>Service discovery, logging, application configuration</td>\n<td>Many applications use hostname for identification</td>\n</tr>\n<tr>\n<td>Cleanup</td>\n<td>Automatic when namespace destroyed</td>\n<td>No persistent state to clean up</td>\n</tr>\n</tbody></table>\n<p>UTS namespaces are relatively simple but important for application compatibility. Many applications expect to run on systems with specific hostnames, and service discovery systems often use hostnames for routing and identification.</p>\n<h4 id=\"user-namespace-isolation\">User Namespace Isolation</h4>\n<p>The <strong>user namespace</strong> maps user and group IDs between the container and host system, enabling privilege separation and allowing containers to run as root inside the namespace while being unprivileged on the host.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Description</th>\n<th>Implementation Detail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Isolation Scope</td>\n<td>User ID and group ID mappings</td>\n<td>UID 0 inside container may be UID 1000 on host</td>\n</tr>\n<tr>\n<td>Creation Flag</td>\n<td><code>CLONE_NEWUSER</code></td>\n<td>Most complex namespace to configure correctly</td>\n</tr>\n<tr>\n<td>UID Mapping</td>\n<td>Maps container UIDs to host UIDs</td>\n<td>Written to <code>/proc/[pid]/uid_map</code></td>\n</tr>\n<tr>\n<td>GID Mapping</td>\n<td>Maps container GIDs to host GIDs</td>\n<td>Written to <code>/proc/[pid]/gid_map</code></td>\n</tr>\n<tr>\n<td>Capabilities</td>\n<td>Grants capabilities within the namespace</td>\n<td>Container root has limited capabilities on host</td>\n</tr>\n<tr>\n<td>Security Benefit</td>\n<td>Unprivileged containers possible</td>\n<td>Container breakout results in unprivileged host access</td>\n</tr>\n</tbody></table>\n<p>User namespaces are crucial for security but complex to configure. They require setting up UID and GID mappings that define how user identities translate between the container and host perspectives.</p>\n<blockquote>\n<p><strong>Architecture Decision: User Namespace Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: User namespaces require complex UID/GID mapping setup and have implications for file permissions and capabilities</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Always enable user namespaces for maximum security</li>\n<li>Make user namespaces optional with configuration flag</li>\n<li>Skip user namespaces to simplify implementation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Make user namespaces optional but provide clear configuration interface</li>\n<li><strong>Rationale</strong>: User namespaces significantly improve security but add complexity and may cause permission issues with mounted volumes. Making them optional allows users to choose the right security/complexity tradeoff.</li>\n<li><strong>Consequences</strong>: More secure when enabled but requires careful UID/GID mapping configuration. File ownership issues may arise when sharing files between host and container.</li>\n</ul>\n</blockquote>\n<h3 id=\"namespace-creation-implementation\">Namespace Creation Implementation</h3>\n<p>The namespace creation process requires careful coordination of multiple system calls and proper error handling to ensure consistent state.</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Action</th>\n<th>System Call</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Prepare namespace flags</td>\n<td>Bitwise OR of <code>CLONE_NEW*</code> constants</td>\n<td>Validate flag combinations</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Create namespaces</td>\n<td><code>clone()</code> or <code>unshare()</code></td>\n<td>Clean up partial namespaces on failure</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Configure user mappings</td>\n<td>Write to <code>/proc/[pid]/uid_map</code></td>\n<td>Verify mapping is valid and applied</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Set up network interfaces</td>\n<td><code>netlink</code> socket operations</td>\n<td>Remove interfaces on failure</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Mount essential filesystems</td>\n<td><code>mount()</code> system calls</td>\n<td>Unmount on failure</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Execute pivot_root</td>\n<td><code>pivot_root()</code> system call</td>\n<td>Restore original root on failure</td>\n</tr>\n</tbody></table>\n<p>The implementation must handle partial failures gracefully. If namespace creation succeeds but subsequent configuration fails, we must clean up the created namespaces to avoid resource leaks.</p>\n<h3 id=\"filesystem-pivot-process\">Filesystem Pivot Process</h3>\n<p>The filesystem pivot process switches the container&#39;s root filesystem from the host root to the container&#39;s isolated filesystem. This is more complex than a simple <code>chroot()</code> because it must handle overlayfs mounts and ensure proper cleanup of the old root.</p>\n<blockquote>\n<p><strong>Decision: pivot_root vs chroot</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to change container&#39;s root filesystem to isolated overlay mount</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Use <code>chroot()</code> system call for simplicity</li>\n<li>Use <code>pivot_root()</code> system call for proper isolation</li>\n<li>Use bind mounts to create filesystem view</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>pivot_root()</code> for complete root filesystem replacement</li>\n<li><strong>Rationale</strong>: <code>chroot()</code> is easily escaped by processes with sufficient privileges and doesn&#39;t properly isolate the old root. <code>pivot_root()</code> provides complete isolation and allows proper cleanup of the old root filesystem.</li>\n<li><strong>Consequences</strong>: More complex implementation but much better security isolation. Requires careful mount point setup and cleanup procedures.</li>\n</ul>\n</blockquote>\n<h4 id=\"pivot-root-algorithm\">Pivot Root Algorithm</h4>\n<p>The pivot root process must be executed in precise order to avoid mount point conflicts and ensure proper isolation:</p>\n<ol>\n<li><p><strong>Verify mount namespace isolation</strong>: Confirm the container process is running in its own mount namespace, isolated from the host mount table. This prevents pivot_root operations from affecting the host filesystem.</p>\n</li>\n<li><p><strong>Prepare overlay filesystem mount</strong>: The filesystem management component must have already created the overlay mount combining image layers. Verify this mount exists and is accessible at the expected path (typically <code>/var/lib/container-runtime/overlay/[container-id]/merged</code>).</p>\n</li>\n<li><p><strong>Create old root mount point</strong>: Inside the new root filesystem, create a directory that will hold the old root temporarily. This is typically <code>/old-root</code> or <code>/mnt/old-root</code>. This directory must exist in the overlay filesystem before pivot_root.</p>\n</li>\n<li><p><strong>Execute pivot_root system call</strong>: Call <code>pivot_root(new_root, old_root)</code> where <code>new_root</code> is the overlay merged directory and <code>old_root</code> is the temporary mount point created in step 3. This atomically swaps the root filesystem.</p>\n</li>\n<li><p><strong>Change working directory</strong>: Immediately after pivot_root, change the current working directory to <code>/</code> in the new root to ensure no processes are holding references to the old root filesystem.</p>\n</li>\n<li><p><strong>Mount essential pseudo-filesystems</strong>: Mount <code>/proc</code>, <code>/sys</code>, <code>/dev</code>, and <code>/tmp</code> within the new root. These are essential for proper container operation and must be mounted after the pivot to ensure they reflect the container&#39;s namespace state.</p>\n</li>\n<li><p><strong>Unmount old root</strong>: Unmount the old root filesystem that is now accessible under the temporary mount point. This completes the isolation and prevents the container from accessing host filesystem paths.</p>\n</li>\n<li><p><strong>Remove old root mount point</strong>: Delete the temporary directory used to hold the old root, completing the cleanup process.</p>\n</li>\n</ol>\n<h4 id=\"mount-point-requirements\">Mount Point Requirements</h4>\n<p>The pivot_root operation has strict requirements that commonly cause failures:</p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Explanation</th>\n<th>Common Failure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>New root must be a mount point</td>\n<td>The target directory must be a filesystem mount, not just a directory</td>\n<td>Using a regular directory causes <code>EINVAL</code></td>\n</tr>\n<tr>\n<td>Old root must be under new root</td>\n<td>The old root mount point must be a subdirectory of the new root</td>\n<td>Placing old root outside new root causes <code>EINVAL</code></td>\n</tr>\n<tr>\n<td>Both must be on different filesystems</td>\n<td>New root and old root cannot be the same filesystem</td>\n<td>Using bind mounts of same filesystem causes <code>EBUSY</code></td>\n</tr>\n<tr>\n<td>No processes using old root</td>\n<td>No process can have working directory or open files in old root</td>\n<td>Active processes cause <code>EBUSY</code></td>\n</tr>\n<tr>\n<td>Mount namespace must be private</td>\n<td>Mount propagation must not affect other namespaces</td>\n<td>Shared mounts can cause <code>EINVAL</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"essential-filesystem-mounts\">Essential Filesystem Mounts</h4>\n<p>After pivot_root completes, the container needs several pseudo-filesystems mounted to function properly:</p>\n<table>\n<thead>\n<tr>\n<th>Mount Point</th>\n<th>Filesystem Type</th>\n<th>Purpose</th>\n<th>Mount Options</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>/proc</code></td>\n<td><code>proc</code></td>\n<td>Process information and system interfaces</td>\n<td><code>nosuid,nodev,noexec</code></td>\n</tr>\n<tr>\n<td><code>/sys</code></td>\n<td><code>sysfs</code></td>\n<td>System device and driver information</td>\n<td><code>nosuid,nodev,noexec,ro</code></td>\n</tr>\n<tr>\n<td><code>/dev</code></td>\n<td><code>tmpfs</code></td>\n<td>Device nodes for container</td>\n<td><code>nosuid,strictatime,mode=755</code></td>\n</tr>\n<tr>\n<td><code>/dev/pts</code></td>\n<td><code>devpts</code></td>\n<td>Pseudo-terminal devices</td>\n<td><code>nosuid,noexec,newinstance,ptmxmode=0666</code></td>\n</tr>\n<tr>\n<td><code>/tmp</code></td>\n<td><code>tmpfs</code></td>\n<td>Temporary file storage</td>\n<td><code>nosuid,nodev,noexec</code></td>\n</tr>\n</tbody></table>\n<p>The <code>/proc</code> mount is particularly critical because many container processes depend on <code>/proc/self/</code> for introspection and <code>/proc/[pid]/</code> for process management. Without proper <code>/proc</code> mounting, tools like <code>ps</code>, <code>top</code>, and many application health checks will fail.</p>\n<h3 id=\"common-namespace-pitfalls\">Common Namespace Pitfalls</h3>\n<p>Namespace creation and management involves several subtle failure modes that can cause containers to behave incorrectly or fail to start. Understanding these pitfalls helps avoid hours of debugging mysterious container failures.</p>\n<h4 id=\"-pitfall-mount-point-requirements-for-pivot_root\">⚠️ <strong>Pitfall: Mount Point Requirements for pivot_root</strong></h4>\n<p><strong>Problem</strong>: The most common failure when implementing pivot_root is violating the kernel&#39;s strict requirements for the operation. The error message <code>EINVAL</code> from pivot_root provides no specific information about which requirement was violated.</p>\n<p><strong>Specific Failure Scenarios</strong>:</p>\n<ul>\n<li>Attempting pivot_root where the new root is not a mount point (just a regular directory)</li>\n<li>Creating the old root directory outside the new root filesystem</li>\n<li>Using the same filesystem for both old and new root (common with bind mounts)</li>\n<li>Running pivot_root while processes have the old root as their working directory</li>\n</ul>\n<p><strong>Why This Breaks</strong>: The kernel enforces these requirements to prevent filesystem inconsistencies and ensure proper cleanup. pivot_root must atomically swap roots while maintaining filesystem integrity.</p>\n<p><strong>Detection</strong>: Check return value of pivot_root system call. <code>EINVAL</code> typically indicates requirement violation, <code>EBUSY</code> indicates active processes using the old root.</p>\n<p><strong>Fix Implementation</strong>:</p>\n<ol>\n<li>Always ensure new root is a proper mount (overlayfs mount, not bind mount of directory)</li>\n<li>Create old root directory inside the new root before calling pivot_root  </li>\n<li>Use <code>fchdir()</code> to change working directory immediately before pivot_root</li>\n<li>Verify no child processes are running with old root as working directory</li>\n</ol>\n<h4 id=\"-pitfall-missing-proc-mount-in-pid-namespace\">⚠️ <strong>Pitfall: Missing /proc Mount in PID Namespace</strong></h4>\n<p><strong>Problem</strong>: After creating a PID namespace, many tools and applications break because <code>/proc</code> still shows the host&#39;s process tree instead of the container&#39;s isolated process view.</p>\n<p><strong>Specific Symptoms</strong>:</p>\n<ul>\n<li><code>ps aux</code> shows all host processes instead of only container processes</li>\n<li>Process tools report wrong PID numbers </li>\n<li>Applications that read <code>/proc/self/</code> get incorrect information</li>\n<li>Init systems fail to manage processes properly</li>\n</ul>\n<p><strong>Why This Breaks</strong>: The <code>/proc</code> filesystem is not automatically updated when entering a new PID namespace. The old <code>/proc</code> mount continues to show the original namespace&#39;s process tree. Applications expect <code>/proc</code> to reflect the current namespace state.</p>\n<p><strong>Detection</strong>: After namespace creation, check if <code>/proc/1/</code> exists and points to the container&#39;s init process, not a host process.</p>\n<p><strong>Fix Implementation</strong>:</p>\n<ol>\n<li>Unmount existing <code>/proc</code> after entering PID namespace: <code>umount(&quot;/proc&quot;)</code></li>\n<li>Mount new proc for the namespace: <code>mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL)</code></li>\n<li>Verify mount shows correct PID namespace view by checking <code>/proc/1/</code> exists</li>\n<li>Ensure mount happens after pivot_root to get correct namespace perspective</li>\n</ol>\n<h4 id=\"-pitfall-user-namespace-uid-mapping-race-condition\">⚠️ <strong>Pitfall: User Namespace UID Mapping Race Condition</strong></h4>\n<p><strong>Problem</strong>: User namespaces start with no UID/GID mappings configured, during which time the process has no privileges and many operations fail with permission errors.</p>\n<p><strong>Specific Failure Scenarios</strong>:</p>\n<ul>\n<li>Process creation fails immediately after user namespace creation</li>\n<li>File operations fail with <code>EACCES</code> even for files the process should access</li>\n<li>Capability checks fail unexpectedly for operations that should succeed</li>\n<li>Race condition where container process starts before UID mapping is written</li>\n</ul>\n<p><strong>Why This Breaks</strong>: User namespaces begin in a state where no UIDs or GIDs are valid. The kernel rejects most privileged operations until <code>/proc/[pid]/uid_map</code> and <code>/proc/[pid]/gid_map</code> are properly configured.</p>\n<p><strong>Detection</strong>: Check if UID mapping files are empty or missing after user namespace creation. Operations failing with <code>EACCES</code> immediately after namespace creation indicate mapping issues.</p>\n<p><strong>Fix Implementation</strong>:</p>\n<ol>\n<li>Create user namespace but don&#39;t execute container command immediately</li>\n<li>Parent process writes UID mapping to <code>/proc/[child-pid]/uid_map</code></li>\n<li>Parent process writes GID mapping to <code>/proc/[child-pid]/gid_map</code>  </li>\n<li>Use synchronization (pipe or signal) to ensure child waits for mapping completion</li>\n<li>Child process verifies mappings are applied before proceeding with container setup</li>\n</ol>\n<h4 id=\"-pitfall-network-namespace-connectivity-loss\">⚠️ <strong>Pitfall: Network Namespace Connectivity Loss</strong></h4>\n<p><strong>Problem</strong>: New network namespaces contain only a loopback interface, leaving containers with no network connectivity unless explicitly configured.</p>\n<p><strong>Specific Symptoms</strong>:</p>\n<ul>\n<li>Container cannot reach external networks or other containers</li>\n<li>DNS resolution fails completely</li>\n<li>Network tools show only <code>lo</code> interface</li>\n<li>Applications fail with &quot;network unreachable&quot; errors</li>\n</ul>\n<p><strong>Why This Breaks</strong>: Network namespace isolation is complete - containers get an empty network stack. Unlike other namespaces that inherit some functionality, network namespaces require explicit configuration for connectivity.</p>\n<p><strong>Detection</strong>: Run <code>ip link show</code> inside container - should show only loopback interface if networking not configured properly.</p>\n<p><strong>Fix Implementation</strong>:</p>\n<ol>\n<li>Create veth pair before container starts: one end for container, one for host</li>\n<li>Move container veth end into container&#39;s network namespace</li>\n<li>Configure IP address on container&#39;s veth interface  </li>\n<li>Connect host veth end to bridge network for routing</li>\n<li>Verify connectivity with ping test before declaring container ready</li>\n</ol>\n<h4 id=\"-pitfall-incomplete-namespace-cleanup-on-failure\">⚠️ <strong>Pitfall: Incomplete Namespace Cleanup on Failure</strong></h4>\n<p><strong>Problem</strong>: When container creation fails partway through namespace setup, partially created namespaces may persist and leak resources or cause conflicts for subsequent containers.</p>\n<p><strong>Specific Failure Scenarios</strong>:</p>\n<ul>\n<li>Process dies after creating some namespaces but before joining all namespaces</li>\n<li>Mount operations fail leaving orphaned mount points</li>\n<li>Network interfaces created but not properly associated with namespaces</li>\n<li>Cgroup directories created but not cleaned up when namespace creation fails</li>\n</ul>\n<p><strong>Why This Breaks</strong>: Namespace creation involves multiple system calls that can fail independently. Each successful step allocates kernel resources that must be explicitly cleaned up if later steps fail.</p>\n<p><strong>Detection</strong>: Check for orphaned mount points in <code>/proc/mounts</code>, unused network interfaces with <code>ip link show</code>, and leaked cgroup directories under <code>/sys/fs/cgroup/</code>.</p>\n<p><strong>Fix Implementation</strong>:</p>\n<ol>\n<li>Track all created namespaces and resources in container state</li>\n<li>Implement rollback logic that undoes successful operations when later operations fail</li>\n<li>Use defer-style cleanup in implementation language to ensure cleanup runs</li>\n<li>Test failure scenarios explicitly to verify cleanup works correctly</li>\n<li>Monitor for resource leaks in integration tests</li>\n</ol>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace Creation</td>\n<td>Direct system calls with <code>golang.org/x/sys/unix</code></td>\n<td>Higher-level library like <code>github.com/opencontainers/runc/libcontainer</code></td>\n</tr>\n<tr>\n<td>Mount Operations</td>\n<td>Standard <code>mount()</code> syscalls</td>\n<td><code>github.com/moby/sys/mount</code> for advanced mount handling</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td><code>os.Process</code> with manual PID tracking</td>\n<td>Process group management with <code>golang.org/x/sys/unix</code></td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Basic error checking and logging</td>\n<td>Structured error types with detailed context</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The namespace isolation component should be organized as a focused module within the container runtime:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/namespace/\n├── namespace.go           ← main namespace manager interface\n├── isolation.go          ← namespace creation and setup logic  \n├── pivot.go              ← filesystem pivot_root implementation\n├── cleanup.go            ← namespace cleanup and resource management\n├── types.go              ← namespace-related type definitions\n└── namespace_test.go     ← comprehensive namespace isolation tests\n\ninternal/container/\n├── manager.go            ← calls namespace component for isolation\n└── state.go              ← tracks namespace handles for cleanup\n\ncmd/container-runtime/\n└── main.go               ← integrates namespace manager</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>This complete namespace manager provides the foundational structure for namespace isolation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespace/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NamespaceType represents different Linux namespace types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NamespaceType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PIDNamespace</span><span style=\"color:#B392F0\"> NamespaceType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MountNamespace</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NetworkNamespace</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UTSNamespace</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UserNamespace</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IPCNamespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NamespaceConfig defines which namespaces to create and their configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NamespaceConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnablePID     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableMount   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableNetwork </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableUTS     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableUser    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableIPC     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // User namespace mappings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UIDMappings []</span><span style=\"color:#B392F0\">UIDMapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GIDMappings []</span><span style=\"color:#B392F0\">GIDMapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // UTS configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Hostname </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Domain   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UIDMapping defines user ID mapping for user namespaces</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UIDMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // UID inside container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostID      </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // UID on host system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Size        </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Range of IDs to map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GIDMapping defines group ID mapping for user namespaces  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GIDMapping</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // GID inside container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HostID      </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // GID on host system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Size        </span><span style=\"color:#F97583\">uint32</span><span style=\"color:#6A737D\">  // Range of IDs to map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NamespaceHandle tracks created namespaces for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NamespaceHandle</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PID         </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">       // Process ID in new namespaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NamespaceTypes []</span><span style=\"color:#B392F0\">NamespaceType</span><span style=\"color:#6A737D\"> // Which namespaces were created</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\"> // When namespaces were created</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OverlayPath </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Path to overlay filesystem mount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkNS   </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">    // Network namespace identifier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespace/namespace.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager handles namespace creation and lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overlayRoot </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bridgeName  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Runtime state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeNamespaces </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceHandle</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewManager creates a new namespace manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">overlayRoot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bridgeName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        overlayRoot:      overlayRoot,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bridgeName:       bridgeName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeNamespaces: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceHandle</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateNamespaces creates isolated namespaces according to configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">NamespaceConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceHandle</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build namespace flags</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flags </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> namespaceTypes []</span><span style=\"color:#B392F0\">NamespaceType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnablePID {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> unix.CLONE_NEWPID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespaceTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(namespaceTypes, PIDNamespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableMount {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> unix.CLONE_NEWNS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespaceTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(namespaceTypes, MountNamespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableNetwork {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> unix.CLONE_NEWNET</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespaceTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(namespaceTypes, NetworkNamespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableUTS {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> unix.CLONE_NEWUTS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespaceTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(namespaceTypes, UTSNamespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableUser {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> unix.CLONE_NEWUSER</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespaceTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(namespaceTypes, UserNamespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableIPC {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        flags </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> unix.CLONE_NEWIPC</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespaceTypes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(namespaceTypes, IPCNamespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create pipe for parent-child synchronization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    readFD, writeFD, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Pipe</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create sync pipe: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> readFD.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> writeFD.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fork process with new namespaces</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pid, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> unix.</span><span style=\"color:#B392F0\">ForkExec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/proc/self/exe\"</span><span style=\"color:#E1E4E8\">, []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"container-runtime\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"namespace-init\"</span><span style=\"color:#E1E4E8\">}, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        &#x26;</span><span style=\"color:#B392F0\">unix</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ProcAttr</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Files: []</span><span style=\"color:#F97583\">uintptr</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, writeFD.</span><span style=\"color:#B392F0\">Fd</span><span style=\"color:#E1E4E8\">()},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Sys:   </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">unix</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SysProcAttr</span><span style=\"color:#E1E4E8\">{Cloneflags: </span><span style=\"color:#F97583\">uintptr</span><span style=\"color:#E1E4E8\">(flags)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create namespaces: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handle </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NamespaceHandle</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PID:            pid,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        NamespaceTypes: namespaceTypes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CreatedAt:      time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        NetworkNS:      fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"netns-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, containerID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure user namespace mappings if enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.EnableUser {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.</span><span style=\"color:#B392F0\">configureUserNamespace</span><span style=\"color:#E1E4E8\">(pid, config.UIDMappings, config.GIDMappings); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m.</span><span style=\"color:#B392F0\">CleanupNamespaces</span><span style=\"color:#E1E4E8\">(handle)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to configure user namespace: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Signal child process that setup is complete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    writeFD.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ready\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.activeNamespaces[containerID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> handle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> handle, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>The following functions provide the structure for namespace isolation implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespace/isolation.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// configureUserNamespace sets up UID/GID mappings for user namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">configureUserNamespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">uidMaps</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">UIDMapping</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">gidMaps</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">GIDMapping</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Open /proc/[pid]/uid_map file for writing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Write each UID mapping in format \"container_id host_id size\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Open /proc/[pid]/gid_map file for writing  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Write each GID mapping in format \"container_id host_id size\\n\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify mappings were applied by reading back the files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Must write \"deny\" to /proc/[pid]/setgroups before writing gid_map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"configureUserNamespace not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// setupEssentialMounts creates required filesystem mounts in container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">setupEssentialMounts</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Mount /proc filesystem with mount(\"proc\", \"/proc\", \"proc\", 0, \"\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Mount /sys filesystem read-only for container safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create /dev as tmpfs and populate essential device nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Mount /dev/pts for terminal support  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create /tmp as tmpfs for temporary file storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify all mounts succeeded and are accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use unix.Mount() with appropriate flags for each filesystem type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"setupEssentialMounts not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// configureHostname sets container hostname in UTS namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">configureHostname</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">hostname</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">domain</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate hostname format (RFC compliance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Call unix.Sethostname() to set hostname in UTS namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call unix.Setdomainname() to set domain if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify hostname was set by reading back with unix.Gethostname()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Hostname changes only affect the current UTS namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"configureHostname not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespace/pivot.go  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecutePivotRoot switches container root filesystem using pivot_root</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecutePivotRoot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">newRoot</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify newRoot is a mount point (check /proc/mounts)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create old root directory inside newRoot (typically /old-root)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Change current directory to newRoot to avoid EBUSY</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call unix.PivotRoot(newRoot, oldRootPath) system call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Change directory to / in the new root filesystem  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Unmount old root filesystem to complete isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Remove old root directory to clean up mount point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: pivot_root requires new root to be mount point, old root under new root</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ExecutePivotRoot not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// prepareOverlayMount creates overlay filesystem from image layers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">prepareOverlayMount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">layers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create overlay directories: lower, upper, work, merged</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Format overlay mount options with lower layers separated by colons</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Mount overlayfs with mount(\"overlay\", merged, \"overlay\", 0, options)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify merged directory shows combined layer content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return path to merged directory for use as new root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Overlay options format: \"lowerdir=layer1:layer2,upperdir=upper,workdir=work\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"prepareOverlayMount not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// validateMountPoint checks if path is a filesystem mount point</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validateMountPoint</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get filesystem stat info for the path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Get filesystem stat info for path's parent directory  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare device IDs - different devices means mount point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Also check /proc/mounts for explicit mount entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use unix.Stat() and compare st.Dev fields for device ID check</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"validateMountPoint not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/namespace/cleanup.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> namespace</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">golang.org/x/sys/unix</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupNamespaces removes container namespaces and associated resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupNamespaces</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">handle</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">NamespaceHandle</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Send SIGTERM to container process to request graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait up to 10 seconds for process to exit voluntarily  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send SIGKILL if process hasn't exited after timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Unmount overlay filesystem if it was mounted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove overlay directories (upper, work, merged)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clean up any remaining mount points in namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Remove handle from activeNamespaces map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use unix.Kill() for signals, unix.Wait4() for process cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"CleanupNamespaces not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cleanupMounts removes all mounts associated with container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">cleanupMounts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">overlayPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read /proc/mounts to find all mounts under overlay path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Unmount each mount point in reverse order (deepest first)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Use MNT_DETACH flag for lazy unmounting if normal unmount fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove empty directories after successful unmount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify no mount points remain under overlay path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Must unmount child mounts before parent mounts to avoid EBUSY</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cleanupMounts not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// killProcessTree terminates all processes in container namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">killProcessTree</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">signal</span><span style=\"color:#B392F0\"> syscall</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Signal</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find all processes in same PID namespace as container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send specified signal to each process in namespace  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Wait for processes to exit after SIGTERM</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Force kill with SIGKILL if processes don't exit gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify all namespace processes have exited</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Read /proc/[pid]/ns/pid to identify processes in same namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"killProcessTree not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing the namespace isolation component, verify correct behavior with these checkpoints:</p>\n<p><strong>Checkpoint 1: PID Namespace Isolation</strong></p>\n<ul>\n<li>Run: <code>go test -run TestPIDNamespace ./internal/namespace/</code></li>\n<li>Expected: Container process sees itself as PID 1, cannot see host processes</li>\n<li>Manual test: Create container and run <code>ps aux</code> - should show only container processes</li>\n<li>Failure signs: Seeing host processes indicates PID namespace not created or /proc not remounted</li>\n</ul>\n<p><strong>Checkpoint 2: Mount Namespace and Pivot Root</strong>  </p>\n<ul>\n<li>Run: <code>go test -run TestMountNamespace ./internal/namespace/</code></li>\n<li>Expected: Container has isolated filesystem view with overlay layers</li>\n<li>Manual test: Container <code>/bin</code> should differ from host <code>/bin</code> directory</li>\n<li>Failure signs: &quot;EINVAL from pivot_root&quot; means mount point requirements not met</li>\n</ul>\n<p><strong>Checkpoint 3: Network Namespace Isolation</strong></p>\n<ul>\n<li>Run: <code>go test -run TestNetworkNamespace ./internal/namespace/</code></li>\n<li>Expected: Container starts with only loopback interface</li>\n<li>Manual test: Run <code>ip link show</code> in container - should show only <code>lo</code> interface initially</li>\n<li>Failure signs: Seeing host network interfaces means network namespace not created</li>\n</ul>\n<p><strong>Checkpoint 4: Complete Namespace Integration</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/namespace/</code>  </li>\n<li>Expected: All namespace types work together without conflicts</li>\n<li>Manual test: Start container with all namespaces and verify isolation</li>\n<li>Failure signs: Resource leaks, mount point conflicts, or partial isolation indicate cleanup issues</li>\n</ul>\n<h2 id=\"resource-control-component\">Resource Control Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Resource Limits with Cgroups) - This section implements CPU, memory, and I/O limits using cgroups v2 for container resource control, along with resource monitoring and out-of-memory handling.</p>\n</blockquote>\n<h3 id=\"mental-model-resource-budget-manager\">Mental Model: Resource Budget Manager</h3>\n<p>Think of cgroups like a family budget manager that allocates monthly allowances to children. Just as parents set spending limits for each child (clothing budget, entertainment budget, snack budget), cgroups set resource limits for each container (memory budget, CPU budget, disk I/O budget). When a child tries to spend more than their allowance, the budget manager either denies the purchase or finds emergency funds from elsewhere. Similarly, when a container tries to use more resources than allocated, cgroups either deny the request (causing the process to wait or fail) or trigger emergency actions like killing the process.</p>\n<p>The budget manager also tracks spending throughout the month, sending warnings when a child approaches their limit (&quot;You&#39;ve spent 80% of your entertainment budget&quot;). Cgroups provide the same visibility, exposing current resource usage so the container runtime can monitor consumption and warn about approaching limits. Just as the family budget ensures no single child monopolizes the household income, cgroups ensure no single container starves other containers of system resources.</p>\n<p>This analogy extends to hierarchical budgets: a family might allocate 40% of income to children&#39;s allowances, then subdivide that among individual children. Cgroups work similarly with hierarchical resource allocation, where you might dedicate 50% of system memory to containers, then divide that pool among individual containers based on their priority and requirements.</p>\n<h3 id=\"cgroup-controller-configuration\">Cgroup Controller Configuration</h3>\n<p>The <strong>cgroup controller configuration</strong> component manages resource limits by interfacing with the Linux cgroups v2 unified hierarchy. Each controller manages a specific resource type and exposes configuration files in <code>/sys/fs/cgroup</code> that define limits, track usage, and trigger enforcement actions.</p>\n<blockquote>\n<p><strong>Decision: Cgroups v2 Over Cgroups v1</strong></p>\n<ul>\n<li><strong>Context</strong>: Linux systems support both cgroups v1 (legacy) and cgroups v2 (modern) interfaces for resource control, with different APIs and capabilities.</li>\n<li><strong>Options Considered</strong>: Use cgroups v1 for broader compatibility, use cgroups v2 for modern features, support both versions with abstraction layer.</li>\n<li><strong>Decision</strong>: Use cgroups v2 unified hierarchy exclusively.</li>\n<li><strong>Rationale</strong>: Cgroups v2 provides unified hierarchy (single tree instead of per-controller trees), better memory accounting, improved CPU isolation, and simplified configuration. Modern distributions default to v2, and v1 is deprecated. The learning value comes from understanding modern kernel interfaces.</li>\n<li><strong>Consequences</strong>: Requires kernel 4.5+ and systemd systems with cgroups v2 enabled. Simpler implementation with unified interface, but incompatible with older systems using v1-only setups.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cgroups v1</td>\n<td>Broader compatibility, extensive documentation</td>\n<td>Complex multi-hierarchy design, deprecated, limited features</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Cgroups v2</td>\n<td>Modern unified hierarchy, better accounting, future-proof</td>\n<td>Requires newer kernels, some tools still v1-only</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Support Both</td>\n<td>Maximum compatibility</td>\n<td>Complex abstraction, doubles testing burden</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>The cgroup controller system creates a dedicated cgroup for each container under <code>/sys/fs/cgroup/container-runtime/[container-id]</code> and enables specific controllers based on the container&#39;s <code>ResourceLimits</code> specification. The system writes configuration values to controller-specific files and monitors usage through statistics files.</p>\n<h4 id=\"memory-controller-configuration\">Memory Controller Configuration</h4>\n<p>The <strong>memory controller</strong> enforces memory limits using the <code>memory.max</code> interface, which provides hard memory capping with configurable out-of-memory behavior. When a container approaches its memory limit, the kernel memory reclaim system attempts to free memory through page cache eviction and swap-out. If reclaim cannot free sufficient memory, the OOM killer terminates processes within the cgroup.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration File</th>\n<th>Purpose</th>\n<th>Format</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>memory.max</code></td>\n<td>Hard memory limit</td>\n<td>Integer bytes or &quot;max&quot;</td>\n<td><code>536870912</code> (512MB)</td>\n</tr>\n<tr>\n<td><code>memory.high</code></td>\n<td>Soft limit triggering reclaim</td>\n<td>Integer bytes or &quot;max&quot;</td>\n<td><code>402653184</code> (384MB)</td>\n</tr>\n<tr>\n<td><code>memory.swap.max</code></td>\n<td>Swap space limit</td>\n<td>Integer bytes or &quot;max&quot;</td>\n<td><code>134217728</code> (128MB)</td>\n</tr>\n<tr>\n<td><code>memory.oom.group</code></td>\n<td>OOM kill entire cgroup</td>\n<td>0 or 1</td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td><code>memory.current</code></td>\n<td>Current memory usage (read-only)</td>\n<td>Integer bytes</td>\n<td><code>123456789</code></td>\n</tr>\n<tr>\n<td><code>memory.peak</code></td>\n<td>Peak memory usage since creation</td>\n<td>Integer bytes</td>\n<td><code>234567890</code></td>\n</tr>\n</tbody></table>\n<p>The memory controller setup process follows these steps:</p>\n<ol>\n<li>Enable the memory controller by writing <code>+memory</code> to the parent cgroup&#39;s <code>cgroup.subtree_control</code> file</li>\n<li>Create the container-specific cgroup directory under the container runtime&#39;s cgroup hierarchy</li>\n<li>Write the hard memory limit from <code>ResourceLimits.Memory</code> to <code>memory.max</code></li>\n<li>Set the soft limit to 75% of hard limit in <code>memory.high</code> to trigger early memory pressure</li>\n<li>Configure swap limits based on container specification or disable swap entirely for predictable behavior</li>\n<li>Enable group OOM killing to ensure related processes are cleaned up together</li>\n</ol>\n<blockquote>\n<p>Memory limits without corresponding swap limits can allow containers to exceed their intended memory budget by using swap space. Always configure both memory.max and memory.swap.max for predictable resource enforcement.</p>\n</blockquote>\n<h4 id=\"cpu-controller-configuration\">CPU Controller Configuration</h4>\n<p>The <strong>CPU controller</strong> implements CPU bandwidth limiting using the Completely Fair Scheduler (CFS) quota mechanism. Instead of CPU priority or weight-based sharing, the controller enforces hard CPU time limits by allocating specific microseconds of CPU time per scheduling period.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration File</th>\n<th>Purpose</th>\n<th>Format</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cpu.max</code></td>\n<td>CPU quota and period</td>\n<td>&quot;quota period&quot; or &quot;max&quot;</td>\n<td><code>50000 100000</code> (50% CPU)</td>\n</tr>\n<tr>\n<td><code>cpu.weight</code></td>\n<td>Relative CPU share</td>\n<td>Integer 1-10000</td>\n<td><code>100</code> (normal weight)</td>\n</tr>\n<tr>\n<td><code>cpu.stat</code></td>\n<td>CPU usage statistics</td>\n<td>Multi-line key-value</td>\n<td><code>usage_usec 1234567</code></td>\n</tr>\n<tr>\n<td><code>cpuset.cpus</code></td>\n<td>Allowed CPU cores</td>\n<td>CPU list format</td>\n<td><code>0-3</code> or <code>0,2,4</code></td>\n</tr>\n<tr>\n<td><code>cpuset.mems</code></td>\n<td>Allowed memory nodes</td>\n<td>NUMA node list</td>\n<td><code>0</code></td>\n</tr>\n</tbody></table>\n<p>The CPU quota system works by defining a scheduling period (typically 100ms) and allocating a portion of that period to the container. A container with <code>cpu.max</code> set to <code>50000 100000</code> receives 50,000 microseconds of CPU time every 100,000 microseconds (50% of one CPU core). The CFS scheduler enforces this by throttling the container&#39;s processes when they exhaust their quota within the current period.</p>\n<p>CPU controller setup algorithm:</p>\n<ol>\n<li>Enable the CPU controller by writing <code>+cpu</code> to the parent cgroup&#39;s <code>cgroup.subtree_control</code> file</li>\n<li>Calculate CPU quota from <code>ResourceLimits.CPU</code> value (nanoseconds per second) to microseconds per 100ms period</li>\n<li>Write the quota and period to <code>cpu.max</code> in the format &quot;quota period&quot;</li>\n<li>Set CPU weight based on container priority (higher weight gets more CPU under contention)</li>\n<li>Configure CPU affinity using <code>cpuset.cpus</code> if the container should run on specific cores</li>\n<li>Set memory node affinity using <code>cpuset.mems</code> for NUMA-aware scheduling</li>\n</ol>\n<p>The CPU limit calculation converts from nanoseconds-per-second to the CFS quota format. For example, a <code>ResourceLimits.CPU</code> value of 500,000,000 nanoseconds (0.5 CPU cores) becomes a quota of 50,000 microseconds per 100,000 microsecond period.</p>\n<h4 id=\"device-controller-configuration\">Device Controller Configuration</h4>\n<p>The <strong>device controller</strong> restricts container access to device files under <code>/dev</code>, preventing containers from accessing host hardware directly unless explicitly permitted. This controller uses allow/deny lists with device type, major/minor numbers, and permission specifications.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration File</th>\n<th>Purpose</th>\n<th>Format</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>devices.allow</code></td>\n<td>Permit device access</td>\n<td>&quot;type major:minor permissions&quot;</td>\n<td><code>c 1:3 rwm</code> (allow /dev/null)</td>\n</tr>\n<tr>\n<td><code>devices.deny</code></td>\n<td>Restrict device access</td>\n<td>&quot;type major:minor permissions&quot;</td>\n<td><code>b *:* rwm</code> (deny all block devices)</td>\n</tr>\n<tr>\n<td><code>devices.list</code></td>\n<td>Current device permissions</td>\n<td>Multi-line device specs</td>\n<td><code>c 1:3 rwm\\nc 1:5 rwm</code></td>\n</tr>\n</tbody></table>\n<p>The device controller starts with a deny-all policy and selectively permits access to essential devices that containers typically need. The standard device allowlist includes character devices for <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/urandom</code>, and <code>/dev/random</code>, while denying access to block devices, raw devices, and hardware-specific character devices.</p>\n<p>Device controller setup process:</p>\n<ol>\n<li>Enable the devices controller (automatically enabled in cgroups v2 when processes are added)</li>\n<li>Apply the default deny-all policy by writing <code>a *:* rwm</code> to <code>devices.deny</code></li>\n<li>Allow essential character devices by writing entries to <code>devices.allow</code> for each permitted device</li>\n<li>Parse any additional device permissions from the container specification</li>\n<li>Write additional device allow rules based on container requirements (e.g., GPU access for ML containers)</li>\n</ol>\n<p>Standard container device allowlist:</p>\n<ul>\n<li><code>c 1:3 rwm</code> - <code>/dev/null</code> (null device)</li>\n<li><code>c 1:5 rwm</code> - <code>/dev/zero</code> (zero device)</li>\n<li><code>c 1:8 rwm</code> - <code>/dev/random</code> (random number generator)</li>\n<li><code>c 1:9 rwm</code> - <code>/dev/urandom</code> (non-blocking random)</li>\n<li><code>c 5:0 rwm</code> - <code>/dev/tty</code> (controlling terminal)</li>\n<li><code>c 5:2 rw</code> - <code>/dev/ptmx</code> (pseudoterminal master)</li>\n<li><code>c 136:* rw</code> - <code>/dev/pts/*</code> (pseudoterminal slaves)</li>\n</ul>\n<h4 id=\"cgroup-creation-and-assignment-algorithm\">Cgroup Creation and Assignment Algorithm</h4>\n<p>The cgroup creation process establishes the resource control hierarchy and assigns the container process to the appropriate cgroup for enforcement. This process must handle race conditions, permission requirements, and cleanup on failure.</p>\n<p>Container cgroup setup algorithm:</p>\n<ol>\n<li><strong>Validate cgroups v2 availability</strong> by checking that <code>/sys/fs/cgroup/cgroup.controllers</code> exists and contains required controllers</li>\n<li><strong>Create runtime cgroup hierarchy</strong> if it doesn&#39;t exist: <code>/sys/fs/cgroup/container-runtime/</code> with appropriate permissions</li>\n<li><strong>Enable controllers</strong> by writing <code>+memory +cpu +pids</code> to <code>/sys/fs/cgroup/container-runtime/cgroup.subtree_control</code></li>\n<li><strong>Create container cgroup</strong> directory at <code>/sys/fs/cgroup/container-runtime/[container-id]/</code></li>\n<li><strong>Configure memory limits</strong> by writing <code>ResourceLimits.Memory</code> to <code>memory.max</code></li>\n<li><strong>Configure CPU limits</strong> by calculating and writing quota/period to <code>cpu.max</code></li>\n<li><strong>Configure PID limits</strong> by writing <code>ResourceLimits.PIDs</code> to <code>pids.max</code></li>\n<li><strong>Configure device access</strong> by setting up device allow/deny rules</li>\n<li><strong>Assign container process</strong> by writing the container&#39;s PID to <code>cgroup.procs</code></li>\n<li><strong>Verify assignment</strong> by reading <code>cgroup.procs</code> and confirming the PID appears in the list</li>\n</ol>\n<p>The process assignment step occurs after the container process starts but before it begins executing the user-specified command. The container runtime forks the container process, performs namespace setup, assigns it to the cgroup, then executes the target command. This ensures resource limits apply from the beginning of command execution.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Process Assignment Timing</strong>\nAssigning a process to a cgroup after it has already consumed significant resources allows it to exceed limits during startup. Always assign processes to cgroups immediately after fork, before any significant work begins.</p>\n</blockquote>\n<h3 id=\"resource-usage-monitoring\">Resource Usage Monitoring</h3>\n<p>The <strong>resource usage monitoring</strong> system tracks current resource consumption by reading statistics from cgroup controller files and detecting when containers approach their configured limits. This monitoring enables the container runtime to implement early warning systems, automatic scaling decisions, and proactive resource management.</p>\n<blockquote>\n<p><strong>Decision: Pull-Based Monitoring Over Event-Based</strong></p>\n<ul>\n<li><strong>Context</strong>: Cgroups provide both polling-based monitoring (reading stat files) and event-based monitoring (using eventfd for threshold notifications).</li>\n<li><strong>Options Considered</strong>: Periodic polling of cgroup stat files, event-based notifications using cgroup.events, hybrid approach with polling plus critical event notifications.</li>\n<li><strong>Decision</strong>: Use periodic polling with configurable intervals for primary monitoring.</li>\n<li><strong>Rationale</strong>: Polling provides consistent monitoring behavior, easier implementation, and better integration with existing monitoring systems. Event-based monitoring requires complex eventfd handling and may miss gradual resource increases. The polling overhead is minimal compared to container workloads.</li>\n<li><strong>Consequences</strong>: Slight monitoring latency (up to polling interval) but simpler implementation. Requires tuning polling frequency to balance responsiveness with overhead.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Monitoring Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Periodic Polling</td>\n<td>Simple implementation, consistent behavior, integrates with standard monitoring</td>\n<td>Fixed latency, potential overhead with frequent polling</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Event Notifications</td>\n<td>Low latency, minimal overhead, kernel-driven</td>\n<td>Complex eventfd handling, can miss gradual changes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Best of both worlds</td>\n<td>Complex implementation, harder to debug</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"memory-usage-monitoring\">Memory Usage Monitoring</h4>\n<p>Memory usage monitoring tracks both current consumption and memory pressure indicators to detect containers approaching their limits before OOM conditions occur. The monitoring system reads multiple memory statistics to build a comprehensive view of container memory behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Memory Statistic</th>\n<th>File Path</th>\n<th>Description</th>\n<th>Warning Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Current Usage</td>\n<td><code>memory.current</code></td>\n<td>Total memory currently allocated</td>\n<td>&gt; 80% of <code>memory.max</code></td>\n</tr>\n<tr>\n<td>Peak Usage</td>\n<td><code>memory.peak</code></td>\n<td>Highest memory usage since container start</td>\n<td>&gt; 90% of <code>memory.max</code></td>\n</tr>\n<tr>\n<td>Cache Usage</td>\n<td><code>memory.stat</code> (cache field)</td>\n<td>Page cache memory that can be reclaimed</td>\n<td>&lt; 10% of total usage</td>\n</tr>\n<tr>\n<td>Swap Usage</td>\n<td><code>memory.swap.current</code></td>\n<td>Current swap space consumption</td>\n<td>&gt; 50% of <code>memory.swap.max</code></td>\n</tr>\n<tr>\n<td>Memory Events</td>\n<td><code>memory.events</code></td>\n<td>OOM kills, memory pressure events</td>\n<td>Any oom_kill events</td>\n</tr>\n</tbody></table>\n<p>Memory monitoring algorithm:</p>\n<ol>\n<li><strong>Read current memory usage</strong> from <code>memory.current</code> and calculate percentage of <code>memory.max</code></li>\n<li><strong>Check memory events</strong> by parsing <code>memory.events</code> for <code>oom</code>, <code>oom_kill</code>, <code>oom_group_kill</code> counters</li>\n<li><strong>Analyze memory composition</strong> by parsing <code>memory.stat</code> to understand cache vs anonymous memory ratio</li>\n<li><strong>Detect memory pressure</strong> by comparing current usage trends with historical patterns</li>\n<li><strong>Calculate memory efficiency</strong> by examining the ratio of productive memory (heap, stack) to overhead (page tables, kernel buffers)</li>\n<li><strong>Generate alerts</strong> when usage exceeds 80% of limit or memory pressure events indicate thrashing</li>\n<li><strong>Update monitoring metrics</strong> for integration with external monitoring systems</li>\n</ol>\n<p>The memory monitoring system maintains a sliding window of usage samples to detect trends and predict when containers might hit memory limits. Rapid memory growth patterns trigger early warnings, while sustained high usage with frequent page reclaim indicates memory pressure requiring attention.</p>\n<blockquote>\n<p>Memory usage can spike temporarily during garbage collection or memory allocation bursts. Use moving averages over 30-60 second windows rather than instantaneous readings for alerting thresholds.</p>\n</blockquote>\n<h4 id=\"cpu-usage-monitoring\">CPU Usage Monitoring</h4>\n<p>CPU usage monitoring tracks both absolute CPU consumption and throttling statistics to understand how containers utilize their allocated CPU quotas. The monitoring system distinguishes between CPU usage (actual compute time) and CPU throttling (time spent waiting due to quota limits).</p>\n<table>\n<thead>\n<tr>\n<th>CPU Statistic</th>\n<th>File Path</th>\n<th>Description</th>\n<th>Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Usage Time</td>\n<td><code>cpu.stat</code> (usage_usec)</td>\n<td>Total CPU microseconds consumed</td>\n<td>Compare to quota allocation</td>\n</tr>\n<tr>\n<td>User Time</td>\n<td><code>cpu.stat</code> (user_usec)</td>\n<td>CPU time spent in user space</td>\n<td>High ratio indicates compute-bound</td>\n</tr>\n<tr>\n<td>System Time</td>\n<td><code>cpu.stat</code> (system_usec)</td>\n<td>CPU time spent in kernel space</td>\n<td>High ratio indicates I/O-bound</td>\n</tr>\n<tr>\n<td>Throttled Time</td>\n<td><code>cpu.stat</code> (throttled_usec)</td>\n<td>Time spent waiting due to quota limits</td>\n<td>&gt; 20% indicates quota too low</td>\n</tr>\n<tr>\n<td>Throttled Periods</td>\n<td><code>cpu.stat</code> (nr_throttled)</td>\n<td>Number of periods where quota was exhausted</td>\n<td>Increasing trend indicates pressure</td>\n</tr>\n</tbody></table>\n<p>CPU monitoring algorithm:</p>\n<ol>\n<li><strong>Sample CPU statistics</strong> by reading and parsing the multi-line <code>cpu.stat</code> file</li>\n<li><strong>Calculate CPU utilization</strong> by comparing <code>usage_usec</code> delta with time elapsed and quota available</li>\n<li><strong>Detect CPU throttling</strong> by monitoring <code>throttled_usec</code> and <code>nr_throttled</code> increases between samples</li>\n<li><strong>Analyze CPU efficiency</strong> by examining user/system time ratios to understand workload characteristics</li>\n<li><strong>Track CPU quota effectiveness</strong> by comparing actual usage patterns with allocated quotas</li>\n<li><strong>Generate CPU pressure alerts</strong> when throttling exceeds thresholds or containers consistently hit quota limits</li>\n<li><strong>Maintain CPU usage history</strong> for capacity planning and right-sizing recommendations</li>\n</ol>\n<p>The CPU monitoring system calculates CPU utilization as a percentage by taking the difference in <code>usage_usec</code> between samples, dividing by the time elapsed, and comparing to the allocated quota. For example, if a container uses 45,000 microseconds of CPU time in a 100,000 microsecond period with a 50,000 microsecond quota, it&#39;s running at 90% of its allocation (45,000 / 50,000).</p>\n<h4 id=\"resource-monitoring-data-structures\">Resource Monitoring Data Structures</h4>\n<p>The resource monitoring system maintains current usage state, historical trends, and alert thresholds for each container using structured data that enables efficient monitoring and reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ContainerID</code></td>\n<td><code>string</code></td>\n<td>Unique identifier for the monitored container</td>\n</tr>\n<tr>\n<td><code>CgroupPath</code></td>\n<td><code>string</code></td>\n<td>Filesystem path to the container&#39;s cgroup directory</td>\n</tr>\n<tr>\n<td><code>LastSampleTime</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp of the most recent monitoring sample</td>\n</tr>\n<tr>\n<td><code>MemoryUsage</code></td>\n<td><code>ResourceUsage</code></td>\n<td>Current memory consumption and trends</td>\n</tr>\n<tr>\n<td><code>CPUUsage</code></td>\n<td><code>ResourceUsage</code></td>\n<td>Current CPU utilization and throttling statistics</td>\n</tr>\n<tr>\n<td><code>IOUsage</code></td>\n<td><code>ResourceUsage</code></td>\n<td>Disk and network I/O statistics</td>\n</tr>\n<tr>\n<td><code>AlertThresholds</code></td>\n<td><code>AlertConfig</code></td>\n<td>Warning and critical thresholds for each resource</td>\n</tr>\n<tr>\n<td><code>UsageHistory</code></td>\n<td><code>[]ResourceSample</code></td>\n<td>Sliding window of historical usage samples</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Current</code></td>\n<td><code>int64</code></td>\n<td>Current resource usage value</td>\n</tr>\n<tr>\n<td><code>Peak</code></td>\n<td><code>int64</code></td>\n<td>Highest usage since monitoring started</td>\n</tr>\n<tr>\n<td><code>Limit</code></td>\n<td><code>int64</code></td>\n<td>Configured resource limit from cgroup</td>\n</tr>\n<tr>\n<td><code>UtilizationPercent</code></td>\n<td><code>float64</code></td>\n<td>Current usage as percentage of limit</td>\n</tr>\n<tr>\n<td><code>TrendSlope</code></td>\n<td><code>float64</code></td>\n<td>Rate of change in usage over time</td>\n</tr>\n<tr>\n<td><code>PressureIndicators</code></td>\n<td><code>map[string]int64</code></td>\n<td>Pressure metrics (throttling, OOM events, etc.)</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>WarningThreshold</code></td>\n<td><code>float64</code></td>\n<td>Utilization percentage triggering warnings</td>\n</tr>\n<tr>\n<td><code>CriticalThreshold</code></td>\n<td><code>float64</code></td>\n<td>Utilization percentage triggering critical alerts</td>\n</tr>\n<tr>\n<td><code>TrendWarningSlope</code></td>\n<td><code>float64</code></td>\n<td>Rate of increase triggering trend-based warnings</td>\n</tr>\n<tr>\n<td><code>EventCountThreshold</code></td>\n<td><code>int64</code></td>\n<td>Number of pressure events triggering alerts</td>\n</tr>\n</tbody></table>\n<h3 id=\"out-of-memory-handling\">Out-of-Memory Handling</h3>\n<p>The <strong>out-of-memory handling</strong> system detects and manages memory exhaustion scenarios when containers exceed their allocated memory limits. The OOM handling mechanism combines kernel-level process termination with application-level cleanup and recovery procedures to maintain system stability.</p>\n<blockquote>\n<p><strong>Decision: Cgroup-Scoped OOM Killing Over System-Wide</strong></p>\n<ul>\n<li><strong>Context</strong>: When memory is exhausted, the Linux kernel can kill processes either system-wide (based on global OOM scores) or within the specific cgroup that exceeded limits.</li>\n<li><strong>Options Considered</strong>: Allow system-wide OOM killer to select victims, enable cgroup-scoped OOM killing, implement custom OOM handling with memory pressure monitoring.</li>\n<li><strong>Decision</strong>: Use cgroup-scoped OOM killing with <code>memory.oom.group</code> enabled.</li>\n<li><strong>Rationale</strong>: Cgroup-scoped killing ensures only the offending container&#39;s processes are terminated, protecting other containers and the host system. Group killing ensures related processes (parent/child, shared memory) are cleaned up together, preventing orphaned resources.</li>\n<li><strong>Consequences</strong>: Container processes may be killed more aggressively than with system-wide OOM, but system stability is preserved. Requires proper application design to handle sudden termination gracefully.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>OOM Handling Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System-Wide OOM</td>\n<td>Natural Linux behavior, well-tested</td>\n<td>Can kill host processes, unpredictable victim selection</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Cgroup-Scoped OOM</td>\n<td>Precise isolation, predictable behavior</td>\n<td>More aggressive killing, requires container awareness</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Custom Memory Pressure</td>\n<td>Fine-grained control, graceful degradation</td>\n<td>Complex implementation, potential memory leaks</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<h4 id=\"oom-detection-and-response\">OOM Detection and Response</h4>\n<p>The OOM detection system monitors memory events and usage patterns to identify when containers are approaching or experiencing memory exhaustion. The system distinguishes between predictable memory pressure (gradual increase toward limits) and sudden memory spikes that trigger immediate OOM conditions.</p>\n<p>OOM detection algorithm:</p>\n<ol>\n<li><strong>Monitor memory events</strong> by reading <code>memory.events</code> and tracking increases in <code>oom</code>, <code>oom_kill</code>, and <code>oom_group_kill</code> counters</li>\n<li><strong>Detect memory pressure</strong> by comparing <code>memory.current</code> with <code>memory.max</code> and monitoring rate of increase</li>\n<li><strong>Check swap exhaustion</strong> by comparing <code>memory.swap.current</code> with <code>memory.swap.max</code> if swap is enabled</li>\n<li><strong>Analyze allocation failures</strong> by monitoring <code>memory.events</code> for <code>high</code>, <code>max</code>, and other pressure indicators</li>\n<li><strong>Predict OOM conditions</strong> using usage trends and allocation patterns to warn before limits are reached</li>\n<li><strong>Trigger preventive actions</strong> when usage exceeds warning thresholds (typically 90% of memory limit)</li>\n<li><strong>Handle OOM events</strong> by detecting process termination and initiating cleanup procedures</li>\n</ol>\n<p>The OOM response system implements a tiered approach based on memory pressure severity:</p>\n<p><strong>Warning Level (80-90% memory usage)</strong>:</p>\n<ul>\n<li>Log memory pressure warnings with usage statistics</li>\n<li>Notify monitoring systems about approaching memory limits</li>\n<li>Optionally trigger garbage collection hints for supported runtimes</li>\n<li>Increase monitoring frequency for more responsive detection</li>\n</ul>\n<p><strong>Critical Level (90-95% memory usage)</strong>:</p>\n<ul>\n<li>Generate critical alerts to monitoring and logging systems</li>\n<li>Implement emergency memory reclaim by dropping non-essential caches</li>\n<li>Prepare for potential OOM by saving critical application state</li>\n<li>Consider triggering application-specific memory reduction mechanisms</li>\n</ul>\n<p><strong>OOM Event (process killed by kernel)</strong>:</p>\n<ul>\n<li>Detect OOM kills by monitoring <code>memory.events</code> counters</li>\n<li>Log detailed OOM information including memory usage at time of kill</li>\n<li>Initiate container cleanup procedures to free resources</li>\n<li>Update container state to reflect OOM termination cause</li>\n<li>Optionally implement restart policies based on OOM frequency</li>\n</ul>\n<h4 id=\"oom-recovery-and-cleanup\">OOM Recovery and Cleanup</h4>\n<p>The OOM recovery system handles the aftermath of memory exhaustion events, ensuring proper resource cleanup and implementing restart policies that prevent repeated OOM cycles. The recovery process must distinguish between application bugs (memory leaks) and insufficient memory allocation.</p>\n<table>\n<thead>\n<tr>\n<th>OOM Recovery Action</th>\n<th>Trigger Condition</th>\n<th>Description</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Cleanup</td>\n<td>Process killed by OOM killer</td>\n<td>Remove container resources, update state</td>\n<td>Clean cgroups, namespaces, mounts</td>\n</tr>\n<tr>\n<td>Diagnostic Logging</td>\n<td>Any OOM event</td>\n<td>Record memory usage patterns and triggers</td>\n<td>Write detailed logs with usage history</td>\n</tr>\n<tr>\n<td>Restart Decision</td>\n<td>Container marked for restart</td>\n<td>Evaluate restart policies and backoff</td>\n<td>Check restart count, implement delays</td>\n</tr>\n<tr>\n<td>Resource Adjustment</td>\n<td>Repeated OOM within window</td>\n<td>Increase memory limits or reduce requests</td>\n<td>Update ResourceLimits if policy allows</td>\n</tr>\n</tbody></table>\n<p>OOM recovery algorithm:</p>\n<ol>\n<li><strong>Detect OOM termination</strong> by monitoring container process exit status and memory events</li>\n<li><strong>Preserve diagnostic information</strong> by capturing memory usage statistics, allocation patterns, and timeline leading to OOM</li>\n<li><strong>Initiate resource cleanup</strong> by removing cgroups, unmounting filesystems, and cleaning network resources</li>\n<li><strong>Update container state</strong> to reflect OOM termination with detailed exit reason and resource usage</li>\n<li><strong>Evaluate restart eligibility</strong> based on restart policies, backoff intervals, and OOM frequency</li>\n<li><strong>Implement restart backoff</strong> to prevent rapid restart cycles that repeatedly trigger OOM</li>\n<li><strong>Optionally adjust resources</strong> if restart policies allow automatic memory limit increases</li>\n<li><strong>Generate alerts</strong> for persistent OOM patterns that require manual intervention</li>\n</ol>\n<p>The restart backoff system implements exponential delays to prevent OOM thrashing:</p>\n<ul>\n<li>First OOM: immediate restart if restart policy allows</li>\n<li>Second OOM within 5 minutes: 10-second delay before restart</li>\n<li>Third OOM within 15 minutes: 60-second delay before restart</li>\n<li>Subsequent OOMs: exponential backoff up to 300-second maximum delay</li>\n</ul>\n<blockquote>\n<p>⚠️ <strong>Pitfall: OOM Loop Prevention</strong>\nContainers that immediately trigger OOM after restart can create rapid resource allocation/deallocation cycles that destabilize the host system. Always implement restart backoff and consider automatic memory limit adjustments for chronic OOM containers.</p>\n</blockquote>\n<h4 id=\"memory-pressure-prevention\">Memory Pressure Prevention</h4>\n<p>The memory pressure prevention system implements proactive measures to avoid OOM conditions by monitoring memory trends and triggering early intervention when containers approach their limits. This system focuses on graceful degradation rather than hard termination.</p>\n<p>Memory pressure prevention strategies:</p>\n<p><strong>Trend-Based Prediction</strong>:</p>\n<ul>\n<li>Monitor memory allocation rate over 60-second windows</li>\n<li>Extrapolate current trends to predict when memory limits will be reached</li>\n<li>Trigger warnings when projected exhaustion time falls below 5 minutes</li>\n<li>Account for allocation bursts and garbage collection patterns</li>\n</ul>\n<p><strong>Application-Level Cooperation</strong>:</p>\n<ul>\n<li>Send SIGUSR1 signals to applications supporting memory pressure notifications</li>\n<li>Implement cgroup memory.pressure interface for pressure stall information</li>\n<li>Allow applications to implement graceful memory reduction strategies</li>\n<li>Provide memory usage APIs for application self-monitoring</li>\n</ul>\n<p><strong>Cache and Buffer Management</strong>:</p>\n<ul>\n<li>Monitor page cache usage through memory.stat analysis</li>\n<li>Trigger early page cache reclaim when memory pressure builds</li>\n<li>Implement buffer size reductions for network and disk I/O</li>\n<li>Coordinate with kernel memory management for optimal reclaim timing</li>\n</ul>\n<p><strong>Dynamic Resource Adjustment</strong>:</p>\n<ul>\n<li>Temporarily increase memory limits during predicted short-term spikes</li>\n<li>Implement memory borrowing from unused container allocations</li>\n<li>Coordinate with cluster-level resource management for dynamic scaling</li>\n<li>Revert temporary adjustments after memory pressure subsides</li>\n</ul>\n<p>The prevention system maintains effectiveness by learning from historical patterns and adjusting prediction algorithms based on application behavior. Containers with predictable memory allocation patterns receive more accurate warnings, while applications with erratic memory usage receive more conservative early warnings.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cgroup Interface</td>\n<td>Direct filesystem operations with os.OpenFile</td>\n<td>go-cgroups library with type safety</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Periodic file reads with time.Ticker</td>\n<td>Prometheus client library with metrics</td>\n</tr>\n<tr>\n<td>OOM Detection</td>\n<td>Poll memory.events file</td>\n<td>Use eventfd for kernel notifications</td>\n</tr>\n<tr>\n<td>Data Persistence</td>\n<td>JSON files in /var/lib/container-runtime</td>\n<td>SQLite database with structured schema</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-runtime/\n  internal/cgroups/\n    cgroups.go              ← cgroup controller interface\n    memory.go               ← memory controller implementation  \n    cpu.go                  ← CPU controller implementation\n    devices.go              ← device controller implementation\n    monitor.go              ← resource usage monitoring\n    oom.go                  ← out-of-memory handling\n    cgroups_test.go         ← unit tests for all controllers\n  internal/resources/\n    limits.go               ← ResourceLimits validation and conversion\n    monitor.go              ← resource monitoring coordinator\n    stats.go                ← usage statistics collection</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>Complete cgroup filesystem interface for reading and writing cgroup files:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/cgroups/filesystem.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cgroups</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">io/ioutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CgroupFS provides filesystem operations for cgroup management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CgroupFS</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Root </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Root cgroup filesystem path (usually /sys/fs/cgroup)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCgroupFS creates a new cgroup filesystem interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCgroupFS</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\">{Root: </span><span style=\"color:#9ECBFF\">\"/sys/fs/cgroup\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WriteFile writes content to a cgroup file with proper error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">content</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fullPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(c.Root, cgroupPath, filename)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(fullPath, []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">(content), </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReadFile reads content from a cgroup file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fullPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(c.Root, cgroupPath, filename)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ioutil.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(fullPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(data)), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateCgroup creates a cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fullPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(c.Root, cgroupPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(fullPath, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveCgroup removes a cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fullPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(c.Root, cgroupPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(fullPath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ParseKeyValue parses multi-line key-value format from cgroup stat files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ParseKeyValue</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">content</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(content, </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, line </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> lines {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> value, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result[parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Resource monitoring data structures and utilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/resources/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> resources</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceUsage tracks current and historical resource consumption</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceUsage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Current             </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">             `json:\"current\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Peak                </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">             `json:\"peak\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limit               </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">             `json:\"limit\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UtilizationPercent  </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">           `json:\"utilization_percent\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TrendSlope          </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">           `json:\"trend_slope\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PressureIndicators  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"pressure_indicators\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceSample represents a point-in-time resource measurement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceSample</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value     </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"value\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Metadata  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AlertConfig defines thresholds for resource usage alerts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AlertConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WarningThreshold     </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"warning_threshold\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CriticalThreshold    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"critical_threshold\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TrendWarningSlope    </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\"> `json:\"trend_warning_slope\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventCountThreshold  </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">   `json:\"event_count_threshold\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerResourceState maintains monitoring state for a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerResourceState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"container_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CgroupPath      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"cgroup_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastSampleTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"last_sample_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryUsage     </span><span style=\"color:#B392F0\">ResourceUsage</span><span style=\"color:#9ECBFF\">          `json:\"memory_usage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUUsage        </span><span style=\"color:#B392F0\">ResourceUsage</span><span style=\"color:#9ECBFF\">          `json:\"cpu_usage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IOUsage         </span><span style=\"color:#B392F0\">ResourceUsage</span><span style=\"color:#9ECBFF\">          `json:\"io_usage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AlertThresholds </span><span style=\"color:#B392F0\">AlertConfig</span><span style=\"color:#9ECBFF\">            `json:\"alert_thresholds\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UsageHistory    []</span><span style=\"color:#B392F0\">ResourceSample</span><span style=\"color:#9ECBFF\">       `json:\"usage_history\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateUtilization computes utilization percentage with bounds checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceUsage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CalculateUtilization</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> r.Limit </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.UtilizationPercent </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(r.Current) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(r.Limit) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.UtilizationPercent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clamp to reasonable bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> r.UtilizationPercent </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 100.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.UtilizationPercent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> r.UtilizationPercent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.UtilizationPercent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p>Cgroup controller implementation with memory, CPU, and device management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/cgroups/controller.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cgroups</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Controller manages cgroup v2 controllers for container resource limits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Controller</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fs       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    basePath </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Base path for container runtime cgroups</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewController creates a new cgroup controller</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewController</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Controller</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Controller</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fs:       </span><span style=\"color:#B392F0\">NewCgroupFS</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        basePath: </span><span style=\"color:#9ECBFF\">\"container-runtime\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainerCgroup sets up cgroup hierarchy and limits for a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Controller</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainerCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limits</span><span style=\"color:#B392F0\"> ResourceLimits</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that cgroups v2 is available by checking /sys/fs/cgroup/cgroup.controllers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create runtime base cgroup if it doesn't exist: /sys/fs/cgroup/container-runtime/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Enable required controllers (+memory +cpu +pids) in base cgroup subtree_control</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create container-specific cgroup directory: /sys/fs/cgroup/container-runtime/[containerID]/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Configure memory limits by writing limits.Memory to memory.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Configure CPU limits by converting limits.CPU to quota/period format for cpu.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Configure PID limits by writing limits.PIDs to pids.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Set up device controller with standard container device allowlist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Verify cgroup creation by reading back the written configuration files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use c.fs.CreateCgroup() and c.fs.WriteFile() for filesystem operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: CPU limits in nanoseconds/second convert to microseconds/100ms for cpu.max</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AssignProcessToCgroup moves a process into the container's cgroup for resource enforcement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Controller</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AssignProcessToCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that the container cgroup exists before assignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Write the PID to the container's cgroup.procs file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify assignment by reading cgroup.procs and confirming PID is listed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle assignment failures due to process state or permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Convert PID to string before writing to cgroup.procs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Assignment may fail if process is already exiting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetResourceUsage reads current resource consumption from cgroup statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Controller</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetResourceUsage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerResourceState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read memory usage from memory.current and memory.peak</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read memory limits from memory.max for utilization calculation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read CPU usage from cpu.stat (parse usage_usec field)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Read CPU throttling statistics from cpu.stat (throttled_usec, nr_throttled)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Read memory pressure events from memory.events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Calculate utilization percentages for each resource type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Detect resource pressure indicators (high throttling, OOM events)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Build and return ContainerResourceState with all collected metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use c.fs.ParseKeyValue() to parse multi-line stat files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle missing or unreadable files gracefully (container may be gone)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveContainerCgroup cleans up cgroup when container is removed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Controller</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainerCgroup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Ensure no processes remain in the cgroup before removal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read cgroup.procs and verify it's empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove the cgroup directory using rmdir (not rm -rf)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle removal failures due to remaining processes or resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Log warnings but don't fail if cgroup is already gone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Cgroup removal will fail if any processes are still assigned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use c.fs.RemoveCgroup() which calls os.Remove() (equivalent to rmdir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Memory controller with OOM detection and handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/cgroups/memory.go  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cgroups</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MemoryController manages memory cgroup settings and OOM handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MemoryController</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupFS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetMemoryLimit configures memory.max and related memory settings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryController</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetMemoryLimit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">limitBytes</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Write hard memory limit to memory.max file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate and set soft limit (75% of hard limit) in memory.high</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure swap limit in memory.swap.max (same as memory limit or disabled)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Enable group OOM killing by writing 1 to memory.oom.group</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify limits are applied by reading back the written values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Convert limitBytes to string before writing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use \"0\" for memory.swap.max to disable swap for the container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetMemoryUsage reads current memory consumption and pressure indicators</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryController</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetMemoryUsage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceUsage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read current memory usage from memory.current</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read peak memory usage from memory.peak  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read memory limit from memory.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse memory.stat to get detailed memory breakdown (cache, anonymous, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Read memory pressure events from memory.events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Calculate utilization percentage and trend indicators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Build ResourceUsage struct with pressure indicators map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: memory.events contains counters for low, high, max, oom, oom_kill events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use m.fs.ParseKeyValue() to parse memory.stat and memory.events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckOOMEvents detects out-of-memory kills and returns event details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryController</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckOOMEvents</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read memory.events file to get OOM event counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for increases in oom_kill and oom_group_kill counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare with previously stored counter values to detect new events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return true if new OOM events occurred since last check</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Include all event counters in returned map for detailed logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Store previous counter values to detect increases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Any non-zero oom_kill count indicates the container has experienced OOM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Resource monitoring with trend analysis and alerting:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/resources/monitor.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> resources</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceMonitor coordinates resource usage monitoring across all containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceMonitor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    controller     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cgroups</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Controller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerResourceState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alertChannel   </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> ResourceAlert</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stopChannel    </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    monitoringInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceAlert represents a resource usage alert condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceAlert</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"container_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceType  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"resource_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AlertLevel    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"alert_level\"`</span><span style=\"color:#6A737D\"> // warning, critical, oom</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentUsage  </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"current_usage\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Limit         </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"limit\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"message\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartMonitoring begins periodic resource usage monitoring for all containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartMonitoring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start background goroutine with ticker for monitoring interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: On each tick, iterate through all registered containers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Collect current resource usage for each container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update usage history with new samples (maintain sliding window)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate trends and detect approaching resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Generate alerts for containers exceeding warning/critical thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check for OOM events and generate immediate critical alerts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Handle context cancellation for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use time.NewTicker(r.monitoringInterval) for periodic monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Protect concurrent access to r.containers map with r.mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterContainer adds a container to the monitoring system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">thresholds</span><span style=\"color:#B392F0\"> AlertConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ContainerResourceState for the new container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize usage history slice with appropriate capacity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Store alert thresholds configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add container to monitoring map with proper locking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Perform initial resource usage reading to establish baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use r.mutex.Lock() for write access to r.containers map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Initialize UsageHistory with make([]ResourceSample, 0, historyCapacity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CalculateUsageTrend computes the rate of change in resource usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CalculateUsageTrend</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">history</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ResourceSample</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that history has at least 2 samples for trend calculation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Use linear regression or simple slope calculation across sample window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate bytes-per-second or percentage-per-minute change rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle edge cases (empty history, identical timestamps, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return trend slope (positive=increasing, negative=decreasing, zero=stable)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Simple slope = (lastValue - firstValue) / (lastTime - firstTime)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Convert time difference to seconds for rate calculation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the Resource Control Component:</p>\n<p><strong>Test Command</strong>: <code>go test ./internal/cgroups/... -v</code></p>\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>Cgroup creation succeeds for valid container specifications</li>\n<li>Memory limits are enforced when containers exceed allocation</li>\n<li>CPU throttling occurs when containers exceed CPU quotas  </li>\n<li>Resource usage monitoring returns accurate utilization statistics</li>\n<li>OOM events are detected and logged appropriately</li>\n</ul>\n<p><strong>Manual Verification</strong>:</p>\n<ol>\n<li>Create a test container with 100MB memory limit: <code>echo &#39;stress --vm 1 --vm-bytes 200M&#39; | ./container-runtime run --memory 104857600 alpine</code></li>\n<li>Container should be killed when memory usage exceeds limit</li>\n<li>Check cgroup files: <code>cat /sys/fs/cgroup/container-runtime/[container-id]/memory.max</code> should show 104857600</li>\n<li>Monitor resource usage: <code>./container-runtime stats [container-id]</code> should show current memory/CPU utilization</li>\n<li>Verify cleanup: after container removal, cgroup directory should be deleted</li>\n</ol>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>&quot;Operation not permitted&quot; when writing to cgroup files → Check that cgroups v2 is enabled and process has sufficient privileges</li>\n<li>Memory limit not enforced → Verify memory.max file contains correct limit and memory.oom.group is enabled</li>\n<li>Resource monitoring returns zero values → Check cgroup file permissions and paths</li>\n<li>Cgroup removal fails → Ensure all processes are terminated before attempting removal</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container uses unlimited memory despite limits</td>\n<td>Memory limits not applied or enforced</td>\n<td>Check memory.max file exists and contains expected value</td>\n<td>Verify cgroups v2 enabled, ensure memory controller active</td>\n</tr>\n<tr>\n<td>CPU usage exceeds configured quotas</td>\n<td>CPU limits not configured or incorrect quota calculation</td>\n<td>Check cpu.max file and verify quota/period values</td>\n<td>Convert nanoseconds correctly to microsecond quota</td>\n</tr>\n<tr>\n<td>Cgroup creation fails with permission denied</td>\n<td>Insufficient privileges or cgroups v2 not available</td>\n<td>Check /sys/fs/cgroup mount and user permissions</td>\n<td>Run with appropriate privileges or enable user namespaces</td>\n</tr>\n<tr>\n<td>Resource monitoring returns stale data</td>\n<td>Cgroup files not updating or monitoring stopped</td>\n<td>Check if container process still exists and cgroup populated</td>\n<td>Verify process assignment and restart monitoring</td>\n</tr>\n<tr>\n<td>OOM kills not detected</td>\n<td>Event monitoring not working or wrong file format</td>\n<td>Read memory.events manually and check counter values</td>\n<td>Implement proper event file parsing and counter tracking</td>\n</tr>\n</tbody></table>\n<h2 id=\"filesystem-layering-component\">Filesystem Layering Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Overlay Filesystem) - This section implements image layering using overlayfs for copy-on-write filesystem support with proper layer management and cleanup.</p>\n</blockquote>\n<h3 id=\"mental-model-transparent-sheets\">Mental Model: Transparent Sheets</h3>\n<p>Before diving into the technical complexities of overlayfs, imagine you&#39;re working with a stack of transparent sheets on an overhead projector. Each sheet represents a filesystem layer that contains some files and directories. When you stack multiple sheets on top of each other, the audience sees a combined view where content from all sheets appears merged together.</p>\n<p>The <strong>bottom sheets</strong> are your base image layers - they contain the operating system files, libraries, and application dependencies. These sheets are read-only; you never modify them directly. You might have a base Ubuntu sheet, then an application runtime sheet on top of it, then your application code sheet on top of that.</p>\n<p>The <strong>top sheet</strong> is special - it&#39;s a blank, writable transparency where you can draw new content or place opaque stickers to &quot;hide&quot; content from the sheets below. When you write a file in the container, it&#39;s like drawing on this top sheet. When you modify an existing file, it&#39;s like placing an opaque sticker over the old content and writing the new content on the sticker.</p>\n<p>This analogy captures the essence of <strong>copy-on-write semantics</strong>: the original sheets (base image layers) remain untouched, but the combined view shows your modifications. If you need to &quot;edit&quot; a file that exists in a lower layer, the filesystem copies it up to the writable layer first, then modifies the copy. The original remains pristine in the lower layer, but the upper copy masks it in the merged view.</p>\n<p>The <strong>projector</strong> itself represents the overlayfs mount that combines all these layers into a single, coherent filesystem tree that the container process sees as its root filesystem. Just as the audience sees one combined image despite the multiple sheets, the container sees one unified filesystem despite the multiple underlying layers.</p>\n<h3 id=\"layer-stacking-and-management\">Layer Stacking and Management</h3>\n<p>The core challenge in filesystem layering is <strong>orchestrating the overlayfs mount</strong> to combine multiple read-only image layers with a single writable upper layer. This process involves careful directory structure setup, mount option configuration, and proper handling of layer ordering.</p>\n<blockquote>\n<p><strong>Decision: Directory Structure for OverlayFS</strong></p>\n<ul>\n<li><strong>Context</strong>: OverlayFS requires specific directory layout with lower directories, upper directory, work directory, and mount target</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Flat structure with all directories in same parent</li>\n<li>Nested structure mirroring image layer hierarchy</li>\n<li>Separate trees for layers, upper, work, and mounts</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate trees organized by function under container storage root</li>\n<li><strong>Rationale</strong>: Cleaner separation of concerns, easier cleanup, better debugging visibility, matches Docker/containerd patterns</li>\n<li><strong>Consequences</strong>: More directory traversal but clearer organization and easier troubleshooting</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Directory Type</th>\n<th>Purpose</th>\n<th>Example Path</th>\n<th>Permissions</th>\n<th>Cleanup Timing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lower Layers</td>\n<td>Read-only image layer content</td>\n<td><code>/var/lib/runtime/layers/sha256:abc123...</code></td>\n<td>755 (readable)</td>\n<td>On image removal</td>\n</tr>\n<tr>\n<td>Upper Directory</td>\n<td>Container&#39;s writable layer</td>\n<td><code>/var/lib/runtime/containers/{id}/upper</code></td>\n<td>755 (writable)</td>\n<td>On container removal</td>\n</tr>\n<tr>\n<td>Work Directory</td>\n<td>OverlayFS internal operations</td>\n<td><code>/var/lib/runtime/containers/{id}/work</code></td>\n<td>755 (writable)</td>\n<td>On container removal</td>\n</tr>\n<tr>\n<td>Merged Mount</td>\n<td>Combined view for container</td>\n<td><code>/var/lib/runtime/containers/{id}/merged</code></td>\n<td>755 (mount target)</td>\n<td>On container stop</td>\n</tr>\n</tbody></table>\n<p>The <strong>layer stacking algorithm</strong> follows a precise sequence to ensure proper overlay mounting:</p>\n<ol>\n<li><p><strong>Validate layer prerequisites</strong> by checking that each lower layer directory exists and contains valid filesystem content. Empty layers are permitted but must have proper directory structure.</p>\n</li>\n<li><p><strong>Create container-specific directories</strong> for the upper layer, work directory, and merge mount point. The work directory must be on the same filesystem as the upper directory to support atomic operations.</p>\n</li>\n<li><p><strong>Construct the lowerdir mount option</strong> by joining all image layer paths with colon separators, ordered from most-specific to most-general (reverse chronological order of layer creation). This ordering ensures that files in later layers override files in earlier layers.</p>\n</li>\n<li><p><strong>Prepare mount options</strong> combining lowerdir, upperdir, workdir, and any additional overlayfs-specific flags like index=on for better performance on supported kernels.</p>\n</li>\n<li><p><strong>Execute the overlay mount</strong> using the mount system call with MS_MGC_VAL flag and &quot;overlay&quot; filesystem type, binding the merged view to the container&#39;s mount point.</p>\n</li>\n<li><p><strong>Verify mount success</strong> by checking that the merged directory shows expected content from all layers and that test write operations succeed in creating files that appear only in the upper directory.</p>\n</li>\n</ol>\n<blockquote>\n<p>The critical insight here is that overlayfs requires the work directory to be empty and on the same filesystem as the upper directory. Many mount failures stem from violating these requirements.</p>\n</blockquote>\n<p><strong>Layer ordering</strong> is crucial for proper file precedence. When multiple layers contain the same file path, overlayfs uses the <strong>first match wins</strong> principle, searching from the upper directory down through the lower directories in the order specified. This means the mount option construction must reverse the chronological layer order:</p>\n<table>\n<thead>\n<tr>\n<th>Layer Type</th>\n<th>Creation Order</th>\n<th>Mount Order</th>\n<th>Precedence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Upper (container changes)</td>\n<td>N/A</td>\n<td>First (implicit)</td>\n<td>Highest</td>\n</tr>\n<tr>\n<td>App layer</td>\n<td>3rd (most recent)</td>\n<td>2nd in lowerdir</td>\n<td>Second highest</td>\n</tr>\n<tr>\n<td>Runtime layer</td>\n<td>2nd</td>\n<td>3rd in lowerdir</td>\n<td>Third highest</td>\n</tr>\n<tr>\n<td>Base OS layer</td>\n<td>1st (oldest)</td>\n<td>Last in lowerdir</td>\n<td>Lowest</td>\n</tr>\n</tbody></table>\n<p><strong>Container filesystem manager</strong> coordinates the entire layer stacking process through a well-defined interface:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PrepareContainerFilesystem</code></td>\n<td><code>containerID string, imageLayers []string</code></td>\n<td><code>error</code></td>\n<td>Creates directories and mounts overlay</td>\n</tr>\n<tr>\n<td><code>MountOverlayFS</code></td>\n<td><code>layers []string, target string</code></td>\n<td><code>error</code></td>\n<td>Core overlay mount operation</td>\n</tr>\n<tr>\n<td><code>GetMergedPath</code></td>\n<td><code>containerID string</code></td>\n<td><code>string</code></td>\n<td>Returns path to merged filesystem</td>\n</tr>\n<tr>\n<td><code>GetUpperPath</code></td>\n<td><code>containerID string</code></td>\n<td><code>string</code></td>\n<td>Returns path to writable layer</td>\n</tr>\n<tr>\n<td><code>ListLayerContent</code></td>\n<td><code>layerPath string</code></td>\n<td><code>[]FileInfo, error</code></td>\n<td>Inspects layer contents for debugging</td>\n</tr>\n<tr>\n<td><code>ValidateLayerIntegrity</code></td>\n<td><code>layerPath string</code></td>\n<td><code>error</code></td>\n<td>Verifies layer filesystem consistency</td>\n</tr>\n</tbody></table>\n<h3 id=\"copy-on-write-semantics\">Copy-on-Write Semantics</h3>\n<p>Copy-on-write (CoW) is the fundamental mechanism that makes container filesystem layering efficient and safe. When a container process attempts to <strong>modify a file that exists in a lower read-only layer</strong>, overlayfs automatically copies the file to the upper writable layer before allowing the modification to proceed. This ensures that the original file in the base image remains unchanged while the container sees its modified version.</p>\n<p>The <strong>CoW trigger conditions</strong> determine when overlayfs initiates a copy operation:</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Triggers CoW</th>\n<th>Behavior</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read existing file</td>\n<td>No</td>\n<td>Direct read from lower layer</td>\n<td>Minimal overhead</td>\n</tr>\n<tr>\n<td>Write new file</td>\n<td>No</td>\n<td>Write directly to upper layer</td>\n<td>Minimal overhead</td>\n</tr>\n<tr>\n<td>Modify existing file</td>\n<td>Yes</td>\n<td>Copy to upper, then modify</td>\n<td>One-time copy cost</td>\n</tr>\n<tr>\n<td>Delete existing file</td>\n<td>Yes</td>\n<td>Create whiteout in upper layer</td>\n<td>Minimal overhead</td>\n</tr>\n<tr>\n<td>Change permissions</td>\n<td>Yes</td>\n<td>Copy to upper, then change attrs</td>\n<td>One-time copy cost</td>\n</tr>\n<tr>\n<td>Create hard link</td>\n<td>Yes</td>\n<td>Copy target to upper if needed</td>\n<td>Depends on target size</td>\n</tr>\n</tbody></table>\n<p><strong>Whiteout files</strong> are overlayfs&#39;s mechanism for handling file deletions without modifying lower layers. When a container deletes a file that exists in a lower layer, overlayfs creates a special <strong>character device file</strong> with device number 0/0 in the upper layer at the same path. This whiteout file masks the lower layer file in the merged view, making it appear deleted to the container while preserving the original in the base image.</p>\n<p>The <strong>copy-up process</strong> follows a specific algorithm to ensure atomicity and consistency:</p>\n<ol>\n<li><p><strong>Create temporary file</strong> in the upper layer with a unique name (typically the target filename with a random suffix) to avoid conflicts during the copy operation.</p>\n</li>\n<li><p><strong>Copy file content</strong> from the lower layer source to the temporary file in chunks, preserving all data exactly while handling large files efficiently.</p>\n</li>\n<li><p><strong>Copy metadata</strong> including permissions, ownership, timestamps, and extended attributes from the original file to maintain exact semantics.</p>\n</li>\n<li><p><strong>Atomic rename</strong> the temporary file to the final target name in the upper layer, making the copied file visible in the merged view instantaneously.</p>\n</li>\n<li><p><strong>Verify copy integrity</strong> by comparing file size and checksums between source and destination to detect any corruption during the copy process.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The copy-up operation is atomic from the container&#39;s perspective - the file either appears unchanged (before copy-up) or fully updated (after copy-up), never in a partial state.</p>\n</blockquote>\n<p><strong>Container process perspective</strong> shows how CoW remains transparent to applications running inside containers:</p>\n<table>\n<thead>\n<tr>\n<th>Container Action</th>\n<th>Filesystem Events</th>\n<th>Container Observes</th>\n<th>Actual Storage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cat /etc/passwd</code></td>\n<td>Read from lower layer</td>\n<td>File contents</td>\n<td>No upper layer copy</td>\n</tr>\n<tr>\n<td><code>echo &quot;test&quot; &gt; /tmp/new</code></td>\n<td>Write to upper layer</td>\n<td>New file created</td>\n<td>File only in upper</td>\n</tr>\n<tr>\n<td><code>sed -i &#39;s/bash/zsh/&#39; /etc/passwd</code></td>\n<td>Copy-up, then modify</td>\n<td>Modified file</td>\n<td>Original in lower, copy in upper</td>\n</tr>\n<tr>\n<td><code>rm /bin/ls</code></td>\n<td>Create whiteout</td>\n<td>File deleted</td>\n<td>Original in lower, whiteout in upper</td>\n</tr>\n<tr>\n<td><code>ls /etc/</code></td>\n<td>Merge lower + upper - whiteouts</td>\n<td>Combined directory</td>\n<td>Files from all layers</td>\n</tr>\n</tbody></table>\n<p><strong>Performance characteristics</strong> of copy-on-write operations vary significantly based on file size and access patterns:</p>\n<table>\n<thead>\n<tr>\n<th>File Size Range</th>\n<th>Copy-up Latency</th>\n<th>Storage Overhead</th>\n<th>Optimization Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt; 4KB (small configs)</td>\n<td>&lt; 1ms</td>\n<td>Minimal</td>\n<td>Acceptable overhead</td>\n</tr>\n<tr>\n<td>4KB - 1MB (libraries)</td>\n<td>1-10ms</td>\n<td>Low</td>\n<td>Monitor for hot files</td>\n</tr>\n<tr>\n<td>1MB - 100MB (binaries)</td>\n<td>10ms - 1s</td>\n<td>Moderate</td>\n<td>Consider image layer optimization</td>\n</tr>\n<tr>\n<td>&gt; 100MB (databases)</td>\n<td>&gt; 1s</td>\n<td>High</td>\n<td>Use volume mounts instead</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Large File Copy-up Performance</strong>\nA common mistake is placing large, frequently-modified files (like databases or log files) in the container&#39;s overlay filesystem. When the container first modifies a 500MB database file from the base image, overlayfs must copy the entire file to the upper layer before allowing any writes. This creates a several-second pause and doubles the storage requirement. <strong>Solution</strong>: Use volume mounts for large, mutable data files, keeping only application code and configuration in the overlay layers.</p>\n<h3 id=\"layer-cleanup-process\">Layer Cleanup Process</h3>\n<p>Proper cleanup of overlay filesystem layers is critical for preventing resource leaks and maintaining system stability. The cleanup process must handle <strong>partial failure scenarios</strong> gracefully while ensuring that shared base image layers are only removed when no longer referenced by any containers.</p>\n<blockquote>\n<p><strong>Decision: Cleanup Ordering Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Failed cleanup can leave mount points active, directories locked, or storage space consumed</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Aggressive cleanup that forces unmount and removes all directories</li>\n<li>Conservative cleanup that fails fast on any error</li>\n<li>Best-effort cleanup with detailed error reporting</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Best-effort cleanup with rollback capability</li>\n<li><strong>Rationale</strong>: Maximizes successful cleanup while providing diagnostics for manual intervention when needed</li>\n<li><strong>Consequences</strong>: More complex cleanup logic but better operational reliability</li>\n</ul>\n</blockquote>\n<p>The <strong>cleanup sequence</strong> follows a carefully ordered set of operations designed to minimize the chance of leaving the system in an inconsistent state:</p>\n<ol>\n<li><p><strong>Identify cleanup scope</strong> by determining which overlay mount points, directories, and layer references belong to the container being removed.</p>\n</li>\n<li><p><strong>Unmount overlay filesystem</strong> using the umount system call with MNT_DETACH flag if normal unmount fails, allowing cleanup to proceed even if processes hold open file descriptors.</p>\n</li>\n<li><p><strong>Remove container-specific directories</strong> including the merged mount point, upper directory, and work directory, which contain only this container&#39;s changes.</p>\n</li>\n<li><p><strong>Update layer reference counts</strong> to track how many containers are using each base image layer, enabling safe cleanup of unused layers.</p>\n</li>\n<li><p><strong>Remove unreferenced image layers</strong> only after confirming no other containers or cached images depend on them.</p>\n</li>\n<li><p><strong>Clean up mount namespace entries</strong> to prevent stale mount information from accumulating in the kernel&#39;s mount table.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Cleanup Phase</th>\n<th>Target</th>\n<th>Error Handling</th>\n<th>Rollback Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Overlay unmount</td>\n<td><code>/var/lib/runtime/containers/{id}/merged</code></td>\n<td>Retry with MNT_DETACH</td>\n<td>Mark for later cleanup</td>\n</tr>\n<tr>\n<td>Upper directory</td>\n<td><code>/var/lib/runtime/containers/{id}/upper</code></td>\n<td>Log and continue</td>\n<td>Manual removal required</td>\n</tr>\n<tr>\n<td>Work directory</td>\n<td><code>/var/lib/runtime/containers/{id}/work</code></td>\n<td>Log and continue</td>\n<td>Manual removal required</td>\n</tr>\n<tr>\n<td>Mount point</td>\n<td><code>/var/lib/runtime/containers/{id}/merged</code></td>\n<td>Log and continue</td>\n<td>Manual removal required</td>\n</tr>\n<tr>\n<td>Layer references</td>\n<td>Reference count files</td>\n<td>Log and continue</td>\n<td>May leak storage space</td>\n</tr>\n<tr>\n<td>Image layers</td>\n<td><code>/var/lib/runtime/layers/sha256:*</code></td>\n<td>Skip if referenced</td>\n<td>Preserve for safety</td>\n</tr>\n</tbody></table>\n<p><strong>Reference counting</strong> prevents premature removal of shared base image layers that might be used by other containers:</p>\n<table>\n<thead>\n<tr>\n<th>Reference Type</th>\n<th>Storage Location</th>\n<th>Update Trigger</th>\n<th>Cleanup Trigger</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container references</td>\n<td><code>/var/lib/runtime/refs/containers/{id}</code></td>\n<td>Container create/remove</td>\n<td>Container removal</td>\n</tr>\n<tr>\n<td>Image references</td>\n<td><code>/var/lib/runtime/refs/images/{digest}</code></td>\n<td>Image pull/remove</td>\n<td>Image removal</td>\n</tr>\n<tr>\n<td>Layer references</td>\n<td><code>/var/lib/runtime/refs/layers/{digest}</code></td>\n<td>Layer first use/last use</td>\n<td>Reference count reaches zero</td>\n</tr>\n</tbody></table>\n<p><strong>Cleanup verification</strong> ensures that the cleanup process completed successfully and didn&#39;t leave orphaned resources:</p>\n<table>\n<thead>\n<tr>\n<th>Verification Check</th>\n<th>Expected State</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mount points cleared</td>\n<td>No overlay mounts for container</td>\n<td>Parse <code>/proc/mounts</code></td>\n<td>Force unmount</td>\n</tr>\n<tr>\n<td>Directories removed</td>\n<td>Container directory tree gone</td>\n<td><code>stat()</code> system call</td>\n<td>Recursive removal</td>\n</tr>\n<tr>\n<td>References updated</td>\n<td>Counts reflect removal</td>\n<td>Read reference files</td>\n<td>Recalculate from existing containers</td>\n</tr>\n<tr>\n<td>Storage reclaimed</td>\n<td>Disk space freed</td>\n<td><code>du</code> on upper directory</td>\n<td>Manual space recovery</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Unmount Failures with Open Files</strong>\nA frequent issue occurs when container cleanup attempts to unmount the overlay filesystem while processes still have open file descriptors to files in the merged view. This can happen if the container process didn&#39;t terminate cleanly or if background processes are still running. <strong>Detection</strong>: The umount system call returns EBUSY. <strong>Solution</strong>: Use <code>MNT_DETACH</code> flag to create a lazy unmount that removes the mount from the namespace immediately but defers the actual cleanup until all references are closed.</p>\n<p>⚠️ <strong>Pitfall: Work Directory Reuse</strong>\nOverlayFS requires the work directory to be empty for each mount operation. If cleanup fails to remove the work directory completely, subsequent container creation will fail with cryptic mount errors. <strong>Detection</strong>: Mount fails with &quot;work directory not empty&quot; or similar message. <strong>Solution</strong>: Always verify work directory is empty before mounting, and remove any stale files if found.</p>\n<p><strong>Cleanup state machine</strong> tracks the progress of cleanup operations and enables recovery from partial failures:</p>\n<table>\n<thead>\n<tr>\n<th>Cleanup State</th>\n<th>Description</th>\n<th>Next States</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CleanupStarted</code></td>\n<td>Cleanup initiated</td>\n<td><code>OverlayUnmounted</code>, <code>CleanupFailed</code></td>\n<td>Retry from beginning</td>\n</tr>\n<tr>\n<td><code>OverlayUnmounted</code></td>\n<td>Overlay filesystem unmounted</td>\n<td><code>DirectoriesRemoved</code>, <code>CleanupFailed</code></td>\n<td>Remove directories</td>\n</tr>\n<tr>\n<td><code>DirectoriesRemoved</code></td>\n<td>Container dirs removed</td>\n<td><code>ReferencesUpdated</code>, <code>CleanupFailed</code></td>\n<td>Update reference counts</td>\n</tr>\n<tr>\n<td><code>ReferencesUpdated</code></td>\n<td>Reference counts updated</td>\n<td><code>LayersChecked</code>, <code>CleanupFailed</code></td>\n<td>Check for unused layers</td>\n</tr>\n<tr>\n<td><code>LayersChecked</code></td>\n<td>Unused layers identified</td>\n<td><code>CleanupCompleted</code>, <code>CleanupFailed</code></td>\n<td>Remove unused layers</td>\n</tr>\n<tr>\n<td><code>CleanupCompleted</code></td>\n<td>All cleanup finished</td>\n<td>N/A</td>\n<td>Success</td>\n</tr>\n<tr>\n<td><code>CleanupFailed</code></td>\n<td>Error occurred</td>\n<td><code>CleanupStarted</code></td>\n<td>Manual intervention or retry</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Filesystem Operations</td>\n<td><code>syscall.Mount()</code> + <code>os.RemoveAll()</code></td>\n<td><code>sys/mount</code> with detailed error handling</td>\n</tr>\n<tr>\n<td>Directory Management</td>\n<td><code>os.MkdirAll()</code> + <code>filepath.Walk()</code></td>\n<td>Custom directory tree with atomic operations</td>\n</tr>\n<tr>\n<td>Layer Storage</td>\n<td>Simple directory hierarchy</td>\n<td>Content-addressable storage with deduplication</td>\n</tr>\n<tr>\n<td>Reference Counting</td>\n<td>JSON files on disk</td>\n<td>Embedded database (BoltDB)</td>\n</tr>\n<tr>\n<td>Mount Verification</td>\n<td>Parse <code>/proc/mounts</code></td>\n<td>Use <code>statfs()</code> and mount namespace APIs</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/filesystem/\n  manager.go              ← main filesystem manager\n  overlay.go              ← overlayfs operations\n  layers.go               ← layer management\n  cleanup.go              ← cleanup operations\n  references.go           ← reference counting\n  manager_test.go         ← integration tests\n  overlay_test.go         ← overlay-specific tests\n  testdata/               ← test layers and fixtures\n    base-layer/\n    app-layer/\n    expected-merged/</code></pre></div>\n\n<p><strong>Infrastructure Starter Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> filesystem</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LayerInfo represents metadata about a filesystem layer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LayerInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Digest      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"digest\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Size        </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">     `json:\"size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RefCount    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">       `json:\"ref_count\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FilesystemManager handles all overlay filesystem operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FilesystemManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storageRoot   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    layersDir     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containersDir </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    refsDir       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewFilesystemManager creates a new filesystem manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewFilesystemManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storageRoot</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fm </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        storageRoot:   storageRoot,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        layersDir:     filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(storageRoot, </span><span style=\"color:#9ECBFF\">\"layers\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        containersDir: filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(storageRoot, </span><span style=\"color:#9ECBFF\">\"containers\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        refsDir:       filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(storageRoot, </span><span style=\"color:#9ECBFF\">\"refs\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create required directory structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dirs </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{fm.layersDir, fm.containersDir, fm.refsDir}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, dir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> dirs {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(dir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create directory </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, dir, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fm, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LayerExists checks if a layer is available locally</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LayerExists</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    layerPath </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(fm.layersDir, digest)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Stat</span><span style=\"color:#E1E4E8\">(layerPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetLayerPath returns the filesystem path for a layer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetLayerPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">digest</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(fm.layersDir, digest)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetContainerPaths returns all paths for a container's overlay setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetContainerPaths</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#FFAB70\">upper</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">work</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">merged</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(fm.containersDir, containerID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"upper\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"work\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">           filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(containerDir, </span><span style=\"color:#9ECBFF\">\"merged\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReferenceManager handles layer reference counting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReferenceManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    refsDir </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddContainerReference records that a container uses specific layers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReferenceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddContainerReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">layers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    refFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rm.refsDir, </span><span style=\"color:#9ECBFF\">\"containers\"</span><span style=\"color:#E1E4E8\">, containerID</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\".json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(filepath.</span><span style=\"color:#B392F0\">Dir</span><span style=\"color:#E1E4E8\">(refFile), </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(layers)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">WriteFile</span><span style=\"color:#E1E4E8\">(refFile, data, </span><span style=\"color:#79B8FF\">0644</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveContainerReference removes a container's layer references</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReferenceManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveContainerReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    refFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rm.refsDir, </span><span style=\"color:#9ECBFF\">\"containers\"</span><span style=\"color:#E1E4E8\">, containerID</span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\">\".json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Remove</span><span style=\"color:#E1E4E8\">(refFile)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// PrepareContainerFilesystem creates and mounts overlay filesystem for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PrepareContainerFilesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">imageLayers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that all required image layers exist locally</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use LayerExists() for each layer digest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create container-specific directories (upper, work, merged)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use GetContainerPaths() and os.MkdirAll()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Ensure work directory is empty (overlayfs requirement)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Remove and recreate work directory if it exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add container reference to track layer usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use ReferenceManager.AddContainerReference()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Mount the overlay filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call MountOverlayFS() with properly ordered layers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MountOverlayFS mounts overlay filesystem with given layers and target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MountOverlayFS</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">layers</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate all layer directories exist and are accessible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check each layer path with os.Stat()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Construct lowerdir option by joining layer paths with \":\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use strings.Join() - order matters! Most recent layer first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Build complete mount options string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Format: \"lowerdir=/path1:/path2,upperdir=/upper,workdir=/work\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Get upper/work paths from target directory structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute overlay mount using syscall.Mount()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: syscall.Mount(\"overlay\", target, \"overlay\", 0, options)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify mount succeeded by checking target directory contents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: List files in target and compare with expected layer contents</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleCopyOnWrite demonstrates CoW behavior (for testing/debugging)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleCopyOnWrite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if file exists in lower layers but not upper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check merged view vs upper directory directly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If file is in lower layer, demonstrate that modification triggers copy-up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Write to file and verify copy appears in upper directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify original file in lower layer remains unchanged</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Compare checksums before and after modification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupContainerFilesystem removes overlay mount and directories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupContainerFilesystem</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get container paths (upper, work, merged)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use GetContainerPaths() method</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Unmount overlay filesystem from merged directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use syscall.Unmount() with 0 flags, retry with MNT_DETACH if busy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove container-specific directories (upper, work, merged)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use os.RemoveAll() for recursive removal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove container's layer references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use ReferenceManager.RemoveContainerReference()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check if any image layers can be cleaned up (reference count = 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement reference counting logic to identify unused layers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyOverlayMount checks that overlay mount is working correctly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyOverlayMount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that merged directory is actually a mount point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Parse /proc/mounts or use statfs() system call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify that files from all layers are visible in merged view</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: List expected files and check they appear in merged directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test that writes go to upper directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create test file in merged view, verify it appears in upper only</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test that whiteouts work for file deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Delete a file from lower layer, verify whiteout created in upper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints (Go):</strong></p>\n<ul>\n<li>Use <code>syscall.Mount(&quot;overlay&quot;, target, &quot;overlay&quot;, 0, options)</code> for overlay mounting</li>\n<li>Handle <code>syscall.EBUSY</code> errors on unmount by retrying with <code>syscall.MNT_DETACH</code></li>\n<li>Use <code>filepath.Join()</code> for cross-platform path construction</li>\n<li>Check mount success by parsing <code>/proc/mounts</code> or using <code>unix.Statfs()</code></li>\n<li>Use <code>os.MkdirAll()</code> with 0755 permissions for directory creation</li>\n<li>Implement proper cleanup with <code>defer</code> statements for resource management</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the overlay filesystem component:</p>\n<ol>\n<li><strong>Test layer mounting:</strong> Run <code>go test -v ./internal/filesystem -run TestOverlayMount</code></li>\n<li><strong>Expected behavior:</strong> Container should see merged view of all image layers</li>\n<li><strong>Manual verification:</strong></li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">   # Check overlay mount exists</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   mount</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> overlay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify upper directory captures changes  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#9ECBFF\"> \"test\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> /path/to/merged/testfile</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ls</span><span style=\"color:#9ECBFF\"> /path/to/upper/</span><span style=\"color:#6A737D\">  # should show testfile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Verify lower layers unchanged</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   ls</span><span style=\"color:#9ECBFF\"> /path/to/layer1/</span><span style=\"color:#6A737D\">  # original contents preserved</span></span></code></pre></div>\n<ol start=\"4\">\n<li><strong>Signs of trouble:</strong> Mount failures usually indicate work directory issues or invalid layer paths</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Invalid argument&quot; on mount</td>\n<td>Work directory not empty or wrong filesystem</td>\n<td>Check <code>ls -la workdir/</code> and <code>df workdir/</code></td>\n<td>Remove work directory contents, ensure same filesystem as upper</td>\n</tr>\n<tr>\n<td>&quot;Device busy&quot; on unmount</td>\n<td>Processes holding open files</td>\n<td>Use <code>lsof +D /merged/path</code> to find processes</td>\n<td>Kill processes or use MNT_DETACH for lazy unmount</td>\n</tr>\n<tr>\n<td>Files missing in merged view</td>\n<td>Wrong lowerdir order or missing layers</td>\n<td>Check mount options in <code>/proc/mounts</code></td>\n<td>Verify layer paths exist and fix ordering</td>\n</tr>\n<tr>\n<td>CoW not working</td>\n<td>Upper directory permissions or filesystem issues</td>\n<td>Test write to merged view, check if file appears in upper</td>\n<td>Fix upper directory permissions (755)</td>\n</tr>\n<tr>\n<td>Storage space not freed</td>\n<td>Cleanup didn&#39;t remove upper directory</td>\n<td>Check disk usage with <code>du -sh /var/lib/runtime/containers/</code></td>\n<td>Manual cleanup of container directories</td>\n</tr>\n</tbody></table>\n<h2 id=\"network-management-component\">Network Management Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Container Networking) - This section implements bridge networking for containers with port mapping and inter-container communication using veth pairs, bridge networks, and NAT rules.</p>\n</blockquote>\n<p>Container networking transforms isolated processes into communicating services by creating virtual network infrastructure that mimics physical networking concepts. The network management component orchestrates multiple Linux kernel networking features to provide containers with network interfaces, IP addresses, routing capabilities, and connectivity to both other containers and the external world. This component must handle the complexity of bridging multiple network namespaces while maintaining proper isolation boundaries and enabling controlled communication pathways.</p>\n<p>The fundamental challenge in container networking lies in the paradox of isolation versus connectivity. Containers need network isolation for security and resource management, but they also need selective connectivity for inter-service communication and external access. Our network management component resolves this paradox by creating controlled communication channels through virtual networking infrastructure, allowing containers to communicate as if they were separate physical machines connected through network switches and routers.</p>\n<h3 id=\"mental-model-virtual-cable-system\">Mental Model: Virtual Cable System</h3>\n<p>Think of container networking like building a virtual office building with separate apartments (containers) that need telephone and internet connectivity. Each apartment starts completely isolated with no communication ability whatsoever. To provide connectivity, we run virtual cables and install virtual network equipment.</p>\n<p>The <strong>veth pair</strong> acts like a special two-way cable with connectors on both ends. We plug one end into the apartment (container network namespace) and feed the other end through the wall into the building&#39;s main network room (host network namespace). This cable carries all network traffic bidirectionally between the apartment and the building&#39;s network infrastructure.</p>\n<p>The <strong>bridge</strong> functions like a network switch in the building&#39;s main network room. All the cables coming from different apartments plug into this switch, allowing apartments to communicate with each other. The switch learns which apartment is connected to which port and intelligently forwards messages between apartments.</p>\n<p><strong>IP address assignment</strong> works like assigning apartment numbers from a predetermined numbering scheme. Each apartment gets a unique address within the building&#39;s addressing plan (subnet), ensuring messages can be properly routed to the correct destination.</p>\n<p><strong>Port forwarding</strong> acts like a receptionist service that forwards calls from the building&#39;s main phone line to specific apartment extensions. When someone calls the building from outside and asks for a specific service, the receptionist (NAT rules) knows which apartment provides that service and forwards the call appropriately.</p>\n<p>This mental model helps understand that container networking creates a complete virtual networking infrastructure that mirrors physical networking concepts, allowing isolated containers to communicate in controlled and predictable ways.</p>\n<h3 id=\"veth-pair-and-bridge-setup\">Veth Pair and Bridge Setup</h3>\n<p>The foundation of container networking rests on creating <strong>virtual ethernet pairs (veth pairs)</strong> that connect isolated network namespaces to shared network infrastructure. A veth pair functions as a bidirectional pipe where packets written to one end immediately appear at the other end, enabling communication across namespace boundaries. The network management component must orchestrate the creation, configuration, and cleanup of these virtual network devices along with bridge networking that enables multi-container communication.</p>\n<p>The veth pair creation process begins by generating unique interface names to avoid conflicts with existing network devices. The component creates the veth pair in the host network namespace, then moves one end into the target container&#39;s network namespace while keeping the other end in the host namespace. This asymmetric placement allows the host to manage connectivity while providing the container with an isolated network interface.</p>\n<blockquote>\n<p><strong>Decision: Veth Pair Naming Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Veth interfaces need unique names to avoid conflicts, and names must be trackable for cleanup operations</li>\n<li><strong>Options Considered</strong>: Random names, UUID-based names, container-ID-based names</li>\n<li><strong>Decision</strong>: Use container ID prefix with interface type suffix (e.g., &quot;veth-container123-host&quot; and &quot;veth-container123-container&quot;)</li>\n<li><strong>Rationale</strong>: Container ID prefixes provide clear ownership mapping for cleanup operations while remaining human-readable for debugging. The host/container suffix clarifies which end of the pair each interface represents.</li>\n<li><strong>Consequences</strong>: Enables efficient cleanup by interface name pattern matching, simplifies debugging by making interface ownership obvious, but limits container ID length due to Linux interface name restrictions.</li>\n</ul>\n</blockquote>\n<p>After creating the veth pair, the component must configure each interface with appropriate settings. The container-side interface receives an IP address from the configured subnet pool, while the host-side interface remains addressless but gets attached to the container bridge. Both interfaces must be brought up (activated) to enable packet flow, and the container interface typically becomes the default gateway interface within the container&#39;s network namespace.</p>\n<p>The bridge setup process creates or reuses a shared bridge device that functions as a virtual network switch for container communication. The bridge maintains a MAC address learning table that maps container MAC addresses to specific ports, enabling efficient packet forwarding between containers. All host-side veth interfaces connect to this bridge, creating a shared layer-2 network segment for container communication.</p>\n<p><strong>Veth Pair Creation Algorithm:</strong></p>\n<ol>\n<li>Generate unique interface names using container ID and interface type suffixes to ensure no naming conflicts with existing network devices</li>\n<li>Create the veth pair in the host network namespace using the netlink library or ip command with both interfaces initially in the host namespace</li>\n<li>Move the container-side interface into the target container&#39;s network namespace using the setns system call or netlink operations</li>\n<li>Configure the container-side interface with an assigned IP address and appropriate subnet mask from the container network&#39;s address pool</li>\n<li>Set the container-side interface as the active default route within the container&#39;s network namespace for external connectivity</li>\n<li>Bring up both interfaces (host-side and container-side) to enable packet forwarding and establish the communication channel</li>\n<li>Attach the host-side interface to the container bridge, registering it as a bridge port for inter-container communication</li>\n<li>Configure MAC address learning and forwarding rules on the bridge port to enable proper packet switching between containers</li>\n<li>Store interface names and configuration details in the container state for cleanup operations when the container terminates</li>\n</ol>\n<p>The bridge configuration requires careful attention to forwarding policies and security settings. The bridge must enable packet forwarding between attached ports while maintaining isolation from the host&#39;s main network interfaces unless explicitly configured otherwise. Bridge forwarding delays and learning timeouts affect container communication latency and convergence time for network topology changes.</p>\n<table>\n<thead>\n<tr>\n<th>Veth Configuration Parameter</th>\n<th>Host Side Value</th>\n<th>Container Side Value</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Interface Name</td>\n<td><code>veth-{containerID}-host</code></td>\n<td><code>veth-{containerID}-container</code></td>\n<td>Unique identification and cleanup tracking</td>\n</tr>\n<tr>\n<td>IP Address</td>\n<td>None (bridge attached)</td>\n<td>Assigned from subnet pool</td>\n<td>Container network identity</td>\n</tr>\n<tr>\n<td>Subnet Mask</td>\n<td>N/A</td>\n<td>/24 (or configured subnet)</td>\n<td>Network boundary definition</td>\n</tr>\n<tr>\n<td>MTU Size</td>\n<td>1500 (or bridge MTU)</td>\n<td>1500 (matches host side)</td>\n<td>Maximum packet size consistency</td>\n</tr>\n<tr>\n<td>MAC Address</td>\n<td>Auto-generated</td>\n<td>Auto-generated</td>\n<td>Layer-2 addressing</td>\n</tr>\n<tr>\n<td>Administrative State</td>\n<td>UP</td>\n<td>UP</td>\n<td>Interface activation</td>\n</tr>\n<tr>\n<td>Bridge Attachment</td>\n<td>Yes (container bridge)</td>\n<td>No (not applicable)</td>\n<td>Inter-container communication</td>\n</tr>\n<tr>\n<td>Default Route</td>\n<td>No</td>\n<td>Yes (via bridge IP)</td>\n<td>External connectivity</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical insight here is that veth pairs create a controlled breach in network namespace isolation. While containers remain isolated at the process and filesystem levels, the veth pair provides a precisely managed communication channel that enables networking while preserving other isolation boundaries.</p>\n</blockquote>\n<p><strong>Bridge Management Algorithm:</strong></p>\n<ol>\n<li>Check if the container bridge already exists, creating it if necessary with appropriate forwarding and learning settings</li>\n<li>Configure bridge IP address and subnet if this is the first container using the bridge, establishing the gateway address for container routing</li>\n<li>Enable IP forwarding on the bridge interface to allow packets to flow between bridge ports and external networks</li>\n<li>Set bridge forwarding delay and aging time parameters to optimize convergence time and memory usage for container networking patterns</li>\n<li>Attach the host-side veth interface as a bridge port, enabling the container to participate in the shared layer-2 network</li>\n<li>Configure port-specific settings like learning, flooding, and STP participation based on security and performance requirements</li>\n<li>Update bridge forwarding database with static entries if required for specific security or performance optimizations</li>\n<li>Enable or disable bridge features like VLAN filtering, multicast snooping, and spanning tree protocol based on deployment requirements</li>\n</ol>\n<p>The component must handle bridge lifecycle management, creating bridges on demand and cleaning them up when no containers remain attached. Bridge cleanup requires careful ordering to avoid leaving orphaned network devices or disrupting communication for remaining containers.</p>\n<h3 id=\"ip-address-assignment\">IP Address Assignment</h3>\n<p>Container IP address assignment requires maintaining a pool of available addresses within a configured subnet while ensuring uniqueness and preventing conflicts with host network addressing. The network management component implements an IP address manager that tracks allocations, handles assignment and release operations, and persists address assignments across container restarts to maintain network identity stability.</p>\n<p>The IP address pool operates within a designated subnet range that must not conflict with the host&#39;s network configuration or other container runtime instances. The component typically reserves the first address in the subnet for the bridge gateway, the last address for broadcast, and manages the remaining addresses as an assignable pool. Address assignment follows a deterministic or pseudo-random strategy to balance predictability with conflict avoidance.</p>\n<blockquote>\n<p><strong>Decision: IP Address Assignment Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Containers need unique IP addresses from a managed pool, with consideration for restart stability and conflict avoidance</li>\n<li><strong>Options Considered</strong>: Sequential assignment, hash-based deterministic assignment, random assignment with conflict detection</li>\n<li><strong>Decision</strong>: Implement hash-based deterministic assignment with fallback to sequential search for conflicts</li>\n<li><strong>Rationale</strong>: Hash-based assignment using container ID provides stable addresses across container restarts, improving debugging and configuration consistency. Sequential fallback ensures assignment success even with hash collisions.</li>\n<li><strong>Consequences</strong>: Enables predictable container addressing for development and testing scenarios, but requires careful hash distribution to avoid clustering in the address space.</li>\n</ul>\n</blockquote>\n<p>The address assignment process begins by computing a candidate address using a hash function applied to the container ID, then checking for conflicts with existing assignments. If the candidate address is available, the component reserves it and associates it with the container in the persistent address allocation table. If conflicts occur, the component falls back to sequential search from the candidate address to find the next available address.</p>\n<p>Address persistence ensures that containers receive the same IP address across restarts when possible, maintaining network identity for services that depend on stable addressing. The component stores address assignments in a persistent data structure that survives runtime restarts and provides atomic allocation and release operations to prevent corruption during concurrent operations.</p>\n<table>\n<thead>\n<tr>\n<th>IP Assignment State</th>\n<th>Container ID</th>\n<th>Assigned IP</th>\n<th>Allocation Time</th>\n<th>Lease Expiry</th>\n<th>Status</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Active</td>\n<td>container-web-01</td>\n<td>172.16.0.10</td>\n<td>2024-01-15T10:30:00Z</td>\n<td>Never</td>\n<td>Running</td>\n</tr>\n<tr>\n<td>Active</td>\n<td>container-db-01</td>\n<td>172.16.0.11</td>\n<td>2024-01-15T10:31:00Z</td>\n<td>Never</td>\n<td>Running</td>\n</tr>\n<tr>\n<td>Reserved</td>\n<td>container-web-02</td>\n<td>172.16.0.12</td>\n<td>2024-01-15T10:32:00Z</td>\n<td>2024-01-15T11:32:00Z</td>\n<td>Stopped</td>\n</tr>\n<tr>\n<td>Released</td>\n<td>N/A</td>\n<td>172.16.0.13</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Available</td>\n</tr>\n</tbody></table>\n<p><strong>IP Address Assignment Algorithm:</strong></p>\n<ol>\n<li>Load the current address allocation table from persistent storage to understand which addresses are currently assigned or reserved</li>\n<li>Compute candidate IP address by applying a hash function to the container ID, mapping to the configured subnet address range</li>\n<li>Check if the candidate address is available in the allocation table, considering both active assignments and temporary reservations</li>\n<li>If candidate is available, reserve the address for this container and update the allocation table with atomic write operations</li>\n<li>If candidate is unavailable, perform sequential search starting from candidate address to find the next available address in the subnet</li>\n<li>Validate that the selected address doesn&#39;t conflict with reserved addresses (gateway, broadcast, network) or host interface addresses</li>\n<li>Create a lease record with container ID, assigned address, allocation timestamp, and lease expiration policy for cleanup operations</li>\n<li>Configure the container&#39;s network interface with the assigned address, subnet mask, and default gateway pointing to the bridge</li>\n<li>Update the allocation table with the final assignment and ensure changes are persisted to storage before returning success</li>\n</ol>\n<p>The component implements address conflict detection by maintaining both active assignments (for running containers) and reserved assignments (for recently stopped containers). Reserved assignments have expiration times that allow address reuse while providing stability for containers that restart quickly. This two-tier approach balances address space efficiency with operational convenience.</p>\n<p>Address release requires careful cleanup to avoid premature reuse that could cause network conflicts. When containers stop, their addresses transition to reserved status with configurable lease expiration times. After lease expiration, addresses return to the available pool. The component implements background cleanup processes that reclaim expired addresses and compact the allocation table.</p>\n<p><strong>Subnet Pool Configuration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Default Value</th>\n<th>Description</th>\n<th>Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Subnet CIDR</td>\n<td>172.16.0.0/24</td>\n<td>Network range for container addresses</td>\n<td>Must not conflict with host routes</td>\n</tr>\n<tr>\n<td>Gateway Address</td>\n<td>172.16.0.1</td>\n<td>Bridge IP address for container default route</td>\n<td>First usable address in subnet</td>\n</tr>\n<tr>\n<td>Address Pool Start</td>\n<td>172.16.0.10</td>\n<td>First address available for container assignment</td>\n<td>After gateway and reserved addresses</td>\n</tr>\n<tr>\n<td>Address Pool End</td>\n<td>172.16.0.250</td>\n<td>Last address available for container assignment</td>\n<td>Before broadcast and reserved addresses</td>\n</tr>\n<tr>\n<td>Lease Duration</td>\n<td>1 hour</td>\n<td>Time to hold reserved addresses after container stop</td>\n<td>Balance stability vs efficiency</td>\n</tr>\n<tr>\n<td>Allocation Strategy</td>\n<td>Hash + Sequential</td>\n<td>Method for selecting candidate addresses</td>\n<td>Deterministic with conflict resolution</td>\n</tr>\n</tbody></table>\n<p>The network management component must coordinate IP address assignments with DNS configuration when containers require hostname resolution. Address assignments can trigger DNS record creation in internal DNS servers, enabling containers to resolve each other by hostname in addition to IP address communication.</p>\n<h3 id=\"port-forwarding-with-nat\">Port Forwarding with NAT</h3>\n<p>Port forwarding enables external clients to access services running inside containers by creating Network Address Translation (NAT) rules that redirect traffic from host ports to container ports. The network management component implements port forwarding using iptables rules that modify packet headers as traffic flows between the external network and container network namespaces. This capability transforms isolated container services into accessible network services while maintaining container isolation for non-forwarded ports.</p>\n<p>The port forwarding mechanism operates by intercepting packets destined for specific host ports and redirecting them to corresponding container IP addresses and ports. The component creates iptables rules in the NAT table that perform Destination Network Address Translation (DNAT), changing the destination address from the host IP to the container IP while preserving the original source information for proper return routing.</p>\n<p>Port forwarding configuration requires careful coordination between the host firewall rules, bridge forwarding policies, and container network configuration. The component must ensure that forwarded traffic can traverse all network boundaries while maintaining security restrictions for non-forwarded traffic. This involves creating rules in multiple iptables chains and tables to handle different phases of packet processing.</p>\n<blockquote>\n<p><strong>Decision: NAT Rule Management Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Container port forwarding requires iptables rules that must be created atomically and cleaned up reliably without interfering with other system rules</li>\n<li><strong>Options Considered</strong>: Direct iptables rule manipulation, custom chain isolation, netfilter hooks programmatic control</li>\n<li><strong>Decision</strong>: Use custom iptables chains for container rules with atomic rule set replacement</li>\n<li><strong>Rationale</strong>: Custom chains provide isolation from system rules, reducing the risk of conflicts. Atomic replacement ensures consistent rule states during updates. Chain-based organization simplifies bulk cleanup operations.</li>\n<li><strong>Consequences</strong>: Enables safe concurrent rule management and reliable cleanup, but requires understanding of iptables chain traversal and rule precedence for effective debugging.</li>\n</ul>\n</blockquote>\n<p>The component creates dedicated iptables chains for container networking rules, avoiding conflicts with system-level firewall policies. Container-specific DNAT rules are added to these custom chains, with jump rules in the standard chains directing relevant traffic through the container rule processing. This architecture enables atomic updates and complete cleanup of container networking rules without affecting other system networking configuration.</p>\n<p>Port forwarding rules must handle both TCP and UDP protocols with appropriate connection tracking and state management. The component creates separate rules for each protocol type, ensuring that connection state tracking works correctly for bi-directional communication. Return traffic must be properly handled through connection tracking to maintain the appearance of direct communication between external clients and container services.</p>\n<table>\n<thead>\n<tr>\n<th>Port Mapping Configuration</th>\n<th>Host Port</th>\n<th>Container IP</th>\n<th>Container Port</th>\n<th>Protocol</th>\n<th>Rule Priority</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Web Service</td>\n<td>8080</td>\n<td>172.16.0.10</td>\n<td>80</td>\n<td>TCP</td>\n<td>100</td>\n</tr>\n<tr>\n<td>Database Access</td>\n<td>5432</td>\n<td>172.16.0.11</td>\n<td>5432</td>\n<td>TCP</td>\n<td>100</td>\n</tr>\n<tr>\n<td>DNS Service</td>\n<td>53</td>\n<td>172.16.0.12</td>\n<td>53</td>\n<td>UDP</td>\n<td>100</td>\n</tr>\n<tr>\n<td>SSH Access</td>\n<td>2222</td>\n<td>172.16.0.10</td>\n<td>22</td>\n<td>TCP</td>\n<td>100</td>\n</tr>\n<tr>\n<td>Custom API</td>\n<td>9000</td>\n<td>172.16.0.13</td>\n<td>3000</td>\n<td>TCP</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p><strong>Port Forwarding Setup Algorithm:</strong></p>\n<ol>\n<li>Validate port mapping configuration to ensure host ports are not already in use by other services or containers</li>\n<li>Create container-specific iptables chain names to isolate rules and enable atomic cleanup operations when containers are removed</li>\n<li>Add jump rules to standard iptables chains (PREROUTING, FORWARD) that direct container traffic to the custom chains for processing</li>\n<li>Create DNAT rules in the PREROUTING chain that change destination address from host IP to container IP for specified ports</li>\n<li>Create FORWARD rules that allow traffic to flow from external interfaces to the container bridge for forwarded ports only</li>\n<li>Enable connection tracking for return traffic by creating corresponding rules in the POSTROUTING chain for source NAT if required</li>\n<li>Configure bridge forwarding rules to allow traffic destined for container IP addresses to traverse the bridge interface correctly</li>\n<li>Test connectivity by verifying that packets can flow bidirectionally between external clients and container services through the NAT rules</li>\n<li>Store port mapping configuration in container state for proper cleanup when the container is stopped or removed</li>\n</ol>\n<p>The component must handle port conflict detection to prevent multiple containers from attempting to bind the same host port. Port allocation tracking maintains a registry of active port forwarding rules, preventing conflicts during container creation and enabling proper cleanup during container removal.</p>\n<p>Connection tracking configuration affects the performance and reliability of port forwarding rules. The component configures netfilter connection tracking parameters to handle the expected connection volume and timeout characteristics of container services. Proper connection tracking ensures that established connections continue working even if iptables rules are temporarily modified during container updates.</p>\n<p><strong>IPTables Rule Structure:</strong></p>\n<p>The network management component creates a structured set of iptables rules organized into logical groups for maintainability and atomic updates:</p>\n<table>\n<thead>\n<tr>\n<th>Chain Name</th>\n<th>Table</th>\n<th>Purpose</th>\n<th>Rule Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONTAINER-DNAT</td>\n<td>nat</td>\n<td>Destination address translation for inbound traffic</td>\n<td><code>-p tcp --dport 8080 -j DNAT --to-destination 172.16.0.10:80</code></td>\n</tr>\n<tr>\n<td>CONTAINER-FORWARD</td>\n<td>filter</td>\n<td>Traffic forwarding authorization for container access</td>\n<td><code>-d 172.16.0.10 -p tcp --dport 80 -j ACCEPT</code></td>\n</tr>\n<tr>\n<td>CONTAINER-POSTROUTING</td>\n<td>nat</td>\n<td>Source address translation for outbound traffic if needed</td>\n<td><code>-s 172.16.0.0/24 ! -d 172.16.0.0/24 -j MASQUERADE</code></td>\n</tr>\n</tbody></table>\n<p>Port forwarding cleanup requires removing all related iptables rules in the correct order to avoid temporary connectivity disruption or rule inconsistencies. The component implements a cleanup algorithm that removes rules from chains in dependency order, then removes custom chains once they are empty. This ensures that no orphaned rules remain that could interfere with future container networking operations.</p>\n<p>⚠️ <strong>Pitfall: Persistent IPTables Rules</strong></p>\n<p>A common mistake is failing to properly clean up iptables rules when containers are removed, leading to accumulated rule sets that can cause port conflicts and security vulnerabilities. The issue manifests as &quot;port already in use&quot; errors when creating new containers, or unexpected traffic forwarding to non-existent containers.</p>\n<p>The problem occurs because iptables rules persist independently of the processes that created them. Even if a container stops or the container runtime crashes, the NAT and forwarding rules remain active in the kernel. This leads to several problematic scenarios: host ports appear occupied when they&#39;re not, traffic gets dropped because target containers no longer exist, and rule accumulation degrades networking performance.</p>\n<p>The solution requires implementing robust cleanup procedures that execute during both normal container shutdown and runtime recovery operations. The component must maintain accurate records of which iptables rules belong to which containers, and implement cleanup verification that ensures rules are actually removed. Additionally, the runtime should perform rule audit operations on startup to clean up orphaned rules from previous runtime instances.</p>\n<p><strong>Advanced Port Forwarding Features:</strong></p>\n<p>The network management component can extend basic port forwarding with additional features that improve usability and security:</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Implementation Approach</th>\n<th>Benefits</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Port Allocation</td>\n<td>Maintain pool of available host ports, assign automatically</td>\n<td>Reduces port conflicts, simplifies container deployment</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Port Range Forwarding</td>\n<td>Create rules for contiguous port ranges rather than individual ports</td>\n<td>Supports applications that use multiple ports</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Source IP Filtering</td>\n<td>Add source address restrictions to DNAT rules</td>\n<td>Enhances security by limiting access origins</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Load Balancing</td>\n<td>Distribute traffic across multiple container instances</td>\n<td>Improves service availability and performance</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fnetwork-topology.svg\" alt=\"Container Network Topology\"></p>\n<p>The network topology diagram illustrates how these networking components work together to create a complete container networking solution. Containers receive isolated network namespaces connected through veth pairs to a shared bridge, with iptables NAT rules enabling external access to container services while maintaining isolation boundaries.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Veth Interface Cleanup Order</strong></p>\n<p>A frequent mistake involves deleting the host-side veth interface before properly shutting down the container process, causing network connectivity loss and potential container hanging. When the host-side veth interface disappears while the container is still running, the container loses all network connectivity including the ability to shut down gracefully if it needs to communicate with external services during shutdown.</p>\n<p>This problem manifests as containers that appear to stop responding during shutdown sequences, taking the full shutdown timeout before being forcefully terminated. The issue occurs because the container&#39;s network interface becomes unusable when its paired host interface is removed, but the container may not detect this failure immediately and continues attempting network operations.</p>\n<p>The solution requires implementing proper shutdown sequencing where container processes are terminated first, allowing them to complete network-dependent shutdown operations before their network interfaces are removed. The component should wait for container process termination before cleaning up veth interfaces, and implement timeout handling for containers that fail to shut down gracefully within reasonable time limits.</p>\n<p>⚠️ <strong>Pitfall: Bridge MTU Misconfiguration</strong></p>\n<p>Incorrectly configured Maximum Transmission Unit (MTU) sizes between veth interfaces and the container bridge cause packet fragmentation and connectivity problems that are difficult to diagnose. When veth interfaces have different MTU sizes than the bridge they connect to, large packets get fragmented or dropped, leading to inconsistent connectivity where small requests work but large data transfers fail.</p>\n<p>The problem typically appears as applications that work for small operations but fail when transferring larger amounts of data. Web applications might load basic pages but fail when uploading files or receiving large API responses. The issue is particularly confusing because basic connectivity tests succeed while real-world usage fails unpredictably.</p>\n<p>The solution requires ensuring MTU consistency across all components in the network path: host interfaces, bridge interfaces, and container veth interfaces must all use compatible MTU sizes. The component should detect the host network MTU and configure all container networking components to use the same or smaller MTU values, avoiding fragmentation issues.</p>\n<p>⚠️ <strong>Pitfall: IP Address Pool Exhaustion</strong></p>\n<p>Failing to implement proper address pool management leads to IP address exhaustion when containers are created and destroyed frequently, especially during development and testing scenarios. The pool exhaustion occurs when addresses remain marked as &quot;in use&quot; after containers are removed, eventually preventing new container creation even though no containers are actually using the addresses.</p>\n<p>This problem manifests as container creation failures with &quot;no available IP addresses&quot; errors, even when few or no containers are currently running. The issue compounds over time as the pool becomes increasingly fragmented with unusable address reservations. Development workflows that create and destroy many containers quickly are particularly susceptible to this problem.</p>\n<p>The solution requires implementing robust address lifecycle management with proper cleanup procedures and lease expiration handling. The component must track address assignments accurately, implement cleanup verification to ensure addresses are actually released when containers stop, and provide administrative tools to manually reclaim orphaned address allocations when automatic cleanup fails.</p>\n<p>⚠️ <strong>Pitfall: IPTables Rule Conflicts</strong></p>\n<p>Creating iptables rules without considering existing system firewall configuration can cause rule conflicts that break both container networking and host system connectivity. The conflicts arise when container networking rules interfere with system security policies, or when system changes modify the iptables configuration in ways that break container connectivity.</p>\n<p>This problem appears as intermittent connectivity failures that depend on the specific system firewall configuration and the order of rule evaluation. Containers might lose network access after system updates that modify firewall rules, or system services might become inaccessible when container networking rules interfere with host networking policies.</p>\n<p>The solution requires implementing defensive rule management that uses custom iptables chains to isolate container networking rules from system rules. The component should check for existing rule conflicts before creating new rules, use rule priorities that don&#39;t interfere with system security policies, and implement rule verification procedures that detect when external changes break container networking functionality.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The network management component requires careful integration with Linux networking APIs and external tools to create and manage virtual network infrastructure. This component represents the most complex aspect of container runtime development due to its dependencies on kernel networking features and interaction with system-level network configuration.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Netlink Communication</td>\n<td><code>vishvananda/netlink</code> Go library</td>\n<td>Direct netlink socket programming</td>\n</tr>\n<tr>\n<td>IP Address Management</td>\n<td>File-based JSON persistence</td>\n<td>Embedded database (BoltDB/BadgerDB)</td>\n</tr>\n<tr>\n<td>IPTables Management</td>\n<td><code>coreos/go-iptables</code> wrapper library</td>\n<td>Direct iptables binary execution</td>\n</tr>\n<tr>\n<td>Network Interface Creation</td>\n<td><code>ip</code> command execution via <code>os/exec</code></td>\n<td>Pure netlink API calls</td>\n</tr>\n<tr>\n<td>Bridge Management</td>\n<td>Linux bridge utilities + commands</td>\n<td>Programmatic netlink bridge control</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-runtime/\n  internal/network/\n    manager.go              ← main network management orchestrator\n    veth.go                ← veth pair creation and management\n    bridge.go              ← bridge networking setup and control\n    ipam.go                ← IP address allocation and management\n    nat.go                 ← port forwarding and iptables rules\n    types.go               ← network-related data structures\n    manager_test.go        ← comprehensive networking integration tests\n  internal/netutil/\n    netlink.go             ← netlink communication helpers\n    iptables.go            ← iptables rule management utilities\n    validation.go          ← network configuration validation\n  configs/\n    network-default.json   ← default network configuration</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Network Utilities):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package netutil provides low-level networking utilities for container runtime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> netutil</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/vishvananda/netlink</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/coreos/go-iptables/iptables</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkConfig defines network configuration for containers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BridgeName    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"bridge_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SubnetCIDR    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"subnet_cidr\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GatewayIP     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"gateway_ip\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DNSServers    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"dns_servers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPTablesChain </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `json:\"iptables_chain\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IPTablesManager wraps iptables operations with error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IPTablesManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ipt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">iptables</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPTables</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewIPTablesManager creates a new iptables manager instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewIPTablesManager</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ipt, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> iptables.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to initialize iptables: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">{ipt: ipt}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateChain creates a custom iptables chain for container rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateChain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">chain</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exists, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.ipt.</span><span style=\"color:#B392F0\">ChainExists</span><span style=\"color:#E1E4E8\">(table, chain)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to check chain existence: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.ipt.</span><span style=\"color:#B392F0\">NewChain</span><span style=\"color:#E1E4E8\">(table, chain); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create chain </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, chain, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddRule adds an iptables rule with validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">chain</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rulespec</span><span style=\"color:#F97583\"> ...</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exists, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.ipt.</span><span style=\"color:#B392F0\">Exists</span><span style=\"color:#E1E4E8\">(table, chain, rulespec</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to check rule existence: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.ipt.</span><span style=\"color:#B392F0\">Insert</span><span style=\"color:#E1E4E8\">(table, chain, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, rulespec</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add rule: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RemoveRule removes an iptables rule with validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPTablesManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RemoveRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">table</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">chain</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rulespec</span><span style=\"color:#F97583\"> ...</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    exists, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.ipt.</span><span style=\"color:#B392F0\">Exists</span><span style=\"color:#E1E4E8\">(table, chain, rulespec</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to check rule existence: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> m.ipt.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(table, chain, rulespec</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to remove rule: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetlinkHelper provides higher-level netlink operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetlinkHelper</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateVethPair creates a veth pair with specified names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">n </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateVethPair</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">hostName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hostVeth </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Veth</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LinkAttrs: </span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">LinkAttrs</span><span style=\"color:#E1E4E8\">{Name: hostName},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PeerName:  containerName,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkAdd</span><span style=\"color:#E1E4E8\">(hostVeth); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create veth pair: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MoveInterfaceToNamespace moves network interface to target namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">n </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MoveInterfaceToNamespace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">interfaceName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    link, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(interfaceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, interfaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetNsPid</span><span style=\"color:#E1E4E8\">(link, pid); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to move interface to namespace: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConfigureInterface sets IP address and brings interface up</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">n </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ConfigureInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">interfaceName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ipAddr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    link, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(interfaceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, interfaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    addr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">ParseAddr</span><span style=\"color:#E1E4E8\">(ipAddr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to parse IP address </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, ipAddr, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">AddrAdd</span><span style=\"color:#E1E4E8\">(link, addr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add IP address: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetUp</span><span style=\"color:#E1E4E8\">(link); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to bring interface up: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateBridge creates and configures a network bridge</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">n </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateBridge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">bridgeName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bridgeIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bridge </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Bridge</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LinkAttrs: </span><span style=\"color:#B392F0\">netlink</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">LinkAttrs</span><span style=\"color:#E1E4E8\">{Name: bridgeName},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkAdd</span><span style=\"color:#E1E4E8\">(bridge); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">strings.</span><span style=\"color:#B392F0\">Contains</span><span style=\"color:#E1E4E8\">(err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"file exists\"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to create bridge: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> bridgeIP </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> n.</span><span style=\"color:#B392F0\">ConfigureInterface</span><span style=\"color:#E1E4E8\">(bridgeName, bridgeIP); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to configure bridge IP: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AttachInterfaceToBridge attaches interface to bridge</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">n </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetlinkHelper</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AttachInterfaceToBridge</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">interfaceName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bridgeName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iface, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(interfaceName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find interface </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, interfaceName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bridge, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkByName</span><span style=\"color:#E1E4E8\">(bridgeName)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to find bridge </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, bridgeName, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> netlink.</span><span style=\"color:#B392F0\">LinkSetMaster</span><span style=\"color:#E1E4E8\">(iface, bridge); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to attach interface to bridge: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateNetworkConfig validates network configuration parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateNetworkConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> NetworkConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.BridgeName </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bridge name cannot be empty\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> net.</span><span style=\"color:#B392F0\">ParseCIDR</span><span style=\"color:#E1E4E8\">(config.SubnetCIDR)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid subnet CIDR: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> net.</span><span style=\"color:#B392F0\">ParseIP</span><span style=\"color:#E1E4E8\">(config.GatewayIP) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid gateway IP address: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, config.GatewayIP)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package network implements container networking with veth pairs, bridges, and NAT</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> network</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">container-runtime/internal/netutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager orchestrates container networking operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config       </span><span style=\"color:#B392F0\">netutil</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetworkConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ipam         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAddressManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iptables     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">netutil</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPTablesManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    netlink      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">netutil</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetlinkHelper</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerNetwork</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerNetwork tracks networking state for a container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerNetwork</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VethHost        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VethContainer   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PortMappings    []</span><span style=\"color:#B392F0\">PortMapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewManager creates a new network manager instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> netutil</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NetworkConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate network configuration parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize IP address manager with subnet pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create iptables manager for NAT rule management</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Initialize netlink helper for interface operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create container bridge if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set up base iptables chains for container networking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Enable IP forwarding on the host system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use netutil.ValidateNetworkConfig for validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupContainerNetwork creates complete network setup for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">portMappings</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerNetwork</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique veth interface names for this container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allocate IP address from the managed pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create veth pair in host network namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Move container-side veth to container network namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Configure container interface with allocated IP address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Attach host-side veth to container bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Create port forwarding rules for specified port mappings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Store container network state for cleanup operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Verify connectivity by testing basic network operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use m.createVethPair, m.allocateIPAddress, m.setupPortForwarding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// createVethPair creates and configures veth pair for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createVethPair</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">hostVeth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerVeth</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create veth pair using netlink helper with generated names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Move container-side interface to container network namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Bring up host-side interface in host namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Attach host-side interface to container bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify both interfaces are properly configured and active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use netlink helper methods for interface operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// configureContainerInterface sets up networking inside container namespace</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">configureContainerInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerVeth</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ipAddress</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Enter container network namespace using setns syscall</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Configure container interface with assigned IP address</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up default route pointing to bridge gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Configure loopback interface for internal communication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return to host network namespace after configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use netlink operations within target namespace context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// setupPortForwarding creates NAT rules for container port access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">setupPortForwarding</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerIP</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">portMappings</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">PortMapping</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create container-specific iptables chain for isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add jump rule to direct traffic to container chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create DNAT rules for each port mapping specification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create corresponding FORWARD rules for traffic authorization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Add MASQUERADE rule for return traffic if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify rules are active and processing traffic correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use iptables manager methods with proper rule ordering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupContainerNetwork removes all network resources for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container network state from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove port forwarding iptables rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Delete custom iptables chains if empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove veth interfaces from bridge and host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Release IP address back to available pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Clean up container network state records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify all resources are properly cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement cleanup in reverse order of setup operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IPAddressManager handles IP address allocation and tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IPAddressManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subnet      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IPNet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gateway     </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">IP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    allocated   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // containerID -> IP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reserved    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\">  // IP -> expiry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AllocateIP assigns IP address to container with conflict detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ipam </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAddressManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AllocateIP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if container already has IP assignment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compute candidate IP using hash of container ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify candidate IP is within subnet and not reserved</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If candidate unavailable, search sequentially for free IP</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Reserve selected IP address for this container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update allocation records with persistent storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return assigned IP address in CIDR notation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use hash function for deterministic assignment strategy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReleaseIP returns IP address to available pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ipam </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IPAddressManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReleaseIP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up current IP assignment for container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove active allocation record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add IP to reserved pool with expiration time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update persistent storage with allocation changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify IP is properly marked as available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement grace period before returning IP to pool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>vishvananda/netlink</code> library for programmatic network interface management instead of executing shell commands</li>\n<li>The <code>coreos/go-iptables</code> library provides safe iptables rule management with existence checking and atomic operations</li>\n<li>Network namespace operations require <code>syscall.Setns()</code> to enter target namespace before configuring interfaces</li>\n<li>Use <code>sync.RWMutex</code> for concurrent access to IP allocation maps and container network state</li>\n<li>Implement proper cleanup with <code>defer</code> statements to ensure resources are released even if errors occur</li>\n<li>Use <code>context.Context</code> for timeout handling during network operations that might hang</li>\n<li>The <code>net</code> package provides utilities for IP address parsing, subnet calculations, and CIDR operations</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the network management component, verify functionality with these tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test 1: Basic container networking</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/container-runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --id</span><span style=\"color:#9ECBFF\"> test-net</span><span style=\"color:#79B8FF\"> --image</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#79B8FF\"> --command</span><span style=\"color:#9ECBFF\"> \"sleep 30\"</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#9ECBFF\"> 8080:80</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Container starts with assigned IP address and veth pair created</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 2: Inter-container communication  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/container-runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --id</span><span style=\"color:#9ECBFF\"> container1</span><span style=\"color:#79B8FF\"> --image</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#79B8FF\"> --command</span><span style=\"color:#9ECBFF\"> \"nc -l -p 8080\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/container-runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --id</span><span style=\"color:#9ECBFF\"> container2</span><span style=\"color:#79B8FF\"> --image</span><span style=\"color:#9ECBFF\"> alpine</span><span style=\"color:#79B8FF\"> --command</span><span style=\"color:#9ECBFF\"> \"nc container1-ip 8080\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Containers can communicate directly via bridge networking</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 3: Port forwarding functionality</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/container-runtime/main.go</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --id</span><span style=\"color:#9ECBFF\"> web-server</span><span style=\"color:#79B8FF\"> --image</span><span style=\"color:#9ECBFF\"> nginx</span><span style=\"color:#79B8FF\"> --port</span><span style=\"color:#9ECBFF\"> 8080:80</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: External access to container service through port forwarding</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test 4: Network cleanup verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/container-runtime/main.go</span><span style=\"color:#9ECBFF\"> remove</span><span style=\"color:#9ECBFF\"> web-server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">iptables</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> nat</span><span style=\"color:#79B8FF\"> -L</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"web-server\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> show</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"veth-web-server\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: No iptables rules or veth interfaces remain after cleanup</span></span></code></pre></div>\n\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container has no network connectivity</td>\n<td>Veth pair not created or misconfigured</td>\n<td><code>ip link show</code> in both namespaces</td>\n<td>Verify veth creation and namespace assignment</td>\n</tr>\n<tr>\n<td>External clients can&#39;t reach container</td>\n<td>Port forwarding rules missing or incorrect</td>\n<td><code>iptables -t nat -L -n</code> to check DNAT rules</td>\n<td>Recreate iptables rules with correct addresses</td>\n</tr>\n<tr>\n<td>Containers can&#39;t communicate with each other</td>\n<td>Bridge not forwarding or IP assignment conflicts</td>\n<td><code>brctl show</code> and ping tests between containers</td>\n<td>Check bridge configuration and IP allocations</td>\n</tr>\n<tr>\n<td>&quot;No available IP addresses&quot; error</td>\n<td>IP pool exhausted or addresses not released</td>\n<td>Check IPAM allocation records and container states</td>\n<td>Implement address cleanup or expand subnet</td>\n</tr>\n<tr>\n<td>Network setup hangs during container creation</td>\n<td>Netlink operations blocked or namespace issues</td>\n<td><code>strace</code> the runtime process for system call failures</td>\n<td>Check for kernel version compatibility and permissions</td>\n</tr>\n</tbody></table>\n<p>The network management component represents the final major subsystem in the container runtime, providing the networking foundation that transforms isolated processes into communicating services. Proper implementation of veth pairs, bridge networking, and port forwarding creates a complete container networking solution that balances isolation with connectivity requirements.</p>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - This section describes how components coordinate during the complete container lifecycle, showing the orchestration of namespace creation (Milestone 1), resource control setup (Milestone 2), filesystem mounting (Milestone 3), and network configuration (Milestone 4).</p>\n</blockquote>\n<h3 id=\"mental-model-orchestra-conductor\">Mental Model: Orchestra Conductor</h3>\n<p>Think of the container runtime as a symphony orchestra performing a complex musical piece. The <strong>Runtime Manager</strong> serves as the conductor, coordinating multiple specialized sections (components) to create a harmonious performance. Each section has specific expertise - the <strong>Namespace Handler</strong> is like the string section providing the foundational melody (isolation), the <strong>Resource Control Component</strong> is like the percussion section maintaining rhythm and timing (resource limits), the <strong>Filesystem Manager</strong> is like the brass section adding layers of richness (overlay filesystem), and the <strong>Network Manager</strong> is like the woodwinds connecting different musical phrases (container communication).</p>\n<p>Just as a conductor must start each section at precisely the right moment and ensure they work together without interfering with each other, the Runtime Manager must orchestrate container creation by coordinating namespace setup, cgroup creation, filesystem mounting, and network configuration in the correct sequence. If the conductor stops the music abruptly, each section must wind down gracefully - similarly, when stopping a container, each component must clean up its resources in the proper order to avoid leaving the system in an inconsistent state.</p>\n<p>The magic happens in the coordination - each component performs its specialized function, but the real value emerges from how they work together to create an isolated, resource-controlled, networked container environment that appears seamless to the user.</p>\n<h3 id=\"container-creation-sequence\">Container Creation Sequence</h3>\n<p>The container creation sequence represents the most complex orchestration in our runtime, involving careful coordination between all components to establish a fully functional isolated environment. This process must handle partial failures gracefully, ensuring that if any step fails, previously created resources are properly cleaned up.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fcontainer-creation-sequence.svg\" alt=\"Container Creation Sequence\"></p>\n<h4 id=\"pre-creation-validation-phase\">Pre-Creation Validation Phase</h4>\n<p>Before beginning the actual container creation, the Runtime Manager performs comprehensive validation to catch configuration errors early, before any system resources are allocated. This validation phase prevents scenarios where container creation fails halfway through due to invalid specifications, leaving partially created resources that require cleanup.</p>\n<p>The validation process examines the <code>ContainerSpec</code> thoroughly, checking that the container ID follows the required format (alphanumeric characters, hyphens, and underscores only, 1-64 characters in length), the specified image layers exist in the local storage, resource limits are within acceptable ranges, and network configuration parameters are valid. Port mapping validation ensures that requested host ports are available and that container ports are within valid ranges (1-65535).</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Purpose</th>\n<th>Failure Consequence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container ID format</td>\n<td>Ensure filesystem-safe naming</td>\n<td>Prevents mount point creation issues</td>\n</tr>\n<tr>\n<td>Image layer existence</td>\n<td>Verify overlay dependencies</td>\n<td>Prevents overlayfs mount failures</td>\n</tr>\n<tr>\n<td>Resource limit bounds</td>\n<td>Validate cgroup parameters</td>\n<td>Prevents cgroup controller errors</td>\n</tr>\n<tr>\n<td>Port availability</td>\n<td>Check host port conflicts</td>\n<td>Prevents iptables rule conflicts</td>\n</tr>\n<tr>\n<td>Network subnet capacity</td>\n<td>Ensure IP addresses available</td>\n<td>Prevents IP allocation failures</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Front-loading validation prevents resource leakage. It&#39;s much cleaner to reject an invalid container specification before creating any namespaces or cgroups than to handle cleanup after partial creation failure.</p>\n</blockquote>\n<h4 id=\"component-initialization-sequence\">Component Initialization Sequence</h4>\n<p>Once validation passes, the Runtime Manager begins the coordinated initialization sequence. This sequence is carefully ordered to handle dependencies between components - for example, namespaces must exist before processes can be assigned to cgroups, and the network namespace must be created before veth pairs can be moved into it.</p>\n<p><strong>Step 1: Container State Initialization</strong></p>\n<p>The Runtime Manager creates a new <code>ContainerState</code> record with status <code>ContainerCreated</code> and persists it to the state store. This persistent record serves as the authoritative source of truth about the container&#39;s existence and current state, enabling recovery operations if the runtime process crashes during creation.</p>\n<p><strong>Step 2: Namespace Creation</strong></p>\n<p>The Namespace Handler receives the container&#39;s <code>NamespaceConfig</code> and creates the requested Linux namespaces. The namespace creation follows a specific order: user namespace first (if enabled) to establish privilege boundaries, followed by PID, mount, network, UTS, and IPC namespaces. Each namespace creation is verified before proceeding to the next.</p>\n<p>The namespace creation process involves creating a new process with the appropriate <code>CLONE_NEW*</code> flags, configuring the namespace environment (such as UID/GID mappings for user namespaces), and establishing the communication channel for coordinating with the container process. The <code>NamespaceHandle</code> returned contains the process ID of the namespace holder and references to all created namespaces.</p>\n<p><strong>Step 3: Filesystem Preparation</strong></p>\n<p>With namespaces established, the Filesystem Manager prepares the container&#39;s root filesystem using overlayfs. This involves creating the directory structure for the overlay mount (upper directory for container changes, work directory for overlayfs operations), combining the image layers into the lower directories specification, and mounting the overlayfs with the proper options.</p>\n<p>The overlay mount operation requires careful attention to mount options, ensuring that the work directory is on the same filesystem as the upper directory, that the lower directories are specified in the correct order (base layer first), and that the mount point has the appropriate permissions for the container&#39;s user namespace mappings.</p>\n<p><strong>Step 4: Cgroup Setup</strong></p>\n<p>The Resource Control Component creates the container&#39;s cgroup hierarchy and applies the specified resource limits. This involves creating a new cgroup under the runtime&#39;s cgroup subtree, enabling the required controllers (memory, CPU, I/O), configuring the resource limits according to the <code>ResourceLimits</code> specification, and preparing the cgroup for process assignment.</p>\n<p>The cgroup creation must handle cgroups v2 delegation properly, ensuring that the runtime has sufficient permissions to create and manage the container cgroup, that the required controllers are available in the parent cgroup, and that resource limits are set before any processes are assigned to the cgroup.</p>\n<p><strong>Step 5: Network Configuration</strong></p>\n<p>The Network Manager sets up the container&#39;s networking environment by creating a veth pair, moving one end into the container&#39;s network namespace, configuring IP addresses and routing, and establishing port forwarding rules if required. This step requires coordination with the previously created network namespace.</p>\n<p>The network setup process involves creating uniquely named veth interfaces, moving the container end of the veth pair into the container&#39;s network namespace, configuring the container interface with an allocated IP address, attaching the host end of the veth pair to the container bridge, and creating iptables rules for any requested port mappings.</p>\n<p><strong>Step 6: Essential Mount Setup</strong></p>\n<p>Within the container&#39;s mount namespace, essential filesystem mounts are established to provide the container with a functional environment. This includes mounting <code>/proc</code> with the appropriate options for the PID namespace, mounting <code>/sys</code> with restricted access, creating <code>/dev</code> with essential device nodes, and establishing <code>/tmp</code> as a tmpfs mount.</p>\n<p>These mounts are critical for container functionality - <code>/proc</code> provides process information and system interfaces, <code>/sys</code> exposes kernel information, and <code>/dev</code> provides access to essential devices like <code>/dev/null</code>, <code>/dev/zero</code>, and <code>/dev/random</code>.</p>\n<h4 id=\"state-transition-and-process-launch\">State Transition and Process Launch</h4>\n<p>After all components have successfully prepared their resources, the Runtime Manager transitions the container state from <code>ContainerCreated</code> to <code>ContainerRunning</code> and launches the container&#39;s main process. This final step involves executing the container command within the prepared namespace environment, assigning the process to the container&#39;s cgroup, and establishing monitoring for the container process.</p>\n<p>The process launch uses the Linux <code>execve</code> system call to replace the namespace holder process with the container&#39;s specified command, ensuring that the process inherits all the prepared namespace, filesystem, and network configuration. The process ID is recorded in the <code>ContainerState</code> for future management operations.</p>\n<h4 id=\"failure-recovery-during-creation\">Failure Recovery During Creation</h4>\n<p>The container creation sequence must handle failures at any step, implementing a rollback mechanism that cleans up successfully created resources. The cleanup sequence runs in reverse order of creation, ensuring that dependencies are properly unwound.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Point</th>\n<th>Resources to Clean Up</th>\n<th>Cleanup Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace creation</td>\n<td>Container state</td>\n<td>Delete state record</td>\n</tr>\n<tr>\n<td>Filesystem preparation</td>\n<td>Namespaces, state</td>\n<td>Cleanup namespaces, delete state</td>\n</tr>\n<tr>\n<td>Cgroup setup</td>\n<td>Filesystem, namespaces, state</td>\n<td>Unmount overlay, cleanup namespaces, delete state</td>\n</tr>\n<tr>\n<td>Network configuration</td>\n<td>Cgroups, filesystem, namespaces, state</td>\n<td>Remove cgroup, unmount overlay, cleanup namespaces, delete state</td>\n</tr>\n<tr>\n<td>Process launch</td>\n<td>Network, cgroups, filesystem, namespaces, state</td>\n<td>Full cleanup of all resources</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Design Decision</strong>: The creation sequence is designed to be atomic from the user&#39;s perspective - either a container is fully created and functional, or it doesn&#39;t exist at all. Partial containers are never left in the system.</p>\n</blockquote>\n<h3 id=\"container-cleanup-sequence\">Container Cleanup Sequence</h3>\n<p>The container cleanup sequence is equally critical to the creation sequence, ensuring that when containers are stopped and removed, all associated resources are properly released and the system is left in a clean state. This process must handle both graceful shutdowns and forced termination scenarios.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fcontainer-lifecycle-state.svg\" alt=\"Container Lifecycle State Machine\"></p>\n<h4 id=\"graceful-termination-process\">Graceful Termination Process</h4>\n<p>When a container stop request is received, the Runtime Manager begins a graceful termination process that allows the container application to shut down cleanly while systematically releasing system resources. This process respects the container&#39;s shutdown timeout while ensuring that system resources are not leaked.</p>\n<p><strong>Step 1: Process Termination Signal</strong></p>\n<p>The Runtime Manager sends a <code>SIGTERM</code> signal to the container&#39;s main process, allowing it to perform graceful shutdown operations such as closing database connections, saving state, and releasing application resources. The runtime waits for a configurable timeout period (typically 10 seconds) for the process to terminate voluntarily.</p>\n<p>If the process doesn&#39;t terminate within the grace period, the Runtime Manager escalates to <code>SIGKILL</code>, which forcibly terminates the process. This two-phase termination approach balances application needs (graceful shutdown) with system reliability (guaranteed termination).</p>\n<p><strong>Step 2: Cgroup Process Migration and Cleanup</strong></p>\n<p>Once the container process has terminated, the Resource Control Component verifies that no other processes remain in the container&#39;s cgroup hierarchy. Any remaining processes are either migrated to a cleanup cgroup or terminated, depending on the runtime configuration.</p>\n<p>The cgroup cleanup process then removes the container&#39;s cgroup hierarchy by first disabling all controllers, moving any remaining processes out of the cgroup, and finally removing the cgroup directory. This sequence is critical because cgroups with active processes or enabled controllers cannot be removed.</p>\n<p><strong>Step 3: Network Resource Cleanup</strong></p>\n<p>The Network Manager systematically removes all networking resources associated with the container. This involves removing iptables rules for port forwarding, releasing the allocated IP address back to the available pool, removing the veth pair (which automatically cleans up both host and container ends), and updating any bridge forwarding tables.</p>\n<p>Network cleanup must be thorough because leaked networking resources can cause conflicts with future containers, prevent IP address reuse, and leave iptables rules that interfere with other container networking.</p>\n<p><strong>Step 4: Filesystem Unmounting and Cleanup</strong></p>\n<p>The Filesystem Manager unmounts the container&#39;s overlayfs and removes the associated directories. This process involves unmounting the overlay from the container&#39;s root mount point, removing the upper directory (containing container changes), removing the work directory, and cleaning up any temporary mount points.</p>\n<p>Special care is taken during unmount operations to handle busy filesystems - if processes are still accessing the container filesystem, the unmount is retried with increasingly aggressive approaches, culminating in lazy unmount (<code>MNT_DETACH</code>) if necessary.</p>\n<p><strong>Step 5: Namespace Cleanup</strong></p>\n<p>The Namespace Handler performs the final cleanup step by removing the container&#39;s namespaces. Since namespaces are automatically cleaned up by the kernel when the last process exits, this step primarily involves verifying that cleanup has occurred and releasing any runtime-held references to namespace file descriptors.</p>\n<p>User namespace cleanup requires special attention to UID/GID mapping cleanup, ensuring that any temporary mapping files are removed and that the namespace&#39;s privilege boundaries are properly dissolved.</p>\n<h4 id=\"state-management-during-cleanup\">State Management During Cleanup</h4>\n<p>Throughout the cleanup sequence, the Runtime Manager updates the container&#39;s state record to reflect the cleanup progress. The container transitions from <code>ContainerRunning</code> to <code>ContainerStopped</code> once the process has terminated, and finally to <code>ContainerRemoved</code> once all resources have been cleaned up.</p>\n<p>The state record serves as a checkpoint for recovery operations - if the runtime crashes during cleanup, it can resume the cleanup process from the last recorded state, preventing resource leaks and ensuring system consistency.</p>\n<table>\n<thead>\n<tr>\n<th>Cleanup Phase</th>\n<th>Container State</th>\n<th>Critical Actions</th>\n<th>Failure Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process termination</td>\n<td><code>ContainerStopped</code></td>\n<td>Send SIGTERM/SIGKILL</td>\n<td>Force kill on restart</td>\n</tr>\n<tr>\n<td>Cgroup cleanup</td>\n<td><code>ContainerStopped</code></td>\n<td>Remove cgroup hierarchy</td>\n<td>Retry cgroup removal</td>\n</tr>\n<tr>\n<td>Network cleanup</td>\n<td><code>ContainerStopped</code></td>\n<td>Remove veth, iptables rules</td>\n<td>Clean up by container ID scan</td>\n</tr>\n<tr>\n<td>Filesystem cleanup</td>\n<td><code>ContainerStopped</code></td>\n<td>Unmount overlayfs</td>\n<td>Force unmount on restart</td>\n</tr>\n<tr>\n<td>Final cleanup</td>\n<td><code>ContainerRemoved</code></td>\n<td>Delete state record</td>\n<td>Mark as removed</td>\n</tr>\n</tbody></table>\n<h4 id=\"forced-removal-and-recovery\">Forced Removal and Recovery</h4>\n<p>In some scenarios, containers may need to be forcibly removed due to unresponsive processes, corrupted state, or system recovery after crashes. The forced removal process bypasses graceful shutdown and aggressively cleans up resources.</p>\n<p>Forced removal begins with <code>SIGKILL</code> to terminate all processes in the container&#39;s cgroup, proceeds with immediate resource cleanup without waiting for graceful termination, uses forced unmount operations for stuck filesystems, and removes networking resources even if some operations fail.</p>\n<p>The recovery process after runtime crashes involves scanning the system for orphaned resources by examining cgroup hierarchies for container-specific paths, checking for overlay mounts with container-specific names, identifying veth interfaces and iptables rules with container tags, and cleaning up any discovered orphaned resources.</p>\n<blockquote>\n<p><strong>Operational Insight</strong>: Container cleanup is where many runtime bugs manifest. Thorough cleanup prevents resource exhaustion and ensures system stability under high container churn rates.</p>\n</blockquote>\n<h4 id=\"cleanup-verification-and-monitoring\">Cleanup Verification and Monitoring</h4>\n<p>After each cleanup operation, the Runtime Manager performs verification steps to ensure resources have been properly released. This includes verifying that the container&#39;s cgroup no longer exists in the filesystem, confirming that no overlay mounts remain for the container, checking that the container&#39;s IP address has been released, and ensuring that no iptables rules reference the container.</p>\n<p>The verification process also updates system monitoring metrics, tracking successful cleanup operations, failed cleanup attempts requiring manual intervention, resource cleanup timing for performance optimization, and overall system resource utilization trends.</p>\n<h3 id=\"component-communication-patterns\">Component Communication Patterns</h3>\n<p>The interactions between components follow well-defined communication patterns that ensure consistency and enable proper error handling. These patterns establish clear boundaries and responsibilities while enabling the complex coordination required for container lifecycle management.</p>\n<h4 id=\"synchronous-command-response-pattern\">Synchronous Command-Response Pattern</h4>\n<p>The primary communication pattern used during container creation and removal is synchronous command-response, where the Runtime Manager issues commands to individual components and waits for completion before proceeding to the next step. This pattern ensures that each step completes successfully before dependent operations begin.</p>\n<p>Each component operation returns both a success/failure indication and detailed information about the operation results. Success responses include resource handles, configuration details, and any information needed by subsequent steps. Failure responses include specific error codes, diagnostic information, and suggestions for recovery actions.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Command Type</th>\n<th>Response Data</th>\n<th>Error Information</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Namespace Handler</td>\n<td><code>CreateNamespaces</code></td>\n<td><code>NamespaceHandle</code> with PIDs and paths</td>\n<td>Namespace creation failures with system error codes</td>\n</tr>\n<tr>\n<td>Resource Controller</td>\n<td><code>CreateContainerCgroup</code></td>\n<td>Cgroup path and applied limits</td>\n<td>Controller availability and permission errors</td>\n</tr>\n<tr>\n<td>Filesystem Manager</td>\n<td><code>PrepareContainerFilesystem</code></td>\n<td>Mount point and overlay paths</td>\n<td>Mount failures and layer availability issues</td>\n</tr>\n<tr>\n<td>Network Manager</td>\n<td><code>SetupContainerNetwork</code></td>\n<td><code>ContainerNetwork</code> with interface details</td>\n<td>IP allocation and bridge configuration errors</td>\n</tr>\n</tbody></table>\n<h4 id=\"event-notification-pattern\">Event Notification Pattern</h4>\n<p>For monitoring and status updates, components use an event notification pattern to inform the Runtime Manager about state changes, resource usage alerts, and error conditions that occur outside of explicit command operations.</p>\n<p>The event notification system operates asynchronously, allowing components to report important events without blocking their normal operations. Events include container process exit notifications, resource usage threshold breaches, network connectivity changes, and filesystem errors.</p>\n<h4 id=\"resource-handle-management\">Resource Handle Management</h4>\n<p>Components return resource handles that encapsulate the resources they&#39;ve created and provide controlled access for cleanup operations. These handles abstract the complexity of resource management while ensuring that resources can be properly released even if the component that created them is not available.</p>\n<p>Resource handles include sufficient information for cleanup operations, maintain references to prevent premature resource release, provide verification methods for health checking, and enable diagnostic operations for troubleshooting.</p>\n<h3 id=\"error-propagation-and-recovery\">Error Propagation and Recovery</h3>\n<p>The container runtime implements comprehensive error propagation and recovery mechanisms that ensure system stability even when individual operations fail. These mechanisms distinguish between recoverable errors (that can be retried) and permanent failures (that require different handling strategies).</p>\n<h4 id=\"error-classification-and-handling\">Error Classification and Handling</h4>\n<p>Errors are classified into categories that determine the appropriate response strategy:</p>\n<p><strong>Transient Errors</strong> are temporary conditions that may resolve with retry, such as resource temporarily unavailable, network connectivity issues, and filesystem busy conditions. These errors trigger automatic retry with exponential backoff.</p>\n<p><strong>Configuration Errors</strong> indicate problems with the container specification or runtime configuration, such as invalid resource limits, missing image layers, and network configuration conflicts. These errors are reported immediately to the user without retry.</p>\n<p><strong>System Errors</strong> indicate serious problems with the underlying system, such as insufficient disk space, kernel feature unavailability, and permission denied errors. These errors may require administrative intervention.</p>\n<p><strong>Resource Exhaustion</strong> occurs when system limits are reached, such as no available IP addresses, maximum containers reached, and insufficient memory for operations. These errors trigger cleanup of unused resources before retry.</p>\n<blockquote>\n<p><strong>Design Philosophy</strong>: Fail fast for configuration errors, retry intelligently for transient errors, and gracefully degrade for resource exhaustion scenarios.</p>\n</blockquote>\n<h4 id=\"recovery-state-machine\">Recovery State Machine</h4>\n<p>The runtime maintains a recovery state machine that tracks the progress of failed operations and determines the appropriate recovery actions:</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Ferror-recovery-flow.svg\" alt=\"Error Recovery and Cleanup Flow\"></p>\n<p>The recovery process uses checkpointing to track which operations have completed successfully, enabling precise rollback without affecting unrelated system state. Recovery actions are idempotent, ensuring that repeated execution produces the same result without side effects.</p>\n<h3 id=\"performance-considerations-and-optimization\">Performance Considerations and Optimization</h3>\n<p>The container lifecycle operations are optimized for both individual container performance and system-wide scalability. These optimizations balance resource utilization, operation latency, and system throughput under various load patterns.</p>\n<h4 id=\"parallel-component-operations\">Parallel Component Operations</h4>\n<p>Where dependencies permit, component operations are executed in parallel to reduce container creation latency. For example, cgroup creation and network setup can proceed simultaneously after namespace creation, and filesystem layer verification can occur in parallel with network bridge preparation.</p>\n<p>The parallel execution framework uses worker pools for each component type, coordinates dependencies through a directed acyclic graph, implements backpressure to prevent resource exhaustion, and maintains operation ordering where required for correctness.</p>\n<h4 id=\"resource-pooling-and-caching\">Resource Pooling and Caching</h4>\n<p>Frequently used resources are pooled and cached to reduce allocation overhead:</p>\n<p><strong>Network Resource Pool</strong>: Pre-allocated IP addresses and veth interface names reduce network setup latency and prevent naming conflicts.</p>\n<p><strong>Filesystem Layer Cache</strong>: Image layers are cached with reference counting, enabling quick overlay setup for containers using the same base images.</p>\n<p><strong>Cgroup Template Cache</strong>: Common cgroup configurations are templated and cached, reducing the overhead of setting individual resource limits.</p>\n<h4 id=\"batch-operations\">Batch Operations</h4>\n<p>When multiple containers are created simultaneously, the runtime batches certain operations to improve efficiency:</p>\n<ul>\n<li>iptables rules are batched and applied together to reduce netfilter reconfiguration overhead</li>\n<li>Filesystem operations are batched to take advantage of kernel I/O scheduling</li>\n<li>Cgroup operations are grouped to minimize cgroup hierarchy traversal</li>\n</ul>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The container lifecycle orchestration requires careful coordination of asynchronous operations while maintaining strong consistency guarantees. The following implementation approach provides a foundation for building reliable container lifecycle management.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Management</td>\n<td>JSON files + file locking</td>\n<td>Embedded database (bbolt/badger)</td>\n</tr>\n<tr>\n<td>Process Management</td>\n<td>os/exec + signal handling</td>\n<td>Dedicated process manager with reaping</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Structured errors + retry logic</td>\n<td>Circuit breaker pattern with backoff</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard log package</td>\n<td>Structured logging (logrus/zap)</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Basic metrics collection</td>\n<td>Prometheus metrics + health checks</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/runtime/\n  manager.go                    ← Runtime Manager implementation\n  manager_test.go              ← Lifecycle integration tests\n  lifecycle.go                 ← Container lifecycle state machine\n  cleanup.go                   ← Resource cleanup coordination\n  validation.go                ← Container specification validation\n  errors.go                    ← Error types and handling\n  state/\n    manager.go                 ← Container state persistence\n    recovery.go                ← Crash recovery logic\n  coordinator/\n    coordinator.go             ← Component operation coordination\n    parallel.go                ← Parallel operation execution\n    rollback.go               ← Failure rollback logic</code></pre></div>\n\n<h4 id=\"core-state-management-infrastructure\">Core State Management Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// StateManager provides persistent storage for container state with crash recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StateManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateDir   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recovery tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operations </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OperationLog</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recovery   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecoveryManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OperationLog tracks the progress of multi-step operations for recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OperationLog</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"container_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OperationType  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"operation_type\"`</span><span style=\"color:#6A737D\"> // \"create\", \"start\", \"stop\", \"remove\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"start_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletedSteps []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">               `json:\"completed_steps\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentStep    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"current_step\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RollbackNeeded </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">                   `json:\"rollback_needed\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorDetails   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"error_details,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SaveContainerState persists container state with atomic write operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SaveContainerState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">state</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container state structure and required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create temporary file for atomic write operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Serialize state to JSON with proper formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Write to temporary file and fsync for durability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Atomically rename temporary file to final location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update in-memory cache with new state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use os.Rename() for atomic file replacement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadContainerState retrieves persisted state with error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LoadContainerState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container ID format and length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Construct state file path from container ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read state file with appropriate error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse JSON and validate required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update in-memory cache with loaded state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for recovery operations in progress</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle file not found vs. corruption differently</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"runtime-manager-core-logic\">Runtime Manager Core Logic</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// RuntimeManager orchestrates all container lifecycle operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RuntimeManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateManager    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nsHandler       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">namespace</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupController </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cgroup</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Controller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fsManager       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">filesystem</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkManager  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">network</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config          </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RuntimeConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventChan       </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RuntimeEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdownCtx     </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdownCancel  </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainer implements the complete container creation sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RuntimeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate container specification thoroughly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check for container ID conflicts in state store</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Initialize container state record with Created status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log operation start for crash recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create namespaces according to namespace configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Prepare filesystem with overlay mount and layer setup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Create and configure cgroup with resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Setup container networking with IP allocation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Update container state to Running status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Launch container process in prepared environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 11: Clean up resources if any step fails (rollback)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use defer functions for cleanup on error paths</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StopContainer implements graceful container termination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RuntimeManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StopContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container state and verify it's running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send SIGTERM to container process for graceful shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Wait for process termination within timeout period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send SIGKILL if process doesn't terminate gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update container state to Stopped status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Begin cleanup sequence for all component resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify all resources have been properly released</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update monitoring metrics for container lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use context with timeout for process termination wait</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"component-coordination-framework\">Component Coordination Framework</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ComponentCoordinator manages parallel and sequential operations across components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ComponentCoordinator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dependency graph for operation ordering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dependencies </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Operation tracking for rollback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    completedOps </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Component interface that all runtime components must implement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Component</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Setup prepares component resources for a container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Setup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cleanup releases component resources for a container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify checks that component resources are properly configured</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Verify</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetDependencies returns components that must complete before this one</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetDependencies</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteParallelOperations coordinates component operations with dependency handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ComponentCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteParallelOperations</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">spec</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ContainerSpec</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Build dependency graph from component requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Identify operations that can execute in parallel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create worker goroutines for independent operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Use channels to coordinate dependency completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Collect results and handle any operation failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Implement rollback for failed parallel operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update operation log with completion status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use sync.WaitGroup for parallel operation coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"error-handling-and-recovery\">Error Handling and Recovery</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// RecoveryManager handles crash recovery and partial operation cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RecoveryManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateManager   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operationLogs  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">OperationLog</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Recovery policies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxRetryAttempts </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    retryBackoff     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cleanupTimeout   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoverFromCrash identifies and completes interrupted operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecoveryManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecoverFromCrash</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Scan operation log directory for incomplete operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Load operation logs and determine recovery actions needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Identify containers requiring rollback vs. completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute cleanup operations for failed container creations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Restart monitoring for containers in running state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update container states to reflect actual system state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Clean up orphaned system resources (cgroups, mounts, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use system inspection to verify actual resource state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RollbackOperation cleans up resources from a failed container operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecoveryManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RollbackOperation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">opLog</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">OperationLog</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Determine which components completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute cleanup in reverse order of creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Handle cleanup failures with appropriate retry logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update container state to reflect rollback completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Remove operation log once rollback completes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log rollback results for debugging and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Components should implement idempotent cleanup operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the container lifecycle coordination:</p>\n<ol>\n<li><strong>Creation Verification</strong>: Run <code>go test ./internal/runtime/...</code> to verify creation sequence logic</li>\n<li><strong>Manual Testing</strong>: Create a container with <code>runtime create test-container config.json</code> and verify all namespaces, cgroups, and networking are properly configured</li>\n<li><strong>Cleanup Verification</strong>: Stop and remove the container, then inspect system state to ensure no leaked resources</li>\n<li><strong>Recovery Testing</strong>: Simulate runtime crash during container creation and verify recovery on restart</li>\n<li><strong>Expected Behavior</strong>: Containers should transition smoothly through Created → Running → Stopped → Removed states with proper resource management at each stage</li>\n</ol>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container creation hangs</td>\n<td>Component deadlock or dependency cycle</td>\n<td>Check component dependency graph and operation logs</td>\n<td>Implement operation timeouts and break dependency cycles</td>\n</tr>\n<tr>\n<td>Partial container cleanup</td>\n<td>Component cleanup failure</td>\n<td>Examine container state and system resources</td>\n<td>Implement idempotent cleanup and retry logic</td>\n</tr>\n<tr>\n<td>Resource leaks after crashes</td>\n<td>Missing recovery operations</td>\n<td>Scan system for orphaned cgroups, mounts, network interfaces</td>\n<td>Add comprehensive recovery scanning and cleanup</td>\n</tr>\n<tr>\n<td>State corruption</td>\n<td>Concurrent state modifications</td>\n<td>Check for missing locks and atomic operations</td>\n<td>Use file locking and atomic state updates</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - Error handling spans namespace creation (milestone 1), cgroup setup (milestone 2), filesystem mounting (milestone 3), and network configuration (milestone 4), requiring comprehensive failure recovery across all components.</p>\n</blockquote>\n<p>Building a container runtime involves orchestrating multiple complex Linux kernel mechanisms, each with its own failure modes and edge cases. Think of error handling in a container runtime like managing a construction project with specialized contractors - when the electrician fails after the plumber has finished, you need a systematic plan to undo completed work while preserving what can be salvaged. Unlike simple applications where failures often mean &quot;try again later,&quot; container runtime failures leave behind kernel resources (namespaces, cgroups, mount points, network interfaces) that must be meticulously cleaned up to avoid resource leaks and system instability.</p>\n<p>The fundamental challenge in container runtime error handling is <strong>partial failure recovery</strong>. Container creation involves a precise sequence of operations across multiple kernel subsystems: creating namespaces, establishing cgroup hierarchies, mounting overlay filesystems, and configuring network interfaces. When operation 7 fails but operations 1-6 succeeded, the runtime must intelligently roll back the successful operations in the correct order while avoiding double-cleanup and resource conflicts.</p>\n<p><img src=\"/api/project/container-runtime/architecture-doc/asset?path=diagrams%2Fcontainer-lifecycle-state.svg\" alt=\"Container Lifecycle State Machine\"></p>\n<p>Resource exhaustion scenarios present another class of critical edge cases. Unlike traditional applications that can gracefully degrade or queue requests, container runtimes must handle hard resource limits imposed by the kernel. When the system runs out of available PIDs, network interfaces, or memory, the runtime must detect these conditions early and provide meaningful feedback rather than cryptic kernel error messages.</p>\n<h3 id=\"partial-failure-recovery\">Partial Failure Recovery</h3>\n<p>Partial failure recovery in container runtimes requires maintaining detailed operation logs and implementing idempotent cleanup procedures. Think of this like a database transaction - either all operations complete successfully, or the system returns to its original state with no side effects. However, unlike database transactions, kernel resource operations cannot be wrapped in a single atomic unit, requiring careful orchestration of cleanup procedures.</p>\n<blockquote>\n<p><strong>Decision: Operation Log with Rollback Mechanism</strong></p>\n<ul>\n<li><strong>Context</strong>: Container creation involves 10-15 distinct operations across multiple kernel subsystems, any of which can fail independently</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Best-effort cleanup without tracking</li>\n<li>Two-phase commit protocol for all operations</li>\n<li>Operation log with explicit rollback procedures</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Operation log with explicit rollback procedures</li>\n<li><strong>Rationale</strong>: Two-phase commit is too heavy for kernel operations that cannot participate in distributed transactions. Best-effort cleanup leads to resource leaks. Operation logs provide precise tracking with efficient rollback.</li>\n<li><strong>Consequences</strong>: Requires persistent storage for operation logs and careful ordering of cleanup procedures, but ensures no resource leaks and consistent system state.</li>\n</ul>\n</blockquote>\n<p>The <code>OperationLog</code> structure tracks the progress of multi-step container operations and provides the foundation for intelligent rollback:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ContainerID</td>\n<td>string</td>\n<td>Unique identifier linking log to container being created</td>\n</tr>\n<tr>\n<td>OperationType</td>\n<td>string</td>\n<td>Type of operation (CREATE, START, STOP, REMOVE)</td>\n</tr>\n<tr>\n<td>StartTime</td>\n<td>time.Time</td>\n<td>When the operation began for timeout detection</td>\n</tr>\n<tr>\n<td>CompletedSteps</td>\n<td>[]string</td>\n<td>List of successfully completed operation steps</td>\n</tr>\n<tr>\n<td>CurrentStep</td>\n<td>string</td>\n<td>Step currently being executed or that failed</td>\n</tr>\n<tr>\n<td>RollbackNeeded</td>\n<td>bool</td>\n<td>Whether rollback procedures should be executed</td>\n</tr>\n<tr>\n<td>ErrorDetails</td>\n<td>map[string]interface{}</td>\n<td>Structured error information for diagnosis</td>\n</tr>\n</tbody></table>\n<p>The rollback mechanism operates through <strong>step-specific cleanup procedures</strong> that can be safely executed multiple times (idempotent) and handle cases where the original operation partially succeeded. Each component provides cleanup methods that inspect the current system state and remove only resources that actually exist:</p>\n<ol>\n<li><strong>Check Operation Log</strong>: The recovery manager scans persistent operation logs to identify incomplete operations from previous runtime executions</li>\n<li><strong>Determine Rollback Scope</strong>: For each incomplete operation, examine the <code>CompletedSteps</code> list to identify which resources were successfully created</li>\n<li><strong>Execute Reverse Cleanup</strong>: Call component-specific cleanup methods in reverse dependency order (network → filesystem → cgroup → namespaces)</li>\n<li><strong>Verify Resource Removal</strong>: After each cleanup step, verify that kernel resources were actually removed and update the operation log</li>\n<li><strong>Handle Cleanup Failures</strong>: If cleanup fails, mark specific resources as requiring manual intervention and continue with remaining cleanup</li>\n<li><strong>Log Completion</strong>: Mark the operation log as fully rolled back or note any resources requiring administrator attention</li>\n</ol>\n<p>Here&#39;s the detailed rollback sequence for each component:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Cleanup Actions</th>\n<th>Verification Steps</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network Manager</td>\n<td>Remove iptables rules, delete veth interfaces, release IP addresses</td>\n<td>Check interface list, verify iptables rules removed</td>\n<td>Log unreleased IPs for manual cleanup</td>\n</tr>\n<tr>\n<td>Filesystem Manager</td>\n<td>Unmount overlayfs, remove overlay directories, update layer references</td>\n<td>Check mount table, verify directories removed</td>\n<td>Force unmount with lazy flags if needed</td>\n</tr>\n<tr>\n<td>Cgroup Controller</td>\n<td>Remove processes from cgroups, delete cgroup directories</td>\n<td>Check cgroup.procs file empty, verify directory removal</td>\n<td>Kill remaining processes if needed</td>\n</tr>\n<tr>\n<td>Namespace Handler</td>\n<td>Close namespace file descriptors, clean up pivot_root artifacts</td>\n<td>Check /proc/PID/ns/ entries, verify mount points</td>\n<td>Mark namespaces for kernel cleanup on process exit</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Cleanup Order Dependencies</strong></p>\n<p>A common mistake is cleaning up components in creation order rather than reverse dependency order. For example, attempting to remove a cgroup before stopping the network manager can fail because iptables rules might still reference the container&#39;s cgroup. The correct cleanup sequence respects dependency relationships: network configuration depends on namespaces existing, cgroups depend on processes being manageable, and filesystem mounts must be unmounted before namespace cleanup.</p>\n<p>The <code>RecoveryManager</code> implements crash recovery by scanning operation logs on startup and completing interrupted operations:</p>\n<table>\n<thead>\n<tr>\n<th>Recovery Scenario</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n<th>Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Runtime crashed during container creation</td>\n<td>Operation log shows incomplete CREATE with recent timestamp</td>\n<td>Execute rollback for all completed steps</td>\n<td>Container fully removed, resources cleaned</td>\n</tr>\n<tr>\n<td>Container process died unexpectedly</td>\n<td>PID in container state no longer exists</td>\n<td>Mark container as stopped, clean up kernel resources</td>\n<td>Container marked STOPPED, resources cleaned</td>\n</tr>\n<tr>\n<td>Manual container kill bypassed runtime</td>\n<td>Container state shows RUNNING but process not found</td>\n<td>Update state to STOPPED, leave resources for explicit cleanup</td>\n<td>Consistent state, manual removal required</td>\n</tr>\n<tr>\n<td>Kernel resource leaked from previous session</td>\n<td>System resources exist but not in runtime state</td>\n<td>Log leaked resources, optionally clean up obvious orphans</td>\n<td>Clean system state, administrator notified</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The key insight for partial failure recovery is that kernel resources have different cleanup requirements than application resources. A failed malloc() simply returns memory to the heap, but a failed namespace creation might leave mount points, cgroup entries, and network interfaces that must be explicitly cleaned up through separate system calls.</p>\n</blockquote>\n<h3 id=\"resource-exhaustion-scenarios\">Resource Exhaustion Scenarios</h3>\n<p>Resource exhaustion scenarios in container runtimes require proactive detection and graceful degradation rather than reactive error handling. Think of resource exhaustion like a city&#39;s infrastructure during peak demand - water pressure drops before pipes burst, and smart systems detect the decline and take preventive action rather than waiting for catastrophic failure.</p>\n<p>The container runtime must monitor multiple types of resource exhaustion:</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Exhaustion Symptoms</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Process IDs</td>\n<td>fork() returns EAGAIN, new containers fail to start</td>\n<td>Check /proc/sys/kernel/pid_max and active PID count</td>\n<td>Queue container requests, increase PID limit if possible</td>\n</tr>\n<tr>\n<td>Memory</td>\n<td>OOM killer activates, container creation fails</td>\n<td>Monitor memory.current vs memory.max in cgroups</td>\n<td>Reject new containers, suggest memory limit increases</td>\n</tr>\n<tr>\n<td>Network Interfaces</td>\n<td>veth creation fails, bridge attachment fails</td>\n<td>Count interfaces in /sys/class/net/</td>\n<td>Clean up unused interfaces, implement interface pooling</td>\n</tr>\n<tr>\n<td>File Descriptors</td>\n<td>open() returns EMFILE/ENFILE</td>\n<td>Check /proc/PID/limits and /proc/sys/fs/file-nr</td>\n<td>Close unused FDs, increase process limits</td>\n</tr>\n<tr>\n<td>Disk Space</td>\n<td>Filesystem operations fail with ENOSPC</td>\n<td>Monitor filesystem usage for container storage</td>\n<td>Clean up stopped containers, rotate logs</td>\n</tr>\n<tr>\n<td>Cgroup Hierarchy Depth</td>\n<td>cgroup creation fails with nested limits</td>\n<td>Check cgroup depth in /sys/fs/cgroup hierarchy</td>\n<td>Flatten cgroup structure, remove unused cgroups</td>\n</tr>\n</tbody></table>\n<p><strong>PID Exhaustion Detection and Mitigation</strong>:</p>\n<p>PID exhaustion is particularly problematic for container runtimes because each container typically creates multiple processes (init process, potential child processes, namespace management processes). The runtime implements PID exhaustion protection through monitoring and admission control:</p>\n<ol>\n<li><strong>Current PID Usage Monitoring</strong>: Periodically scan /proc to count active PIDs and calculate utilization against the system limit (/proc/sys/kernel/pid_max)</li>\n<li><strong>Per-Container PID Tracking</strong>: Maintain accurate counts of PIDs allocated to each container through cgroup process accounting</li>\n<li><strong>Admission Control</strong>: Reject new container creation requests when PID utilization exceeds a configured threshold (e.g., 85%)</li>\n<li><strong>PID Cleanup Detection</strong>: Identify containers with higher PID usage than expected and investigate potential PID leaks</li>\n<li><strong>Emergency PID Recovery</strong>: When PID exhaustion is imminent, forcefully terminate containers marked as non-critical to free PIDs for essential operations</li>\n</ol>\n<p><strong>Memory Pressure Handling</strong>:</p>\n<p>Memory exhaustion affects both the container runtime itself and the containers it manages. The runtime implements multi-level memory pressure detection:</p>\n<table>\n<thead>\n<tr>\n<th>Pressure Level</th>\n<th>Detection Threshold</th>\n<th>Runtime Action</th>\n<th>Container Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal</td>\n<td>Memory usage &lt; 70% of system</td>\n<td>Normal operation</td>\n<td>No restrictions</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>Memory usage 70-85% of system</td>\n<td>Log warnings, reduce caching</td>\n<td>Monitor container memory trends</td>\n</tr>\n<tr>\n<td>Critical</td>\n<td>Memory usage 85-95% of system</td>\n<td>Reject new containers</td>\n<td>Apply stricter memory limits to new containers</td>\n</tr>\n<tr>\n<td>Emergency</td>\n<td>Memory usage &gt; 95% or swap thrashing</td>\n<td>Stop non-essential containers</td>\n<td>Trigger graceful shutdown of containers marked non-critical</td>\n</tr>\n</tbody></table>\n<p>The runtime tracks memory pressure through multiple indicators:</p>\n<ol>\n<li><strong>System Memory Utilization</strong>: Monitor /proc/meminfo for available memory vs total memory</li>\n<li><strong>Container Memory Pressure</strong>: Check memory.pressure files in container cgroups to detect containers approaching their limits</li>\n<li><strong>Swap Activity</strong>: Monitor swap usage trends to detect memory thrashing before system becomes unresponsive</li>\n<li><strong>OOM Event Detection</strong>: Scan kernel logs and cgroup memory.events for OOM kill events affecting containers</li>\n<li><strong>Memory Allocation Failure Rate</strong>: Track the rate of memory allocation failures in container creation operations</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Resource Exhaustion Cascades</strong></p>\n<p>A subtle failure mode occurs when resource exhaustion in one area triggers exhaustion in another. For example, when the runtime cannot create new network interfaces due to kernel limits, it might retry the operation multiple times, consuming PIDs for helper processes and eventually hitting PID limits as well. The runtime must implement circuit breaker patterns that prevent retry loops from amplifying resource exhaustion across multiple subsystems.</p>\n<p><strong>Network Resource Exhaustion</strong>:</p>\n<p>Network interface exhaustion is less common but can occur in environments running many containers with complex networking requirements. The runtime implements network resource management through:</p>\n<table>\n<thead>\n<tr>\n<th>Network Resource</th>\n<th>Limit Type</th>\n<th>Detection Method</th>\n<th>Mitigation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>veth Interfaces</td>\n<td>Kernel compile-time limit</td>\n<td>Count interfaces in /sys/class/net/</td>\n<td>Implement interface reuse pool</td>\n</tr>\n<tr>\n<td>IP Addresses</td>\n<td>Configured subnet size</td>\n<td>Track allocated IPs in IPAM</td>\n<td>Expand subnet or implement IP recycling</td>\n</tr>\n<tr>\n<td>iptables Rules</td>\n<td>Memory and rule count limits</td>\n<td>Monitor iptables rule count</td>\n<td>Consolidate rules, implement rule cleanup</td>\n</tr>\n<tr>\n<td>Bridge Interfaces</td>\n<td>Administrative limit</td>\n<td>Count bridge interfaces</td>\n<td>Reuse bridges across containers</td>\n</tr>\n<tr>\n<td>netns File Descriptors</td>\n<td>Process file descriptor limit</td>\n<td>Track open namespace file descriptors</td>\n<td>Close unused namespace references</td>\n</tr>\n</tbody></table>\n<p>The <code>ResourceMonitor</code> component implements comprehensive resource exhaustion detection:</p>\n<table>\n<thead>\n<tr>\n<th>Monitoring Function</th>\n<th>Check Interval</th>\n<th>Alert Threshold</th>\n<th>Action Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System PID usage</td>\n<td>30 seconds</td>\n<td>70% utilization</td>\n<td>85% utilization</td>\n</tr>\n<tr>\n<td>Memory pressure</td>\n<td>15 seconds</td>\n<td>Moderate pressure</td>\n<td>High pressure</td>\n</tr>\n<tr>\n<td>Filesystem space</td>\n<td>60 seconds</td>\n<td>80% full</td>\n<td>90% full</td>\n</tr>\n<tr>\n<td>Network interface count</td>\n<td>120 seconds</td>\n<td>80% of observed maximum</td>\n<td>95% of observed maximum</td>\n</tr>\n<tr>\n<td>Cgroup hierarchy depth</td>\n<td>300 seconds</td>\n<td>Depth &gt; 10 levels</td>\n<td>Depth &gt; 15 levels</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Exhaustion Recovery Procedures</strong>:</p>\n<p>When resource exhaustion is detected, the runtime follows escalating recovery procedures:</p>\n<ol>\n<li><strong>Level 1 - Preventive Measures</strong>: Increase monitoring frequency, log detailed resource usage, reject non-critical operations</li>\n<li><strong>Level 2 - Resource Reclamation</strong>: Clean up stopped containers, release unused resources, compact resource allocations</li>\n<li><strong>Level 3 - Load Shedding</strong>: Reject new container creation requests, terminate containers marked as non-essential</li>\n<li><strong>Level 4 - Emergency Cleanup</strong>: Force cleanup of resources that appear leaked, restart runtime components to reset resource tracking</li>\n<li><strong>Level 5 - System Protection</strong>: Invoke emergency shutdown procedures to prevent system-wide resource exhaustion</li>\n</ol>\n<blockquote>\n<p>The critical principle in resource exhaustion handling is failing fast and failing clearly. When the runtime detects that it cannot reliably create new containers due to resource constraints, it should immediately return a clear error message rather than attempting the operation and leaving behind partially created resources that worsen the exhaustion.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling and recovery system requires careful coordination of persistent state management and idempotent cleanup procedures. This implementation focuses on building robust error handling that prevents resource leaks and provides clear diagnostic information.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Operation Logging</td>\n<td>JSON files with file locking</td>\n<td>SQLite database with transactions</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Periodic polling with goroutines</td>\n<td>Event-driven monitoring with inotify</td>\n</tr>\n<tr>\n<td>Process Coordination</td>\n<td>Channel-based synchronization</td>\n<td>Context-based cancellation with sync.WaitGroup</td>\n</tr>\n<tr>\n<td>Error Classification</td>\n<td>Custom error types with wrapping</td>\n<td>Structured errors with error codes and metadata</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n  runtime/\n    manager.go              ← RuntimeManager with error handling\n    recovery.go             ← RecoveryManager implementation\n    operation_log.go        ← OperationLog persistence\n  monitoring/\n    resource_monitor.go     ← ResourceMonitor implementation\n    alerts.go              ← Resource exhaustion alerting\n  errors/\n    types.go               ← Error type definitions\n    recovery.go            ← Error recovery utilities\n  components/\n    namespace/\n      cleanup.go           ← Namespace cleanup procedures\n    cgroup/\n      cleanup.go           ← Cgroup cleanup procedures\n    filesystem/\n      cleanup.go           ← Filesystem cleanup procedures\n    network/\n      cleanup.go           ← Network cleanup procedures</code></pre></div>\n\n<h4 id=\"core-error-handling-infrastructure\">Core Error Handling Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// OperationLog tracks multi-step operations for failure recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OperationLog</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"container_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OperationType  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"operation_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"start_time\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletedSteps []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">               `json:\"completed_steps\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentStep    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"current_step\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RollbackNeeded </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">                   `json:\"rollback_needed\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorDetails   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"error_details\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoveryManager handles crash recovery and resource cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RecoveryManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logDir      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    components  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Component</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PersistOperationStep records successful completion of an operation step</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecoveryManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PersistOperationStep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">step</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load existing operation log from disk using container ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add step to CompletedSteps list if not already present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update CurrentStep to reflect progress</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Write updated log back to disk with atomic file operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Ensure file permissions allow cleanup by other processes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use a temporary file + rename for atomic updates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExecuteRollback cleans up resources from a failed operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RecoveryManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ExecuteRollback</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">opLog</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">OperationLog</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Reverse the order of completed steps for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each step, identify the responsible component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Call component-specific cleanup method with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update operation log to track cleanup progress</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle partial cleanup failures gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Mark operation log as fully cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Continue cleanup even if individual steps fail</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"resource-monitoring-implementation\">Resource Monitoring Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ResourceMonitor tracks system resource usage and exhaustion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceMonitor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alertThresholds </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    checkInterval   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alertHandlers   []</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ResourceAlert</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu              </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartMonitoring begins periodic resource usage checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartMonitoring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(rm.checkInterval)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Check PID usage by scanning /proc filesystem</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Check memory pressure from /proc/meminfo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Check filesystem usage for container storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Count network interfaces in /sys/class/net/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Compare usage against configured thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 6: Generate alerts for resources approaching limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Hint: Use /proc/sys/kernel/pid_max for PID limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckPIDExhaustion determines if system is approaching PID limit</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckPIDExhaustion</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read PID limit from /proc/sys/kernel/pid_max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Count active PIDs by scanning /proc directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate utilization percentage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return usage ratio for threshold comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle race conditions where PIDs change during scan</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"component-cleanup-interfaces\">Component Cleanup Interfaces</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Component defines cleanup interface for runtime components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Component</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CleanupResources removes all resources associated with container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CleanupResources</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // VerifyCleanup checks that all resources were actually removed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    VerifyCleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ListResources returns resources currently allocated to container</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ListResources</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Implement cleanup for each component following this pattern:</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupNamespaces removes namespace resources for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">nh </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupResources</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load namespace handle from persistent state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Close all namespace file descriptors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Unmount any remaining filesystem mounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove namespace-specific directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify namespace cleanup completed successfully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use lazy unmount (MNT_DETACH) for stuck mounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupCgroups removes cgroup hierarchy for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupController</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupResources</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Find cgroup path from container ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Kill any remaining processes in cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove container cgroup directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update cgroup reference counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Clean up empty parent cgroups if needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check cgroup.procs is empty before removing directory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing operation logging:</strong></p>\n<ul>\n<li>Run <code>go test ./internal/runtime/recovery_test.go</code> to verify log persistence</li>\n<li>Create a container and verify operation log is written to disk</li>\n<li>Kill the runtime process during container creation and verify rollback on restart</li>\n</ul>\n<p><strong>After implementing resource monitoring:</strong></p>\n<ul>\n<li>Run <code>go test ./internal/monitoring/resource_test.go</code> to verify threshold detection</li>\n<li>Create containers until PID usage approaches threshold</li>\n<li>Verify monitoring detects resource pressure and generates appropriate alerts</li>\n</ul>\n<p><strong>After implementing component cleanup:</strong></p>\n<ul>\n<li>Run integration test that creates container and injects failure at each step</li>\n<li>Verify all kernel resources are cleaned up after each failure scenario</li>\n<li>Check that no mount points, cgroup directories, or network interfaces leak</li>\n</ul>\n<h4 id=\"debugging-common-error-handling-issues\">Debugging Common Error Handling Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Resource busy&quot; during cleanup</td>\n<td>Another process still using resource</td>\n<td><code>lsof</code> for files, <code>lsns</code> for namespaces</td>\n<td>Kill processes holding resource</td>\n</tr>\n<tr>\n<td>Operation log corruption</td>\n<td>Concurrent writes or crash during write</td>\n<td>Check file timestamps and JSON validity</td>\n<td>Implement file locking or atomic writes</td>\n</tr>\n<tr>\n<td>Cleanup hangs indefinitely</td>\n<td>Deadlock in kernel resource cleanup</td>\n<td><code>strace</code> the cleanup process</td>\n<td>Use timeouts and force cleanup options</td>\n</tr>\n<tr>\n<td>Resource leak after container removal</td>\n<td>Component cleanup not called or failed</td>\n<td>Check system resources before/after</td>\n<td>Verify cleanup methods are idempotent</td>\n</tr>\n<tr>\n<td>False resource exhaustion alerts</td>\n<td>Monitoring logic counting incorrectly</td>\n<td>Compare manual resource counts</td>\n<td>Fix counting logic and add bounds checking</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - This section provides comprehensive testing approaches for namespace isolation (milestone 1), resource control (milestone 2), filesystem layering (milestone 3), and container networking (milestone 4), along with end-to-end integration scenarios.</p>\n</blockquote>\n<h3 id=\"mental-model-multi-layer-quality-gates\">Mental Model: Multi-Layer Quality Gates</h3>\n<p>Think of testing a container runtime like quality control in a multi-story manufacturing plant. Each floor represents a milestone - the first floor handles basic isolation (like separate workspaces), the second floor adds resource management (like power and material limits), the third floor implements storage systems (like shared warehouses with private modifications), and the fourth floor connects communication networks (like phone systems between departments). Quality inspectors work at three levels: <strong>unit inspectors</strong> check each machine in isolation, <strong>floor supervisors</strong> verify that all machines on a floor work together properly, and <strong>plant managers</strong> run full production scenarios to ensure the entire facility operates as designed. Just as a defect on the first floor can cascade upward and ruin the final product, a namespace isolation bug can break resource limits, filesystem mounting, and networking. Our testing strategy mirrors this layered approach - we verify each component works correctly in isolation, then test milestone-by-milestone integration, and finally run realistic end-to-end scenarios that exercise the complete container lifecycle.</p>\n<p>The key insight is that container runtime testing requires <strong>progressive validation</strong> - you cannot meaningfully test resource limits if namespace isolation is broken, and networking tests are pointless if the filesystem layer cannot mount properly. Each milestone builds upon the previous one, creating a testing dependency chain that must be validated in sequence. This approach helps developers understand not just whether their implementation works, but where failures originate and how they propagate through the system.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone represents a significant capability increment in our container runtime. The testing approach for each milestone focuses on verifying the specific isolation mechanisms and their integration with previously implemented components. These checkpoints provide concrete validation criteria and specific test scenarios that demonstrate proper functionality.</p>\n<h4 id=\"milestone-1-process-isolation-with-namespaces\">Milestone 1: Process Isolation with Namespaces</h4>\n<p>The first milestone establishes the foundation of container isolation using Linux namespaces. Testing focuses on verifying that each namespace type correctly isolates the container&#39;s view of system resources from the host and other containers.</p>\n<p><strong>PID Namespace Validation</strong> tests ensure that the container process sees itself as PID 1 and cannot see host processes. The test creates a container, executes a process inside it, and verifies that <code>/proc/1/</code> inside the container refers to the container&#39;s initial process rather than the host&#39;s init system. Additionally, the test should confirm that <code>ps aux</code> inside the container shows only container processes, while <code>ps aux</code> on the host shows both host and container processes with different PID mappings.</p>\n<p><strong>Mount Namespace Validation</strong> verifies filesystem isolation by creating different mount points inside the container that should not appear on the host filesystem. The test mounts a temporary filesystem at <code>/tmp/container-test</code> inside the container, writes a file to that location, then confirms that the mount point and file are not visible from the host namespace. This test also validates that changes to existing mount points inside the container (such as remounting <code>/proc</code> with different options) do not affect the host&#39;s view of those filesystems.</p>\n<p><strong>Network Namespace Validation</strong> confirms network stack isolation by checking that the container has its own network interfaces, routing tables, and firewall rules. The test should verify that <code>ip link list</code> inside the container shows different interfaces than on the host, that the container cannot see network connections established on the host using <code>netstat</code>, and that network configuration changes inside the container do not affect host networking.</p>\n<p><strong>UTS Namespace Validation</strong> tests hostname and domain name isolation by setting different values inside the container and verifying they do not affect the host system. The test sets the container hostname to <code>test-container</code>, confirms that <code>hostname</code> inside the container returns this value, while <code>hostname</code> on the host returns the original host name.</p>\n<p><strong>User Namespace Validation</strong> (when implemented) verifies UID and GID mapping by creating a container process that appears to run as root (UID 0) inside the container but actually runs as an unprivileged user on the host. The test should confirm that <code>id</code> inside the container shows UID 0, while the same process appears with a mapped UID when viewed from the host.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Validation Method</th>\n<th>Expected Behavior</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PID isolation</td>\n<td>Check <code>/proc/1/comm</code> inside container</td>\n<td>Container process name, not host init</td>\n<td>Shows host init process or &quot;No such file&quot;</td>\n</tr>\n<tr>\n<td>Process visibility</td>\n<td>Run <code>ps aux</code> inside container</td>\n<td>Only container processes visible</td>\n<td>Host processes appear in container</td>\n</tr>\n<tr>\n<td>Mount isolation</td>\n<td>Create mount inside container, check host</td>\n<td>Mount not visible on host filesystem</td>\n<td>Host shows container mounts</td>\n</tr>\n<tr>\n<td>Network interface isolation</td>\n<td>Compare <code>ip link</code> output</td>\n<td>Different interfaces in container vs host</td>\n<td>Same interfaces visible in both</td>\n</tr>\n<tr>\n<td>Hostname isolation</td>\n<td>Set hostname in container, check host</td>\n<td>Host hostname unchanged</td>\n<td>Container hostname affects host</td>\n</tr>\n<tr>\n<td>File ownership mapping</td>\n<td>Create file as root in user namespace</td>\n<td>File owned by mapped UID on host</td>\n<td>File shows UID 0 on host filesystem</td>\n</tr>\n</tbody></table>\n<p>The milestone 1 checkpoint should demonstrate that a simple container can be created and started, with the container process executing in isolated namespaces. The test creates a container that runs <code>sleep 60</code>, then uses various inspection commands to verify isolation properties while the container is running.</p>\n<h4 id=\"milestone-2-resource-limits-with-cgroups\">Milestone 2: Resource Limits with Cgroups</h4>\n<p>The second milestone adds resource control capabilities on top of namespace isolation. Testing focuses on verifying that cgroups v2 controllers correctly enforce CPU, memory, and I/O limits, and that resource monitoring provides accurate usage statistics.</p>\n<p><strong>Memory Limit Enforcement</strong> tests create containers with specific memory limits and verify that processes exceeding those limits are terminated by the OOM killer. The test starts a container with a 50MB memory limit, runs a process that attempts to allocate 100MB of memory, and confirms that the process is killed before it can consume host memory beyond the limit. Additionally, the test should verify that <code>GetMemoryUsage</code> returns accurate current consumption and that memory pressure indicators increase as the limit is approached.</p>\n<p><strong>CPU Limit Enforcement</strong> validates that CPU quota and period settings correctly throttle container processes. The test creates a container with a 50% CPU limit (cpu.max set to &quot;50000 100000&quot;), runs a CPU-intensive process, and measures actual CPU consumption over a period to confirm it does not exceed the configured limit. The test should also verify that multiple containers with CPU limits can coexist without interfering with each other&#39;s quotas.</p>\n<p><strong>Process Limit Enforcement</strong> tests the PIDs controller by creating a container with a maximum of 10 processes, then attempting to fork more processes and verifying that process creation fails once the limit is reached. This test ensures that containers cannot exhaust the host&#39;s PID space through excessive process creation.</p>\n<p><strong>Resource Usage Monitoring</strong> validates the accuracy of resource consumption reporting. The test creates containers with known workloads (specific memory allocation patterns, CPU-intensive loops, file I/O operations) and compares the reported usage statistics from <code>GetResourceUsage</code> against expected values. This test also verifies that usage statistics are updated within reasonable time intervals.</p>\n<p><strong>OOM Event Detection</strong> tests the container runtime&#39;s ability to detect and report out-of-memory kills. The test creates a container with a low memory limit, runs a process that gradually increases memory consumption until it triggers an OOM kill, then verifies that <code>CheckOOMEvents</code> correctly reports the kill event with appropriate metadata.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Resource Limit</th>\n<th>Test Workload</th>\n<th>Expected Outcome</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory enforcement</td>\n<td>50MB</td>\n<td>Allocate 100MB array</td>\n<td>Process killed by OOM</td>\n<td>Check exit code and OOM counter</td>\n</tr>\n<tr>\n<td>CPU throttling</td>\n<td>0.5 CPU cores</td>\n<td>Infinite loop</td>\n<td>~50% CPU usage</td>\n<td>Measure CPU time over 10 seconds</td>\n</tr>\n<tr>\n<td>PID limit</td>\n<td>10 processes</td>\n<td>Fork bomb</td>\n<td>Fork fails after 10</td>\n<td>Count processes in cgroup</td>\n</tr>\n<tr>\n<td>Memory monitoring</td>\n<td>100MB</td>\n<td>Allocate 75MB</td>\n<td>75MB usage reported</td>\n<td>Compare GetMemoryUsage() result</td>\n</tr>\n<tr>\n<td>OOM detection</td>\n<td>25MB</td>\n<td>Gradual allocation</td>\n<td>OOM event detected</td>\n<td>CheckOOMEvents() returns true</td>\n</tr>\n</tbody></table>\n<p>The milestone 2 checkpoint demonstrates that containers respect resource limits and that the runtime can accurately monitor and report resource consumption. The test creates multiple containers with different resource limits, runs various workloads simultaneously, and verifies that each container&#39;s resource usage stays within its configured bounds while resource monitoring provides accurate statistics.</p>\n<h4 id=\"milestone-3-overlay-filesystem\">Milestone 3: Overlay Filesystem</h4>\n<p>The third milestone implements layered filesystem support using overlayfs, enabling efficient copy-on-write semantics for container images. Testing focuses on verifying proper layer stacking, copy-on-write behavior, and cleanup operations.</p>\n<p><strong>Layer Stacking Validation</strong> tests that multiple read-only layers combine correctly with a writable upper layer to create the expected merged filesystem view. The test creates a container with three layers: a base layer containing <code>/bin/sh</code>, a second layer adding <code>/etc/hostname</code>, and a third layer adding <code>/usr/local/bin/custom-tool</code>. The container should see all files from all layers in their correct locations, with files from higher layers overriding those from lower layers when paths conflict.</p>\n<p><strong>Copy-on-Write Behavior</strong> validates that file modifications inside the container create copies in the upper layer without affecting the original read-only layers. The test modifies an existing file from a lower layer (such as <code>/etc/hosts</code>), then verifies that the original file remains unchanged in the lower layer while the modified version appears in the upper layer. The test also creates new files and confirms they appear only in the upper layer.</p>\n<p><strong>Whiteout File Handling</strong> tests overlayfs support for file deletion across layers. The test deletes a file that exists in a lower layer and verifies that a whiteout file is created in the upper layer, causing the file to disappear from the merged view while preserving the original file in the lower layer.</p>\n<p><strong>Layer Cleanup Verification</strong> ensures that overlay mounts and directories are properly removed when containers are destroyed. The test creates a container, allows it to make filesystem changes, then removes the container and verifies that all overlay-related mount points are unmounted and temporary directories are cleaned up. This test also checks that shared lower layers are not removed when they are still referenced by other containers.</p>\n<p><strong>Overlay Mount Integrity</strong> validates that the overlayfs mount is correctly configured and accessible. The test verifies that the merged directory shows the expected combined view of all layers, that the work directory is properly configured for overlayfs internal operations, and that mount options are correctly applied.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Setup</th>\n<th>Container Action</th>\n<th>Verification</th>\n<th>Expected Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Layer combination</td>\n<td>3 layers with overlapping files</td>\n<td>Read files from all layers</td>\n<td>Check file contents</td>\n<td>Higher layer files visible</td>\n</tr>\n<tr>\n<td>Copy-on-write</td>\n<td>Base layer with <code>/etc/passwd</code></td>\n<td>Modify <code>/etc/passwd</code></td>\n<td>Check original layer</td>\n<td>Original file unchanged</td>\n</tr>\n<tr>\n<td>File creation</td>\n<td>Empty upper layer</td>\n<td>Create <code>/tmp/newfile</code></td>\n<td>Check layer location</td>\n<td>File only in upper layer</td>\n</tr>\n<tr>\n<td>File deletion</td>\n<td>File in lower layer</td>\n<td>Delete file</td>\n<td>Check whiteout creation</td>\n<td>File hidden, whiteout present</td>\n</tr>\n<tr>\n<td>Mount cleanup</td>\n<td>Running container</td>\n<td>Remove container</td>\n<td>Check mount points</td>\n<td>All overlay mounts removed</td>\n</tr>\n</tbody></table>\n<p>The milestone 3 checkpoint demonstrates that containers can be created with layered filesystems, that copy-on-write semantics work correctly, and that filesystem resources are properly cleaned up. The test creates a container from multiple layers, performs various filesystem operations (read, write, delete), and verifies both the visible behavior and the underlying layer management.</p>\n<h4 id=\"milestone-4-container-networking\">Milestone 4: Container Networking</h4>\n<p>The fourth milestone implements container networking using veth pairs and bridge networking. Testing focuses on verifying network isolation, container-to-container communication, and port forwarding functionality.</p>\n<p><strong>Veth Pair Creation</strong> tests that virtual ethernet pairs are correctly created and configured. The test creates a container and verifies that a veth pair connects the container&#39;s network namespace to the host, with one end visible in the container (<code>eth0</code>) and the other end visible on the host (with a generated name like <code>vethXXXXXX</code>). The test should confirm that both ends of the pair are properly configured with appropriate MAC addresses and are in the UP state.</p>\n<p><strong>Bridge Network Integration</strong> validates that container veth interfaces are correctly attached to the container bridge and can communicate with other containers. The test creates two containers on the same bridge network, assigns IP addresses from the configured subnet, and verifies that the containers can ping each other using their IP addresses. This test also confirms that containers cannot communicate with external networks unless explicitly configured.</p>\n<p><strong>IP Address Management</strong> tests that containers receive unique IP addresses from the configured subnet pool and that address conflicts are prevented. The test creates multiple containers and verifies that each receives a different IP address, that addresses are properly allocated and released when containers start and stop, and that reused addresses are not assigned to active containers.</p>\n<p><strong>Port Forwarding Configuration</strong> validates that NAT rules correctly forward traffic from host ports to container ports. The test creates a container running a simple HTTP server on port 8080, configures port forwarding from host port 9000 to container port 8080, then verifies that HTTP requests to <code>localhost:9000</code> on the host are successfully forwarded to the container service.</p>\n<p><strong>Network Isolation Verification</strong> tests that containers in different network namespaces cannot directly access each other&#39;s network resources unless explicitly connected. The test creates containers in separate network namespaces and confirms that they cannot see each other&#39;s network interfaces or established connections.</p>\n<p><strong>DNS Resolution</strong> validates that containers can resolve DNS names using configured nameservers. The test creates a container with DNS servers configured, attempts to resolve a known hostname from inside the container, and verifies that DNS queries are properly forwarded and resolved.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Network Setup</th>\n<th>Test Action</th>\n<th>Expected Outcome</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Veth pair creation</td>\n<td>Single container</td>\n<td>Check interfaces</td>\n<td>Veth pair exists and configured</td>\n<td><code>ip link</code> in both namespaces</td>\n</tr>\n<tr>\n<td>Bridge communication</td>\n<td>Two containers on bridge</td>\n<td>Ping between containers</td>\n<td>Successful ping</td>\n<td><code>ping</code> command returns 0</td>\n</tr>\n<tr>\n<td>IP allocation</td>\n<td>Multiple containers</td>\n<td>Start/stop containers</td>\n<td>Unique IPs assigned</td>\n<td>Check IP uniqueness</td>\n</tr>\n<tr>\n<td>Port forwarding</td>\n<td>Container with HTTP server</td>\n<td>HTTP request to host port</td>\n<td>Request reaches container</td>\n<td>HTTP response received</td>\n</tr>\n<tr>\n<td>Network isolation</td>\n<td>Containers in separate namespaces</td>\n<td>Attempt inter-container access</td>\n<td>Access blocked</td>\n<td>Connection timeout/refused</td>\n</tr>\n<tr>\n<td>DNS resolution</td>\n<td>Container with nameservers</td>\n<td>Resolve external hostname</td>\n<td>DNS query succeeds</td>\n<td><code>nslookup</code> returns IP</td>\n</tr>\n</tbody></table>\n<p>The milestone 4 checkpoint demonstrates complete container networking functionality by creating multiple containers that can communicate with each other and with external services through port forwarding. The test creates a multi-container application (such as a web server and database) connected through bridge networking, with the web server accessible from the host via port forwarding.</p>\n<h3 id=\"integration-test-scenarios\">Integration Test Scenarios</h3>\n<p>Integration testing validates that all milestone components work together correctly in realistic container use cases. These scenarios exercise the complete container lifecycle and test complex interactions between namespace isolation, resource control, filesystem layering, and networking components.</p>\n<h4 id=\"scenario-1-multi-container-web-application\">Scenario 1: Multi-Container Web Application</h4>\n<p>This scenario tests a realistic web application deployment with multiple containers that must coordinate through networking while maintaining proper isolation and resource limits.</p>\n<p><strong>Application Architecture</strong>: The test deploys a three-tier web application consisting of a web server container (nginx serving static content), an application server container (running a simple HTTP API), and a database container (running a lightweight database like SQLite with HTTP interface). Each container has different resource requirements and network connectivity needs.</p>\n<p><strong>Container Configuration</strong>: The web server container receives 100MB memory limit and 0.5 CPU cores, with port 80 forwarded to host port 8080. The application server gets 200MB memory and 1.0 CPU core, with port 3000 accessible only from other containers on the bridge network. The database container receives 300MB memory and 0.3 CPU cores, with port 5432 accessible only from the application server.</p>\n<p><strong>Test Execution Flow</strong>: The test creates all three containers with their respective configurations, starts them in dependency order (database first, then application server, then web server), and verifies that the complete application stack functions correctly. External HTTP requests to the host&#39;s port 8080 should flow through the web server to the application server, which queries the database and returns results.</p>\n<p><strong>Validation Points</strong>: The test validates that each container operates within its resource limits throughout the test duration, that network communication works correctly between containers while external access is properly restricted, that filesystem changes in each container remain isolated, and that all containers can be stopped and cleaned up without leaving orphaned resources.</p>\n<p><strong>Failure Scenario Testing</strong>: The test intentionally introduces failures such as killing the database container and verifying that the application server handles the connection failure gracefully, exceeding memory limits in one container and confirming that other containers continue operating normally, and network partitioning between containers to test error handling.</p>\n<table>\n<thead>\n<tr>\n<th>Test Phase</th>\n<th>Actions</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container startup</td>\n<td>Start containers in dependency order</td>\n<td>All containers reach running state</td>\n<td>Check container status</td>\n</tr>\n<tr>\n<td>Application connectivity</td>\n<td>HTTP request to web server</td>\n<td>Request processed through full stack</td>\n<td>HTTP response with database data</td>\n</tr>\n<tr>\n<td>Resource isolation</td>\n<td>Load test individual containers</td>\n<td>Each container stays within limits</td>\n<td>Monitor cgroup statistics</td>\n</tr>\n<tr>\n<td>Network isolation</td>\n<td>Direct database access from host</td>\n<td>Connection refused</td>\n<td>Network connection timeout</td>\n</tr>\n<tr>\n<td>Failure recovery</td>\n<td>Kill database container</td>\n<td>Application server reports database error</td>\n<td>Check application server logs</td>\n</tr>\n<tr>\n<td>Cleanup verification</td>\n<td>Remove all containers</td>\n<td>All resources cleaned up</td>\n<td>Check for orphaned mounts/processes</td>\n</tr>\n</tbody></table>\n<h4 id=\"scenario-2-batch-processing-with-resource-contention\">Scenario 2: Batch Processing with Resource Contention</h4>\n<p>This scenario tests container runtime behavior under resource pressure, with multiple containers competing for CPU and memory resources while processing data through shared filesystem layers.</p>\n<p><strong>Workload Design</strong>: The test creates five containers that perform different types of batch processing: CPU-intensive mathematical calculations, memory-intensive data sorting, I/O-intensive file processing, network-intensive data transfer, and mixed-workload data analysis. Each container has different resource limits that intentionally create contention scenarios.</p>\n<p><strong>Resource Configuration</strong>: Container limits are set to create controlled resource pressure: total CPU limits exceed available cores by 150%, total memory limits approach system memory capacity, and I/O intensive containers share the same underlying storage. This configuration tests the runtime&#39;s ability to enforce limits and maintain isolation under resource pressure.</p>\n<p><strong>Data Flow Testing</strong>: Containers process data through a pipeline where the output of one container becomes input for another, implemented through shared filesystem layers and network communication. This tests the integration of filesystem layering with networking while maintaining resource isolation.</p>\n<p><strong>Monitoring and Validation</strong>: Throughout the test execution, resource usage monitoring validates that containers stay within their configured limits even under pressure, that resource contention in one container does not cause others to exceed their limits, and that the container runtime maintains stable operation during peak resource utilization.</p>\n<table>\n<thead>\n<tr>\n<th>Container</th>\n<th>Workload Type</th>\n<th>CPU Limit</th>\n<th>Memory Limit</th>\n<th>Test Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>calc-1</td>\n<td>Mathematical computation</td>\n<td>1.5 cores</td>\n<td>100MB</td>\n<td>CPU usage ≤ 1.5 cores</td>\n</tr>\n<tr>\n<td>sort-1</td>\n<td>Large dataset sorting</td>\n<td>0.5 cores</td>\n<td>800MB</td>\n<td>Memory usage ≤ 800MB</td>\n</tr>\n<tr>\n<td>io-1</td>\n<td>File processing</td>\n<td>0.3 cores</td>\n<td>50MB</td>\n<td>I/O operations complete</td>\n</tr>\n<tr>\n<td>net-1</td>\n<td>Data transfer</td>\n<td>0.2 cores</td>\n<td>100MB</td>\n<td>Network throughput stable</td>\n</tr>\n<tr>\n<td>mixed-1</td>\n<td>Combined workload</td>\n<td>1.0 cores</td>\n<td>300MB</td>\n<td>All limits respected</td>\n</tr>\n</tbody></table>\n<h4 id=\"scenario-3-container-lifecycle-stress-testing\">Scenario 3: Container Lifecycle Stress Testing</h4>\n<p>This scenario exercises the complete container lifecycle under high frequency operations, testing the runtime&#39;s stability and resource cleanup capabilities.</p>\n<p><strong>High-Frequency Operations</strong>: The test rapidly creates, starts, stops, and removes containers in various patterns: sequential operations (create-start-stop-remove cycles), parallel operations (multiple containers created simultaneously), and mixed operations (some containers running long-term while others cycle rapidly).</p>\n<p><strong>Resource Exhaustion Testing</strong>: The test pushes the runtime toward various resource limits: creating containers until approaching the maximum number of namespaces, allocating IP addresses until the subnet pool is nearly exhausted, creating filesystem layers until storage space becomes constrained, and generating network traffic until bandwidth limits are reached.</p>\n<p><strong>Error Recovery Validation</strong>: The test intentionally introduces various failure conditions during container lifecycle operations: killing container processes during startup, interrupting filesystem mount operations, simulating network interface failures, and forcing unclean container shutdowns to test cleanup and recovery mechanisms.</p>\n<p><strong>Concurrency and Race Condition Testing</strong>: Multiple test threads perform container operations simultaneously to expose potential race conditions in resource allocation, namespace creation, cgroup management, and network configuration.</p>\n<table>\n<thead>\n<tr>\n<th>Test Pattern</th>\n<th>Operation Count</th>\n<th>Concurrency Level</th>\n<th>Success Criteria</th>\n<th>Failure Detection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rapid cycling</td>\n<td>100 containers</td>\n<td>10 parallel threads</td>\n<td>All operations succeed</td>\n<td>Check for resource leaks</td>\n</tr>\n<tr>\n<td>Long-running mixed</td>\n<td>50 containers</td>\n<td>5 threads, mixed lifecycle</td>\n<td>System remains stable</td>\n<td>Monitor system resources</td>\n</tr>\n<tr>\n<td>Resource exhaustion</td>\n<td>Until limits reached</td>\n<td>Single thread</td>\n<td>Graceful limit handling</td>\n<td>Operations fail cleanly</td>\n</tr>\n<tr>\n<td>Failure injection</td>\n<td>20 containers</td>\n<td>Random failures</td>\n<td>Proper error recovery</td>\n<td>No orphaned resources</td>\n</tr>\n<tr>\n<td>Race condition testing</td>\n<td>30 containers</td>\n<td>20 parallel threads</td>\n<td>Consistent resource state</td>\n<td>Check for conflicts</td>\n</tr>\n</tbody></table>\n<h4 id=\"scenario-4-security-isolation-validation\">Scenario 4: Security Isolation Validation</h4>\n<p>This scenario tests the security boundaries created by namespace isolation, ensuring that containers cannot escape their isolation or interfere with host system security.</p>\n<p><strong>Privilege Escalation Prevention</strong>: The test attempts various privilege escalation techniques from within containers, including attempting to access host filesystem paths outside the container&#39;s view, trying to modify host network configuration through namespace boundaries, attempting to access host processes or system resources, and testing user namespace mapping to ensure proper privilege isolation.</p>\n<p><strong>Resource Access Boundaries</strong>: Containers attempt to access resources beyond their configured limits, including trying to consume more memory than allocated, attempting to access network interfaces outside their namespace, trying to modify filesystem layers that should be read-only, and attempting to access other containers&#39; resources directly.</p>\n<p><strong>Information Disclosure Prevention</strong>: The test verifies that containers cannot access information they should not see, including host system process information, other containers&#39; filesystem contents, network traffic from other containers, and host system configuration details.</p>\n<p><strong>Container-to-Container Isolation</strong>: Multiple containers attempt to interfere with each other through various vectors, including filesystem access attempts, network communication outside configured channels, resource exhaustion attacks against other containers, and process interference attempts.</p>\n<table>\n<thead>\n<tr>\n<th>Security Test Category</th>\n<th>Attack Vector</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Filesystem isolation</td>\n<td>Access <code>/host/etc/passwd</code></td>\n<td>Access denied or file not found</td>\n<td>Check file access results</td>\n</tr>\n<tr>\n<td>Process isolation</td>\n<td>Kill host process from container</td>\n<td>Operation fails</td>\n<td>Check process list</td>\n</tr>\n<tr>\n<td>Network isolation</td>\n<td>Access other container ports</td>\n<td>Connection refused</td>\n<td>Network connection test</td>\n</tr>\n<tr>\n<td>Resource isolation</td>\n<td>Exhaust shared resources</td>\n<td>Other containers unaffected</td>\n<td>Monitor other container performance</td>\n</tr>\n<tr>\n<td>User namespace isolation</td>\n<td>Access files as different UID</td>\n<td>Permission denied</td>\n<td>Check file access permissions</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-container-runtime-testing\">Common Pitfalls in Container Runtime Testing</h3>\n<p>Testing container runtimes presents unique challenges because failures often involve complex interactions between kernel features, filesystem operations, and network configuration. Understanding common pitfalls helps developers create more robust test scenarios and debug issues more effectively.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Container Startup</strong>\nContainer startup involves multiple asynchronous operations (namespace creation, filesystem mounting, network configuration) that can complete in different orders. Tests that immediately check container state after calling <code>StartContainer</code> may fail intermittently because the container hasn&#39;t fully initialized. The test should poll container status with a reasonable timeout, or better yet, wait for a specific readiness signal from the container process (such as a service listening on a port or a status file being created).</p>\n<p>⚠️ <strong>Pitfall: Incomplete Resource Cleanup Detection</strong>\nTests that create and destroy containers rapidly may not detect resource leaks because the effects accumulate slowly. Running a single create-destroy cycle and checking for cleanup appears to work, but running hundreds of cycles reveals leaked mount points, network interfaces, or cgroup directories. Effective testing requires baseline resource measurements before the test, multiple iterations to amplify leak effects, and comprehensive resource scanning after test completion.</p>\n<p>⚠️ <strong>Pitfall: Host System Dependencies</strong>\nContainer runtime tests often assume specific host system configurations (kernel version, available namespaces, cgroups v2 enabled, bridge networking support) that may not be available in all test environments. Tests should verify prerequisites before execution and either skip gracefully or provide clear error messages when requirements are not met. Additionally, tests should not assume specific network interface names, IP address ranges, or filesystem paths that may vary between systems.</p>\n<p>⚠️ <strong>Pitfall: Timing-Dependent Resource Limit Validation</strong>\nResource usage measurements (CPU, memory, I/O) require time to stabilize and may fluctuate based on system load and kernel scheduling decisions. Tests that immediately check resource usage after starting a workload may see inconsistent results. Effective resource limit testing requires sustained workloads running for sufficient time periods, multiple measurements averaged together, and appropriate tolerance ranges that account for measurement variance while still detecting limit violations.</p>\n<p>⚠️ <strong>Pitfall: Network Configuration Interference</strong>\nContainer networking tests can interfere with each other and with host networking configuration, especially when creating bridges, assigning IP addresses, or configuring iptables rules. Tests running in parallel may create conflicting network configurations or exhaust IP address pools. Robust network testing requires isolated network namespaces for test execution, unique IP address ranges for each test, and thorough cleanup of iptables rules and network interfaces.</p>\n<p>⚠️ <strong>Pitfall: Filesystem Layer Corruption</strong>\nOverlayfs operations can leave the filesystem in inconsistent states if interrupted during critical operations like mounting or unmounting. Tests that kill container processes or force unclean shutdowns may corrupt overlay layers, affecting subsequent tests. Proper testing requires careful cleanup of overlay mounts even after failures, validation that overlay directories are in expected states, and potentially rebuilding overlay layers if corruption is detected.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The container runtime testing implementation requires a systematic approach that validates each milestone&#39;s functionality in isolation and then tests integrated scenarios that exercise multiple components simultaneously.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Go testing package with table-driven tests</td>\n<td>Ginkgo BDD framework with custom matchers</td>\n</tr>\n<tr>\n<td>Test Isolation</td>\n<td>Temporary directories with UUID names</td>\n<td>Linux user namespaces for complete test isolation</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Parse /proc and /sys files directly</td>\n<td>Prometheus client library with custom metrics</td>\n</tr>\n<tr>\n<td>Network Testing</td>\n<td>Simple ping and HTTP requests</td>\n<td>Packet capture analysis with gopacket library</td>\n</tr>\n<tr>\n<td>Filesystem Validation</td>\n<td>Directory listing and file content checks</td>\n<td>inotify-based filesystem change monitoring</td>\n</tr>\n<tr>\n<td>Container Orchestration</td>\n<td>Sequential test execution</td>\n<td>Parallel test execution with resource pools</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">project</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">root</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  cmd</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">container</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">runtime</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    main.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                           ← CLI entry point</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  internal</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">runtime</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                   ← Core runtime components</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    manager.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    container.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  internal</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">namespace</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                 ← Namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    namespace.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    namespace_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                 ← Unit tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  internal</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">cgroup</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                   ← Resource control</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroup.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroup_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                    ← Unit tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  internal</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">filesystem</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">               ← Overlay filesystem</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overlay.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overlay_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                   ← Unit tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  internal</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">network</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                  ← Container networking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    network.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    network_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                   ← Unit tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  test</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                             ← Integration tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    integration</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                     ← Cross</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">component tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      milestone1_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">             ← Namespace isolation tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      milestone2_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">             ← Resource control tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      milestone3_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">             ← Filesystem layering tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      milestone4_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">             ← Container networking tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    e2e</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                            ← End</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">to</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">end scenarios</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      webapp_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                 ← Multi</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">container web app</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      batch_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                  ← Batch processing scenario</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      lifecycle_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">              ← Lifecycle stress testing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      security_test.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">               ← Security isolation validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fixtures</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                       ← Test data and images</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      test</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">image</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                   ← Simple container image layers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      workloads</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                    ← Test programs and scripts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    helpers</span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\">                        ← Testing utilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      test_utils.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                 ← Common testing functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      resource_monitor.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">           ← Resource validation helpers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      network_helpers.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">            ← Network testing utilities</span></span></code></pre></div>\n\n<h4 id=\"test-infrastructure-starter-code\">Test Infrastructure Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/helpers/test_utils.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> helpers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/google/uuid</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestEnvironment provides isolated testing environment for container runtime tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestEnvironment</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TempDir     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cleanup     []</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTestEnvironment creates isolated test environment with unique IDs and cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTestEnvironment</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestEnvironment</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tempDir </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/tmp\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"container-test-\"</span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\">uuid.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">MkdirAll</span><span style=\"color:#E1E4E8\">(tempDir, </span><span style=\"color:#79B8FF\">0755</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Fatalf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to create temp directory: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TestEnvironment</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TempDir:     tempDir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ContainerID: </span><span style=\"color:#9ECBFF\">\"test-\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> uuid.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()[:</span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Cleanup:     </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register cleanup for test completion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env.</span><span style=\"color:#B392F0\">CleanupAll</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> env</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AddCleanup registers cleanup function to be called when test completes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">te </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestEnvironment</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AddCleanup</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cleanup</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    te.Cleanup </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(te.Cleanup, cleanup)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupAll executes all registered cleanup functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">te </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestEnvironment</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupAll</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(te.Cleanup) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">--</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> te.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">i</span><span style=\"color:#E1E4E8\">](); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Printf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Cleanup error: </span><span style=\"color:#79B8FF\">%v\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    os.</span><span style=\"color:#B392F0\">RemoveAll</span><span style=\"color:#E1E4E8\">(te.TempDir)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WaitForCondition polls condition function until it returns true or timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WaitForCondition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">condition</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">interval</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deadline </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(timeout)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(deadline) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#B392F0\"> condition</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        time.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(interval)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/helpers/resource_monitor.go  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> helpers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bufio</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceSnapshot captures resource usage at a point in time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceSnapshot</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MemoryUsage </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CPUUsage    </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // nanoseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PIDCount    </span><span style=\"color:#F97583\">int64</span><span style=\"color:#6A737D\">  // number of processes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceMonitor tracks container resource usage over time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ResourceMonitor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupPath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    snapshots  []</span><span style=\"color:#B392F0\">ResourceSnapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewResourceMonitor creates monitor for specified cgroup path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewResourceMonitor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cgroupPath: cgroupPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        snapshots:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">ResourceSnapshot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TakeSnapshot captures current resource usage values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TakeSnapshot</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    snapshot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ResourceSnapshot</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read memory usage from cgroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memoryFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rm.cgroupPath, </span><span style=\"color:#9ECBFF\">\"memory.current\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(memoryFile); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> usage, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(data)), </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            snapshot.MemoryUsage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read CPU usage from cgroup  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cpuFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rm.cgroupPath, </span><span style=\"color:#9ECBFF\">\"cpu.stat\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> file, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(cpuFile); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        defer</span><span style=\"color:#E1E4E8\"> file.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scanner </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> bufio.</span><span style=\"color:#B392F0\">NewScanner</span><span style=\"color:#E1E4E8\">(file)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> scanner.</span><span style=\"color:#B392F0\">Text</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">HasPrefix</span><span style=\"color:#E1E4E8\">(line, </span><span style=\"color:#9ECBFF\">\"usage_usec \"</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> usec, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(strings.</span><span style=\"color:#B392F0\">Fields</span><span style=\"color:#E1E4E8\">(line)[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    snapshot.CPUUsage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> usec </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#6A737D\"> // convert to nanoseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Read process count from cgroup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pidsFile </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(rm.cgroupPath, </span><span style=\"color:#9ECBFF\">\"pids.current\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(pidsFile); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> count, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strconv.</span><span style=\"color:#B392F0\">ParseInt</span><span style=\"color:#E1E4E8\">(strings.</span><span style=\"color:#B392F0\">TrimSpace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(data)), </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">64</span><span style=\"color:#E1E4E8\">); err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            snapshot.PIDCount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rm.snapshots </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(rm.snapshots, snapshot)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetAverageUsage returns average resource usage over monitoring period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ResourceMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetAverageUsage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">duration</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ResourceSnapshot</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cutoff </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">duration)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> memorySum, cpuSum, pidSum </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, snapshot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> rm.snapshots {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> snapshot.Timestamp.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(cutoff) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            memorySum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> snapshot.MemoryUsage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cpuSum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> snapshot.CPUUsage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pidSum </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> snapshot.PIDCount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ResourceSnapshot</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ResourceSnapshot</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MemoryUsage: memorySum </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CPUUsage:    cpuSum </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PIDCount:    pidSum </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> count,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-test-implementation-skeletons\">Milestone Test Implementation Skeletons</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/integration/milestone1_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> integration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/test/helpers</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestNamespaceIsolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> helpers.</span><span style=\"color:#B392F0\">NewTestEnvironment</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runtimeManager </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create container spec with namespace configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Enable PID, mount, network, UTS namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Set container hostname to differentiate from host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Configure basic command like [\"sleep\", \"30\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create and start container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Call CreateContainer with spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Call StartContainer to begin process execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify container reaches ContainerRunning state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate PID namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Execute command in container to check PID 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Compare process list inside container vs host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify container process appears with different PID on host</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate mount namespace isolation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Create temporary mount inside container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify mount is not visible on host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that /proc filesystem is properly mounted in container</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate network namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Compare network interface list inside container vs host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify container cannot see host network connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that container has its own loopback interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate UTS namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check hostname inside container matches configured value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify host hostname is unchanged</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Test that hostname change in container doesn't affect host</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Cleanup and verify</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Stop and remove container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify all namespace resources are cleaned up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check for any orphaned processes or mounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestUserNamespaceMapping</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement user namespace UID/GID mapping tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Create container with user namespace enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Configure UID mapping (container root -> host unprivileged user)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify file ownership appears correctly from both perspectives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Test privilege boundaries are enforced</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// test/integration/milestone2_test.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> integration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/test/helpers</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestResourceLimits</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> helpers.</span><span style=\"color:#B392F0\">NewTestEnvironment</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runtimeManager </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    monitor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> helpers.</span><span style=\"color:#B392F0\">NewResourceMonitor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testCases </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        memoryLimit </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cpuLimit    </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        workload    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expectOOM   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            name:        </span><span style=\"color:#9ECBFF\">\"memory_limit_enforced\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            memoryLimit: </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// 50MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cpuLimit:    </span><span style=\"color:#79B8FF\">1000000000</span><span style=\"color:#E1E4E8\">,        </span><span style=\"color:#6A737D\">// 1 CPU core</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            workload:    </span><span style=\"color:#9ECBFF\">\"allocate_100mb\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expectOOM:   </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            name:        </span><span style=\"color:#9ECBFF\">\"cpu_limit_enforced\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            memoryLimit: </span><span style=\"color:#79B8FF\">200</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// 200MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cpuLimit:    </span><span style=\"color:#79B8FF\">500000000</span><span style=\"color:#E1E4E8\">,          </span><span style=\"color:#6A737D\">// 0.5 CPU cores</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            workload:    </span><span style=\"color:#9ECBFF\">\"cpu_intensive\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            expectOOM:   </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, tc </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> testCases {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Run</span><span style=\"color:#E1E4E8\">(tc.name, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Create container spec with resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Set memory limit to tc.memoryLimit </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Set CPU limit to tc.cpuLimit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Configure workload command based on tc.workload</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Create and start container with monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Create container with resource-limited spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Start resource monitoring before container start</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Begin container execution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Monitor resource usage during workload execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Take resource snapshots every 100ms for test duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Track memory usage, CPU usage, and process count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Calculate average usage over test period</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Validate resource limit enforcement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Check that memory usage stays within limits (unless OOM expected)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Verify CPU usage respects configured quota</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Confirm process count stays within PID limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Handle OOM scenarios if expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Check for OOM killer activation if tc.expectOOM is true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Verify container exit code indicates OOM termination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Confirm other system processes are not affected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 6: Cleanup and verify resource release</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Stop container and verify graceful resource cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Check that cgroup directories are removed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // - Confirm system resource usage returns to baseline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestResourceMonitoring</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement resource usage monitoring accuracy tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Create containers with known resource consumption patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Compare reported usage statistics against expected values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Test monitoring update frequency and accuracy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate alert thresholds and notifications</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-commands\">Milestone Checkpoint Commands</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Milestone 1: Namespace Isolation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./test/integration/milestone1_test.go</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output should show:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Container created with isolated namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - PID 1 inside container is container process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Network interfaces differ between container and host</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Hostname isolation working correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - All namespace resources cleaned up after test</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification commands:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --image=test-image</span><span style=\"color:#79B8FF\"> --command=</span><span style=\"color:#9ECBFF\">\"sleep 60\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> test-container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In separate terminal, check namespace isolation:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> exec</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#9ECBFF\"> ps</span><span style=\"color:#9ECBFF\"> aux</span><span style=\"color:#6A737D\">          # Should show only container processes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> exec</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#9ECBFF\"> hostname</span><span style=\"color:#6A737D\">        # Should show container hostname</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> exec</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> link</span><span style=\"color:#9ECBFF\"> list</span><span style=\"color:#6A737D\">   # Should show container interfaces</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Milestone 2: Resource Control  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./test/integration/milestone2_test.go</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Containers respect memory limits (OOM kill when exceeded)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - CPU usage stays within configured quotas  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Resource monitoring reports accurate usage statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Cgroup cleanup occurs properly after container removal</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> limited-container</span><span style=\"color:#79B8FF\"> --memory=50m</span><span style=\"color:#79B8FF\"> --cpu=0.5</span><span style=\"color:#79B8FF\"> --command=</span><span style=\"color:#9ECBFF\">\"stress-test\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> limited-container</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Monitor resource usage:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/container-runtime/limited-container/memory.current</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> /sys/fs/cgroup/container-runtime/limited-container/cpu.stat</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Milestone 3: Filesystem Layering</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./test/integration/milestone3_test.go</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected results:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Overlay filesystem properly combines multiple layers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Copy-on-write behavior creates files in upper layer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - File modifications don't affect read-only base layers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Layer cleanup removes overlay mounts and directories</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> layered-container</span><span style=\"color:#79B8FF\"> --image=multi-layer-image</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">findmnt</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> overlay</span><span style=\"color:#6A737D\">                           # Should show overlay mount</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> exec</span><span style=\"color:#9ECBFF\"> layered-container</span><span style=\"color:#9ECBFF\"> touch</span><span style=\"color:#9ECBFF\"> /test-file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#9ECBFF\"> /var/lib/container-runtime/containers/</span><span style=\"color:#79B8FF\">*</span><span style=\"color:#9ECBFF\">/upper/</span><span style=\"color:#6A737D\">  # Should contain test-file</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Milestone 4: Container Networking</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./test/integration/milestone4_test.go</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected functionality:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Veth pairs connect containers to bridge network</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Containers can communicate using IP addresses  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Port forwarding enables external access to services</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Network isolation prevents unauthorized access</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> web-server</span><span style=\"color:#79B8FF\"> --port-mapping=8080:80</span><span style=\"color:#79B8FF\"> --command=</span><span style=\"color:#9ECBFF\">\"simple-http-server\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> client</span><span style=\"color:#79B8FF\"> --command=</span><span style=\"color:#9ECBFF\">\"sleep 60\"</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> web-server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> start</span><span style=\"color:#9ECBFF\"> client</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test connectivity:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8080</span><span style=\"color:#6A737D\">                       # Should reach container web server</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> ./container-runtime</span><span style=\"color:#9ECBFF\"> exec</span><span style=\"color:#9ECBFF\"> client</span><span style=\"color:#9ECBFF\"> ping</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#9ECBFF\">web-server-i</span><span style=\"color:#E1E4E8\">p</span><span style=\"color:#F97583\">></span><span style=\"color:#6A737D\">  # Should succeed</span></span></code></pre></div>\n\n<p>The testing implementation provides comprehensive validation of each milestone&#39;s functionality while building toward realistic integration scenarios. The progressive testing approach ensures that developers can verify each component works correctly before integrating with dependent components, making debugging more manageable and building confidence in the overall system design.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - This section provides debugging techniques for namespace isolation (milestone 1), resource control (milestone 2), filesystem layering (milestone 3), and network management (milestone 4). Effective debugging requires understanding both the kernel-level mechanisms and the container runtime&#39;s abstraction layers.</p>\n</blockquote>\n<p>Building a container runtime involves orchestrating multiple complex Linux kernel mechanisms that can fail in subtle ways. When a container fails to start, exhibits unexpected behavior, or consumes incorrect resources, the root cause could lie in namespace creation, cgroup configuration, filesystem mounting, or network setup. This debugging guide provides systematic approaches for diagnosing problems in each component, using kernel inspection tools and container runtime state examination.</p>\n<p><strong>Mental Model: Detective Investigation</strong></p>\n<p>Think of debugging a container runtime like investigating a crime scene. Each kernel mechanism (namespaces, cgroups, overlayfs, network interfaces) leaves traces in the system that tell a story about what happened. Just as a detective follows evidence from multiple sources to reconstruct events, we use kernel state inspection tools, log analysis, and systematic testing to understand why containers behave unexpectedly. The key is knowing where to look for evidence and how to interpret what we find.</p>\n<p>The debugging process follows a systematic approach: first observe symptoms from the container&#39;s perspective, then examine the underlying kernel state, identify discrepancies between expected and actual configuration, and finally trace the root cause back through the container runtime&#39;s component interactions. Each component leaves different types of evidence in different locations within the kernel&#39;s virtual filesystems.</p>\n<h3 id=\"namespace-debugging-techniques\">Namespace Debugging Techniques</h3>\n<p>Namespace issues manifest as containers seeing unexpected processes, having incorrect filesystem views, or lacking proper isolation from the host system. These problems typically stem from incorrect namespace creation, failed filesystem operations, or improper process assignment to namespaces.</p>\n<p><strong>Understanding Namespace State Inspection</strong></p>\n<p>The Linux kernel exposes namespace information through the <code>/proc</code> filesystem, allowing us to inspect which namespaces exist and which processes belong to them. Each process has namespace information in <code>/proc/[pid]/ns/</code> that shows symbolic links to namespace identifiers. When containers share namespaces unexpectedly or fail to create new namespaces, this directory provides the ground truth about actual kernel state.</p>\n<p>The <code>lsns</code> command provides a high-level view of all namespaces on the system, showing which processes belong to each namespace type. This tool helps identify whether container processes are actually isolated or accidentally sharing host namespaces. For example, if a container process appears in the same PID namespace as the host, the namespace creation failed silently.</p>\n<p><strong>Common Namespace Debugging Scenarios</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Commands</th>\n<th>Fix Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container sees all host processes</td>\n<td>PID namespace creation failed</td>\n<td><code>lsns -t pid</code>, <code>ls -la /proc/[pid]/ns/</code></td>\n<td>Check namespace creation flags, verify CLONE_NEWPID</td>\n</tr>\n<tr>\n<td>Container filesystem shows host files</td>\n<td>Mount namespace creation failed or pivot_root failed</td>\n<td><code>findmnt</code>, <code>cat /proc/[pid]/mountinfo</code></td>\n<td>Verify mount namespace, check pivot_root sequence</td>\n</tr>\n<tr>\n<td>Container has host hostname</td>\n<td>UTS namespace not created or not configured</td>\n<td><code>unshare -u hostname</code>, check <code>/proc/[pid]/ns/uts</code></td>\n<td>Ensure UTS namespace creation and hostname setting</td>\n</tr>\n<tr>\n<td>Container networking uses host interfaces</td>\n<td>Network namespace creation failed</td>\n<td><code>ip netns list</code>, <code>ip link show</code> in container</td>\n<td>Verify network namespace creation and veth setup</td>\n</tr>\n<tr>\n<td>Permission denied in container</td>\n<td>User namespace mapping incorrect</td>\n<td><code>cat /proc/[pid]/uid_map</code>, <code>cat /proc/[pid]/gid_map</code></td>\n<td>Fix UID/GID mapping configuration</td>\n</tr>\n</tbody></table>\n<p><strong>Process and Mount Inspection Techniques</strong></p>\n<p>When containers exhibit incorrect process visibility, the first step is determining which PID namespace the container process actually belongs to. The <code>/proc/[pid]/ns/pid</code> symlink shows the namespace identifier, which should be unique for each container. If multiple containers or the host share the same PID namespace identifier, namespace isolation has failed.</p>\n<p>Mount namespace problems require examining the actual mount table that the container process sees. The <code>/proc/[pid]/mountinfo</code> file shows all mount points visible to a specific process, including overlay filesystem mounts, bind mounts, and special filesystems like <code>/proc</code> and <code>/sys</code>. Comparing the container&#39;s mount table with the expected configuration reveals whether filesystem isolation is working correctly.</p>\n<p>The <code>pivot_root</code> operation is particularly error-prone and leaves specific evidence when it fails. If <code>pivot_root</code> fails, the container process will still see the host root filesystem instead of the container&#39;s overlay filesystem. The mount table will show the original host mounts instead of the expected container filesystem hierarchy.</p>\n<p><strong>Network Namespace Inspection</strong></p>\n<p>Network namespace isolation problems manifest as containers having unexpected network interfaces or connectivity. The <code>ip netns</code> command lists all named network namespaces, but container network namespaces are typically unnamed and must be accessed through process namespace references.</p>\n<p>To inspect a container&#39;s network configuration, use <code>nsenter</code> to execute network commands within the container&#39;s namespace: <code>nsenter -t [pid] -n ip addr show</code> reveals which interfaces exist inside the container. A properly isolated container should only see its container interface and the loopback interface, not host interfaces.</p>\n<p>Network namespace debugging also involves verifying veth pair creation and bridge attachment. Each veth pair creates two linked interfaces, with one end in the host namespace and one in the container namespace. The <code>ip link show</code> command in both namespaces should show the paired interfaces with matching indices.</p>\n<p><strong>File Permission and User Namespace Issues</strong></p>\n<p>User namespace problems typically manifest as permission denied errors when the container tries to access files or perform operations that should be allowed. These issues stem from incorrect UID/GID mapping between the container and host user namespaces.</p>\n<p>The <code>/proc/[pid]/uid_map</code> and <code>/proc/[pid]/gid_map</code> files show the current mapping configuration. Each line specifies a range mapping: container ID range, host ID range, and count. Incorrect mappings cause the container process to have unexpected privileges or lack necessary permissions.</p>\n<p>User namespace debugging requires understanding the interaction between namespace isolation and filesystem permissions. Files created by the container appear on the host filesystem with the mapped host UID/GID, which must align with the host user running the container runtime.</p>\n<p>⚠️ <strong>Pitfall: Empty /proc Directory in Container</strong></p>\n<p>One of the most common namespace issues occurs when the container&#39;s <code>/proc</code> directory is empty or shows host processes instead of container processes. This happens when the mount namespace is created correctly, but <code>/proc</code> is not remounted within the container&#39;s PID namespace.</p>\n<p>The fix requires mounting a new <code>/proc</code> filesystem after creating the PID namespace but before executing the container process:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Inside container, after PID namespace creation:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">mount</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> proc</span><span style=\"color:#9ECBFF\"> proc</span><span style=\"color:#9ECBFF\"> /proc</span></span></code></pre></div>\n\n<p>This issue is particularly confusing because the container has a separate PID namespace (process isolation works), but tools like <code>ps</code> fail because they can&#39;t read process information from <code>/proc</code>.</p>\n<p>⚠️ <strong>Pitfall: pivot_root Requires Mount Point</strong></p>\n<p>The <code>pivot_root</code> system call fails with &quot;Invalid argument&quot; if the new root directory is not a mount point. This is a common error when trying to pivot to a regular directory instead of a mounted filesystem.</p>\n<p>The solution is ensuring the new root is a mount point before calling <code>pivot_root</code>. For overlay filesystems, this means the overlay mount operation must complete successfully before attempting the filesystem pivot. Always verify mount success before proceeding to pivot_root.</p>\n<p><strong>Namespace Debugging Command Reference</strong></p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Purpose</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>lsns</code></td>\n<td>List all namespaces</td>\n<td><code>lsns -t pid -p [container-pid]</code></td>\n</tr>\n<tr>\n<td><code>nsenter</code></td>\n<td>Execute command in namespace</td>\n<td><code>nsenter -t [pid] -a ps aux</code></td>\n</tr>\n<tr>\n<td><code>unshare</code></td>\n<td>Create namespace for testing</td>\n<td><code>unshare -p -f --mount-proc bash</code></td>\n</tr>\n<tr>\n<td><code>findmnt</code></td>\n<td>Show mount table</td>\n<td><code>findmnt -N [pid]</code></td>\n</tr>\n<tr>\n<td><code>cat /proc/[pid]/ns/*</code></td>\n<td>Show namespace IDs</td>\n<td>Compare container vs host namespace IDs</td>\n</tr>\n</tbody></table>\n<h3 id=\"cgroup-debugging-techniques\">Cgroup Debugging Techniques</h3>\n<p>Cgroup-related problems manifest as containers exceeding resource limits, failing to start due to permission issues, or resource monitoring returning incorrect values. These issues typically stem from incorrect cgroup hierarchy setup, improper controller configuration, or permission problems with cgroup filesystem access.</p>\n<p><strong>Understanding Cgroup State Inspection</strong></p>\n<p>The cgroups v2 unified hierarchy exposes all configuration and statistics through the <code>/sys/fs/cgroup</code> filesystem. Each container gets its own cgroup directory containing controller configuration files and runtime statistics. Understanding the relationship between cgroup hierarchy, controller enablement, and process assignment is crucial for effective debugging.</p>\n<p>The <code>systemd-cgls</code> command provides a tree view of the entire cgroup hierarchy, showing which processes belong to each cgroup. This tool helps identify whether container processes are assigned to the correct cgroups and whether cgroup nesting is configured properly.</p>\n<p><strong>Cgroup Hierarchy and Controller Verification</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>File Location</th>\n<th>Purpose</th>\n<th>Diagnostic Command</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cgroup membership</td>\n<td><code>/sys/fs/cgroup/[path]/cgroup.procs</code></td>\n<td>Lists PIDs in cgroup</td>\n<td><code>cat cgroup.procs</code></td>\n</tr>\n<tr>\n<td>Enabled controllers</td>\n<td><code>/sys/fs/cgroup/cgroup.controllers</code></td>\n<td>Shows available controllers</td>\n<td><code>cat cgroup.controllers</code></td>\n</tr>\n<tr>\n<td>Memory limit</td>\n<td><code>/sys/fs/cgroup/[path]/memory.max</code></td>\n<td>Current memory limit</td>\n<td><code>cat memory.max</code></td>\n</tr>\n<tr>\n<td>Memory usage</td>\n<td><code>/sys/fs/cgroup/[path]/memory.current</code></td>\n<td>Current memory consumption</td>\n<td><code>cat memory.current</code></td>\n</tr>\n<tr>\n<td>CPU quota</td>\n<td><code>/sys/fs/cgroup/[path]/cpu.max</code></td>\n<td>CPU quota and period</td>\n<td><code>cat cpu.max</code></td>\n</tr>\n<tr>\n<td>OOM events</td>\n<td><code>/sys/fs/cgroup/[path]/memory.events</code></td>\n<td>OOM kill statistics</td>\n<td><code>grep oom_kill memory.events</code></td>\n</tr>\n</tbody></table>\n<p>The cgroup hierarchy must be properly structured for controllers to function correctly. Each container should have its own subdirectory under a parent cgroup where the necessary controllers are enabled. The <code>cgroup.subtree_control</code> file in parent directories controls which controllers are available to child cgroups.</p>\n<p><strong>Memory Controller Debugging</strong></p>\n<p>Memory limit problems often manifest as containers being killed unexpectedly or consuming more memory than expected. The memory controller provides detailed statistics about memory usage patterns, pressure indicators, and out-of-memory events.</p>\n<p>The <code>memory.current</code> file shows instantaneous memory usage, while <code>memory.max</code> shows the configured limit. If usage consistently approaches the limit, the container may be experiencing memory pressure. The <code>memory.pressure</code> file provides pressure stall information indicating when memory allocation is being delayed.</p>\n<p>Out-of-memory events are recorded in <code>memory.events</code>, which tracks both OOM kills and memory pressure events. When a container is killed due to memory exhaustion, this file shows the oom_kill count incrementing. This helps distinguish between application crashes and resource limit enforcement.</p>\n<p><strong>CPU Controller Debugging</strong></p>\n<p>CPU limit issues manifest as containers running slower than expected or consuming more CPU than allocated. The CPU controller uses quota and period values to implement CPU time limits, which can be confusing to interpret and debug.</p>\n<p>The <code>cpu.max</code> file contains two values: quota and period (e.g., &quot;100000 100000&quot; means 100ms quota per 100ms period, allowing 100% CPU). The <code>cpu.stat</code> file shows actual CPU usage statistics, including throttling events when the quota is exceeded.</p>\n<p>CPU throttling debugging requires comparing the configured quota with actual usage patterns. High values in <code>cpu.stat</code> for <code>throttled_usec</code> indicate the container is being actively throttled. This may be expected behavior if the limit is working correctly, or indicate misconfigured limits if the container should have more CPU access.</p>\n<p><strong>Common Cgroup Debugging Scenarios</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Investigation Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container immediately killed</td>\n<td>Memory limit too low or OOM kill</td>\n<td>Check <code>memory.events</code> for oom_kill, compare <code>memory.max</code> vs <code>memory.current</code></td>\n<td>Increase memory limit or optimize container memory usage</td>\n</tr>\n<tr>\n<td>Container runs slowly</td>\n<td>CPU throttling or insufficient quota</td>\n<td>Check <code>cpu.stat</code> for throttling, verify <code>cpu.max</code> configuration</td>\n<td>Adjust CPU quota or identify CPU-intensive operations</td>\n</tr>\n<tr>\n<td>Resource monitoring shows zero usage</td>\n<td>Cgroup not created or process not assigned</td>\n<td>Verify cgroup directory exists, check <code>cgroup.procs</code> contains container PID</td>\n<td>Fix cgroup creation or process assignment</td>\n</tr>\n<tr>\n<td>Permission denied writing cgroup files</td>\n<td>Insufficient privileges or controller not enabled</td>\n<td>Check file ownership, verify controller in <code>cgroup.subtree_control</code></td>\n<td>Run with appropriate privileges or enable controllers</td>\n</tr>\n<tr>\n<td>Cgroup cannot be removed</td>\n<td>Processes still in cgroup or child cgroups exist</td>\n<td>Check <code>cgroup.procs</code> is empty, verify no subdirectories</td>\n<td>Kill remaining processes or remove child cgroups first</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Cgroups v1 vs v2 Interface Differences</strong></p>\n<p>Many debugging approaches fail because they assume cgroups v1 interfaces while the system uses cgroups v2. The file locations, interface syntax, and controller behaviors differ significantly between versions.</p>\n<p>To determine which version is active, check <code>/proc/mounts</code> for cgroup filesystem types. Cgroups v2 shows <code>cgroup2</code> filesystem type mounted at <code>/sys/fs/cgroup</code>, while v1 shows separate <code>cgroup</code> mounts for each controller.</p>\n<p>The debugging commands and file paths in this guide assume cgroups v2. For systems still using v1, controller files are located under separate mount points like <code>/sys/fs/cgroup/memory/</code> and <code>/sys/fs/cgroup/cpu/</code>.</p>\n<p>⚠️ <strong>Pitfall: Controller Delegation Requirements</strong></p>\n<p>Cgroups v2 requires explicit controller delegation from parent to child cgroups. If a controller is not enabled in the parent&#39;s <code>cgroup.subtree_control</code>, child cgroups cannot use that controller even if it&#39;s available at the system level.</p>\n<p>To fix delegation issues, enable controllers at each level of the hierarchy: <code>echo &quot;+memory +cpu&quot; &gt; /sys/fs/cgroup/[parent]/cgroup.subtree_control</code>. This must be done recursively for all parent cgroups up to the container&#39;s cgroup.</p>\n<p><strong>Resource Monitoring and Statistics Interpretation</strong></p>\n<p>Effective cgroup debugging requires understanding how to interpret the statistics and pressure indicators provided by each controller. The statistics files update continuously and provide both instantaneous values and cumulative counters.</p>\n<p>Memory statistics include detailed breakdowns of different memory types: anonymous memory, file cache, shared memory, and kernel memory. Understanding these categories helps identify whether memory usage is due to application data, file system cache, or kernel overhead.</p>\n<p>CPU statistics track not just usage time but also scheduling fairness, voluntary context switches, and throttling events. High involuntary context switch counts may indicate CPU contention, while excessive throttling suggests quota adjustments are needed.</p>\n<p><strong>Cgroup Debugging Tool Reference</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Key Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>systemd-cgls</code></td>\n<td>Display cgroup hierarchy</td>\n<td><code>systemd-cgls -u [container-service]</code></td>\n</tr>\n<tr>\n<td><code>systemd-cgtop</code></td>\n<td>Live cgroup resource usage</td>\n<td><code>systemd-cgtop</code></td>\n</tr>\n<tr>\n<td><code>cat /sys/fs/cgroup/*/cgroup.*</code></td>\n<td>Inspect cgroup configuration</td>\n<td>Check membership, controllers, limits</td>\n</tr>\n<tr>\n<td><code>echo [pid] &gt; cgroup.procs</code></td>\n<td>Manually assign process</td>\n<td>For testing process assignment</td>\n</tr>\n<tr>\n<td><code>cgexec</code></td>\n<td>Execute command in cgroup</td>\n<td><code>cgexec -g memory:/test/container command</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"network-debugging-techniques\">Network Debugging Techniques</h3>\n<p>Container networking problems manifest as connectivity failures, incorrect IP addresses, unreachable services, or port mapping not working. These issues typically involve veth pair creation, bridge configuration, IP address assignment, or iptables rule management.</p>\n<p><strong>Understanding Container Network Architecture</strong></p>\n<p>Container networking creates a complex topology involving multiple network namespaces, virtual interfaces, bridges, and NAT rules. Each component can fail independently, making systematic debugging essential. The key is understanding the packet path from external clients through the host networking stack to the container application.</p>\n<p>A typical packet flow involves: external client → host interface → iptables DNAT → bridge → veth pair → container interface → container application. Each step in this path can be verified independently using standard Linux networking tools.</p>\n<p><strong>Network Interface and Bridge Inspection</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Host Command</th>\n<th>Container Command</th>\n<th>What to Verify</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Veth pair existence</td>\n<td><code>ip link show</code></td>\n<td><code>nsenter -t [pid] -n ip link show</code></td>\n<td>Both ends exist and are UP</td>\n</tr>\n<tr>\n<td>Bridge membership</td>\n<td><code>bridge link show</code></td>\n<td>N/A</td>\n<td>Container veth attached to bridge</td>\n</tr>\n<tr>\n<td>IP address assignment</td>\n<td><code>bridge fdb show</code></td>\n<td><code>nsenter -t [pid] -n ip addr show</code></td>\n<td>Container has correct IP</td>\n</tr>\n<tr>\n<td>Routing configuration</td>\n<td><code>ip route show</code></td>\n<td><code>nsenter -t [pid] -n ip route show</code></td>\n<td>Default route points to bridge gateway</td>\n</tr>\n<tr>\n<td>Interface statistics</td>\n<td><code>ip -s link show [interface]</code></td>\n<td>Same inside container</td>\n<td>Check for packet drops or errors</td>\n</tr>\n</tbody></table>\n<p>Network interface debugging starts with verifying that veth pairs are created correctly and both ends are operational. The <code>ip link show</code> command should show the host end of the veth pair with state UP, and the corresponding interface inside the container namespace should also be UP with the expected name.</p>\n<p>Bridge configuration requires verifying that the container&#39;s veth interface is properly attached to the container bridge. The <code>bridge link show</code> command displays all interfaces attached to bridges, and the container interface should appear in this list with the correct bridge association.</p>\n<p><strong>IP Address and Routing Verification</strong></p>\n<p>IP address assignment problems cause containers to have incorrect addresses or duplicate addresses that conflict with other containers. The container&#39;s IP address should be unique within the bridge subnet and properly configured with the correct netmask and gateway.</p>\n<p>Within the container namespace, <code>ip addr show</code> should display the assigned IP address on the container interface. The default route should point to the bridge gateway IP address, enabling communication with other containers and external networks.</p>\n<p>Address resolution (ARP) problems can cause connectivity issues even when IP configuration appears correct. The <code>ip neigh show</code> command displays the ARP table, which should contain entries for the gateway and other containers that have been contacted.</p>\n<p><strong>Port Forwarding and NAT Rule Debugging</strong></p>\n<p>Port mapping relies on iptables NAT rules to forward traffic from host ports to container ports. These rules span multiple iptables tables and chains, making debugging complex but systematic.</p>\n<table>\n<thead>\n<tr>\n<th>Table</th>\n<th>Chain</th>\n<th>Rule Type</th>\n<th>Purpose</th>\n<th>Verification Command</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>nat</td>\n<td>PREROUTING</td>\n<td>DNAT</td>\n<td>Forward host port to container</td>\n<td><code>iptables -t nat -L PREROUTING -n -v</code></td>\n</tr>\n<tr>\n<td>filter</td>\n<td>FORWARD</td>\n<td>ACCEPT</td>\n<td>Allow forwarded traffic</td>\n<td><code>iptables -L FORWARD -n -v</code></td>\n</tr>\n<tr>\n<td>nat</td>\n<td>POSTROUTING</td>\n<td>MASQUERADE</td>\n<td>Source NAT for outbound</td>\n<td><code>iptables -t nat -L POSTROUTING -n -v</code></td>\n</tr>\n</tbody></table>\n<p>NAT rule debugging requires checking that destination NAT (DNAT) rules exist for each port mapping and that the rules correctly translate host IP:port to container IP:port. The rule should appear in the PREROUTING chain with the correct target specification.</p>\n<p>Forward rules in the filter table must allow traffic to pass between the host and container interfaces. Missing ACCEPT rules in the FORWARD chain cause connections to be dropped even when NAT rules are correctly configured.</p>\n<p><strong>Common Network Debugging Scenarios</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container has no network interface</td>\n<td>Network namespace creation failed or veth not moved</td>\n<td>Check <code>ip link</code> in container, verify network namespace</td>\n<td>Recreate veth pair and move to namespace</td>\n</tr>\n<tr>\n<td>Container cannot reach other containers</td>\n<td>Bridge not configured or IP conflict</td>\n<td>Check bridge membership, verify unique IPs</td>\n<td>Fix bridge setup or resolve IP conflict</td>\n</tr>\n<tr>\n<td>External clients cannot reach container service</td>\n<td>Port forwarding rules missing or incorrect</td>\n<td>Check iptables NAT rules, test with telnet</td>\n<td>Add or fix DNAT rules in iptables</td>\n</tr>\n<tr>\n<td>Container cannot reach external services</td>\n<td>No default route or DNS misconfiguration</td>\n<td>Check routing table in container, test DNS</td>\n<td>Configure default route and DNS servers</td>\n</tr>\n<tr>\n<td>Intermittent connectivity issues</td>\n<td>MTU mismatch or packet fragmentation</td>\n<td>Check MTU on all interfaces, capture packets</td>\n<td>Set consistent MTU values across path</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Veth Interface Names and Namespace Movement</strong></p>\n<p>Veth interfaces have confusing naming behavior when moved between namespaces. Creating a veth pair with specific names and then moving one end to a container namespace can result in unexpected interface names inside the container.</p>\n<p>The solution is to rename the container interface after moving it to the target namespace: <code>ip link set [old-name] name [new-name]</code>. This ensures consistent interface naming regardless of the kernel&#39;s automatic name generation.</p>\n<p>Additionally, attempting to delete a veth pair from the wrong namespace can fail silently, leaving interfaces in an inconsistent state. Always delete veth pairs from the namespace containing the interface you&#39;re targeting.</p>\n<p>⚠️ <strong>Pitfall: iptables Rule Persistence and Cleanup</strong></p>\n<p>Container runtime crashes or improper shutdown can leave iptables rules in place, causing port conflicts when restarting containers with the same port mappings. These orphaned rules can prevent new containers from binding to the same ports.</p>\n<p>The fix requires explicitly cleaning up iptables rules during container removal: <code>iptables -t nat -D PREROUTING -p tcp --dport [host-port] -j DNAT --to [container-ip]:[container-port]</code>. Implementing proper cleanup ensures that container removal completely reverses the network configuration changes.</p>\n<p><strong>Network Performance and Packet Analysis</strong></p>\n<p>Network debugging often requires analyzing actual packet flow to identify where communication fails. The <code>tcpdump</code> tool can capture packets on any interface, including veth interfaces and bridges, showing exactly what traffic is flowing and where it stops.</p>\n<p>Capturing packets on both ends of a veth pair reveals whether traffic is reaching the container interface and whether responses are being sent back. The command <code>tcpdump -i [interface] -n</code> shows packet headers without hostname resolution, making it easier to verify IP addresses and ports.</p>\n<p>Bridge packet analysis helps identify forwarding issues: <code>tcpdump -i [bridge-name] -n</code> captures all traffic crossing the bridge, including inter-container communication and traffic to/from the host namespace.</p>\n<p><strong>Network Debugging Tool Reference</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tool</th>\n<th>Purpose</th>\n<th>Key Usage Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ip</code></td>\n<td>Interface and routing management</td>\n<td><code>ip link</code>, <code>ip addr</code>, <code>ip route</code>, <code>ip netns</code></td>\n</tr>\n<tr>\n<td><code>bridge</code></td>\n<td>Bridge configuration inspection</td>\n<td><code>bridge link show</code>, <code>bridge fdb show</code></td>\n</tr>\n<tr>\n<td><code>iptables</code></td>\n<td>Firewall and NAT rule management</td>\n<td><code>iptables -L -n -v</code>, <code>iptables -t nat -L</code></td>\n</tr>\n<tr>\n<td><code>nsenter</code></td>\n<td>Execute commands in network namespace</td>\n<td><code>nsenter -t [pid] -n [command]</code></td>\n</tr>\n<tr>\n<td><code>tcpdump</code></td>\n<td>Packet capture and analysis</td>\n<td><code>tcpdump -i [interface] -n</code></td>\n</tr>\n<tr>\n<td><code>ss</code></td>\n<td>Socket statistics and connection state</td>\n<td><code>ss -tlnp</code> (listening sockets), <code>ss -an</code> (all connections)</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging techniques described above require systematic application during container runtime development. Effective debugging combines automated testing with manual inspection tools to identify problems early and understand their root causes.</p>\n<p><strong>Technology Recommendations for Debugging Infrastructure</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Log Analysis</td>\n<td>Text logs with grep/awk</td>\n<td>Structured logging with JSON + log aggregation</td>\n</tr>\n<tr>\n<td>State Inspection</td>\n<td>Manual shell commands</td>\n<td>Automated scripts with health checks</td>\n</tr>\n<tr>\n<td>Network Testing</td>\n<td>ping/curl commands</td>\n<td>Packet capture with automated analysis</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Manual /sys/fs/cgroup inspection</td>\n<td>Prometheus metrics collection</td>\n</tr>\n<tr>\n<td>Error Tracking</td>\n<td>Function return values</td>\n<td>Distributed tracing with OpenTelemetry</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure for Debugging Support</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>container-runtime/\n  cmd/\n    runtime/main.go                 ← main runtime binary\n    debug/\n      inspect.go                    ← debug inspection commands\n      health-check.go               ← automated health checking\n  internal/\n    debug/\n      namespace.go                  ← namespace debugging utilities\n      cgroup.go                     ← cgroup inspection helpers\n      network.go                    ← network debugging tools\n    logging/\n      structured.go                 ← structured logging setup\n  scripts/\n    debug-container.sh              ← shell script for manual debugging\n    cleanup-orphaned.sh             ← cleanup script for orphaned resources</code></pre></div>\n\n<p><strong>Debug Inspection Infrastructure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// DebugInspector provides comprehensive container runtime debugging capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// It coordinates inspection across namespaces, cgroups, filesystem, and network components.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DebugInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runtime </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RuntimeManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StructuredLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Component-specific inspectors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    namespaceInspector </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceInspector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupInspector    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupInspector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkInspector   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkInspector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filesystemInspector </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FilesystemInspector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InspectContainer performs comprehensive debugging inspection of a container.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns detailed state information for all container components.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">d </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InspectContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerDebugInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load container state from StateManager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Inspect namespace state using NamespaceInspector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Collect cgroup statistics and configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify network configuration and connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check filesystem mount status and overlay state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Aggregate all inspection results into ContainerDebugInfo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Identify any configuration inconsistencies or errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ContainerDebugInfo aggregates debugging information from all container components.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ContainerDebugInfo</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContainerID   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"container_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State         </span><span style=\"color:#B392F0\">ContainerState</span><span style=\"color:#9ECBFF\">         `json:\"state\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Namespace     </span><span style=\"color:#B392F0\">NamespaceDebugInfo</span><span style=\"color:#9ECBFF\">     `json:\"namespace\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cgroup        </span><span style=\"color:#B392F0\">CgroupDebugInfo</span><span style=\"color:#9ECBFF\">        `json:\"cgroup\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Network       </span><span style=\"color:#B392F0\">NetworkDebugInfo</span><span style=\"color:#9ECBFF\">       `json:\"network\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Filesystem    </span><span style=\"color:#B392F0\">FilesystemDebugInfo</span><span style=\"color:#9ECBFF\">    `json:\"filesystem\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Issues        []</span><span style=\"color:#B392F0\">DebugIssue</span><span style=\"color:#9ECBFF\">           `json:\"issues\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Recommendations []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">             `json:\"recommendations\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Namespace Debugging Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NamespaceInspector provides tools for inspecting namespace state and configuration.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NamespaceInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    procFS </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // typically \"/proc\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InspectNamespaceState examines namespace configuration for a container process.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns detailed information about namespace types, IDs, and isolation status.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ni </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InspectNamespaceState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceDebugInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read namespace information from /proc/[pid]/ns/</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare container namespace IDs with host namespace IDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify expected namespace types are created and isolated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check mount table from /proc/[pid]/mountinfo</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify /proc filesystem is properly mounted in container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Inspect user namespace UID/GID mappings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check UTS namespace hostname configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyProcessIsolation checks if container process sees only expected processes.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tests PID namespace isolation by comparing visible processes.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ni </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NamespaceInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyProcessIsolation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerPID</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ProcessIsolationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Execute 'ps aux' inside container namespace using nsenter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse process list and verify container process has PID 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Ensure no host processes are visible in container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check that only container and child processes are visible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return isolation status with any violations detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cgroup Debugging Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// CgroupInspector provides tools for inspecting cgroup configuration and resource usage.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CgroupInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cgroupRoot </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // typically \"/sys/fs/cgroup\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InspectCgroupConfig examines cgroup setup and resource limits for a container.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns comprehensive information about controllers, limits, and current usage.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ci </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InspectCgroupConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupDebugInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify cgroup directory exists at expected path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check enabled controllers in cgroup.controllers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read memory limits from memory.max and memory.swap.max</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Read CPU configuration from cpu.max and cpu.weight</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Collect current usage from memory.current and cpu.stat</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for OOM events in memory.events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify process assignment in cgroup.procs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MonitorResourcePressure tracks resource pressure indicators for debugging.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns pressure information that can indicate resource bottlenecks.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ci </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CgroupInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MonitorResourcePressure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">cgroupPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PressureInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Read memory pressure from memory.pressure file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Read CPU pressure from cpu.pressure file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Read IO pressure from io.pressure file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Parse pressure stall information (some, full averages)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate pressure trends over monitoring period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return structured pressure information with analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Network Debugging Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NetworkInspector provides tools for debugging container networking configuration.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkInspector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    netlink </span><span style=\"color:#B392F0\">NetlinkInterface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    iptables </span><span style=\"color:#B392F0\">IPTablesInterface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InspectNetworkConfig examines network setup for container connectivity debugging.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns detailed information about interfaces, routing, and NAT configuration.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ni </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InspectNetworkConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pid</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkDebugInfo</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: List network interfaces in host and container namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify veth pair creation and proper link state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check bridge membership for container interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Inspect IP address assignment and routing configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify iptables NAT rules for port forwarding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Test connectivity between container and bridge gateway</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check DNS configuration in container namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestConnectivity performs connectivity tests for network debugging.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Tests various network paths to identify where communication fails.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ni </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkInspector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TestConnectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerPID</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">targetHost</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">targetPort</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConnectivityTestResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Test loopback connectivity within container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Test connectivity to bridge gateway from container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test connectivity to other containers on same bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Test connectivity to external hosts from container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Test port forwarding from host to container service</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return detailed results showing which tests passed/failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Automated Health Checking</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// HealthChecker provides automated validation of container runtime state.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Performs systematic checks to identify common configuration problems.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HealthChecker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inspector </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugInspector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StructuredLogger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateContainerHealth performs comprehensive health checking for a container.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns structured results indicating any detected issues or inconsistencies.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">hc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateContainerHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HealthCheckResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify container state is consistent across all components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check that all expected namespaces are created and isolated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate cgroup configuration matches container specification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify network configuration and connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check filesystem mount status and overlay configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Test basic container operations (exec, signal delivery)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return comprehensive health status with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints for Debugging Implementation</strong></p>\n<p>After implementing debugging capabilities for each milestone:</p>\n<p><strong>Milestone 1 Checkpoint - Namespace Debugging:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test namespace inspection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#79B8FF\"> --container</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --component</span><span style=\"color:#9ECBFF\"> namespaces</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output shows:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - PID namespace: isolated (container PID 1 ≠ host PID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Mount namespace: isolated (/proc shows only container processes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Network namespace: isolated (only container interfaces visible)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - UTS namespace: isolated (container hostname differs from host)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test process isolation verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sudo</span><span style=\"color:#9ECBFF\"> nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#79B8FF\">-p</span><span style=\"color:#9ECBFF\"> ps</span><span style=\"color:#9ECBFF\"> aux</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show only container processes with container process as PID 1</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint - Cgroup Debugging:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test cgroup inspection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#79B8FF\"> --container</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --component</span><span style=\"color:#9ECBFF\"> cgroups</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output shows:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Memory limit: configured and enforced</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - CPU quota: configured with expected values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Process assignment: container PID in correct cgroup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Resource usage: current consumption within limits</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test resource monitoring</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/debug</span><span style=\"color:#9ECBFF\"> monitor</span><span style=\"color:#79B8FF\"> --container</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --duration</span><span style=\"color:#9ECBFF\"> 30s</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show resource usage trends and pressure indicators</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint - Filesystem Debugging:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test overlay filesystem inspection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#79B8FF\"> --container</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --component</span><span style=\"color:#9ECBFF\"> filesystem</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output shows:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Overlay mount: correctly configured with upper/lower/work directories</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Layer stacking: proper order and accessibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Copy-on-write: file modifications isolated to upper layer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify overlay mount</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">findmnt</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> test-container</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show overlayfs mount with correct layer directories</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Checkpoint - Network Debugging:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test network configuration inspection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/debug</span><span style=\"color:#9ECBFF\"> inspect</span><span style=\"color:#79B8FF\"> --container</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --component</span><span style=\"color:#9ECBFF\"> network</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output shows:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Veth pair: created and properly linked</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Bridge membership: container attached to bridge</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - IP assignment: unique IP from configured pool</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Port forwarding: iptables rules for mapped ports</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test connectivity</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/debug</span><span style=\"color:#9ECBFF\"> test-connectivity</span><span style=\"color:#79B8FF\"> --container</span><span style=\"color:#9ECBFF\"> test-container</span><span style=\"color:#79B8FF\"> --target</span><span style=\"color:#9ECBFF\"> google.com:80</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show successful connectivity test results</span></span></code></pre></div>\n\n<p><strong>Debugging Script Examples</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># debug-container.sh - Manual debugging script for container issues</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CONTAINER_ID</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">$1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-z</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$CONTAINER_ID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"Usage: </span><span style=\"color:#79B8FF\">$0</span><span style=\"color:#9ECBFF\"> &#x3C;container-id>\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"=== Container Debug Information ===\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Container ID: </span><span style=\"color:#E1E4E8\">$CONTAINER_ID</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Get container PID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">PID</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$CONTAINER_ID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-z</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"ERROR: Container process not found\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Container PID: </span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check namespace isolation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"\\n=== Namespace Information ===\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">ls</span><span style=\"color:#79B8FF\"> -la</span><span style=\"color:#9ECBFF\"> \"/proc/</span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">/ns/\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check cgroup assignment</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"\\n=== Cgroup Information ===\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> \"/proc/</span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">/cgroup\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check network configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"\\n=== Network Configuration ===\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> addr</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">nsenter</span><span style=\"color:#79B8FF\"> -t</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> ip</span><span style=\"color:#9ECBFF\"> route</span><span style=\"color:#9ECBFF\"> show</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check resource usage</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"\\n=== Resource Usage ===\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">CGROUP_PATH</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> memory</span><span style=\"color:#9ECBFF\"> \"/proc/</span><span style=\"color:#E1E4E8\">$PID</span><span style=\"color:#9ECBFF\">/cgroup\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> cut</span><span style=\"color:#79B8FF\"> -d:</span><span style=\"color:#79B8FF\"> -f3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#F97583\">-n</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#E1E4E8\">$CGROUP_PATH</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\"> ]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cat</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup</span><span style=\"color:#E1E4E8\">$CGROUP_PATH</span><span style=\"color:#9ECBFF\">/memory.current\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cat</span><span style=\"color:#9ECBFF\"> \"/sys/fs/cgroup</span><span style=\"color:#E1E4E8\">$CGROUP_PATH</span><span style=\"color:#9ECBFF\">/memory.max\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span></code></pre></div>\n\n<p>This debugging implementation provides comprehensive tools for identifying and resolving container runtime issues across all components. The structured approach ensures systematic problem diagnosis while the automated health checking helps prevent issues from reaching production.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Beyond milestones 1-4 - This section outlines advanced features that could be added to enhance our container runtime with production-grade security, advanced networking capabilities, and enterprise features.</p>\n</blockquote>\n<h3 id=\"mental-model-construction-site-evolution\">Mental Model: Construction Site Evolution</h3>\n<p>Think of our container runtime like a construction site that starts with basic safety measures and essential tools. We began with fundamental isolation (hard hats and safety barriers), basic resource allocation (power and water connections), simple shelters (basic structures), and basic communication (walkie-talkies). Now we&#39;re ready to add advanced security systems (keycard access, surveillance cameras), sophisticated infrastructure (fiber optic networks, smart building systems), and professional-grade management tools (project management software, quality control systems).</p>\n<p>Just as a construction site evolves from meeting basic safety requirements to implementing enterprise-grade security and management systems, our container runtime can grow from providing fundamental isolation to offering production-ready security policies, advanced networking topologies, and sophisticated operational capabilities. Each enhancement builds upon the solid foundation we&#39;ve established while adding specialized capabilities for different use cases.</p>\n<p>The key insight is that these extensions don&#39;t replace our core components—they enhance and extend them. Our namespace isolation becomes the foundation for advanced security policies. Our basic networking becomes the substrate for complex multi-host topologies. Our simple resource management becomes the basis for sophisticated orchestration integration.</p>\n<h3 id=\"current-foundation-assessment\">Current Foundation Assessment</h3>\n<p>Before exploring future extensions, it&#39;s important to understand what our current implementation provides and where natural extension points exist. Our container runtime has established four core capabilities that serve as extension foundations.</p>\n<p>Our namespace isolation component provides the fundamental security boundary that advanced security policies can build upon. The <code>NamespaceHandle</code> abstraction already supports user namespace UID/GID mapping, which becomes the foundation for capability management and privilege escalation prevention. The mount namespace isolation provides the filesystem access control foundation that security policies like AppArmor and SELinux can leverage.</p>\n<p>The resource control component offers basic memory, CPU, and device limits through cgroups v2, but production environments often need more sophisticated resource policies. Our current <code>ResourceLimits</code> structure and <code>Controller</code> interfaces provide natural extension points for advanced resource management features like priority classes, quality of service guarantees, and dynamic resource allocation.</p>\n<p>Our network management component implements basic bridge networking with port forwarding, providing the foundation for advanced networking features. The <code>Manager</code> component&#39;s abstraction of network operations and the <code>ContainerNetwork</code> state tracking create natural integration points for Container Network Interface (CNI) plugins and multi-host networking solutions.</p>\n<p>The container lifecycle management in our <code>RuntimeManager</code> provides orchestration integration points. The <code>ContainerSpec</code> and <code>ContainerState</code> data model can be extended to support additional metadata, labels, and configuration options that orchestration systems require.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Extension points should be designed into the original architecture, not bolted on afterwards. Our component-based architecture with clear interfaces makes it easier to add new capabilities without disrupting existing functionality.</p>\n</blockquote>\n<h3 id=\"security-enhancements\">Security Enhancements</h3>\n<p>Production container runtimes require multiple layers of security beyond basic namespace isolation. Advanced security features provide defense in depth, ensuring that even if one security boundary is compromised, additional protections remain in place.</p>\n<h4 id=\"mental-model-multi-layer-security-castle\">Mental Model: Multi-Layer Security Castle</h4>\n<p>Think of container security like a medieval castle with multiple defensive layers. Our current namespace isolation is like the outer wall—it keeps most threats out, but sophisticated attackers might find ways over or through it. Advanced security features add additional defensive layers: the moat (seccomp filters blocking dangerous system calls), the gatehouse (capability management controlling what actions are allowed), and the inner keep (AppArmor/SELinux policies providing fine-grained access control).</p>\n<p>Each security layer operates independently but works together to provide comprehensive protection. If an attacker bypasses the namespace isolation (outer wall), they still face seccomp filters (moat) that prevent dangerous system calls. If they somehow execute restricted system calls, capability restrictions (gatehouse) limit what damage they can cause. Even if they gain elevated privileges, mandatory access control policies (inner keep) restrict what resources they can access.</p>\n<h4 id=\"seccomp-filter-integration\">Seccomp Filter Integration</h4>\n<p>Secure Computing Mode (seccomp) filters provide system call level security by restricting which kernel interfaces containerized processes can access. This addresses a fundamental limitation of namespace isolation—while namespaces control what resources a process can see, they don&#39;t restrict which system calls the process can make.</p>\n<p>Our current <code>NamespaceConfig</code> structure provides a natural extension point for seccomp integration. We can add seccomp profile configuration alongside existing namespace settings:</p>\n<table>\n<thead>\n<tr>\n<th>Extension Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SeccompProfile</code></td>\n<td><code>string</code></td>\n<td>Path to seccomp BPF profile or predefined profile name</td>\n</tr>\n<tr>\n<td><code>SeccompMode</code></td>\n<td><code>SeccompMode</code></td>\n<td>Filter mode: disabled, strict, filter, or custom</td>\n</tr>\n<tr>\n<td><code>AllowedSyscalls</code></td>\n<td><code>[]string</code></td>\n<td>Explicit whitelist of permitted system calls</td>\n</tr>\n<tr>\n<td><code>BlockedSyscalls</code></td>\n<td><code>[]string</code></td>\n<td>Explicit blacklist of dangerous system calls</td>\n</tr>\n<tr>\n<td><code>SeccompNotification</code></td>\n<td><code>bool</code></td>\n<td>Enable seccomp user notification for advanced filtering</td>\n</tr>\n</tbody></table>\n<p>The implementation would extend our namespace creation process to apply seccomp filters before executing the container process. The filter installation must happen after namespace creation but before the container process starts, ensuring the restrictions apply to the containerized process and its children.</p>\n<p>A sophisticated seccomp implementation would support multiple profile types. Default profiles provide reasonable security for common use cases—web servers, databases, batch jobs—while custom profiles allow fine-tuned control for specialized applications. Profile composition enables combining multiple partial profiles, such as a base container profile plus application-specific additions.</p>\n<blockquote>\n<p><strong>Decision: Seccomp Profile Management Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Seccomp filters require careful balance between security and application compatibility</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Hard-coded restrictive filters for maximum security</li>\n<li>Fully permissive mode for maximum compatibility  </li>\n<li>Configurable profiles with sensible defaults</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Configurable profiles with curated defaults for common application types</li>\n<li><strong>Rationale</strong>: Provides security benefits while maintaining usability; defaults protect against common attack vectors while custom profiles enable specialized applications</li>\n<li><strong>Consequences</strong>: Requires maintaining profile library and documentation; adds configuration complexity but provides flexible security model</li>\n</ul>\n</blockquote>\n<h4 id=\"capability-management-system\">Capability Management System</h4>\n<p>Linux capabilities provide fine-grained privilege control by breaking down root privileges into discrete capabilities that can be individually granted or restricted. Our container runtime can integrate capability management to implement the principle of least privilege.</p>\n<p>The capability system would extend our <code>NamespaceConfig</code> with capability configuration:</p>\n<table>\n<thead>\n<tr>\n<th>Capability Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AllowedCapabilities</code></td>\n<td><code>[]string</code></td>\n<td>Capabilities container processes can use</td>\n</tr>\n<tr>\n<td><code>DroppedCapabilities</code></td>\n<td><code>[]string</code></td>\n<td>Capabilities explicitly removed from container</td>\n</tr>\n<tr>\n<td><code>AmbientCapabilities</code></td>\n<td><code>[]string</code></td>\n<td>Capabilities inherited by child processes</td>\n</tr>\n<tr>\n<td><code>BoundingSet</code></td>\n<td><code>[]string</code></td>\n<td>Maximum capabilities container can ever acquire</td>\n</tr>\n<tr>\n<td><code>NoNewPrivileges</code></td>\n<td><code>bool</code></td>\n<td>Prevent privilege escalation via execve</td>\n</tr>\n</tbody></table>\n<p>The implementation would manage capability sets during process creation, using the <code>cap_set_proc()</code> interface to configure process capabilities before executing the container command. This requires careful handling of capability inheritance and the interaction between user namespaces and capabilities.</p>\n<p>Advanced capability management includes capability-aware process execution, ensuring that capabilities are properly dropped when switching to non-root users within the container. The system should also support capability audit logging, tracking when processes attempt to use specific capabilities for security monitoring.</p>\n<h4 id=\"apparmor-and-selinux-integration\">AppArmor and SELinux Integration</h4>\n<p>Mandatory Access Control (MAC) systems like AppArmor and SELinux provide policy-based security that restricts resource access regardless of traditional Unix permissions. Integration with these systems adds another security layer beyond namespace isolation and capability restrictions.</p>\n<p>MAC integration extends container configuration with policy specification:</p>\n<table>\n<thead>\n<tr>\n<th>MAC Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AppArmorProfile</code></td>\n<td><code>string</code></td>\n<td>AppArmor profile name or path for container processes</td>\n</tr>\n<tr>\n<td><code>SELinuxLabel</code></td>\n<td><code>string</code></td>\n<td>SELinux security context for container processes</td>\n</tr>\n<tr>\n<td><code>SELinuxType</code></td>\n<td><code>string</code></td>\n<td>SELinux type enforcement domain</td>\n</tr>\n<tr>\n<td><code>SELinuxUser</code></td>\n<td><code>string</code></td>\n<td>SELinux user identity</td>\n</tr>\n<tr>\n<td><code>SELinuxRole</code></td>\n<td><code>string</code></td>\n<td>SELinux role for process context</td>\n</tr>\n<tr>\n<td><code>MACEnforcement</code></td>\n<td><code>MACMode</code></td>\n<td>MAC enforcement level: disabled, permissive, enforcing</td>\n</tr>\n</tbody></table>\n<p>The implementation requires platform-specific integration with MAC systems. On AppArmor systems, this involves loading profiles and applying them to container processes using <code>aa_change_profile()</code>. On SELinux systems, it requires setting security contexts using <code>setexeccon()</code> before process execution.</p>\n<p>MAC policy management becomes a significant operational concern. The runtime should support policy loading, validation, and fallback mechanisms when specified policies are unavailable. Integration with policy development tools helps administrators create and maintain custom policies for containerized applications.</p>\n<blockquote>\n<p><strong>Architecture Decision: MAC System Integration Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Different Linux distributions use different MAC systems (AppArmor on Ubuntu/SUSE, SELinux on RHEL/CentOS)</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Support only one MAC system to reduce complexity</li>\n<li>Runtime detection and automatic MAC system selection</li>\n<li>Plugin-based architecture supporting multiple MAC systems</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Plugin-based MAC integration with runtime detection</li>\n<li><strong>Rationale</strong>: Provides maximum compatibility across distributions; plugin architecture allows adding new MAC systems; runtime detection reduces configuration burden</li>\n<li><strong>Consequences</strong>: Adds architectural complexity but enables broad deployment; requires maintaining multiple MAC integrations</li>\n</ul>\n</blockquote>\n<h4 id=\"security-policy-composition\">Security Policy Composition</h4>\n<p>Advanced security requires combining multiple security mechanisms into coherent policies. A security policy composition system would allow administrators to define security profiles that automatically configure seccomp filters, capabilities, and MAC policies together.</p>\n<p>Security profiles provide named collections of security settings:</p>\n<table>\n<thead>\n<tr>\n<th>Profile Component</th>\n<th>Configuration Scope</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Seccomp Rules</td>\n<td>System call restrictions</td>\n<td>Applied during process creation</td>\n</tr>\n<tr>\n<td>Capability Sets</td>\n<td>Privilege limitations</td>\n<td>Configured via capability management</td>\n</tr>\n<tr>\n<td>MAC Policies</td>\n<td>Resource access control</td>\n<td>Integrated with AppArmor/SELinux</td>\n</tr>\n<tr>\n<td>Namespace Options</td>\n<td>Isolation boundaries</td>\n<td>Extended namespace configuration</td>\n</tr>\n<tr>\n<td>Resource Quotas</td>\n<td>Security-related limits</td>\n<td>Enhanced resource control</td>\n</tr>\n</tbody></table>\n<p>Profile composition enables security policy inheritance and customization. Base profiles provide security foundations for broad categories (web applications, databases, batch processing), while override mechanisms allow application-specific customizations without duplicating common security settings.</p>\n<p>The implementation would extend our <code>ContainerSpec</code> to reference security profiles:</p>\n<table>\n<thead>\n<tr>\n<th>Security Extension</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SecurityProfile</code></td>\n<td><code>string</code></td>\n<td>Named security profile to apply</td>\n</tr>\n<tr>\n<td><code>SecurityOverrides</code></td>\n<td><code>SecurityConfig</code></td>\n<td>Specific overrides to profile defaults</td>\n</tr>\n<tr>\n<td><code>SecurityAudit</code></td>\n<td><code>bool</code></td>\n<td>Enable security event logging and monitoring</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-networking-features\">Advanced Networking Features</h3>\n<p>Production container deployments require sophisticated networking capabilities beyond basic bridge networking. Advanced networking features enable complex topologies, multi-host communication, and integration with orchestration systems.</p>\n<h4 id=\"mental-model-metropolitan-transportation-network\">Mental Model: Metropolitan Transportation Network</h4>\n<p>Think of advanced container networking like evolving from a simple company shuttle system to a metropolitan transportation network. Our current bridge networking is like shuttle buses connecting different buildings on a campus—it works well for local communication but doesn&#39;t scale to citywide transportation needs.</p>\n<p>Advanced networking features are like adding subway systems (overlay networks for multi-host communication), express highways (high-performance networking), traffic management systems (network policies and quality of service), and integrated payment systems (Container Network Interface compatibility for orchestration integration).</p>\n<p>Each networking enhancement serves different transportation needs while integrating with the overall network infrastructure. Multi-host networking provides the backbone for distributed communication, network policies manage traffic flow and security, and CNI integration enables interoperability with orchestration systems.</p>\n<h4 id=\"multi-host-networking-implementation\">Multi-Host Networking Implementation</h4>\n<p>Multi-host networking enables containers running on different physical hosts to communicate as if they were on the same local network. This requires overlay networking technologies that encapsulate container traffic for transmission across the underlying network infrastructure.</p>\n<p>The multi-host networking extension would add overlay network management to our <code>NetworkConfig</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Multi-Host Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>OverlayDriver</code></td>\n<td><code>string</code></td>\n<td>Overlay network implementation: VXLAN, Geneve, IPSec</td>\n</tr>\n<tr>\n<td><code>ClusterSubnet</code></td>\n<td><code>string</code></td>\n<td>CIDR block for cross-host container networking</td>\n</tr>\n<tr>\n<td><code>OverlayInterface</code></td>\n<td><code>string</code></td>\n<td>Host interface for overlay network traffic</td>\n</tr>\n<tr>\n<td><code>EncryptionEnabled</code></td>\n<td><code>bool</code></td>\n<td>Enable overlay traffic encryption</td>\n</tr>\n<tr>\n<td><code>MTUSize</code></td>\n<td><code>int</code></td>\n<td>Maximum transmission unit for overlay packets</td>\n</tr>\n<tr>\n<td><code>MulticastEnabled</code></td>\n<td><code>bool</code></td>\n<td>Enable multicast for service discovery</td>\n</tr>\n</tbody></table>\n<p>VXLAN (Virtual Extensible LAN) provides the most common overlay implementation. It encapsulates layer-2 Ethernet frames within UDP packets, allowing container traffic to traverse layer-3 networks. The implementation requires creating VXLAN interfaces, configuring bridge forwarding tables, and managing overlay network membership.</p>\n<p>Advanced overlay networking includes distributed route management, where each host maintains routing information for containers on other hosts. This can be implemented through static configuration, dynamic protocols like BGP, or integration with service discovery systems like etcd or Consul.</p>\n<p>Network address translation becomes more complex in multi-host environments. East-west traffic (container-to-container across hosts) uses overlay routing, while north-south traffic (external-to-container) requires careful NAT rule coordination to avoid conflicts between hosts.</p>\n<h4 id=\"container-network-interface-cni-integration\">Container Network Interface (CNI) Integration</h4>\n<p>Container Network Interface (CNI) provides a standardized plugin architecture for container networking, enabling integration with Kubernetes and other orchestration systems. CNI integration transforms our container runtime from a standalone system into an orchestration-compatible component.</p>\n<p>CNI integration extends our network management with plugin support:</p>\n<table>\n<thead>\n<tr>\n<th>CNI Extension</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CNIConfigPath</code></td>\n<td><code>string</code></td>\n<td>Directory containing CNI plugin configurations</td>\n</tr>\n<tr>\n<td><code>CNIPluginPath</code></td>\n<td><code>string</code></td>\n<td>Directory containing CNI plugin binaries</td>\n</tr>\n<tr>\n<td><code>CNINetworkName</code></td>\n<td><code>string</code></td>\n<td>Default network configuration to use</td>\n</tr>\n<tr>\n<td><code>CNICacheDir</code></td>\n<td><code>string</code></td>\n<td>Directory for CNI plugin state and caching</td>\n</tr>\n<tr>\n<td><code>CNIArgs</code></td>\n<td><code>map[string]string</code></td>\n<td>Additional arguments passed to CNI plugins</td>\n</tr>\n</tbody></table>\n<p>The implementation replaces our direct network management with CNI plugin execution. Instead of creating veth pairs and bridge configurations directly, the runtime executes CNI plugins that handle network setup according to standardized interfaces.</p>\n<p>CNI plugin lifecycle follows the ADD/DEL pattern. During container creation, the runtime calls the CNI plugin ADD command with container information and network configuration. The plugin creates network interfaces, assigns IP addresses, and configures routing according to its implementation. During container removal, the DEL command cleans up network resources.</p>\n<p>Advanced CNI integration supports plugin chaining, where multiple CNI plugins collaborate to provide complete networking functionality. For example, a bridge plugin creates basic connectivity while a firewall plugin adds security rules and a monitoring plugin adds traffic statistics.</p>\n<blockquote>\n<p><strong>Decision: CNI Integration Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: CNI provides standardized networking but adds complexity compared to direct implementation</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Replace all networking with CNI plugins</li>\n<li>Support CNI as optional alternative to built-in networking</li>\n<li>Implement CNI-compatible plugins wrapping our existing networking</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Support CNI as configurable alternative with built-in networking as fallback</li>\n<li><strong>Rationale</strong>: Provides orchestration compatibility while maintaining simplicity for standalone use; CNI plugins handle complex networking scenarios our built-in implementation can&#39;t support</li>\n<li><strong>Consequences</strong>: Increases testing complexity but enables Kubernetes integration; requires maintaining both networking paths</li>\n</ul>\n</blockquote>\n<h4 id=\"network-policy-enforcement\">Network Policy Enforcement</h4>\n<p>Network policies provide declarative security and traffic management for container networking. They define which containers can communicate with each other and what external resources containers can access.</p>\n<p>Network policy implementation extends our networking with policy specification:</p>\n<table>\n<thead>\n<tr>\n<th>Policy Component</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NetworkPolicies</code></td>\n<td><code>[]NetworkPolicy</code></td>\n<td>List of policies applied to container</td>\n</tr>\n<tr>\n<td><code>DefaultPolicy</code></td>\n<td><code>PolicyAction</code></td>\n<td>Default action for non-matching traffic</td>\n</tr>\n<tr>\n<td><code>PolicyEnforcement</code></td>\n<td><code>EnforcementMode</code></td>\n<td>Policy enforcement level</td>\n</tr>\n</tbody></table>\n<p>Network policy enforcement requires integration with traffic filtering mechanisms. On Linux systems, this typically means generating iptables rules that implement policy decisions. Advanced implementations use eBPF programs for high-performance packet filtering.</p>\n<p>Policy evaluation becomes complex with multiple policies applying to the same container. The implementation needs conflict resolution mechanisms, policy precedence rules, and efficient policy lookup algorithms for high-throughput environments.</p>\n<h4 id=\"quality-of-service-and-traffic-shaping\">Quality of Service and Traffic Shaping</h4>\n<p>Advanced networking includes Quality of Service (QoS) mechanisms that prioritize traffic and manage bandwidth allocation. This ensures critical container communications receive necessary network resources even under load.</p>\n<p>QoS implementation adds traffic management to container networking:</p>\n<table>\n<thead>\n<tr>\n<th>QoS Component</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>BandwidthLimits</code></td>\n<td><code>BandwidthConfig</code></td>\n<td>Maximum bandwidth for container traffic</td>\n</tr>\n<tr>\n<td><code>TrafficPriority</code></td>\n<td><code>PriorityClass</code></td>\n<td>Traffic prioritization level</td>\n</tr>\n<tr>\n<td><code>QueueDiscipline</code></td>\n<td><code>string</code></td>\n<td>Linux traffic control queuing discipline</td>\n</tr>\n<tr>\n<td><code>RateShaping</code></td>\n<td><code>RateConfig</code></td>\n<td>Traffic shaping parameters</td>\n</tr>\n</tbody></table>\n<p>Implementation uses Linux traffic control (tc) subsystem to configure queuing disciplines, traffic classes, and rate limiting. This requires understanding of network queuing theory and careful configuration to avoid unintended traffic delays.</p>\n<p>Advanced QoS features include adaptive bandwidth allocation, where containers can burst above their guaranteed bandwidth when network capacity is available, and priority-based preemption, where high-priority traffic can temporarily reduce bandwidth available to lower-priority flows.</p>\n<h3 id=\"image-management-and-distribution\">Image Management and Distribution</h3>\n<p>Production container runtimes require sophisticated image management capabilities beyond the basic layer handling we implemented. Image management encompasses image distribution, storage optimization, security scanning, and metadata management.</p>\n<h4 id=\"mental-model-digital-library-system\">Mental Model: Digital Library System</h4>\n<p>Think of advanced image management like evolving from a personal book collection to managing a digital library system. Our current layer management is like having books on shelves—you can find and use them, but there&#39;s no catalog system, no way to share with other libraries, and no way to verify book authenticity.</p>\n<p>Advanced image management adds library infrastructure: catalog systems (image registries with metadata), interlibrary loans (image distribution and sharing), authentication systems (image signing and verification), and storage optimization (deduplication and compression).</p>\n<h4 id=\"container-image-registry-integration\">Container Image Registry Integration</h4>\n<p>Image registry integration enables pulling container images from remote repositories, supporting image distribution workflows common in production environments. This extends our runtime beyond locally available layers to support dynamic image retrieval.</p>\n<p>Registry integration extends our <code>ContainerSpec</code> with remote image support:</p>\n<table>\n<thead>\n<tr>\n<th>Registry Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ImageRegistry</code></td>\n<td><code>string</code></td>\n<td>Registry URL for image retrieval</td>\n</tr>\n<tr>\n<td><code>ImageCredentials</code></td>\n<td><code>RegistryCredentials</code></td>\n<td>Authentication for private registries</td>\n</tr>\n<tr>\n<td><code>ImageTag</code></td>\n<td><code>string</code></td>\n<td>Specific image version or tag</td>\n</tr>\n<tr>\n<td><code>ImageDigest</code></td>\n<td><code>string</code></td>\n<td>Content-addressable image identifier</td>\n</tr>\n<tr>\n<td><code>PullPolicy</code></td>\n<td><code>PullPolicy</code></td>\n<td>When to pull images: Always, IfNotPresent, Never</td>\n</tr>\n</tbody></table>\n<p>Implementation requires supporting Docker Registry HTTP API V2 for image manifest retrieval and layer downloading. This includes handling authentication, layer deduplication, and resumable downloads for large images.</p>\n<p>Advanced registry integration includes image mirroring and caching, where frequently used images are cached locally to reduce registry load and improve startup times. Multi-registry support enables fallback between primary and mirror registries for high availability.</p>\n<h4 id=\"image-security-and-verification\">Image Security and Verification</h4>\n<p>Image security addresses supply chain security by verifying image authenticity and scanning for vulnerabilities. This becomes critical in production environments where compromised images pose significant security risks.</p>\n<p>Image security extends our image handling with verification:</p>\n<table>\n<thead>\n<tr>\n<th>Security Component</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ImageSigning</code></td>\n<td><code>SigningConfig</code></td>\n<td>Image signature verification settings</td>\n</tr>\n<tr>\n<td><code>VulnerabilityScanning</code></td>\n<td><code>ScanConfig</code></td>\n<td>Security vulnerability detection</td>\n</tr>\n<tr>\n<td><code>PolicyEnforcement</code></td>\n<td><code>SecurityPolicy</code></td>\n<td>Image acceptance policies</td>\n</tr>\n<tr>\n<td><code>TrustedRegistries</code></td>\n<td><code>[]string</code></td>\n<td>Whitelist of trusted image sources</td>\n</tr>\n</tbody></table>\n<p>Implementation integrates with image signing systems like Notary or cosign for cryptographic verification of image authenticity. Vulnerability scanning requires integration with security databases and scanning tools to identify known vulnerabilities in image contents.</p>\n<p>Policy enforcement enables organizations to define acceptance criteria for container images, automatically rejecting images that don&#39;t meet security requirements. This includes vulnerability thresholds, signature requirements, and source registry restrictions.</p>\n<h3 id=\"orchestration-integration\">Orchestration Integration</h3>\n<p>Production container runtimes increasingly operate as components within larger orchestration systems. Orchestration integration enables our runtime to participate in cluster management, service discovery, and automated deployment workflows.</p>\n<h4 id=\"mental-model-orchestra-conductor-system\">Mental Model: Orchestra Conductor System</h4>\n<p>Think of orchestration integration like enabling a talented musician to play as part of a symphony orchestra. Our container runtime is like a skilled instrumentalist who can perform solo pieces beautifully, but orchestration integration adds the ability to follow a conductor, coordinate with other musicians, and contribute to complex symphonic performances.</p>\n<p>The runtime learns to respond to orchestration signals (start this container when that service is ready), participate in ensemble coordination (register service endpoints for load balancing), and adapt to the conductor&#39;s tempo (scale up during high demand, scale down during quiet periods).</p>\n<h4 id=\"kubernetes-container-runtime-interface-cri\">Kubernetes Container Runtime Interface (CRI)</h4>\n<p>Container Runtime Interface provides the standard interface between Kubernetes and container runtimes. CRI integration transforms our runtime into a Kubernetes-compatible component that can manage pods and containers under kubelet orchestration.</p>\n<p>CRI implementation requires implementing the RuntimeService and ImageService gRPC interfaces:</p>\n<table>\n<thead>\n<tr>\n<th>CRI Service</th>\n<th>Key Methods</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RuntimeService</code></td>\n<td><code>RunPodSandbox</code>, <code>CreateContainer</code>, <code>StartContainer</code></td>\n<td>Pod and container lifecycle</td>\n</tr>\n<tr>\n<td><code>ImageService</code></td>\n<td><code>PullImage</code>, <code>ListImages</code>, <code>RemoveImage</code></td>\n<td>Image management operations</td>\n</tr>\n<tr>\n<td><code>StreamingService</code></td>\n<td><code>Exec</code>, <code>Attach</code>, <code>PortForward</code></td>\n<td>Interactive container operations</td>\n</tr>\n</tbody></table>\n<p>Implementation challenges include adapting our single-container model to Kubernetes&#39; pod abstraction, where multiple containers share network and storage namespaces. This requires extending our namespace management to support shared namespaces between related containers.</p>\n<p>CRI integration also requires implementing Kubernetes-specific features like pod security contexts, resource quotas, and liveness/readiness probes. These extend our basic container capabilities with orchestration-aware functionality.</p>\n<h4 id=\"service-mesh-integration\">Service Mesh Integration</h4>\n<p>Service mesh architectures require container runtimes to support sidecar injection, traffic interception, and service identity management. Integration enables our runtime to participate in sophisticated microservices architectures.</p>\n<p>Service mesh support extends container networking with mesh capabilities:</p>\n<table>\n<thead>\n<tr>\n<th>Mesh Component</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SidecarInjection</code></td>\n<td><code>bool</code></td>\n<td>Automatic sidecar proxy injection</td>\n</tr>\n<tr>\n<td><code>TrafficInterception</code></td>\n<td><code>InterceptConfig</code></td>\n<td>Traffic redirection configuration</td>\n</tr>\n<tr>\n<td><code>ServiceIdentity</code></td>\n<td><code>IdentityConfig</code></td>\n<td>Service authentication and authorization</td>\n</tr>\n<tr>\n<td><code>MeshConfiguration</code></td>\n<td><code>MeshConfig</code></td>\n<td>Service mesh integration settings</td>\n</tr>\n</tbody></table>\n<p>Implementation requires coordinating with service mesh control planes for configuration distribution and telemetry collection. This includes supporting init containers for traffic redirection setup and managing certificate distribution for mutual TLS authentication.</p>\n<h3 id=\"storage-and-volume-management\">Storage and Volume Management</h3>\n<p>Advanced storage features extend our basic filesystem layering with persistent volumes, dynamic provisioning, and storage optimization capabilities.</p>\n<h4 id=\"persistent-volume-integration\">Persistent Volume Integration</h4>\n<p>Persistent volumes enable containers to access storage that survives container lifecycle events. This requires extending our filesystem management beyond container-scoped overlay filesystems.</p>\n<p>Volume integration extends <code>ContainerSpec</code> with storage specification:</p>\n<table>\n<thead>\n<tr>\n<th>Volume Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Volumes</code></td>\n<td><code>[]VolumeMount</code></td>\n<td>List of volumes to mount in container</td>\n</tr>\n<tr>\n<td><code>VolumeDrivers</code></td>\n<td><code>map[string]VolumeDriver</code></td>\n<td>Storage driver implementations</td>\n</tr>\n<tr>\n<td><code>StorageClasses</code></td>\n<td><code>[]StorageClass</code></td>\n<td>Available storage types and policies</td>\n</tr>\n</tbody></table>\n<p>Implementation requires supporting multiple volume types: host path mounts for simple local storage, network file systems for shared storage, and cloud provider storage APIs for dynamic provisioning.</p>\n<h4 id=\"storage-optimization\">Storage Optimization</h4>\n<p>Storage optimization includes features like image layer deduplication, compression, and content-addressable storage that reduce storage overhead and improve performance.</p>\n<p>Advanced storage features include snapshot support for volume backup and restoration, encryption for sensitive data protection, and storage quotas for multi-tenant environments.</p>\n<h3 id=\"common-pitfalls-in-advanced-extensions\">Common Pitfalls in Advanced Extensions</h3>\n<p>⚠️ <strong>Pitfall: Feature Creep Without Architecture Planning</strong>\nAdding advanced features without considering their architectural impact leads to tightly coupled, difficult-to-maintain systems. Each extension should have clear interfaces and minimal dependencies on other components. Plan extension points during initial design rather than retrofitting them later.</p>\n<p>⚠️ <strong>Pitfall: Security Feature Interference</strong> \nMultiple security mechanisms can interfere with each other if not carefully coordinated. Seccomp filters might block system calls that AppArmor policies expect to audit. User namespace UID mapping might conflict with capability management. Design security feature integration holistically rather than adding each mechanism independently.</p>\n<p>⚠️ <strong>Pitfall: CNI Plugin Compatibility Assumptions</strong>\nAssuming all CNI plugins behave consistently leads to runtime errors in diverse environments. Different CNI plugins have different requirements for network namespace setup, interface naming, and cleanup behavior. Test with multiple CNI plugins and handle plugin-specific quirks gracefully.</p>\n<p>⚠️ <strong>Pitfall: Performance Impact of Advanced Features</strong>\nAdvanced features often add performance overhead that may not be acceptable in all environments. Image scanning delays container startup. Network policies add packet processing overhead. QoS traffic shaping adds latency. Make advanced features configurable and provide performance monitoring to quantify their impact.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Seccomp Integration</td>\n<td>Static JSON profiles</td>\n<td>eBPF-based dynamic filtering</td>\n</tr>\n<tr>\n<td>MAC System Support</td>\n<td>Single system (AppArmor or SELinux)</td>\n<td>Runtime detection with plugin architecture</td>\n</tr>\n<tr>\n<td>CNI Implementation</td>\n<td>Execute CNI binaries directly</td>\n<td>CNI library integration with caching</td>\n</tr>\n<tr>\n<td>Image Registry</td>\n<td>HTTP client with basic auth</td>\n<td>Full OCI distribution spec support</td>\n</tr>\n<tr>\n<td>Orchestration</td>\n<td>Simple webhook API</td>\n<td>Full CRI gRPC implementation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/extensions/\n    security/\n      seccomp/\n        profiles.go         ← seccomp profile management\n        filters.go          ← BPF filter installation\n      capabilities/\n        manager.go          ← capability set management\n      mac/\n        apparmor.go         ← AppArmor integration\n        selinux.go          ← SELinux integration\n        interface.go        ← MAC system abstraction\n    networking/\n      cni/\n        plugin_manager.go   ← CNI plugin execution\n        config_parser.go    ← CNI configuration handling\n      overlay/\n        vxlan.go           ← VXLAN overlay implementation\n        routing.go         ← Overlay route management\n      policy/\n        enforcer.go        ← Network policy enforcement\n        iptables.go        ← iptables rule management\n    storage/\n      registry/\n        client.go          ← Registry API client\n        auth.go            ← Registry authentication\n      volumes/\n        manager.go         ← Volume lifecycle management\n        drivers/\n          hostpath.go      ← Host path volume driver\n          nfs.go           ← NFS volume driver\n    orchestration/\n      cri/\n        runtime_service.go ← CRI RuntimeService implementation\n        image_service.go   ← CRI ImageService implementation\n      mesh/\n        sidecar.go         ← Service mesh sidecar management</code></pre></div>\n\n<h4 id=\"security-extension-starter-code\">Security Extension Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package security provides advanced security features for container runtime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> security</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">syscall</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">unsafe</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecurityManager coordinates multiple security mechanisms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecurityManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    seccompEnabled    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    capabilityEnabled </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    macEnabled        </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    profiles         </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecurityProfile</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SecurityProfile defines a complete security configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SecurityProfile</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name               </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SeccompProfile     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AllowedCapabilities []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DroppedCapabilities []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AppArmorProfile    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SELinuxLabel       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewSecurityManager creates a security manager with system detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSecurityManager</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecurityManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SecurityManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        seccompEnabled:    </span><span style=\"color:#B392F0\">detectSeccompSupport</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        capabilityEnabled: </span><span style=\"color:#B392F0\">detectCapabilitySupport</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        macEnabled:       </span><span style=\"color:#B392F0\">detectMACSupport</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        profiles:         </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecurityProfile</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ApplySecurityProfile applies all security mechanisms from profile</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SecurityManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ApplySecurityProfile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">profile</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">SecurityProfile</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate security profile completeness and compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply seccomp filters using prctl(PR_SET_SECCOMP) if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure process capabilities using cap_set_proc if enabled  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set MAC security context (AppArmor or SELinux) if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Enable no_new_privs to prevent privilege escalation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Record applied security settings for audit and debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SeccompFilterManager handles seccomp BPF filter installation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SeccompFilterManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    profileDir </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InstallSeccompFilter loads and installs BPF seccomp filter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sfm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SeccompFilterManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InstallSeccompFilter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">profilePath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load seccomp profile from JSON file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compile syscall names to architecture-specific numbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate BPF program from syscall allow/deny rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Install BPF filter using prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify filter installation and test with sample syscalls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"cni-integration-starter-code\">CNI Integration Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package cni provides Container Network Interface integration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cni</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os/exec</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CNIManager handles CNI plugin execution and state management  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CNIManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configPath  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pluginPath  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cacheDir    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networks    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CNIConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CNIConfig represents a CNI network configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CNIConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CNIVersion </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"cniVersion\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Bridge     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"bridge,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAM       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"ipam,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DNS        </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"dns,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CNIResult represents the result of CNI plugin execution</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CNIResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CNIVersion </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"cniVersion\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Interfaces []</span><span style=\"color:#B392F0\">Interface</span><span style=\"color:#9ECBFF\"> `json:\"interfaces\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPs        []</span><span style=\"color:#B392F0\">IPConfig</span><span style=\"color:#9ECBFF\">  `json:\"ips\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Routes     []</span><span style=\"color:#B392F0\">Route</span><span style=\"color:#9ECBFF\">     `json:\"routes\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DNS        </span><span style=\"color:#B392F0\">DNSConfig</span><span style=\"color:#9ECBFF\">   `json:\"dns\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCNIManager creates CNI manager with configuration discovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCNIManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">configPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">pluginPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cacheDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CNIManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CNIManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        configPath: configPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pluginPath: pluginPath, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cacheDir:   cacheDir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        networks:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CNIConfig</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupContainerNetwork executes CNI ADD command for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CNIManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">networkName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">netnsPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CNIResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load CNI configuration from configPath directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Find CNI plugin binary in pluginPath directory  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Prepare CNI environment variables (CNI_COMMAND=ADD, CNI_CONTAINERID, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute CNI plugin with configuration JSON on stdin</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Parse CNI result JSON from plugin stdout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Cache network state in cacheDir for cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CleanupContainerNetwork executes CNI DEL command for container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CNIManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CleanupContainerNetwork</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">containerID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">networkName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load cached network state from cacheDir</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Prepare CNI environment variables (CNI_COMMAND=DEL)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Execute CNI plugin DEL command with original configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Remove cached network state from cacheDir</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle plugin errors gracefully (plugin may be missing)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"orchestration-integration-core-types\">Orchestration Integration Core Types</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package orchestration provides integration with container orchestration systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> orchestration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">google.golang.org/grpc</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pb </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/cri-api/pkg/apis/runtime/v1alpha2</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CRIRuntimeService implements Kubernetes Container Runtime Interface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CRIRuntimeService</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    pb</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">UnimplementedRuntimeServiceServer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    containerManager </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ContainerManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    podManager      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PodManager</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    imageManager    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImageManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PodSandboxConfig extends our container model for Kubernetes pods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PodSandboxConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PodID         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name          </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Namespace     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SharedNetNS   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SharedIPCNS   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SharedPIDNS   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Annotations   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Labels        </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunPodSandbox creates the pod infrastructure container</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cri </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CRIRuntimeService</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RunPodSandbox</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">pb</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RunPodSandboxRequest</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">pb</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RunPodSandboxResponse</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse pod sandbox configuration from request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create shared namespaces for pod (network, IPC, PID if configured)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set up pod-level networking using CNI or built-in networking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create pod sandbox container to hold namespaces  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Apply pod-level security policies and resource limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Register pod sandbox in pod manager state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateContainer creates container within existing pod sandbox</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cri </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CRIRuntimeService</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateContainer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">pb</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CreateContainerRequest</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">pb</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CreateContainerResponse</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate pod sandbox exists and is running</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Join container to pod's shared namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply container-specific resource limits and security policies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set up container filesystem with image layers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create container using our existing container creation logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Register container in CRI state tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p><strong>Security Enhancement Checkpoint:</strong></p>\n<ul>\n<li>Test seccomp filter installation: <code>sudo strace -e trace=prctl ./container-runtime run --seccomp=restrictive test-container</code></li>\n<li>Verify capability dropping: Container should fail to execute <code>ping</code> with network capabilities dropped</li>\n<li>Check MAC policy application: <code>ps -eZ | grep container-process</code> should show correct SELinux context</li>\n</ul>\n<p><strong>CNI Integration Checkpoint:</strong>  </p>\n<ul>\n<li>Install basic CNI plugins: <code>bridge</code> and <code>host-local</code> IPAM</li>\n<li>Test CNI network setup: <code>./container-runtime run --network=cni test-container</code> </li>\n<li>Verify connectivity: Container should get IP from CNI IPAM and reach other containers</li>\n</ul>\n<p><strong>Advanced Networking Checkpoint:</strong></p>\n<ul>\n<li>Set up multi-host overlay: Deploy containers on different hosts, verify cross-host connectivity</li>\n<li>Test network policies: Create policy blocking container communication, verify enforcement</li>\n<li>Validate QoS: Apply bandwidth limits, verify traffic shaping with <code>iperf3</code></li>\n</ul>\n<h4 id=\"extension-debugging-tips\">Extension Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Seccomp filter blocks required syscalls</td>\n<td>Overly restrictive profile</td>\n<td><code>strace</code> container process, check for <code>EPERM</code> errors</td>\n<td>Add required syscalls to profile whitelist</td>\n</tr>\n<tr>\n<td>CNI plugin execution fails</td>\n<td>Missing plugin binary or configuration</td>\n<td>Check plugin exists in CNI_PATH, validate config JSON</td>\n<td>Install plugin, fix configuration syntax</td>\n</tr>\n<tr>\n<td>Container can&#39;t join pod network</td>\n<td>Pod sandbox networking setup failed</td>\n<td>Check pod sandbox status, inspect network namespaces</td>\n<td>Debug CNI plugin execution, check bridge config</td>\n</tr>\n<tr>\n<td>MAC policy denials</td>\n<td>Incorrect security context</td>\n<td>Check <code>ausearch -m AVC</code> for SELinux denials</td>\n<td>Update security policy or container context</td>\n</tr>\n<tr>\n<td>Multi-host networking broken</td>\n<td>Overlay network misconfiguration</td>\n<td>Check VXLAN interface status, validate routing</td>\n<td>Verify overlay network setup, check firewall rules</td>\n</tr>\n</tbody></table>\n<p>These extensions transform our educational container runtime into a production-capable system while maintaining the clean architecture and clear component boundaries we established in the core implementation.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - This glossary provides comprehensive definitions for container runtime terminology, Linux kernel concepts, and system administration terms used throughout all sections, helping readers understand the technical vocabulary essential for implementing process isolation, resource control, filesystem layering, and container networking.</p>\n</blockquote>\n<p>This glossary serves as a comprehensive reference for all technical terms, concepts, and terminology used throughout the container runtime design document. Understanding these definitions is crucial for successfully implementing the four milestones of our container runtime project.</p>\n<h3 id=\"mental-model-technical-dictionary-as-navigation-map\">Mental Model: Technical Dictionary as Navigation Map</h3>\n<p>Think of this glossary as a navigation map for exploring a new technical territory. Just as a map helps you understand the landscape by defining landmarks, terrain features, and pathways, this glossary defines the technical landmarks (Linux kernel features), terrain features (system resources and isolation mechanisms), and pathways (APIs and interfaces) you&#39;ll encounter while building your container runtime. Each definition provides not just the meaning, but the context of how that concept fits into the larger ecosystem of containerization technology.</p>\n<h3 id=\"container-runtime-core-concepts\">Container Runtime Core Concepts</h3>\n<p>The foundation of container technology rests on several key concepts that work together to create isolated execution environments.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>container runtime</td>\n<td>System Component</td>\n<td>A system that manages the complete lifecycle of containers, including creation, execution, monitoring, and cleanup. Responsible for orchestrating Linux kernel features like namespaces, cgroups, and overlay filesystems to provide process isolation and resource control. Examples include Docker Engine, containerd, and our custom implementation.</td>\n</tr>\n<tr>\n<td>container specification</td>\n<td>Data Structure</td>\n<td>A declarative blueprint defining how a container should be configured, including the image to run, resource limits, network settings, environment variables, and command to execute. Represented by the <code>ContainerSpec</code> structure with fields for image, command, resources, and networking configuration.</td>\n</tr>\n<tr>\n<td>runtime state</td>\n<td>Data Structure</td>\n<td>The current operational status and resource tracking information for an active container. Includes process ID, namespace handles, cgroup paths, network configuration, and lifecycle timestamps. Maintained by the <code>StateManager</code> component for persistence across runtime restarts.</td>\n</tr>\n<tr>\n<td>container lifecycle</td>\n<td>State Machine</td>\n<td>The progression of a container through distinct states: Created (resources allocated but process not started), Running (process executing), Stopped (process terminated but resources preserved), and Removed (all resources cleaned up). Each transition involves specific setup or cleanup operations.</td>\n</tr>\n<tr>\n<td>process isolation</td>\n<td>Isolation Mechanism</td>\n<td>The fundamental container property where processes inside a container have a restricted view of system resources, seeing only what they&#39;re permitted to access. Achieved through Linux namespaces that create separate views of PIDs, filesystems, network interfaces, and other system resources.</td>\n</tr>\n<tr>\n<td>resource limits</td>\n<td>Control Mechanism</td>\n<td>Constraints enforced by the Linux kernel to prevent containers from consuming unlimited system resources. Implemented using cgroups to limit memory, CPU time, I/O bandwidth, and process count. Essential for multi-tenant systems and preventing resource exhaustion.</td>\n</tr>\n</tbody></table>\n<h3 id=\"linux-kernel-features\">Linux Kernel Features</h3>\n<p>Our container runtime builds upon several advanced Linux kernel features that provide the foundation for containerization.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>namespace</td>\n<td>Kernel Feature</td>\n<td>A Linux kernel feature that provides process isolation by creating separate instances of global system resources. Each namespace type isolates a different category of resources (PIDs, filesystems, network interfaces, hostnames, users). Processes in different namespaces see different views of the same system.</td>\n</tr>\n<tr>\n<td>cgroup</td>\n<td>Kernel Feature</td>\n<td>A Linux control group mechanism for organizing processes into hierarchical groups and applying resource limits and accounting. Cgroups v2 provides a unified hierarchy with controllers for memory, CPU, I/O, and device access. Essential for preventing containers from monopolizing system resources.</td>\n</tr>\n<tr>\n<td>overlayfs</td>\n<td>Filesystem Type</td>\n<td>A union filesystem implementation in the Linux kernel that efficiently combines multiple directory trees into a single merged view. Supports copy-on-write semantics where changes to files are stored in an upper layer without modifying lower layers. Foundation for container image layering.</td>\n</tr>\n<tr>\n<td>pivot_root</td>\n<td>System Call</td>\n<td>A Linux system call that atomically changes the root filesystem of a process and its children. More secure than <code>chroot</code> because it ensures the old root is unmounted. Used during container startup to switch from the host filesystem to the container&#39;s filesystem view.</td>\n</tr>\n<tr>\n<td>netlink</td>\n<td>Kernel Interface</td>\n<td>A socket-based communication mechanism between the Linux kernel and userspace processes. Used for network configuration operations like creating network interfaces, configuring routes, and managing network namespaces. Provides programmatic access to networking functionality.</td>\n</tr>\n</tbody></table>\n<h3 id=\"namespace-types-and-isolation\">Namespace Types and Isolation</h3>\n<p>Each namespace type provides isolation for a specific category of system resources, creating the illusion of dedicated resources for each container.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>mount namespace</td>\n<td>Namespace Type</td>\n<td>Isolates the filesystem mount points visible to processes, allowing each container to have its own filesystem hierarchy and mount configuration. Created with <code>CLONE_NEWNS</code> flag. Enables containers to have different root filesystems and mount different volumes without affecting the host.</td>\n</tr>\n<tr>\n<td>PID namespace</td>\n<td>Namespace Type</td>\n<td>Isolates the process ID number space, making processes in the namespace see only other processes in the same namespace. The first process in a PID namespace appears as PID 1. Created with <code>CLONE_NEWPID</code> flag. Provides process isolation and enables clean process tree management.</td>\n</tr>\n<tr>\n<td>network namespace</td>\n<td>Namespace Type</td>\n<td>Isolates network interfaces, routing tables, firewall rules, and network statistics. Each network namespace has its own loopback interface and can have its own network interfaces. Created with <code>CLONE_NEWNET</code> flag. Enables containers to have isolated network stacks.</td>\n</tr>\n<tr>\n<td>UTS namespace</td>\n<td>Namespace Type</td>\n<td>Isolates the system hostname and NIS domain name, allowing each container to have its own hostname without affecting the host system. Created with <code>CLONE_NEWUTS</code> flag. Enables containers to identify themselves with unique hostnames.</td>\n</tr>\n<tr>\n<td>user namespace</td>\n<td>Namespace Type</td>\n<td>Isolates user and group ID number spaces and privileges, allowing processes to have different user IDs inside the namespace than outside. Enables unprivileged containers where root inside the container maps to a non-root user outside. Created with <code>CLONE_NEWUSER</code> flag.</td>\n</tr>\n<tr>\n<td>IPC namespace</td>\n<td>Namespace Type</td>\n<td>Isolates System V IPC objects (message queues, semaphores, shared memory segments) and POSIX message queues. Prevents containers from interfering with each other&#39;s inter-process communication. Created with <code>CLONE_NEWIPC</code> flag.</td>\n</tr>\n</tbody></table>\n<h3 id=\"cgroup-resource-control\">Cgroup Resource Control</h3>\n<p>Cgroups provide hierarchical resource management and accounting, essential for fair resource allocation in multi-container environments.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cgroups v2</td>\n<td>Cgroup Version</td>\n<td>The modern unified hierarchy implementation of control groups, replacing the multiple separate hierarchies of cgroups v1. Provides a single tree structure with controllers that can be selectively enabled. Offers improved consistency and easier management for container runtimes.</td>\n</tr>\n<tr>\n<td>memory controller</td>\n<td>Cgroup Controller</td>\n<td>A cgroup subsystem that manages memory allocation, usage tracking, and enforcement of memory limits. Can limit anonymous memory, page cache, and total memory usage. Provides memory pressure notifications and configurable out-of-memory behavior for fine-grained memory management.</td>\n</tr>\n<tr>\n<td>CPU controller</td>\n<td>Cgroup Controller</td>\n<td>A cgroup subsystem that manages CPU time allocation through quotas and weights. Can limit CPU usage to specific percentages and implement fair scheduling policies. Provides both hard limits (quotas) and proportional sharing (weights) for flexible CPU resource management.</td>\n</tr>\n<tr>\n<td>device controller</td>\n<td>Cgroup Controller</td>\n<td>A cgroup subsystem that controls access to device files, determining which devices processes can access and with what permissions (read, write, create). Essential for container security by preventing unauthorized access to host devices.</td>\n</tr>\n<tr>\n<td>OOM killer</td>\n<td>Kernel Mechanism</td>\n<td>The Linux kernel&#39;s out-of-memory killer that terminates processes when memory is exhausted. In containerized environments, can be configured per-cgroup to kill only processes within the offending container rather than affecting the entire system. Critical for system stability under memory pressure.</td>\n</tr>\n<tr>\n<td>memory pressure</td>\n<td>Resource Condition</td>\n<td>A condition where memory usage approaches configured limits, potentially leading to performance degradation or out-of-memory conditions. Cgroups provide pressure stall information (PSI) metrics to detect memory pressure before critical situations occur.</td>\n</tr>\n<tr>\n<td>CPU throttling</td>\n<td>Resource Control</td>\n<td>The process of limiting CPU time allocation when a cgroup exceeds its configured CPU quota. Implemented by the kernel scheduler to enforce CPU limits while maintaining fairness. Can cause performance degradation if limits are set too restrictively.</td>\n</tr>\n<tr>\n<td>resource monitoring</td>\n<td>Monitoring Process</td>\n<td>The continuous tracking of container resource consumption over time, including memory usage, CPU utilization, I/O operations, and process counts. Enables resource trend analysis, capacity planning, and automated scaling decisions based on historical usage patterns.</td>\n</tr>\n<tr>\n<td>cgroup hierarchy</td>\n<td>Organizational Structure</td>\n<td>The tree structure organizing control groups, where child cgroups inherit resource limits from parents and can apply additional restrictions. Enables hierarchical resource management where system resources are allocated first to major subsystems, then subdivided for individual containers.</td>\n</tr>\n</tbody></table>\n<h3 id=\"filesystem-and-storage-concepts\">Filesystem and Storage Concepts</h3>\n<p>Container filesystems use sophisticated layering and copy-on-write mechanisms to efficiently share common data while allowing independent modifications.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>copy-on-write</td>\n<td>Filesystem Optimization</td>\n<td>A storage optimization technique where multiple containers can share the same base files until one container modifies a file, at which point a private copy is created. Reduces storage usage and improves startup time by avoiding unnecessary file duplication.</td>\n</tr>\n<tr>\n<td>layer stacking</td>\n<td>Filesystem Architecture</td>\n<td>The technique of combining multiple read-only filesystem layers with a single writable layer to create a complete filesystem view. Lower layers contain base system files and application dependencies, while the upper layer captures container-specific changes.</td>\n</tr>\n<tr>\n<td>whiteout files</td>\n<td>Filesystem Mechanism</td>\n<td>Special marker files in overlayfs that indicate deleted files in lower layers. When a file is deleted in the upper layer, a whiteout file is created to mask the file&#39;s presence in lower layers. Essential for proper deletion semantics in layered filesystems.</td>\n</tr>\n<tr>\n<td>upper directory</td>\n<td>Filesystem Layer</td>\n<td>The writable layer in an overlay filesystem where all container modifications are stored. Contains new files created by the container and modified versions of files from lower layers. Typically unique per container to ensure isolation.</td>\n</tr>\n<tr>\n<td>lower directories</td>\n<td>Filesystem Layers</td>\n<td>The read-only layers in an overlay filesystem that contain base image content. Multiple lower directories are stacked to create the base filesystem view. Shared between containers using the same base image to minimize storage usage.</td>\n</tr>\n<tr>\n<td>work directory</td>\n<td>Filesystem Component</td>\n<td>A scratch directory used internally by overlayfs for atomic operations during copy-on-write. Must be on the same filesystem as the upper directory and should be empty when mounting. Hidden from container processes but essential for overlay functionality.</td>\n</tr>\n<tr>\n<td>merged view</td>\n<td>Filesystem Abstraction</td>\n<td>The combined filesystem view presented to container processes, showing the result of merging all lower directories with the upper directory. Files in upper layers hide files with the same path in lower layers, creating the illusion of a single unified filesystem.</td>\n</tr>\n<tr>\n<td>layer cleanup</td>\n<td>Maintenance Process</td>\n<td>The process of removing unused filesystem layers and directories when containers are destroyed. Includes unmounting overlay filesystems, removing temporary directories, and updating reference counts for shared layers to prevent storage leaks.</td>\n</tr>\n</tbody></table>\n<h3 id=\"container-networking\">Container Networking</h3>\n<p>Container networking creates isolated network environments while enabling communication between containers and external systems.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>veth pair</td>\n<td>Network Interface</td>\n<td>A virtual ethernet pair consisting of two connected network interfaces that act like opposite ends of a network cable. Traffic sent to one interface is received by the other. Used to connect container network namespaces to host network namespaces or bridges.</td>\n</tr>\n<tr>\n<td>bridge networking</td>\n<td>Network Architecture</td>\n<td>A layer-2 switching mechanism that connects multiple network interfaces, allowing containers to communicate with each other and external networks. Linux bridges forward traffic between connected interfaces based on MAC addresses, similar to physical network switches.</td>\n</tr>\n<tr>\n<td>port forwarding</td>\n<td>Network Translation</td>\n<td>The process of redirecting network traffic from host ports to container ports using network address translation (NAT) rules. Enables external clients to access services running inside containers by mapping host IP:port combinations to container IP:port combinations.</td>\n</tr>\n<tr>\n<td>port mapping</td>\n<td>Configuration Specification</td>\n<td>A configuration that defines how host ports should be forwarded to container ports, specified by the <code>PortMapping</code> structure with host port, container port, and protocol. Essential for making container services accessible from outside the container network.</td>\n</tr>\n<tr>\n<td>DNAT</td>\n<td>Network Translation</td>\n<td>Destination Network Address Translation - a type of NAT that modifies the destination IP address and/or port of packets. Used in container port forwarding to redirect traffic from host interfaces to container interfaces.</td>\n</tr>\n<tr>\n<td>container bridge</td>\n<td>Network Infrastructure</td>\n<td>A virtual network switch that connects container network interfaces, typically named <code>docker0</code> or similar. Provides layer-2 connectivity between containers and can be connected to host interfaces for external access. Central component of container networking architecture.</td>\n</tr>\n<tr>\n<td>IP address pool</td>\n<td>Address Management</td>\n<td>A managed range of IP addresses allocated for container use, typically from private address space (e.g., 172.17.0.0/16). The container runtime assigns unique addresses from this pool to prevent IP conflicts and enable proper routing.</td>\n</tr>\n<tr>\n<td>NAT rules</td>\n<td>Network Configuration</td>\n<td>Network address translation rules configured in the Linux netfilter framework (iptables) to modify packet headers for container networking. Includes DNAT rules for inbound traffic and SNAT rules for outbound traffic from containers.</td>\n</tr>\n</tbody></table>\n<h3 id=\"container-lifecycle-and-operations\">Container Lifecycle and Operations</h3>\n<p>Container operations follow specific patterns and sequences to ensure reliable resource management and cleanup.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>graceful termination</td>\n<td>Shutdown Process</td>\n<td>The process of allowing a container process to shut down cleanly by sending SIGTERM and waiting for the process to exit voluntarily before forcing termination. Gives applications time to save state, close connections, and perform cleanup operations.</td>\n</tr>\n<tr>\n<td>forced removal</td>\n<td>Cleanup Process</td>\n<td>Aggressive container cleanup that bypasses graceful shutdown and immediately removes all container resources. Used when graceful termination fails or times out. May result in data loss or resource leaks if not implemented carefully.</td>\n</tr>\n<tr>\n<td>resource handle</td>\n<td>Abstraction</td>\n<td>A data structure that encapsulates references to created resources (namespaces, cgroups, network interfaces) and provides methods for cleanup. Enables proper resource management and prevents resource leaks when containers are removed.</td>\n</tr>\n<tr>\n<td>operation log</td>\n<td>Persistence Mechanism</td>\n<td>A persistent record of multi-step container operations that tracks which steps have completed successfully. Enables recovery and rollback if operations are interrupted by crashes or failures. Essential for maintaining consistent state across runtime restarts.</td>\n</tr>\n<tr>\n<td>rollback mechanism</td>\n<td>Error Recovery</td>\n<td>The process of cleaning up successfully created resources when a container operation fails partway through. Ensures the system remains in a consistent state and prevents resource leaks when container creation or modification fails.</td>\n</tr>\n<tr>\n<td>component coordination</td>\n<td>Orchestration Pattern</td>\n<td>The process of organizing multiple specialized components (namespace handler, cgroup controller, filesystem manager, network manager) to work together during container operations. Manages dependencies and ensures operations occur in the correct order.</td>\n</tr>\n<tr>\n<td>dependency graph</td>\n<td>Operational Structure</td>\n<td>The ordering requirements between component operations, such as creating network namespaces before configuring network interfaces. Represents which operations must complete before others can begin, enabling parallel execution where possible.</td>\n</tr>\n<tr>\n<td>atomic operations</td>\n<td>Operation Property</td>\n<td>Operations that either complete entirely or have no effect, preventing partial state that could lead to resource leaks or inconsistencies. Critical for container operations that involve multiple kernel resources requiring coordinated setup.</td>\n</tr>\n<tr>\n<td>idempotent cleanup</td>\n<td>Cleanup Property</td>\n<td>Cleanup operations that can be safely repeated multiple times without causing errors or side effects. Essential for reliable resource cleanup in the presence of failures, crashes, or redundant cleanup attempts.</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-recovery\">Error Handling and Recovery</h3>\n<p>Robust container runtimes must handle various failure modes and provide mechanisms for detection and recovery.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>partial failure recovery</td>\n<td>Error Recovery</td>\n<td>The process of handling cases where container creation partially succeeds but some components fail, requiring cleanup of successfully created resources while leaving the system in a consistent state. Prevents resource leaks and orphaned kernel objects.</td>\n</tr>\n<tr>\n<td>resource exhaustion scenarios</td>\n<td>Failure Mode</td>\n<td>Situations where system resources (PIDs, memory, network interfaces, file descriptors) approach or exceed their limits, potentially causing container operations to fail. Requires detection, graceful degradation, and recovery strategies.</td>\n</tr>\n<tr>\n<td>graceful degradation</td>\n<td>Resilience Pattern</td>\n<td>The strategy of reducing functionality when resources are constrained rather than failing completely. For example, reducing container resource limits or disabling non-essential features when system resources are scarce.</td>\n</tr>\n<tr>\n<td>circuit breaker</td>\n<td>Resilience Pattern</td>\n<td>A pattern that prevents retry loops from amplifying failures by temporarily stopping operations when failure rates exceed thresholds. Protects the system from cascading failures and allows time for recovery.</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-validation\">Testing and Validation</h3>\n<p>Comprehensive testing ensures container isolation, resource control, and networking function correctly across various scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>integration testing</td>\n<td>Testing Approach</td>\n<td>Validation of multiple components working together to ensure the complete container runtime functions correctly. Tests end-to-end scenarios like container creation, execution, resource enforcement, and cleanup across all system components.</td>\n</tr>\n<tr>\n<td>milestone checkpoint</td>\n<td>Validation Point</td>\n<td>A verification point after implementing specific functionality, with concrete tests to run and expected behavior to verify progress. Provides incremental validation that each implementation milestone meets its acceptance criteria.</td>\n</tr>\n<tr>\n<td>test environment</td>\n<td>Testing Infrastructure</td>\n<td>An isolated testing setup with cleanup capabilities that provides reproducible conditions for testing container operations. Includes temporary directories, test containers, and automated cleanup to prevent test pollution.</td>\n</tr>\n<tr>\n<td>race condition</td>\n<td>Concurrency Bug</td>\n<td>Timing-dependent bugs in concurrent operations where the outcome depends on the relative timing of events. Common in container runtimes due to parallel resource creation and cleanup operations requiring careful synchronization.</td>\n</tr>\n<tr>\n<td>resource exhaustion</td>\n<td>Testing Scenario</td>\n<td>Test scenarios designed to verify system behavior when resources (memory, PIDs, network interfaces) approach their limits. Ensures the container runtime handles resource pressure gracefully without crashing or corrupting state.</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-diagnostics\">Debugging and Diagnostics</h3>\n<p>Effective debugging techniques are essential for diagnosing issues in the complex interactions between kernel features and container runtime components.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>namespace debugging</td>\n<td>Debugging Technique</td>\n<td>Systematic inspection of Linux namespace configuration and isolation to verify that containers have the expected view of system resources. Includes checking <code>/proc/PID/ns/</code> entries, mount tables, and process visibility.</td>\n</tr>\n<tr>\n<td>cgroup debugging</td>\n<td>Debugging Technique</td>\n<td>Analysis of resource control group setup and enforcement to verify that containers are properly limited and monitored. Includes inspecting cgroup hierarchies, resource usage statistics, and limit enforcement.</td>\n</tr>\n<tr>\n<td>network debugging</td>\n<td>Debugging Technique</td>\n<td>Diagnosis of container networking connectivity and configuration to identify why containers cannot communicate or access external resources. Uses tools like <code>ip</code>, <code>bridge</code>, <code>iptables</code>, and <code>netstat</code> to inspect network state.</td>\n</tr>\n<tr>\n<td>process isolation</td>\n<td>Debugging Focus</td>\n<td>Verification that container processes are properly separated from host processes and can only see other processes in their namespace. Critical for container security and proper resource accounting.</td>\n</tr>\n<tr>\n<td>resource pressure</td>\n<td>Diagnostic Indicator</td>\n<td>Metrics showing when resource usage approaches limits, potentially leading to performance degradation or failures. Includes memory pressure stall information, CPU throttling indicators, and I/O wait times.</td>\n</tr>\n<tr>\n<td>connectivity testing</td>\n<td>Diagnostic Process</td>\n<td>Validation of network paths and communication capabilities to ensure containers can reach required services. Tests both inter-container communication and external network access through various protocols.</td>\n</tr>\n<tr>\n<td>health checking</td>\n<td>Monitoring Process</td>\n<td>Automated validation of container runtime state and configuration to detect problems before they cause failures. Includes checking resource usage trends, network connectivity, and filesystem integrity.</td>\n</tr>\n<tr>\n<td>mount table inspection</td>\n<td>Debugging Technique</td>\n<td>Examination of filesystem mount points visible to containers to verify that the expected filesystems are mounted and accessible. Uses <code>/proc/PID/mounts</code> and <code>/proc/PID/mountinfo</code> to inspect mount state.</td>\n</tr>\n<tr>\n<td>veth pair verification</td>\n<td>Debugging Technique</td>\n<td>Checking that virtual ethernet interface creation and linkage function correctly, ensuring containers have proper network connectivity. Verifies interface creation, namespace assignment, and traffic flow.</td>\n</tr>\n<tr>\n<td>iptables rule analysis</td>\n<td>Debugging Technique</td>\n<td>Inspection of network address translation and firewall rules to verify that port forwarding and traffic filtering work correctly. Essential for diagnosing container network access issues.</td>\n</tr>\n</tbody></table>\n<h3 id=\"security-and-advanced-features\">Security and Advanced Features</h3>\n<p>Advanced container runtimes implement additional security mechanisms and features beyond basic isolation.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>seccomp filters</td>\n<td>Security Mechanism</td>\n<td>System call level security restrictions that limit which system calls container processes can execute. Implemented using Berkeley Packet Filter (BPF) programs loaded into the kernel to intercept and filter system calls.</td>\n</tr>\n<tr>\n<td>mandatory access control</td>\n<td>Security Framework</td>\n<td>Policy-based security mechanisms beyond traditional Unix permissions, including SELinux and AppArmor. Provide additional layers of access control based on security policies rather than just file ownership and permissions.</td>\n</tr>\n<tr>\n<td>capability management</td>\n<td>Security Feature</td>\n<td>Fine-grained privilege control system that divides root privileges into distinct capabilities (e.g., CAP_NET_ADMIN, CAP_SYS_ADMIN). Allows containers to perform specific privileged operations without full root access.</td>\n</tr>\n<tr>\n<td>defense in depth</td>\n<td>Security Strategy</td>\n<td>The approach of implementing multiple independent security layers so that if one layer is compromised, other layers continue to provide protection. Combines namespaces, cgroups, seccomp, capabilities, and MAC for comprehensive security.</td>\n</tr>\n<tr>\n<td>supply chain security</td>\n<td>Security Concern</td>\n<td>Verification of software component authenticity and integrity throughout the development and deployment pipeline. Includes image signing, vulnerability scanning, and provenance tracking for container images.</td>\n</tr>\n</tbody></table>\n<h3 id=\"networking-extensions\">Networking Extensions</h3>\n<p>Advanced networking features enable sophisticated container network topologies and service mesh integration.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>overlay networking</td>\n<td>Network Architecture</td>\n<td>Network virtualization that creates logical networks spanning multiple hosts using encapsulation protocols like VXLAN or GRE. Enables containers on different hosts to communicate as if on the same network segment.</td>\n</tr>\n<tr>\n<td>Container Network Interface</td>\n<td>Standard Interface</td>\n<td>A specification and plugin architecture for configuring network interfaces in containers. Provides a standard way to integrate different networking solutions with container runtimes and orchestrators like Kubernetes.</td>\n</tr>\n<tr>\n<td>network policies</td>\n<td>Security Feature</td>\n<td>Declarative rules that control traffic flow between containers and external endpoints. Implemented at the network level to provide microsegmentation and traffic filtering based on labels, namespaces, and other criteria.</td>\n</tr>\n<tr>\n<td>quality of service</td>\n<td>Network Feature</td>\n<td>Traffic prioritization and bandwidth management mechanisms that ensure critical applications receive adequate network resources. Includes traffic shaping, priority queuing, and bandwidth guarantees.</td>\n</tr>\n<tr>\n<td>service mesh</td>\n<td>Infrastructure Layer</td>\n<td>A dedicated infrastructure layer that handles service-to-service communication, providing features like traffic management, security, and observability. Often implemented using sidecar proxies alongside application containers.</td>\n</tr>\n<tr>\n<td>traffic interception</td>\n<td>Network Feature</td>\n<td>The ability to redirect network traffic through proxies or filters for processing, monitoring, or security scanning. Essential for service mesh implementations and network security appliances.</td>\n</tr>\n</tbody></table>\n<h3 id=\"storage-and-image-management\">Storage and Image Management</h3>\n<p>Container storage systems provide persistent data management and efficient image distribution mechanisms.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>image registry</td>\n<td>Storage System</td>\n<td>A repository for storing and distributing container images, supporting features like authentication, authorization, and content distribution. Examples include Docker Hub, Amazon ECR, and private registry implementations.</td>\n</tr>\n<tr>\n<td>vulnerability scanning</td>\n<td>Security Process</td>\n<td>Automated security analysis of container images to identify known vulnerabilities in installed packages and dependencies. Integrates with image registries and CI/CD pipelines to prevent deployment of vulnerable images.</td>\n</tr>\n<tr>\n<td>persistent volumes</td>\n<td>Storage Abstraction</td>\n<td>Storage that survives container lifecycle events, allowing data to persist across container restarts and migrations. Implemented through volume mounts that connect containers to external storage systems.</td>\n</tr>\n<tr>\n<td>content-addressable storage</td>\n<td>Storage Architecture</td>\n<td>Storage organized by content hash rather than filename, ensuring data integrity and enabling efficient deduplication. Used in container image storage to share common layers between images and detect corruption.</td>\n</tr>\n<tr>\n<td>dynamic provisioning</td>\n<td>Storage Feature</td>\n<td>Automatic storage allocation based on demand rather than pre-allocated storage pools. Enables containers to request storage resources dynamically and have them provisioned from available storage systems.</td>\n</tr>\n</tbody></table>\n<h3 id=\"container-orchestration-interface\">Container Orchestration Interface</h3>\n<p>Modern container runtimes often integrate with orchestration systems and provide standardized interfaces.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Category</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container Runtime Interface</td>\n<td>Standard Interface</td>\n<td>A Kubernetes standard interface that defines how container orchestrators communicate with container runtimes. Enables different container runtimes to work with Kubernetes without requiring orchestrator-specific integration code.</td>\n</tr>\n<tr>\n<td>sidecar injection</td>\n<td>Deployment Pattern</td>\n<td>The automatic deployment of auxiliary containers alongside application containers to provide additional functionality like networking, security, or monitoring. Common in service mesh implementations for proxy injection.</td>\n</tr>\n</tbody></table>\n<p>This glossary provides the essential vocabulary needed to understand and implement our container runtime system. Each term is carefully chosen to represent concepts you&#39;ll encounter while working through the four implementation milestones, from basic namespace isolation to advanced networking features.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding these terms is crucial for successful implementation of your container runtime. As you work through each milestone, refer back to these definitions to ensure you&#39;re using terminology correctly and understanding the underlying concepts.</p>\n<p><strong>Key Term Categories for Each Milestone:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Milestone</th>\n<th>Primary Term Categories</th>\n<th>Focus Areas</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Milestone 1</td>\n<td>Namespace Types, Kernel Features, Process Isolation</td>\n<td>Understanding how namespaces create isolated views of system resources</td>\n</tr>\n<tr>\n<td>Milestone 2</td>\n<td>Cgroup Controllers, Resource Control, Monitoring</td>\n<td>Learning how cgroups enforce resource limits and provide usage statistics</td>\n</tr>\n<tr>\n<td>Milestone 3</td>\n<td>Filesystem Concepts, Layer Stacking, Copy-on-Write</td>\n<td>Mastering overlayfs mechanics and layer management</td>\n</tr>\n<tr>\n<td>Milestone 4</td>\n<td>Container Networking, NAT Rules, Interface Management</td>\n<td>Implementing virtual networking with bridges and port forwarding</td>\n</tr>\n</tbody></table>\n<p><strong>Terminology Usage Guidelines:</strong></p>\n<p>When implementing your container runtime, consistently use these terms in your code comments, documentation, and variable names. This consistency helps maintain clarity and makes your code easier to understand and maintain.</p>\n<p>For example, when implementing namespace creation, use terms like &quot;namespace handle&quot; for data structures that track namespace resources, &quot;process isolation&quot; when describing the security benefits, and &quot;mount namespace&quot; when specifically referring to filesystem isolation.</p>\n<p><strong>Common Terminology Mistakes:</strong></p>\n<p>⚠️ <strong>Pitfall: Mixing cgroups v1 and v2 terminology</strong>\nUsing cgroups v1 terms like &quot;memory.limit_in_bytes&quot; when implementing cgroups v2, which uses &quot;memory.max&quot;. Always verify you&#39;re using the correct terminology for your target cgroup version.</p>\n<p>⚠️ <strong>Pitfall: Confusing overlay filesystem layers</strong>\nReferring to &quot;upper layers&quot; (plural) when overlayfs has only one upper directory but multiple lower directories. The terminology is specific: one upper directory, multiple lower directories, one merged view.</p>\n<p>⚠️ <strong>Pitfall: Misusing network namespace terminology</strong>\nCalling veth pairs &quot;virtual interfaces&quot; without clarifying they&#39;re specifically ethernet pairs. The term &quot;veth pair&quot; is precise and indicates the bidirectional nature of the connection.</p>\n<p><strong>Reference Implementation Notes:</strong></p>\n<p>When reading container runtime source code (Docker, containerd, runc), you&#39;ll encounter these same terms used consistently across implementations. Understanding this standard terminology helps you read and contribute to existing projects beyond your own implementation.</p>\n<p>The Linux kernel documentation uses these exact terms, so mastering this vocabulary helps you understand system documentation, manual pages, and kernel interfaces more effectively.</p>\n","toc":[{"level":1,"text":"Container Runtime: Design Document","id":"container-runtime-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: Apartments in a Building","id":"mental-model-apartments-in-a-building"},{"level":3,"text":"Existing Container Runtime Approaches","id":"existing-container-runtime-approaches"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Mental Model: Building a Studio Apartment vs. a Luxury Hotel","id":"mental-model-building-a-studio-apartment-vs-a-luxury-hotel"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Process Isolation Through Namespaces","id":"process-isolation-through-namespaces"},{"level":4,"text":"Resource Control Using Cgroups","id":"resource-control-using-cgroups"},{"level":4,"text":"Filesystem Layering with OverlayFS","id":"filesystem-layering-with-overlayfs"},{"level":4,"text":"Basic Container Networking","id":"basic-container-networking"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":4,"text":"Image Distribution and Registry Management","id":"image-distribution-and-registry-management"},{"level":4,"text":"Container Orchestration and Scheduling","id":"container-orchestration-and-scheduling"},{"level":4,"text":"Production-Grade Security Features","id":"production-grade-security-features"},{"level":4,"text":"Advanced Networking Features","id":"advanced-networking-features"},{"level":4,"text":"Performance Optimization and Scalability","id":"performance-optimization-and-scalability"},{"level":4,"text":"Backward Compatibility and Standards Compliance","id":"backward-compatibility-and-standards-compliance"},{"level":3,"text":"Success Criteria and Validation","id":"success-criteria-and-validation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structures","id":"core-data-structures"},{"level":4,"text":"Scope Discipline Implementation","id":"scope-discipline-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Mental Model: The Orchestra Conductor","id":"mental-model-the-orchestra-conductor"},{"level":3,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":4,"text":"Manager Component","id":"manager-component"},{"level":4,"text":"Namespace Handler Component","id":"namespace-handler-component"},{"level":4,"text":"Cgroup Controller Component","id":"cgroup-controller-component"},{"level":4,"text":"Filesystem Manager Component","id":"filesystem-manager-component"},{"level":4,"text":"Network Manager Component","id":"network-manager-component"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure Implementation","id":"file-structure-implementation"},{"level":4,"text":"Component Interface Contracts","id":"component-interface-contracts"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Container Specification","id":"container-specification"},{"level":3,"text":"Resource Limits Structure","id":"resource-limits-structure"},{"level":3,"text":"Network Configuration Structure","id":"network-configuration-structure"},{"level":3,"text":"Port Mapping Structure","id":"port-mapping-structure"},{"level":3,"text":"Runtime State","id":"runtime-state"},{"level":3,"text":"Container Status Enumeration","id":"container-status-enumeration"},{"level":3,"text":"Common Data Model Pitfalls","id":"common-data-model-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structures","id":"core-data-structures"},{"level":4,"text":"Validation Functions","id":"validation-functions"},{"level":4,"text":"State Management Helper","id":"state-management-helper"},{"level":4,"text":"Language-Specific Implementation Notes","id":"language-specific-implementation-notes"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Namespace Isolation Component","id":"namespace-isolation-component"},{"level":3,"text":"Mental Model: Separate Worlds","id":"mental-model-separate-worlds"},{"level":3,"text":"Namespace Types and Setup","id":"namespace-types-and-setup"},{"level":4,"text":"PID Namespace Isolation","id":"pid-namespace-isolation"},{"level":4,"text":"Mount Namespace Isolation","id":"mount-namespace-isolation"},{"level":4,"text":"Network Namespace Isolation","id":"network-namespace-isolation"},{"level":4,"text":"UTS Namespace Isolation","id":"uts-namespace-isolation"},{"level":4,"text":"User Namespace Isolation","id":"user-namespace-isolation"},{"level":3,"text":"Namespace Creation Implementation","id":"namespace-creation-implementation"},{"level":3,"text":"Filesystem Pivot Process","id":"filesystem-pivot-process"},{"level":4,"text":"Pivot Root Algorithm","id":"pivot-root-algorithm"},{"level":4,"text":"Mount Point Requirements","id":"mount-point-requirements"},{"level":4,"text":"Essential Filesystem Mounts","id":"essential-filesystem-mounts"},{"level":3,"text":"Common Namespace Pitfalls","id":"common-namespace-pitfalls"},{"level":4,"text":"⚠️ Pitfall: Mount Point Requirements for pivot_root","id":"-pitfall-mount-point-requirements-for-pivot_root"},{"level":4,"text":"⚠️ Pitfall: Missing /proc Mount in PID Namespace","id":"-pitfall-missing-proc-mount-in-pid-namespace"},{"level":4,"text":"⚠️ Pitfall: User Namespace UID Mapping Race Condition","id":"-pitfall-user-namespace-uid-mapping-race-condition"},{"level":4,"text":"⚠️ Pitfall: Network Namespace Connectivity Loss","id":"-pitfall-network-namespace-connectivity-loss"},{"level":4,"text":"⚠️ Pitfall: Incomplete Namespace Cleanup on Failure","id":"-pitfall-incomplete-namespace-cleanup-on-failure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Resource Control Component","id":"resource-control-component"},{"level":3,"text":"Mental Model: Resource Budget Manager","id":"mental-model-resource-budget-manager"},{"level":3,"text":"Cgroup Controller Configuration","id":"cgroup-controller-configuration"},{"level":4,"text":"Memory Controller Configuration","id":"memory-controller-configuration"},{"level":4,"text":"CPU Controller Configuration","id":"cpu-controller-configuration"},{"level":4,"text":"Device Controller Configuration","id":"device-controller-configuration"},{"level":4,"text":"Cgroup Creation and Assignment Algorithm","id":"cgroup-creation-and-assignment-algorithm"},{"level":3,"text":"Resource Usage Monitoring","id":"resource-usage-monitoring"},{"level":4,"text":"Memory Usage Monitoring","id":"memory-usage-monitoring"},{"level":4,"text":"CPU Usage Monitoring","id":"cpu-usage-monitoring"},{"level":4,"text":"Resource Monitoring Data Structures","id":"resource-monitoring-data-structures"},{"level":3,"text":"Out-of-Memory Handling","id":"out-of-memory-handling"},{"level":4,"text":"OOM Detection and Response","id":"oom-detection-and-response"},{"level":4,"text":"OOM Recovery and Cleanup","id":"oom-recovery-and-cleanup"},{"level":4,"text":"Memory Pressure Prevention","id":"memory-pressure-prevention"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Filesystem Layering Component","id":"filesystem-layering-component"},{"level":3,"text":"Mental Model: Transparent Sheets","id":"mental-model-transparent-sheets"},{"level":3,"text":"Layer Stacking and Management","id":"layer-stacking-and-management"},{"level":3,"text":"Copy-on-Write Semantics","id":"copy-on-write-semantics"},{"level":3,"text":"Layer Cleanup Process","id":"layer-cleanup-process"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Network Management Component","id":"network-management-component"},{"level":3,"text":"Mental Model: Virtual Cable System","id":"mental-model-virtual-cable-system"},{"level":3,"text":"Veth Pair and Bridge Setup","id":"veth-pair-and-bridge-setup"},{"level":3,"text":"IP Address Assignment","id":"ip-address-assignment"},{"level":3,"text":"Port Forwarding with NAT","id":"port-forwarding-with-nat"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Mental Model: Orchestra Conductor","id":"mental-model-orchestra-conductor"},{"level":3,"text":"Container Creation Sequence","id":"container-creation-sequence"},{"level":4,"text":"Pre-Creation Validation Phase","id":"pre-creation-validation-phase"},{"level":4,"text":"Component Initialization Sequence","id":"component-initialization-sequence"},{"level":4,"text":"State Transition and Process Launch","id":"state-transition-and-process-launch"},{"level":4,"text":"Failure Recovery During Creation","id":"failure-recovery-during-creation"},{"level":3,"text":"Container Cleanup Sequence","id":"container-cleanup-sequence"},{"level":4,"text":"Graceful Termination Process","id":"graceful-termination-process"},{"level":4,"text":"State Management During Cleanup","id":"state-management-during-cleanup"},{"level":4,"text":"Forced Removal and Recovery","id":"forced-removal-and-recovery"},{"level":4,"text":"Cleanup Verification and Monitoring","id":"cleanup-verification-and-monitoring"},{"level":3,"text":"Component Communication Patterns","id":"component-communication-patterns"},{"level":4,"text":"Synchronous Command-Response Pattern","id":"synchronous-command-response-pattern"},{"level":4,"text":"Event Notification Pattern","id":"event-notification-pattern"},{"level":4,"text":"Resource Handle Management","id":"resource-handle-management"},{"level":3,"text":"Error Propagation and Recovery","id":"error-propagation-and-recovery"},{"level":4,"text":"Error Classification and Handling","id":"error-classification-and-handling"},{"level":4,"text":"Recovery State Machine","id":"recovery-state-machine"},{"level":3,"text":"Performance Considerations and Optimization","id":"performance-considerations-and-optimization"},{"level":4,"text":"Parallel Component Operations","id":"parallel-component-operations"},{"level":4,"text":"Resource Pooling and Caching","id":"resource-pooling-and-caching"},{"level":4,"text":"Batch Operations","id":"batch-operations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core State Management Infrastructure","id":"core-state-management-infrastructure"},{"level":4,"text":"Runtime Manager Core Logic","id":"runtime-manager-core-logic"},{"level":4,"text":"Component Coordination Framework","id":"component-coordination-framework"},{"level":4,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Partial Failure Recovery","id":"partial-failure-recovery"},{"level":3,"text":"Resource Exhaustion Scenarios","id":"resource-exhaustion-scenarios"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Error Handling Infrastructure","id":"core-error-handling-infrastructure"},{"level":4,"text":"Resource Monitoring Implementation","id":"resource-monitoring-implementation"},{"level":4,"text":"Component Cleanup Interfaces","id":"component-cleanup-interfaces"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Common Error Handling Issues","id":"debugging-common-error-handling-issues"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: Multi-Layer Quality Gates","id":"mental-model-multi-layer-quality-gates"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1: Process Isolation with Namespaces","id":"milestone-1-process-isolation-with-namespaces"},{"level":4,"text":"Milestone 2: Resource Limits with Cgroups","id":"milestone-2-resource-limits-with-cgroups"},{"level":4,"text":"Milestone 3: Overlay Filesystem","id":"milestone-3-overlay-filesystem"},{"level":4,"text":"Milestone 4: Container Networking","id":"milestone-4-container-networking"},{"level":3,"text":"Integration Test Scenarios","id":"integration-test-scenarios"},{"level":4,"text":"Scenario 1: Multi-Container Web Application","id":"scenario-1-multi-container-web-application"},{"level":4,"text":"Scenario 2: Batch Processing with Resource Contention","id":"scenario-2-batch-processing-with-resource-contention"},{"level":4,"text":"Scenario 3: Container Lifecycle Stress Testing","id":"scenario-3-container-lifecycle-stress-testing"},{"level":4,"text":"Scenario 4: Security Isolation Validation","id":"scenario-4-security-isolation-validation"},{"level":3,"text":"Common Pitfalls in Container Runtime Testing","id":"common-pitfalls-in-container-runtime-testing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Test Infrastructure Starter Code","id":"test-infrastructure-starter-code"},{"level":4,"text":"Milestone Test Implementation Skeletons","id":"milestone-test-implementation-skeletons"},{"level":4,"text":"Milestone Checkpoint Commands","id":"milestone-checkpoint-commands"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Namespace Debugging Techniques","id":"namespace-debugging-techniques"},{"level":3,"text":"Cgroup Debugging Techniques","id":"cgroup-debugging-techniques"},{"level":3,"text":"Network Debugging Techniques","id":"network-debugging-techniques"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: Construction Site Evolution","id":"mental-model-construction-site-evolution"},{"level":3,"text":"Current Foundation Assessment","id":"current-foundation-assessment"},{"level":3,"text":"Security Enhancements","id":"security-enhancements"},{"level":4,"text":"Mental Model: Multi-Layer Security Castle","id":"mental-model-multi-layer-security-castle"},{"level":4,"text":"Seccomp Filter Integration","id":"seccomp-filter-integration"},{"level":4,"text":"Capability Management System","id":"capability-management-system"},{"level":4,"text":"AppArmor and SELinux Integration","id":"apparmor-and-selinux-integration"},{"level":4,"text":"Security Policy Composition","id":"security-policy-composition"},{"level":3,"text":"Advanced Networking Features","id":"advanced-networking-features"},{"level":4,"text":"Mental Model: Metropolitan Transportation Network","id":"mental-model-metropolitan-transportation-network"},{"level":4,"text":"Multi-Host Networking Implementation","id":"multi-host-networking-implementation"},{"level":4,"text":"Container Network Interface (CNI) Integration","id":"container-network-interface-cni-integration"},{"level":4,"text":"Network Policy Enforcement","id":"network-policy-enforcement"},{"level":4,"text":"Quality of Service and Traffic Shaping","id":"quality-of-service-and-traffic-shaping"},{"level":3,"text":"Image Management and Distribution","id":"image-management-and-distribution"},{"level":4,"text":"Mental Model: Digital Library System","id":"mental-model-digital-library-system"},{"level":4,"text":"Container Image Registry Integration","id":"container-image-registry-integration"},{"level":4,"text":"Image Security and Verification","id":"image-security-and-verification"},{"level":3,"text":"Orchestration Integration","id":"orchestration-integration"},{"level":4,"text":"Mental Model: Orchestra Conductor System","id":"mental-model-orchestra-conductor-system"},{"level":4,"text":"Kubernetes Container Runtime Interface (CRI)","id":"kubernetes-container-runtime-interface-cri"},{"level":4,"text":"Service Mesh Integration","id":"service-mesh-integration"},{"level":3,"text":"Storage and Volume Management","id":"storage-and-volume-management"},{"level":4,"text":"Persistent Volume Integration","id":"persistent-volume-integration"},{"level":4,"text":"Storage Optimization","id":"storage-optimization"},{"level":3,"text":"Common Pitfalls in Advanced Extensions","id":"common-pitfalls-in-advanced-extensions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Security Extension Starter Code","id":"security-extension-starter-code"},{"level":4,"text":"CNI Integration Starter Code","id":"cni-integration-starter-code"},{"level":4,"text":"Orchestration Integration Core Types","id":"orchestration-integration-core-types"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Extension Debugging Tips","id":"extension-debugging-tips"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: Technical Dictionary as Navigation Map","id":"mental-model-technical-dictionary-as-navigation-map"},{"level":3,"text":"Container Runtime Core Concepts","id":"container-runtime-core-concepts"},{"level":3,"text":"Linux Kernel Features","id":"linux-kernel-features"},{"level":3,"text":"Namespace Types and Isolation","id":"namespace-types-and-isolation"},{"level":3,"text":"Cgroup Resource Control","id":"cgroup-resource-control"},{"level":3,"text":"Filesystem and Storage Concepts","id":"filesystem-and-storage-concepts"},{"level":3,"text":"Container Networking","id":"container-networking"},{"level":3,"text":"Container Lifecycle and Operations","id":"container-lifecycle-and-operations"},{"level":3,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":3,"text":"Testing and Validation","id":"testing-and-validation"},{"level":3,"text":"Debugging and Diagnostics","id":"debugging-and-diagnostics"},{"level":3,"text":"Security and Advanced Features","id":"security-and-advanced-features"},{"level":3,"text":"Networking Extensions","id":"networking-extensions"},{"level":3,"text":"Storage and Image Management","id":"storage-and-image-management"},{"level":3,"text":"Container Orchestration Interface","id":"container-orchestration-interface"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"}],"title":"Container Runtime: Design Document","markdown":"# Container Runtime: Design Document\n\n\n## Overview\n\nThis system implements a minimal container runtime that provides process isolation using Linux namespaces, resource control through cgroups, and layered filesystem support via overlayfs. The key architectural challenge is orchestrating multiple kernel isolation mechanisms while maintaining clean abstractions and handling complex failure modes across namespace boundaries.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** This section provides foundational understanding for all milestones, establishing the conceptual framework for process isolation, resource control, and filesystem layering.\n\nModern software deployment relies heavily on containerization, yet many developers treat containers as black boxes—they understand how to use Docker commands but lack insight into the fundamental isolation mechanisms that make containers possible. Building a container runtime from scratch reveals the elegant interplay between Linux kernel features: namespaces for process isolation, cgroups for resource control, and overlay filesystems for efficient image layering. This educational journey transforms abstract concepts like \"process isolation\" into concrete understanding of system calls, kernel interfaces, and the intricate choreography required to create truly isolated execution environments.\n\nThe core challenge in container runtime design lies not in any single isolation mechanism, but in orchestrating multiple kernel subsystems to work together harmoniously. A container must simultaneously exist in its own process tree (PID namespace), have its own filesystem view (mount namespace), control its resource consumption (cgroups), and maintain network connectivity (network namespace)—all while appearing to be a normal process from the host's perspective. This coordination requires deep understanding of Linux kernel interfaces, careful error handling across subsystem boundaries, and robust cleanup procedures when things go wrong.\n\n### Mental Model: Apartments in a Building\n\nBefore diving into technical details, consider this mental model: **containers are like apartments in a large apartment building, where each apartment provides complete living isolation while sharing the building's infrastructure**.\n\n![Container Runtime System Architecture](./diagrams/system-architecture.svg)\n\nIn this apartment building analogy:\n\n**The Building (Host System)** represents the physical machine running Linux. The building provides shared infrastructure: electricity (CPU), water and heating (memory and I/O), structural support (kernel), and external connectivity (network). All apartments rely on this shared foundation, but each apartment gets its own allocated portion of these resources.\n\n**Individual Apartments (Containers)** are completely isolated living spaces. From inside apartment 3B, you cannot see into apartment 2A's living room, rummage through their belongings, or use up all the hot water and leave them with cold showers. Each apartment has its own address (IP address), its own thermostat controls (resource limits), and its own locked door (security boundaries). The residents of apartment 3B might not even know that apartment 2A exists—they see their apartment as if it were a standalone house.\n\n**The Building Management (Runtime Manager)** handles apartment lifecycle: creating new apartments when tenants move in, setting up utilities connections, enforcing building rules about noise and resource usage, handling maintenance requests, and cleaning up when tenants move out. Management also handles the complex coordination between different building systems—ensuring the electrical system, plumbing, HVAC, and security all work together for each apartment.\n\n**Utility Connections (Namespaces)** provide each apartment with isolated access to building services. Each apartment gets its own electrical meter (PID namespace), its own water pressure (mount namespace), its own mail delivery (network namespace), and its own thermostat zone (UTS namespace). These systems are carefully isolated—a power surge in apartment 2A doesn't affect apartment 3B's electricity, and a plumbing leak in 3B doesn't contaminate 2A's water supply.\n\n**Resource Allocation (Cgroups)** ensures fair sharing of building resources. Management enforces rules: apartment 2A gets 30% of the building's heating capacity, apartment 3B gets 40% of the available hot water, and no single apartment can use more than 25% of the total electrical capacity. When apartment 2A tries to exceed its heating allowance, the system automatically regulates their usage rather than letting them freeze out their neighbors.\n\n**Shared Infrastructure Layers (Overlay Filesystem)** allow apartments to share common elements efficiently while maintaining isolation. All apartments share the same basic floor plan and fixtures (base image layers), but each apartment can customize their space with their own furniture and decorations (writable layer). When a tenant in 3B paints their walls red, it doesn't affect the walls in 2A—each apartment's customizations exist in their own layer.\n\n> The key insight is that **isolation is not about physical separation—it's about controlled sharing**. Apartments share the same building, electrical grid, and water supply, but each apartment gets its own controlled interface to these shared resources.\n\nThis mental model illuminates the fundamental challenge of container runtime design: orchestrating multiple isolation mechanisms (utility connections, resource allocation, space management) to create the illusion of independent environments while efficiently sharing underlying infrastructure. Just as building management must coordinate electricians, plumbers, HVAC technicians, and security to make apartments work, a container runtime must coordinate namespace creation, cgroup configuration, filesystem mounting, and network setup to make containers work.\n\n### Existing Container Runtime Approaches\n\nUnderstanding the design space of container runtimes requires examining how different implementations approach the fundamental challenges of process isolation, resource control, and filesystem management. Each runtime makes different trade-offs between simplicity, performance, security, and feature richness, providing valuable insights into architectural decisions we'll face in our own implementation.\n\n> **Decision: Runtime Architecture Comparison**\n> - **Context**: Container runtimes exist at different abstraction levels, from low-level kernel interface wrappers to high-level developer platforms. Understanding this landscape helps us position our educational runtime and learn from proven approaches.\n> - **Options Considered**: Build using existing runtime as foundation, implement OCI-compatible runtime, create minimal educational runtime\n> - **Decision**: Create minimal educational runtime that implements core concepts directly\n> - **Rationale**: Direct implementation of kernel interfaces maximizes learning value by exposing all underlying mechanisms without abstraction layers hiding the complexity\n> - **Consequences**: Higher implementation effort but deeper understanding of fundamental isolation primitives and their interactions\n\n| Runtime | Architecture Level | Primary Focus | Implementation Language | Key Design Philosophy |\n|---------|------------------|---------------|----------------------|----------------------|\n| Docker | High-level Platform | Developer Experience | Go | Integrated toolchain with registry, build system, and runtime |\n| containerd | Mid-level Daemon | Industry Standard | Go | Modular architecture with pluggable components |\n| runc | Low-level Runtime | OCI Compliance | Go | Minimal implementation of OCI runtime specification |\n| crun | Low-level Runtime | Performance | C | Fast startup times with lower memory overhead |\n| kata-containers | High-security Runtime | Hardware Isolation | Rust/Go | VM-based containers for enhanced security boundaries |\n\n**Docker: Integrated Developer Platform**\n\nDocker pioneered the modern container experience by providing a complete developer toolchain that abstracts away kernel complexity. The Docker architecture consists of multiple layers: the Docker CLI communicates with the Docker daemon, which manages container lifecycles by delegating to containerd, which in turn uses runc for actual container creation. This layered approach prioritizes developer experience—running `docker run nginx` hides the complexity of namespace creation, cgroup configuration, and overlay filesystem mounting behind a simple command.\n\nThe Docker approach teaches us that **developer experience often requires architectural complexity**. Docker's multi-daemon architecture (dockerd → containerd → runc) introduces latency and resource overhead but provides features like image building, registry integration, volume management, and networking that developers expect. For our educational runtime, we'll implement these kernel interfaces directly rather than layering abstractions, maximizing learning value even at the cost of developer convenience.\n\n**containerd: Modular Industry Standard**\n\ncontainerd represents the industry's attempt to create a standard, modular container runtime that can serve as a foundation for higher-level tools. Originally extracted from Docker, containerd focuses on the core container lifecycle: image management, container execution, storage management, and network attachment. It provides a gRPC API that tools like Docker and Kubernetes use for container operations.\n\ncontainerd's architecture demonstrates **separation of concerns through well-defined interfaces**. The containerd daemon manages container metadata and coordinates between specialized subsystems: the image store handles layer management, the snapshotter manages filesystem layers, the runtime manager handles container execution, and the network plugins handle connectivity. Each subsystem can be replaced or extended without affecting others.\n\nOur educational runtime will adopt containerd's principle of component separation while implementing everything in a single process to avoid the complexity of inter-process communication during the learning phase.\n\n**runc: OCI-Compliant Minimal Runtime**\n\nrunc implements the Open Container Initiative (OCI) runtime specification, providing the lowest-level container execution without daemon overhead. It takes a JSON configuration file describing desired container properties (namespaces, cgroups, filesystem mounts, process arguments) and executes the specified process in an isolated environment. runc demonstrates that container creation can be reduced to a deterministic sequence of system calls.\n\nThe runc approach reveals that **containers are just processes with fancy isolation**. When you execute `runc run container-id`, runc performs this sequence: creates namespaces via clone() system call, sets up cgroup limits, mounts the overlay filesystem, configures networking interfaces, and finally execv() the target process. The target process becomes PID 1 in its own PID namespace, completely unaware that it's running in a container.\n\nOur implementation will follow runc's principle of deterministic container creation while exposing each step explicitly for educational purposes rather than hiding them behind a configuration file.\n\n**crun: Performance-Optimized Runtime**\n\ncrun reimplements the OCI runtime specification in C rather than Go, achieving significantly faster container startup times and lower memory overhead. This design choice illustrates the performance trade-offs inherent in container runtime implementation. Go's garbage collector and higher-level abstractions provide development productivity but introduce latency that becomes significant when orchestrators like Kubernetes start thousands of containers per minute.\n\ncrun's performance focus teaches us that **system call overhead dominates container creation performance**. The fundamental operations—namespace creation, cgroup setup, filesystem mounting—involve expensive kernel transitions. Optimizing these operations requires careful attention to system call batching, memory allocation patterns, and avoiding unnecessary filesystem operations.\n\nFor our educational runtime, we'll prioritize code clarity over performance optimization, but understanding these trade-offs helps explain why production runtimes make certain architectural choices.\n\n**Container Runtime Interface (CRI) Integration**\n\nModern container runtimes must integrate with orchestration systems like Kubernetes through the Container Runtime Interface (CRI). CRI defines a gRPC API that Kubernetes uses to manage container lifecycles: `RunPodSandbox` creates isolated environments, `CreateContainer` prepares container specifications, `StartContainer` begins process execution, and `StopContainer` terminates processes cleanly.\n\n| CRI Operation | Runtime Responsibilities | Kernel Interfaces Used |\n|---------------|------------------------|----------------------|\n| RunPodSandbox | Create shared namespace environment for pod containers | clone() with namespace flags, mount() for shared volumes |\n| CreateContainer | Prepare container filesystem and configuration | mount() for overlayfs, cgroup filesystem writes |\n| StartContainer | Execute container process in isolated environment | execve() after namespace/cgroup setup |\n| StopContainer | Terminate process and cleanup resources | kill() signal delivery, umount(), cgroup cleanup |\n| RemoveContainer | Clean up container metadata and temporary files | filesystem cleanup, cgroup removal |\n\nUnderstanding CRI integration reveals that **container runtimes are ultimately process lifecycle managers**. They coordinate kernel isolation mechanisms to create the illusion of independent machines while providing APIs that higher-level tools can use programmatically.\n\n> **Key Design Insight**: All container runtimes, regardless of their high-level architecture, ultimately perform the same fundamental operations: process isolation through namespaces, resource control through cgroups, filesystem layering through overlay mounts, and network connectivity through virtual interfaces. The differences lie in how they package these operations, what additional features they provide, and how they balance performance, security, and usability trade-offs.\n\nOur educational runtime will implement these core operations directly, providing deep understanding of the kernel interfaces that production runtimes build upon. By understanding these fundamentals, developers gain the knowledge needed to debug container issues, optimize containerized applications, and make informed decisions about runtime selection in production environments.\n\nThe journey from understanding container concepts to implementing kernel interfaces reveals why containerization became so transformative: it provides process isolation and resource control that previously required separate virtual machines, but with much lower overhead and faster startup times. This efficiency comes from clever use of Linux kernel features that already existed—containers didn't require new kernel functionality, just creative orchestration of existing isolation primitives.\n\n### Implementation Guidance\n\nThis implementation guidance provides concrete technology choices and starter code to begin building your container runtime while focusing learning effort on the core isolation mechanisms rather than peripheral infrastructure.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option | Our Choice |\n|-----------|---------------|----------------|------------|\n| HTTP API | Standard library net/http with JSON | gRPC with Protocol Buffers | Standard library (learning focus) |\n| Configuration | JSON files with encoding/json | YAML with third-party parser | JSON (minimal dependencies) |\n| Logging | Standard library log package | Structured logging (logrus/zap) | Standard library (simplicity) |\n| Process Management | os/exec with direct system calls | Third-party process libraries | os/exec + unix package (direct kernel access) |\n| Filesystem Operations | Standard library os and filepath | Third-party filesystem abstractions | Standard library (transparency) |\n| Network Configuration | Direct netlink system calls | Third-party network libraries | golang.org/x/sys/unix (learning kernel interfaces) |\n\n**Recommended File Structure:**\n\n```\ncontainer-runtime/\n├── cmd/\n│   ├── runtime/\n│   │   └── main.go                    ← CLI entry point\n│   └── daemon/\n│       └── main.go                    ← Daemon mode entry point\n├── internal/\n│   ├── runtime/\n│   │   ├── manager.go                 ← Runtime Manager (orchestrates components)\n│   │   ├── container.go               ← Container specification and state\n│   │   └── manager_test.go\n│   ├── namespace/\n│   │   ├── namespace.go               ← Namespace Handler component\n│   │   ├── mount.go                   ← Mount namespace operations\n│   │   ├── pid.go                     ← PID namespace operations\n│   │   └── namespace_test.go\n│   ├── cgroup/\n│   │   ├── controller.go              ← Cgroup Controller component\n│   │   ├── memory.go                  ← Memory controller operations\n│   │   ├── cpu.go                     ← CPU controller operations\n│   │   └── controller_test.go\n│   ├── filesystem/\n│   │   ├── overlay.go                 ← Filesystem Manager component\n│   │   ├── layers.go                  ← Layer management operations\n│   │   └── overlay_test.go\n│   ├── network/\n│   │   ├── manager.go                 ← Network Manager component\n│   │   ├── bridge.go                  ← Bridge networking setup\n│   │   ├── veth.go                    ← Virtual ethernet operations\n│   │   └── manager_test.go\n│   └── utils/\n│       ├── syscalls.go                ← System call wrappers\n│       └── paths.go                   ← Path utilities\n├── pkg/\n│   └── api/\n│       ├── types.go                   ← Public API types\n│       └── client.go                  ← Client library\n├── configs/\n│   └── runtime.json                   ← Default configuration\n├── scripts/\n│   ├── setup-cgroups.sh             ← System setup helpers\n│   └── cleanup-test-env.sh           ← Test cleanup utilities\n└── docs/\n    ├── design/\n    └── examples/\n```\n\n**Infrastructure Starter Code:**\n\nSince our focus is learning container runtime concepts rather than building JSON parsers or HTTP servers, here's complete starter code for peripheral infrastructure:\n\n**Configuration Management (`internal/runtime/container.go`):**\n```go\npackage runtime\n\nimport (\n    \"encoding/json\"\n    \"os\"\n)\n\n// ContainerSpec defines what a container should look like\ntype ContainerSpec struct {\n    ID          string            `json:\"id\"`\n    Image       string            `json:\"image\"`\n    Command     []string          `json:\"command\"`\n    Environment map[string]string `json:\"environment\"`\n    WorkingDir  string            `json:\"working_dir\"`\n    \n    // Resource limits\n    Memory      int64    `json:\"memory\"`        // bytes\n    CPUShares   int64    `json:\"cpu_shares\"`    // relative weight\n    CPUQuota    int64    `json:\"cpu_quota\"`     // microseconds per period\n    \n    // Networking\n    NetworkMode string   `json:\"network_mode\"`  // \"bridge\", \"host\", \"none\"\n    PortMappings []PortMapping `json:\"port_mappings\"`\n}\n\ntype PortMapping struct {\n    HostPort      int    `json:\"host_port\"`\n    ContainerPort int    `json:\"container_port\"`\n    Protocol      string `json:\"protocol\"`  // \"tcp\" or \"udp\"\n}\n\n// ContainerState tracks runtime information\ntype ContainerState struct {\n    ID          string `json:\"id\"`\n    Status      string `json:\"status\"`  // \"created\", \"running\", \"stopped\"\n    PID         int    `json:\"pid\"`     // container process PID\n    ExitCode    int    `json:\"exit_code\"`\n    \n    // Resource handles for cleanup\n    NamespacePath string   `json:\"namespace_path\"`\n    CgroupPath    string   `json:\"cgroup_path\"`\n    OverlayPath   string   `json:\"overlay_path\"`\n    NetworkNS     string   `json:\"network_ns\"`\n}\n\nfunc LoadContainerSpec(path string) (*ContainerSpec, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, err\n    }\n    \n    var spec ContainerSpec\n    if err := json.Unmarshal(data, &spec); err != nil {\n        return nil, err\n    }\n    \n    return &spec, nil\n}\n\nfunc (s *ContainerState) SaveToFile(path string) error {\n    data, err := json.MarshalIndent(s, \"\", \"  \")\n    if err != nil {\n        return err\n    }\n    \n    return os.WriteFile(path, data, 0644)\n}\n```\n\n**System Call Utilities (`internal/utils/syscalls.go`):**\n```go\npackage utils\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"syscall\"\n    \"unsafe\"\n    \n    \"golang.org/x/sys/unix\"\n)\n\n// NamespaceType represents different Linux namespace types\ntype NamespaceType int\n\nconst (\n    CLONE_NEWPID   = 0x20000000\n    CLONE_NEWNS    = 0x00020000\n    CLONE_NEWNET   = 0x40000000\n    CLONE_NEWUTS   = 0x04000000\n    CLONE_NEWIPC   = 0x08000000\n    CLONE_NEWUSER  = 0x10000000\n)\n\n// CreateNamespaces creates new namespaces for container isolation\nfunc CreateNamespaces(namespaces []int) error {\n    var flags uintptr\n    for _, ns := range namespaces {\n        flags |= uintptr(ns)\n    }\n    \n    _, _, errno := syscall.RawSyscall(syscall.SYS_UNSHARE, flags, 0, 0)\n    if errno != 0 {\n        return fmt.Errorf(\"unshare failed: %v\", errno)\n    }\n    \n    return nil\n}\n\n// MountOverlayFS mounts overlayfs with specified layers\nfunc MountOverlayFS(lowerDirs []string, upperDir, workDir, target string) error {\n    // Build overlay mount options\n    var lowers string\n    for i, dir := range lowerDirs {\n        if i > 0 {\n            lowers += \":\"\n        }\n        lowers += dir\n    }\n    \n    options := fmt.Sprintf(\"lowerdir=%s,upperdir=%s,workdir=%s\", \n                          lowers, upperDir, workDir)\n    \n    return syscall.Mount(\"overlay\", target, \"overlay\", 0, options)\n}\n\n// WriteToFile is a helper for writing to cgroup control files\nfunc WriteToFile(path, value string) error {\n    return os.WriteFile(path, []byte(value), 0644)\n}\n\n// EnsureDir creates directory if it doesn't exist\nfunc EnsureDir(path string) error {\n    return os.MkdirAll(path, 0755)\n}\n```\n\n**Core Logic Skeleton:**\n\nFor the main Runtime Manager, provide skeleton with detailed TODOs mapping to the design concepts:\n\n```go\npackage runtime\n\nimport (\n    \"fmt\"\n    \"os/exec\"\n    \"path/filepath\"\n)\n\n// Manager orchestrates all container runtime components\ntype Manager struct {\n    containerStore map[string]*ContainerState\n    cgroupRoot     string\n    overlayRoot    string\n    bridgeName     string\n}\n\nfunc NewManager(cgroupRoot, overlayRoot, bridgeName string) *Manager {\n    return &Manager{\n        containerStore: make(map[string]*ContainerState),\n        cgroupRoot:     cgroupRoot,\n        overlayRoot:    overlayRoot,\n        bridgeName:     bridgeName,\n    }\n}\n\n// CreateContainer sets up container environment without starting process\nfunc (m *Manager) CreateContainer(spec *ContainerSpec) error {\n    // TODO 1: Validate container specification (check required fields, resource limits)\n    // TODO 2: Create container state directory structure under /var/lib/container-runtime/\n    // TODO 3: Set up overlay filesystem layers (lower dirs from image, upper dir for container)\n    // TODO 4: Create cgroup hierarchy for container resource control\n    // TODO 5: Prepare network namespace (create veth pair, attach to bridge)\n    // TODO 6: Save container state to persistent storage for later operations\n    // Hint: Don't start the container process yet - that's StartContainer's job\n    return fmt.Errorf(\"not implemented\")\n}\n\n// StartContainer begins execution of container process in isolated environment\nfunc (m *Manager) StartContainer(containerID string) error {\n    // TODO 1: Load container state and validate it's in \"created\" status\n    // TODO 2: Clone new process with namespace isolation flags (CLONE_NEWPID, etc.)\n    // TODO 3: In child process: pivot to new root filesystem, mount /proc, setup environment\n    // TODO 4: In child process: join container cgroup, drop to non-root user if specified\n    // TODO 5: In child process: exec the container command (this replaces clone child)\n    // TODO 6: In parent process: update container state to \"running\", save PID\n    // Hint: Use cmd.SysProcAttr to set namespace clone flags\n    return fmt.Errorf(\"not implemented\")\n}\n\n// StopContainer terminates container process and performs cleanup\nfunc (m *Manager) StopContainer(containerID string) error {\n    // TODO 1: Find container state and validate it's running\n    // TODO 2: Send SIGTERM to container process, wait for graceful shutdown\n    // TODO 3: If process doesn't exit in 10 seconds, send SIGKILL\n    // TODO 4: Wait for process to exit and capture exit code\n    // TODO 5: Update container state to \"stopped\" with exit code\n    // TODO 6: Clean up temporary resources (but keep overlay layers for restart)\n    return fmt.Errorf(\"not implemented\")\n}\n\n// RemoveContainer performs full cleanup of stopped container\nfunc (m *Manager) RemoveContainer(containerID string) error {\n    // TODO 1: Verify container is stopped (not running)\n    // TODO 2: Unmount overlay filesystem layers\n    // TODO 3: Remove cgroup directory (this also kills any remaining processes)\n    // TODO 4: Clean up network namespace and veth interfaces\n    // TODO 5: Remove container state directory and all associated files\n    // TODO 6: Remove container from in-memory store\n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n**Language-Specific Implementation Hints:**\n\n**Go System Call Interface:**\n- Use `golang.org/x/sys/unix` package for low-level system calls rather than the standard `syscall` package\n- Container process creation requires `exec.Cmd` with `SysProcAttr.Cloneflags` set to namespace flags\n- File descriptor handling: always defer close() calls and check for errors\n- Cgroup operations are just filesystem writes to `/sys/fs/cgroup/` - no special API needed\n\n**Error Handling Patterns:**\n- Wrap system call errors with context: `fmt.Errorf(\"failed to mount overlay: %w\", err)`\n- For cleanup operations, continue cleanup even if individual steps fail, but accumulate errors\n- Use `defer` functions for resource cleanup, but handle errors explicitly\n\n**Concurrency Considerations:**\n- Container operations can be concurrent, but individual container state changes should be atomic\n- Use `sync.Mutex` to protect the container store map from concurrent access\n- Child processes inherit parent's file descriptors - be careful about resource leaks\n\n**Milestone Checkpoints:**\n\nAfter implementing each component, verify functionality with these concrete tests:\n\n**Milestone 1 Checkpoint (Namespaces):**\n```bash\n# Test PID namespace isolation\nsudo go run cmd/runtime/main.go create --spec examples/busybox.json\nsudo go run cmd/runtime/main.go start busybox-test\n# Inside container, 'ps aux' should show only container processes\n# Container PID 1 should be your container command, not init\n\n# Test mount namespace isolation  \n# Inside container, 'mount' should show only container mounts\n# Host filesystem should not be visible except through overlay\n```\n\n**Milestone 2 Checkpoint (Cgroups):**\n```bash\n# Test memory limits\necho '{\"memory\": 134217728}' > test-config.json  # 128MB limit\nsudo go run cmd/runtime/main.go create --spec test-config.json\n# Verify limit: cat /sys/fs/cgroup/container-test/memory.max should show 134217728\n\n# Test CPU limits  \n# Run CPU-intensive process in container, verify it doesn't exceed quota\n# Host 'top' should show container process respecting CPU limits\n```\n\n**Milestone 3 Checkpoint (Overlay Filesystem):**\n```bash\n# Test copy-on-write behavior\nsudo go run cmd/runtime/main.go start test-container\n# Inside container: echo \"test\" > /usr/local/test-file\n# After container stops, base image should be unchanged\n# Check upper layer contains the new file\nls -la /var/lib/container-runtime/overlay/test-container/upper/usr/local/\n```\n\n**Milestone 4 Checkpoint (Networking):**\n```bash\n# Test container connectivity\nsudo go run cmd/runtime/main.go create --network bridge --ports 8080:80 web-test\nsudo go run cmd/runtime/main.go start web-test\n# Container should get IP address in bridge subnet\n# Port 8080 on host should forward to port 80 in container\ncurl http://localhost:8080  # should reach container service\n```\n\n**Common Debugging Scenarios:**\n\n| Symptom | Likely Cause | Diagnosis Command | Fix |\n|---------|--------------|------------------|-----|\n| \"Operation not permitted\" on namespace creation | Missing CAP_SYS_ADMIN capability | `getcap $(which your-runtime)` | Run with sudo or set capabilities |\n| Container sees host processes | PID namespace not created properly | `ls -la /proc/self/ns/pid` in container | Check clone flags include CLONE_NEWPID |\n| \"No such file or directory\" after pivot_root | New root is not a mount point | `mount \\| grep new_root` | Bind mount new root to itself first |\n| Overlay mount fails | Work directory not empty | `ls -la workdir/` | Ensure work directory is empty before mount |\n| Network namespace setup fails | Bridge interface doesn't exist | `ip link show docker0` | Create bridge interface first |\n| Container process becomes zombie | Parent not reaping child | `ps aux \\| grep defunct` | Add proper signal handling and wait() |\n\nThis implementation guidance provides working infrastructure code and detailed skeleton functions that map directly to the conceptual understanding built in the main design sections. Focus your learning effort on implementing the TODO sections rather than building peripheral infrastructure from scratch.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** This section establishes the scope and boundaries for all milestones (1-4), defining what capabilities our container runtime will implement and what advanced features are intentionally excluded.\n\n### Mental Model: Building a Studio Apartment vs. a Luxury Hotel\n\nThink of our container runtime project like deciding between building a studio apartment versus a luxury hotel. A studio apartment has everything you need to live comfortably—a bed, kitchen, bathroom, and living space—but it doesn't have a concierge, room service, or a swimming pool. Similarly, our minimal container runtime will provide all the essential isolation and resource management features that make containers work, but we're deliberately excluding the complex operational features that production container platforms require.\n\nThis analogy helps frame our decision-making: every feature request gets evaluated with \"Is this essential plumbing (like water and electricity in an apartment) or is this a luxury amenity (like a hotel spa)?\" Essential plumbing goes in; luxury amenities are explicitly excluded to keep the learning focused on core concepts.\n\nThe key insight is that understanding how to build the studio apartment—the fundamental isolation primitives—gives you the knowledge to later understand how luxury hotels work. But trying to build the hotel first would overwhelm you with operational complexity before you understand why containers need isolation in the first place.\n\n### Functional Goals\n\nOur container runtime will implement four core capabilities that demonstrate the fundamental mechanisms underlying all container systems. These align directly with our four milestones and represent the minimum viable functionality for process isolation, resource control, filesystem layering, and network connectivity.\n\n#### Process Isolation Through Namespaces\n\nThe runtime will create isolated process environments using Linux namespaces, demonstrating how containers achieve the illusion of running on separate machines while sharing the same kernel. This capability forms the foundation of container security and process isolation.\n\n| Namespace Type | Isolation Provided | Implementation Goal |\n|---|---|---|\n| PID | Process ID space | Container sees itself as PID 1, cannot see host processes |\n| Mount | Filesystem view | Container has isolated filesystem tree, cannot access host mounts |\n| Network | Network interfaces and routing | Container has private network stack with virtual interfaces |\n| UTS | Hostname and domain name | Container can set its own hostname without affecting host |\n| User | User and group ID mapping | Container processes run with mapped UIDs for security |\n| IPC | Inter-process communication | Container has isolated message queues and shared memory |\n\nThe runtime will handle the complex namespace creation sequence, including proper ordering (user namespace must be created first), filesystem pivoting using `pivot_root`, and the critical `/proc` remounting that many container tutorials skip. This goal specifically targets understanding how processes can have completely different views of the same system resources.\n\n> **Design Insight:** Process isolation is not about virtualization—it's about perspective. The same kernel and hardware serve multiple isolated views of system resources. Understanding this perspective-based isolation is crucial for grasping container security models.\n\n#### Resource Control Using Cgroups\n\nThe runtime will enforce CPU, memory, and I/O limits using cgroups v2, demonstrating how containers prevent resource starvation and ensure predictable performance. This capability shows how multi-tenant systems maintain isolation not just for security, but for performance and reliability.\n\n| Resource Type | Control Mechanism | Enforcement Goal |\n|---|---|---|\n| Memory | `memory.max` hard limit | Container killed if it exceeds allocated memory |\n| CPU | `cpu.max` quota and period | Container CPU time limited to specified percentage |\n| I/O | `io.max` bandwidth limits | Container disk I/O throttled to prevent interference |\n| PIDs | `pids.max` process limit | Container cannot fork-bomb the host system |\n\nThe implementation will include resource usage monitoring through cgroup statistics files, graceful out-of-memory handling with configurable OOM behavior, and proper cgroup hierarchy management. This goal specifically targets understanding how the kernel enforces resource boundaries and how containers achieve predictable performance isolation.\n\n#### Filesystem Layering with OverlayFS\n\nThe runtime will implement copy-on-write filesystem semantics using overlayfs, demonstrating how container images achieve efficient storage and fast startup times. This capability shows how containers can share base images while maintaining isolated filesystem changes.\n\n![OverlayFS Layer Structure](./diagrams/overlayfs-structure.svg)\n\n| Layer Type | Purpose | Behavior |\n|---|---|---|\n| Base Image Layers | Read-only image content | Shared across containers, never modified |\n| Upper Layer | Container modifications | Captures all file changes during container lifetime |\n| Work Directory | OverlayFS metadata | Temporary space for overlay operations |\n| Merged View | Combined filesystem | What the container process sees as its root filesystem |\n\nThe implementation will handle multiple image layer stacking, proper mount option configuration for overlayfs, and complete cleanup of overlay mounts and directories when containers are removed. This goal specifically targets understanding how modern container systems achieve both efficiency (shared layers) and isolation (private changes).\n\n#### Basic Container Networking\n\nThe runtime will provide network connectivity using bridge networking with port mapping, demonstrating how containers communicate with each other and the external world while maintaining network namespace isolation. This capability shows how containers achieve network isolation without sacrificing connectivity.\n\n| Network Component | Function | Implementation Goal |\n|---|---|---|\n| veth Pair | Container-to-host connection | Virtual ethernet cable connecting container to host |\n| Bridge | Inter-container networking | Virtual switch allowing containers to communicate |\n| IP Assignment | Container addressing | Automatic IP allocation from configurable subnet |\n| Port Forwarding | External access | NAT rules mapping host ports to container services |\n| DNS Resolution | Name resolution | Configurable nameserver settings for container |\n\nThe implementation will create and manage veth pairs, configure bridge networking for multi-container communication, implement port mapping using iptables NAT rules, and handle proper cleanup of network interfaces and rules. This goal specifically targets understanding how containers maintain network isolation while enabling controlled connectivity.\n\n> **Architecture Decision: Bridge Networking Over Host Networking**\n> - **Context**: Containers need network connectivity while maintaining isolation from the host network stack\n> - **Options Considered**: \n>   - Host networking (share host network namespace)\n>   - Bridge networking (isolated namespace with virtual bridge)\n>   - Overlay networking (software-defined networking across hosts)\n> - **Decision**: Bridge networking with veth pairs\n> - **Rationale**: Bridge networking provides the right balance of isolation and simplicity for educational purposes. Host networking sacrifices isolation (containers see all host network interfaces), while overlay networking introduces complex distributed systems concepts that distract from core container isolation mechanisms.\n> - **Consequences**: Containers get network isolation and controlled connectivity, but we limit ourselves to single-host networking (no multi-host container communication).\n\n### Explicit Non-Goals\n\nUnderstanding what we will **not** build is equally important for keeping the project focused on learning container fundamentals. These non-goals represent production-grade features that would significantly increase complexity without proportionally increasing understanding of core isolation mechanisms.\n\n#### Image Distribution and Registry Management\n\nWe will **not** implement image pulling from remote registries, image caching, or image building capabilities. Our runtime will assume container images already exist as local directory structures or tar files that can be extracted locally.\n\n| Feature | Why Excluded | Learning Impact |\n|---|---|---|\n| Remote image pulling | Requires HTTP clients, authentication, and error handling for network failures | Distracts from isolation primitives with network programming |\n| Image caching | Requires content-addressable storage and garbage collection | Adds storage management complexity unrelated to containers |\n| Image building | Requires Dockerfile parsing and build context management | Separate problem domain from runtime execution |\n| Image signing/verification | Requires cryptographic libraries and PKI understanding | Security topic separate from isolation mechanisms |\n\nStudents will create simple local images by preparing directory structures with the files they want in their container filesystem. This keeps the focus on how overlayfs combines layers rather than how images are distributed across networks.\n\n#### Container Orchestration and Scheduling\n\nWe will **not** implement multi-container coordination, service discovery, rolling updates, or cluster management. Our runtime manages individual containers in isolation without understanding relationships between containers.\n\n| Feature | Why Excluded | Learning Impact |\n|---|---|---|\n| Service discovery | Requires distributed coordination and consensus algorithms | Adds distributed systems complexity |\n| Load balancing | Requires traffic routing and health checking | Network management separate from isolation |\n| Rolling updates | Requires deployment strategies and state management | Operations concern, not isolation primitive |\n| Resource scheduling | Requires cluster-wide resource tracking and optimization | Distributed systems problem |\n\nStudents will start containers individually and manage them through direct runtime commands. This keeps the focus on how a single container achieves isolation rather than how multiple containers work together in production systems.\n\n#### Production-Grade Security Features\n\nWe will **not** implement advanced security policies, capability management, or mandatory access controls. Our runtime will use basic user namespace mapping but exclude enterprise security features.\n\n| Feature | Why Excluded | Learning Impact |\n|---|---|---|\n| SELinux/AppArmor integration | Requires understanding mandatory access control systems | Security specialization separate from container basics |\n| Seccomp filters | Requires system call filtering and security policy languages | Advanced security topic |\n| Capability management | Requires deep Linux capability system knowledge | Security detail that obscures main learning objectives |\n| Runtime security scanning | Requires vulnerability databases and policy engines | Operations security concern |\n\nStudents will learn how user namespaces provide basic privilege separation, but advanced security policies are left for specialized security courses. This keeps the focus on how isolation works rather than how to secure it against sophisticated attacks.\n\n#### Advanced Networking Features\n\nWe will **not** implement overlay networks, service meshes, or multi-host networking. Our networking will be limited to single-host bridge networking with basic port forwarding.\n\n| Feature | Why Excluded | Learning Impact |\n|---|---|---|\n| Overlay networks | Requires distributed networking and tunnel management | Network virtualization separate from container isolation |\n| Service mesh integration | Requires sidecar proxy management and service discovery | Microservices architecture concern |\n| CNI plugin support | Requires plugin architecture and network policy management | Standardization complexity |\n| Multi-host networking | Requires cluster networking and distributed state | Distributed systems problem |\n\nStudents will connect containers through a simple bridge and access them through port forwarding. This demonstrates the core concept of network namespace isolation without the complexity of distributed networking.\n\n#### Performance Optimization and Scalability\n\nWe will **not** optimize for high-performance container startup, massive container density, or enterprise-scale resource management. Our runtime prioritizes code clarity over performance optimization.\n\n| Feature | Why Excluded | Learning Impact |\n|---|---|---|\n| Fast container startup | Requires optimization techniques that obscure basic operations | Performance engineering separate from learning isolation |\n| High container density | Requires resource optimization and sharing strategies | Production scalability concern |\n| Resource pooling | Requires complex resource management and sharing algorithms | Operations optimization |\n| Monitoring and metrics | Requires metrics collection and time-series storage | Observability tooling separate from core function |\n\nStudents will focus on correctness and understanding rather than performance. A container that takes 2 seconds to start but clearly demonstrates namespace creation is better for learning than one that starts in 50ms but hides the setup complexity.\n\n> **Design Insight:** Educational projects require ruthless scope discipline. Every feature that doesn't directly teach the core concepts is a potential distraction that prevents deep understanding of the fundamentals. Production systems need all these excluded features, but learning systems need focus.\n\n#### Backward Compatibility and Standards Compliance\n\nWe will **not** implement full OCI (Open Container Initiative) compatibility, Docker API compatibility, or support for legacy container formats. Our runtime will use simple configuration formats optimized for learning rather than industry standards.\n\n| Feature | Why Excluded | Learning Impact |\n|---|---|---|\n| OCI runtime spec compliance | Requires implementing complex specification details | Standards compliance distracts from core concepts |\n| Docker API compatibility | Requires REST API implementation and Docker protocol details | API design separate from isolation mechanisms |\n| Legacy format support | Requires supporting multiple image and config formats | Backward compatibility complexity |\n| Standardized logging | Requires structured logging and log driver architecture | Operational tooling concern |\n\nStudents will use simple JSON configuration files and direct command-line interaction with the runtime. This removes the cognitive load of learning industry specifications while focusing on the underlying isolation mechanisms that all standards ultimately implement.\n\n### Success Criteria and Validation\n\nOur functional goals will be validated through specific behavioral tests that demonstrate successful isolation and resource control. These criteria define what \"working\" means for each capability.\n\n| Goal | Success Criterion | Validation Method |\n|---|---|---|\n| Process Isolation | Container process sees itself as PID 1, cannot see host processes | Run `ps aux` inside container, verify only container processes visible |\n| Resource Control | Container respects memory limit and is killed when exceeded | Start container with 50MB limit, allocate 100MB, verify OOM kill |\n| Filesystem Layering | Changes inside container don't affect base image | Modify files in running container, verify base layer unchanged |\n| Network Connectivity | Container can reach external network and accept incoming connections | Ping external host from container, curl container service from host |\n\nThese validation methods provide concrete evidence that our runtime successfully implements container isolation without relying on complex testing infrastructure or production-scale scenarios.\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the goals and respecting the non-goals throughout the development process.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option (Avoid) |\n|---|---|---|\n| Configuration Format | JSON files with simple schemas | YAML with complex validation, OCI specs |\n| Namespace Creation | Direct `syscall.SyscallN()` calls | High-level abstraction libraries |\n| Filesystem Operations | `os` and `syscall` packages | Virtual filesystem libraries |\n| Network Management | `netlink` package for basic operations | CNI plugins, complex networking libraries |\n| Resource Monitoring | Direct cgroup file reading | Prometheus metrics, complex telemetry |\n| Error Handling | Simple error returns and logging | Complex error categorization, retries |\n\n#### Recommended File Structure\n\nOrganize the codebase to reflect the four main functional areas while avoiding the complexity that production systems require:\n\n```\ncontainer-runtime/\n├── cmd/\n│   └── container/\n│       └── main.go                    ← Simple CLI interface\n├── internal/\n│   ├── manager/\n│   │   ├── manager.go                 ← ContainerSpec and lifecycle coordination\n│   │   └── manager_test.go\n│   ├── namespace/\n│   │   ├── namespace.go               ← CreateNamespaces and pivot_root logic\n│   │   └── namespace_test.go\n│   ├── cgroup/\n│   │   ├── cgroup.go                  ← Resource limit enforcement\n│   │   └── cgroup_test.go\n│   ├── filesystem/\n│   │   ├── overlay.go                 ← MountOverlayFS implementation\n│   │   └── overlay_test.go\n│   └── network/\n│       ├── bridge.go                  ← veth and bridge management\n│       └── bridge_test.go\n├── examples/\n│   ├── alpine-image/                  ← Simple container image for testing\n│   └── container-config.json          ← Example ContainerSpec\n└── docs/\n    └── debugging-guide.md             ← Common issues and solutions\n```\n\nThis structure keeps related functionality together while avoiding the multi-layered abstractions that production runtimes use for extensibility.\n\n#### Core Data Structures\n\nDefine simple, focused data structures that capture the essential information without over-engineering for extensibility:\n\n```go\n// ContainerSpec represents the desired container configuration\ntype ContainerSpec struct {\n    ID          string            `json:\"id\"`\n    Image       string            `json:\"image\"`          // Local directory path\n    Command     []string          `json:\"command\"`\n    WorkingDir  string            `json:\"workingDir\"`\n    Environment map[string]string `json:\"environment\"`\n    Resources   ResourceLimits    `json:\"resources\"`\n    Network     NetworkConfig     `json:\"network\"`\n}\n\n// ResourceLimits defines cgroup resource constraints\ntype ResourceLimits struct {\n    Memory int64 `json:\"memory\"`  // bytes\n    CPU    int64 `json:\"cpu\"`     // CPU quota in microseconds per 100ms period\n    PIDs   int64 `json:\"pids\"`    // maximum number of processes\n}\n\n// NetworkConfig specifies container networking\ntype NetworkConfig struct {\n    PortMappings []PortMapping `json:\"portMappings\"`\n    DNS          []string      `json:\"dns\"`\n}\n```\n\n#### Scope Discipline Implementation\n\nThroughout development, apply these filters to avoid scope creep:\n\n**Filter 1: Core Learning Objective Test**\n> \"Does this feature directly teach namespace isolation, resource control, filesystem layering, or basic networking?\"\n\nIf the answer is no, the feature belongs in the non-goals category.\n\n**Filter 2: Complexity-to-Learning Ratio Test**  \n> \"Does implementing this feature require more than 50 lines of code unrelated to the core isolation mechanisms?\"\n\nIf yes, consider whether a simpler alternative achieves the same learning objective.\n\n**Filter 3: Production Readiness Test (Reverse Filter)**\n> \"Would this feature be required for production use?\"\n\nIf yes, and it's not in our functional goals, it likely belongs in non-goals. Our runtime should be educational, not production-ready.\n\n#### Milestone Checkpoints\n\nAfter implementing each functional goal, validate success using these concrete checkpoints:\n\n**Milestone 1 Checkpoint - Process Isolation:**\n```bash\n# Start container with simple command\n./container run examples/alpine-image /bin/sh\n\n# Inside container, verify isolation\nps aux          # Should only show container processes\nhostname        # Should show container-specific hostname\nmount           # Should show isolated mount namespace\n```\n\n**Milestone 2 Checkpoint - Resource Control:**\n```bash\n# Start container with memory limit\n./container run --memory=50MB examples/alpine-image stress --vm 1 --vm-bytes 100M\n\n# Verify OOM kill occurs\necho $?         # Should be non-zero exit code indicating kill\n```\n\n**Milestone 3 Checkpoint - Filesystem Layering:**\n```bash\n# Start container and modify filesystem\n./container run examples/alpine-image /bin/sh\n# Inside container: echo \"test\" > /tmp/container-file\n\n# Verify base image unchanged\nls examples/alpine-image/tmp/    # Should not contain container-file\n```\n\n**Milestone 4 Checkpoint - Networking:**\n```bash\n# Start container with port mapping\n./container run --port=8080:80 examples/alpine-image httpd -f\n\n# Test connectivity\ncurl localhost:8080             # Should reach container service\n```\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Feature Creep Through \"Just One More Thing\"**\n\nThe most common failure mode is gradually adding features that seem \"small\" but collectively violate the non-goals. Examples include:\n- Adding image format auto-detection (\"it's just checking file extensions\")\n- Implementing container logs (\"it's just redirecting stdout\")  \n- Adding health checks (\"it's just running a command periodically\")\n\n**Fix**: Maintain a strict feature log. Every addition must be explicitly justified against the functional goals and reviewed for scope creep.\n\n⚠️ **Pitfall: Over-Engineering for Extensibility**\n\nEducational code often becomes too abstract when developers anticipate future features that are in the non-goals list.\n\n**Fix**: Write the simplest code that demonstrates the concept. Prefer concrete implementations over abstract interfaces when the abstraction only serves excluded features.\n\n⚠️ **Pitfall: Incomplete Non-Goal Documentation**\n\nTeams often agree on non-goals but don't document them clearly, leading to scope debates during implementation.\n\n**Fix**: For every rejected feature request, add it to the non-goals list with a clear explanation of why it's excluded. This prevents re-litigation of scope decisions.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** This section establishes the overall system design for all milestones (1-4), showing how the runtime manager orchestrates namespace creation, resource control, filesystem layering, and networking components.\n\n### Mental Model: The Orchestra Conductor\n\nThink of our container runtime as an **orchestra conductor** managing a complex performance. Just as a conductor coordinates different instrument sections—strings, brass, woodwinds, and percussion—our runtime manager coordinates different isolation mechanisms: namespaces for process isolation, cgroups for resource limits, overlayfs for filesystem layering, and network components for connectivity.\n\nThe conductor doesn't play any instruments directly, but ensures each section comes in at the right time, plays in harmony, and follows the overall score. Similarly, our runtime manager doesn't implement the low-level kernel features directly, but orchestrates when namespaces get created, when cgroups are configured, when filesystems are mounted, and when network interfaces are established.\n\nJust as a conductor must handle mistakes gracefully—if the violins come in too early or the drums miss their cue—our runtime manager must handle partial failures where some components succeed while others fail, ensuring the entire system reaches a consistent state.\n\n![Container Runtime System Architecture](./diagrams/system-architecture.svg)\n\nOur container runtime architecture centers around a **Manager** component that orchestrates four specialized subsystems, each responsible for a different aspect of container isolation and resource management. This design follows the principle of separation of concerns, where each component has a clearly defined responsibility and well-defined interfaces for interaction with other components.\n\nThe architecture addresses the fundamental challenge of container runtimes: **coordinating multiple kernel-level isolation mechanisms** that must be set up in the correct order, configured consistently, and cleaned up properly when containers are removed. Each kernel feature—namespaces, cgroups, overlayfs, and network interfaces—has its own setup requirements, failure modes, and cleanup procedures.\n\n> **Decision: Component-Based Architecture with Central Orchestration**\n> - **Context**: Container creation involves coordinating multiple kernel features that must be configured in a specific sequence, with each step depending on the success of previous steps.\n> - **Options Considered**: \n>   1. Monolithic design with all logic in a single component\n>   2. Component-based design with central orchestrator\n>   3. Pipeline design with sequential processing stages\n> - **Decision**: Component-based design with central Manager orchestrating specialized components\n> - **Rationale**: This approach provides clear separation of concerns, making each component testable in isolation while maintaining centralized control over the complex sequencing requirements. The Manager can implement sophisticated error recovery since it has visibility into all component states.\n> - **Consequences**: Enables easier testing and debugging of individual isolation mechanisms, but requires careful interface design between components and adds complexity to the Manager's coordination logic.\n\nThe following table compares our architectural options:\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Monolithic | Simple control flow, easier debugging | Hard to test individual features, complex error recovery | No |\n| Component-based | Clear separation, testable components, extensible | Interface complexity, coordination overhead | **Yes** |\n| Pipeline | Natural sequential flow, easy to add stages | Rigid ordering, limited error recovery options | No |\n\n### Component Responsibilities\n\nEach component in our architecture owns a specific domain of container isolation, with clearly defined responsibilities and interfaces. The **Manager** serves as the central orchestrator, while specialized components handle the technical details of their respective kernel features.\n\n#### Manager Component\n\nThe **Manager** component acts as the central orchestrator for all container operations, implementing the primary API that external clients use to manage container lifecycles. It maintains the authoritative state of all active containers and coordinates the complex sequencing required for container creation, startup, shutdown, and cleanup.\n\n| Responsibility | Details | Component Interface |\n|----------------|---------|-------------------|\n| Container Lifecycle | Manages complete container lifecycle from creation through removal | `CreateContainer(spec)`, `StartContainer(id)`, `StopContainer(id)`, `RemoveContainer(id)` |\n| State Management | Tracks active containers, their PIDs, resource allocations, and cleanup requirements | `GetContainer(id)`, `ListContainers()` |\n| Operation Sequencing | Ensures components are called in correct order during container operations | Internal coordination with all components |\n| Error Recovery | Handles partial failures by cleaning up successfully created resources | Rollback procedures for each operation type |\n| Configuration Loading | Loads and validates container specifications from configuration files | `LoadContainerSpec(path)` |\n\nThe Manager maintains a **ContainerState** registry that tracks all active containers and their associated resources. This registry serves as the source of truth for cleanup operations and enables the Manager to handle system restarts by detecting orphaned resources.\n\n> The critical insight for the Manager design is that container operations are **transactions** across multiple kernel subsystems. Like database transactions, they must either complete fully or be rolled back completely, leaving no partial state that could cause resource leaks or inconsistent behavior.\n\n#### Namespace Handler Component\n\nThe **Namespace Handler** specializes in Linux namespace manipulation, creating isolated execution environments for container processes. It understands the subtle requirements and ordering constraints of different namespace types, handling the complex filesystem operations required for mount namespace isolation.\n\n| Namespace Type | Isolation Provided | Setup Requirements | Handler Responsibility |\n|----------------|-------------------|-------------------|----------------------|\n| PID | Process ID space isolation | Clone with `CLONE_NEWPID` | `CreatePIDNamespace()`, ensure container process becomes PID 1 |\n| Mount | Filesystem view isolation | Pivot root operation, /proc mounting | `CreateMountNamespace()`, `PivotRoot()`, mount essential filesystems |\n| Network | Network stack isolation | Create network namespace, configure interfaces | `CreateNetworkNamespace()`, coordinate with Network Manager |\n| UTS | Hostname and domain isolation | Set container hostname independently | `CreateUTSNamespace()`, `SetHostname()` |\n| User | User ID mapping and capabilities | Configure UID/GID mapping for unprivileged containers | `CreateUserNamespace()`, `ConfigureUIDMapping()` |\n\nThe Namespace Handler encapsulates the complex requirements for namespace setup, particularly the filesystem operations required for mount namespace isolation. It handles the **pivot_root** system call, which requires careful preparation of mount points and proper sequencing to avoid common failures.\n\n#### Cgroup Controller Component\n\nThe **Cgroup Controller** manages resource limits and monitoring using Linux cgroups v2, providing fine-grained control over CPU, memory, and I/O resources allocated to containers. It abstracts the complexity of the cgroup filesystem interface and provides high-level resource management operations.\n\n| Resource Type | Control Mechanism | Configuration Parameters | Controller Responsibility |\n|---------------|-------------------|-------------------------|--------------------------|\n| Memory | Hard and soft limits, OOM behavior | `memory.max`, `memory.high`, `memory.oom.group` | `SetMemoryLimit()`, `GetMemoryUsage()`, `ConfigureOOMBehavior()` |\n| CPU | Quota and period-based scheduling | `cpu.max`, `cpu.weight` | `SetCPULimit()`, `GetCPUUsage()` |\n| I/O | Bandwidth and IOPS limits | `io.max`, `io.weight` | `SetIOLimits()`, `GetIOStats()` |\n| PIDs | Maximum process count | `pids.max` | `SetPIDLimit()`, `GetPIDCount()` |\n\nThe Cgroup Controller handles the hierarchical nature of cgroups, creating per-container cgroup directories under a runtime-managed hierarchy. It provides resource monitoring capabilities that enable the Manager to detect resource pressure and implement proactive management policies.\n\n> **Decision: Cgroups v2 Unified Hierarchy**\n> - **Context**: Linux systems support both cgroups v1 (legacy) and v2 (unified hierarchy), with different interfaces and capabilities.\n> - **Options Considered**:\n>   1. Support only cgroups v1 for maximum compatibility\n>   2. Support only cgroups v2 for modern features\n>   3. Dual support with runtime detection\n> - **Decision**: Target cgroups v2 unified hierarchy exclusively\n> - **Rationale**: Cgroups v2 provides a cleaner interface, better resource isolation, and is the future direction for Linux. Most modern systems support v2, and the complexity of dual support outweighs compatibility benefits for an educational runtime.\n> - **Consequences**: Requires Linux 4.5+ with cgroups v2 enabled, but provides cleaner implementation and better resource control features.\n\n#### Filesystem Manager Component\n\nThe **Filesystem Manager** implements image layering using overlayfs, providing copy-on-write semantics that enable efficient container filesystem isolation. It manages the complex directory structure required by overlayfs and handles layer composition from multiple image layers.\n\n| Operation | Purpose | Implementation Details | Manager Responsibility |\n|-----------|---------|----------------------|----------------------|\n| Layer Preparation | Extract and prepare image layers | Create directory structure for lower layers | `PrepareImageLayers(imageID)` |\n| Overlay Mounting | Combine layers into unified view | Mount overlayfs with proper options | `MountOverlayFS(layers, target)` |\n| Copy-on-Write | Handle file modifications efficiently | Ensure changes stay in upper layer | Transparent through overlayfs |\n| Cleanup | Remove overlay mounts and directories | Unmount and clean up layer directories | `CleanupContainer(containerID)` |\n\nThe Filesystem Manager maintains a **layer cache** that tracks extracted image layers, enabling layer reuse across multiple containers that share common base images. This significantly reduces storage overhead and container startup time.\n\nThe component handles the specific requirements of overlayfs, including the need for separate upper, work, and lower directories, and the requirement that the work directory be on the same filesystem as the upper directory for atomic operations.\n\n#### Network Manager Component\n\nThe **Network Manager** implements container networking using virtual ethernet pairs and bridge networking, providing network isolation while enabling both inter-container communication and external connectivity. It manages IP address allocation and implements port forwarding using iptables NAT rules.\n\n| Networking Feature | Implementation | Configuration | Manager Responsibility |\n|-------------------|----------------|---------------|----------------------|\n| Container Isolation | Create network namespace per container | Coordinate with Namespace Handler | `CreateContainerNetwork()` |\n| Inter-container Communication | Bridge networking with veth pairs | Create and configure bridge interface | `SetupBridge()`, `ConnectContainer()` |\n| IP Address Management | Subnet-based IP allocation | CIDR pool for automatic assignment | `AllocateIP()`, `ReleaseIP()` |\n| External Connectivity | NAT rules for port forwarding | iptables rules for host-to-container access | `ConfigurePortForwarding()` |\n| DNS Resolution | Configure container DNS settings | Set up /etc/resolv.conf in container | `ConfigureDNS()` |\n\nThe Network Manager coordinates closely with the Namespace Handler to ensure network namespaces are created before network interfaces are configured. It maintains an **IP allocation registry** to prevent address conflicts and enable proper cleanup when containers are removed.\n\n> The key architectural challenge for networking is that network configuration spans multiple namespaces—host and container—requiring careful coordination of operations that occur in different network contexts.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Component Initialization Order**\nMany developers assume components can be initialized independently, but container creation requires strict ordering. For example, the mount namespace must be created before overlayfs can be mounted, and network namespace must exist before veth pairs can be configured. The Manager must enforce these dependencies explicitly.\n\n⚠️ **Pitfall: Shared State Between Components**\nComponents that share state directly create tight coupling and make error recovery difficult. Each component should own its state completely, communicating with other components only through the Manager's coordination layer.\n\n⚠️ **Pitfall: Incomplete Error Recovery**\nWhen container creation fails partway through, developers often forget to clean up resources created by earlier components. Each component must provide cleanup methods that the Manager can call during error recovery, and these must be idempotent.\n\n⚠️ **Pitfall: Resource Leak on Manager Restart**\nIf the Manager process crashes, it loses track of active containers and their associated resources (cgroups, mount points, network interfaces). The Manager must implement startup recovery that scans for orphaned resources and either adopts or cleans them up.\n\n### Recommended File Structure\n\nThe codebase organization reflects our component-based architecture, with clear module boundaries that align with component responsibilities. This structure makes it easy to develop, test, and maintain each component independently while keeping integration points well-defined.\n\n![Cgroup v2 Hierarchy Structure](./diagrams/cgroup-hierarchy.svg)\n\n```\ncontainer-runtime/\n├── cmd/\n│   ├── runtime/\n│   │   └── main.go                    # Main runtime daemon entry point\n│   └── cli/\n│       └── main.go                    # Command-line client for runtime API\n├── internal/\n│   ├── manager/\n│   │   ├── manager.go                 # Central orchestrator component\n│   │   ├── container.go               # Container state management\n│   │   ├── config.go                  # Configuration loading and validation\n│   │   └── manager_test.go            # Integration tests for Manager\n│   ├── namespace/\n│   │   ├── handler.go                 # Namespace creation and management\n│   │   ├── mount.go                   # Mount namespace and pivot_root operations\n│   │   ├── types.go                   # Namespace type constants and structures\n│   │   └── handler_test.go            # Namespace operation unit tests\n│   ├── cgroup/\n│   │   ├── controller.go              # Cgroup v2 resource control\n│   │   ├── memory.go                  # Memory controller specific operations\n│   │   ├── cpu.go                     # CPU controller specific operations\n│   │   └── controller_test.go         # Cgroup management unit tests\n│   ├── filesystem/\n│   │   ├── overlay.go                 # OverlayFS mounting and layer management\n│   │   ├── layers.go                  # Image layer extraction and caching\n│   │   ├── cleanup.go                 # Filesystem cleanup operations\n│   │   └── overlay_test.go            # Filesystem operation unit tests\n│   ├── network/\n│   │   ├── manager.go                 # Network setup and configuration\n│   │   ├── bridge.go                  # Bridge networking implementation\n│   │   ├── veth.go                    # Virtual ethernet pair management\n│   │   ├── iptables.go                # NAT rules for port forwarding\n│   │   └── manager_test.go            # Network configuration unit tests\n│   └── types/\n│       ├── container.go               # ContainerSpec and ContainerState definitions\n│       ├── resources.go               # ResourceLimits and monitoring types\n│       └── network.go                 # NetworkConfig and PortMapping types\n├── pkg/\n│   ├── api/\n│   │   ├── runtime.go                 # Public API interfaces\n│   │   └── client.go                  # Client library for runtime API\n│   └── utils/\n│       ├── syscalls.go                # System call wrappers\n│       └── paths.go                   # Path manipulation utilities\n├── configs/\n│   ├── default.yaml                   # Default runtime configuration\n│   └── examples/\n│       ├── alpine.yaml                # Example Alpine container spec\n│       └── nginx.yaml                 # Example Nginx container spec\n├── test/\n│   ├── integration/\n│   │   ├── container_lifecycle_test.go # End-to-end container tests\n│   │   └── networking_test.go          # Multi-container networking tests\n│   └── fixtures/\n│       ├── test-images/               # Test container images\n│       └── configs/                   # Test configuration files\n└── docs/\n    ├── api.md                         # API documentation\n    └── troubleshooting.md             # Common issues and solutions\n```\n\nThe **internal/** directory contains all implementation components that are not exposed as public APIs. Each component has its own package with clearly defined interfaces, making it easy to develop and test components independently.\n\nThe **types/** package serves as a central location for all data structures shared between components, preventing circular dependencies while ensuring consistent type definitions across the codebase.\n\nThe **pkg/** directory contains public APIs that external clients can use to interact with our runtime, following Go conventions for library organization.\n\n> **Decision: Internal Package Organization**\n> - **Context**: Component interfaces need to be accessible to the Manager for orchestration, but shouldn't be exposed to external clients.\n> - **Options Considered**:\n>   1. All components in single package with public interfaces\n>   2. Separate packages with internal interfaces\n>   3. Separate packages with public interfaces in pkg/\n> - **Decision**: Separate internal packages with shared types package\n> - **Rationale**: This provides clear component boundaries while preventing external dependencies on internal implementation details. The shared types package avoids circular dependencies between component packages.\n> - **Consequences**: Enables independent component development and testing, but requires careful interface design to minimize coupling between packages.\n\n### Implementation Guidance\n\nOur component-based architecture requires careful attention to interface design and dependency management. The following guidance helps implement clean component boundaries while maintaining the flexibility needed for container runtime operations.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| IPC | Direct Go method calls within process | gRPC interfaces for potential distribution |\n| Configuration | YAML files with `gopkg.in/yaml.v3` | JSON Schema validation with structured configs |\n| Logging | Standard `log` package with structured output | `github.com/sirupsen/logrus` with contextual fields |\n| Error Handling | Standard Go error handling with wrapped errors | Custom error types with error codes and recovery hints |\n| State Storage | In-memory maps with file-based persistence | Embedded database like BoltDB for reliable state |\n| Testing | Standard `testing` package with table-driven tests | `github.com/stretchr/testify` for assertions and mocks |\n\n#### File Structure Implementation\n\nThe recommended file structure supports clean separation between components while maintaining clear integration points. Here's how to implement the core structure:\n\n```go\n// internal/types/container.go - Central type definitions\npackage types\n\n// ContainerSpec defines the desired state of a container\ntype ContainerSpec struct {\n    ID          string                 `yaml:\"id\" json:\"id\"`\n    Image       string                 `yaml:\"image\" json:\"image\"`\n    Command     []string               `yaml:\"command\" json:\"command\"`\n    WorkingDir  string                 `yaml:\"workdir\" json:\"workdir\"`\n    Environment map[string]string      `yaml:\"environment\" json:\"environment\"`\n    Resources   ResourceLimits         `yaml:\"resources\" json:\"resources\"`\n    Network     NetworkConfig          `yaml:\"network\" json:\"network\"`\n}\n\n// ContainerState tracks the runtime state of an active container\ntype ContainerState struct {\n    Spec         ContainerSpec    `json:\"spec\"`\n    Status       ContainerStatus  `json:\"status\"`\n    PID          int             `json:\"pid\"`\n    CreatedAt    time.Time       `json:\"created_at\"`\n    StartedAt    *time.Time      `json:\"started_at,omitempty\"`\n    CgroupPath   string          `json:\"cgroup_path\"`\n    OverlayPath  string          `json:\"overlay_path\"`\n    NetworkNS    string          `json:\"network_ns\"`\n    VethHost     string          `json:\"veth_host\"`\n    VethContainer string         `json:\"veth_container\"`\n    IPAddress    string          `json:\"ip_address\"`\n}\n\ntype ContainerStatus string\n\nconst (\n    StatusCreated ContainerStatus = \"created\"\n    StatusRunning ContainerStatus = \"running\"\n    StatusStopped ContainerStatus = \"stopped\"\n    StatusError   ContainerStatus = \"error\"\n)\n\n// ResourceLimits defines resource constraints for containers\ntype ResourceLimits struct {\n    Memory int64 `yaml:\"memory\" json:\"memory\"`     // bytes\n    CPU    int64 `yaml:\"cpu\" json:\"cpu\"`           // CPU quota in microseconds per 100ms period\n    PIDs   int64 `yaml:\"pids\" json:\"pids\"`         // maximum number of processes\n}\n\n// NetworkConfig defines networking configuration for containers\ntype NetworkConfig struct {\n    PortMappings []PortMapping `yaml:\"port_mappings\" json:\"port_mappings\"`\n    DNS          []string      `yaml:\"dns\" json:\"dns\"`\n}\n\n// PortMapping defines a host-to-container port forward\ntype PortMapping struct {\n    HostPort      int    `yaml:\"host_port\" json:\"host_port\"`\n    ContainerPort int    `yaml:\"container_port\" json:\"container_port\"`\n    Protocol      string `yaml:\"protocol\" json:\"protocol\"` // \"tcp\" or \"udp\"\n}\n```\n\n```go\n// internal/manager/manager.go - Core orchestration component\npackage manager\n\nimport (\n    \"container-runtime/internal/types\"\n    \"container-runtime/internal/namespace\"\n    \"container-runtime/internal/cgroup\"\n    \"container-runtime/internal/filesystem\"\n    \"container-runtime/internal/network\"\n)\n\n// Manager orchestrates container lifecycle operations across all subsystems\ntype Manager struct {\n    containers   map[string]*types.ContainerState\n    nsHandler    *namespace.Handler\n    cgroupCtrl   *cgroup.Controller\n    fsManager    *filesystem.Manager\n    netManager   *network.Manager\n    configDir    string\n    stateDir     string\n}\n\n// NewManager creates a new container runtime manager\nfunc NewManager(configDir, stateDir string) (*Manager, error) {\n    // TODO: Initialize all component managers\n    // TODO: Create necessary directories\n    // TODO: Load existing container state from persistence\n    // TODO: Perform startup recovery for orphaned resources\n    return nil, nil\n}\n\n// CreateContainer prepares a new container environment without starting it\nfunc (m *Manager) CreateContainer(spec *types.ContainerSpec) error {\n    // TODO: Validate container specification\n    // TODO: Check for container ID conflicts\n    // TODO: Create container state entry\n    // TODO: Prepare image layers through filesystem manager\n    // TODO: Create and configure cgroup through cgroup controller\n    // TODO: Create namespaces through namespace handler\n    // TODO: Set up network namespace through network manager\n    // TODO: Mount overlayfs through filesystem manager\n    // TODO: Persist container state\n    // TODO: Handle errors by cleaning up partial resources\n    return nil\n}\n\n// StartContainer begins execution of a created container\nfunc (m *Manager) StartContainer(id string) error {\n    // TODO: Validate container exists and is in created state\n    // TODO: Fork container process in prepared namespaces\n    // TODO: Add process to cgroup\n    // TODO: Configure network interfaces\n    // TODO: Execute container command\n    // TODO: Update container state to running\n    // TODO: Persist state change\n    return nil\n}\n\n// StopContainer gracefully terminates a running container\nfunc (m *Manager) StopContainer(id string) error {\n    // TODO: Validate container exists and is running\n    // TODO: Send SIGTERM to container process\n    // TODO: Wait for graceful shutdown with timeout\n    // TODO: Send SIGKILL if timeout exceeded\n    // TODO: Update container state to stopped\n    // TODO: Persist state change\n    return nil\n}\n\n// RemoveContainer cleans up all resources for a stopped container\nfunc (m *Manager) RemoveContainer(id string) error {\n    // TODO: Validate container exists and is stopped\n    // TODO: Unmount overlayfs through filesystem manager\n    // TODO: Clean up network configuration through network manager\n    // TODO: Remove cgroup through cgroup controller\n    // TODO: Clean up namespace resources\n    // TODO: Remove container state entry\n    // TODO: Clean up persistent state\n    return nil\n}\n\n// LoadContainerSpec loads container specification from YAML file\nfunc (m *Manager) LoadContainerSpec(path string) (*types.ContainerSpec, error) {\n    // TODO: Read YAML file\n    // TODO: Parse into ContainerSpec struct\n    // TODO: Validate required fields\n    // TODO: Set default values for optional fields\n    // TODO: Return parsed and validated spec\n    return nil, nil\n}\n```\n\n#### Component Interface Contracts\n\nEach component must implement specific interfaces that the Manager uses for orchestration. This ensures clean separation of concerns while maintaining coordinated behavior:\n\n```go\n// Component interfaces that each subsystem must implement\ntype NamespaceHandler interface {\n    CreateNamespaces(containerID string, flags NamespaceFlags) error\n    EnterNamespaces(containerID string) error\n    CleanupNamespaces(containerID string) error\n}\n\ntype CgroupController interface {\n    CreateCgroup(containerID string, limits types.ResourceLimits) error\n    AddProcess(containerID string, pid int) error\n    GetUsage(containerID string) (*ResourceUsage, error)\n    RemoveCgroup(containerID string) error\n}\n\ntype FilesystemManager interface {\n    PrepareContainer(containerID, imageID string) error\n    MountOverlayFS(containerID string, layers []string, target string) error\n    CleanupContainer(containerID string) error\n}\n\ntype NetworkManager interface {\n    CreateContainerNetwork(containerID string, config types.NetworkConfig) error\n    ConnectContainer(containerID string) error\n    DisconnectContainer(containerID string) error\n    CleanupNetwork(containerID string) error\n}\n```\n\n#### Milestone Checkpoints\n\n**Checkpoint 1: Architecture Setup**\nAfter implementing the basic file structure and Manager skeleton:\n- Run `go mod tidy && go build ./cmd/runtime/` - should compile without errors\n- Create a simple container spec YAML file in `configs/test.yaml`\n- Run `go test ./internal/types/` - basic type validation should pass\n- The Manager should be able to load container specs from YAML files\n\n**Checkpoint 2: Component Integration**\nAfter implementing component interfaces:\n- Each component package should compile independently\n- Run `go test ./internal/manager/` - Manager should instantiate all components\n- Mock implementations of component interfaces should allow testing Manager orchestration logic\n- The Manager should be able to coordinate component method calls in proper sequence\n\n**Checkpoint 3: Error Recovery**\nAfter implementing cleanup and error handling:\n- Test partial failure scenarios - create resources with some components, then trigger failures\n- Verify that Manager properly cleans up resources from successful components\n- Check that the system reaches consistent state after any failure\n- No resource leaks should remain after failed container creation attempts\n\nThis architecture provides the foundation for implementing each milestone's specific functionality while maintaining clean component boundaries and coordinated behavior across the entire container runtime system.\n\n\n## Data Model\n\n> **Milestone(s):** All milestones (1-4) rely on this data model. The container specification structures support milestone 1 (namespace configuration), milestone 2 (resource limits), milestone 3 (image and filesystem configuration), and milestone 4 (network configuration). The runtime state structures track the lifecycle and cleanup resources across all milestones.\n\nThe data model forms the foundation of our container runtime, defining how we represent container configurations, track runtime state, and manage the complex lifecycle of isolated processes. Think of the data model as the **architectural blueprints** for our container system - just as building blueprints specify every room, door, and utility connection before construction begins, our data structures define every piece of information needed to create, manage, and clean up containers before any code executes.\n\nThe data model serves two critical purposes in container runtime architecture. First, it provides a **declarative specification interface** where users describe what they want (run this command, with these resource limits, using this image) without needing to understand the complex orchestration of namespaces, cgroups, and filesystem operations underneath. Second, it maintains **runtime state tracking** that allows our system to properly manage the lifecycle of containers, ensuring clean startup sequences and comprehensive cleanup when containers terminate.\n\nContainer runtimes must juggle multiple kernel subsystems simultaneously - Linux namespaces for isolation, cgroups for resource control, overlayfs for layered filesystems, and network interfaces for connectivity. Each subsystem has its own configuration parameters, runtime handles, and cleanup requirements. Our data model abstracts this complexity into coherent structures that represent the user's intent and the system's current state.\n\n### Container Specification\n\nThe `ContainerSpec` structure defines the **declarative blueprint** for what a container should look like when running. This represents the user's intent - the desired end state - rather than the implementation details of how to achieve that state. Think of it as a **recipe card** that specifies all ingredients (image, resources, network settings) and basic instructions (command to run, environment variables) needed to create a container, while leaving the actual cooking process (namespace creation, cgroup setup, filesystem mounting) to the runtime implementation.\n\nThe container specification follows the principle of **immutable configuration** - once created, a spec should not change during the container's lifetime. This immutability simplifies reasoning about container behavior and enables reliable cleanup, since the runtime can always refer back to the original specification to understand what resources were allocated and need to be released.\n\n> **Decision: Separate Specification from Runtime State**\n> - **Context**: Container management requires both user intent (what should run) and current system state (what is actually running)\n> - **Options Considered**: \n>   1. Single structure mixing spec and state\n>   2. Separate spec and state structures\n>   3. Inheritance hierarchy with base container class\n> - **Decision**: Use separate `ContainerSpec` and `ContainerState` structures\n> - **Rationale**: Clear separation of concerns allows immutable specifications while enabling mutable state tracking. Simplifies serialization for persistence and makes the API clearer for users.\n> - **Consequences**: Requires careful coordination between spec and state, but provides better encapsulation and testing isolation.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| ID | string | Unique identifier for this container instance. Must be unique across all containers managed by this runtime. Used for filesystem paths, cgroup names, and cleanup tracking. |\n| Image | string | Path to the container image directory or identifier. For our minimal runtime, this points to a directory containing the root filesystem that will become the container's root. |\n| Command | []string | Command and arguments to execute inside the container. First element is the executable path (relative to container root), remaining elements are arguments passed to the process. |\n| WorkingDir | string | Working directory path inside the container where the command will be executed. Path is relative to the container's root filesystem. Defaults to \"/\" if not specified. |\n| Environment | map[string]string | Environment variables to set in the container process. Maps variable names to their values. These supplement (and can override) any environment variables from the base image. |\n| Resources | ResourceLimits | Resource constraints to apply to this container via cgroups. Defines memory limits, CPU quotas, and process limits that constrain container resource usage. |\n| Network | NetworkConfig | Network configuration specifying how this container connects to networks and exposes services. Includes port mappings and DNS settings. |\n\nThe `ID` field serves as the primary key for all container operations and becomes embedded in filesystem paths, cgroup hierarchies, and network interface names. Container IDs must be valid as directory names (no special characters that would break filesystem operations) and should be reasonably short to avoid hitting path length limits when combined with deep directory structures.\n\nThe `Image` field in our minimal implementation points to a local directory containing a complete root filesystem. Production container runtimes would extend this to support image references, layer manifests, and remote registries, but for learning purposes we focus on local filesystem images that can be easily inspected and modified during development.\n\nThe `Command` array follows POSIX conventions where the first element is the executable and subsequent elements are individual arguments. This differs from shell command lines - arguments containing spaces must be separate array elements rather than quoted strings. The runtime does not perform shell expansion or interpretation of the command elements.\n\n### Resource Limits Structure\n\nResource limits define the **resource budget** allocated to a container, implemented through Linux cgroups. Think of resource limits as setting a **spending allowance** for different types of system resources - just as a parent might give a child separate allowances for food, entertainment, and savings, cgroups let us set separate limits for memory consumption, CPU usage, and process creation.\n\n> **Decision: Explicit Resource Limit Fields vs Generic Map**\n> - **Context**: Need to represent different types of resource limits that will be enforced via cgroups\n> - **Options Considered**:\n>   1. Typed fields for each resource type (Memory, CPU, PIDs)\n>   2. Generic map[string]interface{} for flexibility\n>   3. Nested structures per cgroup controller\n> - **Decision**: Use explicit typed fields for core resource types\n> - **Rationale**: Type safety prevents configuration errors, clear API makes resource limits obvious, easier validation and documentation\n> - **Consequences**: Adding new resource types requires schema changes, but provides better user experience and prevents runtime errors\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| Memory | int64 | Maximum memory usage in bytes. Enforced via cgroup memory.max. Container processes will be killed if they exceed this limit. Zero means no limit. |\n| CPU | int64 | CPU quota in microseconds per 100ms period. Enforced via cgroup cpu.max. Value of 50000 means container gets 50% of one CPU core. Zero means no limit. |\n| PIDs | int64 | Maximum number of processes/threads this container can create. Enforced via cgroup pids.max. Prevents fork bombs and runaway process creation. Zero means no limit. |\n\nThe memory limit directly maps to the cgroups v2 `memory.max` file, which enforces a hard limit on memory usage. When a container approaches this limit, the kernel will start killing processes within the container's cgroup, typically starting with the most recently started processes. This provides strong isolation but can cause abrupt application failures if limits are set too low.\n\nCPU limits use the cgroups v2 bandwidth control system, which implements a quota over a fixed period. The period is typically 100 milliseconds (100000 microseconds), and the quota specifies how many microseconds of CPU time the container can use within each period. A quota of 50000 microseconds in a 100000 microsecond period means the container gets 50% of one CPU core.\n\nProcess limits prevent containers from exhausting the system's process table through fork bombs or poorly written applications that leak processes. The limit applies to the total number of tasks (processes and threads) within the container's cgroup, providing protection against both accidental and malicious process creation.\n\n### Network Configuration Structure\n\nNetwork configuration defines how a container connects to networks and exposes services to the outside world. Think of network configuration as specifying the **mailing address and phone system** for your container - it determines how other containers and external systems can reach services running inside the container, and how the container reaches external resources.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| PortMappings | []PortMapping | List of port forwarding rules that expose container services on host ports. Each mapping creates NAT rules forwarding traffic from a host port to a container port. |\n| DNS | []string | DNS nameserver IP addresses for container name resolution. These servers will be configured in the container's /etc/resolv.conf file for hostname lookups. |\n\nThe port mappings implement **Network Address Translation (NAT)** using iptables rules that forward traffic from host network interfaces to the container's network namespace. This allows external clients to connect to services running inside containers by connecting to host ports, with the traffic automatically forwarded to the appropriate container ports.\n\nDNS configuration ensures that processes inside containers can resolve hostnames to IP addresses. Since containers run in isolated network namespaces, they cannot automatically inherit the host system's DNS configuration and must have explicit nameserver configuration.\n\n### Port Mapping Structure\n\nPort mappings define individual **traffic forwarding rules** that expose container services on the host network. Each port mapping creates a tunnel through the network isolation boundary, allowing external traffic to reach specific services inside containers.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| HostPort | int | Port number on the host where traffic will be received. Must be available (not already bound by another service). Range 1-65535. |\n| ContainerPort | int | Port number inside the container where the service is listening. This is the destination for forwarded traffic. Range 1-65535. |\n| Protocol | string | Network protocol for this port mapping. Typically \"tcp\" or \"udp\". Determines which iptables rules and traffic types this mapping handles. |\n\nPort mappings create a **bidirectional tunnel** through the network namespace isolation. Inbound traffic to the host port gets forwarded to the container port, and response traffic from the container port gets forwarded back to the original external client. This requires careful iptables rule management to ensure traffic flows correctly in both directions.\n\nThe protocol field determines which type of network traffic this mapping handles. TCP mappings create connection-oriented forwarding suitable for HTTP services, databases, and other stream-based protocols. UDP mappings create connectionless forwarding suitable for DNS, DHCP, and other packet-based protocols.\n\n### Runtime State\n\nThe `ContainerState` structure tracks the **current operational status** of a running container, maintaining all the runtime handles, resource paths, and metadata needed to manage and clean up container instances. Think of runtime state as the **active case file** for a container - it contains all the information needed to monitor, interact with, and eventually clean up a running container instance.\n\nRuntime state is **mutable and ephemeral** - it changes as containers start, run, and stop, and it does not need to persist across system restarts (since containers don't survive reboots in our minimal implementation). The state structure serves as a central registry of all system resources allocated to a container, enabling systematic cleanup when containers terminate.\n\nThe runtime state maintains **resource ownership tracking** - for every system resource allocated during container creation (cgroup directories, overlay mounts, network interfaces), the state structure records the identifiers and paths needed to clean up those resources. This prevents resource leaks and ensures containers can be completely removed from the system.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| Spec | ContainerSpec | The original container specification that created this instance. Provides immutable reference to user intent and configuration parameters. |\n| Status | ContainerStatus | Current lifecycle status of this container (Created, Running, Stopped, etc.). Determines which operations are valid and what cleanup is required. |\n| PID | int | Process ID of the main container process in the host PID namespace. Used for process management and cleanup. Zero if container is not running. |\n| CreatedAt | time.Time | Timestamp when container state was first created. Used for logging, monitoring, and container age calculations. |\n| StartedAt | *time.Time | Timestamp when container process was started, or nil if never started. Pointer allows distinction between \"never started\" and \"started at Unix epoch\". |\n| CgroupPath | string | Full filesystem path to this container's cgroup directory (e.g., \"/sys/fs/cgroup/container-123\"). Used for resource limit enforcement and cleanup. |\n| OverlayPath | string | Full filesystem path to the overlay mount point for this container's root filesystem. Must be unmounted during cleanup to prevent resource leaks. |\n| NetworkNS | string | Path to the network namespace file in /proc (e.g., \"/proc/123/ns/net\"). Used for network operations and cleanup. |\n| VethHost | string | Name of the veth interface in the host network namespace (e.g., \"veth123h\"). Must be deleted during cleanup. |\n| VethContainer | string | Name of the veth interface inside the container network namespace (e.g., \"eth0\"). Automatically cleaned up when namespace is destroyed. |\n| IPAddress | string | IP address assigned to this container's network interface. Used for connectivity and must be returned to the address pool during cleanup. |\n\nThe embedded `Spec` field provides **configuration consistency** - the runtime can always refer back to the original user intent when making decisions about resource management, cleanup, or status reporting. This embedded spec should never be modified after container creation, ensuring that the original configuration remains available throughout the container lifecycle.\n\nThe `PID` field represents the container's main process as seen from the host perspective. Even though the process sees itself as PID 1 inside its PID namespace, the host system assigns it a regular PID that we use for process management operations like sending signals or checking process status.\n\nPath-based fields (`CgroupPath`, `OverlayPath`, `NetworkNS`) provide the **cleanup roadmap** - they contain all the filesystem paths that must be unmounted, removed, or cleaned up when the container terminates. These paths are determined during container creation and remain stable throughout the container's lifetime.\n\nNetwork-related fields (`VethHost`, `VethContainer`, `IPAddress`) track the **network plumbing** created for this container. The host veth interface must be explicitly deleted during cleanup, while the container veth interface is automatically cleaned up when the network namespace is destroyed. The IP address must be returned to the available address pool so it can be reused by future containers.\n\n### Container Status Enumeration\n\nContainer status represents the current **lifecycle stage** of a container instance, determining which operations are valid and what state transitions are possible. This follows a simple state machine that mirrors the typical container lifecycle from creation through cleanup.\n\n| Status Value | Description | Valid Transitions | Cleanup Required |\n|-------------|-------------|-------------------|------------------|\n| Created | Container resources allocated but process not started | → Running, → Stopped | Full cleanup (cgroups, filesystem, network) |\n| Running | Container process actively executing | → Stopped | Process termination + full cleanup |\n| Stopped | Container process terminated but resources not cleaned | → Removed | Full cleanup (cgroups, filesystem, network) |\n| Removed | Container completely cleaned up and removed | None (terminal state) | None |\n\nThe status progression typically follows: Created → Running → Stopped → Removed, though containers can transition directly from Created to Stopped if they fail to start, or from Running to Removed if they are forcibly deleted while running.\n\n### Common Data Model Pitfalls\n\n⚠️ **Pitfall: Mixing Configuration with Runtime State**\nMany developers initially put runtime-specific fields like PIDs and paths directly into the container specification structure. This breaks the separation between user intent (what should run) and system state (what is actually running). Keep the `ContainerSpec` immutable and put all runtime tracking in `ContainerState`.\n\n⚠️ **Pitfall: Forgetting Resource Cleanup Tracking**\nThe runtime state must track every system resource allocated during container creation. Forgetting to record filesystem paths, network interface names, or cgroup paths leads to resource leaks when containers are removed. Always add cleanup tracking fields to `ContainerState` when introducing new resource types.\n\n⚠️ **Pitfall: Using Host-Relative Paths in Container Specs**\nContainer specifications should use container-relative paths for working directories and command paths, not host system paths. The `WorkingDir` field should be \"/app\" not \"/var/lib/containers/container-123/rootfs/app\" - the runtime handles the translation to host paths during execution.\n\n⚠️ **Pitfall: Insufficient Container ID Validation**\nContainer IDs become embedded in filesystem paths and network interface names, so they must be validated to ensure they don't contain characters that would break these systems. Reject IDs containing \"/\", \".\", \"..\", or other special characters that could cause path traversal or naming conflicts.\n\n### Implementation Guidance\n\nThe data model implementation requires careful attention to serialization, validation, and lifecycle management. The structures serve as both API contracts and internal state management, so they need to be robust against invalid input while remaining easy to work with programmatically.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Serialization | JSON with encoding/json package | Protocol Buffers with schema validation |\n| Validation | Manual field checks in constructors | Struct tags with validator library |\n| State Persistence | In-memory maps with JSON files | Embedded database like BoltDB |\n| ID Generation | UUID v4 with google/uuid | Collision-resistant with timestamp + random |\n\n#### Recommended File Structure\n\n```\ninternal/\n  types/\n    container.go           ← Core data structures\n    container_test.go      ← Structure validation tests\n    validation.go          ← Input validation functions\n    validation_test.go     ← Validation test cases\n  runtime/\n    state_manager.go       ← Container state tracking\n    state_manager_test.go  ← State management tests\n```\n\n#### Core Data Structures\n\n```go\npackage types\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"path/filepath\"\n    \"regexp\"\n    \"strings\"\n    \"time\"\n)\n\n// ContainerSpec defines the desired configuration for a container instance.\n// This structure is immutable after creation and represents user intent.\ntype ContainerSpec struct {\n    // ID uniquely identifies this container instance\n    ID string `json:\"id\"`\n    \n    // Image specifies the root filesystem for the container\n    Image string `json:\"image\"`\n    \n    // Command and arguments to execute in the container\n    Command []string `json:\"command\"`\n    \n    // WorkingDir sets the initial working directory (container-relative path)\n    WorkingDir string `json:\"working_dir,omitempty\"`\n    \n    // Environment variables for the container process\n    Environment map[string]string `json:\"environment,omitempty\"`\n    \n    // Resource limits enforced via cgroups\n    Resources ResourceLimits `json:\"resources,omitempty\"`\n    \n    // Network configuration for connectivity and port exposure\n    Network NetworkConfig `json:\"network,omitempty\"`\n}\n\n// ResourceLimits defines cgroup-enforced resource constraints\ntype ResourceLimits struct {\n    // Memory limit in bytes (0 = no limit)\n    Memory int64 `json:\"memory,omitempty\"`\n    \n    // CPU quota in microseconds per 100ms period (0 = no limit) \n    CPU int64 `json:\"cpu,omitempty\"`\n    \n    // Maximum number of processes/threads (0 = no limit)\n    PIDs int64 `json:\"pids,omitempty\"`\n}\n\n// NetworkConfig specifies container networking requirements\ntype NetworkConfig struct {\n    // Port mappings for service exposure\n    PortMappings []PortMapping `json:\"port_mappings,omitempty\"`\n    \n    // DNS nameservers for hostname resolution\n    DNS []string `json:\"dns,omitempty\"`\n}\n\n// PortMapping defines a single port forwarding rule\ntype PortMapping struct {\n    // Host port to listen on\n    HostPort int `json:\"host_port\"`\n    \n    // Container port to forward to\n    ContainerPort int `json:\"container_port\"`\n    \n    // Protocol (\"tcp\" or \"udp\")\n    Protocol string `json:\"protocol\"`\n}\n\n// ContainerState tracks the runtime status of a container instance\ntype ContainerState struct {\n    // Original specification (immutable reference)\n    Spec ContainerSpec `json:\"spec\"`\n    \n    // Current lifecycle status\n    Status ContainerStatus `json:\"status\"`\n    \n    // Main process ID in host namespace (0 if not running)\n    PID int `json:\"pid\"`\n    \n    // Creation and start timestamps\n    CreatedAt time.Time  `json:\"created_at\"`\n    StartedAt *time.Time `json:\"started_at,omitempty\"`\n    \n    // Resource cleanup tracking\n    CgroupPath   string `json:\"cgroup_path,omitempty\"`\n    OverlayPath  string `json:\"overlay_path,omitempty\"`\n    NetworkNS    string `json:\"network_ns,omitempty\"`\n    VethHost     string `json:\"veth_host,omitempty\"`\n    VethContainer string `json:\"veth_container,omitempty\"`\n    IPAddress    string `json:\"ip_address,omitempty\"`\n}\n\n// ContainerStatus represents container lifecycle states\ntype ContainerStatus string\n\nconst (\n    ContainerCreated ContainerStatus = \"created\"\n    ContainerRunning ContainerStatus = \"running\" \n    ContainerStopped ContainerStatus = \"stopped\"\n    ContainerRemoved ContainerStatus = \"removed\"\n)\n```\n\n#### Validation Functions\n\n```go\n// ValidateContainerSpec checks a container specification for common errors\nfunc ValidateContainerSpec(spec *ContainerSpec) error {\n    // TODO 1: Validate container ID format (alphanumeric, hyphens, underscores only)\n    // TODO 2: Check that Image path exists and is accessible\n    // TODO 3: Validate Command has at least one element and first element is not empty\n    // TODO 4: Validate WorkingDir is absolute path starting with \"/\"\n    // TODO 5: Check Environment variable names don't contain \"=\" character\n    // TODO 6: Validate ResourceLimits are non-negative\n    // TODO 7: Validate PortMappings have valid port ranges (1-65535)\n    // TODO 8: Check DNS entries are valid IP addresses\n    return nil\n}\n\n// ValidateContainerID ensures ID can safely be used in filesystem paths\nfunc ValidateContainerID(id string) error {\n    // TODO 1: Check ID length is between 1 and 64 characters\n    // TODO 2: Verify ID matches pattern: alphanumeric, hyphens, underscores only\n    // TODO 3: Ensure ID doesn't start or end with hyphen or underscore\n    // TODO 4: Reject reserved names like \".\", \"..\", or system directory names\n    return nil\n}\n\n// ValidatePortMapping checks a single port mapping for validity\nfunc ValidatePortMapping(pm PortMapping) error {\n    // TODO 1: Validate HostPort is in range 1-65535\n    // TODO 2: Validate ContainerPort is in range 1-65535\n    // TODO 3: Check Protocol is either \"tcp\" or \"udp\"\n    // TODO 4: Verify HostPort is not in reserved range (1-1023) unless privileged\n    return nil\n}\n```\n\n#### State Management Helper\n\n```go\npackage runtime\n\n// StateManager handles container state persistence and lifecycle tracking\ntype StateManager struct {\n    // TODO: Add fields for state storage (map, file path, etc.)\n}\n\n// SaveContainerState persists container state to storage\nfunc (sm *StateManager) SaveContainerState(state *types.ContainerState) error {\n    // TODO 1: Serialize state to JSON\n    // TODO 2: Write to persistent storage (file, database, etc.)\n    // TODO 3: Ensure atomic write operation\n    // TODO 4: Handle storage errors gracefully\n    return nil\n}\n\n// LoadContainerState retrieves container state from storage\nfunc (sm *StateManager) LoadContainerState(id string) (*types.ContainerState, error) {\n    // TODO 1: Read state data from storage\n    // TODO 2: Deserialize JSON to ContainerState struct\n    // TODO 3: Validate loaded data integrity\n    // TODO 4: Return appropriate error if container not found\n    return nil, nil\n}\n\n// ListContainers returns all container states matching optional filter\nfunc (sm *StateManager) ListContainers(status types.ContainerStatus) ([]*types.ContainerState, error) {\n    // TODO 1: Load all container states from storage\n    // TODO 2: Filter by status if specified (empty status = return all)\n    // TODO 3: Sort results by creation time\n    // TODO 4: Return slice of matching containers\n    return nil, nil\n}\n\n// DeleteContainerState removes container state from storage\nfunc (sm *StateManager) DeleteContainerState(id string) error {\n    // TODO 1: Verify container exists in storage\n    // TODO 2: Remove state data from persistent storage\n    // TODO 3: Clean up any related temporary files\n    // TODO 4: Ensure deletion is atomic\n    return nil\n}\n```\n\n#### Language-Specific Implementation Notes\n\n**Go-specific considerations:**\n- Use `encoding/json` struct tags for API serialization control\n- Implement `String()` methods on enums like `ContainerStatus` for logging\n- Use pointer types (`*time.Time`) to distinguish between zero values and unset fields\n- Consider using `sync.RWMutex` for concurrent access to state maps\n- Validate file paths using `filepath.Clean()` to prevent directory traversal\n\n**Validation patterns:**\n- Use regular expressions for ID format validation: `^[a-zA-Z0-9]([a-zA-Z0-9_-]*[a-zA-Z0-9])?$`\n- Check port ranges with simple numeric comparisons: `port >= 1 && port <= 65535`\n- Validate IP addresses using `net.ParseIP()` from standard library\n- Use `os.Stat()` to verify image directory existence and permissions\n\n#### Milestone Checkpoint\n\nAfter implementing the data model structures:\n\n1. **Run unit tests**: `go test ./internal/types/...` should pass all validation tests\n2. **Test JSON serialization**: Create a container spec, marshal to JSON, unmarshal back, verify equality\n3. **Validate error handling**: Try invalid container IDs, port ranges, and paths - should get clear error messages\n4. **Check state transitions**: Verify container status can only transition through valid states\n\nExpected behavior:\n- Container specs with valid fields serialize/deserialize correctly\n- Invalid container IDs (with special characters) are rejected with descriptive errors\n- Port mappings outside 1-65535 range are rejected\n- Resource limits accept zero (unlimited) and positive values, reject negative values\n\nSigns of problems:\n- JSON marshaling panics → Check for circular references in embedded structs\n- Validation allows invalid input → Add more comprehensive test cases\n- File path operations fail → Ensure proper path cleaning and validation\n\n\n## Namespace Isolation Component\n\n> **Milestone(s):** Milestone 1 (Process Isolation with Namespaces) - This section implements the core isolation mechanisms that allow containers to have their own view of system resources while running on a shared kernel.\n\n### Mental Model: Separate Worlds\n\nThink of Linux namespaces as creating parallel universes for processes. Imagine you have a magical building where each apartment exists in its own dimension. From inside apartment 3B, the residents can only see their own rooms, their own mailbox labeled \"1\" (even though it's really mailbox 3B from the outside), and their own view out the windows. They have no idea that apartments 3A and 3C even exist - they think they're the only residents in the entire building.\n\nThis is exactly how namespaces work for container processes. When a process runs inside a container, it lives in its own isolated world where:\n\n- It thinks it's the only process running (PID namespace) and sees itself as process ID 1\n- It has its own private filesystem that looks like a complete Linux system (mount namespace) \n- It has its own network interfaces and IP addresses (network namespace)\n- It can set its own hostname without affecting other containers (UTS namespace)\n- It maps its user IDs differently from the host system (user namespace)\n\nThe crucial insight is that these parallel worlds are created by the Linux kernel, not by copying actual resources. The kernel maintains a single set of processes, files, and network interfaces, but it presents different views of these resources to processes in different namespaces. When a container process asks \"what processes are running?\", the kernel filters the answer to only show processes in the same PID namespace. When it asks \"what files exist in /bin?\", the kernel shows files from the container's mount namespace, not the host's /bin directory.\n\nThis isolation is both powerful and lightweight. Unlike virtual machines that duplicate entire operating systems, namespaces share the same kernel while providing complete isolation of the user-space view. The container process genuinely believes it's running on its own dedicated system, even though dozens of other containers might be running on the same physical machine.\n\n![Namespace Isolation Layers](./diagrams/namespace-isolation.svg)\n\n### Namespace Types and Setup\n\nLinux provides several namespace types, each isolating a different aspect of the system. Our container runtime needs to orchestrate the creation and configuration of multiple namespace types to provide complete process isolation.\n\n> **Decision: Namespace Combination Strategy**\n> - **Context**: Containers need isolation across multiple system resources (processes, filesystems, network, hostname, IPC). We must decide whether to create all namespaces together or incrementally.\n> - **Options Considered**: \n>   1. Create all namespaces atomically in a single system call\n>   2. Create namespaces incrementally as needed\n>   3. Create base namespaces first, then specialize\n> - **Decision**: Create all required namespaces atomically using a single `clone()` or `unshare()` call with combined flags\n> - **Rationale**: Atomic creation prevents race conditions where a process exists in some namespaces but not others. It also simplifies error handling - either all namespaces are created successfully, or the operation fails completely.\n> - **Consequences**: Simplifies the creation logic and eliminates partial failure states, but requires careful flag combination and may be less flexible for specialized container types.\n\n#### PID Namespace Isolation\n\nThe **PID namespace** creates an isolated process tree where the container's first process becomes PID 1. This is fundamental to container isolation because it prevents containers from seeing or signaling processes on the host system.\n\n| Aspect | Description | Implementation Detail |\n|--------|-------------|---------------------|\n| Isolation Scope | Process visibility and PID assignment | Container processes only see processes within their PID namespace |\n| Creation Flag | `CLONE_NEWPID` | Used with `clone()`, `unshare()`, or `setns()` system calls |\n| First Process | Becomes PID 1 in the new namespace | Critical for proper init semantics and signal handling |\n| Process Tree | Complete isolation from host process tree | `/proc` shows only namespace-local processes |\n| Signal Delivery | Signals cannot cross namespace boundaries | Prevents container processes from killing host processes |\n| Cleanup Behavior | Namespace destroyed when last process exits | Automatic cleanup prevents resource leaks |\n\nWhen we create a PID namespace, the first process spawned inside it becomes PID 1 from the container's perspective, even though it has a different PID on the host system. This PID 1 process has special responsibilities - it must reap zombie child processes and handle signals properly. If PID 1 dies, the entire namespace is destroyed and all processes within it are killed.\n\nThe namespace creation sequence follows this algorithm:\n\n1. The runtime manager calls `clone()` with `CLONE_NEWPID` flag to create a new PID namespace\n2. The kernel creates a new PID namespace and assigns the cloned process PID 1 within that namespace\n3. The process mounts a new `/proc` filesystem to show only namespace-local processes\n4. Any child processes spawned within the namespace receive PIDs 2, 3, etc. from the container's perspective\n5. The namespace persists until the last process within it exits\n\n#### Mount Namespace Isolation\n\nThe **mount namespace** provides each container with its own filesystem view, allowing containers to have different root filesystems, mount points, and filesystem hierarchies without affecting the host or other containers.\n\n| Aspect | Description | Implementation Detail |\n|--------|-------------|---------------------|\n| Isolation Scope | Filesystem mounts and hierarchy | Each namespace has independent mount table |\n| Creation Flag | `CLONE_NEWNS` | First namespace type introduced in Linux |\n| Root Filesystem | Container sees its own root directory | Achieved through `pivot_root()` or `chroot()` |\n| Mount Propagation | Controls how mounts spread between namespaces | Can be shared, slave, or private |\n| Filesystem View | Complete isolation of filesystem tree | Container `/bin` different from host `/bin` |\n| Cleanup Behavior | Mounts automatically unmounted when namespace dies | Prevents mount point leaks |\n\nMount namespaces are particularly complex because they interact with the overlayfs layer management system. The runtime must coordinate between creating the mount namespace, preparing the overlay filesystem layers, and then switching the container's root filesystem to point to the merged overlay view.\n\nThe mount namespace setup algorithm proceeds as follows:\n\n1. Create the mount namespace using `CLONE_NEWNS` flag during process creation\n2. Prepare the overlay filesystem by mounting the image layers (handled by the filesystem component)\n3. Create mount points for essential filesystems (`/proc`, `/sys`, `/dev`, `/tmp`)\n4. Execute `pivot_root()` to switch from the host root to the container root\n5. Mount essential pseudo-filesystems within the new root\n6. Unmount the old root filesystem to complete the isolation\n\n#### Network Namespace Isolation\n\nThe **network namespace** gives each container its own network stack, including network interfaces, IP addresses, routing tables, and firewall rules. This enables containers to have conflicting network configurations without interference.\n\n| Aspect | Description | Implementation Detail |\n|--------|-------------|---------------------|\n| Isolation Scope | Complete network stack isolation | Interfaces, routes, iptables rules, sockets |\n| Creation Flag | `CLONE_NEWNET` | Creates empty network namespace initially |\n| Initial State | Only loopback interface present | All other interfaces must be added explicitly |\n| Interface Assignment | Physical or virtual interfaces moved into namespace | Typically uses veth pairs |\n| IP Configuration | Independent IP addresses and routing | Configured via netlink or ip command |\n| Connectivity | Requires explicit bridge/routing setup | Handled by network management component |\n\nA new network namespace starts completely empty except for the loopback interface. This means containers have no network connectivity until we explicitly configure interfaces, IP addresses, and routing. The network management component handles creating veth pairs and connecting them to bridge networks.\n\nNetwork namespace setup follows this sequence:\n\n1. Create network namespace with `CLONE_NEWNET` during container process creation\n2. Network management component creates a veth pair (virtual ethernet cable)\n3. One end of veth pair moved into container namespace, other end remains on host\n4. Container end configured with IP address from allocated subnet\n5. Host end connected to bridge network for inter-container communication\n6. Routing rules configured to enable container network access\n\n#### UTS Namespace Isolation\n\nThe **UTS namespace** (UNIX Time Sharing) isolates hostname and domain name, allowing each container to have its own system identity without affecting the host or other containers.\n\n| Aspect | Description | Implementation Detail |\n|--------|-------------|---------------------|\n| Isolation Scope | Hostname and NIS domain name | System calls like `gethostname()` return namespace-local values |\n| Creation Flag | `CLONE_NEWUTS` | Lightweight namespace with minimal overhead |\n| Initial State | Inherits hostname from parent namespace | Can be changed independently afterward |\n| Configuration | Set via `sethostname()` system call | Typically set from container specification |\n| Use Cases | Service discovery, logging, application configuration | Many applications use hostname for identification |\n| Cleanup | Automatic when namespace destroyed | No persistent state to clean up |\n\nUTS namespaces are relatively simple but important for application compatibility. Many applications expect to run on systems with specific hostnames, and service discovery systems often use hostnames for routing and identification.\n\n#### User Namespace Isolation\n\nThe **user namespace** maps user and group IDs between the container and host system, enabling privilege separation and allowing containers to run as root inside the namespace while being unprivileged on the host.\n\n| Aspect | Description | Implementation Detail |\n|--------|-------------|---------------------|\n| Isolation Scope | User ID and group ID mappings | UID 0 inside container may be UID 1000 on host |\n| Creation Flag | `CLONE_NEWUSER` | Most complex namespace to configure correctly |\n| UID Mapping | Maps container UIDs to host UIDs | Written to `/proc/[pid]/uid_map` |\n| GID Mapping | Maps container GIDs to host GIDs | Written to `/proc/[pid]/gid_map` |\n| Capabilities | Grants capabilities within the namespace | Container root has limited capabilities on host |\n| Security Benefit | Unprivileged containers possible | Container breakout results in unprivileged host access |\n\nUser namespaces are crucial for security but complex to configure. They require setting up UID and GID mappings that define how user identities translate between the container and host perspectives.\n\n> **Architecture Decision: User Namespace Configuration**\n> - **Context**: User namespaces require complex UID/GID mapping setup and have implications for file permissions and capabilities\n> - **Options Considered**:\n>   1. Always enable user namespaces for maximum security\n>   2. Make user namespaces optional with configuration flag\n>   3. Skip user namespaces to simplify implementation\n> - **Decision**: Make user namespaces optional but provide clear configuration interface\n> - **Rationale**: User namespaces significantly improve security but add complexity and may cause permission issues with mounted volumes. Making them optional allows users to choose the right security/complexity tradeoff.\n> - **Consequences**: More secure when enabled but requires careful UID/GID mapping configuration. File ownership issues may arise when sharing files between host and container.\n\n### Namespace Creation Implementation\n\nThe namespace creation process requires careful coordination of multiple system calls and proper error handling to ensure consistent state.\n\n| Step | Action | System Call | Error Handling |\n|------|--------|-------------|----------------|\n| 1 | Prepare namespace flags | Bitwise OR of `CLONE_NEW*` constants | Validate flag combinations |\n| 2 | Create namespaces | `clone()` or `unshare()` | Clean up partial namespaces on failure |\n| 3 | Configure user mappings | Write to `/proc/[pid]/uid_map` | Verify mapping is valid and applied |\n| 4 | Set up network interfaces | `netlink` socket operations | Remove interfaces on failure |\n| 5 | Mount essential filesystems | `mount()` system calls | Unmount on failure |\n| 6 | Execute pivot_root | `pivot_root()` system call | Restore original root on failure |\n\nThe implementation must handle partial failures gracefully. If namespace creation succeeds but subsequent configuration fails, we must clean up the created namespaces to avoid resource leaks.\n\n### Filesystem Pivot Process\n\nThe filesystem pivot process switches the container's root filesystem from the host root to the container's isolated filesystem. This is more complex than a simple `chroot()` because it must handle overlayfs mounts and ensure proper cleanup of the old root.\n\n> **Decision: pivot_root vs chroot**\n> - **Context**: Need to change container's root filesystem to isolated overlay mount\n> - **Options Considered**:\n>   1. Use `chroot()` system call for simplicity\n>   2. Use `pivot_root()` system call for proper isolation\n>   3. Use bind mounts to create filesystem view\n> - **Decision**: Use `pivot_root()` for complete root filesystem replacement\n> - **Rationale**: `chroot()` is easily escaped by processes with sufficient privileges and doesn't properly isolate the old root. `pivot_root()` provides complete isolation and allows proper cleanup of the old root filesystem.\n> - **Consequences**: More complex implementation but much better security isolation. Requires careful mount point setup and cleanup procedures.\n\n#### Pivot Root Algorithm\n\nThe pivot root process must be executed in precise order to avoid mount point conflicts and ensure proper isolation:\n\n1. **Verify mount namespace isolation**: Confirm the container process is running in its own mount namespace, isolated from the host mount table. This prevents pivot_root operations from affecting the host filesystem.\n\n2. **Prepare overlay filesystem mount**: The filesystem management component must have already created the overlay mount combining image layers. Verify this mount exists and is accessible at the expected path (typically `/var/lib/container-runtime/overlay/[container-id]/merged`).\n\n3. **Create old root mount point**: Inside the new root filesystem, create a directory that will hold the old root temporarily. This is typically `/old-root` or `/mnt/old-root`. This directory must exist in the overlay filesystem before pivot_root.\n\n4. **Execute pivot_root system call**: Call `pivot_root(new_root, old_root)` where `new_root` is the overlay merged directory and `old_root` is the temporary mount point created in step 3. This atomically swaps the root filesystem.\n\n5. **Change working directory**: Immediately after pivot_root, change the current working directory to `/` in the new root to ensure no processes are holding references to the old root filesystem.\n\n6. **Mount essential pseudo-filesystems**: Mount `/proc`, `/sys`, `/dev`, and `/tmp` within the new root. These are essential for proper container operation and must be mounted after the pivot to ensure they reflect the container's namespace state.\n\n7. **Unmount old root**: Unmount the old root filesystem that is now accessible under the temporary mount point. This completes the isolation and prevents the container from accessing host filesystem paths.\n\n8. **Remove old root mount point**: Delete the temporary directory used to hold the old root, completing the cleanup process.\n\n#### Mount Point Requirements\n\nThe pivot_root operation has strict requirements that commonly cause failures:\n\n| Requirement | Explanation | Common Failure |\n|-------------|-------------|----------------|\n| New root must be a mount point | The target directory must be a filesystem mount, not just a directory | Using a regular directory causes `EINVAL` |\n| Old root must be under new root | The old root mount point must be a subdirectory of the new root | Placing old root outside new root causes `EINVAL` |\n| Both must be on different filesystems | New root and old root cannot be the same filesystem | Using bind mounts of same filesystem causes `EBUSY` |\n| No processes using old root | No process can have working directory or open files in old root | Active processes cause `EBUSY` |\n| Mount namespace must be private | Mount propagation must not affect other namespaces | Shared mounts can cause `EINVAL` |\n\n#### Essential Filesystem Mounts\n\nAfter pivot_root completes, the container needs several pseudo-filesystems mounted to function properly:\n\n| Mount Point | Filesystem Type | Purpose | Mount Options |\n|-------------|----------------|---------|---------------|\n| `/proc` | `proc` | Process information and system interfaces | `nosuid,nodev,noexec` |\n| `/sys` | `sysfs` | System device and driver information | `nosuid,nodev,noexec,ro` |\n| `/dev` | `tmpfs` | Device nodes for container | `nosuid,strictatime,mode=755` |\n| `/dev/pts` | `devpts` | Pseudo-terminal devices | `nosuid,noexec,newinstance,ptmxmode=0666` |\n| `/tmp` | `tmpfs` | Temporary file storage | `nosuid,nodev,noexec` |\n\nThe `/proc` mount is particularly critical because many container processes depend on `/proc/self/` for introspection and `/proc/[pid]/` for process management. Without proper `/proc` mounting, tools like `ps`, `top`, and many application health checks will fail.\n\n### Common Namespace Pitfalls\n\nNamespace creation and management involves several subtle failure modes that can cause containers to behave incorrectly or fail to start. Understanding these pitfalls helps avoid hours of debugging mysterious container failures.\n\n#### ⚠️ **Pitfall: Mount Point Requirements for pivot_root**\n\n**Problem**: The most common failure when implementing pivot_root is violating the kernel's strict requirements for the operation. The error message `EINVAL` from pivot_root provides no specific information about which requirement was violated.\n\n**Specific Failure Scenarios**:\n- Attempting pivot_root where the new root is not a mount point (just a regular directory)\n- Creating the old root directory outside the new root filesystem\n- Using the same filesystem for both old and new root (common with bind mounts)\n- Running pivot_root while processes have the old root as their working directory\n\n**Why This Breaks**: The kernel enforces these requirements to prevent filesystem inconsistencies and ensure proper cleanup. pivot_root must atomically swap roots while maintaining filesystem integrity.\n\n**Detection**: Check return value of pivot_root system call. `EINVAL` typically indicates requirement violation, `EBUSY` indicates active processes using the old root.\n\n**Fix Implementation**:\n1. Always ensure new root is a proper mount (overlayfs mount, not bind mount of directory)\n2. Create old root directory inside the new root before calling pivot_root  \n3. Use `fchdir()` to change working directory immediately before pivot_root\n4. Verify no child processes are running with old root as working directory\n\n#### ⚠️ **Pitfall: Missing /proc Mount in PID Namespace**\n\n**Problem**: After creating a PID namespace, many tools and applications break because `/proc` still shows the host's process tree instead of the container's isolated process view.\n\n**Specific Symptoms**:\n- `ps aux` shows all host processes instead of only container processes\n- Process tools report wrong PID numbers \n- Applications that read `/proc/self/` get incorrect information\n- Init systems fail to manage processes properly\n\n**Why This Breaks**: The `/proc` filesystem is not automatically updated when entering a new PID namespace. The old `/proc` mount continues to show the original namespace's process tree. Applications expect `/proc` to reflect the current namespace state.\n\n**Detection**: After namespace creation, check if `/proc/1/` exists and points to the container's init process, not a host process.\n\n**Fix Implementation**:\n1. Unmount existing `/proc` after entering PID namespace: `umount(\"/proc\")`\n2. Mount new proc for the namespace: `mount(\"proc\", \"/proc\", \"proc\", 0, NULL)`\n3. Verify mount shows correct PID namespace view by checking `/proc/1/` exists\n4. Ensure mount happens after pivot_root to get correct namespace perspective\n\n#### ⚠️ **Pitfall: User Namespace UID Mapping Race Condition**\n\n**Problem**: User namespaces start with no UID/GID mappings configured, during which time the process has no privileges and many operations fail with permission errors.\n\n**Specific Failure Scenarios**:\n- Process creation fails immediately after user namespace creation\n- File operations fail with `EACCES` even for files the process should access\n- Capability checks fail unexpectedly for operations that should succeed\n- Race condition where container process starts before UID mapping is written\n\n**Why This Breaks**: User namespaces begin in a state where no UIDs or GIDs are valid. The kernel rejects most privileged operations until `/proc/[pid]/uid_map` and `/proc/[pid]/gid_map` are properly configured.\n\n**Detection**: Check if UID mapping files are empty or missing after user namespace creation. Operations failing with `EACCES` immediately after namespace creation indicate mapping issues.\n\n**Fix Implementation**:\n1. Create user namespace but don't execute container command immediately\n2. Parent process writes UID mapping to `/proc/[child-pid]/uid_map`\n3. Parent process writes GID mapping to `/proc/[child-pid]/gid_map`  \n4. Use synchronization (pipe or signal) to ensure child waits for mapping completion\n5. Child process verifies mappings are applied before proceeding with container setup\n\n#### ⚠️ **Pitfall: Network Namespace Connectivity Loss**\n\n**Problem**: New network namespaces contain only a loopback interface, leaving containers with no network connectivity unless explicitly configured.\n\n**Specific Symptoms**:\n- Container cannot reach external networks or other containers\n- DNS resolution fails completely\n- Network tools show only `lo` interface\n- Applications fail with \"network unreachable\" errors\n\n**Why This Breaks**: Network namespace isolation is complete - containers get an empty network stack. Unlike other namespaces that inherit some functionality, network namespaces require explicit configuration for connectivity.\n\n**Detection**: Run `ip link show` inside container - should show only loopback interface if networking not configured properly.\n\n**Fix Implementation**:\n1. Create veth pair before container starts: one end for container, one for host\n2. Move container veth end into container's network namespace\n3. Configure IP address on container's veth interface  \n4. Connect host veth end to bridge network for routing\n5. Verify connectivity with ping test before declaring container ready\n\n#### ⚠️ **Pitfall: Incomplete Namespace Cleanup on Failure**\n\n**Problem**: When container creation fails partway through namespace setup, partially created namespaces may persist and leak resources or cause conflicts for subsequent containers.\n\n**Specific Failure Scenarios**:\n- Process dies after creating some namespaces but before joining all namespaces\n- Mount operations fail leaving orphaned mount points\n- Network interfaces created but not properly associated with namespaces\n- Cgroup directories created but not cleaned up when namespace creation fails\n\n**Why This Breaks**: Namespace creation involves multiple system calls that can fail independently. Each successful step allocates kernel resources that must be explicitly cleaned up if later steps fail.\n\n**Detection**: Check for orphaned mount points in `/proc/mounts`, unused network interfaces with `ip link show`, and leaked cgroup directories under `/sys/fs/cgroup/`.\n\n**Fix Implementation**:\n1. Track all created namespaces and resources in container state\n2. Implement rollback logic that undoes successful operations when later operations fail\n3. Use defer-style cleanup in implementation language to ensure cleanup runs\n4. Test failure scenarios explicitly to verify cleanup works correctly\n5. Monitor for resource leaks in integration tests\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Namespace Creation | Direct system calls with `golang.org/x/sys/unix` | Higher-level library like `github.com/opencontainers/runc/libcontainer` |\n| Mount Operations | Standard `mount()` syscalls | `github.com/moby/sys/mount` for advanced mount handling |\n| Process Management | `os.Process` with manual PID tracking | Process group management with `golang.org/x/sys/unix` |\n| Error Handling | Basic error checking and logging | Structured error types with detailed context |\n\n#### Recommended File Structure\n\nThe namespace isolation component should be organized as a focused module within the container runtime:\n\n```\ninternal/namespace/\n├── namespace.go           ← main namespace manager interface\n├── isolation.go          ← namespace creation and setup logic  \n├── pivot.go              ← filesystem pivot_root implementation\n├── cleanup.go            ← namespace cleanup and resource management\n├── types.go              ← namespace-related type definitions\n└── namespace_test.go     ← comprehensive namespace isolation tests\n\ninternal/container/\n├── manager.go            ← calls namespace component for isolation\n└── state.go              ← tracks namespace handles for cleanup\n\ncmd/container-runtime/\n└── main.go               ← integrates namespace manager\n```\n\n#### Infrastructure Starter Code\n\nThis complete namespace manager provides the foundational structure for namespace isolation:\n\n```go\n// internal/namespace/types.go\npackage namespace\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\n// NamespaceType represents different Linux namespace types\ntype NamespaceType int\n\nconst (\n    PIDNamespace NamespaceType = iota\n    MountNamespace\n    NetworkNamespace\n    UTSNamespace\n    UserNamespace\n    IPCNamespace\n)\n\n// NamespaceConfig defines which namespaces to create and their configuration\ntype NamespaceConfig struct {\n    EnablePID     bool\n    EnableMount   bool\n    EnableNetwork bool\n    EnableUTS     bool\n    EnableUser    bool\n    EnableIPC     bool\n    \n    // User namespace mappings\n    UIDMappings []UIDMapping\n    GIDMappings []GIDMapping\n    \n    // UTS configuration\n    Hostname string\n    Domain   string\n}\n\n// UIDMapping defines user ID mapping for user namespaces\ntype UIDMapping struct {\n    ContainerID uint32  // UID inside container\n    HostID      uint32  // UID on host system\n    Size        uint32  // Range of IDs to map\n}\n\n// GIDMapping defines group ID mapping for user namespaces  \ntype GIDMapping struct {\n    ContainerID uint32  // GID inside container\n    HostID      uint32  // GID on host system\n    Size        uint32  // Range of IDs to map\n}\n\n// NamespaceHandle tracks created namespaces for cleanup\ntype NamespaceHandle struct {\n    PID         int       // Process ID in new namespaces\n    NamespaceTypes []NamespaceType // Which namespaces were created\n    CreatedAt   time.Time // When namespaces were created\n    OverlayPath string    // Path to overlay filesystem mount\n    NetworkNS   string    // Network namespace identifier\n}\n```\n\n```go\n// internal/namespace/namespace.go\npackage namespace\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"golang.org/x/sys/unix\"\n)\n\n// Manager handles namespace creation and lifecycle\ntype Manager struct {\n    // Configuration\n    overlayRoot string\n    bridgeName  string\n    \n    // Runtime state\n    activeNamespaces map[string]*NamespaceHandle\n}\n\n// NewManager creates a new namespace manager\nfunc NewManager(overlayRoot, bridgeName string) *Manager {\n    return &Manager{\n        overlayRoot:      overlayRoot,\n        bridgeName:       bridgeName,\n        activeNamespaces: make(map[string]*NamespaceHandle),\n    }\n}\n\n// CreateNamespaces creates isolated namespaces according to configuration\nfunc (m *Manager) CreateNamespaces(containerID string, config *NamespaceConfig) (*NamespaceHandle, error) {\n    // Build namespace flags\n    flags := 0\n    var namespaceTypes []NamespaceType\n    \n    if config.EnablePID {\n        flags |= unix.CLONE_NEWPID\n        namespaceTypes = append(namespaceTypes, PIDNamespace)\n    }\n    if config.EnableMount {\n        flags |= unix.CLONE_NEWNS\n        namespaceTypes = append(namespaceTypes, MountNamespace)\n    }\n    if config.EnableNetwork {\n        flags |= unix.CLONE_NEWNET\n        namespaceTypes = append(namespaceTypes, NetworkNamespace)\n    }\n    if config.EnableUTS {\n        flags |= unix.CLONE_NEWUTS\n        namespaceTypes = append(namespaceTypes, UTSNamespace)\n    }\n    if config.EnableUser {\n        flags |= unix.CLONE_NEWUSER\n        namespaceTypes = append(namespaceTypes, UserNamespace)\n    }\n    if config.EnableIPC {\n        flags |= unix.CLONE_NEWIPC\n        namespaceTypes = append(namespaceTypes, IPCNamespace)\n    }\n    \n    // Create pipe for parent-child synchronization\n    readFD, writeFD, err := os.Pipe()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create sync pipe: %w\", err)\n    }\n    defer readFD.Close()\n    defer writeFD.Close()\n    \n    // Fork process with new namespaces\n    pid, err := unix.ForkExec(\"/proc/self/exe\", []string{\"container-runtime\", \"namespace-init\"}, \n        &unix.ProcAttr{\n            Files: []uintptr{0, 1, 2, writeFD.Fd()},\n            Sys:   &unix.SysProcAttr{Cloneflags: uintptr(flags)},\n        })\n    \n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create namespaces: %w\", err)\n    }\n    \n    handle := &NamespaceHandle{\n        PID:            pid,\n        NamespaceTypes: namespaceTypes,\n        CreatedAt:      time.Now(),\n        NetworkNS:      fmt.Sprintf(\"netns-%s\", containerID),\n    }\n    \n    // Configure user namespace mappings if enabled\n    if config.EnableUser {\n        if err := m.configureUserNamespace(pid, config.UIDMappings, config.GIDMappings); err != nil {\n            m.CleanupNamespaces(handle)\n            return nil, fmt.Errorf(\"failed to configure user namespace: %w\", err)\n        }\n    }\n    \n    // Signal child process that setup is complete\n    writeFD.Write([]byte(\"ready\"))\n    \n    m.activeNamespaces[containerID] = handle\n    return handle, nil\n}\n```\n\n#### Core Logic Skeleton Code\n\nThe following functions provide the structure for namespace isolation implementation:\n\n```go\n// internal/namespace/isolation.go\npackage namespace\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"golang.org/x/sys/unix\"\n)\n\n// configureUserNamespace sets up UID/GID mappings for user namespace\nfunc (m *Manager) configureUserNamespace(pid int, uidMaps []UIDMapping, gidMaps []GIDMapping) error {\n    // TODO 1: Open /proc/[pid]/uid_map file for writing\n    // TODO 2: Write each UID mapping in format \"container_id host_id size\\n\"\n    // TODO 3: Open /proc/[pid]/gid_map file for writing  \n    // TODO 4: Write each GID mapping in format \"container_id host_id size\\n\"\n    // TODO 5: Verify mappings were applied by reading back the files\n    // Hint: Must write \"deny\" to /proc/[pid]/setgroups before writing gid_map\n    \n    return fmt.Errorf(\"configureUserNamespace not implemented\")\n}\n\n// setupEssentialMounts creates required filesystem mounts in container\nfunc (m *Manager) setupEssentialMounts() error {\n    // TODO 1: Mount /proc filesystem with mount(\"proc\", \"/proc\", \"proc\", 0, \"\")\n    // TODO 2: Mount /sys filesystem read-only for container safety\n    // TODO 3: Create /dev as tmpfs and populate essential device nodes\n    // TODO 4: Mount /dev/pts for terminal support  \n    // TODO 5: Create /tmp as tmpfs for temporary file storage\n    // TODO 6: Verify all mounts succeeded and are accessible\n    // Hint: Use unix.Mount() with appropriate flags for each filesystem type\n    \n    return fmt.Errorf(\"setupEssentialMounts not implemented\")\n}\n\n// configureHostname sets container hostname in UTS namespace\nfunc (m *Manager) configureHostname(hostname, domain string) error {\n    // TODO 1: Validate hostname format (RFC compliance)\n    // TODO 2: Call unix.Sethostname() to set hostname in UTS namespace\n    // TODO 3: Call unix.Setdomainname() to set domain if provided\n    // TODO 4: Verify hostname was set by reading back with unix.Gethostname()\n    // Hint: Hostname changes only affect the current UTS namespace\n    \n    return fmt.Errorf(\"configureHostname not implemented\")\n}\n```\n\n```go\n// internal/namespace/pivot.go  \npackage namespace\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"golang.org/x/sys/unix\"\n)\n\n// ExecutePivotRoot switches container root filesystem using pivot_root\nfunc (m *Manager) ExecutePivotRoot(newRoot string) error {\n    // TODO 1: Verify newRoot is a mount point (check /proc/mounts)\n    // TODO 2: Create old root directory inside newRoot (typically /old-root)\n    // TODO 3: Change current directory to newRoot to avoid EBUSY\n    // TODO 4: Call unix.PivotRoot(newRoot, oldRootPath) system call\n    // TODO 5: Change directory to / in the new root filesystem  \n    // TODO 6: Unmount old root filesystem to complete isolation\n    // TODO 7: Remove old root directory to clean up mount point\n    // Hint: pivot_root requires new root to be mount point, old root under new root\n    \n    return fmt.Errorf(\"ExecutePivotRoot not implemented\")\n}\n\n// prepareOverlayMount creates overlay filesystem from image layers\nfunc (m *Manager) prepareOverlayMount(containerID string, layers []string) (string, error) {\n    // TODO 1: Create overlay directories: lower, upper, work, merged\n    // TODO 2: Format overlay mount options with lower layers separated by colons\n    // TODO 3: Mount overlayfs with mount(\"overlay\", merged, \"overlay\", 0, options)\n    // TODO 4: Verify merged directory shows combined layer content\n    // TODO 5: Return path to merged directory for use as new root\n    // Hint: Overlay options format: \"lowerdir=layer1:layer2,upperdir=upper,workdir=work\"\n    \n    return \"\", fmt.Errorf(\"prepareOverlayMount not implemented\")\n}\n\n// validateMountPoint checks if path is a filesystem mount point\nfunc (m *Manager) validateMountPoint(path string) error {\n    // TODO 1: Get filesystem stat info for the path\n    // TODO 2: Get filesystem stat info for path's parent directory  \n    // TODO 3: Compare device IDs - different devices means mount point\n    // TODO 4: Also check /proc/mounts for explicit mount entry\n    // Hint: Use unix.Stat() and compare st.Dev fields for device ID check\n    \n    return fmt.Errorf(\"validateMountPoint not implemented\")\n}\n```\n\n```go\n// internal/namespace/cleanup.go\npackage namespace\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"syscall\"\n    \"golang.org/x/sys/unix\"\n)\n\n// CleanupNamespaces removes container namespaces and associated resources\nfunc (m *Manager) CleanupNamespaces(handle *NamespaceHandle) error {\n    // TODO 1: Send SIGTERM to container process to request graceful shutdown\n    // TODO 2: Wait up to 10 seconds for process to exit voluntarily  \n    // TODO 3: Send SIGKILL if process hasn't exited after timeout\n    // TODO 4: Unmount overlay filesystem if it was mounted\n    // TODO 5: Remove overlay directories (upper, work, merged)\n    // TODO 6: Clean up any remaining mount points in namespace\n    // TODO 7: Remove handle from activeNamespaces map\n    // Hint: Use unix.Kill() for signals, unix.Wait4() for process cleanup\n    \n    return fmt.Errorf(\"CleanupNamespaces not implemented\")\n}\n\n// cleanupMounts removes all mounts associated with container\nfunc (m *Manager) cleanupMounts(overlayPath string) error {\n    // TODO 1: Read /proc/mounts to find all mounts under overlay path\n    // TODO 2: Unmount each mount point in reverse order (deepest first)\n    // TODO 3: Use MNT_DETACH flag for lazy unmounting if normal unmount fails\n    // TODO 4: Remove empty directories after successful unmount\n    // TODO 5: Verify no mount points remain under overlay path\n    // Hint: Must unmount child mounts before parent mounts to avoid EBUSY\n    \n    return fmt.Errorf(\"cleanupMounts not implemented\")\n}\n\n// killProcessTree terminates all processes in container namespace\nfunc (m *Manager) killProcessTree(pid int, signal syscall.Signal) error {\n    // TODO 1: Find all processes in same PID namespace as container\n    // TODO 2: Send specified signal to each process in namespace  \n    // TODO 3: Wait for processes to exit after SIGTERM\n    // TODO 4: Force kill with SIGKILL if processes don't exit gracefully\n    // TODO 5: Verify all namespace processes have exited\n    // Hint: Read /proc/[pid]/ns/pid to identify processes in same namespace\n    \n    return fmt.Errorf(\"killProcessTree not implemented\")\n}\n```\n\n#### Milestone Checkpoints\n\nAfter implementing the namespace isolation component, verify correct behavior with these checkpoints:\n\n**Checkpoint 1: PID Namespace Isolation**\n- Run: `go test -run TestPIDNamespace ./internal/namespace/`\n- Expected: Container process sees itself as PID 1, cannot see host processes\n- Manual test: Create container and run `ps aux` - should show only container processes\n- Failure signs: Seeing host processes indicates PID namespace not created or /proc not remounted\n\n**Checkpoint 2: Mount Namespace and Pivot Root**  \n- Run: `go test -run TestMountNamespace ./internal/namespace/`\n- Expected: Container has isolated filesystem view with overlay layers\n- Manual test: Container `/bin` should differ from host `/bin` directory\n- Failure signs: \"EINVAL from pivot_root\" means mount point requirements not met\n\n**Checkpoint 3: Network Namespace Isolation**\n- Run: `go test -run TestNetworkNamespace ./internal/namespace/`\n- Expected: Container starts with only loopback interface\n- Manual test: Run `ip link show` in container - should show only `lo` interface initially\n- Failure signs: Seeing host network interfaces means network namespace not created\n\n**Checkpoint 4: Complete Namespace Integration**\n- Run: `go test ./internal/namespace/`  \n- Expected: All namespace types work together without conflicts\n- Manual test: Start container with all namespaces and verify isolation\n- Failure signs: Resource leaks, mount point conflicts, or partial isolation indicate cleanup issues\n\n\n## Resource Control Component\n\n> **Milestone(s):** Milestone 2 (Resource Limits with Cgroups) - This section implements CPU, memory, and I/O limits using cgroups v2 for container resource control, along with resource monitoring and out-of-memory handling.\n\n### Mental Model: Resource Budget Manager\n\nThink of cgroups like a family budget manager that allocates monthly allowances to children. Just as parents set spending limits for each child (clothing budget, entertainment budget, snack budget), cgroups set resource limits for each container (memory budget, CPU budget, disk I/O budget). When a child tries to spend more than their allowance, the budget manager either denies the purchase or finds emergency funds from elsewhere. Similarly, when a container tries to use more resources than allocated, cgroups either deny the request (causing the process to wait or fail) or trigger emergency actions like killing the process.\n\nThe budget manager also tracks spending throughout the month, sending warnings when a child approaches their limit (\"You've spent 80% of your entertainment budget\"). Cgroups provide the same visibility, exposing current resource usage so the container runtime can monitor consumption and warn about approaching limits. Just as the family budget ensures no single child monopolizes the household income, cgroups ensure no single container starves other containers of system resources.\n\nThis analogy extends to hierarchical budgets: a family might allocate 40% of income to children's allowances, then subdivide that among individual children. Cgroups work similarly with hierarchical resource allocation, where you might dedicate 50% of system memory to containers, then divide that pool among individual containers based on their priority and requirements.\n\n### Cgroup Controller Configuration\n\nThe **cgroup controller configuration** component manages resource limits by interfacing with the Linux cgroups v2 unified hierarchy. Each controller manages a specific resource type and exposes configuration files in `/sys/fs/cgroup` that define limits, track usage, and trigger enforcement actions.\n\n> **Decision: Cgroups v2 Over Cgroups v1**\n> - **Context**: Linux systems support both cgroups v1 (legacy) and cgroups v2 (modern) interfaces for resource control, with different APIs and capabilities.\n> - **Options Considered**: Use cgroups v1 for broader compatibility, use cgroups v2 for modern features, support both versions with abstraction layer.\n> - **Decision**: Use cgroups v2 unified hierarchy exclusively.\n> - **Rationale**: Cgroups v2 provides unified hierarchy (single tree instead of per-controller trees), better memory accounting, improved CPU isolation, and simplified configuration. Modern distributions default to v2, and v1 is deprecated. The learning value comes from understanding modern kernel interfaces.\n> - **Consequences**: Requires kernel 4.5+ and systemd systems with cgroups v2 enabled. Simpler implementation with unified interface, but incompatible with older systems using v1-only setups.\n\n| Option | Pros | Cons | Chosen |\n|--------|------|------|---------|\n| Cgroups v1 | Broader compatibility, extensive documentation | Complex multi-hierarchy design, deprecated, limited features | No |\n| Cgroups v2 | Modern unified hierarchy, better accounting, future-proof | Requires newer kernels, some tools still v1-only | **Yes** |\n| Support Both | Maximum compatibility | Complex abstraction, doubles testing burden | No |\n\nThe cgroup controller system creates a dedicated cgroup for each container under `/sys/fs/cgroup/container-runtime/[container-id]` and enables specific controllers based on the container's `ResourceLimits` specification. The system writes configuration values to controller-specific files and monitors usage through statistics files.\n\n#### Memory Controller Configuration\n\nThe **memory controller** enforces memory limits using the `memory.max` interface, which provides hard memory capping with configurable out-of-memory behavior. When a container approaches its memory limit, the kernel memory reclaim system attempts to free memory through page cache eviction and swap-out. If reclaim cannot free sufficient memory, the OOM killer terminates processes within the cgroup.\n\n| Configuration File | Purpose | Format | Example Value |\n|-------------------|---------|---------|---------------|\n| `memory.max` | Hard memory limit | Integer bytes or \"max\" | `536870912` (512MB) |\n| `memory.high` | Soft limit triggering reclaim | Integer bytes or \"max\" | `402653184` (384MB) |\n| `memory.swap.max` | Swap space limit | Integer bytes or \"max\" | `134217728` (128MB) |\n| `memory.oom.group` | OOM kill entire cgroup | 0 or 1 | `1` |\n| `memory.current` | Current memory usage (read-only) | Integer bytes | `123456789` |\n| `memory.peak` | Peak memory usage since creation | Integer bytes | `234567890` |\n\nThe memory controller setup process follows these steps:\n1. Enable the memory controller by writing `+memory` to the parent cgroup's `cgroup.subtree_control` file\n2. Create the container-specific cgroup directory under the container runtime's cgroup hierarchy\n3. Write the hard memory limit from `ResourceLimits.Memory` to `memory.max`\n4. Set the soft limit to 75% of hard limit in `memory.high` to trigger early memory pressure\n5. Configure swap limits based on container specification or disable swap entirely for predictable behavior\n6. Enable group OOM killing to ensure related processes are cleaned up together\n\n> Memory limits without corresponding swap limits can allow containers to exceed their intended memory budget by using swap space. Always configure both memory.max and memory.swap.max for predictable resource enforcement.\n\n#### CPU Controller Configuration\n\nThe **CPU controller** implements CPU bandwidth limiting using the Completely Fair Scheduler (CFS) quota mechanism. Instead of CPU priority or weight-based sharing, the controller enforces hard CPU time limits by allocating specific microseconds of CPU time per scheduling period.\n\n| Configuration File | Purpose | Format | Example Value |\n|-------------------|---------|---------|---------------|\n| `cpu.max` | CPU quota and period | \"quota period\" or \"max\" | `50000 100000` (50% CPU) |\n| `cpu.weight` | Relative CPU share | Integer 1-10000 | `100` (normal weight) |\n| `cpu.stat` | CPU usage statistics | Multi-line key-value | `usage_usec 1234567` |\n| `cpuset.cpus` | Allowed CPU cores | CPU list format | `0-3` or `0,2,4` |\n| `cpuset.mems` | Allowed memory nodes | NUMA node list | `0` |\n\nThe CPU quota system works by defining a scheduling period (typically 100ms) and allocating a portion of that period to the container. A container with `cpu.max` set to `50000 100000` receives 50,000 microseconds of CPU time every 100,000 microseconds (50% of one CPU core). The CFS scheduler enforces this by throttling the container's processes when they exhaust their quota within the current period.\n\nCPU controller setup algorithm:\n1. Enable the CPU controller by writing `+cpu` to the parent cgroup's `cgroup.subtree_control` file\n2. Calculate CPU quota from `ResourceLimits.CPU` value (nanoseconds per second) to microseconds per 100ms period\n3. Write the quota and period to `cpu.max` in the format \"quota period\"\n4. Set CPU weight based on container priority (higher weight gets more CPU under contention)\n5. Configure CPU affinity using `cpuset.cpus` if the container should run on specific cores\n6. Set memory node affinity using `cpuset.mems` for NUMA-aware scheduling\n\nThe CPU limit calculation converts from nanoseconds-per-second to the CFS quota format. For example, a `ResourceLimits.CPU` value of 500,000,000 nanoseconds (0.5 CPU cores) becomes a quota of 50,000 microseconds per 100,000 microsecond period.\n\n#### Device Controller Configuration\n\nThe **device controller** restricts container access to device files under `/dev`, preventing containers from accessing host hardware directly unless explicitly permitted. This controller uses allow/deny lists with device type, major/minor numbers, and permission specifications.\n\n| Configuration File | Purpose | Format | Example Value |\n|-------------------|---------|---------|---------------|\n| `devices.allow` | Permit device access | \"type major:minor permissions\" | `c 1:3 rwm` (allow /dev/null) |\n| `devices.deny` | Restrict device access | \"type major:minor permissions\" | `b *:* rwm` (deny all block devices) |\n| `devices.list` | Current device permissions | Multi-line device specs | `c 1:3 rwm\\nc 1:5 rwm` |\n\nThe device controller starts with a deny-all policy and selectively permits access to essential devices that containers typically need. The standard device allowlist includes character devices for `/dev/null`, `/dev/zero`, `/dev/urandom`, and `/dev/random`, while denying access to block devices, raw devices, and hardware-specific character devices.\n\nDevice controller setup process:\n1. Enable the devices controller (automatically enabled in cgroups v2 when processes are added)\n2. Apply the default deny-all policy by writing `a *:* rwm` to `devices.deny`\n3. Allow essential character devices by writing entries to `devices.allow` for each permitted device\n4. Parse any additional device permissions from the container specification\n5. Write additional device allow rules based on container requirements (e.g., GPU access for ML containers)\n\nStandard container device allowlist:\n- `c 1:3 rwm` - `/dev/null` (null device)\n- `c 1:5 rwm` - `/dev/zero` (zero device)\n- `c 1:8 rwm` - `/dev/random` (random number generator)\n- `c 1:9 rwm` - `/dev/urandom` (non-blocking random)\n- `c 5:0 rwm` - `/dev/tty` (controlling terminal)\n- `c 5:2 rw` - `/dev/ptmx` (pseudoterminal master)\n- `c 136:* rw` - `/dev/pts/*` (pseudoterminal slaves)\n\n#### Cgroup Creation and Assignment Algorithm\n\nThe cgroup creation process establishes the resource control hierarchy and assigns the container process to the appropriate cgroup for enforcement. This process must handle race conditions, permission requirements, and cleanup on failure.\n\nContainer cgroup setup algorithm:\n1. **Validate cgroups v2 availability** by checking that `/sys/fs/cgroup/cgroup.controllers` exists and contains required controllers\n2. **Create runtime cgroup hierarchy** if it doesn't exist: `/sys/fs/cgroup/container-runtime/` with appropriate permissions\n3. **Enable controllers** by writing `+memory +cpu +pids` to `/sys/fs/cgroup/container-runtime/cgroup.subtree_control`\n4. **Create container cgroup** directory at `/sys/fs/cgroup/container-runtime/[container-id]/`\n5. **Configure memory limits** by writing `ResourceLimits.Memory` to `memory.max`\n6. **Configure CPU limits** by calculating and writing quota/period to `cpu.max`\n7. **Configure PID limits** by writing `ResourceLimits.PIDs` to `pids.max`\n8. **Configure device access** by setting up device allow/deny rules\n9. **Assign container process** by writing the container's PID to `cgroup.procs`\n10. **Verify assignment** by reading `cgroup.procs` and confirming the PID appears in the list\n\nThe process assignment step occurs after the container process starts but before it begins executing the user-specified command. The container runtime forks the container process, performs namespace setup, assigns it to the cgroup, then executes the target command. This ensures resource limits apply from the beginning of command execution.\n\n> ⚠️ **Pitfall: Process Assignment Timing**\n> Assigning a process to a cgroup after it has already consumed significant resources allows it to exceed limits during startup. Always assign processes to cgroups immediately after fork, before any significant work begins.\n\n### Resource Usage Monitoring\n\nThe **resource usage monitoring** system tracks current resource consumption by reading statistics from cgroup controller files and detecting when containers approach their configured limits. This monitoring enables the container runtime to implement early warning systems, automatic scaling decisions, and proactive resource management.\n\n> **Decision: Pull-Based Monitoring Over Event-Based**\n> - **Context**: Cgroups provide both polling-based monitoring (reading stat files) and event-based monitoring (using eventfd for threshold notifications).\n> - **Options Considered**: Periodic polling of cgroup stat files, event-based notifications using cgroup.events, hybrid approach with polling plus critical event notifications.\n> - **Decision**: Use periodic polling with configurable intervals for primary monitoring.\n> - **Rationale**: Polling provides consistent monitoring behavior, easier implementation, and better integration with existing monitoring systems. Event-based monitoring requires complex eventfd handling and may miss gradual resource increases. The polling overhead is minimal compared to container workloads.\n> - **Consequences**: Slight monitoring latency (up to polling interval) but simpler implementation. Requires tuning polling frequency to balance responsiveness with overhead.\n\n| Monitoring Approach | Pros | Cons | Chosen |\n|-------------------|------|------|---------|\n| Periodic Polling | Simple implementation, consistent behavior, integrates with standard monitoring | Fixed latency, potential overhead with frequent polling | **Yes** |\n| Event Notifications | Low latency, minimal overhead, kernel-driven | Complex eventfd handling, can miss gradual changes | No |\n| Hybrid Approach | Best of both worlds | Complex implementation, harder to debug | No |\n\n#### Memory Usage Monitoring\n\nMemory usage monitoring tracks both current consumption and memory pressure indicators to detect containers approaching their limits before OOM conditions occur. The monitoring system reads multiple memory statistics to build a comprehensive view of container memory behavior.\n\n| Memory Statistic | File Path | Description | Warning Threshold |\n|-----------------|-----------|-------------|-------------------|\n| Current Usage | `memory.current` | Total memory currently allocated | > 80% of `memory.max` |\n| Peak Usage | `memory.peak` | Highest memory usage since container start | > 90% of `memory.max` |\n| Cache Usage | `memory.stat` (cache field) | Page cache memory that can be reclaimed | < 10% of total usage |\n| Swap Usage | `memory.swap.current` | Current swap space consumption | > 50% of `memory.swap.max` |\n| Memory Events | `memory.events` | OOM kills, memory pressure events | Any oom_kill events |\n\nMemory monitoring algorithm:\n1. **Read current memory usage** from `memory.current` and calculate percentage of `memory.max`\n2. **Check memory events** by parsing `memory.events` for `oom`, `oom_kill`, `oom_group_kill` counters\n3. **Analyze memory composition** by parsing `memory.stat` to understand cache vs anonymous memory ratio\n4. **Detect memory pressure** by comparing current usage trends with historical patterns\n5. **Calculate memory efficiency** by examining the ratio of productive memory (heap, stack) to overhead (page tables, kernel buffers)\n6. **Generate alerts** when usage exceeds 80% of limit or memory pressure events indicate thrashing\n7. **Update monitoring metrics** for integration with external monitoring systems\n\nThe memory monitoring system maintains a sliding window of usage samples to detect trends and predict when containers might hit memory limits. Rapid memory growth patterns trigger early warnings, while sustained high usage with frequent page reclaim indicates memory pressure requiring attention.\n\n> Memory usage can spike temporarily during garbage collection or memory allocation bursts. Use moving averages over 30-60 second windows rather than instantaneous readings for alerting thresholds.\n\n#### CPU Usage Monitoring\n\nCPU usage monitoring tracks both absolute CPU consumption and throttling statistics to understand how containers utilize their allocated CPU quotas. The monitoring system distinguishes between CPU usage (actual compute time) and CPU throttling (time spent waiting due to quota limits).\n\n| CPU Statistic | File Path | Description | Threshold |\n|---------------|-----------|-------------|-----------|\n| Usage Time | `cpu.stat` (usage_usec) | Total CPU microseconds consumed | Compare to quota allocation |\n| User Time | `cpu.stat` (user_usec) | CPU time spent in user space | High ratio indicates compute-bound |\n| System Time | `cpu.stat` (system_usec) | CPU time spent in kernel space | High ratio indicates I/O-bound |\n| Throttled Time | `cpu.stat` (throttled_usec) | Time spent waiting due to quota limits | > 20% indicates quota too low |\n| Throttled Periods | `cpu.stat` (nr_throttled) | Number of periods where quota was exhausted | Increasing trend indicates pressure |\n\nCPU monitoring algorithm:\n1. **Sample CPU statistics** by reading and parsing the multi-line `cpu.stat` file\n2. **Calculate CPU utilization** by comparing `usage_usec` delta with time elapsed and quota available\n3. **Detect CPU throttling** by monitoring `throttled_usec` and `nr_throttled` increases between samples\n4. **Analyze CPU efficiency** by examining user/system time ratios to understand workload characteristics\n5. **Track CPU quota effectiveness** by comparing actual usage patterns with allocated quotas\n6. **Generate CPU pressure alerts** when throttling exceeds thresholds or containers consistently hit quota limits\n7. **Maintain CPU usage history** for capacity planning and right-sizing recommendations\n\nThe CPU monitoring system calculates CPU utilization as a percentage by taking the difference in `usage_usec` between samples, dividing by the time elapsed, and comparing to the allocated quota. For example, if a container uses 45,000 microseconds of CPU time in a 100,000 microsecond period with a 50,000 microsecond quota, it's running at 90% of its allocation (45,000 / 50,000).\n\n#### Resource Monitoring Data Structures\n\nThe resource monitoring system maintains current usage state, historical trends, and alert thresholds for each container using structured data that enables efficient monitoring and reporting.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `ContainerID` | `string` | Unique identifier for the monitored container |\n| `CgroupPath` | `string` | Filesystem path to the container's cgroup directory |\n| `LastSampleTime` | `time.Time` | Timestamp of the most recent monitoring sample |\n| `MemoryUsage` | `ResourceUsage` | Current memory consumption and trends |\n| `CPUUsage` | `ResourceUsage` | Current CPU utilization and throttling statistics |\n| `IOUsage` | `ResourceUsage` | Disk and network I/O statistics |\n| `AlertThresholds` | `AlertConfig` | Warning and critical thresholds for each resource |\n| `UsageHistory` | `[]ResourceSample` | Sliding window of historical usage samples |\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Current` | `int64` | Current resource usage value |\n| `Peak` | `int64` | Highest usage since monitoring started |\n| `Limit` | `int64` | Configured resource limit from cgroup |\n| `UtilizationPercent` | `float64` | Current usage as percentage of limit |\n| `TrendSlope` | `float64` | Rate of change in usage over time |\n| `PressureIndicators` | `map[string]int64` | Pressure metrics (throttling, OOM events, etc.) |\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `WarningThreshold` | `float64` | Utilization percentage triggering warnings |\n| `CriticalThreshold` | `float64` | Utilization percentage triggering critical alerts |\n| `TrendWarningSlope` | `float64` | Rate of increase triggering trend-based warnings |\n| `EventCountThreshold` | `int64` | Number of pressure events triggering alerts |\n\n### Out-of-Memory Handling\n\nThe **out-of-memory handling** system detects and manages memory exhaustion scenarios when containers exceed their allocated memory limits. The OOM handling mechanism combines kernel-level process termination with application-level cleanup and recovery procedures to maintain system stability.\n\n> **Decision: Cgroup-Scoped OOM Killing Over System-Wide**\n> - **Context**: When memory is exhausted, the Linux kernel can kill processes either system-wide (based on global OOM scores) or within the specific cgroup that exceeded limits.\n> - **Options Considered**: Allow system-wide OOM killer to select victims, enable cgroup-scoped OOM killing, implement custom OOM handling with memory pressure monitoring.\n> - **Decision**: Use cgroup-scoped OOM killing with `memory.oom.group` enabled.\n> - **Rationale**: Cgroup-scoped killing ensures only the offending container's processes are terminated, protecting other containers and the host system. Group killing ensures related processes (parent/child, shared memory) are cleaned up together, preventing orphaned resources.\n> - **Consequences**: Container processes may be killed more aggressively than with system-wide OOM, but system stability is preserved. Requires proper application design to handle sudden termination gracefully.\n\n| OOM Handling Approach | Pros | Cons | Chosen |\n|-----------------------|------|------|---------|\n| System-Wide OOM | Natural Linux behavior, well-tested | Can kill host processes, unpredictable victim selection | No |\n| Cgroup-Scoped OOM | Precise isolation, predictable behavior | More aggressive killing, requires container awareness | **Yes** |\n| Custom Memory Pressure | Fine-grained control, graceful degradation | Complex implementation, potential memory leaks | No |\n\n#### OOM Detection and Response\n\nThe OOM detection system monitors memory events and usage patterns to identify when containers are approaching or experiencing memory exhaustion. The system distinguishes between predictable memory pressure (gradual increase toward limits) and sudden memory spikes that trigger immediate OOM conditions.\n\nOOM detection algorithm:\n1. **Monitor memory events** by reading `memory.events` and tracking increases in `oom`, `oom_kill`, and `oom_group_kill` counters\n2. **Detect memory pressure** by comparing `memory.current` with `memory.max` and monitoring rate of increase\n3. **Check swap exhaustion** by comparing `memory.swap.current` with `memory.swap.max` if swap is enabled\n4. **Analyze allocation failures** by monitoring `memory.events` for `high`, `max`, and other pressure indicators\n5. **Predict OOM conditions** using usage trends and allocation patterns to warn before limits are reached\n6. **Trigger preventive actions** when usage exceeds warning thresholds (typically 90% of memory limit)\n7. **Handle OOM events** by detecting process termination and initiating cleanup procedures\n\nThe OOM response system implements a tiered approach based on memory pressure severity:\n\n**Warning Level (80-90% memory usage)**:\n- Log memory pressure warnings with usage statistics\n- Notify monitoring systems about approaching memory limits\n- Optionally trigger garbage collection hints for supported runtimes\n- Increase monitoring frequency for more responsive detection\n\n**Critical Level (90-95% memory usage)**:\n- Generate critical alerts to monitoring and logging systems\n- Implement emergency memory reclaim by dropping non-essential caches\n- Prepare for potential OOM by saving critical application state\n- Consider triggering application-specific memory reduction mechanisms\n\n**OOM Event (process killed by kernel)**:\n- Detect OOM kills by monitoring `memory.events` counters\n- Log detailed OOM information including memory usage at time of kill\n- Initiate container cleanup procedures to free resources\n- Update container state to reflect OOM termination cause\n- Optionally implement restart policies based on OOM frequency\n\n#### OOM Recovery and Cleanup\n\nThe OOM recovery system handles the aftermath of memory exhaustion events, ensuring proper resource cleanup and implementing restart policies that prevent repeated OOM cycles. The recovery process must distinguish between application bugs (memory leaks) and insufficient memory allocation.\n\n| OOM Recovery Action | Trigger Condition | Description | Implementation |\n|-------------------|------------------|-------------|----------------|\n| Immediate Cleanup | Process killed by OOM killer | Remove container resources, update state | Clean cgroups, namespaces, mounts |\n| Diagnostic Logging | Any OOM event | Record memory usage patterns and triggers | Write detailed logs with usage history |\n| Restart Decision | Container marked for restart | Evaluate restart policies and backoff | Check restart count, implement delays |\n| Resource Adjustment | Repeated OOM within window | Increase memory limits or reduce requests | Update ResourceLimits if policy allows |\n\nOOM recovery algorithm:\n1. **Detect OOM termination** by monitoring container process exit status and memory events\n2. **Preserve diagnostic information** by capturing memory usage statistics, allocation patterns, and timeline leading to OOM\n3. **Initiate resource cleanup** by removing cgroups, unmounting filesystems, and cleaning network resources\n4. **Update container state** to reflect OOM termination with detailed exit reason and resource usage\n5. **Evaluate restart eligibility** based on restart policies, backoff intervals, and OOM frequency\n6. **Implement restart backoff** to prevent rapid restart cycles that repeatedly trigger OOM\n7. **Optionally adjust resources** if restart policies allow automatic memory limit increases\n8. **Generate alerts** for persistent OOM patterns that require manual intervention\n\nThe restart backoff system implements exponential delays to prevent OOM thrashing:\n- First OOM: immediate restart if restart policy allows\n- Second OOM within 5 minutes: 10-second delay before restart\n- Third OOM within 15 minutes: 60-second delay before restart\n- Subsequent OOMs: exponential backoff up to 300-second maximum delay\n\n> ⚠️ **Pitfall: OOM Loop Prevention**\n> Containers that immediately trigger OOM after restart can create rapid resource allocation/deallocation cycles that destabilize the host system. Always implement restart backoff and consider automatic memory limit adjustments for chronic OOM containers.\n\n#### Memory Pressure Prevention\n\nThe memory pressure prevention system implements proactive measures to avoid OOM conditions by monitoring memory trends and triggering early intervention when containers approach their limits. This system focuses on graceful degradation rather than hard termination.\n\nMemory pressure prevention strategies:\n\n**Trend-Based Prediction**:\n- Monitor memory allocation rate over 60-second windows\n- Extrapolate current trends to predict when memory limits will be reached\n- Trigger warnings when projected exhaustion time falls below 5 minutes\n- Account for allocation bursts and garbage collection patterns\n\n**Application-Level Cooperation**:\n- Send SIGUSR1 signals to applications supporting memory pressure notifications\n- Implement cgroup memory.pressure interface for pressure stall information\n- Allow applications to implement graceful memory reduction strategies\n- Provide memory usage APIs for application self-monitoring\n\n**Cache and Buffer Management**:\n- Monitor page cache usage through memory.stat analysis\n- Trigger early page cache reclaim when memory pressure builds\n- Implement buffer size reductions for network and disk I/O\n- Coordinate with kernel memory management for optimal reclaim timing\n\n**Dynamic Resource Adjustment**:\n- Temporarily increase memory limits during predicted short-term spikes\n- Implement memory borrowing from unused container allocations\n- Coordinate with cluster-level resource management for dynamic scaling\n- Revert temporary adjustments after memory pressure subsides\n\nThe prevention system maintains effectiveness by learning from historical patterns and adjusting prediction algorithms based on application behavior. Containers with predictable memory allocation patterns receive more accurate warnings, while applications with erratic memory usage receive more conservative early warnings.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Cgroup Interface | Direct filesystem operations with os.OpenFile | go-cgroups library with type safety |\n| Resource Monitoring | Periodic file reads with time.Ticker | Prometheus client library with metrics |\n| OOM Detection | Poll memory.events file | Use eventfd for kernel notifications |\n| Data Persistence | JSON files in /var/lib/container-runtime | SQLite database with structured schema |\n\n#### Recommended File Structure\n\n```\ncontainer-runtime/\n  internal/cgroups/\n    cgroups.go              ← cgroup controller interface\n    memory.go               ← memory controller implementation  \n    cpu.go                  ← CPU controller implementation\n    devices.go              ← device controller implementation\n    monitor.go              ← resource usage monitoring\n    oom.go                  ← out-of-memory handling\n    cgroups_test.go         ← unit tests for all controllers\n  internal/resources/\n    limits.go               ← ResourceLimits validation and conversion\n    monitor.go              ← resource monitoring coordinator\n    stats.go                ← usage statistics collection\n```\n\n#### Infrastructure Starter Code\n\nComplete cgroup filesystem interface for reading and writing cgroup files:\n\n```go\n// pkg/cgroups/filesystem.go\npackage cgroups\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"os\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n)\n\n// CgroupFS provides filesystem operations for cgroup management\ntype CgroupFS struct {\n    Root string // Root cgroup filesystem path (usually /sys/fs/cgroup)\n}\n\n// NewCgroupFS creates a new cgroup filesystem interface\nfunc NewCgroupFS() *CgroupFS {\n    return &CgroupFS{Root: \"/sys/fs/cgroup\"}\n}\n\n// WriteFile writes content to a cgroup file with proper error handling\nfunc (c *CgroupFS) WriteFile(cgroupPath, filename, content string) error {\n    fullPath := filepath.Join(c.Root, cgroupPath, filename)\n    return ioutil.WriteFile(fullPath, []byte(content), 0644)\n}\n\n// ReadFile reads content from a cgroup file\nfunc (c *CgroupFS) ReadFile(cgroupPath, filename string) (string, error) {\n    fullPath := filepath.Join(c.Root, cgroupPath, filename)\n    data, err := ioutil.ReadFile(fullPath)\n    if err != nil {\n        return \"\", err\n    }\n    return strings.TrimSpace(string(data)), nil\n}\n\n// CreateCgroup creates a cgroup directory\nfunc (c *CgroupFS) CreateCgroup(cgroupPath string) error {\n    fullPath := filepath.Join(c.Root, cgroupPath)\n    return os.MkdirAll(fullPath, 0755)\n}\n\n// RemoveCgroup removes a cgroup directory\nfunc (c *CgroupFS) RemoveCgroup(cgroupPath string) error {\n    fullPath := filepath.Join(c.Root, cgroupPath)\n    return os.Remove(fullPath)\n}\n\n// ParseKeyValue parses multi-line key-value format from cgroup stat files\nfunc (c *CgroupFS) ParseKeyValue(content string) map[string]int64 {\n    result := make(map[string]int64)\n    lines := strings.Split(content, \"\\n\")\n    for _, line := range lines {\n        if line == \"\" {\n            continue\n        }\n        parts := strings.Fields(line)\n        if len(parts) == 2 {\n            if value, err := strconv.ParseInt(parts[1], 10, 64); err == nil {\n                result[parts[0]] = value\n            }\n        }\n    }\n    return result\n}\n```\n\nResource monitoring data structures and utilities:\n\n```go\n// internal/resources/types.go\npackage resources\n\nimport (\n    \"time\"\n)\n\n// ResourceUsage tracks current and historical resource consumption\ntype ResourceUsage struct {\n    Current             int64             `json:\"current\"`\n    Peak                int64             `json:\"peak\"`\n    Limit               int64             `json:\"limit\"`\n    UtilizationPercent  float64           `json:\"utilization_percent\"`\n    TrendSlope          float64           `json:\"trend_slope\"`\n    PressureIndicators  map[string]int64  `json:\"pressure_indicators\"`\n}\n\n// ResourceSample represents a point-in-time resource measurement\ntype ResourceSample struct {\n    Timestamp time.Time `json:\"timestamp\"`\n    Value     int64     `json:\"value\"`\n    Metadata  map[string]interface{} `json:\"metadata,omitempty\"`\n}\n\n// AlertConfig defines thresholds for resource usage alerts\ntype AlertConfig struct {\n    WarningThreshold     float64 `json:\"warning_threshold\"`\n    CriticalThreshold    float64 `json:\"critical_threshold\"`\n    TrendWarningSlope    float64 `json:\"trend_warning_slope\"`\n    EventCountThreshold  int64   `json:\"event_count_threshold\"`\n}\n\n// ContainerResourceState maintains monitoring state for a container\ntype ContainerResourceState struct {\n    ContainerID     string                 `json:\"container_id\"`\n    CgroupPath      string                 `json:\"cgroup_path\"`\n    LastSampleTime  time.Time              `json:\"last_sample_time\"`\n    MemoryUsage     ResourceUsage          `json:\"memory_usage\"`\n    CPUUsage        ResourceUsage          `json:\"cpu_usage\"`\n    IOUsage         ResourceUsage          `json:\"io_usage\"`\n    AlertThresholds AlertConfig            `json:\"alert_thresholds\"`\n    UsageHistory    []ResourceSample       `json:\"usage_history\"`\n}\n\n// CalculateUtilization computes utilization percentage with bounds checking\nfunc (r *ResourceUsage) CalculateUtilization() {\n    if r.Limit > 0 {\n        r.UtilizationPercent = float64(r.Current) / float64(r.Limit) * 100.0\n    } else {\n        r.UtilizationPercent = 0.0\n    }\n    \n    // Clamp to reasonable bounds\n    if r.UtilizationPercent > 100.0 {\n        r.UtilizationPercent = 100.0\n    }\n    if r.UtilizationPercent < 0.0 {\n        r.UtilizationPercent = 0.0\n    }\n}\n```\n\n#### Core Logic Skeleton Code\n\nCgroup controller implementation with memory, CPU, and device management:\n\n```go\n// internal/cgroups/controller.go\npackage cgroups\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \"strconv\"\n    \"time\"\n)\n\n// Controller manages cgroup v2 controllers for container resource limits\ntype Controller struct {\n    fs       *CgroupFS\n    basePath string // Base path for container runtime cgroups\n}\n\n// NewController creates a new cgroup controller\nfunc NewController() *Controller {\n    return &Controller{\n        fs:       NewCgroupFS(),\n        basePath: \"container-runtime\",\n    }\n}\n\n// CreateContainerCgroup sets up cgroup hierarchy and limits for a container\nfunc (c *Controller) CreateContainerCgroup(containerID string, limits ResourceLimits) error {\n    // TODO 1: Validate that cgroups v2 is available by checking /sys/fs/cgroup/cgroup.controllers\n    // TODO 2: Create runtime base cgroup if it doesn't exist: /sys/fs/cgroup/container-runtime/\n    // TODO 3: Enable required controllers (+memory +cpu +pids) in base cgroup subtree_control\n    // TODO 4: Create container-specific cgroup directory: /sys/fs/cgroup/container-runtime/[containerID]/\n    // TODO 5: Configure memory limits by writing limits.Memory to memory.max\n    // TODO 6: Configure CPU limits by converting limits.CPU to quota/period format for cpu.max\n    // TODO 7: Configure PID limits by writing limits.PIDs to pids.max\n    // TODO 8: Set up device controller with standard container device allowlist\n    // TODO 9: Verify cgroup creation by reading back the written configuration files\n    // Hint: Use c.fs.CreateCgroup() and c.fs.WriteFile() for filesystem operations\n    // Hint: CPU limits in nanoseconds/second convert to microseconds/100ms for cpu.max\n}\n\n// AssignProcessToCgroup moves a process into the container's cgroup for resource enforcement\nfunc (c *Controller) AssignProcessToCgroup(containerID string, pid int) error {\n    // TODO 1: Validate that the container cgroup exists before assignment\n    // TODO 2: Write the PID to the container's cgroup.procs file\n    // TODO 3: Verify assignment by reading cgroup.procs and confirming PID is listed\n    // TODO 4: Handle assignment failures due to process state or permissions\n    // Hint: Convert PID to string before writing to cgroup.procs\n    // Hint: Assignment may fail if process is already exiting\n}\n\n// GetResourceUsage reads current resource consumption from cgroup statistics\nfunc (c *Controller) GetResourceUsage(containerID string) (*ContainerResourceState, error) {\n    // TODO 1: Read memory usage from memory.current and memory.peak\n    // TODO 2: Read memory limits from memory.max for utilization calculation  \n    // TODO 3: Read CPU usage from cpu.stat (parse usage_usec field)\n    // TODO 4: Read CPU throttling statistics from cpu.stat (throttled_usec, nr_throttled)\n    // TODO 5: Read memory pressure events from memory.events\n    // TODO 6: Calculate utilization percentages for each resource type\n    // TODO 7: Detect resource pressure indicators (high throttling, OOM events)\n    // TODO 8: Build and return ContainerResourceState with all collected metrics\n    // Hint: Use c.fs.ParseKeyValue() to parse multi-line stat files\n    // Hint: Handle missing or unreadable files gracefully (container may be gone)\n}\n\n// RemoveContainerCgroup cleans up cgroup when container is removed\nfunc (c *Controller) RemoveContainerCgroup(containerID string) error {\n    // TODO 1: Ensure no processes remain in the cgroup before removal\n    // TODO 2: Read cgroup.procs and verify it's empty\n    // TODO 3: Remove the cgroup directory using rmdir (not rm -rf)\n    // TODO 4: Handle removal failures due to remaining processes or resources\n    // TODO 5: Log warnings but don't fail if cgroup is already gone\n    // Hint: Cgroup removal will fail if any processes are still assigned\n    // Hint: Use c.fs.RemoveCgroup() which calls os.Remove() (equivalent to rmdir)\n}\n```\n\nMemory controller with OOM detection and handling:\n\n```go\n// internal/cgroups/memory.go  \npackage cgroups\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n)\n\n// MemoryController manages memory cgroup settings and OOM handling\ntype MemoryController struct {\n    fs *CgroupFS\n}\n\n// SetMemoryLimit configures memory.max and related memory settings\nfunc (m *MemoryController) SetMemoryLimit(cgroupPath string, limitBytes int64) error {\n    // TODO 1: Write hard memory limit to memory.max file\n    // TODO 2: Calculate and set soft limit (75% of hard limit) in memory.high\n    // TODO 3: Configure swap limit in memory.swap.max (same as memory limit or disabled)\n    // TODO 4: Enable group OOM killing by writing 1 to memory.oom.group\n    // TODO 5: Verify limits are applied by reading back the written values\n    // Hint: Convert limitBytes to string before writing\n    // Hint: Use \"0\" for memory.swap.max to disable swap for the container\n}\n\n// GetMemoryUsage reads current memory consumption and pressure indicators\nfunc (m *MemoryController) GetMemoryUsage(cgroupPath string) (*ResourceUsage, error) {\n    // TODO 1: Read current memory usage from memory.current\n    // TODO 2: Read peak memory usage from memory.peak  \n    // TODO 3: Read memory limit from memory.max\n    // TODO 4: Parse memory.stat to get detailed memory breakdown (cache, anonymous, etc.)\n    // TODO 5: Read memory pressure events from memory.events\n    // TODO 6: Calculate utilization percentage and trend indicators\n    // TODO 7: Build ResourceUsage struct with pressure indicators map\n    // Hint: memory.events contains counters for low, high, max, oom, oom_kill events\n    // Hint: Use m.fs.ParseKeyValue() to parse memory.stat and memory.events\n}\n\n// CheckOOMEvents detects out-of-memory kills and returns event details\nfunc (m *MemoryController) CheckOOMEvents(cgroupPath string) (bool, map[string]int64, error) {\n    // TODO 1: Read memory.events file to get OOM event counters\n    // TODO 2: Check for increases in oom_kill and oom_group_kill counters\n    // TODO 3: Compare with previously stored counter values to detect new events\n    // TODO 4: Return true if new OOM events occurred since last check\n    // TODO 5: Include all event counters in returned map for detailed logging\n    // Hint: Store previous counter values to detect increases\n    // Hint: Any non-zero oom_kill count indicates the container has experienced OOM\n}\n```\n\nResource monitoring with trend analysis and alerting:\n\n```go\n// internal/resources/monitor.go\npackage resources\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n)\n\n// ResourceMonitor coordinates resource usage monitoring across all containers\ntype ResourceMonitor struct {\n    controller     *cgroups.Controller\n    containers     map[string]*ContainerResourceState\n    mutex          sync.RWMutex\n    alertChannel   chan ResourceAlert\n    stopChannel    chan struct{}\n    monitoringInterval time.Duration\n}\n\n// ResourceAlert represents a resource usage alert condition\ntype ResourceAlert struct {\n    ContainerID   string    `json:\"container_id\"`\n    ResourceType  string    `json:\"resource_type\"`\n    AlertLevel    string    `json:\"alert_level\"` // warning, critical, oom\n    CurrentUsage  int64     `json:\"current_usage\"`\n    Limit         int64     `json:\"limit\"`\n    Message       string    `json:\"message\"`\n    Timestamp     time.Time `json:\"timestamp\"`\n}\n\n// StartMonitoring begins periodic resource usage monitoring for all containers\nfunc (r *ResourceMonitor) StartMonitoring(ctx context.Context) {\n    // TODO 1: Start background goroutine with ticker for monitoring interval\n    // TODO 2: On each tick, iterate through all registered containers\n    // TODO 3: Collect current resource usage for each container\n    // TODO 4: Update usage history with new samples (maintain sliding window)\n    // TODO 5: Calculate trends and detect approaching resource limits\n    // TODO 6: Generate alerts for containers exceeding warning/critical thresholds\n    // TODO 7: Check for OOM events and generate immediate critical alerts\n    // TODO 8: Handle context cancellation for graceful shutdown\n    // Hint: Use time.NewTicker(r.monitoringInterval) for periodic monitoring\n    // Hint: Protect concurrent access to r.containers map with r.mutex\n}\n\n// RegisterContainer adds a container to the monitoring system\nfunc (r *ResourceMonitor) RegisterContainer(containerID, cgroupPath string, thresholds AlertConfig) error {\n    // TODO 1: Create ContainerResourceState for the new container\n    // TODO 2: Initialize usage history slice with appropriate capacity\n    // TODO 3: Store alert thresholds configuration\n    // TODO 4: Add container to monitoring map with proper locking\n    // TODO 5: Perform initial resource usage reading to establish baseline\n    // Hint: Use r.mutex.Lock() for write access to r.containers map\n    // Hint: Initialize UsageHistory with make([]ResourceSample, 0, historyCapacity)\n}\n\n// CalculateUsageTrend computes the rate of change in resource usage\nfunc (r *ResourceMonitor) CalculateUsageTrend(history []ResourceSample) float64 {\n    // TODO 1: Validate that history has at least 2 samples for trend calculation\n    // TODO 2: Use linear regression or simple slope calculation across sample window\n    // TODO 3: Calculate bytes-per-second or percentage-per-minute change rate\n    // TODO 4: Handle edge cases (empty history, identical timestamps, etc.)\n    // TODO 5: Return trend slope (positive=increasing, negative=decreasing, zero=stable)\n    // Hint: Simple slope = (lastValue - firstValue) / (lastTime - firstTime)\n    // Hint: Convert time difference to seconds for rate calculation\n}\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the Resource Control Component:\n\n**Test Command**: `go test ./internal/cgroups/... -v`\n\n**Expected Behavior**:\n- Cgroup creation succeeds for valid container specifications\n- Memory limits are enforced when containers exceed allocation\n- CPU throttling occurs when containers exceed CPU quotas  \n- Resource usage monitoring returns accurate utilization statistics\n- OOM events are detected and logged appropriately\n\n**Manual Verification**:\n1. Create a test container with 100MB memory limit: `echo 'stress --vm 1 --vm-bytes 200M' | ./container-runtime run --memory 104857600 alpine`\n2. Container should be killed when memory usage exceeds limit\n3. Check cgroup files: `cat /sys/fs/cgroup/container-runtime/[container-id]/memory.max` should show 104857600\n4. Monitor resource usage: `./container-runtime stats [container-id]` should show current memory/CPU utilization\n5. Verify cleanup: after container removal, cgroup directory should be deleted\n\n**Signs of Problems**:\n- \"Operation not permitted\" when writing to cgroup files → Check that cgroups v2 is enabled and process has sufficient privileges\n- Memory limit not enforced → Verify memory.max file contains correct limit and memory.oom.group is enabled\n- Resource monitoring returns zero values → Check cgroup file permissions and paths\n- Cgroup removal fails → Ensure all processes are terminated before attempting removal\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Container uses unlimited memory despite limits | Memory limits not applied or enforced | Check memory.max file exists and contains expected value | Verify cgroups v2 enabled, ensure memory controller active |\n| CPU usage exceeds configured quotas | CPU limits not configured or incorrect quota calculation | Check cpu.max file and verify quota/period values | Convert nanoseconds correctly to microsecond quota |\n| Cgroup creation fails with permission denied | Insufficient privileges or cgroups v2 not available | Check /sys/fs/cgroup mount and user permissions | Run with appropriate privileges or enable user namespaces |\n| Resource monitoring returns stale data | Cgroup files not updating or monitoring stopped | Check if container process still exists and cgroup populated | Verify process assignment and restart monitoring |\n| OOM kills not detected | Event monitoring not working or wrong file format | Read memory.events manually and check counter values | Implement proper event file parsing and counter tracking |\n\n\n## Filesystem Layering Component\n\n> **Milestone(s):** Milestone 3 (Overlay Filesystem) - This section implements image layering using overlayfs for copy-on-write filesystem support with proper layer management and cleanup.\n\n### Mental Model: Transparent Sheets\n\nBefore diving into the technical complexities of overlayfs, imagine you're working with a stack of transparent sheets on an overhead projector. Each sheet represents a filesystem layer that contains some files and directories. When you stack multiple sheets on top of each other, the audience sees a combined view where content from all sheets appears merged together.\n\nThe **bottom sheets** are your base image layers - they contain the operating system files, libraries, and application dependencies. These sheets are read-only; you never modify them directly. You might have a base Ubuntu sheet, then an application runtime sheet on top of it, then your application code sheet on top of that.\n\nThe **top sheet** is special - it's a blank, writable transparency where you can draw new content or place opaque stickers to \"hide\" content from the sheets below. When you write a file in the container, it's like drawing on this top sheet. When you modify an existing file, it's like placing an opaque sticker over the old content and writing the new content on the sticker.\n\nThis analogy captures the essence of **copy-on-write semantics**: the original sheets (base image layers) remain untouched, but the combined view shows your modifications. If you need to \"edit\" a file that exists in a lower layer, the filesystem copies it up to the writable layer first, then modifies the copy. The original remains pristine in the lower layer, but the upper copy masks it in the merged view.\n\nThe **projector** itself represents the overlayfs mount that combines all these layers into a single, coherent filesystem tree that the container process sees as its root filesystem. Just as the audience sees one combined image despite the multiple sheets, the container sees one unified filesystem despite the multiple underlying layers.\n\n### Layer Stacking and Management\n\nThe core challenge in filesystem layering is **orchestrating the overlayfs mount** to combine multiple read-only image layers with a single writable upper layer. This process involves careful directory structure setup, mount option configuration, and proper handling of layer ordering.\n\n> **Decision: Directory Structure for OverlayFS**\n> - **Context**: OverlayFS requires specific directory layout with lower directories, upper directory, work directory, and mount target\n> - **Options Considered**: \n>   1. Flat structure with all directories in same parent\n>   2. Nested structure mirroring image layer hierarchy\n>   3. Separate trees for layers, upper, work, and mounts\n> - **Decision**: Separate trees organized by function under container storage root\n> - **Rationale**: Cleaner separation of concerns, easier cleanup, better debugging visibility, matches Docker/containerd patterns\n> - **Consequences**: More directory traversal but clearer organization and easier troubleshooting\n\n| Directory Type | Purpose | Example Path | Permissions | Cleanup Timing |\n|---|---|---|---|---|\n| Lower Layers | Read-only image layer content | `/var/lib/runtime/layers/sha256:abc123...` | 755 (readable) | On image removal |\n| Upper Directory | Container's writable layer | `/var/lib/runtime/containers/{id}/upper` | 755 (writable) | On container removal |\n| Work Directory | OverlayFS internal operations | `/var/lib/runtime/containers/{id}/work` | 755 (writable) | On container removal |\n| Merged Mount | Combined view for container | `/var/lib/runtime/containers/{id}/merged` | 755 (mount target) | On container stop |\n\nThe **layer stacking algorithm** follows a precise sequence to ensure proper overlay mounting:\n\n1. **Validate layer prerequisites** by checking that each lower layer directory exists and contains valid filesystem content. Empty layers are permitted but must have proper directory structure.\n\n2. **Create container-specific directories** for the upper layer, work directory, and merge mount point. The work directory must be on the same filesystem as the upper directory to support atomic operations.\n\n3. **Construct the lowerdir mount option** by joining all image layer paths with colon separators, ordered from most-specific to most-general (reverse chronological order of layer creation). This ordering ensures that files in later layers override files in earlier layers.\n\n4. **Prepare mount options** combining lowerdir, upperdir, workdir, and any additional overlayfs-specific flags like index=on for better performance on supported kernels.\n\n5. **Execute the overlay mount** using the mount system call with MS_MGC_VAL flag and \"overlay\" filesystem type, binding the merged view to the container's mount point.\n\n6. **Verify mount success** by checking that the merged directory shows expected content from all layers and that test write operations succeed in creating files that appear only in the upper directory.\n\n> The critical insight here is that overlayfs requires the work directory to be empty and on the same filesystem as the upper directory. Many mount failures stem from violating these requirements.\n\n**Layer ordering** is crucial for proper file precedence. When multiple layers contain the same file path, overlayfs uses the **first match wins** principle, searching from the upper directory down through the lower directories in the order specified. This means the mount option construction must reverse the chronological layer order:\n\n| Layer Type | Creation Order | Mount Order | Precedence |\n|---|---|---|---|\n| Upper (container changes) | N/A | First (implicit) | Highest |\n| App layer | 3rd (most recent) | 2nd in lowerdir | Second highest |\n| Runtime layer | 2nd | 3rd in lowerdir | Third highest |\n| Base OS layer | 1st (oldest) | Last in lowerdir | Lowest |\n\n**Container filesystem manager** coordinates the entire layer stacking process through a well-defined interface:\n\n| Method | Parameters | Returns | Description |\n|---|---|---|---|\n| `PrepareContainerFilesystem` | `containerID string, imageLayers []string` | `error` | Creates directories and mounts overlay |\n| `MountOverlayFS` | `layers []string, target string` | `error` | Core overlay mount operation |\n| `GetMergedPath` | `containerID string` | `string` | Returns path to merged filesystem |\n| `GetUpperPath` | `containerID string` | `string` | Returns path to writable layer |\n| `ListLayerContent` | `layerPath string` | `[]FileInfo, error` | Inspects layer contents for debugging |\n| `ValidateLayerIntegrity` | `layerPath string` | `error` | Verifies layer filesystem consistency |\n\n### Copy-on-Write Semantics\n\nCopy-on-write (CoW) is the fundamental mechanism that makes container filesystem layering efficient and safe. When a container process attempts to **modify a file that exists in a lower read-only layer**, overlayfs automatically copies the file to the upper writable layer before allowing the modification to proceed. This ensures that the original file in the base image remains unchanged while the container sees its modified version.\n\nThe **CoW trigger conditions** determine when overlayfs initiates a copy operation:\n\n| Operation Type | Triggers CoW | Behavior | Performance Impact |\n|---|---|---|---|\n| Read existing file | No | Direct read from lower layer | Minimal overhead |\n| Write new file | No | Write directly to upper layer | Minimal overhead |\n| Modify existing file | Yes | Copy to upper, then modify | One-time copy cost |\n| Delete existing file | Yes | Create whiteout in upper layer | Minimal overhead |\n| Change permissions | Yes | Copy to upper, then change attrs | One-time copy cost |\n| Create hard link | Yes | Copy target to upper if needed | Depends on target size |\n\n**Whiteout files** are overlayfs's mechanism for handling file deletions without modifying lower layers. When a container deletes a file that exists in a lower layer, overlayfs creates a special **character device file** with device number 0/0 in the upper layer at the same path. This whiteout file masks the lower layer file in the merged view, making it appear deleted to the container while preserving the original in the base image.\n\nThe **copy-up process** follows a specific algorithm to ensure atomicity and consistency:\n\n1. **Create temporary file** in the upper layer with a unique name (typically the target filename with a random suffix) to avoid conflicts during the copy operation.\n\n2. **Copy file content** from the lower layer source to the temporary file in chunks, preserving all data exactly while handling large files efficiently.\n\n3. **Copy metadata** including permissions, ownership, timestamps, and extended attributes from the original file to maintain exact semantics.\n\n4. **Atomic rename** the temporary file to the final target name in the upper layer, making the copied file visible in the merged view instantaneously.\n\n5. **Verify copy integrity** by comparing file size and checksums between source and destination to detect any corruption during the copy process.\n\n> **Key Design Insight**: The copy-up operation is atomic from the container's perspective - the file either appears unchanged (before copy-up) or fully updated (after copy-up), never in a partial state.\n\n**Container process perspective** shows how CoW remains transparent to applications running inside containers:\n\n| Container Action | Filesystem Events | Container Observes | Actual Storage |\n|---|---|---|---|\n| `cat /etc/passwd` | Read from lower layer | File contents | No upper layer copy |\n| `echo \"test\" > /tmp/new` | Write to upper layer | New file created | File only in upper |\n| `sed -i 's/bash/zsh/' /etc/passwd` | Copy-up, then modify | Modified file | Original in lower, copy in upper |\n| `rm /bin/ls` | Create whiteout | File deleted | Original in lower, whiteout in upper |\n| `ls /etc/` | Merge lower + upper - whiteouts | Combined directory | Files from all layers |\n\n**Performance characteristics** of copy-on-write operations vary significantly based on file size and access patterns:\n\n| File Size Range | Copy-up Latency | Storage Overhead | Optimization Strategy |\n|---|---|---|---|\n| < 4KB (small configs) | < 1ms | Minimal | Acceptable overhead |\n| 4KB - 1MB (libraries) | 1-10ms | Low | Monitor for hot files |\n| 1MB - 100MB (binaries) | 10ms - 1s | Moderate | Consider image layer optimization |\n| > 100MB (databases) | > 1s | High | Use volume mounts instead |\n\n⚠️ **Pitfall: Large File Copy-up Performance**\nA common mistake is placing large, frequently-modified files (like databases or log files) in the container's overlay filesystem. When the container first modifies a 500MB database file from the base image, overlayfs must copy the entire file to the upper layer before allowing any writes. This creates a several-second pause and doubles the storage requirement. **Solution**: Use volume mounts for large, mutable data files, keeping only application code and configuration in the overlay layers.\n\n### Layer Cleanup Process\n\nProper cleanup of overlay filesystem layers is critical for preventing resource leaks and maintaining system stability. The cleanup process must handle **partial failure scenarios** gracefully while ensuring that shared base image layers are only removed when no longer referenced by any containers.\n\n> **Decision: Cleanup Ordering Strategy**\n> - **Context**: Failed cleanup can leave mount points active, directories locked, or storage space consumed\n> - **Options Considered**:\n>   1. Aggressive cleanup that forces unmount and removes all directories\n>   2. Conservative cleanup that fails fast on any error\n>   3. Best-effort cleanup with detailed error reporting\n> - **Decision**: Best-effort cleanup with rollback capability\n> - **Rationale**: Maximizes successful cleanup while providing diagnostics for manual intervention when needed\n> - **Consequences**: More complex cleanup logic but better operational reliability\n\nThe **cleanup sequence** follows a carefully ordered set of operations designed to minimize the chance of leaving the system in an inconsistent state:\n\n1. **Identify cleanup scope** by determining which overlay mount points, directories, and layer references belong to the container being removed.\n\n2. **Unmount overlay filesystem** using the umount system call with MNT_DETACH flag if normal unmount fails, allowing cleanup to proceed even if processes hold open file descriptors.\n\n3. **Remove container-specific directories** including the merged mount point, upper directory, and work directory, which contain only this container's changes.\n\n4. **Update layer reference counts** to track how many containers are using each base image layer, enabling safe cleanup of unused layers.\n\n5. **Remove unreferenced image layers** only after confirming no other containers or cached images depend on them.\n\n6. **Clean up mount namespace entries** to prevent stale mount information from accumulating in the kernel's mount table.\n\n| Cleanup Phase | Target | Error Handling | Rollback Action |\n|---|---|---|---|\n| Overlay unmount | `/var/lib/runtime/containers/{id}/merged` | Retry with MNT_DETACH | Mark for later cleanup |\n| Upper directory | `/var/lib/runtime/containers/{id}/upper` | Log and continue | Manual removal required |\n| Work directory | `/var/lib/runtime/containers/{id}/work` | Log and continue | Manual removal required |\n| Mount point | `/var/lib/runtime/containers/{id}/merged` | Log and continue | Manual removal required |\n| Layer references | Reference count files | Log and continue | May leak storage space |\n| Image layers | `/var/lib/runtime/layers/sha256:*` | Skip if referenced | Preserve for safety |\n\n**Reference counting** prevents premature removal of shared base image layers that might be used by other containers:\n\n| Reference Type | Storage Location | Update Trigger | Cleanup Trigger |\n|---|---|---|---|\n| Container references | `/var/lib/runtime/refs/containers/{id}` | Container create/remove | Container removal |\n| Image references | `/var/lib/runtime/refs/images/{digest}` | Image pull/remove | Image removal |\n| Layer references | `/var/lib/runtime/refs/layers/{digest}` | Layer first use/last use | Reference count reaches zero |\n\n**Cleanup verification** ensures that the cleanup process completed successfully and didn't leave orphaned resources:\n\n| Verification Check | Expected State | Detection Method | Recovery Action |\n|---|---|---|---|\n| Mount points cleared | No overlay mounts for container | Parse `/proc/mounts` | Force unmount |\n| Directories removed | Container directory tree gone | `stat()` system call | Recursive removal |\n| References updated | Counts reflect removal | Read reference files | Recalculate from existing containers |\n| Storage reclaimed | Disk space freed | `du` on upper directory | Manual space recovery |\n\n⚠️ **Pitfall: Unmount Failures with Open Files**\nA frequent issue occurs when container cleanup attempts to unmount the overlay filesystem while processes still have open file descriptors to files in the merged view. This can happen if the container process didn't terminate cleanly or if background processes are still running. **Detection**: The umount system call returns EBUSY. **Solution**: Use `MNT_DETACH` flag to create a lazy unmount that removes the mount from the namespace immediately but defers the actual cleanup until all references are closed.\n\n⚠️ **Pitfall: Work Directory Reuse**\nOverlayFS requires the work directory to be empty for each mount operation. If cleanup fails to remove the work directory completely, subsequent container creation will fail with cryptic mount errors. **Detection**: Mount fails with \"work directory not empty\" or similar message. **Solution**: Always verify work directory is empty before mounting, and remove any stale files if found.\n\n**Cleanup state machine** tracks the progress of cleanup operations and enables recovery from partial failures:\n\n| Cleanup State | Description | Next States | Recovery Action |\n|---|---|---|---|\n| `CleanupStarted` | Cleanup initiated | `OverlayUnmounted`, `CleanupFailed` | Retry from beginning |\n| `OverlayUnmounted` | Overlay filesystem unmounted | `DirectoriesRemoved`, `CleanupFailed` | Remove directories |\n| `DirectoriesRemoved` | Container dirs removed | `ReferencesUpdated`, `CleanupFailed` | Update reference counts |\n| `ReferencesUpdated` | Reference counts updated | `LayersChecked`, `CleanupFailed` | Check for unused layers |\n| `LayersChecked` | Unused layers identified | `CleanupCompleted`, `CleanupFailed` | Remove unused layers |\n| `CleanupCompleted` | All cleanup finished | N/A | Success |\n| `CleanupFailed` | Error occurred | `CleanupStarted` | Manual intervention or retry |\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Filesystem Operations | `syscall.Mount()` + `os.RemoveAll()` | `sys/mount` with detailed error handling |\n| Directory Management | `os.MkdirAll()` + `filepath.Walk()` | Custom directory tree with atomic operations |\n| Layer Storage | Simple directory hierarchy | Content-addressable storage with deduplication |\n| Reference Counting | JSON files on disk | Embedded database (BoltDB) |\n| Mount Verification | Parse `/proc/mounts` | Use `statfs()` and mount namespace APIs |\n\n**Recommended File Structure:**\n\n```\ninternal/filesystem/\n  manager.go              ← main filesystem manager\n  overlay.go              ← overlayfs operations\n  layers.go               ← layer management\n  cleanup.go              ← cleanup operations\n  references.go           ← reference counting\n  manager_test.go         ← integration tests\n  overlay_test.go         ← overlay-specific tests\n  testdata/               ← test layers and fixtures\n    base-layer/\n    app-layer/\n    expected-merged/\n```\n\n**Infrastructure Starter Code:**\n\n```go\npackage filesystem\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n    \"syscall\"\n    \"encoding/json\"\n    \"time\"\n)\n\n// LayerInfo represents metadata about a filesystem layer\ntype LayerInfo struct {\n    Digest      string    `json:\"digest\"`\n    Size        int64     `json:\"size\"`\n    CreatedAt   time.Time `json:\"created_at\"`\n    RefCount    int       `json:\"ref_count\"`\n}\n\n// FilesystemManager handles all overlay filesystem operations\ntype FilesystemManager struct {\n    storageRoot   string\n    layersDir     string\n    containersDir string\n    refsDir       string\n}\n\n// NewFilesystemManager creates a new filesystem manager\nfunc NewFilesystemManager(storageRoot string) (*FilesystemManager, error) {\n    fm := &FilesystemManager{\n        storageRoot:   storageRoot,\n        layersDir:     filepath.Join(storageRoot, \"layers\"),\n        containersDir: filepath.Join(storageRoot, \"containers\"),\n        refsDir:       filepath.Join(storageRoot, \"refs\"),\n    }\n    \n    // Create required directory structure\n    dirs := []string{fm.layersDir, fm.containersDir, fm.refsDir}\n    for _, dir := range dirs {\n        if err := os.MkdirAll(dir, 0755); err != nil {\n            return nil, fmt.Errorf(\"failed to create directory %s: %v\", dir, err)\n        }\n    }\n    \n    return fm, nil\n}\n\n// LayerExists checks if a layer is available locally\nfunc (fm *FilesystemManager) LayerExists(digest string) bool {\n    layerPath := filepath.Join(fm.layersDir, digest)\n    _, err := os.Stat(layerPath)\n    return err == nil\n}\n\n// GetLayerPath returns the filesystem path for a layer\nfunc (fm *FilesystemManager) GetLayerPath(digest string) string {\n    return filepath.Join(fm.layersDir, digest)\n}\n\n// GetContainerPaths returns all paths for a container's overlay setup\nfunc (fm *FilesystemManager) GetContainerPaths(containerID string) (upper, work, merged string) {\n    containerDir := filepath.Join(fm.containersDir, containerID)\n    return filepath.Join(containerDir, \"upper\"),\n           filepath.Join(containerDir, \"work\"),\n           filepath.Join(containerDir, \"merged\")\n}\n\n// ReferenceManager handles layer reference counting\ntype ReferenceManager struct {\n    refsDir string\n}\n\n// AddContainerReference records that a container uses specific layers\nfunc (rm *ReferenceManager) AddContainerReference(containerID string, layers []string) error {\n    refFile := filepath.Join(rm.refsDir, \"containers\", containerID+\".json\")\n    if err := os.MkdirAll(filepath.Dir(refFile), 0755); err != nil {\n        return err\n    }\n    \n    data, err := json.Marshal(layers)\n    if err != nil {\n        return err\n    }\n    \n    return os.WriteFile(refFile, data, 0644)\n}\n\n// RemoveContainerReference removes a container's layer references\nfunc (rm *ReferenceManager) RemoveContainerReference(containerID string) error {\n    refFile := filepath.Join(rm.refsDir, \"containers\", containerID+\".json\")\n    return os.Remove(refFile)\n}\n```\n\n**Core Logic Skeleton Code:**\n\n```go\n// PrepareContainerFilesystem creates and mounts overlay filesystem for container\nfunc (fm *FilesystemManager) PrepareContainerFilesystem(containerID string, imageLayers []string) error {\n    // TODO 1: Validate that all required image layers exist locally\n    // Hint: Use LayerExists() for each layer digest\n    \n    // TODO 2: Create container-specific directories (upper, work, merged)\n    // Hint: Use GetContainerPaths() and os.MkdirAll()\n    \n    // TODO 3: Ensure work directory is empty (overlayfs requirement)\n    // Hint: Remove and recreate work directory if it exists\n    \n    // TODO 4: Add container reference to track layer usage\n    // Hint: Use ReferenceManager.AddContainerReference()\n    \n    // TODO 5: Mount the overlay filesystem\n    // Hint: Call MountOverlayFS() with properly ordered layers\n    \n    return nil\n}\n\n// MountOverlayFS mounts overlay filesystem with given layers and target\nfunc (fm *FilesystemManager) MountOverlayFS(layers []string, target string) error {\n    // TODO 1: Validate all layer directories exist and are accessible\n    // Hint: Check each layer path with os.Stat()\n    \n    // TODO 2: Construct lowerdir option by joining layer paths with \":\"\n    // Hint: Use strings.Join() - order matters! Most recent layer first\n    \n    // TODO 3: Build complete mount options string\n    // Format: \"lowerdir=/path1:/path2,upperdir=/upper,workdir=/work\"\n    // Hint: Get upper/work paths from target directory structure\n    \n    // TODO 4: Execute overlay mount using syscall.Mount()\n    // Hint: syscall.Mount(\"overlay\", target, \"overlay\", 0, options)\n    \n    // TODO 5: Verify mount succeeded by checking target directory contents\n    // Hint: List files in target and compare with expected layer contents\n    \n    return nil\n}\n\n// HandleCopyOnWrite demonstrates CoW behavior (for testing/debugging)\nfunc (fm *FilesystemManager) HandleCopyOnWrite(containerID, filePath string) error {\n    // TODO 1: Check if file exists in lower layers but not upper\n    // Hint: Check merged view vs upper directory directly\n    \n    // TODO 2: If file is in lower layer, demonstrate that modification triggers copy-up\n    // Hint: Write to file and verify copy appears in upper directory\n    \n    // TODO 3: Verify original file in lower layer remains unchanged\n    // Hint: Compare checksums before and after modification\n    \n    return nil\n}\n\n// CleanupContainerFilesystem removes overlay mount and directories\nfunc (fm *FilesystemManager) CleanupContainerFilesystem(containerID string) error {\n    // TODO 1: Get container paths (upper, work, merged)\n    // Hint: Use GetContainerPaths() method\n    \n    // TODO 2: Unmount overlay filesystem from merged directory\n    // Hint: Use syscall.Unmount() with 0 flags, retry with MNT_DETACH if busy\n    \n    // TODO 3: Remove container-specific directories (upper, work, merged)\n    // Hint: Use os.RemoveAll() for recursive removal\n    \n    // TODO 4: Remove container's layer references\n    // Hint: Use ReferenceManager.RemoveContainerReference()\n    \n    // TODO 5: Check if any image layers can be cleaned up (reference count = 0)\n    // Hint: Implement reference counting logic to identify unused layers\n    \n    return nil\n}\n\n// VerifyOverlayMount checks that overlay mount is working correctly\nfunc (fm *FilesystemManager) VerifyOverlayMount(containerID string) error {\n    // TODO 1: Check that merged directory is actually a mount point\n    // Hint: Parse /proc/mounts or use statfs() system call\n    \n    // TODO 2: Verify that files from all layers are visible in merged view\n    // Hint: List expected files and check they appear in merged directory\n    \n    // TODO 3: Test that writes go to upper directory\n    // Hint: Create test file in merged view, verify it appears in upper only\n    \n    // TODO 4: Test that whiteouts work for file deletion\n    // Hint: Delete a file from lower layer, verify whiteout created in upper\n    \n    return nil\n}\n```\n\n**Language-Specific Hints (Go):**\n\n- Use `syscall.Mount(\"overlay\", target, \"overlay\", 0, options)` for overlay mounting\n- Handle `syscall.EBUSY` errors on unmount by retrying with `syscall.MNT_DETACH`\n- Use `filepath.Join()` for cross-platform path construction\n- Check mount success by parsing `/proc/mounts` or using `unix.Statfs()`\n- Use `os.MkdirAll()` with 0755 permissions for directory creation\n- Implement proper cleanup with `defer` statements for resource management\n\n**Milestone Checkpoint:**\n\nAfter implementing the overlay filesystem component:\n\n1. **Test layer mounting:** Run `go test -v ./internal/filesystem -run TestOverlayMount`\n2. **Expected behavior:** Container should see merged view of all image layers\n3. **Manual verification:** \n   ```bash\n   # Check overlay mount exists\n   mount | grep overlay\n   \n   # Verify upper directory captures changes  \n   echo \"test\" > /path/to/merged/testfile\n   ls /path/to/upper/  # should show testfile\n   \n   # Verify lower layers unchanged\n   ls /path/to/layer1/  # original contents preserved\n   ```\n4. **Signs of trouble:** Mount failures usually indicate work directory issues or invalid layer paths\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---|---|---|---|\n| \"Invalid argument\" on mount | Work directory not empty or wrong filesystem | Check `ls -la workdir/` and `df workdir/` | Remove work directory contents, ensure same filesystem as upper |\n| \"Device busy\" on unmount | Processes holding open files | Use `lsof +D /merged/path` to find processes | Kill processes or use MNT_DETACH for lazy unmount |\n| Files missing in merged view | Wrong lowerdir order or missing layers | Check mount options in `/proc/mounts` | Verify layer paths exist and fix ordering |\n| CoW not working | Upper directory permissions or filesystem issues | Test write to merged view, check if file appears in upper | Fix upper directory permissions (755) |\n| Storage space not freed | Cleanup didn't remove upper directory | Check disk usage with `du -sh /var/lib/runtime/containers/` | Manual cleanup of container directories |\n\n\n## Network Management Component\n\n> **Milestone(s):** Milestone 4 (Container Networking) - This section implements bridge networking for containers with port mapping and inter-container communication using veth pairs, bridge networks, and NAT rules.\n\nContainer networking transforms isolated processes into communicating services by creating virtual network infrastructure that mimics physical networking concepts. The network management component orchestrates multiple Linux kernel networking features to provide containers with network interfaces, IP addresses, routing capabilities, and connectivity to both other containers and the external world. This component must handle the complexity of bridging multiple network namespaces while maintaining proper isolation boundaries and enabling controlled communication pathways.\n\nThe fundamental challenge in container networking lies in the paradox of isolation versus connectivity. Containers need network isolation for security and resource management, but they also need selective connectivity for inter-service communication and external access. Our network management component resolves this paradox by creating controlled communication channels through virtual networking infrastructure, allowing containers to communicate as if they were separate physical machines connected through network switches and routers.\n\n### Mental Model: Virtual Cable System\n\nThink of container networking like building a virtual office building with separate apartments (containers) that need telephone and internet connectivity. Each apartment starts completely isolated with no communication ability whatsoever. To provide connectivity, we run virtual cables and install virtual network equipment.\n\nThe **veth pair** acts like a special two-way cable with connectors on both ends. We plug one end into the apartment (container network namespace) and feed the other end through the wall into the building's main network room (host network namespace). This cable carries all network traffic bidirectionally between the apartment and the building's network infrastructure.\n\nThe **bridge** functions like a network switch in the building's main network room. All the cables coming from different apartments plug into this switch, allowing apartments to communicate with each other. The switch learns which apartment is connected to which port and intelligently forwards messages between apartments.\n\n**IP address assignment** works like assigning apartment numbers from a predetermined numbering scheme. Each apartment gets a unique address within the building's addressing plan (subnet), ensuring messages can be properly routed to the correct destination.\n\n**Port forwarding** acts like a receptionist service that forwards calls from the building's main phone line to specific apartment extensions. When someone calls the building from outside and asks for a specific service, the receptionist (NAT rules) knows which apartment provides that service and forwards the call appropriately.\n\nThis mental model helps understand that container networking creates a complete virtual networking infrastructure that mirrors physical networking concepts, allowing isolated containers to communicate in controlled and predictable ways.\n\n### Veth Pair and Bridge Setup\n\nThe foundation of container networking rests on creating **virtual ethernet pairs (veth pairs)** that connect isolated network namespaces to shared network infrastructure. A veth pair functions as a bidirectional pipe where packets written to one end immediately appear at the other end, enabling communication across namespace boundaries. The network management component must orchestrate the creation, configuration, and cleanup of these virtual network devices along with bridge networking that enables multi-container communication.\n\nThe veth pair creation process begins by generating unique interface names to avoid conflicts with existing network devices. The component creates the veth pair in the host network namespace, then moves one end into the target container's network namespace while keeping the other end in the host namespace. This asymmetric placement allows the host to manage connectivity while providing the container with an isolated network interface.\n\n> **Decision: Veth Pair Naming Strategy**\n> - **Context**: Veth interfaces need unique names to avoid conflicts, and names must be trackable for cleanup operations\n> - **Options Considered**: Random names, UUID-based names, container-ID-based names\n> - **Decision**: Use container ID prefix with interface type suffix (e.g., \"veth-container123-host\" and \"veth-container123-container\")\n> - **Rationale**: Container ID prefixes provide clear ownership mapping for cleanup operations while remaining human-readable for debugging. The host/container suffix clarifies which end of the pair each interface represents.\n> - **Consequences**: Enables efficient cleanup by interface name pattern matching, simplifies debugging by making interface ownership obvious, but limits container ID length due to Linux interface name restrictions.\n\nAfter creating the veth pair, the component must configure each interface with appropriate settings. The container-side interface receives an IP address from the configured subnet pool, while the host-side interface remains addressless but gets attached to the container bridge. Both interfaces must be brought up (activated) to enable packet flow, and the container interface typically becomes the default gateway interface within the container's network namespace.\n\nThe bridge setup process creates or reuses a shared bridge device that functions as a virtual network switch for container communication. The bridge maintains a MAC address learning table that maps container MAC addresses to specific ports, enabling efficient packet forwarding between containers. All host-side veth interfaces connect to this bridge, creating a shared layer-2 network segment for container communication.\n\n**Veth Pair Creation Algorithm:**\n\n1. Generate unique interface names using container ID and interface type suffixes to ensure no naming conflicts with existing network devices\n2. Create the veth pair in the host network namespace using the netlink library or ip command with both interfaces initially in the host namespace\n3. Move the container-side interface into the target container's network namespace using the setns system call or netlink operations\n4. Configure the container-side interface with an assigned IP address and appropriate subnet mask from the container network's address pool\n5. Set the container-side interface as the active default route within the container's network namespace for external connectivity\n6. Bring up both interfaces (host-side and container-side) to enable packet forwarding and establish the communication channel\n7. Attach the host-side interface to the container bridge, registering it as a bridge port for inter-container communication\n8. Configure MAC address learning and forwarding rules on the bridge port to enable proper packet switching between containers\n9. Store interface names and configuration details in the container state for cleanup operations when the container terminates\n\nThe bridge configuration requires careful attention to forwarding policies and security settings. The bridge must enable packet forwarding between attached ports while maintaining isolation from the host's main network interfaces unless explicitly configured otherwise. Bridge forwarding delays and learning timeouts affect container communication latency and convergence time for network topology changes.\n\n| Veth Configuration Parameter | Host Side Value | Container Side Value | Purpose |\n|-----|-----|-----|-----|\n| Interface Name | `veth-{containerID}-host` | `veth-{containerID}-container` | Unique identification and cleanup tracking |\n| IP Address | None (bridge attached) | Assigned from subnet pool | Container network identity |\n| Subnet Mask | N/A | /24 (or configured subnet) | Network boundary definition |\n| MTU Size | 1500 (or bridge MTU) | 1500 (matches host side) | Maximum packet size consistency |\n| MAC Address | Auto-generated | Auto-generated | Layer-2 addressing |\n| Administrative State | UP | UP | Interface activation |\n| Bridge Attachment | Yes (container bridge) | No (not applicable) | Inter-container communication |\n| Default Route | No | Yes (via bridge IP) | External connectivity |\n\n> The critical insight here is that veth pairs create a controlled breach in network namespace isolation. While containers remain isolated at the process and filesystem levels, the veth pair provides a precisely managed communication channel that enables networking while preserving other isolation boundaries.\n\n**Bridge Management Algorithm:**\n\n1. Check if the container bridge already exists, creating it if necessary with appropriate forwarding and learning settings\n2. Configure bridge IP address and subnet if this is the first container using the bridge, establishing the gateway address for container routing\n3. Enable IP forwarding on the bridge interface to allow packets to flow between bridge ports and external networks\n4. Set bridge forwarding delay and aging time parameters to optimize convergence time and memory usage for container networking patterns\n5. Attach the host-side veth interface as a bridge port, enabling the container to participate in the shared layer-2 network\n6. Configure port-specific settings like learning, flooding, and STP participation based on security and performance requirements\n7. Update bridge forwarding database with static entries if required for specific security or performance optimizations\n8. Enable or disable bridge features like VLAN filtering, multicast snooping, and spanning tree protocol based on deployment requirements\n\nThe component must handle bridge lifecycle management, creating bridges on demand and cleaning them up when no containers remain attached. Bridge cleanup requires careful ordering to avoid leaving orphaned network devices or disrupting communication for remaining containers.\n\n### IP Address Assignment\n\nContainer IP address assignment requires maintaining a pool of available addresses within a configured subnet while ensuring uniqueness and preventing conflicts with host network addressing. The network management component implements an IP address manager that tracks allocations, handles assignment and release operations, and persists address assignments across container restarts to maintain network identity stability.\n\nThe IP address pool operates within a designated subnet range that must not conflict with the host's network configuration or other container runtime instances. The component typically reserves the first address in the subnet for the bridge gateway, the last address for broadcast, and manages the remaining addresses as an assignable pool. Address assignment follows a deterministic or pseudo-random strategy to balance predictability with conflict avoidance.\n\n> **Decision: IP Address Assignment Strategy**\n> - **Context**: Containers need unique IP addresses from a managed pool, with consideration for restart stability and conflict avoidance\n> - **Options Considered**: Sequential assignment, hash-based deterministic assignment, random assignment with conflict detection\n> - **Decision**: Implement hash-based deterministic assignment with fallback to sequential search for conflicts\n> - **Rationale**: Hash-based assignment using container ID provides stable addresses across container restarts, improving debugging and configuration consistency. Sequential fallback ensures assignment success even with hash collisions.\n> - **Consequences**: Enables predictable container addressing for development and testing scenarios, but requires careful hash distribution to avoid clustering in the address space.\n\nThe address assignment process begins by computing a candidate address using a hash function applied to the container ID, then checking for conflicts with existing assignments. If the candidate address is available, the component reserves it and associates it with the container in the persistent address allocation table. If conflicts occur, the component falls back to sequential search from the candidate address to find the next available address.\n\nAddress persistence ensures that containers receive the same IP address across restarts when possible, maintaining network identity for services that depend on stable addressing. The component stores address assignments in a persistent data structure that survives runtime restarts and provides atomic allocation and release operations to prevent corruption during concurrent operations.\n\n| IP Assignment State | Container ID | Assigned IP | Allocation Time | Lease Expiry | Status |\n|-----|-----|-----|-----|-----|-----|\n| Active | container-web-01 | 172.16.0.10 | 2024-01-15T10:30:00Z | Never | Running |\n| Active | container-db-01 | 172.16.0.11 | 2024-01-15T10:31:00Z | Never | Running |\n| Reserved | container-web-02 | 172.16.0.12 | 2024-01-15T10:32:00Z | 2024-01-15T11:32:00Z | Stopped |\n| Released | N/A | 172.16.0.13 | N/A | N/A | Available |\n\n**IP Address Assignment Algorithm:**\n\n1. Load the current address allocation table from persistent storage to understand which addresses are currently assigned or reserved\n2. Compute candidate IP address by applying a hash function to the container ID, mapping to the configured subnet address range\n3. Check if the candidate address is available in the allocation table, considering both active assignments and temporary reservations\n4. If candidate is available, reserve the address for this container and update the allocation table with atomic write operations\n5. If candidate is unavailable, perform sequential search starting from candidate address to find the next available address in the subnet\n6. Validate that the selected address doesn't conflict with reserved addresses (gateway, broadcast, network) or host interface addresses\n7. Create a lease record with container ID, assigned address, allocation timestamp, and lease expiration policy for cleanup operations\n8. Configure the container's network interface with the assigned address, subnet mask, and default gateway pointing to the bridge\n9. Update the allocation table with the final assignment and ensure changes are persisted to storage before returning success\n\nThe component implements address conflict detection by maintaining both active assignments (for running containers) and reserved assignments (for recently stopped containers). Reserved assignments have expiration times that allow address reuse while providing stability for containers that restart quickly. This two-tier approach balances address space efficiency with operational convenience.\n\nAddress release requires careful cleanup to avoid premature reuse that could cause network conflicts. When containers stop, their addresses transition to reserved status with configurable lease expiration times. After lease expiration, addresses return to the available pool. The component implements background cleanup processes that reclaim expired addresses and compact the allocation table.\n\n**Subnet Pool Configuration:**\n\n| Parameter | Default Value | Description | Constraints |\n|-----|-----|-----|-----|\n| Subnet CIDR | 172.16.0.0/24 | Network range for container addresses | Must not conflict with host routes |\n| Gateway Address | 172.16.0.1 | Bridge IP address for container default route | First usable address in subnet |\n| Address Pool Start | 172.16.0.10 | First address available for container assignment | After gateway and reserved addresses |\n| Address Pool End | 172.16.0.250 | Last address available for container assignment | Before broadcast and reserved addresses |\n| Lease Duration | 1 hour | Time to hold reserved addresses after container stop | Balance stability vs efficiency |\n| Allocation Strategy | Hash + Sequential | Method for selecting candidate addresses | Deterministic with conflict resolution |\n\nThe network management component must coordinate IP address assignments with DNS configuration when containers require hostname resolution. Address assignments can trigger DNS record creation in internal DNS servers, enabling containers to resolve each other by hostname in addition to IP address communication.\n\n### Port Forwarding with NAT\n\nPort forwarding enables external clients to access services running inside containers by creating Network Address Translation (NAT) rules that redirect traffic from host ports to container ports. The network management component implements port forwarding using iptables rules that modify packet headers as traffic flows between the external network and container network namespaces. This capability transforms isolated container services into accessible network services while maintaining container isolation for non-forwarded ports.\n\nThe port forwarding mechanism operates by intercepting packets destined for specific host ports and redirecting them to corresponding container IP addresses and ports. The component creates iptables rules in the NAT table that perform Destination Network Address Translation (DNAT), changing the destination address from the host IP to the container IP while preserving the original source information for proper return routing.\n\nPort forwarding configuration requires careful coordination between the host firewall rules, bridge forwarding policies, and container network configuration. The component must ensure that forwarded traffic can traverse all network boundaries while maintaining security restrictions for non-forwarded traffic. This involves creating rules in multiple iptables chains and tables to handle different phases of packet processing.\n\n> **Decision: NAT Rule Management Strategy**\n> - **Context**: Container port forwarding requires iptables rules that must be created atomically and cleaned up reliably without interfering with other system rules\n> - **Options Considered**: Direct iptables rule manipulation, custom chain isolation, netfilter hooks programmatic control\n> - **Decision**: Use custom iptables chains for container rules with atomic rule set replacement\n> - **Rationale**: Custom chains provide isolation from system rules, reducing the risk of conflicts. Atomic replacement ensures consistent rule states during updates. Chain-based organization simplifies bulk cleanup operations.\n> - **Consequences**: Enables safe concurrent rule management and reliable cleanup, but requires understanding of iptables chain traversal and rule precedence for effective debugging.\n\nThe component creates dedicated iptables chains for container networking rules, avoiding conflicts with system-level firewall policies. Container-specific DNAT rules are added to these custom chains, with jump rules in the standard chains directing relevant traffic through the container rule processing. This architecture enables atomic updates and complete cleanup of container networking rules without affecting other system networking configuration.\n\nPort forwarding rules must handle both TCP and UDP protocols with appropriate connection tracking and state management. The component creates separate rules for each protocol type, ensuring that connection state tracking works correctly for bi-directional communication. Return traffic must be properly handled through connection tracking to maintain the appearance of direct communication between external clients and container services.\n\n| Port Mapping Configuration | Host Port | Container IP | Container Port | Protocol | Rule Priority |\n|-----|-----|-----|-----|-----|-----|\n| Web Service | 8080 | 172.16.0.10 | 80 | TCP | 100 |\n| Database Access | 5432 | 172.16.0.11 | 5432 | TCP | 100 |\n| DNS Service | 53 | 172.16.0.12 | 53 | UDP | 100 |\n| SSH Access | 2222 | 172.16.0.10 | 22 | TCP | 100 |\n| Custom API | 9000 | 172.16.0.13 | 3000 | TCP | 100 |\n\n**Port Forwarding Setup Algorithm:**\n\n1. Validate port mapping configuration to ensure host ports are not already in use by other services or containers\n2. Create container-specific iptables chain names to isolate rules and enable atomic cleanup operations when containers are removed\n3. Add jump rules to standard iptables chains (PREROUTING, FORWARD) that direct container traffic to the custom chains for processing\n4. Create DNAT rules in the PREROUTING chain that change destination address from host IP to container IP for specified ports\n5. Create FORWARD rules that allow traffic to flow from external interfaces to the container bridge for forwarded ports only\n6. Enable connection tracking for return traffic by creating corresponding rules in the POSTROUTING chain for source NAT if required\n7. Configure bridge forwarding rules to allow traffic destined for container IP addresses to traverse the bridge interface correctly\n8. Test connectivity by verifying that packets can flow bidirectionally between external clients and container services through the NAT rules\n9. Store port mapping configuration in container state for proper cleanup when the container is stopped or removed\n\nThe component must handle port conflict detection to prevent multiple containers from attempting to bind the same host port. Port allocation tracking maintains a registry of active port forwarding rules, preventing conflicts during container creation and enabling proper cleanup during container removal.\n\nConnection tracking configuration affects the performance and reliability of port forwarding rules. The component configures netfilter connection tracking parameters to handle the expected connection volume and timeout characteristics of container services. Proper connection tracking ensures that established connections continue working even if iptables rules are temporarily modified during container updates.\n\n**IPTables Rule Structure:**\n\nThe network management component creates a structured set of iptables rules organized into logical groups for maintainability and atomic updates:\n\n| Chain Name | Table | Purpose | Rule Examples |\n|-----|-----|-----|-----|\n| CONTAINER-DNAT | nat | Destination address translation for inbound traffic | `-p tcp --dport 8080 -j DNAT --to-destination 172.16.0.10:80` |\n| CONTAINER-FORWARD | filter | Traffic forwarding authorization for container access | `-d 172.16.0.10 -p tcp --dport 80 -j ACCEPT` |\n| CONTAINER-POSTROUTING | nat | Source address translation for outbound traffic if needed | `-s 172.16.0.0/24 ! -d 172.16.0.0/24 -j MASQUERADE` |\n\nPort forwarding cleanup requires removing all related iptables rules in the correct order to avoid temporary connectivity disruption or rule inconsistencies. The component implements a cleanup algorithm that removes rules from chains in dependency order, then removes custom chains once they are empty. This ensures that no orphaned rules remain that could interfere with future container networking operations.\n\n⚠️ **Pitfall: Persistent IPTables Rules**\n\nA common mistake is failing to properly clean up iptables rules when containers are removed, leading to accumulated rule sets that can cause port conflicts and security vulnerabilities. The issue manifests as \"port already in use\" errors when creating new containers, or unexpected traffic forwarding to non-existent containers.\n\nThe problem occurs because iptables rules persist independently of the processes that created them. Even if a container stops or the container runtime crashes, the NAT and forwarding rules remain active in the kernel. This leads to several problematic scenarios: host ports appear occupied when they're not, traffic gets dropped because target containers no longer exist, and rule accumulation degrades networking performance.\n\nThe solution requires implementing robust cleanup procedures that execute during both normal container shutdown and runtime recovery operations. The component must maintain accurate records of which iptables rules belong to which containers, and implement cleanup verification that ensures rules are actually removed. Additionally, the runtime should perform rule audit operations on startup to clean up orphaned rules from previous runtime instances.\n\n**Advanced Port Forwarding Features:**\n\nThe network management component can extend basic port forwarding with additional features that improve usability and security:\n\n| Feature | Implementation Approach | Benefits | Complexity |\n|-----|-----|-----|-----|\n| Dynamic Port Allocation | Maintain pool of available host ports, assign automatically | Reduces port conflicts, simplifies container deployment | Medium |\n| Port Range Forwarding | Create rules for contiguous port ranges rather than individual ports | Supports applications that use multiple ports | Medium |\n| Source IP Filtering | Add source address restrictions to DNAT rules | Enhances security by limiting access origins | Low |\n| Load Balancing | Distribute traffic across multiple container instances | Improves service availability and performance | High |\n\n![Container Network Topology](./diagrams/network-topology.svg)\n\nThe network topology diagram illustrates how these networking components work together to create a complete container networking solution. Containers receive isolated network namespaces connected through veth pairs to a shared bridge, with iptables NAT rules enabling external access to container services while maintaining isolation boundaries.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Veth Interface Cleanup Order**\n\nA frequent mistake involves deleting the host-side veth interface before properly shutting down the container process, causing network connectivity loss and potential container hanging. When the host-side veth interface disappears while the container is still running, the container loses all network connectivity including the ability to shut down gracefully if it needs to communicate with external services during shutdown.\n\nThis problem manifests as containers that appear to stop responding during shutdown sequences, taking the full shutdown timeout before being forcefully terminated. The issue occurs because the container's network interface becomes unusable when its paired host interface is removed, but the container may not detect this failure immediately and continues attempting network operations.\n\nThe solution requires implementing proper shutdown sequencing where container processes are terminated first, allowing them to complete network-dependent shutdown operations before their network interfaces are removed. The component should wait for container process termination before cleaning up veth interfaces, and implement timeout handling for containers that fail to shut down gracefully within reasonable time limits.\n\n⚠️ **Pitfall: Bridge MTU Misconfiguration**\n\nIncorrectly configured Maximum Transmission Unit (MTU) sizes between veth interfaces and the container bridge cause packet fragmentation and connectivity problems that are difficult to diagnose. When veth interfaces have different MTU sizes than the bridge they connect to, large packets get fragmented or dropped, leading to inconsistent connectivity where small requests work but large data transfers fail.\n\nThe problem typically appears as applications that work for small operations but fail when transferring larger amounts of data. Web applications might load basic pages but fail when uploading files or receiving large API responses. The issue is particularly confusing because basic connectivity tests succeed while real-world usage fails unpredictably.\n\nThe solution requires ensuring MTU consistency across all components in the network path: host interfaces, bridge interfaces, and container veth interfaces must all use compatible MTU sizes. The component should detect the host network MTU and configure all container networking components to use the same or smaller MTU values, avoiding fragmentation issues.\n\n⚠️ **Pitfall: IP Address Pool Exhaustion**\n\nFailing to implement proper address pool management leads to IP address exhaustion when containers are created and destroyed frequently, especially during development and testing scenarios. The pool exhaustion occurs when addresses remain marked as \"in use\" after containers are removed, eventually preventing new container creation even though no containers are actually using the addresses.\n\nThis problem manifests as container creation failures with \"no available IP addresses\" errors, even when few or no containers are currently running. The issue compounds over time as the pool becomes increasingly fragmented with unusable address reservations. Development workflows that create and destroy many containers quickly are particularly susceptible to this problem.\n\nThe solution requires implementing robust address lifecycle management with proper cleanup procedures and lease expiration handling. The component must track address assignments accurately, implement cleanup verification to ensure addresses are actually released when containers stop, and provide administrative tools to manually reclaim orphaned address allocations when automatic cleanup fails.\n\n⚠️ **Pitfall: IPTables Rule Conflicts**\n\nCreating iptables rules without considering existing system firewall configuration can cause rule conflicts that break both container networking and host system connectivity. The conflicts arise when container networking rules interfere with system security policies, or when system changes modify the iptables configuration in ways that break container connectivity.\n\nThis problem appears as intermittent connectivity failures that depend on the specific system firewall configuration and the order of rule evaluation. Containers might lose network access after system updates that modify firewall rules, or system services might become inaccessible when container networking rules interfere with host networking policies.\n\nThe solution requires implementing defensive rule management that uses custom iptables chains to isolate container networking rules from system rules. The component should check for existing rule conflicts before creating new rules, use rule priorities that don't interfere with system security policies, and implement rule verification procedures that detect when external changes break container networking functionality.\n\n### Implementation Guidance\n\nThe network management component requires careful integration with Linux networking APIs and external tools to create and manage virtual network infrastructure. This component represents the most complex aspect of container runtime development due to its dependencies on kernel networking features and interaction with system-level network configuration.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----|-----|-----|\n| Netlink Communication | `vishvananda/netlink` Go library | Direct netlink socket programming |\n| IP Address Management | File-based JSON persistence | Embedded database (BoltDB/BadgerDB) |\n| IPTables Management | `coreos/go-iptables` wrapper library | Direct iptables binary execution |\n| Network Interface Creation | `ip` command execution via `os/exec` | Pure netlink API calls |\n| Bridge Management | Linux bridge utilities + commands | Programmatic netlink bridge control |\n\n**Recommended File Structure:**\n\n```\ncontainer-runtime/\n  internal/network/\n    manager.go              ← main network management orchestrator\n    veth.go                ← veth pair creation and management\n    bridge.go              ← bridge networking setup and control\n    ipam.go                ← IP address allocation and management\n    nat.go                 ← port forwarding and iptables rules\n    types.go               ← network-related data structures\n    manager_test.go        ← comprehensive networking integration tests\n  internal/netutil/\n    netlink.go             ← netlink communication helpers\n    iptables.go            ← iptables rule management utilities\n    validation.go          ← network configuration validation\n  configs/\n    network-default.json   ← default network configuration\n```\n\n**Infrastructure Starter Code (Complete Network Utilities):**\n\n```go\n// Package netutil provides low-level networking utilities for container runtime\npackage netutil\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"os/exec\"\n    \"strconv\"\n    \"strings\"\n    \"github.com/vishvananda/netlink\"\n    \"github.com/coreos/go-iptables/iptables\"\n)\n\n// NetworkConfig defines network configuration for containers\ntype NetworkConfig struct {\n    BridgeName    string   `json:\"bridge_name\"`\n    SubnetCIDR    string   `json:\"subnet_cidr\"`\n    GatewayIP     string   `json:\"gateway_ip\"`\n    DNSServers    []string `json:\"dns_servers\"`\n    IPTablesChain string   `json:\"iptables_chain\"`\n}\n\n// IPTablesManager wraps iptables operations with error handling\ntype IPTablesManager struct {\n    ipt *iptables.IPTables\n}\n\n// NewIPTablesManager creates a new iptables manager instance\nfunc NewIPTablesManager() (*IPTablesManager, error) {\n    ipt, err := iptables.New()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to initialize iptables: %w\", err)\n    }\n    return &IPTablesManager{ipt: ipt}, nil\n}\n\n// CreateChain creates a custom iptables chain for container rules\nfunc (m *IPTablesManager) CreateChain(table, chain string) error {\n    exists, err := m.ipt.ChainExists(table, chain)\n    if err != nil {\n        return fmt.Errorf(\"failed to check chain existence: %w\", err)\n    }\n    if !exists {\n        if err := m.ipt.NewChain(table, chain); err != nil {\n            return fmt.Errorf(\"failed to create chain %s: %w\", chain, err)\n        }\n    }\n    return nil\n}\n\n// AddRule adds an iptables rule with validation\nfunc (m *IPTablesManager) AddRule(table, chain string, rulespec ...string) error {\n    exists, err := m.ipt.Exists(table, chain, rulespec...)\n    if err != nil {\n        return fmt.Errorf(\"failed to check rule existence: %w\", err)\n    }\n    if !exists {\n        if err := m.ipt.Insert(table, chain, 1, rulespec...); err != nil {\n            return fmt.Errorf(\"failed to add rule: %w\", err)\n        }\n    }\n    return nil\n}\n\n// RemoveRule removes an iptables rule with validation\nfunc (m *IPTablesManager) RemoveRule(table, chain string, rulespec ...string) error {\n    exists, err := m.ipt.Exists(table, chain, rulespec...)\n    if err != nil {\n        return fmt.Errorf(\"failed to check rule existence: %w\", err)\n    }\n    if exists {\n        if err := m.ipt.Delete(table, chain, rulespec...); err != nil {\n            return fmt.Errorf(\"failed to remove rule: %w\", err)\n        }\n    }\n    return nil\n}\n\n// NetlinkHelper provides higher-level netlink operations\ntype NetlinkHelper struct{}\n\n// CreateVethPair creates a veth pair with specified names\nfunc (n *NetlinkHelper) CreateVethPair(hostName, containerName string) error {\n    hostVeth := &netlink.Veth{\n        LinkAttrs: netlink.LinkAttrs{Name: hostName},\n        PeerName:  containerName,\n    }\n    \n    if err := netlink.LinkAdd(hostVeth); err != nil {\n        return fmt.Errorf(\"failed to create veth pair: %w\", err)\n    }\n    return nil\n}\n\n// MoveInterfaceToNamespace moves network interface to target namespace\nfunc (n *NetlinkHelper) MoveInterfaceToNamespace(interfaceName string, pid int) error {\n    link, err := netlink.LinkByName(interfaceName)\n    if err != nil {\n        return fmt.Errorf(\"failed to find interface %s: %w\", interfaceName, err)\n    }\n    \n    if err := netlink.LinkSetNsPid(link, pid); err != nil {\n        return fmt.Errorf(\"failed to move interface to namespace: %w\", err)\n    }\n    return nil\n}\n\n// ConfigureInterface sets IP address and brings interface up\nfunc (n *NetlinkHelper) ConfigureInterface(interfaceName, ipAddr string) error {\n    link, err := netlink.LinkByName(interfaceName)\n    if err != nil {\n        return fmt.Errorf(\"failed to find interface %s: %w\", interfaceName, err)\n    }\n    \n    addr, err := netlink.ParseAddr(ipAddr)\n    if err != nil {\n        return fmt.Errorf(\"failed to parse IP address %s: %w\", ipAddr, err)\n    }\n    \n    if err := netlink.AddrAdd(link, addr); err != nil {\n        return fmt.Errorf(\"failed to add IP address: %w\", err)\n    }\n    \n    if err := netlink.LinkSetUp(link); err != nil {\n        return fmt.Errorf(\"failed to bring interface up: %w\", err)\n    }\n    \n    return nil\n}\n\n// CreateBridge creates and configures a network bridge\nfunc (n *NetlinkHelper) CreateBridge(bridgeName, bridgeIP string) error {\n    bridge := &netlink.Bridge{\n        LinkAttrs: netlink.LinkAttrs{Name: bridgeName},\n    }\n    \n    if err := netlink.LinkAdd(bridge); err != nil {\n        if !strings.Contains(err.Error(), \"file exists\") {\n            return fmt.Errorf(\"failed to create bridge: %w\", err)\n        }\n    }\n    \n    if bridgeIP != \"\" {\n        if err := n.ConfigureInterface(bridgeName, bridgeIP); err != nil {\n            return fmt.Errorf(\"failed to configure bridge IP: %w\", err)\n        }\n    }\n    \n    return nil\n}\n\n// AttachInterfaceToBridge attaches interface to bridge\nfunc (n *NetlinkHelper) AttachInterfaceToBridge(interfaceName, bridgeName string) error {\n    iface, err := netlink.LinkByName(interfaceName)\n    if err != nil {\n        return fmt.Errorf(\"failed to find interface %s: %w\", interfaceName, err)\n    }\n    \n    bridge, err := netlink.LinkByName(bridgeName)\n    if err != nil {\n        return fmt.Errorf(\"failed to find bridge %s: %w\", bridgeName, err)\n    }\n    \n    if err := netlink.LinkSetMaster(iface, bridge); err != nil {\n        return fmt.Errorf(\"failed to attach interface to bridge: %w\", err)\n    }\n    \n    return nil\n}\n\n// ValidateNetworkConfig validates network configuration parameters\nfunc ValidateNetworkConfig(config NetworkConfig) error {\n    if config.BridgeName == \"\" {\n        return fmt.Errorf(\"bridge name cannot be empty\")\n    }\n    \n    _, _, err := net.ParseCIDR(config.SubnetCIDR)\n    if err != nil {\n        return fmt.Errorf(\"invalid subnet CIDR: %w\", err)\n    }\n    \n    if net.ParseIP(config.GatewayIP) == nil {\n        return fmt.Errorf(\"invalid gateway IP address: %s\", config.GatewayIP)\n    }\n    \n    return nil\n}\n```\n\n**Core Logic Skeleton Code:**\n\n```go\n// Package network implements container networking with veth pairs, bridges, and NAT\npackage network\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net\"\n    \"sync\"\n    \"time\"\n    \"container-runtime/internal/netutil\"\n)\n\n// Manager orchestrates container networking operations\ntype Manager struct {\n    config       netutil.NetworkConfig\n    ipam         *IPAddressManager\n    iptables     *netutil.IPTablesManager\n    netlink      *netutil.NetlinkHelper\n    mu           sync.RWMutex\n    containers   map[string]*ContainerNetwork\n}\n\n// ContainerNetwork tracks networking state for a container\ntype ContainerNetwork struct {\n    ContainerID     string\n    VethHost        string\n    VethContainer   string\n    IPAddress       string\n    PortMappings    []PortMapping\n    CreatedAt       time.Time\n}\n\n// NewManager creates a new network manager instance\nfunc NewManager(config netutil.NetworkConfig) (*Manager, error) {\n    // TODO 1: Validate network configuration parameters\n    // TODO 2: Initialize IP address manager with subnet pool\n    // TODO 3: Create iptables manager for NAT rule management\n    // TODO 4: Initialize netlink helper for interface operations\n    // TODO 5: Create container bridge if it doesn't exist\n    // TODO 6: Set up base iptables chains for container networking\n    // TODO 7: Enable IP forwarding on the host system\n    // Hint: Use netutil.ValidateNetworkConfig for validation\n}\n\n// SetupContainerNetwork creates complete network setup for container\nfunc (m *Manager) SetupContainerNetwork(containerID string, portMappings []PortMapping, pid int) (*ContainerNetwork, error) {\n    // TODO 1: Generate unique veth interface names for this container\n    // TODO 2: Allocate IP address from the managed pool\n    // TODO 3: Create veth pair in host network namespace\n    // TODO 4: Move container-side veth to container network namespace\n    // TODO 5: Configure container interface with allocated IP address\n    // TODO 6: Attach host-side veth to container bridge\n    // TODO 7: Create port forwarding rules for specified port mappings\n    // TODO 8: Store container network state for cleanup operations\n    // TODO 9: Verify connectivity by testing basic network operations\n    // Hint: Use m.createVethPair, m.allocateIPAddress, m.setupPortForwarding\n}\n\n// createVethPair creates and configures veth pair for container\nfunc (m *Manager) createVethPair(containerID, hostVeth, containerVeth string, pid int) error {\n    // TODO 1: Create veth pair using netlink helper with generated names\n    // TODO 2: Move container-side interface to container network namespace\n    // TODO 3: Bring up host-side interface in host namespace\n    // TODO 4: Attach host-side interface to container bridge\n    // TODO 5: Verify both interfaces are properly configured and active\n    // Hint: Use netlink helper methods for interface operations\n}\n\n// configureContainerInterface sets up networking inside container namespace\nfunc (m *Manager) configureContainerInterface(containerVeth, ipAddress string, pid int) error {\n    // TODO 1: Enter container network namespace using setns syscall\n    // TODO 2: Configure container interface with assigned IP address\n    // TODO 3: Set up default route pointing to bridge gateway\n    // TODO 4: Configure loopback interface for internal communication\n    // TODO 5: Return to host network namespace after configuration\n    // Hint: Use netlink operations within target namespace context\n}\n\n// setupPortForwarding creates NAT rules for container port access\nfunc (m *Manager) setupPortForwarding(containerID, containerIP string, portMappings []PortMapping) error {\n    // TODO 1: Create container-specific iptables chain for isolation\n    // TODO 2: Add jump rule to direct traffic to container chain\n    // TODO 3: Create DNAT rules for each port mapping specification\n    // TODO 4: Create corresponding FORWARD rules for traffic authorization\n    // TODO 5: Add MASQUERADE rule for return traffic if needed\n    // TODO 6: Verify rules are active and processing traffic correctly\n    // Hint: Use iptables manager methods with proper rule ordering\n}\n\n// CleanupContainerNetwork removes all network resources for container\nfunc (m *Manager) CleanupContainerNetwork(containerID string) error {\n    // TODO 1: Load container network state from storage\n    // TODO 2: Remove port forwarding iptables rules\n    // TODO 3: Delete custom iptables chains if empty\n    // TODO 4: Remove veth interfaces from bridge and host\n    // TODO 5: Release IP address back to available pool\n    // TODO 6: Clean up container network state records\n    // TODO 7: Verify all resources are properly cleaned up\n    // Hint: Implement cleanup in reverse order of setup operations\n}\n\n// IPAddressManager handles IP address allocation and tracking\ntype IPAddressManager struct {\n    subnet      *net.IPNet\n    gateway     net.IP\n    allocated   map[string]string  // containerID -> IP\n    reserved    map[string]time.Time  // IP -> expiry\n    mu          sync.RWMutex\n}\n\n// AllocateIP assigns IP address to container with conflict detection\nfunc (ipam *IPAddressManager) AllocateIP(containerID string) (string, error) {\n    // TODO 1: Check if container already has IP assignment\n    // TODO 2: Compute candidate IP using hash of container ID\n    // TODO 3: Verify candidate IP is within subnet and not reserved\n    // TODO 4: If candidate unavailable, search sequentially for free IP\n    // TODO 5: Reserve selected IP address for this container\n    // TODO 6: Update allocation records with persistent storage\n    // TODO 7: Return assigned IP address in CIDR notation\n    // Hint: Use hash function for deterministic assignment strategy\n}\n\n// ReleaseIP returns IP address to available pool\nfunc (ipam *IPAddressManager) ReleaseIP(containerID string) error {\n    // TODO 1: Look up current IP assignment for container\n    // TODO 2: Remove active allocation record\n    // TODO 3: Add IP to reserved pool with expiration time\n    // TODO 4: Update persistent storage with allocation changes\n    // TODO 5: Verify IP is properly marked as available\n    // Hint: Implement grace period before returning IP to pool\n}\n```\n\n**Language-Specific Hints:**\n\n- Use `vishvananda/netlink` library for programmatic network interface management instead of executing shell commands\n- The `coreos/go-iptables` library provides safe iptables rule management with existence checking and atomic operations\n- Network namespace operations require `syscall.Setns()` to enter target namespace before configuring interfaces\n- Use `sync.RWMutex` for concurrent access to IP allocation maps and container network state\n- Implement proper cleanup with `defer` statements to ensure resources are released even if errors occur\n- Use `context.Context` for timeout handling during network operations that might hang\n- The `net` package provides utilities for IP address parsing, subnet calculations, and CIDR operations\n\n**Milestone Checkpoint:**\n\nAfter implementing the network management component, verify functionality with these tests:\n\n```bash\n# Test 1: Basic container networking\ngo run cmd/container-runtime/main.go create --id test-net --image alpine --command \"sleep 30\" --port 8080:80\n# Expected: Container starts with assigned IP address and veth pair created\n\n# Test 2: Inter-container communication  \ngo run cmd/container-runtime/main.go create --id container1 --image alpine --command \"nc -l -p 8080\"\ngo run cmd/container-runtime/main.go create --id container2 --image alpine --command \"nc container1-ip 8080\"\n# Expected: Containers can communicate directly via bridge networking\n\n# Test 3: Port forwarding functionality\ngo run cmd/container-runtime/main.go create --id web-server --image nginx --port 8080:80\ncurl http://localhost:8080\n# Expected: External access to container service through port forwarding\n\n# Test 4: Network cleanup verification\ngo run cmd/container-runtime/main.go remove web-server\niptables -t nat -L | grep \"web-server\"\nip link show | grep \"veth-web-server\"\n# Expected: No iptables rules or veth interfaces remain after cleanup\n```\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|-----|-----|-----|-----|\n| Container has no network connectivity | Veth pair not created or misconfigured | `ip link show` in both namespaces | Verify veth creation and namespace assignment |\n| External clients can't reach container | Port forwarding rules missing or incorrect | `iptables -t nat -L -n` to check DNAT rules | Recreate iptables rules with correct addresses |\n| Containers can't communicate with each other | Bridge not forwarding or IP assignment conflicts | `brctl show` and ping tests between containers | Check bridge configuration and IP allocations |\n| \"No available IP addresses\" error | IP pool exhausted or addresses not released | Check IPAM allocation records and container states | Implement address cleanup or expand subnet |\n| Network setup hangs during container creation | Netlink operations blocked or namespace issues | `strace` the runtime process for system call failures | Check for kernel version compatibility and permissions |\n\nThe network management component represents the final major subsystem in the container runtime, providing the networking foundation that transforms isolated processes into communicating services. Proper implementation of veth pairs, bridge networking, and port forwarding creates a complete container networking solution that balances isolation with connectivity requirements.\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** All milestones (1-4) - This section describes how components coordinate during the complete container lifecycle, showing the orchestration of namespace creation (Milestone 1), resource control setup (Milestone 2), filesystem mounting (Milestone 3), and network configuration (Milestone 4).\n\n### Mental Model: Orchestra Conductor\n\nThink of the container runtime as a symphony orchestra performing a complex musical piece. The **Runtime Manager** serves as the conductor, coordinating multiple specialized sections (components) to create a harmonious performance. Each section has specific expertise - the **Namespace Handler** is like the string section providing the foundational melody (isolation), the **Resource Control Component** is like the percussion section maintaining rhythm and timing (resource limits), the **Filesystem Manager** is like the brass section adding layers of richness (overlay filesystem), and the **Network Manager** is like the woodwinds connecting different musical phrases (container communication).\n\nJust as a conductor must start each section at precisely the right moment and ensure they work together without interfering with each other, the Runtime Manager must orchestrate container creation by coordinating namespace setup, cgroup creation, filesystem mounting, and network configuration in the correct sequence. If the conductor stops the music abruptly, each section must wind down gracefully - similarly, when stopping a container, each component must clean up its resources in the proper order to avoid leaving the system in an inconsistent state.\n\nThe magic happens in the coordination - each component performs its specialized function, but the real value emerges from how they work together to create an isolated, resource-controlled, networked container environment that appears seamless to the user.\n\n### Container Creation Sequence\n\nThe container creation sequence represents the most complex orchestration in our runtime, involving careful coordination between all components to establish a fully functional isolated environment. This process must handle partial failures gracefully, ensuring that if any step fails, previously created resources are properly cleaned up.\n\n![Container Creation Sequence](./diagrams/container-creation-sequence.svg)\n\n#### Pre-Creation Validation Phase\n\nBefore beginning the actual container creation, the Runtime Manager performs comprehensive validation to catch configuration errors early, before any system resources are allocated. This validation phase prevents scenarios where container creation fails halfway through due to invalid specifications, leaving partially created resources that require cleanup.\n\nThe validation process examines the `ContainerSpec` thoroughly, checking that the container ID follows the required format (alphanumeric characters, hyphens, and underscores only, 1-64 characters in length), the specified image layers exist in the local storage, resource limits are within acceptable ranges, and network configuration parameters are valid. Port mapping validation ensures that requested host ports are available and that container ports are within valid ranges (1-65535).\n\n| Validation Check | Purpose | Failure Consequence |\n|-----------------|---------|-------------------|\n| Container ID format | Ensure filesystem-safe naming | Prevents mount point creation issues |\n| Image layer existence | Verify overlay dependencies | Prevents overlayfs mount failures |\n| Resource limit bounds | Validate cgroup parameters | Prevents cgroup controller errors |\n| Port availability | Check host port conflicts | Prevents iptables rule conflicts |\n| Network subnet capacity | Ensure IP addresses available | Prevents IP allocation failures |\n\n> **Design Insight**: Front-loading validation prevents resource leakage. It's much cleaner to reject an invalid container specification before creating any namespaces or cgroups than to handle cleanup after partial creation failure.\n\n#### Component Initialization Sequence\n\nOnce validation passes, the Runtime Manager begins the coordinated initialization sequence. This sequence is carefully ordered to handle dependencies between components - for example, namespaces must exist before processes can be assigned to cgroups, and the network namespace must be created before veth pairs can be moved into it.\n\n**Step 1: Container State Initialization**\n\nThe Runtime Manager creates a new `ContainerState` record with status `ContainerCreated` and persists it to the state store. This persistent record serves as the authoritative source of truth about the container's existence and current state, enabling recovery operations if the runtime process crashes during creation.\n\n**Step 2: Namespace Creation**\n\nThe Namespace Handler receives the container's `NamespaceConfig` and creates the requested Linux namespaces. The namespace creation follows a specific order: user namespace first (if enabled) to establish privilege boundaries, followed by PID, mount, network, UTS, and IPC namespaces. Each namespace creation is verified before proceeding to the next.\n\nThe namespace creation process involves creating a new process with the appropriate `CLONE_NEW*` flags, configuring the namespace environment (such as UID/GID mappings for user namespaces), and establishing the communication channel for coordinating with the container process. The `NamespaceHandle` returned contains the process ID of the namespace holder and references to all created namespaces.\n\n**Step 3: Filesystem Preparation**\n\nWith namespaces established, the Filesystem Manager prepares the container's root filesystem using overlayfs. This involves creating the directory structure for the overlay mount (upper directory for container changes, work directory for overlayfs operations), combining the image layers into the lower directories specification, and mounting the overlayfs with the proper options.\n\nThe overlay mount operation requires careful attention to mount options, ensuring that the work directory is on the same filesystem as the upper directory, that the lower directories are specified in the correct order (base layer first), and that the mount point has the appropriate permissions for the container's user namespace mappings.\n\n**Step 4: Cgroup Setup**\n\nThe Resource Control Component creates the container's cgroup hierarchy and applies the specified resource limits. This involves creating a new cgroup under the runtime's cgroup subtree, enabling the required controllers (memory, CPU, I/O), configuring the resource limits according to the `ResourceLimits` specification, and preparing the cgroup for process assignment.\n\nThe cgroup creation must handle cgroups v2 delegation properly, ensuring that the runtime has sufficient permissions to create and manage the container cgroup, that the required controllers are available in the parent cgroup, and that resource limits are set before any processes are assigned to the cgroup.\n\n**Step 5: Network Configuration**\n\nThe Network Manager sets up the container's networking environment by creating a veth pair, moving one end into the container's network namespace, configuring IP addresses and routing, and establishing port forwarding rules if required. This step requires coordination with the previously created network namespace.\n\nThe network setup process involves creating uniquely named veth interfaces, moving the container end of the veth pair into the container's network namespace, configuring the container interface with an allocated IP address, attaching the host end of the veth pair to the container bridge, and creating iptables rules for any requested port mappings.\n\n**Step 6: Essential Mount Setup**\n\nWithin the container's mount namespace, essential filesystem mounts are established to provide the container with a functional environment. This includes mounting `/proc` with the appropriate options for the PID namespace, mounting `/sys` with restricted access, creating `/dev` with essential device nodes, and establishing `/tmp` as a tmpfs mount.\n\nThese mounts are critical for container functionality - `/proc` provides process information and system interfaces, `/sys` exposes kernel information, and `/dev` provides access to essential devices like `/dev/null`, `/dev/zero`, and `/dev/random`.\n\n#### State Transition and Process Launch\n\nAfter all components have successfully prepared their resources, the Runtime Manager transitions the container state from `ContainerCreated` to `ContainerRunning` and launches the container's main process. This final step involves executing the container command within the prepared namespace environment, assigning the process to the container's cgroup, and establishing monitoring for the container process.\n\nThe process launch uses the Linux `execve` system call to replace the namespace holder process with the container's specified command, ensuring that the process inherits all the prepared namespace, filesystem, and network configuration. The process ID is recorded in the `ContainerState` for future management operations.\n\n#### Failure Recovery During Creation\n\nThe container creation sequence must handle failures at any step, implementing a rollback mechanism that cleans up successfully created resources. The cleanup sequence runs in reverse order of creation, ensuring that dependencies are properly unwound.\n\n| Failure Point | Resources to Clean Up | Cleanup Actions |\n|--------------|----------------------|-----------------|\n| Namespace creation | Container state | Delete state record |\n| Filesystem preparation | Namespaces, state | Cleanup namespaces, delete state |\n| Cgroup setup | Filesystem, namespaces, state | Unmount overlay, cleanup namespaces, delete state |\n| Network configuration | Cgroups, filesystem, namespaces, state | Remove cgroup, unmount overlay, cleanup namespaces, delete state |\n| Process launch | Network, cgroups, filesystem, namespaces, state | Full cleanup of all resources |\n\n> **Critical Design Decision**: The creation sequence is designed to be atomic from the user's perspective - either a container is fully created and functional, or it doesn't exist at all. Partial containers are never left in the system.\n\n### Container Cleanup Sequence\n\nThe container cleanup sequence is equally critical to the creation sequence, ensuring that when containers are stopped and removed, all associated resources are properly released and the system is left in a clean state. This process must handle both graceful shutdowns and forced termination scenarios.\n\n![Container Lifecycle State Machine](./diagrams/container-lifecycle-state.svg)\n\n#### Graceful Termination Process\n\nWhen a container stop request is received, the Runtime Manager begins a graceful termination process that allows the container application to shut down cleanly while systematically releasing system resources. This process respects the container's shutdown timeout while ensuring that system resources are not leaked.\n\n**Step 1: Process Termination Signal**\n\nThe Runtime Manager sends a `SIGTERM` signal to the container's main process, allowing it to perform graceful shutdown operations such as closing database connections, saving state, and releasing application resources. The runtime waits for a configurable timeout period (typically 10 seconds) for the process to terminate voluntarily.\n\nIf the process doesn't terminate within the grace period, the Runtime Manager escalates to `SIGKILL`, which forcibly terminates the process. This two-phase termination approach balances application needs (graceful shutdown) with system reliability (guaranteed termination).\n\n**Step 2: Cgroup Process Migration and Cleanup**\n\nOnce the container process has terminated, the Resource Control Component verifies that no other processes remain in the container's cgroup hierarchy. Any remaining processes are either migrated to a cleanup cgroup or terminated, depending on the runtime configuration.\n\nThe cgroup cleanup process then removes the container's cgroup hierarchy by first disabling all controllers, moving any remaining processes out of the cgroup, and finally removing the cgroup directory. This sequence is critical because cgroups with active processes or enabled controllers cannot be removed.\n\n**Step 3: Network Resource Cleanup**\n\nThe Network Manager systematically removes all networking resources associated with the container. This involves removing iptables rules for port forwarding, releasing the allocated IP address back to the available pool, removing the veth pair (which automatically cleans up both host and container ends), and updating any bridge forwarding tables.\n\nNetwork cleanup must be thorough because leaked networking resources can cause conflicts with future containers, prevent IP address reuse, and leave iptables rules that interfere with other container networking.\n\n**Step 4: Filesystem Unmounting and Cleanup**\n\nThe Filesystem Manager unmounts the container's overlayfs and removes the associated directories. This process involves unmounting the overlay from the container's root mount point, removing the upper directory (containing container changes), removing the work directory, and cleaning up any temporary mount points.\n\nSpecial care is taken during unmount operations to handle busy filesystems - if processes are still accessing the container filesystem, the unmount is retried with increasingly aggressive approaches, culminating in lazy unmount (`MNT_DETACH`) if necessary.\n\n**Step 5: Namespace Cleanup**\n\nThe Namespace Handler performs the final cleanup step by removing the container's namespaces. Since namespaces are automatically cleaned up by the kernel when the last process exits, this step primarily involves verifying that cleanup has occurred and releasing any runtime-held references to namespace file descriptors.\n\nUser namespace cleanup requires special attention to UID/GID mapping cleanup, ensuring that any temporary mapping files are removed and that the namespace's privilege boundaries are properly dissolved.\n\n#### State Management During Cleanup\n\nThroughout the cleanup sequence, the Runtime Manager updates the container's state record to reflect the cleanup progress. The container transitions from `ContainerRunning` to `ContainerStopped` once the process has terminated, and finally to `ContainerRemoved` once all resources have been cleaned up.\n\nThe state record serves as a checkpoint for recovery operations - if the runtime crashes during cleanup, it can resume the cleanup process from the last recorded state, preventing resource leaks and ensuring system consistency.\n\n| Cleanup Phase | Container State | Critical Actions | Failure Recovery |\n|--------------|----------------|------------------|------------------|\n| Process termination | `ContainerStopped` | Send SIGTERM/SIGKILL | Force kill on restart |\n| Cgroup cleanup | `ContainerStopped` | Remove cgroup hierarchy | Retry cgroup removal |\n| Network cleanup | `ContainerStopped` | Remove veth, iptables rules | Clean up by container ID scan |\n| Filesystem cleanup | `ContainerStopped` | Unmount overlayfs | Force unmount on restart |\n| Final cleanup | `ContainerRemoved` | Delete state record | Mark as removed |\n\n#### Forced Removal and Recovery\n\nIn some scenarios, containers may need to be forcibly removed due to unresponsive processes, corrupted state, or system recovery after crashes. The forced removal process bypasses graceful shutdown and aggressively cleans up resources.\n\nForced removal begins with `SIGKILL` to terminate all processes in the container's cgroup, proceeds with immediate resource cleanup without waiting for graceful termination, uses forced unmount operations for stuck filesystems, and removes networking resources even if some operations fail.\n\nThe recovery process after runtime crashes involves scanning the system for orphaned resources by examining cgroup hierarchies for container-specific paths, checking for overlay mounts with container-specific names, identifying veth interfaces and iptables rules with container tags, and cleaning up any discovered orphaned resources.\n\n> **Operational Insight**: Container cleanup is where many runtime bugs manifest. Thorough cleanup prevents resource exhaustion and ensures system stability under high container churn rates.\n\n#### Cleanup Verification and Monitoring\n\nAfter each cleanup operation, the Runtime Manager performs verification steps to ensure resources have been properly released. This includes verifying that the container's cgroup no longer exists in the filesystem, confirming that no overlay mounts remain for the container, checking that the container's IP address has been released, and ensuring that no iptables rules reference the container.\n\nThe verification process also updates system monitoring metrics, tracking successful cleanup operations, failed cleanup attempts requiring manual intervention, resource cleanup timing for performance optimization, and overall system resource utilization trends.\n\n### Component Communication Patterns\n\nThe interactions between components follow well-defined communication patterns that ensure consistency and enable proper error handling. These patterns establish clear boundaries and responsibilities while enabling the complex coordination required for container lifecycle management.\n\n#### Synchronous Command-Response Pattern\n\nThe primary communication pattern used during container creation and removal is synchronous command-response, where the Runtime Manager issues commands to individual components and waits for completion before proceeding to the next step. This pattern ensures that each step completes successfully before dependent operations begin.\n\nEach component operation returns both a success/failure indication and detailed information about the operation results. Success responses include resource handles, configuration details, and any information needed by subsequent steps. Failure responses include specific error codes, diagnostic information, and suggestions for recovery actions.\n\n| Component | Command Type | Response Data | Error Information |\n|-----------|-------------|---------------|------------------|\n| Namespace Handler | `CreateNamespaces` | `NamespaceHandle` with PIDs and paths | Namespace creation failures with system error codes |\n| Resource Controller | `CreateContainerCgroup` | Cgroup path and applied limits | Controller availability and permission errors |\n| Filesystem Manager | `PrepareContainerFilesystem` | Mount point and overlay paths | Mount failures and layer availability issues |\n| Network Manager | `SetupContainerNetwork` | `ContainerNetwork` with interface details | IP allocation and bridge configuration errors |\n\n#### Event Notification Pattern\n\nFor monitoring and status updates, components use an event notification pattern to inform the Runtime Manager about state changes, resource usage alerts, and error conditions that occur outside of explicit command operations.\n\nThe event notification system operates asynchronously, allowing components to report important events without blocking their normal operations. Events include container process exit notifications, resource usage threshold breaches, network connectivity changes, and filesystem errors.\n\n#### Resource Handle Management\n\nComponents return resource handles that encapsulate the resources they've created and provide controlled access for cleanup operations. These handles abstract the complexity of resource management while ensuring that resources can be properly released even if the component that created them is not available.\n\nResource handles include sufficient information for cleanup operations, maintain references to prevent premature resource release, provide verification methods for health checking, and enable diagnostic operations for troubleshooting.\n\n### Error Propagation and Recovery\n\nThe container runtime implements comprehensive error propagation and recovery mechanisms that ensure system stability even when individual operations fail. These mechanisms distinguish between recoverable errors (that can be retried) and permanent failures (that require different handling strategies).\n\n#### Error Classification and Handling\n\nErrors are classified into categories that determine the appropriate response strategy:\n\n**Transient Errors** are temporary conditions that may resolve with retry, such as resource temporarily unavailable, network connectivity issues, and filesystem busy conditions. These errors trigger automatic retry with exponential backoff.\n\n**Configuration Errors** indicate problems with the container specification or runtime configuration, such as invalid resource limits, missing image layers, and network configuration conflicts. These errors are reported immediately to the user without retry.\n\n**System Errors** indicate serious problems with the underlying system, such as insufficient disk space, kernel feature unavailability, and permission denied errors. These errors may require administrative intervention.\n\n**Resource Exhaustion** occurs when system limits are reached, such as no available IP addresses, maximum containers reached, and insufficient memory for operations. These errors trigger cleanup of unused resources before retry.\n\n> **Design Philosophy**: Fail fast for configuration errors, retry intelligently for transient errors, and gracefully degrade for resource exhaustion scenarios.\n\n#### Recovery State Machine\n\nThe runtime maintains a recovery state machine that tracks the progress of failed operations and determines the appropriate recovery actions:\n\n![Error Recovery and Cleanup Flow](./diagrams/error-recovery-flow.svg)\n\nThe recovery process uses checkpointing to track which operations have completed successfully, enabling precise rollback without affecting unrelated system state. Recovery actions are idempotent, ensuring that repeated execution produces the same result without side effects.\n\n### Performance Considerations and Optimization\n\nThe container lifecycle operations are optimized for both individual container performance and system-wide scalability. These optimizations balance resource utilization, operation latency, and system throughput under various load patterns.\n\n#### Parallel Component Operations\n\nWhere dependencies permit, component operations are executed in parallel to reduce container creation latency. For example, cgroup creation and network setup can proceed simultaneously after namespace creation, and filesystem layer verification can occur in parallel with network bridge preparation.\n\nThe parallel execution framework uses worker pools for each component type, coordinates dependencies through a directed acyclic graph, implements backpressure to prevent resource exhaustion, and maintains operation ordering where required for correctness.\n\n#### Resource Pooling and Caching\n\nFrequently used resources are pooled and cached to reduce allocation overhead:\n\n**Network Resource Pool**: Pre-allocated IP addresses and veth interface names reduce network setup latency and prevent naming conflicts.\n\n**Filesystem Layer Cache**: Image layers are cached with reference counting, enabling quick overlay setup for containers using the same base images.\n\n**Cgroup Template Cache**: Common cgroup configurations are templated and cached, reducing the overhead of setting individual resource limits.\n\n#### Batch Operations\n\nWhen multiple containers are created simultaneously, the runtime batches certain operations to improve efficiency:\n\n- iptables rules are batched and applied together to reduce netfilter reconfiguration overhead\n- Filesystem operations are batched to take advantage of kernel I/O scheduling\n- Cgroup operations are grouped to minimize cgroup hierarchy traversal\n\n### Implementation Guidance\n\nThe container lifecycle orchestration requires careful coordination of asynchronous operations while maintaining strong consistency guarantees. The following implementation approach provides a foundation for building reliable container lifecycle management.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| State Management | JSON files + file locking | Embedded database (bbolt/badger) |\n| Process Management | os/exec + signal handling | Dedicated process manager with reaping |\n| Error Handling | Structured errors + retry logic | Circuit breaker pattern with backoff |\n| Logging | Standard log package | Structured logging (logrus/zap) |\n| Monitoring | Basic metrics collection | Prometheus metrics + health checks |\n\n#### Recommended File Structure\n\n```\ninternal/runtime/\n  manager.go                    ← Runtime Manager implementation\n  manager_test.go              ← Lifecycle integration tests\n  lifecycle.go                 ← Container lifecycle state machine\n  cleanup.go                   ← Resource cleanup coordination\n  validation.go                ← Container specification validation\n  errors.go                    ← Error types and handling\n  state/\n    manager.go                 ← Container state persistence\n    recovery.go                ← Crash recovery logic\n  coordinator/\n    coordinator.go             ← Component operation coordination\n    parallel.go                ← Parallel operation execution\n    rollback.go               ← Failure rollback logic\n```\n\n#### Core State Management Infrastructure\n\n```go\n// StateManager provides persistent storage for container state with crash recovery\ntype StateManager struct {\n    stateDir   string\n    containers map[string]*ContainerState\n    mu         sync.RWMutex\n    \n    // Recovery tracking\n    operations map[string]*OperationLog\n    recovery   *RecoveryManager\n}\n\n// OperationLog tracks the progress of multi-step operations for recovery\ntype OperationLog struct {\n    ContainerID    string                 `json:\"container_id\"`\n    OperationType  string                 `json:\"operation_type\"` // \"create\", \"start\", \"stop\", \"remove\"\n    StartTime      time.Time              `json:\"start_time\"`\n    CompletedSteps []string               `json:\"completed_steps\"`\n    CurrentStep    string                 `json:\"current_step\"`\n    RollbackNeeded bool                   `json:\"rollback_needed\"`\n    ErrorDetails   map[string]interface{} `json:\"error_details,omitempty\"`\n}\n\n// SaveContainerState persists container state with atomic write operations\nfunc (sm *StateManager) SaveContainerState(state *ContainerState) error {\n    // TODO 1: Validate container state structure and required fields\n    // TODO 2: Create temporary file for atomic write operation\n    // TODO 3: Serialize state to JSON with proper formatting\n    // TODO 4: Write to temporary file and fsync for durability\n    // TODO 5: Atomically rename temporary file to final location\n    // TODO 6: Update in-memory cache with new state\n    // Hint: Use os.Rename() for atomic file replacement\n}\n\n// LoadContainerState retrieves persisted state with error handling\nfunc (sm *StateManager) LoadContainerState(containerID string) (*ContainerState, error) {\n    // TODO 1: Validate container ID format and length\n    // TODO 2: Construct state file path from container ID\n    // TODO 3: Read state file with appropriate error handling\n    // TODO 4: Parse JSON and validate required fields\n    // TODO 5: Update in-memory cache with loaded state\n    // TODO 6: Check for recovery operations in progress\n    // Hint: Handle file not found vs. corruption differently\n}\n```\n\n#### Runtime Manager Core Logic\n\n```go\n// RuntimeManager orchestrates all container lifecycle operations\ntype RuntimeManager struct {\n    stateManager    *StateManager\n    nsHandler       *namespace.Handler\n    cgroupController *cgroup.Controller\n    fsManager       *filesystem.Manager\n    networkManager  *network.Manager\n    \n    config          *RuntimeConfig\n    eventChan       chan *RuntimeEvent\n    shutdownCtx     context.Context\n    shutdownCancel  context.CancelFunc\n}\n\n// CreateContainer implements the complete container creation sequence\nfunc (rm *RuntimeManager) CreateContainer(spec *ContainerSpec) error {\n    // TODO 1: Validate container specification thoroughly\n    // TODO 2: Check for container ID conflicts in state store\n    // TODO 3: Initialize container state record with Created status\n    // TODO 4: Log operation start for crash recovery\n    // TODO 5: Create namespaces according to namespace configuration\n    // TODO 6: Prepare filesystem with overlay mount and layer setup\n    // TODO 7: Create and configure cgroup with resource limits\n    // TODO 8: Setup container networking with IP allocation\n    // TODO 9: Update container state to Running status\n    // TODO 10: Launch container process in prepared environment\n    // TODO 11: Clean up resources if any step fails (rollback)\n    // Hint: Use defer functions for cleanup on error paths\n}\n\n// StopContainer implements graceful container termination\nfunc (rm *RuntimeManager) StopContainer(containerID string, timeout time.Duration) error {\n    // TODO 1: Load container state and verify it's running\n    // TODO 2: Send SIGTERM to container process for graceful shutdown\n    // TODO 3: Wait for process termination within timeout period\n    // TODO 4: Send SIGKILL if process doesn't terminate gracefully\n    // TODO 5: Update container state to Stopped status\n    // TODO 6: Begin cleanup sequence for all component resources\n    // TODO 7: Verify all resources have been properly released\n    // TODO 8: Update monitoring metrics for container lifecycle\n    // Hint: Use context with timeout for process termination wait\n}\n```\n\n#### Component Coordination Framework\n\n```go\n// ComponentCoordinator manages parallel and sequential operations across components\ntype ComponentCoordinator struct {\n    components map[string]Component\n    \n    // Dependency graph for operation ordering\n    dependencies map[string][]string\n    \n    // Operation tracking for rollback\n    completedOps map[string][]string\n    mu           sync.Mutex\n}\n\n// Component interface that all runtime components must implement\ntype Component interface {\n    // Setup prepares component resources for a container\n    Setup(containerID string, spec *ContainerSpec) (*ComponentResult, error)\n    \n    // Cleanup releases component resources for a container\n    Cleanup(containerID string) error\n    \n    // Verify checks that component resources are properly configured\n    Verify(containerID string) error\n    \n    // GetDependencies returns components that must complete before this one\n    GetDependencies() []string\n}\n\n// ExecuteParallelOperations coordinates component operations with dependency handling\nfunc (cc *ComponentCoordinator) ExecuteParallelOperations(containerID string, spec *ContainerSpec) error {\n    // TODO 1: Build dependency graph from component requirements\n    // TODO 2: Identify operations that can execute in parallel\n    // TODO 3: Create worker goroutines for independent operations\n    // TODO 4: Use channels to coordinate dependency completion\n    // TODO 5: Collect results and handle any operation failures\n    // TODO 6: Implement rollback for failed parallel operations\n    // TODO 7: Update operation log with completion status\n    // Hint: Use sync.WaitGroup for parallel operation coordination\n}\n```\n\n#### Error Handling and Recovery\n\n```go\n// RecoveryManager handles crash recovery and partial operation cleanup\ntype RecoveryManager struct {\n    stateManager   *StateManager\n    operationLogs  map[string]*OperationLog\n    components     map[string]Component\n    \n    // Recovery policies\n    maxRetryAttempts int\n    retryBackoff     time.Duration\n    cleanupTimeout   time.Duration\n}\n\n// RecoverFromCrash identifies and completes interrupted operations\nfunc (rm *RecoveryManager) RecoverFromCrash() error {\n    // TODO 1: Scan operation log directory for incomplete operations\n    // TODO 2: Load operation logs and determine recovery actions needed\n    // TODO 3: Identify containers requiring rollback vs. completion\n    // TODO 4: Execute cleanup operations for failed container creations\n    // TODO 5: Restart monitoring for containers in running state\n    // TODO 6: Update container states to reflect actual system state\n    // TODO 7: Clean up orphaned system resources (cgroups, mounts, etc.)\n    // Hint: Use system inspection to verify actual resource state\n}\n\n// RollbackOperation cleans up resources from a failed container operation\nfunc (rm *RecoveryManager) RollbackOperation(opLog *OperationLog) error {\n    // TODO 1: Determine which components completed successfully\n    // TODO 2: Execute cleanup in reverse order of creation\n    // TODO 3: Handle cleanup failures with appropriate retry logic\n    // TODO 4: Update container state to reflect rollback completion\n    // TODO 5: Remove operation log once rollback completes\n    // TODO 6: Log rollback results for debugging and monitoring\n    // Hint: Components should implement idempotent cleanup operations\n}\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the container lifecycle coordination:\n\n1. **Creation Verification**: Run `go test ./internal/runtime/...` to verify creation sequence logic\n2. **Manual Testing**: Create a container with `runtime create test-container config.json` and verify all namespaces, cgroups, and networking are properly configured\n3. **Cleanup Verification**: Stop and remove the container, then inspect system state to ensure no leaked resources\n4. **Recovery Testing**: Simulate runtime crash during container creation and verify recovery on restart\n5. **Expected Behavior**: Containers should transition smoothly through Created → Running → Stopped → Removed states with proper resource management at each stage\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Container creation hangs | Component deadlock or dependency cycle | Check component dependency graph and operation logs | Implement operation timeouts and break dependency cycles |\n| Partial container cleanup | Component cleanup failure | Examine container state and system resources | Implement idempotent cleanup and retry logic |\n| Resource leaks after crashes | Missing recovery operations | Scan system for orphaned cgroups, mounts, network interfaces | Add comprehensive recovery scanning and cleanup |\n| State corruption | Concurrent state modifications | Check for missing locks and atomic operations | Use file locking and atomic state updates |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (1-4) - Error handling spans namespace creation (milestone 1), cgroup setup (milestone 2), filesystem mounting (milestone 3), and network configuration (milestone 4), requiring comprehensive failure recovery across all components.\n\nBuilding a container runtime involves orchestrating multiple complex Linux kernel mechanisms, each with its own failure modes and edge cases. Think of error handling in a container runtime like managing a construction project with specialized contractors - when the electrician fails after the plumber has finished, you need a systematic plan to undo completed work while preserving what can be salvaged. Unlike simple applications where failures often mean \"try again later,\" container runtime failures leave behind kernel resources (namespaces, cgroups, mount points, network interfaces) that must be meticulously cleaned up to avoid resource leaks and system instability.\n\nThe fundamental challenge in container runtime error handling is **partial failure recovery**. Container creation involves a precise sequence of operations across multiple kernel subsystems: creating namespaces, establishing cgroup hierarchies, mounting overlay filesystems, and configuring network interfaces. When operation 7 fails but operations 1-6 succeeded, the runtime must intelligently roll back the successful operations in the correct order while avoiding double-cleanup and resource conflicts.\n\n![Container Lifecycle State Machine](./diagrams/container-lifecycle-state.svg)\n\nResource exhaustion scenarios present another class of critical edge cases. Unlike traditional applications that can gracefully degrade or queue requests, container runtimes must handle hard resource limits imposed by the kernel. When the system runs out of available PIDs, network interfaces, or memory, the runtime must detect these conditions early and provide meaningful feedback rather than cryptic kernel error messages.\n\n### Partial Failure Recovery\n\nPartial failure recovery in container runtimes requires maintaining detailed operation logs and implementing idempotent cleanup procedures. Think of this like a database transaction - either all operations complete successfully, or the system returns to its original state with no side effects. However, unlike database transactions, kernel resource operations cannot be wrapped in a single atomic unit, requiring careful orchestration of cleanup procedures.\n\n> **Decision: Operation Log with Rollback Mechanism**\n> - **Context**: Container creation involves 10-15 distinct operations across multiple kernel subsystems, any of which can fail independently\n> - **Options Considered**: \n>   1. Best-effort cleanup without tracking\n>   2. Two-phase commit protocol for all operations\n>   3. Operation log with explicit rollback procedures\n> - **Decision**: Operation log with explicit rollback procedures\n> - **Rationale**: Two-phase commit is too heavy for kernel operations that cannot participate in distributed transactions. Best-effort cleanup leads to resource leaks. Operation logs provide precise tracking with efficient rollback.\n> - **Consequences**: Requires persistent storage for operation logs and careful ordering of cleanup procedures, but ensures no resource leaks and consistent system state.\n\nThe `OperationLog` structure tracks the progress of multi-step container operations and provides the foundation for intelligent rollback:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ContainerID | string | Unique identifier linking log to container being created |\n| OperationType | string | Type of operation (CREATE, START, STOP, REMOVE) |\n| StartTime | time.Time | When the operation began for timeout detection |\n| CompletedSteps | []string | List of successfully completed operation steps |\n| CurrentStep | string | Step currently being executed or that failed |\n| RollbackNeeded | bool | Whether rollback procedures should be executed |\n| ErrorDetails | map[string]interface{} | Structured error information for diagnosis |\n\nThe rollback mechanism operates through **step-specific cleanup procedures** that can be safely executed multiple times (idempotent) and handle cases where the original operation partially succeeded. Each component provides cleanup methods that inspect the current system state and remove only resources that actually exist:\n\n1. **Check Operation Log**: The recovery manager scans persistent operation logs to identify incomplete operations from previous runtime executions\n2. **Determine Rollback Scope**: For each incomplete operation, examine the `CompletedSteps` list to identify which resources were successfully created\n3. **Execute Reverse Cleanup**: Call component-specific cleanup methods in reverse dependency order (network → filesystem → cgroup → namespaces)\n4. **Verify Resource Removal**: After each cleanup step, verify that kernel resources were actually removed and update the operation log\n5. **Handle Cleanup Failures**: If cleanup fails, mark specific resources as requiring manual intervention and continue with remaining cleanup\n6. **Log Completion**: Mark the operation log as fully rolled back or note any resources requiring administrator attention\n\nHere's the detailed rollback sequence for each component:\n\n| Component | Cleanup Actions | Verification Steps | Failure Handling |\n|-----------|----------------|-------------------|------------------|\n| Network Manager | Remove iptables rules, delete veth interfaces, release IP addresses | Check interface list, verify iptables rules removed | Log unreleased IPs for manual cleanup |\n| Filesystem Manager | Unmount overlayfs, remove overlay directories, update layer references | Check mount table, verify directories removed | Force unmount with lazy flags if needed |\n| Cgroup Controller | Remove processes from cgroups, delete cgroup directories | Check cgroup.procs file empty, verify directory removal | Kill remaining processes if needed |\n| Namespace Handler | Close namespace file descriptors, clean up pivot_root artifacts | Check /proc/PID/ns/ entries, verify mount points | Mark namespaces for kernel cleanup on process exit |\n\n⚠️ **Pitfall: Cleanup Order Dependencies**\n\nA common mistake is cleaning up components in creation order rather than reverse dependency order. For example, attempting to remove a cgroup before stopping the network manager can fail because iptables rules might still reference the container's cgroup. The correct cleanup sequence respects dependency relationships: network configuration depends on namespaces existing, cgroups depend on processes being manageable, and filesystem mounts must be unmounted before namespace cleanup.\n\nThe `RecoveryManager` implements crash recovery by scanning operation logs on startup and completing interrupted operations:\n\n| Recovery Scenario | Detection Method | Recovery Action | Outcome |\n|------------------|------------------|-----------------|----------|\n| Runtime crashed during container creation | Operation log shows incomplete CREATE with recent timestamp | Execute rollback for all completed steps | Container fully removed, resources cleaned |\n| Container process died unexpectedly | PID in container state no longer exists | Mark container as stopped, clean up kernel resources | Container marked STOPPED, resources cleaned |\n| Manual container kill bypassed runtime | Container state shows RUNNING but process not found | Update state to STOPPED, leave resources for explicit cleanup | Consistent state, manual removal required |\n| Kernel resource leaked from previous session | System resources exist but not in runtime state | Log leaked resources, optionally clean up obvious orphans | Clean system state, administrator notified |\n\n> The key insight for partial failure recovery is that kernel resources have different cleanup requirements than application resources. A failed malloc() simply returns memory to the heap, but a failed namespace creation might leave mount points, cgroup entries, and network interfaces that must be explicitly cleaned up through separate system calls.\n\n### Resource Exhaustion Scenarios\n\nResource exhaustion scenarios in container runtimes require proactive detection and graceful degradation rather than reactive error handling. Think of resource exhaustion like a city's infrastructure during peak demand - water pressure drops before pipes burst, and smart systems detect the decline and take preventive action rather than waiting for catastrophic failure.\n\nThe container runtime must monitor multiple types of resource exhaustion:\n\n| Resource Type | Exhaustion Symptoms | Detection Method | Recovery Strategy |\n|---------------|-------------------|------------------|-------------------|\n| Process IDs | fork() returns EAGAIN, new containers fail to start | Check /proc/sys/kernel/pid_max and active PID count | Queue container requests, increase PID limit if possible |\n| Memory | OOM killer activates, container creation fails | Monitor memory.current vs memory.max in cgroups | Reject new containers, suggest memory limit increases |\n| Network Interfaces | veth creation fails, bridge attachment fails | Count interfaces in /sys/class/net/ | Clean up unused interfaces, implement interface pooling |\n| File Descriptors | open() returns EMFILE/ENFILE | Check /proc/PID/limits and /proc/sys/fs/file-nr | Close unused FDs, increase process limits |\n| Disk Space | Filesystem operations fail with ENOSPC | Monitor filesystem usage for container storage | Clean up stopped containers, rotate logs |\n| Cgroup Hierarchy Depth | cgroup creation fails with nested limits | Check cgroup depth in /sys/fs/cgroup hierarchy | Flatten cgroup structure, remove unused cgroups |\n\n**PID Exhaustion Detection and Mitigation**:\n\nPID exhaustion is particularly problematic for container runtimes because each container typically creates multiple processes (init process, potential child processes, namespace management processes). The runtime implements PID exhaustion protection through monitoring and admission control:\n\n1. **Current PID Usage Monitoring**: Periodically scan /proc to count active PIDs and calculate utilization against the system limit (/proc/sys/kernel/pid_max)\n2. **Per-Container PID Tracking**: Maintain accurate counts of PIDs allocated to each container through cgroup process accounting\n3. **Admission Control**: Reject new container creation requests when PID utilization exceeds a configured threshold (e.g., 85%)\n4. **PID Cleanup Detection**: Identify containers with higher PID usage than expected and investigate potential PID leaks\n5. **Emergency PID Recovery**: When PID exhaustion is imminent, forcefully terminate containers marked as non-critical to free PIDs for essential operations\n\n**Memory Pressure Handling**:\n\nMemory exhaustion affects both the container runtime itself and the containers it manages. The runtime implements multi-level memory pressure detection:\n\n| Pressure Level | Detection Threshold | Runtime Action | Container Action |\n|----------------|-------------------|----------------|-------------------|\n| Normal | Memory usage < 70% of system | Normal operation | No restrictions |\n| Warning | Memory usage 70-85% of system | Log warnings, reduce caching | Monitor container memory trends |\n| Critical | Memory usage 85-95% of system | Reject new containers | Apply stricter memory limits to new containers |\n| Emergency | Memory usage > 95% or swap thrashing | Stop non-essential containers | Trigger graceful shutdown of containers marked non-critical |\n\nThe runtime tracks memory pressure through multiple indicators:\n\n1. **System Memory Utilization**: Monitor /proc/meminfo for available memory vs total memory\n2. **Container Memory Pressure**: Check memory.pressure files in container cgroups to detect containers approaching their limits\n3. **Swap Activity**: Monitor swap usage trends to detect memory thrashing before system becomes unresponsive\n4. **OOM Event Detection**: Scan kernel logs and cgroup memory.events for OOM kill events affecting containers\n5. **Memory Allocation Failure Rate**: Track the rate of memory allocation failures in container creation operations\n\n⚠️ **Pitfall: Resource Exhaustion Cascades**\n\nA subtle failure mode occurs when resource exhaustion in one area triggers exhaustion in another. For example, when the runtime cannot create new network interfaces due to kernel limits, it might retry the operation multiple times, consuming PIDs for helper processes and eventually hitting PID limits as well. The runtime must implement circuit breaker patterns that prevent retry loops from amplifying resource exhaustion across multiple subsystems.\n\n**Network Resource Exhaustion**:\n\nNetwork interface exhaustion is less common but can occur in environments running many containers with complex networking requirements. The runtime implements network resource management through:\n\n| Network Resource | Limit Type | Detection Method | Mitigation Strategy |\n|-----------------|------------|------------------|-------------------|\n| veth Interfaces | Kernel compile-time limit | Count interfaces in /sys/class/net/ | Implement interface reuse pool |\n| IP Addresses | Configured subnet size | Track allocated IPs in IPAM | Expand subnet or implement IP recycling |\n| iptables Rules | Memory and rule count limits | Monitor iptables rule count | Consolidate rules, implement rule cleanup |\n| Bridge Interfaces | Administrative limit | Count bridge interfaces | Reuse bridges across containers |\n| netns File Descriptors | Process file descriptor limit | Track open namespace file descriptors | Close unused namespace references |\n\nThe `ResourceMonitor` component implements comprehensive resource exhaustion detection:\n\n| Monitoring Function | Check Interval | Alert Threshold | Action Threshold |\n|-------------------|----------------|----------------|------------------|\n| System PID usage | 30 seconds | 70% utilization | 85% utilization |\n| Memory pressure | 15 seconds | Moderate pressure | High pressure |\n| Filesystem space | 60 seconds | 80% full | 90% full |\n| Network interface count | 120 seconds | 80% of observed maximum | 95% of observed maximum |\n| Cgroup hierarchy depth | 300 seconds | Depth > 10 levels | Depth > 15 levels |\n\n**Resource Exhaustion Recovery Procedures**:\n\nWhen resource exhaustion is detected, the runtime follows escalating recovery procedures:\n\n1. **Level 1 - Preventive Measures**: Increase monitoring frequency, log detailed resource usage, reject non-critical operations\n2. **Level 2 - Resource Reclamation**: Clean up stopped containers, release unused resources, compact resource allocations\n3. **Level 3 - Load Shedding**: Reject new container creation requests, terminate containers marked as non-essential\n4. **Level 4 - Emergency Cleanup**: Force cleanup of resources that appear leaked, restart runtime components to reset resource tracking\n5. **Level 5 - System Protection**: Invoke emergency shutdown procedures to prevent system-wide resource exhaustion\n\n> The critical principle in resource exhaustion handling is failing fast and failing clearly. When the runtime detects that it cannot reliably create new containers due to resource constraints, it should immediately return a clear error message rather than attempting the operation and leaving behind partially created resources that worsen the exhaustion.\n\n### Implementation Guidance\n\nThe error handling and recovery system requires careful coordination of persistent state management and idempotent cleanup procedures. This implementation focuses on building robust error handling that prevents resource leaks and provides clear diagnostic information.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Operation Logging | JSON files with file locking | SQLite database with transactions |\n| Resource Monitoring | Periodic polling with goroutines | Event-driven monitoring with inotify |\n| Process Coordination | Channel-based synchronization | Context-based cancellation with sync.WaitGroup |\n| Error Classification | Custom error types with wrapping | Structured errors with error codes and metadata |\n\n#### Recommended File Structure\n\n```\ninternal/\n  runtime/\n    manager.go              ← RuntimeManager with error handling\n    recovery.go             ← RecoveryManager implementation\n    operation_log.go        ← OperationLog persistence\n  monitoring/\n    resource_monitor.go     ← ResourceMonitor implementation\n    alerts.go              ← Resource exhaustion alerting\n  errors/\n    types.go               ← Error type definitions\n    recovery.go            ← Error recovery utilities\n  components/\n    namespace/\n      cleanup.go           ← Namespace cleanup procedures\n    cgroup/\n      cleanup.go           ← Cgroup cleanup procedures\n    filesystem/\n      cleanup.go           ← Filesystem cleanup procedures\n    network/\n      cleanup.go           ← Network cleanup procedures\n```\n\n#### Core Error Handling Infrastructure\n\n```go\n// OperationLog tracks multi-step operations for failure recovery\ntype OperationLog struct {\n    ContainerID    string                 `json:\"container_id\"`\n    OperationType  string                 `json:\"operation_type\"`\n    StartTime      time.Time              `json:\"start_time\"`\n    CompletedSteps []string               `json:\"completed_steps\"`\n    CurrentStep    string                 `json:\"current_step\"`\n    RollbackNeeded bool                   `json:\"rollback_needed\"`\n    ErrorDetails   map[string]interface{} `json:\"error_details\"`\n}\n\n// RecoveryManager handles crash recovery and resource cleanup\ntype RecoveryManager struct {\n    logDir      string\n    components  map[string]Component\n    mu          sync.RWMutex\n}\n\n// PersistOperationStep records successful completion of an operation step\nfunc (rm *RecoveryManager) PersistOperationStep(containerID, step string) error {\n    // TODO 1: Load existing operation log from disk using container ID\n    // TODO 2: Add step to CompletedSteps list if not already present\n    // TODO 3: Update CurrentStep to reflect progress\n    // TODO 4: Write updated log back to disk with atomic file operations\n    // TODO 5: Ensure file permissions allow cleanup by other processes\n    // Hint: Use a temporary file + rename for atomic updates\n}\n\n// ExecuteRollback cleans up resources from a failed operation\nfunc (rm *RecoveryManager) ExecuteRollback(opLog *OperationLog) error {\n    // TODO 1: Reverse the order of completed steps for cleanup\n    // TODO 2: For each step, identify the responsible component\n    // TODO 3: Call component-specific cleanup method with error handling\n    // TODO 4: Update operation log to track cleanup progress\n    // TODO 5: Handle partial cleanup failures gracefully\n    // TODO 6: Mark operation log as fully cleaned up\n    // Hint: Continue cleanup even if individual steps fail\n}\n```\n\n#### Resource Monitoring Implementation\n\n```go\n// ResourceMonitor tracks system resource usage and exhaustion\ntype ResourceMonitor struct {\n    alertThresholds map[string]float64\n    checkInterval   time.Duration\n    alertHandlers   []func(ResourceAlert)\n    mu              sync.RWMutex\n}\n\n// StartMonitoring begins periodic resource usage checking\nfunc (rm *ResourceMonitor) StartMonitoring(ctx context.Context) {\n    ticker := time.NewTicker(rm.checkInterval)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case <-ticker.C:\n            // TODO 1: Check PID usage by scanning /proc filesystem\n            // TODO 2: Check memory pressure from /proc/meminfo\n            // TODO 3: Check filesystem usage for container storage\n            // TODO 4: Count network interfaces in /sys/class/net/\n            // TODO 5: Compare usage against configured thresholds\n            // TODO 6: Generate alerts for resources approaching limits\n            // Hint: Use /proc/sys/kernel/pid_max for PID limit\n        }\n    }\n}\n\n// CheckPIDExhaustion determines if system is approaching PID limit\nfunc (rm *ResourceMonitor) CheckPIDExhaustion() (float64, error) {\n    // TODO 1: Read PID limit from /proc/sys/kernel/pid_max\n    // TODO 2: Count active PIDs by scanning /proc directory\n    // TODO 3: Calculate utilization percentage\n    // TODO 4: Return usage ratio for threshold comparison\n    // Hint: Handle race conditions where PIDs change during scan\n}\n```\n\n#### Component Cleanup Interfaces\n\n```go\n// Component defines cleanup interface for runtime components\ntype Component interface {\n    // CleanupResources removes all resources associated with container\n    CleanupResources(containerID string) error\n    \n    // VerifyCleanup checks that all resources were actually removed\n    VerifyCleanup(containerID string) error\n    \n    // ListResources returns resources currently allocated to container\n    ListResources(containerID string) ([]string, error)\n}\n\n// Implement cleanup for each component following this pattern:\n\n// CleanupNamespaces removes namespace resources for container\nfunc (nh *NamespaceHandler) CleanupResources(containerID string) error {\n    // TODO 1: Load namespace handle from persistent state\n    // TODO 2: Close all namespace file descriptors\n    // TODO 3: Unmount any remaining filesystem mounts\n    // TODO 4: Remove namespace-specific directories\n    // TODO 5: Verify namespace cleanup completed successfully\n    // Hint: Use lazy unmount (MNT_DETACH) for stuck mounts\n}\n\n// CleanupCgroups removes cgroup hierarchy for container\nfunc (cc *CgroupController) CleanupResources(containerID string) error {\n    // TODO 1: Find cgroup path from container ID\n    // TODO 2: Kill any remaining processes in cgroup\n    // TODO 3: Remove container cgroup directory\n    // TODO 4: Update cgroup reference counts\n    // TODO 5: Clean up empty parent cgroups if needed\n    // Hint: Check cgroup.procs is empty before removing directory\n}\n```\n\n#### Milestone Checkpoints\n\n**After implementing operation logging:**\n- Run `go test ./internal/runtime/recovery_test.go` to verify log persistence\n- Create a container and verify operation log is written to disk\n- Kill the runtime process during container creation and verify rollback on restart\n\n**After implementing resource monitoring:**\n- Run `go test ./internal/monitoring/resource_test.go` to verify threshold detection\n- Create containers until PID usage approaches threshold\n- Verify monitoring detects resource pressure and generates appropriate alerts\n\n**After implementing component cleanup:**\n- Run integration test that creates container and injects failure at each step\n- Verify all kernel resources are cleaned up after each failure scenario\n- Check that no mount points, cgroup directories, or network interfaces leak\n\n#### Debugging Common Error Handling Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Resource busy\" during cleanup | Another process still using resource | `lsof` for files, `lsns` for namespaces | Kill processes holding resource |\n| Operation log corruption | Concurrent writes or crash during write | Check file timestamps and JSON validity | Implement file locking or atomic writes |\n| Cleanup hangs indefinitely | Deadlock in kernel resource cleanup | `strace` the cleanup process | Use timeouts and force cleanup options |\n| Resource leak after container removal | Component cleanup not called or failed | Check system resources before/after | Verify cleanup methods are idempotent |\n| False resource exhaustion alerts | Monitoring logic counting incorrectly | Compare manual resource counts | Fix counting logic and add bounds checking |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (1-4) - This section provides comprehensive testing approaches for namespace isolation (milestone 1), resource control (milestone 2), filesystem layering (milestone 3), and container networking (milestone 4), along with end-to-end integration scenarios.\n\n### Mental Model: Multi-Layer Quality Gates\n\nThink of testing a container runtime like quality control in a multi-story manufacturing plant. Each floor represents a milestone - the first floor handles basic isolation (like separate workspaces), the second floor adds resource management (like power and material limits), the third floor implements storage systems (like shared warehouses with private modifications), and the fourth floor connects communication networks (like phone systems between departments). Quality inspectors work at three levels: **unit inspectors** check each machine in isolation, **floor supervisors** verify that all machines on a floor work together properly, and **plant managers** run full production scenarios to ensure the entire facility operates as designed. Just as a defect on the first floor can cascade upward and ruin the final product, a namespace isolation bug can break resource limits, filesystem mounting, and networking. Our testing strategy mirrors this layered approach - we verify each component works correctly in isolation, then test milestone-by-milestone integration, and finally run realistic end-to-end scenarios that exercise the complete container lifecycle.\n\nThe key insight is that container runtime testing requires **progressive validation** - you cannot meaningfully test resource limits if namespace isolation is broken, and networking tests are pointless if the filesystem layer cannot mount properly. Each milestone builds upon the previous one, creating a testing dependency chain that must be validated in sequence. This approach helps developers understand not just whether their implementation works, but where failures originate and how they propagate through the system.\n\n### Milestone Checkpoints\n\nEach milestone represents a significant capability increment in our container runtime. The testing approach for each milestone focuses on verifying the specific isolation mechanisms and their integration with previously implemented components. These checkpoints provide concrete validation criteria and specific test scenarios that demonstrate proper functionality.\n\n#### Milestone 1: Process Isolation with Namespaces\n\nThe first milestone establishes the foundation of container isolation using Linux namespaces. Testing focuses on verifying that each namespace type correctly isolates the container's view of system resources from the host and other containers.\n\n**PID Namespace Validation** tests ensure that the container process sees itself as PID 1 and cannot see host processes. The test creates a container, executes a process inside it, and verifies that `/proc/1/` inside the container refers to the container's initial process rather than the host's init system. Additionally, the test should confirm that `ps aux` inside the container shows only container processes, while `ps aux` on the host shows both host and container processes with different PID mappings.\n\n**Mount Namespace Validation** verifies filesystem isolation by creating different mount points inside the container that should not appear on the host filesystem. The test mounts a temporary filesystem at `/tmp/container-test` inside the container, writes a file to that location, then confirms that the mount point and file are not visible from the host namespace. This test also validates that changes to existing mount points inside the container (such as remounting `/proc` with different options) do not affect the host's view of those filesystems.\n\n**Network Namespace Validation** confirms network stack isolation by checking that the container has its own network interfaces, routing tables, and firewall rules. The test should verify that `ip link list` inside the container shows different interfaces than on the host, that the container cannot see network connections established on the host using `netstat`, and that network configuration changes inside the container do not affect host networking.\n\n**UTS Namespace Validation** tests hostname and domain name isolation by setting different values inside the container and verifying they do not affect the host system. The test sets the container hostname to `test-container`, confirms that `hostname` inside the container returns this value, while `hostname` on the host returns the original host name.\n\n**User Namespace Validation** (when implemented) verifies UID and GID mapping by creating a container process that appears to run as root (UID 0) inside the container but actually runs as an unprivileged user on the host. The test should confirm that `id` inside the container shows UID 0, while the same process appears with a mapped UID when viewed from the host.\n\n| Test Scenario | Validation Method | Expected Behavior | Failure Indicators |\n|---------------|------------------|-------------------|-------------------|\n| PID isolation | Check `/proc/1/comm` inside container | Container process name, not host init | Shows host init process or \"No such file\" |\n| Process visibility | Run `ps aux` inside container | Only container processes visible | Host processes appear in container |\n| Mount isolation | Create mount inside container, check host | Mount not visible on host filesystem | Host shows container mounts |\n| Network interface isolation | Compare `ip link` output | Different interfaces in container vs host | Same interfaces visible in both |\n| Hostname isolation | Set hostname in container, check host | Host hostname unchanged | Container hostname affects host |\n| File ownership mapping | Create file as root in user namespace | File owned by mapped UID on host | File shows UID 0 on host filesystem |\n\nThe milestone 1 checkpoint should demonstrate that a simple container can be created and started, with the container process executing in isolated namespaces. The test creates a container that runs `sleep 60`, then uses various inspection commands to verify isolation properties while the container is running.\n\n#### Milestone 2: Resource Limits with Cgroups\n\nThe second milestone adds resource control capabilities on top of namespace isolation. Testing focuses on verifying that cgroups v2 controllers correctly enforce CPU, memory, and I/O limits, and that resource monitoring provides accurate usage statistics.\n\n**Memory Limit Enforcement** tests create containers with specific memory limits and verify that processes exceeding those limits are terminated by the OOM killer. The test starts a container with a 50MB memory limit, runs a process that attempts to allocate 100MB of memory, and confirms that the process is killed before it can consume host memory beyond the limit. Additionally, the test should verify that `GetMemoryUsage` returns accurate current consumption and that memory pressure indicators increase as the limit is approached.\n\n**CPU Limit Enforcement** validates that CPU quota and period settings correctly throttle container processes. The test creates a container with a 50% CPU limit (cpu.max set to \"50000 100000\"), runs a CPU-intensive process, and measures actual CPU consumption over a period to confirm it does not exceed the configured limit. The test should also verify that multiple containers with CPU limits can coexist without interfering with each other's quotas.\n\n**Process Limit Enforcement** tests the PIDs controller by creating a container with a maximum of 10 processes, then attempting to fork more processes and verifying that process creation fails once the limit is reached. This test ensures that containers cannot exhaust the host's PID space through excessive process creation.\n\n**Resource Usage Monitoring** validates the accuracy of resource consumption reporting. The test creates containers with known workloads (specific memory allocation patterns, CPU-intensive loops, file I/O operations) and compares the reported usage statistics from `GetResourceUsage` against expected values. This test also verifies that usage statistics are updated within reasonable time intervals.\n\n**OOM Event Detection** tests the container runtime's ability to detect and report out-of-memory kills. The test creates a container with a low memory limit, runs a process that gradually increases memory consumption until it triggers an OOM kill, then verifies that `CheckOOMEvents` correctly reports the kill event with appropriate metadata.\n\n| Test Scenario | Resource Limit | Test Workload | Expected Outcome | Validation Method |\n|---------------|----------------|---------------|------------------|-------------------|\n| Memory enforcement | 50MB | Allocate 100MB array | Process killed by OOM | Check exit code and OOM counter |\n| CPU throttling | 0.5 CPU cores | Infinite loop | ~50% CPU usage | Measure CPU time over 10 seconds |\n| PID limit | 10 processes | Fork bomb | Fork fails after 10 | Count processes in cgroup |\n| Memory monitoring | 100MB | Allocate 75MB | 75MB usage reported | Compare GetMemoryUsage() result |\n| OOM detection | 25MB | Gradual allocation | OOM event detected | CheckOOMEvents() returns true |\n\nThe milestone 2 checkpoint demonstrates that containers respect resource limits and that the runtime can accurately monitor and report resource consumption. The test creates multiple containers with different resource limits, runs various workloads simultaneously, and verifies that each container's resource usage stays within its configured bounds while resource monitoring provides accurate statistics.\n\n#### Milestone 3: Overlay Filesystem\n\nThe third milestone implements layered filesystem support using overlayfs, enabling efficient copy-on-write semantics for container images. Testing focuses on verifying proper layer stacking, copy-on-write behavior, and cleanup operations.\n\n**Layer Stacking Validation** tests that multiple read-only layers combine correctly with a writable upper layer to create the expected merged filesystem view. The test creates a container with three layers: a base layer containing `/bin/sh`, a second layer adding `/etc/hostname`, and a third layer adding `/usr/local/bin/custom-tool`. The container should see all files from all layers in their correct locations, with files from higher layers overriding those from lower layers when paths conflict.\n\n**Copy-on-Write Behavior** validates that file modifications inside the container create copies in the upper layer without affecting the original read-only layers. The test modifies an existing file from a lower layer (such as `/etc/hosts`), then verifies that the original file remains unchanged in the lower layer while the modified version appears in the upper layer. The test also creates new files and confirms they appear only in the upper layer.\n\n**Whiteout File Handling** tests overlayfs support for file deletion across layers. The test deletes a file that exists in a lower layer and verifies that a whiteout file is created in the upper layer, causing the file to disappear from the merged view while preserving the original file in the lower layer.\n\n**Layer Cleanup Verification** ensures that overlay mounts and directories are properly removed when containers are destroyed. The test creates a container, allows it to make filesystem changes, then removes the container and verifies that all overlay-related mount points are unmounted and temporary directories are cleaned up. This test also checks that shared lower layers are not removed when they are still referenced by other containers.\n\n**Overlay Mount Integrity** validates that the overlayfs mount is correctly configured and accessible. The test verifies that the merged directory shows the expected combined view of all layers, that the work directory is properly configured for overlayfs internal operations, and that mount options are correctly applied.\n\n| Test Scenario | Setup | Container Action | Verification | Expected Result |\n|---------------|--------|------------------|-------------|-----------------|\n| Layer combination | 3 layers with overlapping files | Read files from all layers | Check file contents | Higher layer files visible |\n| Copy-on-write | Base layer with `/etc/passwd` | Modify `/etc/passwd` | Check original layer | Original file unchanged |\n| File creation | Empty upper layer | Create `/tmp/newfile` | Check layer location | File only in upper layer |\n| File deletion | File in lower layer | Delete file | Check whiteout creation | File hidden, whiteout present |\n| Mount cleanup | Running container | Remove container | Check mount points | All overlay mounts removed |\n\nThe milestone 3 checkpoint demonstrates that containers can be created with layered filesystems, that copy-on-write semantics work correctly, and that filesystem resources are properly cleaned up. The test creates a container from multiple layers, performs various filesystem operations (read, write, delete), and verifies both the visible behavior and the underlying layer management.\n\n#### Milestone 4: Container Networking\n\nThe fourth milestone implements container networking using veth pairs and bridge networking. Testing focuses on verifying network isolation, container-to-container communication, and port forwarding functionality.\n\n**Veth Pair Creation** tests that virtual ethernet pairs are correctly created and configured. The test creates a container and verifies that a veth pair connects the container's network namespace to the host, with one end visible in the container (`eth0`) and the other end visible on the host (with a generated name like `vethXXXXXX`). The test should confirm that both ends of the pair are properly configured with appropriate MAC addresses and are in the UP state.\n\n**Bridge Network Integration** validates that container veth interfaces are correctly attached to the container bridge and can communicate with other containers. The test creates two containers on the same bridge network, assigns IP addresses from the configured subnet, and verifies that the containers can ping each other using their IP addresses. This test also confirms that containers cannot communicate with external networks unless explicitly configured.\n\n**IP Address Management** tests that containers receive unique IP addresses from the configured subnet pool and that address conflicts are prevented. The test creates multiple containers and verifies that each receives a different IP address, that addresses are properly allocated and released when containers start and stop, and that reused addresses are not assigned to active containers.\n\n**Port Forwarding Configuration** validates that NAT rules correctly forward traffic from host ports to container ports. The test creates a container running a simple HTTP server on port 8080, configures port forwarding from host port 9000 to container port 8080, then verifies that HTTP requests to `localhost:9000` on the host are successfully forwarded to the container service.\n\n**Network Isolation Verification** tests that containers in different network namespaces cannot directly access each other's network resources unless explicitly connected. The test creates containers in separate network namespaces and confirms that they cannot see each other's network interfaces or established connections.\n\n**DNS Resolution** validates that containers can resolve DNS names using configured nameservers. The test creates a container with DNS servers configured, attempts to resolve a known hostname from inside the container, and verifies that DNS queries are properly forwarded and resolved.\n\n| Test Scenario | Network Setup | Test Action | Expected Outcome | Validation Method |\n|---------------|---------------|-------------|------------------|-------------------|\n| Veth pair creation | Single container | Check interfaces | Veth pair exists and configured | `ip link` in both namespaces |\n| Bridge communication | Two containers on bridge | Ping between containers | Successful ping | `ping` command returns 0 |\n| IP allocation | Multiple containers | Start/stop containers | Unique IPs assigned | Check IP uniqueness |\n| Port forwarding | Container with HTTP server | HTTP request to host port | Request reaches container | HTTP response received |\n| Network isolation | Containers in separate namespaces | Attempt inter-container access | Access blocked | Connection timeout/refused |\n| DNS resolution | Container with nameservers | Resolve external hostname | DNS query succeeds | `nslookup` returns IP |\n\nThe milestone 4 checkpoint demonstrates complete container networking functionality by creating multiple containers that can communicate with each other and with external services through port forwarding. The test creates a multi-container application (such as a web server and database) connected through bridge networking, with the web server accessible from the host via port forwarding.\n\n### Integration Test Scenarios\n\nIntegration testing validates that all milestone components work together correctly in realistic container use cases. These scenarios exercise the complete container lifecycle and test complex interactions between namespace isolation, resource control, filesystem layering, and networking components.\n\n#### Scenario 1: Multi-Container Web Application\n\nThis scenario tests a realistic web application deployment with multiple containers that must coordinate through networking while maintaining proper isolation and resource limits.\n\n**Application Architecture**: The test deploys a three-tier web application consisting of a web server container (nginx serving static content), an application server container (running a simple HTTP API), and a database container (running a lightweight database like SQLite with HTTP interface). Each container has different resource requirements and network connectivity needs.\n\n**Container Configuration**: The web server container receives 100MB memory limit and 0.5 CPU cores, with port 80 forwarded to host port 8080. The application server gets 200MB memory and 1.0 CPU core, with port 3000 accessible only from other containers on the bridge network. The database container receives 300MB memory and 0.3 CPU cores, with port 5432 accessible only from the application server.\n\n**Test Execution Flow**: The test creates all three containers with their respective configurations, starts them in dependency order (database first, then application server, then web server), and verifies that the complete application stack functions correctly. External HTTP requests to the host's port 8080 should flow through the web server to the application server, which queries the database and returns results.\n\n**Validation Points**: The test validates that each container operates within its resource limits throughout the test duration, that network communication works correctly between containers while external access is properly restricted, that filesystem changes in each container remain isolated, and that all containers can be stopped and cleaned up without leaving orphaned resources.\n\n**Failure Scenario Testing**: The test intentionally introduces failures such as killing the database container and verifying that the application server handles the connection failure gracefully, exceeding memory limits in one container and confirming that other containers continue operating normally, and network partitioning between containers to test error handling.\n\n| Test Phase | Actions | Expected Behavior | Validation Method |\n|------------|---------|-------------------|-------------------|\n| Container startup | Start containers in dependency order | All containers reach running state | Check container status |\n| Application connectivity | HTTP request to web server | Request processed through full stack | HTTP response with database data |\n| Resource isolation | Load test individual containers | Each container stays within limits | Monitor cgroup statistics |\n| Network isolation | Direct database access from host | Connection refused | Network connection timeout |\n| Failure recovery | Kill database container | Application server reports database error | Check application server logs |\n| Cleanup verification | Remove all containers | All resources cleaned up | Check for orphaned mounts/processes |\n\n#### Scenario 2: Batch Processing with Resource Contention\n\nThis scenario tests container runtime behavior under resource pressure, with multiple containers competing for CPU and memory resources while processing data through shared filesystem layers.\n\n**Workload Design**: The test creates five containers that perform different types of batch processing: CPU-intensive mathematical calculations, memory-intensive data sorting, I/O-intensive file processing, network-intensive data transfer, and mixed-workload data analysis. Each container has different resource limits that intentionally create contention scenarios.\n\n**Resource Configuration**: Container limits are set to create controlled resource pressure: total CPU limits exceed available cores by 150%, total memory limits approach system memory capacity, and I/O intensive containers share the same underlying storage. This configuration tests the runtime's ability to enforce limits and maintain isolation under resource pressure.\n\n**Data Flow Testing**: Containers process data through a pipeline where the output of one container becomes input for another, implemented through shared filesystem layers and network communication. This tests the integration of filesystem layering with networking while maintaining resource isolation.\n\n**Monitoring and Validation**: Throughout the test execution, resource usage monitoring validates that containers stay within their configured limits even under pressure, that resource contention in one container does not cause others to exceed their limits, and that the container runtime maintains stable operation during peak resource utilization.\n\n| Container | Workload Type | CPU Limit | Memory Limit | Test Validation |\n|-----------|---------------|-----------|--------------|-----------------|\n| calc-1 | Mathematical computation | 1.5 cores | 100MB | CPU usage ≤ 1.5 cores |\n| sort-1 | Large dataset sorting | 0.5 cores | 800MB | Memory usage ≤ 800MB |\n| io-1 | File processing | 0.3 cores | 50MB | I/O operations complete |\n| net-1 | Data transfer | 0.2 cores | 100MB | Network throughput stable |\n| mixed-1 | Combined workload | 1.0 cores | 300MB | All limits respected |\n\n#### Scenario 3: Container Lifecycle Stress Testing\n\nThis scenario exercises the complete container lifecycle under high frequency operations, testing the runtime's stability and resource cleanup capabilities.\n\n**High-Frequency Operations**: The test rapidly creates, starts, stops, and removes containers in various patterns: sequential operations (create-start-stop-remove cycles), parallel operations (multiple containers created simultaneously), and mixed operations (some containers running long-term while others cycle rapidly).\n\n**Resource Exhaustion Testing**: The test pushes the runtime toward various resource limits: creating containers until approaching the maximum number of namespaces, allocating IP addresses until the subnet pool is nearly exhausted, creating filesystem layers until storage space becomes constrained, and generating network traffic until bandwidth limits are reached.\n\n**Error Recovery Validation**: The test intentionally introduces various failure conditions during container lifecycle operations: killing container processes during startup, interrupting filesystem mount operations, simulating network interface failures, and forcing unclean container shutdowns to test cleanup and recovery mechanisms.\n\n**Concurrency and Race Condition Testing**: Multiple test threads perform container operations simultaneously to expose potential race conditions in resource allocation, namespace creation, cgroup management, and network configuration.\n\n| Test Pattern | Operation Count | Concurrency Level | Success Criteria | Failure Detection |\n|--------------|-----------------|-------------------|------------------|-------------------|\n| Rapid cycling | 100 containers | 10 parallel threads | All operations succeed | Check for resource leaks |\n| Long-running mixed | 50 containers | 5 threads, mixed lifecycle | System remains stable | Monitor system resources |\n| Resource exhaustion | Until limits reached | Single thread | Graceful limit handling | Operations fail cleanly |\n| Failure injection | 20 containers | Random failures | Proper error recovery | No orphaned resources |\n| Race condition testing | 30 containers | 20 parallel threads | Consistent resource state | Check for conflicts |\n\n#### Scenario 4: Security Isolation Validation\n\nThis scenario tests the security boundaries created by namespace isolation, ensuring that containers cannot escape their isolation or interfere with host system security.\n\n**Privilege Escalation Prevention**: The test attempts various privilege escalation techniques from within containers, including attempting to access host filesystem paths outside the container's view, trying to modify host network configuration through namespace boundaries, attempting to access host processes or system resources, and testing user namespace mapping to ensure proper privilege isolation.\n\n**Resource Access Boundaries**: Containers attempt to access resources beyond their configured limits, including trying to consume more memory than allocated, attempting to access network interfaces outside their namespace, trying to modify filesystem layers that should be read-only, and attempting to access other containers' resources directly.\n\n**Information Disclosure Prevention**: The test verifies that containers cannot access information they should not see, including host system process information, other containers' filesystem contents, network traffic from other containers, and host system configuration details.\n\n**Container-to-Container Isolation**: Multiple containers attempt to interfere with each other through various vectors, including filesystem access attempts, network communication outside configured channels, resource exhaustion attacks against other containers, and process interference attempts.\n\n| Security Test Category | Attack Vector | Expected Behavior | Validation Method |\n|------------------------|---------------|-------------------|-------------------|\n| Filesystem isolation | Access `/host/etc/passwd` | Access denied or file not found | Check file access results |\n| Process isolation | Kill host process from container | Operation fails | Check process list |\n| Network isolation | Access other container ports | Connection refused | Network connection test |\n| Resource isolation | Exhaust shared resources | Other containers unaffected | Monitor other container performance |\n| User namespace isolation | Access files as different UID | Permission denied | Check file access permissions |\n\n### Common Pitfalls in Container Runtime Testing\n\nTesting container runtimes presents unique challenges because failures often involve complex interactions between kernel features, filesystem operations, and network configuration. Understanding common pitfalls helps developers create more robust test scenarios and debug issues more effectively.\n\n⚠️ **Pitfall: Race Conditions in Container Startup**\nContainer startup involves multiple asynchronous operations (namespace creation, filesystem mounting, network configuration) that can complete in different orders. Tests that immediately check container state after calling `StartContainer` may fail intermittently because the container hasn't fully initialized. The test should poll container status with a reasonable timeout, or better yet, wait for a specific readiness signal from the container process (such as a service listening on a port or a status file being created).\n\n⚠️ **Pitfall: Incomplete Resource Cleanup Detection**\nTests that create and destroy containers rapidly may not detect resource leaks because the effects accumulate slowly. Running a single create-destroy cycle and checking for cleanup appears to work, but running hundreds of cycles reveals leaked mount points, network interfaces, or cgroup directories. Effective testing requires baseline resource measurements before the test, multiple iterations to amplify leak effects, and comprehensive resource scanning after test completion.\n\n⚠️ **Pitfall: Host System Dependencies**\nContainer runtime tests often assume specific host system configurations (kernel version, available namespaces, cgroups v2 enabled, bridge networking support) that may not be available in all test environments. Tests should verify prerequisites before execution and either skip gracefully or provide clear error messages when requirements are not met. Additionally, tests should not assume specific network interface names, IP address ranges, or filesystem paths that may vary between systems.\n\n⚠️ **Pitfall: Timing-Dependent Resource Limit Validation**\nResource usage measurements (CPU, memory, I/O) require time to stabilize and may fluctuate based on system load and kernel scheduling decisions. Tests that immediately check resource usage after starting a workload may see inconsistent results. Effective resource limit testing requires sustained workloads running for sufficient time periods, multiple measurements averaged together, and appropriate tolerance ranges that account for measurement variance while still detecting limit violations.\n\n⚠️ **Pitfall: Network Configuration Interference**\nContainer networking tests can interfere with each other and with host networking configuration, especially when creating bridges, assigning IP addresses, or configuring iptables rules. Tests running in parallel may create conflicting network configurations or exhaust IP address pools. Robust network testing requires isolated network namespaces for test execution, unique IP address ranges for each test, and thorough cleanup of iptables rules and network interfaces.\n\n⚠️ **Pitfall: Filesystem Layer Corruption**\nOverlayfs operations can leave the filesystem in inconsistent states if interrupted during critical operations like mounting or unmounting. Tests that kill container processes or force unclean shutdowns may corrupt overlay layers, affecting subsequent tests. Proper testing requires careful cleanup of overlay mounts even after failures, validation that overlay directories are in expected states, and potentially rebuilding overlay layers if corruption is detected.\n\n### Implementation Guidance\n\nThe container runtime testing implementation requires a systematic approach that validates each milestone's functionality in isolation and then tests integrated scenarios that exercise multiple components simultaneously.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Test Framework | Go testing package with table-driven tests | Ginkgo BDD framework with custom matchers |\n| Test Isolation | Temporary directories with UUID names | Linux user namespaces for complete test isolation |\n| Resource Monitoring | Parse /proc and /sys files directly | Prometheus client library with custom metrics |\n| Network Testing | Simple ping and HTTP requests | Packet capture analysis with gopacket library |\n| Filesystem Validation | Directory listing and file content checks | inotify-based filesystem change monitoring |\n| Container Orchestration | Sequential test execution | Parallel test execution with resource pools |\n\n#### Recommended File Structure\n\n```go\nproject-root/\n  cmd/container-runtime/\n    main.go                           ← CLI entry point\n  internal/runtime/                   ← Core runtime components\n    manager.go\n    container.go\n  internal/namespace/                 ← Namespace isolation\n    namespace.go\n    namespace_test.go                 ← Unit tests\n  internal/cgroup/                   ← Resource control\n    cgroup.go\n    cgroup_test.go                    ← Unit tests\n  internal/filesystem/               ← Overlay filesystem\n    overlay.go\n    overlay_test.go                   ← Unit tests\n  internal/network/                  ← Container networking\n    network.go\n    network_test.go                   ← Unit tests\n  test/                             ← Integration tests\n    integration/                     ← Cross-component tests\n      milestone1_test.go             ← Namespace isolation tests\n      milestone2_test.go             ← Resource control tests\n      milestone3_test.go             ← Filesystem layering tests\n      milestone4_test.go             ← Container networking tests\n    e2e/                            ← End-to-end scenarios\n      webapp_test.go                 ← Multi-container web app\n      batch_test.go                  ← Batch processing scenario\n      lifecycle_test.go              ← Lifecycle stress testing\n      security_test.go               ← Security isolation validation\n    fixtures/                       ← Test data and images\n      test-image/                   ← Simple container image layers\n      workloads/                    ← Test programs and scripts\n    helpers/                        ← Testing utilities\n      test_utils.go                 ← Common testing functions\n      resource_monitor.go           ← Resource validation helpers\n      network_helpers.go            ← Network testing utilities\n```\n\n#### Test Infrastructure Starter Code\n\n```go\n// test/helpers/test_utils.go\npackage helpers\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n    \"time\"\n    \"github.com/google/uuid\"\n)\n\n// TestEnvironment provides isolated testing environment for container runtime tests\ntype TestEnvironment struct {\n    TempDir     string\n    ContainerID string\n    Cleanup     []func() error\n}\n\n// NewTestEnvironment creates isolated test environment with unique IDs and cleanup\nfunc NewTestEnvironment(t *testing.T) *TestEnvironment {\n    tempDir := filepath.Join(\"/tmp\", \"container-test-\"+uuid.New().String())\n    if err := os.MkdirAll(tempDir, 0755); err != nil {\n        t.Fatalf(\"Failed to create temp directory: %v\", err)\n    }\n    \n    env := &TestEnvironment{\n        TempDir:     tempDir,\n        ContainerID: \"test-\" + uuid.New().String()[:8],\n        Cleanup:     make([]func() error, 0),\n    }\n    \n    // Register cleanup for test completion\n    t.Cleanup(func() {\n        env.CleanupAll()\n    })\n    \n    return env\n}\n\n// AddCleanup registers cleanup function to be called when test completes\nfunc (te *TestEnvironment) AddCleanup(cleanup func() error) {\n    te.Cleanup = append(te.Cleanup, cleanup)\n}\n\n// CleanupAll executes all registered cleanup functions\nfunc (te *TestEnvironment) CleanupAll() {\n    for i := len(te.Cleanup) - 1; i >= 0; i-- {\n        if err := te.Cleanup[i](); err != nil {\n            fmt.Printf(\"Cleanup error: %v\\n\", err)\n        }\n    }\n    os.RemoveAll(te.TempDir)\n}\n\n// WaitForCondition polls condition function until it returns true or timeout\nfunc WaitForCondition(condition func() bool, timeout time.Duration, interval time.Duration) bool {\n    deadline := time.Now().Add(timeout)\n    for time.Now().Before(deadline) {\n        if condition() {\n            return true\n        }\n        time.Sleep(interval)\n    }\n    return false\n}\n```\n\n```go\n// test/helpers/resource_monitor.go  \npackage helpers\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\n// ResourceSnapshot captures resource usage at a point in time\ntype ResourceSnapshot struct {\n    Timestamp   time.Time\n    MemoryUsage int64  // bytes\n    CPUUsage    int64  // nanoseconds\n    PIDCount    int64  // number of processes\n}\n\n// ResourceMonitor tracks container resource usage over time\ntype ResourceMonitor struct {\n    cgroupPath string\n    snapshots  []ResourceSnapshot\n}\n\n// NewResourceMonitor creates monitor for specified cgroup path\nfunc NewResourceMonitor(cgroupPath string) *ResourceMonitor {\n    return &ResourceMonitor{\n        cgroupPath: cgroupPath,\n        snapshots:  make([]ResourceSnapshot, 0),\n    }\n}\n\n// TakeSnapshot captures current resource usage values\nfunc (rm *ResourceMonitor) TakeSnapshot() error {\n    snapshot := ResourceSnapshot{\n        Timestamp: time.Now(),\n    }\n    \n    // Read memory usage from cgroup\n    memoryFile := filepath.Join(rm.cgroupPath, \"memory.current\")\n    if data, err := os.ReadFile(memoryFile); err == nil {\n        if usage, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 64); err == nil {\n            snapshot.MemoryUsage = usage\n        }\n    }\n    \n    // Read CPU usage from cgroup  \n    cpuFile := filepath.Join(rm.cgroupPath, \"cpu.stat\")\n    if file, err := os.Open(cpuFile); err == nil {\n        defer file.Close()\n        scanner := bufio.NewScanner(file)\n        for scanner.Scan() {\n            line := scanner.Text()\n            if strings.HasPrefix(line, \"usage_usec \") {\n                if usec, err := strconv.ParseInt(strings.Fields(line)[1], 10, 64); err == nil {\n                    snapshot.CPUUsage = usec * 1000 // convert to nanoseconds\n                }\n                break\n            }\n        }\n    }\n    \n    // Read process count from cgroup\n    pidsFile := filepath.Join(rm.cgroupPath, \"pids.current\")\n    if data, err := os.ReadFile(pidsFile); err == nil {\n        if count, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 64); err == nil {\n            snapshot.PIDCount = count\n        }\n    }\n    \n    rm.snapshots = append(rm.snapshots, snapshot)\n    return nil\n}\n\n// GetAverageUsage returns average resource usage over monitoring period\nfunc (rm *ResourceMonitor) GetAverageUsage(duration time.Duration) ResourceSnapshot {\n    cutoff := time.Now().Add(-duration)\n    var memorySum, cpuSum, pidSum int64\n    var count int64\n    \n    for _, snapshot := range rm.snapshots {\n        if snapshot.Timestamp.After(cutoff) {\n            memorySum += snapshot.MemoryUsage\n            cpuSum += snapshot.CPUUsage\n            pidSum += snapshot.PIDCount\n            count++\n        }\n    }\n    \n    if count == 0 {\n        return ResourceSnapshot{}\n    }\n    \n    return ResourceSnapshot{\n        Timestamp:   time.Now(),\n        MemoryUsage: memorySum / count,\n        CPUUsage:    cpuSum / count,\n        PIDCount:    pidSum / count,\n    }\n}\n```\n\n#### Milestone Test Implementation Skeletons\n\n```go\n// test/integration/milestone1_test.go\npackage integration\n\nimport (\n    \"testing\"\n    \"time\"\n    \"your-project/internal/runtime\"\n    \"your-project/test/helpers\"\n)\n\nfunc TestNamespaceIsolation(t *testing.T) {\n    env := helpers.NewTestEnvironment(t)\n    runtimeManager := runtime.NewManager()\n    \n    // TODO 1: Create container spec with namespace configuration\n    // - Enable PID, mount, network, UTS namespaces\n    // - Set container hostname to differentiate from host\n    // - Configure basic command like [\"sleep\", \"30\"]\n    \n    // TODO 2: Create and start container\n    // - Call CreateContainer with spec\n    // - Call StartContainer to begin process execution\n    // - Verify container reaches ContainerRunning state\n    \n    // TODO 3: Validate PID namespace isolation\n    // - Execute command in container to check PID 1\n    // - Compare process list inside container vs host\n    // - Verify container process appears with different PID on host\n    \n    // TODO 4: Validate mount namespace isolation  \n    // - Create temporary mount inside container\n    // - Verify mount is not visible on host\n    // - Check that /proc filesystem is properly mounted in container\n    \n    // TODO 5: Validate network namespace isolation\n    // - Compare network interface list inside container vs host\n    // - Verify container cannot see host network connections\n    // - Check that container has its own loopback interface\n    \n    // TODO 6: Validate UTS namespace isolation\n    // - Check hostname inside container matches configured value\n    // - Verify host hostname is unchanged\n    // - Test that hostname change in container doesn't affect host\n    \n    // TODO 7: Cleanup and verify\n    // - Stop and remove container\n    // - Verify all namespace resources are cleaned up\n    // - Check for any orphaned processes or mounts\n}\n\nfunc TestUserNamespaceMapping(t *testing.T) {\n    // TODO: Implement user namespace UID/GID mapping tests\n    // - Create container with user namespace enabled\n    // - Configure UID mapping (container root -> host unprivileged user)\n    // - Verify file ownership appears correctly from both perspectives\n    // - Test privilege boundaries are enforced\n}\n```\n\n```go\n// test/integration/milestone2_test.go\npackage integration\n\nimport (\n    \"testing\"\n    \"time\"\n    \"your-project/internal/runtime\"\n    \"your-project/test/helpers\"\n)\n\nfunc TestResourceLimits(t *testing.T) {\n    env := helpers.NewTestEnvironment(t)\n    runtimeManager := runtime.NewManager()\n    monitor := helpers.NewResourceMonitor(\"\")\n    \n    testCases := []struct {\n        name        string\n        memoryLimit int64\n        cpuLimit    int64\n        workload    string\n        expectOOM   bool\n    }{\n        {\n            name:        \"memory_limit_enforced\",\n            memoryLimit: 50 * 1024 * 1024, // 50MB\n            cpuLimit:    1000000000,        // 1 CPU core\n            workload:    \"allocate_100mb\",\n            expectOOM:   true,\n        },\n        {\n            name:        \"cpu_limit_enforced\", \n            memoryLimit: 200 * 1024 * 1024, // 200MB\n            cpuLimit:    500000000,          // 0.5 CPU cores\n            workload:    \"cpu_intensive\",\n            expectOOM:   false,\n        },\n    }\n    \n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            // TODO 1: Create container spec with resource limits\n            // - Set memory limit to tc.memoryLimit \n            // - Set CPU limit to tc.cpuLimit\n            // - Configure workload command based on tc.workload\n            \n            // TODO 2: Create and start container with monitoring\n            // - Create container with resource-limited spec\n            // - Start resource monitoring before container start\n            // - Begin container execution\n            \n            // TODO 3: Monitor resource usage during workload execution\n            // - Take resource snapshots every 100ms for test duration\n            // - Track memory usage, CPU usage, and process count\n            // - Calculate average usage over test period\n            \n            // TODO 4: Validate resource limit enforcement\n            // - Check that memory usage stays within limits (unless OOM expected)\n            // - Verify CPU usage respects configured quota\n            // - Confirm process count stays within PID limits\n            \n            // TODO 5: Handle OOM scenarios if expected\n            // - Check for OOM killer activation if tc.expectOOM is true\n            // - Verify container exit code indicates OOM termination\n            // - Confirm other system processes are not affected\n            \n            // TODO 6: Cleanup and verify resource release\n            // - Stop container and verify graceful resource cleanup\n            // - Check that cgroup directories are removed\n            // - Confirm system resource usage returns to baseline\n        })\n    }\n}\n\nfunc TestResourceMonitoring(t *testing.T) {\n    // TODO: Implement resource usage monitoring accuracy tests\n    // - Create containers with known resource consumption patterns\n    // - Compare reported usage statistics against expected values\n    // - Test monitoring update frequency and accuracy\n    // - Validate alert thresholds and notifications\n}\n```\n\n#### Milestone Checkpoint Commands\n\n```bash\n# Milestone 1: Namespace Isolation\ngo test ./test/integration/milestone1_test.go -v\n\n# Expected output should show:\n# - Container created with isolated namespaces\n# - PID 1 inside container is container process\n# - Network interfaces differ between container and host\n# - Hostname isolation working correctly\n# - All namespace resources cleaned up after test\n\n# Manual verification commands:\nsudo ./container-runtime create test-container --image=test-image --command=\"sleep 60\"\nsudo ./container-runtime start test-container\n\n# In separate terminal, check namespace isolation:\nsudo ./container-runtime exec test-container ps aux          # Should show only container processes\nsudo ./container-runtime exec test-container hostname        # Should show container hostname\nsudo ./container-runtime exec test-container ip link list   # Should show container interfaces\n\n# Milestone 2: Resource Control  \ngo test ./test/integration/milestone2_test.go -v\n\n# Expected behavior:\n# - Containers respect memory limits (OOM kill when exceeded)\n# - CPU usage stays within configured quotas  \n# - Resource monitoring reports accurate usage statistics\n# - Cgroup cleanup occurs properly after container removal\n\n# Manual verification:\nsudo ./container-runtime create limited-container --memory=50m --cpu=0.5 --command=\"stress-test\"\nsudo ./container-runtime start limited-container\n\n# Monitor resource usage:\ncat /sys/fs/cgroup/container-runtime/limited-container/memory.current\ncat /sys/fs/cgroup/container-runtime/limited-container/cpu.stat\n\n# Milestone 3: Filesystem Layering\ngo test ./test/integration/milestone3_test.go -v  \n\n# Expected results:\n# - Overlay filesystem properly combines multiple layers\n# - Copy-on-write behavior creates files in upper layer\n# - File modifications don't affect read-only base layers\n# - Layer cleanup removes overlay mounts and directories\n\n# Manual verification:\nsudo ./container-runtime create layered-container --image=multi-layer-image\nfindmnt | grep overlay                           # Should show overlay mount\nsudo ./container-runtime exec layered-container touch /test-file\nls /var/lib/container-runtime/containers/*/upper/  # Should contain test-file\n\n# Milestone 4: Container Networking\ngo test ./test/integration/milestone4_test.go -v\n\n# Expected functionality:\n# - Veth pairs connect containers to bridge network\n# - Containers can communicate using IP addresses  \n# - Port forwarding enables external access to services\n# - Network isolation prevents unauthorized access\n\n# Manual verification:\nsudo ./container-runtime create web-server --port-mapping=8080:80 --command=\"simple-http-server\"\nsudo ./container-runtime create client --command=\"sleep 60\"  \nsudo ./container-runtime start web-server\nsudo ./container-runtime start client\n\n# Test connectivity:\ncurl http://localhost:8080                       # Should reach container web server\nsudo ./container-runtime exec client ping <web-server-ip>  # Should succeed\n```\n\nThe testing implementation provides comprehensive validation of each milestone's functionality while building toward realistic integration scenarios. The progressive testing approach ensures that developers can verify each component works correctly before integrating with dependent components, making debugging more manageable and building confidence in the overall system design.\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (1-4) - This section provides debugging techniques for namespace isolation (milestone 1), resource control (milestone 2), filesystem layering (milestone 3), and network management (milestone 4). Effective debugging requires understanding both the kernel-level mechanisms and the container runtime's abstraction layers.\n\nBuilding a container runtime involves orchestrating multiple complex Linux kernel mechanisms that can fail in subtle ways. When a container fails to start, exhibits unexpected behavior, or consumes incorrect resources, the root cause could lie in namespace creation, cgroup configuration, filesystem mounting, or network setup. This debugging guide provides systematic approaches for diagnosing problems in each component, using kernel inspection tools and container runtime state examination.\n\n**Mental Model: Detective Investigation**\n\nThink of debugging a container runtime like investigating a crime scene. Each kernel mechanism (namespaces, cgroups, overlayfs, network interfaces) leaves traces in the system that tell a story about what happened. Just as a detective follows evidence from multiple sources to reconstruct events, we use kernel state inspection tools, log analysis, and systematic testing to understand why containers behave unexpectedly. The key is knowing where to look for evidence and how to interpret what we find.\n\nThe debugging process follows a systematic approach: first observe symptoms from the container's perspective, then examine the underlying kernel state, identify discrepancies between expected and actual configuration, and finally trace the root cause back through the container runtime's component interactions. Each component leaves different types of evidence in different locations within the kernel's virtual filesystems.\n\n### Namespace Debugging Techniques\n\nNamespace issues manifest as containers seeing unexpected processes, having incorrect filesystem views, or lacking proper isolation from the host system. These problems typically stem from incorrect namespace creation, failed filesystem operations, or improper process assignment to namespaces.\n\n**Understanding Namespace State Inspection**\n\nThe Linux kernel exposes namespace information through the `/proc` filesystem, allowing us to inspect which namespaces exist and which processes belong to them. Each process has namespace information in `/proc/[pid]/ns/` that shows symbolic links to namespace identifiers. When containers share namespaces unexpectedly or fail to create new namespaces, this directory provides the ground truth about actual kernel state.\n\nThe `lsns` command provides a high-level view of all namespaces on the system, showing which processes belong to each namespace type. This tool helps identify whether container processes are actually isolated or accidentally sharing host namespaces. For example, if a container process appears in the same PID namespace as the host, the namespace creation failed silently.\n\n**Common Namespace Debugging Scenarios**\n\n| Symptom | Likely Cause | Diagnostic Commands | Fix Approach |\n|---------|--------------|-------------------|---------------|\n| Container sees all host processes | PID namespace creation failed | `lsns -t pid`, `ls -la /proc/[pid]/ns/` | Check namespace creation flags, verify CLONE_NEWPID |\n| Container filesystem shows host files | Mount namespace creation failed or pivot_root failed | `findmnt`, `cat /proc/[pid]/mountinfo` | Verify mount namespace, check pivot_root sequence |\n| Container has host hostname | UTS namespace not created or not configured | `unshare -u hostname`, check `/proc/[pid]/ns/uts` | Ensure UTS namespace creation and hostname setting |\n| Container networking uses host interfaces | Network namespace creation failed | `ip netns list`, `ip link show` in container | Verify network namespace creation and veth setup |\n| Permission denied in container | User namespace mapping incorrect | `cat /proc/[pid]/uid_map`, `cat /proc/[pid]/gid_map` | Fix UID/GID mapping configuration |\n\n**Process and Mount Inspection Techniques**\n\nWhen containers exhibit incorrect process visibility, the first step is determining which PID namespace the container process actually belongs to. The `/proc/[pid]/ns/pid` symlink shows the namespace identifier, which should be unique for each container. If multiple containers or the host share the same PID namespace identifier, namespace isolation has failed.\n\nMount namespace problems require examining the actual mount table that the container process sees. The `/proc/[pid]/mountinfo` file shows all mount points visible to a specific process, including overlay filesystem mounts, bind mounts, and special filesystems like `/proc` and `/sys`. Comparing the container's mount table with the expected configuration reveals whether filesystem isolation is working correctly.\n\nThe `pivot_root` operation is particularly error-prone and leaves specific evidence when it fails. If `pivot_root` fails, the container process will still see the host root filesystem instead of the container's overlay filesystem. The mount table will show the original host mounts instead of the expected container filesystem hierarchy.\n\n**Network Namespace Inspection**\n\nNetwork namespace isolation problems manifest as containers having unexpected network interfaces or connectivity. The `ip netns` command lists all named network namespaces, but container network namespaces are typically unnamed and must be accessed through process namespace references.\n\nTo inspect a container's network configuration, use `nsenter` to execute network commands within the container's namespace: `nsenter -t [pid] -n ip addr show` reveals which interfaces exist inside the container. A properly isolated container should only see its container interface and the loopback interface, not host interfaces.\n\nNetwork namespace debugging also involves verifying veth pair creation and bridge attachment. Each veth pair creates two linked interfaces, with one end in the host namespace and one in the container namespace. The `ip link show` command in both namespaces should show the paired interfaces with matching indices.\n\n**File Permission and User Namespace Issues**\n\nUser namespace problems typically manifest as permission denied errors when the container tries to access files or perform operations that should be allowed. These issues stem from incorrect UID/GID mapping between the container and host user namespaces.\n\nThe `/proc/[pid]/uid_map` and `/proc/[pid]/gid_map` files show the current mapping configuration. Each line specifies a range mapping: container ID range, host ID range, and count. Incorrect mappings cause the container process to have unexpected privileges or lack necessary permissions.\n\nUser namespace debugging requires understanding the interaction between namespace isolation and filesystem permissions. Files created by the container appear on the host filesystem with the mapped host UID/GID, which must align with the host user running the container runtime.\n\n⚠️ **Pitfall: Empty /proc Directory in Container**\n\nOne of the most common namespace issues occurs when the container's `/proc` directory is empty or shows host processes instead of container processes. This happens when the mount namespace is created correctly, but `/proc` is not remounted within the container's PID namespace.\n\nThe fix requires mounting a new `/proc` filesystem after creating the PID namespace but before executing the container process:\n\n```bash\n# Inside container, after PID namespace creation:\nmount -t proc proc /proc\n```\n\nThis issue is particularly confusing because the container has a separate PID namespace (process isolation works), but tools like `ps` fail because they can't read process information from `/proc`.\n\n⚠️ **Pitfall: pivot_root Requires Mount Point**\n\nThe `pivot_root` system call fails with \"Invalid argument\" if the new root directory is not a mount point. This is a common error when trying to pivot to a regular directory instead of a mounted filesystem.\n\nThe solution is ensuring the new root is a mount point before calling `pivot_root`. For overlay filesystems, this means the overlay mount operation must complete successfully before attempting the filesystem pivot. Always verify mount success before proceeding to pivot_root.\n\n**Namespace Debugging Command Reference**\n\n| Command | Purpose | Example Usage |\n|---------|---------|---------------|\n| `lsns` | List all namespaces | `lsns -t pid -p [container-pid]` |\n| `nsenter` | Execute command in namespace | `nsenter -t [pid] -a ps aux` |\n| `unshare` | Create namespace for testing | `unshare -p -f --mount-proc bash` |\n| `findmnt` | Show mount table | `findmnt -N [pid]` |\n| `cat /proc/[pid]/ns/*` | Show namespace IDs | Compare container vs host namespace IDs |\n\n### Cgroup Debugging Techniques\n\nCgroup-related problems manifest as containers exceeding resource limits, failing to start due to permission issues, or resource monitoring returning incorrect values. These issues typically stem from incorrect cgroup hierarchy setup, improper controller configuration, or permission problems with cgroup filesystem access.\n\n**Understanding Cgroup State Inspection**\n\nThe cgroups v2 unified hierarchy exposes all configuration and statistics through the `/sys/fs/cgroup` filesystem. Each container gets its own cgroup directory containing controller configuration files and runtime statistics. Understanding the relationship between cgroup hierarchy, controller enablement, and process assignment is crucial for effective debugging.\n\nThe `systemd-cgls` command provides a tree view of the entire cgroup hierarchy, showing which processes belong to each cgroup. This tool helps identify whether container processes are assigned to the correct cgroups and whether cgroup nesting is configured properly.\n\n**Cgroup Hierarchy and Controller Verification**\n\n| Component | File Location | Purpose | Diagnostic Command |\n|-----------|---------------|---------|-------------------|\n| Cgroup membership | `/sys/fs/cgroup/[path]/cgroup.procs` | Lists PIDs in cgroup | `cat cgroup.procs` |\n| Enabled controllers | `/sys/fs/cgroup/cgroup.controllers` | Shows available controllers | `cat cgroup.controllers` |\n| Memory limit | `/sys/fs/cgroup/[path]/memory.max` | Current memory limit | `cat memory.max` |\n| Memory usage | `/sys/fs/cgroup/[path]/memory.current` | Current memory consumption | `cat memory.current` |\n| CPU quota | `/sys/fs/cgroup/[path]/cpu.max` | CPU quota and period | `cat cpu.max` |\n| OOM events | `/sys/fs/cgroup/[path]/memory.events` | OOM kill statistics | `grep oom_kill memory.events` |\n\nThe cgroup hierarchy must be properly structured for controllers to function correctly. Each container should have its own subdirectory under a parent cgroup where the necessary controllers are enabled. The `cgroup.subtree_control` file in parent directories controls which controllers are available to child cgroups.\n\n**Memory Controller Debugging**\n\nMemory limit problems often manifest as containers being killed unexpectedly or consuming more memory than expected. The memory controller provides detailed statistics about memory usage patterns, pressure indicators, and out-of-memory events.\n\nThe `memory.current` file shows instantaneous memory usage, while `memory.max` shows the configured limit. If usage consistently approaches the limit, the container may be experiencing memory pressure. The `memory.pressure` file provides pressure stall information indicating when memory allocation is being delayed.\n\nOut-of-memory events are recorded in `memory.events`, which tracks both OOM kills and memory pressure events. When a container is killed due to memory exhaustion, this file shows the oom_kill count incrementing. This helps distinguish between application crashes and resource limit enforcement.\n\n**CPU Controller Debugging**\n\nCPU limit issues manifest as containers running slower than expected or consuming more CPU than allocated. The CPU controller uses quota and period values to implement CPU time limits, which can be confusing to interpret and debug.\n\nThe `cpu.max` file contains two values: quota and period (e.g., \"100000 100000\" means 100ms quota per 100ms period, allowing 100% CPU). The `cpu.stat` file shows actual CPU usage statistics, including throttling events when the quota is exceeded.\n\nCPU throttling debugging requires comparing the configured quota with actual usage patterns. High values in `cpu.stat` for `throttled_usec` indicate the container is being actively throttled. This may be expected behavior if the limit is working correctly, or indicate misconfigured limits if the container should have more CPU access.\n\n**Common Cgroup Debugging Scenarios**\n\n| Symptom | Likely Cause | Investigation Steps | Resolution |\n|---------|--------------|-------------------|-------------|\n| Container immediately killed | Memory limit too low or OOM kill | Check `memory.events` for oom_kill, compare `memory.max` vs `memory.current` | Increase memory limit or optimize container memory usage |\n| Container runs slowly | CPU throttling or insufficient quota | Check `cpu.stat` for throttling, verify `cpu.max` configuration | Adjust CPU quota or identify CPU-intensive operations |\n| Resource monitoring shows zero usage | Cgroup not created or process not assigned | Verify cgroup directory exists, check `cgroup.procs` contains container PID | Fix cgroup creation or process assignment |\n| Permission denied writing cgroup files | Insufficient privileges or controller not enabled | Check file ownership, verify controller in `cgroup.subtree_control` | Run with appropriate privileges or enable controllers |\n| Cgroup cannot be removed | Processes still in cgroup or child cgroups exist | Check `cgroup.procs` is empty, verify no subdirectories | Kill remaining processes or remove child cgroups first |\n\n⚠️ **Pitfall: Cgroups v1 vs v2 Interface Differences**\n\nMany debugging approaches fail because they assume cgroups v1 interfaces while the system uses cgroups v2. The file locations, interface syntax, and controller behaviors differ significantly between versions.\n\nTo determine which version is active, check `/proc/mounts` for cgroup filesystem types. Cgroups v2 shows `cgroup2` filesystem type mounted at `/sys/fs/cgroup`, while v1 shows separate `cgroup` mounts for each controller.\n\nThe debugging commands and file paths in this guide assume cgroups v2. For systems still using v1, controller files are located under separate mount points like `/sys/fs/cgroup/memory/` and `/sys/fs/cgroup/cpu/`.\n\n⚠️ **Pitfall: Controller Delegation Requirements**\n\nCgroups v2 requires explicit controller delegation from parent to child cgroups. If a controller is not enabled in the parent's `cgroup.subtree_control`, child cgroups cannot use that controller even if it's available at the system level.\n\nTo fix delegation issues, enable controllers at each level of the hierarchy: `echo \"+memory +cpu\" > /sys/fs/cgroup/[parent]/cgroup.subtree_control`. This must be done recursively for all parent cgroups up to the container's cgroup.\n\n**Resource Monitoring and Statistics Interpretation**\n\nEffective cgroup debugging requires understanding how to interpret the statistics and pressure indicators provided by each controller. The statistics files update continuously and provide both instantaneous values and cumulative counters.\n\nMemory statistics include detailed breakdowns of different memory types: anonymous memory, file cache, shared memory, and kernel memory. Understanding these categories helps identify whether memory usage is due to application data, file system cache, or kernel overhead.\n\nCPU statistics track not just usage time but also scheduling fairness, voluntary context switches, and throttling events. High involuntary context switch counts may indicate CPU contention, while excessive throttling suggests quota adjustments are needed.\n\n**Cgroup Debugging Tool Reference**\n\n| Tool | Purpose | Key Usage |\n|------|---------|-----------|\n| `systemd-cgls` | Display cgroup hierarchy | `systemd-cgls -u [container-service]` |\n| `systemd-cgtop` | Live cgroup resource usage | `systemd-cgtop` |\n| `cat /sys/fs/cgroup/*/cgroup.*` | Inspect cgroup configuration | Check membership, controllers, limits |\n| `echo [pid] > cgroup.procs` | Manually assign process | For testing process assignment |\n| `cgexec` | Execute command in cgroup | `cgexec -g memory:/test/container command` |\n\n### Network Debugging Techniques\n\nContainer networking problems manifest as connectivity failures, incorrect IP addresses, unreachable services, or port mapping not working. These issues typically involve veth pair creation, bridge configuration, IP address assignment, or iptables rule management.\n\n**Understanding Container Network Architecture**\n\nContainer networking creates a complex topology involving multiple network namespaces, virtual interfaces, bridges, and NAT rules. Each component can fail independently, making systematic debugging essential. The key is understanding the packet path from external clients through the host networking stack to the container application.\n\nA typical packet flow involves: external client → host interface → iptables DNAT → bridge → veth pair → container interface → container application. Each step in this path can be verified independently using standard Linux networking tools.\n\n**Network Interface and Bridge Inspection**\n\n| Component | Host Command | Container Command | What to Verify |\n|-----------|--------------|------------------|----------------|\n| Veth pair existence | `ip link show` | `nsenter -t [pid] -n ip link show` | Both ends exist and are UP |\n| Bridge membership | `bridge link show` | N/A | Container veth attached to bridge |\n| IP address assignment | `bridge fdb show` | `nsenter -t [pid] -n ip addr show` | Container has correct IP |\n| Routing configuration | `ip route show` | `nsenter -t [pid] -n ip route show` | Default route points to bridge gateway |\n| Interface statistics | `ip -s link show [interface]` | Same inside container | Check for packet drops or errors |\n\nNetwork interface debugging starts with verifying that veth pairs are created correctly and both ends are operational. The `ip link show` command should show the host end of the veth pair with state UP, and the corresponding interface inside the container namespace should also be UP with the expected name.\n\nBridge configuration requires verifying that the container's veth interface is properly attached to the container bridge. The `bridge link show` command displays all interfaces attached to bridges, and the container interface should appear in this list with the correct bridge association.\n\n**IP Address and Routing Verification**\n\nIP address assignment problems cause containers to have incorrect addresses or duplicate addresses that conflict with other containers. The container's IP address should be unique within the bridge subnet and properly configured with the correct netmask and gateway.\n\nWithin the container namespace, `ip addr show` should display the assigned IP address on the container interface. The default route should point to the bridge gateway IP address, enabling communication with other containers and external networks.\n\nAddress resolution (ARP) problems can cause connectivity issues even when IP configuration appears correct. The `ip neigh show` command displays the ARP table, which should contain entries for the gateway and other containers that have been contacted.\n\n**Port Forwarding and NAT Rule Debugging**\n\nPort mapping relies on iptables NAT rules to forward traffic from host ports to container ports. These rules span multiple iptables tables and chains, making debugging complex but systematic.\n\n| Table | Chain | Rule Type | Purpose | Verification Command |\n|-------|-------|-----------|---------|-------------------|\n| nat | PREROUTING | DNAT | Forward host port to container | `iptables -t nat -L PREROUTING -n -v` |\n| filter | FORWARD | ACCEPT | Allow forwarded traffic | `iptables -L FORWARD -n -v` |\n| nat | POSTROUTING | MASQUERADE | Source NAT for outbound | `iptables -t nat -L POSTROUTING -n -v` |\n\nNAT rule debugging requires checking that destination NAT (DNAT) rules exist for each port mapping and that the rules correctly translate host IP:port to container IP:port. The rule should appear in the PREROUTING chain with the correct target specification.\n\nForward rules in the filter table must allow traffic to pass between the host and container interfaces. Missing ACCEPT rules in the FORWARD chain cause connections to be dropped even when NAT rules are correctly configured.\n\n**Common Network Debugging Scenarios**\n\n| Symptom | Likely Cause | Diagnostic Steps | Resolution |\n|---------|--------------|-----------------|------------|\n| Container has no network interface | Network namespace creation failed or veth not moved | Check `ip link` in container, verify network namespace | Recreate veth pair and move to namespace |\n| Container cannot reach other containers | Bridge not configured or IP conflict | Check bridge membership, verify unique IPs | Fix bridge setup or resolve IP conflict |\n| External clients cannot reach container service | Port forwarding rules missing or incorrect | Check iptables NAT rules, test with telnet | Add or fix DNAT rules in iptables |\n| Container cannot reach external services | No default route or DNS misconfiguration | Check routing table in container, test DNS | Configure default route and DNS servers |\n| Intermittent connectivity issues | MTU mismatch or packet fragmentation | Check MTU on all interfaces, capture packets | Set consistent MTU values across path |\n\n⚠️ **Pitfall: Veth Interface Names and Namespace Movement**\n\nVeth interfaces have confusing naming behavior when moved between namespaces. Creating a veth pair with specific names and then moving one end to a container namespace can result in unexpected interface names inside the container.\n\nThe solution is to rename the container interface after moving it to the target namespace: `ip link set [old-name] name [new-name]`. This ensures consistent interface naming regardless of the kernel's automatic name generation.\n\nAdditionally, attempting to delete a veth pair from the wrong namespace can fail silently, leaving interfaces in an inconsistent state. Always delete veth pairs from the namespace containing the interface you're targeting.\n\n⚠️ **Pitfall: iptables Rule Persistence and Cleanup**\n\nContainer runtime crashes or improper shutdown can leave iptables rules in place, causing port conflicts when restarting containers with the same port mappings. These orphaned rules can prevent new containers from binding to the same ports.\n\nThe fix requires explicitly cleaning up iptables rules during container removal: `iptables -t nat -D PREROUTING -p tcp --dport [host-port] -j DNAT --to [container-ip]:[container-port]`. Implementing proper cleanup ensures that container removal completely reverses the network configuration changes.\n\n**Network Performance and Packet Analysis**\n\nNetwork debugging often requires analyzing actual packet flow to identify where communication fails. The `tcpdump` tool can capture packets on any interface, including veth interfaces and bridges, showing exactly what traffic is flowing and where it stops.\n\nCapturing packets on both ends of a veth pair reveals whether traffic is reaching the container interface and whether responses are being sent back. The command `tcpdump -i [interface] -n` shows packet headers without hostname resolution, making it easier to verify IP addresses and ports.\n\nBridge packet analysis helps identify forwarding issues: `tcpdump -i [bridge-name] -n` captures all traffic crossing the bridge, including inter-container communication and traffic to/from the host namespace.\n\n**Network Debugging Tool Reference**\n\n| Tool | Purpose | Key Usage Examples |\n|------|---------|-------------------|\n| `ip` | Interface and routing management | `ip link`, `ip addr`, `ip route`, `ip netns` |\n| `bridge` | Bridge configuration inspection | `bridge link show`, `bridge fdb show` |\n| `iptables` | Firewall and NAT rule management | `iptables -L -n -v`, `iptables -t nat -L` |\n| `nsenter` | Execute commands in network namespace | `nsenter -t [pid] -n [command]` |\n| `tcpdump` | Packet capture and analysis | `tcpdump -i [interface] -n` |\n| `ss` | Socket statistics and connection state | `ss -tlnp` (listening sockets), `ss -an` (all connections) |\n\n### Implementation Guidance\n\nThe debugging techniques described above require systematic application during container runtime development. Effective debugging combines automated testing with manual inspection tools to identify problems early and understand their root causes.\n\n**Technology Recommendations for Debugging Infrastructure**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Log Analysis | Text logs with grep/awk | Structured logging with JSON + log aggregation |\n| State Inspection | Manual shell commands | Automated scripts with health checks |\n| Network Testing | ping/curl commands | Packet capture with automated analysis |\n| Resource Monitoring | Manual /sys/fs/cgroup inspection | Prometheus metrics collection |\n| Error Tracking | Function return values | Distributed tracing with OpenTelemetry |\n\n**Recommended File Structure for Debugging Support**\n\n```\ncontainer-runtime/\n  cmd/\n    runtime/main.go                 ← main runtime binary\n    debug/\n      inspect.go                    ← debug inspection commands\n      health-check.go               ← automated health checking\n  internal/\n    debug/\n      namespace.go                  ← namespace debugging utilities\n      cgroup.go                     ← cgroup inspection helpers\n      network.go                    ← network debugging tools\n    logging/\n      structured.go                 ← structured logging setup\n  scripts/\n    debug-container.sh              ← shell script for manual debugging\n    cleanup-orphaned.sh             ← cleanup script for orphaned resources\n```\n\n**Debug Inspection Infrastructure**\n\n```go\n// DebugInspector provides comprehensive container runtime debugging capabilities.\n// It coordinates inspection across namespaces, cgroups, filesystem, and network components.\ntype DebugInspector struct {\n    runtime *RuntimeManager\n    logger  *StructuredLogger\n    \n    // Component-specific inspectors\n    namespaceInspector *NamespaceInspector\n    cgroupInspector    *CgroupInspector\n    networkInspector   *NetworkInspector\n    filesystemInspector *FilesystemInspector\n}\n\n// InspectContainer performs comprehensive debugging inspection of a container.\n// Returns detailed state information for all container components.\nfunc (d *DebugInspector) InspectContainer(containerID string) (*ContainerDebugInfo, error) {\n    // TODO 1: Load container state from StateManager\n    // TODO 2: Inspect namespace state using NamespaceInspector\n    // TODO 3: Collect cgroup statistics and configuration\n    // TODO 4: Verify network configuration and connectivity\n    // TODO 5: Check filesystem mount status and overlay state\n    // TODO 6: Aggregate all inspection results into ContainerDebugInfo\n    // TODO 7: Identify any configuration inconsistencies or errors\n}\n\n// ContainerDebugInfo aggregates debugging information from all container components.\ntype ContainerDebugInfo struct {\n    ContainerID   string                 `json:\"container_id\"`\n    State         ContainerState         `json:\"state\"`\n    Namespace     NamespaceDebugInfo     `json:\"namespace\"`\n    Cgroup        CgroupDebugInfo        `json:\"cgroup\"`\n    Network       NetworkDebugInfo       `json:\"network\"`\n    Filesystem    FilesystemDebugInfo    `json:\"filesystem\"`\n    Issues        []DebugIssue           `json:\"issues\"`\n    Recommendations []string             `json:\"recommendations\"`\n}\n```\n\n**Namespace Debugging Implementation**\n\n```go\n// NamespaceInspector provides tools for inspecting namespace state and configuration.\ntype NamespaceInspector struct {\n    procFS string // typically \"/proc\"\n}\n\n// InspectNamespaceState examines namespace configuration for a container process.\n// Returns detailed information about namespace types, IDs, and isolation status.\nfunc (ni *NamespaceInspector) InspectNamespaceState(pid int) (*NamespaceDebugInfo, error) {\n    // TODO 1: Read namespace information from /proc/[pid]/ns/\n    // TODO 2: Compare container namespace IDs with host namespace IDs\n    // TODO 3: Verify expected namespace types are created and isolated\n    // TODO 4: Check mount table from /proc/[pid]/mountinfo\n    // TODO 5: Verify /proc filesystem is properly mounted in container\n    // TODO 6: Inspect user namespace UID/GID mappings\n    // TODO 7: Check UTS namespace hostname configuration\n}\n\n// VerifyProcessIsolation checks if container process sees only expected processes.\n// Tests PID namespace isolation by comparing visible processes.\nfunc (ni *NamespaceInspector) VerifyProcessIsolation(containerPID int) (*ProcessIsolationResult, error) {\n    // TODO 1: Execute 'ps aux' inside container namespace using nsenter\n    // TODO 2: Parse process list and verify container process has PID 1\n    // TODO 3: Ensure no host processes are visible in container\n    // TODO 4: Check that only container and child processes are visible\n    // TODO 5: Return isolation status with any violations detected\n}\n```\n\n**Cgroup Debugging Implementation**\n\n```go\n// CgroupInspector provides tools for inspecting cgroup configuration and resource usage.\ntype CgroupInspector struct {\n    cgroupRoot string // typically \"/sys/fs/cgroup\"\n}\n\n// InspectCgroupConfig examines cgroup setup and resource limits for a container.\n// Returns comprehensive information about controllers, limits, and current usage.\nfunc (ci *CgroupInspector) InspectCgroupConfig(cgroupPath string) (*CgroupDebugInfo, error) {\n    // TODO 1: Verify cgroup directory exists at expected path\n    // TODO 2: Check enabled controllers in cgroup.controllers\n    // TODO 3: Read memory limits from memory.max and memory.swap.max\n    // TODO 4: Read CPU configuration from cpu.max and cpu.weight\n    // TODO 5: Collect current usage from memory.current and cpu.stat\n    // TODO 6: Check for OOM events in memory.events\n    // TODO 7: Verify process assignment in cgroup.procs\n}\n\n// MonitorResourcePressure tracks resource pressure indicators for debugging.\n// Returns pressure information that can indicate resource bottlenecks.\nfunc (ci *CgroupInspector) MonitorResourcePressure(cgroupPath string) (*PressureInfo, error) {\n    // TODO 1: Read memory pressure from memory.pressure file\n    // TODO 2: Read CPU pressure from cpu.pressure file\n    // TODO 3: Read IO pressure from io.pressure file\n    // TODO 4: Parse pressure stall information (some, full averages)\n    // TODO 5: Calculate pressure trends over monitoring period\n    // TODO 6: Return structured pressure information with analysis\n}\n```\n\n**Network Debugging Implementation**\n\n```go\n// NetworkInspector provides tools for debugging container networking configuration.\ntype NetworkInspector struct {\n    netlink NetlinkInterface\n    iptables IPTablesInterface\n}\n\n// InspectNetworkConfig examines network setup for container connectivity debugging.\n// Returns detailed information about interfaces, routing, and NAT configuration.\nfunc (ni *NetworkInspector) InspectNetworkConfig(containerID string, pid int) (*NetworkDebugInfo, error) {\n    // TODO 1: List network interfaces in host and container namespaces\n    // TODO 2: Verify veth pair creation and proper link state\n    // TODO 3: Check bridge membership for container interface\n    // TODO 4: Inspect IP address assignment and routing configuration\n    // TODO 5: Verify iptables NAT rules for port forwarding\n    // TODO 6: Test connectivity between container and bridge gateway\n    // TODO 7: Check DNS configuration in container namespace\n}\n\n// TestConnectivity performs connectivity tests for network debugging.\n// Tests various network paths to identify where communication fails.\nfunc (ni *NetworkInspector) TestConnectivity(containerPID int, targetHost string, targetPort int) (*ConnectivityTestResult, error) {\n    // TODO 1: Test loopback connectivity within container\n    // TODO 2: Test connectivity to bridge gateway from container\n    // TODO 3: Test connectivity to other containers on same bridge\n    // TODO 4: Test connectivity to external hosts from container\n    // TODO 5: Test port forwarding from host to container service\n    // TODO 6: Return detailed results showing which tests passed/failed\n}\n```\n\n**Automated Health Checking**\n\n```go\n// HealthChecker provides automated validation of container runtime state.\n// Performs systematic checks to identify common configuration problems.\ntype HealthChecker struct {\n    inspector *DebugInspector\n    logger    *StructuredLogger\n}\n\n// ValidateContainerHealth performs comprehensive health checking for a container.\n// Returns structured results indicating any detected issues or inconsistencies.\nfunc (hc *HealthChecker) ValidateContainerHealth(containerID string) (*HealthCheckResult, error) {\n    // TODO 1: Verify container state is consistent across all components\n    // TODO 2: Check that all expected namespaces are created and isolated\n    // TODO 3: Validate cgroup configuration matches container specification\n    // TODO 4: Verify network configuration and connectivity\n    // TODO 5: Check filesystem mount status and overlay configuration\n    // TODO 6: Test basic container operations (exec, signal delivery)\n    // TODO 7: Return comprehensive health status with recommendations\n}\n```\n\n**Milestone Checkpoints for Debugging Implementation**\n\nAfter implementing debugging capabilities for each milestone:\n\n**Milestone 1 Checkpoint - Namespace Debugging:**\n```bash\n# Test namespace inspection\ngo run ./cmd/debug inspect --container test-container --component namespaces\n\n# Expected output shows:\n# - PID namespace: isolated (container PID 1 ≠ host PID)\n# - Mount namespace: isolated (/proc shows only container processes)\n# - Network namespace: isolated (only container interfaces visible)\n# - UTS namespace: isolated (container hostname differs from host)\n\n# Test process isolation verification\nsudo nsenter -t $(pgrep test-container) -p ps aux\n# Should show only container processes with container process as PID 1\n```\n\n**Milestone 2 Checkpoint - Cgroup Debugging:**\n```bash\n# Test cgroup inspection\ngo run ./cmd/debug inspect --container test-container --component cgroups\n\n# Expected output shows:\n# - Memory limit: configured and enforced\n# - CPU quota: configured with expected values\n# - Process assignment: container PID in correct cgroup\n# - Resource usage: current consumption within limits\n\n# Test resource monitoring\ngo run ./cmd/debug monitor --container test-container --duration 30s\n# Should show resource usage trends and pressure indicators\n```\n\n**Milestone 3 Checkpoint - Filesystem Debugging:**\n```bash\n# Test overlay filesystem inspection\ngo run ./cmd/debug inspect --container test-container --component filesystem\n\n# Expected output shows:\n# - Overlay mount: correctly configured with upper/lower/work directories\n# - Layer stacking: proper order and accessibility\n# - Copy-on-write: file modifications isolated to upper layer\n\n# Verify overlay mount\nfindmnt | grep test-container\n# Should show overlayfs mount with correct layer directories\n```\n\n**Milestone 4 Checkpoint - Network Debugging:**\n```bash\n# Test network configuration inspection\ngo run ./cmd/debug inspect --container test-container --component network\n\n# Expected output shows:\n# - Veth pair: created and properly linked\n# - Bridge membership: container attached to bridge\n# - IP assignment: unique IP from configured pool\n# - Port forwarding: iptables rules for mapped ports\n\n# Test connectivity\ngo run ./cmd/debug test-connectivity --container test-container --target google.com:80\n# Should show successful connectivity test results\n```\n\n**Debugging Script Examples**\n\n```bash\n#!/bin/bash\n# debug-container.sh - Manual debugging script for container issues\n\nCONTAINER_ID=\"$1\"\nif [ -z \"$CONTAINER_ID\" ]; then\n    echo \"Usage: $0 <container-id>\"\n    exit 1\nfi\n\necho \"=== Container Debug Information ===\"\necho \"Container ID: $CONTAINER_ID\"\n\n# Get container PID\nPID=$(pgrep -f \"$CONTAINER_ID\")\nif [ -z \"$PID\" ]; then\n    echo \"ERROR: Container process not found\"\n    exit 1\nfi\n\necho \"Container PID: $PID\"\n\n# Check namespace isolation\necho -e \"\\n=== Namespace Information ===\"\nls -la \"/proc/$PID/ns/\"\n\n# Check cgroup assignment\necho -e \"\\n=== Cgroup Information ===\"\ncat \"/proc/$PID/cgroup\"\n\n# Check network configuration\necho -e \"\\n=== Network Configuration ===\"\nnsenter -t \"$PID\" -n ip addr show\nnsenter -t \"$PID\" -n ip route show\n\n# Check resource usage\necho -e \"\\n=== Resource Usage ===\"\nCGROUP_PATH=$(grep memory \"/proc/$PID/cgroup\" | cut -d: -f3)\nif [ -n \"$CGROUP_PATH\" ]; then\n    cat \"/sys/fs/cgroup$CGROUP_PATH/memory.current\"\n    cat \"/sys/fs/cgroup$CGROUP_PATH/memory.max\"\nfi\n```\n\nThis debugging implementation provides comprehensive tools for identifying and resolving container runtime issues across all components. The structured approach ensures systematic problem diagnosis while the automated health checking helps prevent issues from reaching production.\n\n\n## Future Extensions\n\n> **Milestone(s):** Beyond milestones 1-4 - This section outlines advanced features that could be added to enhance our container runtime with production-grade security, advanced networking capabilities, and enterprise features.\n\n### Mental Model: Construction Site Evolution\n\nThink of our container runtime like a construction site that starts with basic safety measures and essential tools. We began with fundamental isolation (hard hats and safety barriers), basic resource allocation (power and water connections), simple shelters (basic structures), and basic communication (walkie-talkies). Now we're ready to add advanced security systems (keycard access, surveillance cameras), sophisticated infrastructure (fiber optic networks, smart building systems), and professional-grade management tools (project management software, quality control systems).\n\nJust as a construction site evolves from meeting basic safety requirements to implementing enterprise-grade security and management systems, our container runtime can grow from providing fundamental isolation to offering production-ready security policies, advanced networking topologies, and sophisticated operational capabilities. Each enhancement builds upon the solid foundation we've established while adding specialized capabilities for different use cases.\n\nThe key insight is that these extensions don't replace our core components—they enhance and extend them. Our namespace isolation becomes the foundation for advanced security policies. Our basic networking becomes the substrate for complex multi-host topologies. Our simple resource management becomes the basis for sophisticated orchestration integration.\n\n### Current Foundation Assessment\n\nBefore exploring future extensions, it's important to understand what our current implementation provides and where natural extension points exist. Our container runtime has established four core capabilities that serve as extension foundations.\n\nOur namespace isolation component provides the fundamental security boundary that advanced security policies can build upon. The `NamespaceHandle` abstraction already supports user namespace UID/GID mapping, which becomes the foundation for capability management and privilege escalation prevention. The mount namespace isolation provides the filesystem access control foundation that security policies like AppArmor and SELinux can leverage.\n\nThe resource control component offers basic memory, CPU, and device limits through cgroups v2, but production environments often need more sophisticated resource policies. Our current `ResourceLimits` structure and `Controller` interfaces provide natural extension points for advanced resource management features like priority classes, quality of service guarantees, and dynamic resource allocation.\n\nOur network management component implements basic bridge networking with port forwarding, providing the foundation for advanced networking features. The `Manager` component's abstraction of network operations and the `ContainerNetwork` state tracking create natural integration points for Container Network Interface (CNI) plugins and multi-host networking solutions.\n\nThe container lifecycle management in our `RuntimeManager` provides orchestration integration points. The `ContainerSpec` and `ContainerState` data model can be extended to support additional metadata, labels, and configuration options that orchestration systems require.\n\n> **Design Insight**: Extension points should be designed into the original architecture, not bolted on afterwards. Our component-based architecture with clear interfaces makes it easier to add new capabilities without disrupting existing functionality.\n\n### Security Enhancements\n\nProduction container runtimes require multiple layers of security beyond basic namespace isolation. Advanced security features provide defense in depth, ensuring that even if one security boundary is compromised, additional protections remain in place.\n\n#### Mental Model: Multi-Layer Security Castle\n\nThink of container security like a medieval castle with multiple defensive layers. Our current namespace isolation is like the outer wall—it keeps most threats out, but sophisticated attackers might find ways over or through it. Advanced security features add additional defensive layers: the moat (seccomp filters blocking dangerous system calls), the gatehouse (capability management controlling what actions are allowed), and the inner keep (AppArmor/SELinux policies providing fine-grained access control).\n\nEach security layer operates independently but works together to provide comprehensive protection. If an attacker bypasses the namespace isolation (outer wall), they still face seccomp filters (moat) that prevent dangerous system calls. If they somehow execute restricted system calls, capability restrictions (gatehouse) limit what damage they can cause. Even if they gain elevated privileges, mandatory access control policies (inner keep) restrict what resources they can access.\n\n#### Seccomp Filter Integration\n\nSecure Computing Mode (seccomp) filters provide system call level security by restricting which kernel interfaces containerized processes can access. This addresses a fundamental limitation of namespace isolation—while namespaces control what resources a process can see, they don't restrict which system calls the process can make.\n\nOur current `NamespaceConfig` structure provides a natural extension point for seccomp integration. We can add seccomp profile configuration alongside existing namespace settings:\n\n| Extension Field | Type | Purpose |\n|---|---|---|\n| `SeccompProfile` | `string` | Path to seccomp BPF profile or predefined profile name |\n| `SeccompMode` | `SeccompMode` | Filter mode: disabled, strict, filter, or custom |\n| `AllowedSyscalls` | `[]string` | Explicit whitelist of permitted system calls |\n| `BlockedSyscalls` | `[]string` | Explicit blacklist of dangerous system calls |\n| `SeccompNotification` | `bool` | Enable seccomp user notification for advanced filtering |\n\nThe implementation would extend our namespace creation process to apply seccomp filters before executing the container process. The filter installation must happen after namespace creation but before the container process starts, ensuring the restrictions apply to the containerized process and its children.\n\nA sophisticated seccomp implementation would support multiple profile types. Default profiles provide reasonable security for common use cases—web servers, databases, batch jobs—while custom profiles allow fine-tuned control for specialized applications. Profile composition enables combining multiple partial profiles, such as a base container profile plus application-specific additions.\n\n> **Decision: Seccomp Profile Management Strategy**\n> - **Context**: Seccomp filters require careful balance between security and application compatibility\n> - **Options Considered**: \n>   - Hard-coded restrictive filters for maximum security\n>   - Fully permissive mode for maximum compatibility  \n>   - Configurable profiles with sensible defaults\n> - **Decision**: Configurable profiles with curated defaults for common application types\n> - **Rationale**: Provides security benefits while maintaining usability; defaults protect against common attack vectors while custom profiles enable specialized applications\n> - **Consequences**: Requires maintaining profile library and documentation; adds configuration complexity but provides flexible security model\n\n#### Capability Management System\n\nLinux capabilities provide fine-grained privilege control by breaking down root privileges into discrete capabilities that can be individually granted or restricted. Our container runtime can integrate capability management to implement the principle of least privilege.\n\nThe capability system would extend our `NamespaceConfig` with capability configuration:\n\n| Capability Field | Type | Purpose |\n|---|---|---|\n| `AllowedCapabilities` | `[]string` | Capabilities container processes can use |\n| `DroppedCapabilities` | `[]string` | Capabilities explicitly removed from container |\n| `AmbientCapabilities` | `[]string` | Capabilities inherited by child processes |\n| `BoundingSet` | `[]string` | Maximum capabilities container can ever acquire |\n| `NoNewPrivileges` | `bool` | Prevent privilege escalation via execve |\n\nThe implementation would manage capability sets during process creation, using the `cap_set_proc()` interface to configure process capabilities before executing the container command. This requires careful handling of capability inheritance and the interaction between user namespaces and capabilities.\n\nAdvanced capability management includes capability-aware process execution, ensuring that capabilities are properly dropped when switching to non-root users within the container. The system should also support capability audit logging, tracking when processes attempt to use specific capabilities for security monitoring.\n\n#### AppArmor and SELinux Integration\n\nMandatory Access Control (MAC) systems like AppArmor and SELinux provide policy-based security that restricts resource access regardless of traditional Unix permissions. Integration with these systems adds another security layer beyond namespace isolation and capability restrictions.\n\nMAC integration extends container configuration with policy specification:\n\n| MAC Field | Type | Purpose |\n|---|---|---|\n| `AppArmorProfile` | `string` | AppArmor profile name or path for container processes |\n| `SELinuxLabel` | `string` | SELinux security context for container processes |\n| `SELinuxType` | `string` | SELinux type enforcement domain |\n| `SELinuxUser` | `string` | SELinux user identity |\n| `SELinuxRole` | `string` | SELinux role for process context |\n| `MACEnforcement` | `MACMode` | MAC enforcement level: disabled, permissive, enforcing |\n\nThe implementation requires platform-specific integration with MAC systems. On AppArmor systems, this involves loading profiles and applying them to container processes using `aa_change_profile()`. On SELinux systems, it requires setting security contexts using `setexeccon()` before process execution.\n\nMAC policy management becomes a significant operational concern. The runtime should support policy loading, validation, and fallback mechanisms when specified policies are unavailable. Integration with policy development tools helps administrators create and maintain custom policies for containerized applications.\n\n> **Architecture Decision: MAC System Integration Strategy**\n> - **Context**: Different Linux distributions use different MAC systems (AppArmor on Ubuntu/SUSE, SELinux on RHEL/CentOS)\n> - **Options Considered**:\n>   - Support only one MAC system to reduce complexity\n>   - Runtime detection and automatic MAC system selection\n>   - Plugin-based architecture supporting multiple MAC systems\n> - **Decision**: Plugin-based MAC integration with runtime detection\n> - **Rationale**: Provides maximum compatibility across distributions; plugin architecture allows adding new MAC systems; runtime detection reduces configuration burden\n> - **Consequences**: Adds architectural complexity but enables broad deployment; requires maintaining multiple MAC integrations\n\n#### Security Policy Composition\n\nAdvanced security requires combining multiple security mechanisms into coherent policies. A security policy composition system would allow administrators to define security profiles that automatically configure seccomp filters, capabilities, and MAC policies together.\n\nSecurity profiles provide named collections of security settings:\n\n| Profile Component | Configuration Scope | Integration Point |\n|---|---|---|\n| Seccomp Rules | System call restrictions | Applied during process creation |\n| Capability Sets | Privilege limitations | Configured via capability management |\n| MAC Policies | Resource access control | Integrated with AppArmor/SELinux |\n| Namespace Options | Isolation boundaries | Extended namespace configuration |\n| Resource Quotas | Security-related limits | Enhanced resource control |\n\nProfile composition enables security policy inheritance and customization. Base profiles provide security foundations for broad categories (web applications, databases, batch processing), while override mechanisms allow application-specific customizations without duplicating common security settings.\n\nThe implementation would extend our `ContainerSpec` to reference security profiles:\n\n| Security Extension | Type | Purpose |\n|---|---|---|\n| `SecurityProfile` | `string` | Named security profile to apply |\n| `SecurityOverrides` | `SecurityConfig` | Specific overrides to profile defaults |\n| `SecurityAudit` | `bool` | Enable security event logging and monitoring |\n\n### Advanced Networking Features\n\nProduction container deployments require sophisticated networking capabilities beyond basic bridge networking. Advanced networking features enable complex topologies, multi-host communication, and integration with orchestration systems.\n\n#### Mental Model: Metropolitan Transportation Network\n\nThink of advanced container networking like evolving from a simple company shuttle system to a metropolitan transportation network. Our current bridge networking is like shuttle buses connecting different buildings on a campus—it works well for local communication but doesn't scale to citywide transportation needs.\n\nAdvanced networking features are like adding subway systems (overlay networks for multi-host communication), express highways (high-performance networking), traffic management systems (network policies and quality of service), and integrated payment systems (Container Network Interface compatibility for orchestration integration).\n\nEach networking enhancement serves different transportation needs while integrating with the overall network infrastructure. Multi-host networking provides the backbone for distributed communication, network policies manage traffic flow and security, and CNI integration enables interoperability with orchestration systems.\n\n#### Multi-Host Networking Implementation\n\nMulti-host networking enables containers running on different physical hosts to communicate as if they were on the same local network. This requires overlay networking technologies that encapsulate container traffic for transmission across the underlying network infrastructure.\n\nThe multi-host networking extension would add overlay network management to our `NetworkConfig`:\n\n| Multi-Host Field | Type | Purpose |\n|---|---|---|\n| `OverlayDriver` | `string` | Overlay network implementation: VXLAN, Geneve, IPSec |\n| `ClusterSubnet` | `string` | CIDR block for cross-host container networking |\n| `OverlayInterface` | `string` | Host interface for overlay network traffic |\n| `EncryptionEnabled` | `bool` | Enable overlay traffic encryption |\n| `MTUSize` | `int` | Maximum transmission unit for overlay packets |\n| `MulticastEnabled` | `bool` | Enable multicast for service discovery |\n\nVXLAN (Virtual Extensible LAN) provides the most common overlay implementation. It encapsulates layer-2 Ethernet frames within UDP packets, allowing container traffic to traverse layer-3 networks. The implementation requires creating VXLAN interfaces, configuring bridge forwarding tables, and managing overlay network membership.\n\nAdvanced overlay networking includes distributed route management, where each host maintains routing information for containers on other hosts. This can be implemented through static configuration, dynamic protocols like BGP, or integration with service discovery systems like etcd or Consul.\n\nNetwork address translation becomes more complex in multi-host environments. East-west traffic (container-to-container across hosts) uses overlay routing, while north-south traffic (external-to-container) requires careful NAT rule coordination to avoid conflicts between hosts.\n\n#### Container Network Interface (CNI) Integration\n\nContainer Network Interface (CNI) provides a standardized plugin architecture for container networking, enabling integration with Kubernetes and other orchestration systems. CNI integration transforms our container runtime from a standalone system into an orchestration-compatible component.\n\nCNI integration extends our network management with plugin support:\n\n| CNI Extension | Type | Purpose |\n|---|---|---|\n| `CNIConfigPath` | `string` | Directory containing CNI plugin configurations |\n| `CNIPluginPath` | `string` | Directory containing CNI plugin binaries |\n| `CNINetworkName` | `string` | Default network configuration to use |\n| `CNICacheDir` | `string` | Directory for CNI plugin state and caching |\n| `CNIArgs` | `map[string]string` | Additional arguments passed to CNI plugins |\n\nThe implementation replaces our direct network management with CNI plugin execution. Instead of creating veth pairs and bridge configurations directly, the runtime executes CNI plugins that handle network setup according to standardized interfaces.\n\nCNI plugin lifecycle follows the ADD/DEL pattern. During container creation, the runtime calls the CNI plugin ADD command with container information and network configuration. The plugin creates network interfaces, assigns IP addresses, and configures routing according to its implementation. During container removal, the DEL command cleans up network resources.\n\nAdvanced CNI integration supports plugin chaining, where multiple CNI plugins collaborate to provide complete networking functionality. For example, a bridge plugin creates basic connectivity while a firewall plugin adds security rules and a monitoring plugin adds traffic statistics.\n\n> **Decision: CNI Integration Strategy**\n> - **Context**: CNI provides standardized networking but adds complexity compared to direct implementation\n> - **Options Considered**:\n>   - Replace all networking with CNI plugins\n>   - Support CNI as optional alternative to built-in networking\n>   - Implement CNI-compatible plugins wrapping our existing networking\n> - **Decision**: Support CNI as configurable alternative with built-in networking as fallback\n> - **Rationale**: Provides orchestration compatibility while maintaining simplicity for standalone use; CNI plugins handle complex networking scenarios our built-in implementation can't support\n> - **Consequences**: Increases testing complexity but enables Kubernetes integration; requires maintaining both networking paths\n\n#### Network Policy Enforcement\n\nNetwork policies provide declarative security and traffic management for container networking. They define which containers can communicate with each other and what external resources containers can access.\n\nNetwork policy implementation extends our networking with policy specification:\n\n| Policy Component | Type | Purpose |\n|---|---|---|\n| `NetworkPolicies` | `[]NetworkPolicy` | List of policies applied to container |\n| `DefaultPolicy` | `PolicyAction` | Default action for non-matching traffic |\n| `PolicyEnforcement` | `EnforcementMode` | Policy enforcement level |\n\nNetwork policy enforcement requires integration with traffic filtering mechanisms. On Linux systems, this typically means generating iptables rules that implement policy decisions. Advanced implementations use eBPF programs for high-performance packet filtering.\n\nPolicy evaluation becomes complex with multiple policies applying to the same container. The implementation needs conflict resolution mechanisms, policy precedence rules, and efficient policy lookup algorithms for high-throughput environments.\n\n#### Quality of Service and Traffic Shaping\n\nAdvanced networking includes Quality of Service (QoS) mechanisms that prioritize traffic and manage bandwidth allocation. This ensures critical container communications receive necessary network resources even under load.\n\nQoS implementation adds traffic management to container networking:\n\n| QoS Component | Type | Purpose |\n|---|---|---|\n| `BandwidthLimits` | `BandwidthConfig` | Maximum bandwidth for container traffic |\n| `TrafficPriority` | `PriorityClass` | Traffic prioritization level |\n| `QueueDiscipline` | `string` | Linux traffic control queuing discipline |\n| `RateShaping` | `RateConfig` | Traffic shaping parameters |\n\nImplementation uses Linux traffic control (tc) subsystem to configure queuing disciplines, traffic classes, and rate limiting. This requires understanding of network queuing theory and careful configuration to avoid unintended traffic delays.\n\nAdvanced QoS features include adaptive bandwidth allocation, where containers can burst above their guaranteed bandwidth when network capacity is available, and priority-based preemption, where high-priority traffic can temporarily reduce bandwidth available to lower-priority flows.\n\n### Image Management and Distribution\n\nProduction container runtimes require sophisticated image management capabilities beyond the basic layer handling we implemented. Image management encompasses image distribution, storage optimization, security scanning, and metadata management.\n\n#### Mental Model: Digital Library System\n\nThink of advanced image management like evolving from a personal book collection to managing a digital library system. Our current layer management is like having books on shelves—you can find and use them, but there's no catalog system, no way to share with other libraries, and no way to verify book authenticity.\n\nAdvanced image management adds library infrastructure: catalog systems (image registries with metadata), interlibrary loans (image distribution and sharing), authentication systems (image signing and verification), and storage optimization (deduplication and compression).\n\n#### Container Image Registry Integration\n\nImage registry integration enables pulling container images from remote repositories, supporting image distribution workflows common in production environments. This extends our runtime beyond locally available layers to support dynamic image retrieval.\n\nRegistry integration extends our `ContainerSpec` with remote image support:\n\n| Registry Field | Type | Purpose |\n|---|---|---|\n| `ImageRegistry` | `string` | Registry URL for image retrieval |\n| `ImageCredentials` | `RegistryCredentials` | Authentication for private registries |\n| `ImageTag` | `string` | Specific image version or tag |\n| `ImageDigest` | `string` | Content-addressable image identifier |\n| `PullPolicy` | `PullPolicy` | When to pull images: Always, IfNotPresent, Never |\n\nImplementation requires supporting Docker Registry HTTP API V2 for image manifest retrieval and layer downloading. This includes handling authentication, layer deduplication, and resumable downloads for large images.\n\nAdvanced registry integration includes image mirroring and caching, where frequently used images are cached locally to reduce registry load and improve startup times. Multi-registry support enables fallback between primary and mirror registries for high availability.\n\n#### Image Security and Verification\n\nImage security addresses supply chain security by verifying image authenticity and scanning for vulnerabilities. This becomes critical in production environments where compromised images pose significant security risks.\n\nImage security extends our image handling with verification:\n\n| Security Component | Type | Purpose |\n|---|---|---|\n| `ImageSigning` | `SigningConfig` | Image signature verification settings |\n| `VulnerabilityScanning` | `ScanConfig` | Security vulnerability detection |\n| `PolicyEnforcement` | `SecurityPolicy` | Image acceptance policies |\n| `TrustedRegistries` | `[]string` | Whitelist of trusted image sources |\n\nImplementation integrates with image signing systems like Notary or cosign for cryptographic verification of image authenticity. Vulnerability scanning requires integration with security databases and scanning tools to identify known vulnerabilities in image contents.\n\nPolicy enforcement enables organizations to define acceptance criteria for container images, automatically rejecting images that don't meet security requirements. This includes vulnerability thresholds, signature requirements, and source registry restrictions.\n\n### Orchestration Integration\n\nProduction container runtimes increasingly operate as components within larger orchestration systems. Orchestration integration enables our runtime to participate in cluster management, service discovery, and automated deployment workflows.\n\n#### Mental Model: Orchestra Conductor System\n\nThink of orchestration integration like enabling a talented musician to play as part of a symphony orchestra. Our container runtime is like a skilled instrumentalist who can perform solo pieces beautifully, but orchestration integration adds the ability to follow a conductor, coordinate with other musicians, and contribute to complex symphonic performances.\n\nThe runtime learns to respond to orchestration signals (start this container when that service is ready), participate in ensemble coordination (register service endpoints for load balancing), and adapt to the conductor's tempo (scale up during high demand, scale down during quiet periods).\n\n#### Kubernetes Container Runtime Interface (CRI)\n\nContainer Runtime Interface provides the standard interface between Kubernetes and container runtimes. CRI integration transforms our runtime into a Kubernetes-compatible component that can manage pods and containers under kubelet orchestration.\n\nCRI implementation requires implementing the RuntimeService and ImageService gRPC interfaces:\n\n| CRI Service | Key Methods | Purpose |\n|---|---|---|\n| `RuntimeService` | `RunPodSandbox`, `CreateContainer`, `StartContainer` | Pod and container lifecycle |\n| `ImageService` | `PullImage`, `ListImages`, `RemoveImage` | Image management operations |\n| `StreamingService` | `Exec`, `Attach`, `PortForward` | Interactive container operations |\n\nImplementation challenges include adapting our single-container model to Kubernetes' pod abstraction, where multiple containers share network and storage namespaces. This requires extending our namespace management to support shared namespaces between related containers.\n\nCRI integration also requires implementing Kubernetes-specific features like pod security contexts, resource quotas, and liveness/readiness probes. These extend our basic container capabilities with orchestration-aware functionality.\n\n#### Service Mesh Integration\n\nService mesh architectures require container runtimes to support sidecar injection, traffic interception, and service identity management. Integration enables our runtime to participate in sophisticated microservices architectures.\n\nService mesh support extends container networking with mesh capabilities:\n\n| Mesh Component | Type | Purpose |\n|---|---|---|\n| `SidecarInjection` | `bool` | Automatic sidecar proxy injection |\n| `TrafficInterception` | `InterceptConfig` | Traffic redirection configuration |\n| `ServiceIdentity` | `IdentityConfig` | Service authentication and authorization |\n| `MeshConfiguration` | `MeshConfig` | Service mesh integration settings |\n\nImplementation requires coordinating with service mesh control planes for configuration distribution and telemetry collection. This includes supporting init containers for traffic redirection setup and managing certificate distribution for mutual TLS authentication.\n\n### Storage and Volume Management\n\nAdvanced storage features extend our basic filesystem layering with persistent volumes, dynamic provisioning, and storage optimization capabilities.\n\n#### Persistent Volume Integration\n\nPersistent volumes enable containers to access storage that survives container lifecycle events. This requires extending our filesystem management beyond container-scoped overlay filesystems.\n\nVolume integration extends `ContainerSpec` with storage specification:\n\n| Volume Field | Type | Purpose |\n|---|---|---|\n| `Volumes` | `[]VolumeMount` | List of volumes to mount in container |\n| `VolumeDrivers` | `map[string]VolumeDriver` | Storage driver implementations |\n| `StorageClasses` | `[]StorageClass` | Available storage types and policies |\n\nImplementation requires supporting multiple volume types: host path mounts for simple local storage, network file systems for shared storage, and cloud provider storage APIs for dynamic provisioning.\n\n#### Storage Optimization\n\nStorage optimization includes features like image layer deduplication, compression, and content-addressable storage that reduce storage overhead and improve performance.\n\nAdvanced storage features include snapshot support for volume backup and restoration, encryption for sensitive data protection, and storage quotas for multi-tenant environments.\n\n### Common Pitfalls in Advanced Extensions\n\n⚠️ **Pitfall: Feature Creep Without Architecture Planning**\nAdding advanced features without considering their architectural impact leads to tightly coupled, difficult-to-maintain systems. Each extension should have clear interfaces and minimal dependencies on other components. Plan extension points during initial design rather than retrofitting them later.\n\n⚠️ **Pitfall: Security Feature Interference** \nMultiple security mechanisms can interfere with each other if not carefully coordinated. Seccomp filters might block system calls that AppArmor policies expect to audit. User namespace UID mapping might conflict with capability management. Design security feature integration holistically rather than adding each mechanism independently.\n\n⚠️ **Pitfall: CNI Plugin Compatibility Assumptions**\nAssuming all CNI plugins behave consistently leads to runtime errors in diverse environments. Different CNI plugins have different requirements for network namespace setup, interface naming, and cleanup behavior. Test with multiple CNI plugins and handle plugin-specific quirks gracefully.\n\n⚠️ **Pitfall: Performance Impact of Advanced Features**\nAdvanced features often add performance overhead that may not be acceptable in all environments. Image scanning delays container startup. Network policies add packet processing overhead. QoS traffic shaping adds latency. Make advanced features configurable and provide performance monitoring to quantify their impact.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Seccomp Integration | Static JSON profiles | eBPF-based dynamic filtering |\n| MAC System Support | Single system (AppArmor or SELinux) | Runtime detection with plugin architecture |\n| CNI Implementation | Execute CNI binaries directly | CNI library integration with caching |\n| Image Registry | HTTP client with basic auth | Full OCI distribution spec support |\n| Orchestration | Simple webhook API | Full CRI gRPC implementation |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  internal/extensions/\n    security/\n      seccomp/\n        profiles.go         ← seccomp profile management\n        filters.go          ← BPF filter installation\n      capabilities/\n        manager.go          ← capability set management\n      mac/\n        apparmor.go         ← AppArmor integration\n        selinux.go          ← SELinux integration\n        interface.go        ← MAC system abstraction\n    networking/\n      cni/\n        plugin_manager.go   ← CNI plugin execution\n        config_parser.go    ← CNI configuration handling\n      overlay/\n        vxlan.go           ← VXLAN overlay implementation\n        routing.go         ← Overlay route management\n      policy/\n        enforcer.go        ← Network policy enforcement\n        iptables.go        ← iptables rule management\n    storage/\n      registry/\n        client.go          ← Registry API client\n        auth.go            ← Registry authentication\n      volumes/\n        manager.go         ← Volume lifecycle management\n        drivers/\n          hostpath.go      ← Host path volume driver\n          nfs.go           ← NFS volume driver\n    orchestration/\n      cri/\n        runtime_service.go ← CRI RuntimeService implementation\n        image_service.go   ← CRI ImageService implementation\n      mesh/\n        sidecar.go         ← Service mesh sidecar management\n```\n\n#### Security Extension Starter Code\n\n```go\n// Package security provides advanced security features for container runtime\npackage security\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"syscall\"\n    \"unsafe\"\n)\n\n// SecurityManager coordinates multiple security mechanisms\ntype SecurityManager struct {\n    seccompEnabled    bool\n    capabilityEnabled bool\n    macEnabled        bool\n    profiles         map[string]*SecurityProfile\n}\n\n// SecurityProfile defines a complete security configuration\ntype SecurityProfile struct {\n    Name               string\n    SeccompProfile     string\n    AllowedCapabilities []string\n    DroppedCapabilities []string\n    AppArmorProfile    string\n    SELinuxLabel       string\n}\n\n// NewSecurityManager creates a security manager with system detection\nfunc NewSecurityManager() (*SecurityManager, error) {\n    return &SecurityManager{\n        seccompEnabled:    detectSeccompSupport(),\n        capabilityEnabled: detectCapabilitySupport(),\n        macEnabled:       detectMACSupport(),\n        profiles:         make(map[string]*SecurityProfile),\n    }, nil\n}\n\n// ApplySecurityProfile applies all security mechanisms from profile\nfunc (sm *SecurityManager) ApplySecurityProfile(ctx context.Context, containerID string, profile *SecurityProfile) error {\n    // TODO 1: Validate security profile completeness and compatibility\n    // TODO 2: Apply seccomp filters using prctl(PR_SET_SECCOMP) if enabled\n    // TODO 3: Configure process capabilities using cap_set_proc if enabled  \n    // TODO 4: Set MAC security context (AppArmor or SELinux) if enabled\n    // TODO 5: Enable no_new_privs to prevent privilege escalation\n    // TODO 6: Record applied security settings for audit and debugging\n    return fmt.Errorf(\"not implemented\")\n}\n\n// SeccompFilterManager handles seccomp BPF filter installation\ntype SeccompFilterManager struct {\n    profileDir string\n}\n\n// InstallSeccompFilter loads and installs BPF seccomp filter\nfunc (sfm *SeccompFilterManager) InstallSeccompFilter(profilePath string) error {\n    // TODO 1: Load seccomp profile from JSON file\n    // TODO 2: Compile syscall names to architecture-specific numbers\n    // TODO 3: Generate BPF program from syscall allow/deny rules\n    // TODO 4: Install BPF filter using prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER)\n    // TODO 5: Verify filter installation and test with sample syscalls\n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n#### CNI Integration Starter Code\n\n```go\n// Package cni provides Container Network Interface integration\npackage cni\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"os/exec\"\n    \"path/filepath\"\n)\n\n// CNIManager handles CNI plugin execution and state management  \ntype CNIManager struct {\n    configPath  string\n    pluginPath  string\n    cacheDir    string\n    networks    map[string]*CNIConfig\n}\n\n// CNIConfig represents a CNI network configuration\ntype CNIConfig struct {\n    CNIVersion string                 `json:\"cniVersion\"`\n    Name       string                 `json:\"name\"`\n    Type       string                 `json:\"type\"`\n    Bridge     map[string]interface{} `json:\"bridge,omitempty\"`\n    IPAM       map[string]interface{} `json:\"ipam,omitempty\"`\n    DNS        map[string]interface{} `json:\"dns,omitempty\"`\n}\n\n// CNIResult represents the result of CNI plugin execution\ntype CNIResult struct {\n    CNIVersion string      `json:\"cniVersion\"`\n    Interfaces []Interface `json:\"interfaces\"`\n    IPs        []IPConfig  `json:\"ips\"`\n    Routes     []Route     `json:\"routes\"`\n    DNS        DNSConfig   `json:\"dns\"`\n}\n\n// NewCNIManager creates CNI manager with configuration discovery\nfunc NewCNIManager(configPath, pluginPath, cacheDir string) (*CNIManager, error) {\n    return &CNIManager{\n        configPath: configPath,\n        pluginPath: pluginPath, \n        cacheDir:   cacheDir,\n        networks:   make(map[string]*CNIConfig),\n    }, nil\n}\n\n// SetupContainerNetwork executes CNI ADD command for container\nfunc (cm *CNIManager) SetupContainerNetwork(ctx context.Context, containerID, networkName string, netnsPath string) (*CNIResult, error) {\n    // TODO 1: Load CNI configuration from configPath directory\n    // TODO 2: Find CNI plugin binary in pluginPath directory  \n    // TODO 3: Prepare CNI environment variables (CNI_COMMAND=ADD, CNI_CONTAINERID, etc.)\n    // TODO 4: Execute CNI plugin with configuration JSON on stdin\n    // TODO 5: Parse CNI result JSON from plugin stdout\n    // TODO 6: Cache network state in cacheDir for cleanup\n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// CleanupContainerNetwork executes CNI DEL command for container\nfunc (cm *CNIManager) CleanupContainerNetwork(ctx context.Context, containerID, networkName string) error {\n    // TODO 1: Load cached network state from cacheDir\n    // TODO 2: Prepare CNI environment variables (CNI_COMMAND=DEL)\n    // TODO 3: Execute CNI plugin DEL command with original configuration\n    // TODO 4: Remove cached network state from cacheDir\n    // TODO 5: Handle plugin errors gracefully (plugin may be missing)\n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Orchestration Integration Core Types\n\n```go\n// Package orchestration provides integration with container orchestration systems\npackage orchestration\n\nimport (\n    \"context\"\n    \"time\"\n    \"google.golang.org/grpc\"\n    pb \"k8s.io/cri-api/pkg/apis/runtime/v1alpha2\"\n)\n\n// CRIRuntimeService implements Kubernetes Container Runtime Interface\ntype CRIRuntimeService struct {\n    pb.UnimplementedRuntimeServiceServer\n    containerManager *ContainerManager\n    podManager      *PodManager  \n    imageManager    *ImageManager\n}\n\n// PodSandboxConfig extends our container model for Kubernetes pods\ntype PodSandboxConfig struct {\n    PodID         string\n    Name          string\n    Namespace     string\n    SharedNetNS   bool\n    SharedIPCNS   bool\n    SharedPIDNS   bool\n    Annotations   map[string]string\n    Labels        map[string]string\n}\n\n// RunPodSandbox creates the pod infrastructure container\nfunc (cri *CRIRuntimeService) RunPodSandbox(ctx context.Context, req *pb.RunPodSandboxRequest) (*pb.RunPodSandboxResponse, error) {\n    // TODO 1: Parse pod sandbox configuration from request\n    // TODO 2: Create shared namespaces for pod (network, IPC, PID if configured)\n    // TODO 3: Set up pod-level networking using CNI or built-in networking\n    // TODO 4: Create pod sandbox container to hold namespaces  \n    // TODO 5: Apply pod-level security policies and resource limits\n    // TODO 6: Register pod sandbox in pod manager state\n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// CreateContainer creates container within existing pod sandbox\nfunc (cri *CRIRuntimeService) CreateContainer(ctx context.Context, req *pb.CreateContainerRequest) (*pb.CreateContainerResponse, error) {\n    // TODO 1: Validate pod sandbox exists and is running\n    // TODO 2: Join container to pod's shared namespaces\n    // TODO 3: Apply container-specific resource limits and security policies\n    // TODO 4: Set up container filesystem with image layers\n    // TODO 5: Create container using our existing container creation logic\n    // TODO 6: Register container in CRI state tracking\n    return nil, fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Milestone Checkpoints for Extensions\n\n**Security Enhancement Checkpoint:**\n- Test seccomp filter installation: `sudo strace -e trace=prctl ./container-runtime run --seccomp=restrictive test-container`\n- Verify capability dropping: Container should fail to execute `ping` with network capabilities dropped\n- Check MAC policy application: `ps -eZ | grep container-process` should show correct SELinux context\n\n**CNI Integration Checkpoint:**  \n- Install basic CNI plugins: `bridge` and `host-local` IPAM\n- Test CNI network setup: `./container-runtime run --network=cni test-container` \n- Verify connectivity: Container should get IP from CNI IPAM and reach other containers\n\n**Advanced Networking Checkpoint:**\n- Set up multi-host overlay: Deploy containers on different hosts, verify cross-host connectivity\n- Test network policies: Create policy blocking container communication, verify enforcement\n- Validate QoS: Apply bandwidth limits, verify traffic shaping with `iperf3`\n\n#### Extension Debugging Tips\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---|---|---|---|\n| Seccomp filter blocks required syscalls | Overly restrictive profile | `strace` container process, check for `EPERM` errors | Add required syscalls to profile whitelist |\n| CNI plugin execution fails | Missing plugin binary or configuration | Check plugin exists in CNI_PATH, validate config JSON | Install plugin, fix configuration syntax |\n| Container can't join pod network | Pod sandbox networking setup failed | Check pod sandbox status, inspect network namespaces | Debug CNI plugin execution, check bridge config |\n| MAC policy denials | Incorrect security context | Check `ausearch -m AVC` for SELinux denials | Update security policy or container context |\n| Multi-host networking broken | Overlay network misconfiguration | Check VXLAN interface status, validate routing | Verify overlay network setup, check firewall rules |\n\nThese extensions transform our educational container runtime into a production-capable system while maintaining the clean architecture and clear component boundaries we established in the core implementation.\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (1-4) - This glossary provides comprehensive definitions for container runtime terminology, Linux kernel concepts, and system administration terms used throughout all sections, helping readers understand the technical vocabulary essential for implementing process isolation, resource control, filesystem layering, and container networking.\n\nThis glossary serves as a comprehensive reference for all technical terms, concepts, and terminology used throughout the container runtime design document. Understanding these definitions is crucial for successfully implementing the four milestones of our container runtime project.\n\n### Mental Model: Technical Dictionary as Navigation Map\n\nThink of this glossary as a navigation map for exploring a new technical territory. Just as a map helps you understand the landscape by defining landmarks, terrain features, and pathways, this glossary defines the technical landmarks (Linux kernel features), terrain features (system resources and isolation mechanisms), and pathways (APIs and interfaces) you'll encounter while building your container runtime. Each definition provides not just the meaning, but the context of how that concept fits into the larger ecosystem of containerization technology.\n\n### Container Runtime Core Concepts\n\nThe foundation of container technology rests on several key concepts that work together to create isolated execution environments.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| container runtime | System Component | A system that manages the complete lifecycle of containers, including creation, execution, monitoring, and cleanup. Responsible for orchestrating Linux kernel features like namespaces, cgroups, and overlay filesystems to provide process isolation and resource control. Examples include Docker Engine, containerd, and our custom implementation. |\n| container specification | Data Structure | A declarative blueprint defining how a container should be configured, including the image to run, resource limits, network settings, environment variables, and command to execute. Represented by the `ContainerSpec` structure with fields for image, command, resources, and networking configuration. |\n| runtime state | Data Structure | The current operational status and resource tracking information for an active container. Includes process ID, namespace handles, cgroup paths, network configuration, and lifecycle timestamps. Maintained by the `StateManager` component for persistence across runtime restarts. |\n| container lifecycle | State Machine | The progression of a container through distinct states: Created (resources allocated but process not started), Running (process executing), Stopped (process terminated but resources preserved), and Removed (all resources cleaned up). Each transition involves specific setup or cleanup operations. |\n| process isolation | Isolation Mechanism | The fundamental container property where processes inside a container have a restricted view of system resources, seeing only what they're permitted to access. Achieved through Linux namespaces that create separate views of PIDs, filesystems, network interfaces, and other system resources. |\n| resource limits | Control Mechanism | Constraints enforced by the Linux kernel to prevent containers from consuming unlimited system resources. Implemented using cgroups to limit memory, CPU time, I/O bandwidth, and process count. Essential for multi-tenant systems and preventing resource exhaustion. |\n\n### Linux Kernel Features\n\nOur container runtime builds upon several advanced Linux kernel features that provide the foundation for containerization.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| namespace | Kernel Feature | A Linux kernel feature that provides process isolation by creating separate instances of global system resources. Each namespace type isolates a different category of resources (PIDs, filesystems, network interfaces, hostnames, users). Processes in different namespaces see different views of the same system. |\n| cgroup | Kernel Feature | A Linux control group mechanism for organizing processes into hierarchical groups and applying resource limits and accounting. Cgroups v2 provides a unified hierarchy with controllers for memory, CPU, I/O, and device access. Essential for preventing containers from monopolizing system resources. |\n| overlayfs | Filesystem Type | A union filesystem implementation in the Linux kernel that efficiently combines multiple directory trees into a single merged view. Supports copy-on-write semantics where changes to files are stored in an upper layer without modifying lower layers. Foundation for container image layering. |\n| pivot_root | System Call | A Linux system call that atomically changes the root filesystem of a process and its children. More secure than `chroot` because it ensures the old root is unmounted. Used during container startup to switch from the host filesystem to the container's filesystem view. |\n| netlink | Kernel Interface | A socket-based communication mechanism between the Linux kernel and userspace processes. Used for network configuration operations like creating network interfaces, configuring routes, and managing network namespaces. Provides programmatic access to networking functionality. |\n\n### Namespace Types and Isolation\n\nEach namespace type provides isolation for a specific category of system resources, creating the illusion of dedicated resources for each container.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| mount namespace | Namespace Type | Isolates the filesystem mount points visible to processes, allowing each container to have its own filesystem hierarchy and mount configuration. Created with `CLONE_NEWNS` flag. Enables containers to have different root filesystems and mount different volumes without affecting the host. |\n| PID namespace | Namespace Type | Isolates the process ID number space, making processes in the namespace see only other processes in the same namespace. The first process in a PID namespace appears as PID 1. Created with `CLONE_NEWPID` flag. Provides process isolation and enables clean process tree management. |\n| network namespace | Namespace Type | Isolates network interfaces, routing tables, firewall rules, and network statistics. Each network namespace has its own loopback interface and can have its own network interfaces. Created with `CLONE_NEWNET` flag. Enables containers to have isolated network stacks. |\n| UTS namespace | Namespace Type | Isolates the system hostname and NIS domain name, allowing each container to have its own hostname without affecting the host system. Created with `CLONE_NEWUTS` flag. Enables containers to identify themselves with unique hostnames. |\n| user namespace | Namespace Type | Isolates user and group ID number spaces and privileges, allowing processes to have different user IDs inside the namespace than outside. Enables unprivileged containers where root inside the container maps to a non-root user outside. Created with `CLONE_NEWUSER` flag. |\n| IPC namespace | Namespace Type | Isolates System V IPC objects (message queues, semaphores, shared memory segments) and POSIX message queues. Prevents containers from interfering with each other's inter-process communication. Created with `CLONE_NEWIPC` flag. |\n\n### Cgroup Resource Control\n\nCgroups provide hierarchical resource management and accounting, essential for fair resource allocation in multi-container environments.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| cgroups v2 | Cgroup Version | The modern unified hierarchy implementation of control groups, replacing the multiple separate hierarchies of cgroups v1. Provides a single tree structure with controllers that can be selectively enabled. Offers improved consistency and easier management for container runtimes. |\n| memory controller | Cgroup Controller | A cgroup subsystem that manages memory allocation, usage tracking, and enforcement of memory limits. Can limit anonymous memory, page cache, and total memory usage. Provides memory pressure notifications and configurable out-of-memory behavior for fine-grained memory management. |\n| CPU controller | Cgroup Controller | A cgroup subsystem that manages CPU time allocation through quotas and weights. Can limit CPU usage to specific percentages and implement fair scheduling policies. Provides both hard limits (quotas) and proportional sharing (weights) for flexible CPU resource management. |\n| device controller | Cgroup Controller | A cgroup subsystem that controls access to device files, determining which devices processes can access and with what permissions (read, write, create). Essential for container security by preventing unauthorized access to host devices. |\n| OOM killer | Kernel Mechanism | The Linux kernel's out-of-memory killer that terminates processes when memory is exhausted. In containerized environments, can be configured per-cgroup to kill only processes within the offending container rather than affecting the entire system. Critical for system stability under memory pressure. |\n| memory pressure | Resource Condition | A condition where memory usage approaches configured limits, potentially leading to performance degradation or out-of-memory conditions. Cgroups provide pressure stall information (PSI) metrics to detect memory pressure before critical situations occur. |\n| CPU throttling | Resource Control | The process of limiting CPU time allocation when a cgroup exceeds its configured CPU quota. Implemented by the kernel scheduler to enforce CPU limits while maintaining fairness. Can cause performance degradation if limits are set too restrictively. |\n| resource monitoring | Monitoring Process | The continuous tracking of container resource consumption over time, including memory usage, CPU utilization, I/O operations, and process counts. Enables resource trend analysis, capacity planning, and automated scaling decisions based on historical usage patterns. |\n| cgroup hierarchy | Organizational Structure | The tree structure organizing control groups, where child cgroups inherit resource limits from parents and can apply additional restrictions. Enables hierarchical resource management where system resources are allocated first to major subsystems, then subdivided for individual containers. |\n\n### Filesystem and Storage Concepts\n\nContainer filesystems use sophisticated layering and copy-on-write mechanisms to efficiently share common data while allowing independent modifications.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| copy-on-write | Filesystem Optimization | A storage optimization technique where multiple containers can share the same base files until one container modifies a file, at which point a private copy is created. Reduces storage usage and improves startup time by avoiding unnecessary file duplication. |\n| layer stacking | Filesystem Architecture | The technique of combining multiple read-only filesystem layers with a single writable layer to create a complete filesystem view. Lower layers contain base system files and application dependencies, while the upper layer captures container-specific changes. |\n| whiteout files | Filesystem Mechanism | Special marker files in overlayfs that indicate deleted files in lower layers. When a file is deleted in the upper layer, a whiteout file is created to mask the file's presence in lower layers. Essential for proper deletion semantics in layered filesystems. |\n| upper directory | Filesystem Layer | The writable layer in an overlay filesystem where all container modifications are stored. Contains new files created by the container and modified versions of files from lower layers. Typically unique per container to ensure isolation. |\n| lower directories | Filesystem Layers | The read-only layers in an overlay filesystem that contain base image content. Multiple lower directories are stacked to create the base filesystem view. Shared between containers using the same base image to minimize storage usage. |\n| work directory | Filesystem Component | A scratch directory used internally by overlayfs for atomic operations during copy-on-write. Must be on the same filesystem as the upper directory and should be empty when mounting. Hidden from container processes but essential for overlay functionality. |\n| merged view | Filesystem Abstraction | The combined filesystem view presented to container processes, showing the result of merging all lower directories with the upper directory. Files in upper layers hide files with the same path in lower layers, creating the illusion of a single unified filesystem. |\n| layer cleanup | Maintenance Process | The process of removing unused filesystem layers and directories when containers are destroyed. Includes unmounting overlay filesystems, removing temporary directories, and updating reference counts for shared layers to prevent storage leaks. |\n\n### Container Networking\n\nContainer networking creates isolated network environments while enabling communication between containers and external systems.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| veth pair | Network Interface | A virtual ethernet pair consisting of two connected network interfaces that act like opposite ends of a network cable. Traffic sent to one interface is received by the other. Used to connect container network namespaces to host network namespaces or bridges. |\n| bridge networking | Network Architecture | A layer-2 switching mechanism that connects multiple network interfaces, allowing containers to communicate with each other and external networks. Linux bridges forward traffic between connected interfaces based on MAC addresses, similar to physical network switches. |\n| port forwarding | Network Translation | The process of redirecting network traffic from host ports to container ports using network address translation (NAT) rules. Enables external clients to access services running inside containers by mapping host IP:port combinations to container IP:port combinations. |\n| port mapping | Configuration Specification | A configuration that defines how host ports should be forwarded to container ports, specified by the `PortMapping` structure with host port, container port, and protocol. Essential for making container services accessible from outside the container network. |\n| DNAT | Network Translation | Destination Network Address Translation - a type of NAT that modifies the destination IP address and/or port of packets. Used in container port forwarding to redirect traffic from host interfaces to container interfaces. |\n| container bridge | Network Infrastructure | A virtual network switch that connects container network interfaces, typically named `docker0` or similar. Provides layer-2 connectivity between containers and can be connected to host interfaces for external access. Central component of container networking architecture. |\n| IP address pool | Address Management | A managed range of IP addresses allocated for container use, typically from private address space (e.g., 172.17.0.0/16). The container runtime assigns unique addresses from this pool to prevent IP conflicts and enable proper routing. |\n| NAT rules | Network Configuration | Network address translation rules configured in the Linux netfilter framework (iptables) to modify packet headers for container networking. Includes DNAT rules for inbound traffic and SNAT rules for outbound traffic from containers. |\n\n### Container Lifecycle and Operations\n\nContainer operations follow specific patterns and sequences to ensure reliable resource management and cleanup.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| graceful termination | Shutdown Process | The process of allowing a container process to shut down cleanly by sending SIGTERM and waiting for the process to exit voluntarily before forcing termination. Gives applications time to save state, close connections, and perform cleanup operations. |\n| forced removal | Cleanup Process | Aggressive container cleanup that bypasses graceful shutdown and immediately removes all container resources. Used when graceful termination fails or times out. May result in data loss or resource leaks if not implemented carefully. |\n| resource handle | Abstraction | A data structure that encapsulates references to created resources (namespaces, cgroups, network interfaces) and provides methods for cleanup. Enables proper resource management and prevents resource leaks when containers are removed. |\n| operation log | Persistence Mechanism | A persistent record of multi-step container operations that tracks which steps have completed successfully. Enables recovery and rollback if operations are interrupted by crashes or failures. Essential for maintaining consistent state across runtime restarts. |\n| rollback mechanism | Error Recovery | The process of cleaning up successfully created resources when a container operation fails partway through. Ensures the system remains in a consistent state and prevents resource leaks when container creation or modification fails. |\n| component coordination | Orchestration Pattern | The process of organizing multiple specialized components (namespace handler, cgroup controller, filesystem manager, network manager) to work together during container operations. Manages dependencies and ensures operations occur in the correct order. |\n| dependency graph | Operational Structure | The ordering requirements between component operations, such as creating network namespaces before configuring network interfaces. Represents which operations must complete before others can begin, enabling parallel execution where possible. |\n| atomic operations | Operation Property | Operations that either complete entirely or have no effect, preventing partial state that could lead to resource leaks or inconsistencies. Critical for container operations that involve multiple kernel resources requiring coordinated setup. |\n| idempotent cleanup | Cleanup Property | Cleanup operations that can be safely repeated multiple times without causing errors or side effects. Essential for reliable resource cleanup in the presence of failures, crashes, or redundant cleanup attempts. |\n\n### Error Handling and Recovery\n\nRobust container runtimes must handle various failure modes and provide mechanisms for detection and recovery.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| partial failure recovery | Error Recovery | The process of handling cases where container creation partially succeeds but some components fail, requiring cleanup of successfully created resources while leaving the system in a consistent state. Prevents resource leaks and orphaned kernel objects. |\n| resource exhaustion scenarios | Failure Mode | Situations where system resources (PIDs, memory, network interfaces, file descriptors) approach or exceed their limits, potentially causing container operations to fail. Requires detection, graceful degradation, and recovery strategies. |\n| graceful degradation | Resilience Pattern | The strategy of reducing functionality when resources are constrained rather than failing completely. For example, reducing container resource limits or disabling non-essential features when system resources are scarce. |\n| circuit breaker | Resilience Pattern | A pattern that prevents retry loops from amplifying failures by temporarily stopping operations when failure rates exceed thresholds. Protects the system from cascading failures and allows time for recovery. |\n\n### Testing and Validation\n\nComprehensive testing ensures container isolation, resource control, and networking function correctly across various scenarios.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| integration testing | Testing Approach | Validation of multiple components working together to ensure the complete container runtime functions correctly. Tests end-to-end scenarios like container creation, execution, resource enforcement, and cleanup across all system components. |\n| milestone checkpoint | Validation Point | A verification point after implementing specific functionality, with concrete tests to run and expected behavior to verify progress. Provides incremental validation that each implementation milestone meets its acceptance criteria. |\n| test environment | Testing Infrastructure | An isolated testing setup with cleanup capabilities that provides reproducible conditions for testing container operations. Includes temporary directories, test containers, and automated cleanup to prevent test pollution. |\n| race condition | Concurrency Bug | Timing-dependent bugs in concurrent operations where the outcome depends on the relative timing of events. Common in container runtimes due to parallel resource creation and cleanup operations requiring careful synchronization. |\n| resource exhaustion | Testing Scenario | Test scenarios designed to verify system behavior when resources (memory, PIDs, network interfaces) approach their limits. Ensures the container runtime handles resource pressure gracefully without crashing or corrupting state. |\n\n### Debugging and Diagnostics\n\nEffective debugging techniques are essential for diagnosing issues in the complex interactions between kernel features and container runtime components.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| namespace debugging | Debugging Technique | Systematic inspection of Linux namespace configuration and isolation to verify that containers have the expected view of system resources. Includes checking `/proc/PID/ns/` entries, mount tables, and process visibility. |\n| cgroup debugging | Debugging Technique | Analysis of resource control group setup and enforcement to verify that containers are properly limited and monitored. Includes inspecting cgroup hierarchies, resource usage statistics, and limit enforcement. |\n| network debugging | Debugging Technique | Diagnosis of container networking connectivity and configuration to identify why containers cannot communicate or access external resources. Uses tools like `ip`, `bridge`, `iptables`, and `netstat` to inspect network state. |\n| process isolation | Debugging Focus | Verification that container processes are properly separated from host processes and can only see other processes in their namespace. Critical for container security and proper resource accounting. |\n| resource pressure | Diagnostic Indicator | Metrics showing when resource usage approaches limits, potentially leading to performance degradation or failures. Includes memory pressure stall information, CPU throttling indicators, and I/O wait times. |\n| connectivity testing | Diagnostic Process | Validation of network paths and communication capabilities to ensure containers can reach required services. Tests both inter-container communication and external network access through various protocols. |\n| health checking | Monitoring Process | Automated validation of container runtime state and configuration to detect problems before they cause failures. Includes checking resource usage trends, network connectivity, and filesystem integrity. |\n| mount table inspection | Debugging Technique | Examination of filesystem mount points visible to containers to verify that the expected filesystems are mounted and accessible. Uses `/proc/PID/mounts` and `/proc/PID/mountinfo` to inspect mount state. |\n| veth pair verification | Debugging Technique | Checking that virtual ethernet interface creation and linkage function correctly, ensuring containers have proper network connectivity. Verifies interface creation, namespace assignment, and traffic flow. |\n| iptables rule analysis | Debugging Technique | Inspection of network address translation and firewall rules to verify that port forwarding and traffic filtering work correctly. Essential for diagnosing container network access issues. |\n\n### Security and Advanced Features\n\nAdvanced container runtimes implement additional security mechanisms and features beyond basic isolation.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| seccomp filters | Security Mechanism | System call level security restrictions that limit which system calls container processes can execute. Implemented using Berkeley Packet Filter (BPF) programs loaded into the kernel to intercept and filter system calls. |\n| mandatory access control | Security Framework | Policy-based security mechanisms beyond traditional Unix permissions, including SELinux and AppArmor. Provide additional layers of access control based on security policies rather than just file ownership and permissions. |\n| capability management | Security Feature | Fine-grained privilege control system that divides root privileges into distinct capabilities (e.g., CAP_NET_ADMIN, CAP_SYS_ADMIN). Allows containers to perform specific privileged operations without full root access. |\n| defense in depth | Security Strategy | The approach of implementing multiple independent security layers so that if one layer is compromised, other layers continue to provide protection. Combines namespaces, cgroups, seccomp, capabilities, and MAC for comprehensive security. |\n| supply chain security | Security Concern | Verification of software component authenticity and integrity throughout the development and deployment pipeline. Includes image signing, vulnerability scanning, and provenance tracking for container images. |\n\n### Networking Extensions\n\nAdvanced networking features enable sophisticated container network topologies and service mesh integration.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| overlay networking | Network Architecture | Network virtualization that creates logical networks spanning multiple hosts using encapsulation protocols like VXLAN or GRE. Enables containers on different hosts to communicate as if on the same network segment. |\n| Container Network Interface | Standard Interface | A specification and plugin architecture for configuring network interfaces in containers. Provides a standard way to integrate different networking solutions with container runtimes and orchestrators like Kubernetes. |\n| network policies | Security Feature | Declarative rules that control traffic flow between containers and external endpoints. Implemented at the network level to provide microsegmentation and traffic filtering based on labels, namespaces, and other criteria. |\n| quality of service | Network Feature | Traffic prioritization and bandwidth management mechanisms that ensure critical applications receive adequate network resources. Includes traffic shaping, priority queuing, and bandwidth guarantees. |\n| service mesh | Infrastructure Layer | A dedicated infrastructure layer that handles service-to-service communication, providing features like traffic management, security, and observability. Often implemented using sidecar proxies alongside application containers. |\n| traffic interception | Network Feature | The ability to redirect network traffic through proxies or filters for processing, monitoring, or security scanning. Essential for service mesh implementations and network security appliances. |\n\n### Storage and Image Management\n\nContainer storage systems provide persistent data management and efficient image distribution mechanisms.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| image registry | Storage System | A repository for storing and distributing container images, supporting features like authentication, authorization, and content distribution. Examples include Docker Hub, Amazon ECR, and private registry implementations. |\n| vulnerability scanning | Security Process | Automated security analysis of container images to identify known vulnerabilities in installed packages and dependencies. Integrates with image registries and CI/CD pipelines to prevent deployment of vulnerable images. |\n| persistent volumes | Storage Abstraction | Storage that survives container lifecycle events, allowing data to persist across container restarts and migrations. Implemented through volume mounts that connect containers to external storage systems. |\n| content-addressable storage | Storage Architecture | Storage organized by content hash rather than filename, ensuring data integrity and enabling efficient deduplication. Used in container image storage to share common layers between images and detect corruption. |\n| dynamic provisioning | Storage Feature | Automatic storage allocation based on demand rather than pre-allocated storage pools. Enables containers to request storage resources dynamically and have them provisioned from available storage systems. |\n\n### Container Orchestration Interface\n\nModern container runtimes often integrate with orchestration systems and provide standardized interfaces.\n\n| Term | Category | Definition |\n|------|----------|------------|\n| Container Runtime Interface | Standard Interface | A Kubernetes standard interface that defines how container orchestrators communicate with container runtimes. Enables different container runtimes to work with Kubernetes without requiring orchestrator-specific integration code. |\n| sidecar injection | Deployment Pattern | The automatic deployment of auxiliary containers alongside application containers to provide additional functionality like networking, security, or monitoring. Common in service mesh implementations for proxy injection. |\n\nThis glossary provides the essential vocabulary needed to understand and implement our container runtime system. Each term is carefully chosen to represent concepts you'll encounter while working through the four implementation milestones, from basic namespace isolation to advanced networking features.\n\n### Implementation Guidance\n\nUnderstanding these terms is crucial for successful implementation of your container runtime. As you work through each milestone, refer back to these definitions to ensure you're using terminology correctly and understanding the underlying concepts.\n\n**Key Term Categories for Each Milestone:**\n\n| Milestone | Primary Term Categories | Focus Areas |\n|-----------|------------------------|-------------|\n| Milestone 1 | Namespace Types, Kernel Features, Process Isolation | Understanding how namespaces create isolated views of system resources |\n| Milestone 2 | Cgroup Controllers, Resource Control, Monitoring | Learning how cgroups enforce resource limits and provide usage statistics |\n| Milestone 3 | Filesystem Concepts, Layer Stacking, Copy-on-Write | Mastering overlayfs mechanics and layer management |\n| Milestone 4 | Container Networking, NAT Rules, Interface Management | Implementing virtual networking with bridges and port forwarding |\n\n**Terminology Usage Guidelines:**\n\nWhen implementing your container runtime, consistently use these terms in your code comments, documentation, and variable names. This consistency helps maintain clarity and makes your code easier to understand and maintain.\n\nFor example, when implementing namespace creation, use terms like \"namespace handle\" for data structures that track namespace resources, \"process isolation\" when describing the security benefits, and \"mount namespace\" when specifically referring to filesystem isolation.\n\n**Common Terminology Mistakes:**\n\n⚠️ **Pitfall: Mixing cgroups v1 and v2 terminology**\nUsing cgroups v1 terms like \"memory.limit_in_bytes\" when implementing cgroups v2, which uses \"memory.max\". Always verify you're using the correct terminology for your target cgroup version.\n\n⚠️ **Pitfall: Confusing overlay filesystem layers**\nReferring to \"upper layers\" (plural) when overlayfs has only one upper directory but multiple lower directories. The terminology is specific: one upper directory, multiple lower directories, one merged view.\n\n⚠️ **Pitfall: Misusing network namespace terminology**\nCalling veth pairs \"virtual interfaces\" without clarifying they're specifically ethernet pairs. The term \"veth pair\" is precise and indicates the bidirectional nature of the connection.\n\n**Reference Implementation Notes:**\n\nWhen reading container runtime source code (Docker, containerd, runc), you'll encounter these same terms used consistently across implementations. Understanding this standard terminology helps you read and contribute to existing projects beyond your own implementation.\n\nThe Linux kernel documentation uses these exact terms, so mastering this vocabulary helps you understand system documentation, manual pages, and kernel interfaces more effectively.\n"}