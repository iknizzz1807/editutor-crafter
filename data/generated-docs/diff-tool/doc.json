{"html":"<h1 id=\"diff-tool-design-document\">Diff Tool: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A text comparison tool that identifies differences between two files using the Longest Common Subsequence algorithm and Myers&#39; diff algorithm to generate unified diff output. The key architectural challenge is efficiently computing optimal edit sequences using dynamic programming while providing readable output formats.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — understanding the fundamental problem drives all implementation decisions</p>\n</blockquote>\n<p>Text comparison appears deceptively simple on the surface. Given two files, we want to identify what changed — which lines were added, deleted, or remained the same. However, this seemingly straightforward task reveals deep complexity when we consider the numerous ways text can be modified and the challenge of presenting changes in a meaningful, readable format.</p>\n<p>The core challenge lies in defining what constitutes the &quot;best&quot; representation of differences between two text sequences. When a user edits a document, they don&#39;t simply perform random insertions and deletions — they make logical changes like adding paragraphs, moving sections, or revising sentences. Our diff algorithm must reverse-engineer these intentions from the final result, identifying the most intuitive way to express the transformation from one version to another.</p>\n<p>Consider a simple example where we compare two versions of a function. The original version might have five lines, and the modified version might have seven lines. There could be multiple valid ways to represent this change: we could show that two lines were added at the end, or that the entire function was deleted and replaced, or that specific lines were inserted at particular positions. The algorithm must choose the representation that minimizes cognitive load for the human reader while accurately capturing the semantic changes.</p>\n<p>The problem becomes even more complex when we consider that text files can contain thousands of lines, use different encodings, have varying line ending conventions, and may share very few common elements. A naive approach that compares every character or line against every other character or line quickly becomes computationally prohibitive. We need algorithms that can efficiently find optimal solutions while handling edge cases gracefully.</p>\n<h3 id=\"mental-model-dna-sequence-alignment\">Mental Model: DNA Sequence Alignment</h3>\n<p>The most intuitive way to understand text comparison is through the lens of <strong>DNA sequence alignment</strong>, a fundamental problem in bioinformatics. Just as biologists compare genetic sequences to understand evolutionary relationships and identify mutations, we compare text files to understand editorial changes and identify modifications.</p>\n<p>In DNA sequence alignment, scientists start with two genetic sequences — strings of nucleotides represented as letters (A, T, G, C). They want to find the optimal alignment that maximizes matching bases while minimizing the number of insertions, deletions, and substitutions needed to transform one sequence into another. The key insight is that not all differences are equally meaningful — some represent genuine evolutionary changes, while others might be artifacts of sequencing errors or irrelevant variations.</p>\n<p>Similarly, when comparing text files, we have two sequences of lines (instead of nucleotides). Our goal is to find the optimal alignment that maximizes matching lines while minimizing the number of insertions and deletions needed to transform the first file into the second. Just as DNA alignment algorithms identify the longest matching subsequences to infer evolutionary relationships, diff algorithms identify the <strong>longest common subsequence</strong> of lines to infer editorial relationships.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: The longest common subsequence represents the &quot;evolutionary backbone&quot; — the content that remained stable between versions. Everything else represents editorial mutations that need to be highlighted.</p>\n</blockquote>\n<p>This biological analogy illuminates several important aspects of the diff problem. First, <strong>order matters</strong> — just as the sequence of nucleotides in DNA determines genetic function, the sequence of lines in a text file determines logical structure. We can&#39;t arbitrarily rearrange lines to maximize matches without losing semantic meaning. Second, <strong>context is crucial</strong> — just as biologists present alignments with surrounding sequences to help interpret the significance of mutations, diff tools must present changes with surrounding context lines to help readers understand the scope and impact of modifications.</p>\n<p>Third, <strong>optimal alignment requires global perspective</strong> — we can&#39;t make locally optimal decisions about matching lines without considering the global structure. A line that appears in both files might seem like an obvious match, but if aligning those lines forces many other lines to appear as insertions and deletions, a different alignment might produce a cleaner, more readable result.</p>\n<p>The DNA analogy also reveals why this problem is computationally challenging. With sequences of length m and n, there are exponentially many possible alignments to consider. Dynamic programming algorithms like those used in bioinformatics provide a systematic way to explore all possibilities efficiently, building up optimal solutions for smaller subsequences and combining them to solve the larger problem.</p>\n<h3 id=\"existing-diff-algorithms\">Existing Diff Algorithms</h3>\n<p>The evolution of diff algorithms reflects a progression from simple, intuitive approaches to sophisticated techniques that balance computational efficiency with output quality. Understanding this progression helps us appreciate the design decisions in modern diff tools and choose the right algorithm for our specific requirements.</p>\n<blockquote>\n<p><strong>Decision: Algorithm Selection Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to choose between multiple diff algorithms with different performance and quality characteristics</li>\n<li><strong>Options Considered</strong>: Naive character comparison, line-by-line comparison, LCS-based approach, Myers&#39; algorithm</li>\n<li><strong>Decision</strong>: Implement LCS-based approach first, with Myers&#39; algorithm as future enhancement</li>\n<li><strong>Rationale</strong>: LCS provides optimal results for learning dynamic programming concepts, while Myers&#39; offers better performance for large files</li>\n<li><strong>Consequences</strong>: Excellent output quality but O(mn) space complexity; Myers&#39; extension will require significant architectural changes</li>\n</ul>\n</blockquote>\n<h4 id=\"naive-character-by-character-comparison\">Naive Character-by-Character Comparison</h4>\n<p>The most straightforward approach treats files as sequences of characters and attempts to find character-level differences. This algorithm scans through both files simultaneously, marking characters as matching or different based on direct comparison.</p>\n<p>The naive character approach works by maintaining two pointers, one for each file, and advancing them in lockstep. When characters match, both pointers advance. When characters differ, the algorithm faces a decision: should it treat this as a substitution, or should it look ahead to see if one file has an insertion or deletion at this position?</p>\n<p>The fundamental problem with character-level comparison is <strong>alignment ambiguity</strong>. Consider comparing &quot;abcde&quot; with &quot;axbcde&quot;. The naive algorithm might identify &#39;a&#39; as matching, then encounter &#39;b&#39; versus &#39;x&#39; and incorrectly conclude that &#39;b&#39; was substituted with &#39;x&#39;, &#39;c&#39; was substituted with &#39;b&#39;, and so on. The correct interpretation — that &#39;x&#39; was inserted between &#39;a&#39; and &#39;b&#39; — requires lookahead or backtracking capabilities that the naive approach lacks.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Character-by-Character Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Time Complexity</strong></td>\n<td>O(n) for simple scan, O(nm) with backtracking</td>\n</tr>\n<tr>\n<td><strong>Space Complexity</strong></td>\n<td>O(1) for simple scan, O(nm) for optimal alignment</td>\n</tr>\n<tr>\n<td><strong>Output Quality</strong></td>\n<td>Poor - many false substitutions, misaligned content</td>\n</tr>\n<tr>\n<td><strong>Implementation Complexity</strong></td>\n<td>Very simple for basic version, complex for quality results</td>\n</tr>\n<tr>\n<td><strong>Use Cases</strong></td>\n<td>Binary file comparison, simple text validation</td>\n</tr>\n</tbody></table>\n<p>Despite these limitations, character-level comparison remains valuable for specific scenarios. Binary file comparison often uses this approach because line-based comparison is meaningless for non-text data. Additionally, character-level diffs can provide fine-grained analysis within lines that have been identified as changed by higher-level algorithms.</p>\n<h4 id=\"line-by-line-comparison\">Line-by-Line Comparison</h4>\n<p>Recognizing that most text editing operations work at the line level, line-by-line comparison treats files as sequences of line strings rather than character sequences. This approach significantly reduces the search space and produces more semantically meaningful results for typical text files.</p>\n<p>Line-based comparison begins by tokenizing both files into arrays of lines, preserving the original line structure including empty lines. The algorithm then applies sequence comparison techniques to these line arrays, treating each line as an atomic unit. This abstraction level matches how humans typically think about text editing — we add paragraphs, delete sections, and modify sentences, rather than randomly inserting and deleting characters.</p>\n<p>The line-based approach immediately solves several problems that plague character-level comparison. <strong>Alignment ambiguity</strong> is greatly reduced because entire lines serve as strong anchors for alignment. <strong>Semantic coherence</strong> improves because the algorithm naturally preserves logical text structure. <strong>Performance</strong> increases dramatically because we&#39;re comparing hundreds or thousands of lines instead of millions of characters.</p>\n<p>However, line-based comparison introduces its own challenges. <strong>Whitespace sensitivity</strong> can cause semantically identical lines to appear different due to trailing spaces or tab-versus-space differences. <strong>Line ending variations</strong> (LF, CRLF, CR) can create spurious differences between files created on different operating systems. <strong>Granularity limitations</strong> mean that changes within a line appear as complete line replacements, even if only a single word was modified.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Line-by-Line Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Time Complexity</strong></td>\n<td>O(n) for simple scan, depends on subsequence algorithm for quality results</td>\n</tr>\n<tr>\n<td><strong>Space Complexity</strong></td>\n<td>O(n + m) for line storage plus algorithm-specific requirements</td>\n</tr>\n<tr>\n<td><strong>Output Quality</strong></td>\n<td>Good - matches human editing patterns, preserves document structure</td>\n</tr>\n<tr>\n<td><strong>Implementation Complexity</strong></td>\n<td>Moderate - requires tokenization, normalization, and subsequence algorithms</td>\n</tr>\n<tr>\n<td><strong>Use Cases</strong></td>\n<td>Most text files, source code, configuration files, documentation</td>\n</tr>\n</tbody></table>\n<p>Modern diff tools universally adopt line-based comparison as their foundation, then apply various algorithms to find optimal line sequence alignments. The choice of subsequence algorithm determines the tool&#39;s performance characteristics and output quality.</p>\n<h4 id=\"longest-common-subsequence-lcs-approach\">Longest Common Subsequence (LCS) Approach</h4>\n<p>The <strong>Longest Common Subsequence</strong> algorithm provides a rigorous mathematical foundation for optimal sequence comparison. Unlike heuristic approaches, LCS guarantees finding the longest sequence of lines that appear in both files in the same order, providing a principled way to identify what remained unchanged between versions.</p>\n<p>LCS operates on the insight that the optimal diff should maximize the amount of content marked as &quot;unchanged&quot; while minimizing the content marked as &quot;added&quot; or &quot;deleted&quot;. By finding the longest possible common subsequence, we identify the maximum amount of shared content, and everything else naturally falls into insertion or deletion categories.</p>\n<p>The algorithm uses <strong>dynamic programming</strong> to build up optimal solutions systematically. It constructs a two-dimensional matrix where entry (i,j) represents the length of the LCS between the first i lines of file A and the first j lines of file B. The recurrence relation captures the essential logic: if lines i and j match, we can extend the LCS from position (i-1, j-1); otherwise, we take the better of the two options where one file advances and the other doesn&#39;t.</p>\n<p>This mathematical rigor comes with computational costs. The classic LCS algorithm requires O(mn) time and O(mn) space, where m and n are the lengths of the input sequences. For large files, this can consume substantial memory. However, the algorithm&#39;s guarantee of optimal results makes it an excellent choice for learning dynamic programming concepts and understanding the theoretical foundation of diff algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>LCS-Based Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Time Complexity</strong></td>\n<td>O(mn) - must consider all position pairs</td>\n</tr>\n<tr>\n<td><strong>Space Complexity</strong></td>\n<td>O(mn) for full matrix, O(min(m,n)) with optimization</td>\n</tr>\n<tr>\n<td><strong>Output Quality</strong></td>\n<td>Optimal - guaranteed to find longest common subsequence</td>\n</tr>\n<tr>\n<td><strong>Implementation Complexity</strong></td>\n<td>Moderate - requires understanding of dynamic programming</td>\n</tr>\n<tr>\n<td><strong>Use Cases</strong></td>\n<td>Educational purposes, small to medium files, maximum quality required</td>\n</tr>\n</tbody></table>\n<p>The LCS approach serves as an excellent foundation for understanding diff algorithms because it makes the optimization goal explicit and provides a clear algorithmic framework. Once developers understand how LCS works, they can appreciate the trade-offs made by more advanced algorithms.</p>\n<h4 id=\"myers39-diff-algorithm\">Myers&#39; Diff Algorithm</h4>\n<p><strong>Myers&#39; algorithm</strong> represents the state-of-the-art in diff algorithm design, providing the same optimal results as LCS while offering significantly better performance characteristics for typical use cases. Developed by Eugene Myers in 1986, this algorithm powers many modern version control systems and diff tools.</p>\n<p>Myers&#39; key insight is that most real-world file comparisons involve relatively few changes compared to the total file size. While the worst-case scenario still requires O(mn) time, the expected case for files with few differences runs in O(n + d²) time, where d is the number of differences. This makes the algorithm extremely fast for the common case of comparing similar files with localized changes.</p>\n<p>The algorithm reconceptualizes the diff problem as a <strong>graph traversal</strong> problem. Instead of building a complete dynamic programming matrix, Myers&#39; algorithm explores only the portions of the search space that are likely to contain optimal solutions. It uses a clever <strong>edit graph</strong> representation where horizontal moves represent insertions, vertical moves represent deletions, and diagonal moves represent matches.</p>\n<p>The graph traversal proceeds in <strong>waves</strong>, exploring all possible paths that require exactly k edit operations before exploring paths that require k+1 operations. This breadth-first approach guarantees that the first path to reach the end represents an optimal solution, allowing the algorithm to terminate early without exploring the entire search space.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Myers&#39; Algorithm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Time Complexity</strong></td>\n<td>O(n + d²) expected case, O(mn) worst case</td>\n</tr>\n<tr>\n<td><strong>Space Complexity</strong></td>\n<td>O(d) for the search frontier</td>\n</tr>\n<tr>\n<td><strong>Output Quality</strong></td>\n<td>Optimal - same results as LCS but computed more efficiently</td>\n</tr>\n<tr>\n<td><strong>Implementation Complexity</strong></td>\n<td>High - requires understanding of graph algorithms and optimization techniques</td>\n</tr>\n<tr>\n<td><strong>Use Cases</strong></td>\n<td>Production diff tools, version control systems, large file comparison</td>\n</tr>\n</tbody></table>\n<p>Myers&#39; algorithm also provides natural opportunities for further optimizations. The <strong>linear space</strong> variant reduces memory usage to O(d), making it practical for comparing very large files. <strong>Patience diff</strong> and <strong>histogram diff</strong> build on Myers&#39; foundation to handle common patterns like code movement and repeated sections more elegantly.</p>\n<h4 id=\"algorithm-comparison-and-selection-criteria\">Algorithm Comparison and Selection Criteria</h4>\n<p>The choice between diff algorithms depends on multiple factors including file size, expected difference density, performance requirements, implementation complexity, and output quality needs. Understanding these trade-offs helps architects make informed decisions for their specific use cases.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Best For</th>\n<th>Avoid When</th>\n<th>Key Advantage</th>\n<th>Major Limitation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Naive Character</strong></td>\n<td>Binary files, simple validation</td>\n<td>Text files, quality matters</td>\n<td>Simple implementation</td>\n<td>Poor alignment quality</td>\n</tr>\n<tr>\n<td><strong>Line-by-Line Heuristic</strong></td>\n<td>Quick prototypes, approximations</td>\n<td>Optimal results required</td>\n<td>Fast implementation</td>\n<td>Suboptimal results</td>\n</tr>\n<tr>\n<td><strong>LCS Dynamic Programming</strong></td>\n<td>Learning, guaranteed optimal results</td>\n<td>Large files, memory constrained</td>\n<td>Theoretical foundation</td>\n<td>High memory usage</td>\n</tr>\n<tr>\n<td><strong>Myers&#39; Algorithm</strong></td>\n<td>Production systems, large files</td>\n<td>Educational contexts</td>\n<td>Best practical performance</td>\n<td>Implementation complexity</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Insight</strong>: The progression from naive approaches to Myers&#39; algorithm illustrates a fundamental pattern in algorithm design — starting with simple, correct solutions and then optimizing based on real-world usage patterns and constraints.</p>\n</blockquote>\n<p>For our diff tool implementation, we&#39;ll begin with the LCS approach because it provides the clearest path for learning dynamic programming concepts while guaranteeing optimal results. The mathematical rigor of LCS helps developers understand exactly what &quot;optimal&quot; means in the context of sequence comparison, providing a solid foundation for appreciating the optimizations made by more advanced algorithms.</p>\n<p>The modular architecture we&#39;ll design can accommodate future algorithm upgrades. By separating the sequence comparison logic from file handling and output formatting, we can later swap in Myers&#39; algorithm or other approaches without affecting the rest of the system. This extensibility principle ensures that our learning-focused implementation can evolve into a production-quality tool.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The context and problem understanding phase requires no code implementation, but establishing the right mental models and terminology now will guide all subsequent development decisions. This section provides the conceptual foundation and research direction for implementing a robust diff tool.</p>\n<h4 id=\"a-research-and-analysis-recommendations\">A. Research and Analysis Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Activity</th>\n<th>Beginner Approach</th>\n<th>Advanced Exploration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Algorithm Study</strong></td>\n<td>Implement LCS by hand on paper with 3-4 line examples</td>\n<td>Study Myers&#39; paper and implement edit graph traversal</td>\n</tr>\n<tr>\n<td><strong>Tool Analysis</strong></td>\n<td>Run <code>diff -u</code> on sample files, analyze output format</td>\n<td>Compare <code>diff</code>, <code>git diff</code>, and specialized tools like <code>wdiff</code></td>\n</tr>\n<tr>\n<td><strong>Performance Testing</strong></td>\n<td>Time algorithms on files with 100-1000 lines</td>\n<td>Benchmark with real codebases, measure memory usage</td>\n</tr>\n<tr>\n<td><strong>Format Research</strong></td>\n<td>Study unified diff format specification</td>\n<td>Explore side-by-side, context, and HTML output formats</td>\n</tr>\n</tbody></table>\n<h4 id=\"b-conceptual-validation-exercises\">B. Conceptual Validation Exercises</h4>\n<p>Before writing any code, validate your understanding of the core concepts through these exercises:</p>\n<p><strong>Exercise 1: Manual LCS Computation</strong>\nTake two short text sequences (5-8 lines each) and manually compute their LCS using the dynamic programming matrix. This hands-on experience will reveal common indexing pitfalls and help you understand the backtracking process.</p>\n<p>Example sequences for practice:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>File A: [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;date&quot;]\nFile B: [&quot;banana&quot;, &quot;cherry&quot;, &quot;elderberry&quot;, &quot;fig&quot;]</code></pre></div>\n\n<p><strong>Exercise 2: Diff Format Analysis</strong>\nCreate several test file pairs and run them through standard <code>diff -u</code> command. Analyze the output format, paying attention to:</p>\n<ul>\n<li>How line numbers are calculated and displayed</li>\n<li>Where context lines appear and how many are included</li>\n<li>How consecutive changes are grouped into hunks</li>\n<li>What happens with edge cases like empty files or no common lines</li>\n</ul>\n<p><strong>Exercise 3: Algorithm Comparison</strong>\nFor the same file pair, manually trace through different algorithmic approaches:</p>\n<ul>\n<li>Naive character-by-character (identify where it fails)</li>\n<li>Simple line matching without LCS (show suboptimal results)</li>\n<li>LCS-based approach (demonstrate optimal alignment)</li>\n</ul>\n<h4 id=\"c-key-terminology-and-concepts\">C. Key Terminology and Concepts</h4>\n<p>Establish consistent vocabulary that will be used throughout the implementation:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Sequence</strong></td>\n<td>Ordered collection of comparable elements</td>\n<td>Array of lines from a text file</td>\n</tr>\n<tr>\n<td><strong>Common Subsequence</strong></td>\n<td>Elements appearing in both sequences in same order</td>\n<td>Lines present in both file versions</td>\n</tr>\n<tr>\n<td><strong>Edit Distance</strong></td>\n<td>Minimum operations to transform one sequence to another</td>\n<td>Number of insertions + deletions needed</td>\n</tr>\n<tr>\n<td><strong>Hunk</strong></td>\n<td>Group of consecutive changes with surrounding context</td>\n<td>Block of diff output starting with @@</td>\n</tr>\n<tr>\n<td><strong>Context Lines</strong></td>\n<td>Unchanged lines displayed around changes for readability</td>\n<td>Lines before/after changes in diff output</td>\n</tr>\n</tbody></table>\n<h4 id=\"d-problem-decomposition-strategy\">D. Problem Decomposition Strategy</h4>\n<p>Break down the overall diff problem into manageable subproblems that map to our milestone structure:</p>\n<ol>\n<li><p><strong>File Representation Problem</strong>: How do we convert file bytes into comparable line sequences while handling encoding and line ending variations?</p>\n</li>\n<li><p><strong>Sequence Alignment Problem</strong>: How do we find the optimal way to align two line sequences to minimize apparent changes?</p>\n</li>\n<li><p><strong>Change Classification Problem</strong>: How do we convert the alignment result into explicit add/delete/unchanged operations?</p>\n</li>\n<li><p><strong>Output Formatting Problem</strong>: How do we present the change operations in a readable, standard format?</p>\n</li>\n<li><p><strong>User Interface Problem</strong>: How do we provide command-line access with appropriate options and error handling?</p>\n</li>\n</ol>\n<h4 id=\"e-design-principles-for-implementation\">E. Design Principles for Implementation</h4>\n<p>Establish core principles that will guide implementation decisions:</p>\n<blockquote>\n<p><strong>Principle 1: Correctness Over Performance</strong>\nPrioritize producing correct, optimal results over algorithmic optimizations. Performance improvements can come later without changing the external interface.</p>\n</blockquote>\n<blockquote>\n<p><strong>Principle 2: Modularity for Learning</strong>\nDesign each component to be independently testable and understandable. A learner should be able to focus on one algorithmic concept at a time.</p>\n</blockquote>\n<blockquote>\n<p><strong>Principle 3: Standard Compatibility</strong>\nProduce output that matches established diff tool conventions. This allows comparison with reference implementations for validation.</p>\n</blockquote>\n<blockquote>\n<p><strong>Principle 4: Graceful Degradation</strong>\nHandle edge cases and errors gracefully, providing helpful error messages rather than crashing or producing incorrect output.</p>\n</blockquote>\n<h4 id=\"f-milestone-checkpoint-expectations\">F. Milestone Checkpoint Expectations</h4>\n<p>After completing this context and problem statement analysis, you should be able to:</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Explain the LCS concept</strong> using the DNA alignment analogy to someone unfamiliar with algorithms</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Manually compute</strong> the LCS for simple 4-5 line file examples using the dynamic programming matrix</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Identify the trade-offs</strong> between naive, LCS-based, and Myers&#39; algorithmic approaches</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Analyze diff output</strong> from standard tools, understanding the unified format structure</li>\n<li><input disabled=\"\" type=\"checkbox\"> <strong>Decompose the overall problem</strong> into the specific subproblems addressed by each milestone</li>\n</ul>\n<h4 id=\"g-common-conceptual-pitfalls\">G. Common Conceptual Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Confusing LCS with String Edit Distance</strong>\nLCS finds the longest common subsequence, while edit distance finds the minimum number of operations needed for transformation. These are related but different concepts. LCS focuses on what stays the same; edit distance focuses on what changes.</p>\n<p>⚠️ <strong>Pitfall: Assuming Character-Level Comparison is Simpler</strong>\nCharacter-level comparison seems simpler but produces poor results for text files. Line-level comparison is actually easier to implement correctly and produces much better output.</p>\n<p>⚠️ <strong>Pitfall: Underestimating Memory Requirements</strong>\nThe naive LCS algorithm requires O(mn) space, which can be substantial for large files. A 10,000-line file comparison needs 100 million matrix entries, potentially several gigabytes of memory.</p>\n<p>⚠️ <strong>Pitfall: Ignoring File Encoding Issues</strong>\nText files can use various encodings (UTF-8, Latin-1, ASCII) and line endings (LF, CRLF, CR). Ignoring these differences can cause identical files to appear different or cause decoding errors.</p>\n<p>This conceptual foundation prepares you for the detailed architectural design and implementation phases. The mental models and terminology established here will guide decision-making throughout the development process, ensuring that implementation details serve the larger goal of creating an intuitive, correct, and efficient diff tool.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — clearly defining scope prevents feature creep and guides implementation decisions throughout the project</p>\n</blockquote>\n<p>Setting clear boundaries for our diff tool implementation is crucial for maintaining focus and delivering a working solution within reasonable complexity. This section establishes what we will build, what we explicitly won&#39;t build, and the rationale behind these decisions. By defining these boundaries upfront, we can make consistent architectural decisions and avoid the temptation to add features that would complicate the core learning objectives.</p>\n<p>The scope definition serves multiple purposes beyond project management. It helps us choose the right algorithms and data structures for our specific use case, guides our testing strategy by defining the expected behavior boundaries, and sets realistic expectations for performance and functionality. Most importantly for a learning project, it keeps us focused on the core concepts of dynamic programming, edit distance computation, and diff algorithm implementation without getting distracted by peripheral concerns.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>Our diff tool will implement a focused set of core capabilities that demonstrate the fundamental concepts of text comparison algorithms while providing practical utility. These goals are designed to cover the essential user workflows for comparing text files while maintaining implementation simplicity.</p>\n<p><strong>Mental Model: Essential Workshop Tools</strong> — Think of our functional goals like selecting tools for a woodworking workshop. We&#39;re not trying to build every possible tool, but rather the essential ones that can handle 80% of common tasks well. A good plane, saw, and chisel will accomplish most woodworking projects, even if specialized tools might be marginally better for specific tasks. Similarly, our diff tool focuses on the core comparison operations that handle the vast majority of real-world text comparison needs.</p>\n<h4 id=\"core-text-comparison-capabilities\">Core Text Comparison Capabilities</h4>\n<p>The foundation of our tool is reliable text comparison between two files using the Longest Common Subsequence algorithm. This provides the theoretical correctness that many users expect from a diff tool — finding the optimal sequence of changes that transforms one file into another.</p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Implementation Approach</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Line-based comparison</td>\n<td>Split files into line arrays, compare using LCS</td>\n<td>Identical results to reference implementations</td>\n</tr>\n<tr>\n<td>UTF-8 and Latin-1 encoding support</td>\n<td>Automatic encoding detection with fallback</td>\n<td>Handles common text file encodings without corruption</td>\n</tr>\n<tr>\n<td>Multiple line ending formats</td>\n<td>Normalize LF, CRLF, and CR during tokenization</td>\n<td>Consistent behavior across Windows, Unix, and Mac files</td>\n</tr>\n<tr>\n<td>Empty file handling</td>\n<td>Special case detection with appropriate output</td>\n<td>Graceful handling without algorithm failures</td>\n</tr>\n<tr>\n<td>Large file support</td>\n<td>Streaming line reading with memory management</td>\n<td>Process files up to several MB without memory exhaustion</td>\n</tr>\n</tbody></table>\n<p>The line-based approach aligns with how humans naturally think about text changes — additions, deletions, and modifications typically happen at the granularity of lines rather than individual characters. This choice also significantly reduces the computational complexity compared to character-level diffing while still providing useful results for most text files.</p>\n<h4 id=\"unified-diff-format-output\">Unified Diff Format Output</h4>\n<p>Our output format will conform to the unified diff standard, ensuring compatibility with existing tools and user expectations. The unified format strikes an optimal balance between human readability and machine parseability.</p>\n<table>\n<thead>\n<tr>\n<th>Format Element</th>\n<th>Structure</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File headers</td>\n<td><code>--- filename1</code> and <code>+++ filename2</code></td>\n<td><code>--- original.txt</code></td>\n</tr>\n<tr>\n<td>Hunk headers</td>\n<td><code>@@ -start,count +start,count @@</code></td>\n<td><code>@@ -15,7 +15,9 @@</code></td>\n</tr>\n<tr>\n<td>Context lines</td>\n<td>Lines without prefix</td>\n<td><code>    unchanged line</code></td>\n</tr>\n<tr>\n<td>Deletion markers</td>\n<td>Lines prefixed with <code>-</code></td>\n<td><code>-   deleted content</code></td>\n</tr>\n<tr>\n<td>Addition markers</td>\n<td>Lines prefixed with <code>+</code></td>\n<td><code>+   added content</code></td>\n</tr>\n</tbody></table>\n<p>The unified format provides several advantages over alternatives like side-by-side or context diff formats. It&#39;s compact for large changes, clearly shows the relationship between deletions and additions, and is universally supported by version control systems, patch utilities, and code review tools.</p>\n<h4 id=\"configurable-context-display\">Configurable Context Display</h4>\n<p>Context lines around changes provide crucial readability for understanding the location and nature of modifications. Our implementation will support configurable context amounts to balance between providing sufficient context and keeping output concise.</p>\n<blockquote>\n<p><strong>Decision: Default Context Lines</strong></p>\n<ul>\n<li><strong>Context</strong>: Users need context to understand where changes occur, but too much context clutters output</li>\n<li><strong>Options Considered</strong>: 0 lines (minimal), 3 lines (git default), 5 lines (traditional diff)</li>\n<li><strong>Decision</strong>: Default to 3 context lines with configurable override</li>\n<li><strong>Rationale</strong>: Matches git behavior for user familiarity, provides sufficient context for most changes, keeps output manageable for review</li>\n<li><strong>Consequences</strong>: Enables intuitive usage while allowing customization for specific needs</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Context Setting</th>\n<th>Use Case</th>\n<th>Output Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0 lines</td>\n<td>Minimal output, large files</td>\n<td>Only changed lines shown</td>\n</tr>\n<tr>\n<td>1-2 lines</td>\n<td>Quick scanning</td>\n<td>Limited context, compact</td>\n</tr>\n<tr>\n<td>3 lines (default)</td>\n<td>Code review, general use</td>\n<td>Good balance of context and brevity</td>\n</tr>\n<tr>\n<td>5+ lines</td>\n<td>Understanding complex changes</td>\n<td>Extensive context, verbose output</td>\n</tr>\n</tbody></table>\n<h4 id=\"command-line-interface\">Command-Line Interface</h4>\n<p>The CLI provides the primary user interaction with our diff tool, emphasizing simplicity and following Unix conventions for predictable behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Interface Element</th>\n<th>Specification</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic invocation</td>\n<td><code>difftool file1 file2</code></td>\n<td>Matches standard diff utility patterns</td>\n</tr>\n<tr>\n<td>Context control</td>\n<td><code>--context N</code> or <code>-c N</code></td>\n<td>Standard flag naming for context lines</td>\n</tr>\n<tr>\n<td>Color control</td>\n<td><code>--no-color</code></td>\n<td>Disable ANSI codes for piping/redirection</td>\n</tr>\n<tr>\n<td>Help output</td>\n<td><code>--help</code> or <code>-h</code></td>\n<td>Standard help flag conventions</td>\n</tr>\n<tr>\n<td>Exit codes</td>\n<td>0 (identical), 1 (different), 2 (error)</td>\n<td>Scriptable behavior matching diff standards</td>\n</tr>\n</tbody></table>\n<p>The interface design prioritizes discoverability and consistency with existing tools. Users familiar with standard diff utilities should be able to use our tool immediately without consulting documentation for basic operations.</p>\n<h4 id=\"visual-enhancement-features\">Visual Enhancement Features</h4>\n<p>Color output significantly improves the readability of diff results in terminal environments by providing immediate visual cues about change types.</p>\n<table>\n<thead>\n<tr>\n<th>Enhancement</th>\n<th>Implementation</th>\n<th>Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Colored additions</td>\n<td>Green text for <code>+</code> lines</td>\n<td>Immediate recognition of new content</td>\n</tr>\n<tr>\n<td>Colored deletions</td>\n<td>Red text for <code>-</code> lines</td>\n<td>Clear identification of removed content</td>\n</tr>\n<tr>\n<td>TTY detection</td>\n<td>Automatic color disabling for non-terminals</td>\n<td>Prevents ANSI codes in files/pipes</td>\n</tr>\n<tr>\n<td>Color override</td>\n<td>Manual disable via flag</td>\n<td>User control for accessibility needs</td>\n</tr>\n</tbody></table>\n<p>The color scheme follows conventional diff tool coloring that users expect, reducing cognitive load when interpreting results. Automatic TTY detection ensures that color codes don&#39;t interfere with file output or shell scripting scenarios.</p>\n<h3 id=\"non-goals\">Non-Goals</h3>\n<p>Explicitly defining what we will not implement is equally important as defining what we will build. These exclusions keep our scope manageable while focusing on the core learning objectives around dynamic programming and diff algorithms.</p>\n<p><strong>Mental Model: Focused Learning Path</strong> — Think of non-goals like choosing a hiking trail. When learning to hike, you pick a trail that matches your current skill level and available time. You don&#39;t attempt advanced mountaineering techniques or multi-day expeditions on your first outing. Similarly, our non-goals represent advanced features that would distract from mastering the fundamental concepts of text comparison algorithms.</p>\n<h4 id=\"advanced-diff-algorithms\">Advanced Diff Algorithms</h4>\n<p>While Myers&#39; algorithm offers superior performance characteristics, implementing it properly requires understanding edit graphs, diagonal traversal, and complex optimization techniques that go beyond the scope of a beginner project focused on dynamic programming concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Algorithm</th>\n<th>Complexity Reason</th>\n<th>Alternative Learning Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Myers&#39; algorithm</td>\n<td>Edit graph theory, O(ND) complexity analysis</td>\n<td>Advanced algorithms course</td>\n</tr>\n<tr>\n<td>Patience diff</td>\n<td>Requires understanding of unique line identification</td>\n<td>Specialized diff algorithm study</td>\n</tr>\n<tr>\n<td>Histogram diff</td>\n<td>Statistical analysis of file content patterns</td>\n<td>Machine learning or statistics focus</td>\n</tr>\n<tr>\n<td>Semantic diff</td>\n<td>Language parsing, AST comparison</td>\n<td>Compiler design or language processing</td>\n</tr>\n</tbody></table>\n<p>Our LCS-based approach provides the theoretical foundation that makes these advanced algorithms comprehensible later. Students who master the dynamic programming approach will be well-prepared to understand how Myers&#39; algorithm optimizes the same underlying problem.</p>\n<h4 id=\"multi-file-and-directory-operations\">Multi-File and Directory Operations</h4>\n<p>Directory comparison introduces file system traversal, recursive algorithms, and complex output formatting that would overshadow the core diff algorithm learning objectives.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Implementation Complexity</th>\n<th>Focus Dilution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Directory diffing</td>\n<td>Recursive tree traversal, file matching</td>\n<td>File system operations vs. algorithms</td>\n</tr>\n<tr>\n<td>Batch file comparison</td>\n<td>Process management, parallel execution</td>\n<td>Concurrency vs. dynamic programming</td>\n</tr>\n<tr>\n<td>Archive comparison</td>\n<td>Compression format handling</td>\n<td>File format parsing vs. text comparison</td>\n</tr>\n<tr>\n<td>Remote file access</td>\n<td>Network protocols, authentication</td>\n<td>Distributed systems vs. local algorithms</td>\n</tr>\n</tbody></table>\n<p>These features require substantial infrastructure code that doesn&#39;t contribute to understanding text comparison algorithms. Students can add these capabilities later once they&#39;ve mastered the core diff computation.</p>\n<h4 id=\"binary-file-support\">Binary File Support</h4>\n<p>Binary file comparison requires fundamentally different algorithms and output formats that don&#39;t align with our text-focused learning objectives.</p>\n<blockquote>\n<p><strong>Decision: Text Files Only</strong></p>\n<ul>\n<li><strong>Context</strong>: Binary files require byte-level comparison with different visualization needs</li>\n<li><strong>Options Considered</strong>: Hex dump diff, binary detection with error, universal byte comparison</li>\n<li><strong>Decision</strong>: Detect binary files and report error with helpful message</li>\n<li><strong>Rationale</strong>: Keeps focus on text algorithms, avoids complex binary visualization, provides clear user feedback</li>\n<li><strong>Consequences</strong>: Users must use specialized tools for binary comparison, but get clear guidance on limitation</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Binary Scenario</th>\n<th>Our Behavior</th>\n<th>User Guidance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure binary files</td>\n<td>Error with detection message</td>\n<td>Suggest <code>cmp</code> or <code>xxd</code> utilities</td>\n</tr>\n<tr>\n<td>Mixed text/binary</td>\n<td>Attempt text processing, may show garbage</td>\n<td>Warning about potential binary content</td>\n</tr>\n<tr>\n<td>Large binary files</td>\n<td>Early detection to avoid memory issues</td>\n<td>Clear error before processing begins</td>\n</tr>\n</tbody></table>\n<h4 id=\"advanced-output-formats\">Advanced Output Formats</h4>\n<p>Supporting multiple output formats would require complex formatting infrastructure that distracts from the algorithmic learning goals.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Format</th>\n<th>Implementation Overhead</th>\n<th>Learning Distraction</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Side-by-side display</td>\n<td>Terminal width detection, column alignment</td>\n<td>UI formatting vs. algorithm implementation</td>\n</tr>\n<tr>\n<td>HTML output</td>\n<td>Web formatting, CSS styling, escaping</td>\n<td>Web development vs. text processing</td>\n</tr>\n<tr>\n<td>JSON/XML structured output</td>\n<td>Schema definition, serialization libraries</td>\n<td>Data formats vs. diff computation</td>\n</tr>\n<tr>\n<td>Patch file generation</td>\n<td>Advanced header formatting, metadata handling</td>\n<td>File format specifications vs. algorithms</td>\n</tr>\n</tbody></table>\n<p>The unified diff format provides sufficient functionality for learning purposes while maintaining compatibility with existing tools. Students can explore alternative formats in follow-up projects once they understand the underlying comparison logic.</p>\n<h4 id=\"three-way-merge-and-conflict-resolution\">Three-Way Merge and Conflict Resolution</h4>\n<p>Merge algorithms introduce conflict detection, resolution strategies, and complex user interaction patterns that represent a separate area of study from basic two-way comparison.</p>\n<table>\n<thead>\n<tr>\n<th>Merge Feature</th>\n<th>Algorithmic Complexity</th>\n<th>UI Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Three-way merge</td>\n<td>Multiple LCS computations, conflict detection</td>\n<td>Interactive conflict resolution</td>\n</tr>\n<tr>\n<td>Automatic resolution</td>\n<td>Heuristic development, edge case handling</td>\n<td>Strategy configuration interfaces</td>\n</tr>\n<tr>\n<td>Manual conflict editing</td>\n<td>Text editor integration, temporary files</td>\n<td>File manipulation, process management</td>\n</tr>\n<tr>\n<td>Merge base detection</td>\n<td>Version control concepts, graph algorithms</td>\n<td>Repository integration requirements</td>\n</tr>\n</tbody></table>\n<p>Three-way merging builds upon two-way diffing but requires additional theoretical knowledge about merge bases, conflict categories, and resolution strategies. This complexity would double the scope of our project without proportional learning benefit for the core dynamic programming concepts.</p>\n<h4 id=\"performance-optimization-features\">Performance Optimization Features</h4>\n<p>Advanced performance optimizations require profiling tools, memory management techniques, and algorithmic analysis that extend beyond the introductory scope.</p>\n<table>\n<thead>\n<tr>\n<th>Optimization</th>\n<th>Technical Requirements</th>\n<th>Learning Prerequisites</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory streaming</td>\n<td>Chunk-based processing, temporary storage</td>\n<td>Systems programming concepts</td>\n</tr>\n<tr>\n<td>Parallel processing</td>\n<td>Thread management, work distribution</td>\n<td>Concurrency programming</td>\n</tr>\n<tr>\n<td>Caching systems</td>\n<td>Hash computation, cache invalidation</td>\n<td>Performance engineering</td>\n</tr>\n<tr>\n<td>Incremental diffing</td>\n<td>Change detection, partial recomputation</td>\n<td>Advanced algorithm optimization</td>\n</tr>\n</tbody></table>\n<p>Students benefit more from implementing a correct, straightforward algorithm first, then learning optimization techniques in dedicated performance-focused projects. The educational value comes from understanding the algorithmic complexity and correctness, not from premature optimization.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The scope decisions outlined above directly influence our technology choices and code organization. This guidance provides concrete recommendations for translating these goals into a working implementation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File I/O</td>\n<td>Built-in file operations (<code>open</code>, <code>read</code>)</td>\n<td>Memory-mapped files (<code>mmap</code>)</td>\n</tr>\n<tr>\n<td>Encoding Detection</td>\n<td>Try UTF-8, fallback to Latin-1</td>\n<td><code>chardet</code> library with confidence scoring</td>\n</tr>\n<tr>\n<td>CLI Parsing</td>\n<td>Manual <code>sys.argv</code> processing</td>\n<td><code>argparse</code> with subcommands and validation</td>\n</tr>\n<tr>\n<td>Color Output</td>\n<td>Simple ANSI escape sequences</td>\n<td><code>colorama</code> for cross-platform support</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in <code>unittest</code> module</td>\n<td><code>pytest</code> with fixtures and parameterization</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, the simple options provide direct control and understanding of the underlying operations. Students can upgrade to advanced options in later iterations once they understand the basic functionality.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>Organizing code to match our functional goals helps maintain clear separation of concerns:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff-tool/\n├── src/\n│   ├── __init__.py\n│   ├── main.py                 # CLI entry point and argument parsing\n│   ├── file_reader.py          # File I/O and line tokenization\n│   ├── lcs_engine.py          # LCS algorithm implementation\n│   ├── diff_generator.py      # Edit script and hunk formation\n│   └── output_formatter.py    # Unified diff format generation\n├── tests/\n│   ├── test_file_reader.py    # File I/O edge cases\n│   ├── test_lcs_engine.py     # Algorithm correctness\n│   ├── test_diff_generator.py # Hunk formation logic\n│   └── test_integration.py    # End-to-end scenarios\n├── examples/\n│   ├── sample1.txt           # Test files for manual verification\n│   ├── sample2.txt\n│   └── expected_output.diff\n└── README.md                 # Usage instructions and examples</code></pre></div>\n\n<p>This structure isolates each major component in its own module, making it easier to test individual pieces and understand the data flow between components.</p>\n<h4 id=\"scope-validation-checklist\">Scope Validation Checklist</h4>\n<p>Use this checklist during implementation to ensure you stay within the defined scope:</p>\n<p><strong>Functional Goals Checklist:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Reads two text files specified as command-line arguments</li>\n<li><input disabled=\"\" type=\"checkbox\"> Handles UTF-8 and Latin-1 encoding automatically</li>\n<li><input disabled=\"\" type=\"checkbox\"> Normalizes different line ending formats (LF, CRLF, CR)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Implements LCS algorithm with dynamic programming</li>\n<li><input disabled=\"\" type=\"checkbox\"> Generates unified diff format output</li>\n<li><input disabled=\"\" type=\"checkbox\"> Supports configurable context lines (default 3)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Provides colored output in terminal environments</li>\n<li><input disabled=\"\" type=\"checkbox\"> Returns appropriate exit codes (0, 1, 2)</li>\n<li><input disabled=\"\" type=\"checkbox\"> Includes <code>--help</code> and <code>--no-color</code> flags</li>\n</ul>\n<p><strong>Non-Goals Validation:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> No directory comparison features</li>\n<li><input disabled=\"\" type=\"checkbox\"> No binary file processing (error with clear message)</li>\n<li><input disabled=\"\" type=\"checkbox\"> No side-by-side or HTML output formats</li>\n<li><input disabled=\"\" type=\"checkbox\"> No three-way merge capabilities</li>\n<li><input disabled=\"\" type=\"checkbox\"> No advanced performance optimizations</li>\n<li><input disabled=\"\" type=\"checkbox\"> No network or remote file access</li>\n<li><input disabled=\"\" type=\"checkbox\"> No Myers&#39; algorithm implementation</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>Each milestone should be validated against our scope boundaries:</p>\n<p><strong>Milestone 1 Checkpoint (Line Tokenization):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic functionality</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> examples/sample1.txt</span><span style=\"color:#9ECBFF\"> examples/sample2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify encoding handling</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> utf8_file.txt</span><span style=\"color:#9ECBFF\"> latin1_file.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check line ending normalization</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> windows_file.txt</span><span style=\"color:#9ECBFF\"> unix_file.txt</span></span></code></pre></div>\n\n<p>Expected behavior: Files read successfully, line counts reported, no encoding errors for supported formats, binary files rejected with clear error message.</p>\n<p><strong>Milestone 2 Checkpoint (LCS Algorithm):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Manual LCS verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.lcs_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LCSEngine</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LCSEngine()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">lines1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">lines2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"X\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">lcs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> engine.compute_lcs(lines1, lines2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> lcs </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Expected longest common subsequence</span></span></code></pre></div>\n\n<p>Expected behavior: LCS algorithm produces correct results for known inputs, handles empty files gracefully, completes in reasonable time for moderately sized files.</p>\n<p><strong>Milestone 3 Checkpoint (Diff Generation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Generate diff output</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> file1.txt</span><span style=\"color:#9ECBFF\"> file2.txt</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> output.diff</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify unified format</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> \"^@@\"</span><span style=\"color:#9ECBFF\"> output.diff</span><span style=\"color:#6A737D\">  # Should show hunk headers</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> \"^-\"</span><span style=\"color:#9ECBFF\"> output.diff</span><span style=\"color:#6A737D\">   # Should show deletions</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#9ECBFF\"> \"^+\"</span><span style=\"color:#9ECBFF\"> output.diff</span><span style=\"color:#6A737D\">   # Should show additions</span></span></code></pre></div>\n\n<p>Expected behavior: Output follows unified diff format, hunk headers show correct line numbers, context lines appear around changes, output is compatible with patch utilities.</p>\n<p><strong>Milestone 4 Checkpoint (CLI and Color):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test CLI options</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#79B8FF\"> --help</span><span style=\"color:#6A737D\">                    # Shows usage information</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#79B8FF\"> --context</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> file1</span><span style=\"color:#9ECBFF\"> file2</span><span style=\"color:#6A737D\">  # Uses 5 context lines</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#79B8FF\"> --no-color</span><span style=\"color:#9ECBFF\"> file1</span><span style=\"color:#9ECBFF\"> file2</span><span style=\"color:#6A737D\">   # No ANSI codes in output</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test exit codes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> identical1.txt</span><span style=\"color:#9ECBFF\"> identical2.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $?</span><span style=\"color:#6A737D\">  # Should print 0</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> different1.txt</span><span style=\"color:#9ECBFF\"> different2.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $?</span><span style=\"color:#6A737D\">  # Should print 1</span></span></code></pre></div>\n\n<p>Expected behavior: Help text displays correctly, context option changes output, no-color flag removes ANSI codes, exit codes match file comparison results.</p>\n<h4 id=\"common-scope-creep-pitfalls\">Common Scope Creep Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Adding Word-Level Diffing</strong>\nBeginning programmers often want to add word-level or character-level diffing when they see that line-level changes don&#39;t show small modifications clearly. This significantly increases algorithm complexity and output formatting requirements. Instead, focus on making the line-level algorithm robust and correct. Word-level diffing can be a follow-up project.</p>\n<p>⚠️ <strong>Pitfall: Implementing Directory Recursion</strong>\nThe temptation to add <code>diff -r</code> functionality is strong, but directory traversal introduces file system edge cases, symbolic link handling, and complex output organization. These concerns distract from the core algorithmic learning. Stick to two-file comparison.</p>\n<p>⚠️ <strong>Pitfall: Premature Performance Optimization</strong>\nStudents often worry about performance and want to add caching, parallel processing, or memory optimization before the basic algorithm works correctly. Focus on correctness first. Performance optimization requires profiling and measurement that&#39;s beyond the scope of learning dynamic programming concepts.</p>\n<p>⚠️ <strong>Pitfall: Over-Engineering the CLI</strong>\nRich command-line interfaces with subcommands, configuration files, and extensive options seem professional but require significant infrastructure code. Keep the CLI simple and focused on the core comparison operation. Advanced CLI features can be added in later iterations.</p>\n<p>The key to successful scope management is recognizing when a feature request or implementation idea moves beyond the learning objectives. Ask yourself: &quot;Does this help me understand dynamic programming and diff algorithms better, or does it distract from that goal?&quot; Use that question to guide scope decisions throughout development.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-stack-recommendations\">Technology Stack Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Beginner Choice</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Language</td>\n<td>Python 3.8+</td>\n<td>Built-in file I/O, string handling, clear syntax for algorithm focus</td>\n</tr>\n<tr>\n<td>CLI Framework</td>\n<td><code>argparse</code> module</td>\n<td>Standard library, sufficient for simple flag handling</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td>Built-in <code>open()</code> with encoding parameter</td>\n<td>Direct control over encoding, no external dependencies</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>unittest</code> module</td>\n<td>Standard library, familiar structure, good for learning TDD</td>\n</tr>\n<tr>\n<td>Color Output</td>\n<td>Manual ANSI escape codes</td>\n<td>Understanding of terminal control, no dependencies</td>\n</tr>\n</tbody></table>\n<h4 id=\"essential-infrastructure-code\">Essential Infrastructure Code</h4>\n<p><strong>File Encoding Detection Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> codecs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_file_encoding</span><span style=\"color:#E1E4E8\">(filepath):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detect file encoding, trying UTF-8 first, then Latin-1.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encodings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'latin-1'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> encoding </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> encodings:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(filepath, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">encoding) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                f.read()  </span><span style=\"color:#6A737D\"># Try to read entire file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> encoding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> UnicodeDecodeError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Could not decode </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> with supported encodings\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_file_lines</span><span style=\"color:#E1E4E8\">(filepath):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Read file lines with automatic encoding detection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoding </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> detect_file_encoding(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(filepath, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">encoding, </span><span style=\"color:#FFAB70\">newline</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f.read()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Normalize line endings and split</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Handle trailing newline consistently</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> lines </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> lines[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines.pop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> lines</span></span></code></pre></div>\n\n<p><strong>ANSI Color Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ColorFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handle colored output with automatic TTY detection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[31m'</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GREEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[32m'</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESET</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[0m'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, use_color</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> use_color </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.use_color </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sys.stdout.isatty()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.use_color </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> use_color</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> red</span><span style=\"color:#E1E4E8\">(self, text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format text in red for deletions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.use_color:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RED}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> green</span><span style=\"color:#E1E4E8\">(self, text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format text in green for additions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.use_color:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">GREEN}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span></code></pre></div>\n\n<h4 id=\"core-component-skeletons\">Core Component Skeletons</h4>\n<p><strong>LCS Engine (for student implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LCSEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Implement Longest Common Subsequence using dynamic programming.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compute_lcs</span><span style=\"color:#E1E4E8\">(self, sequence1, sequence2):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Find the longest common subsequence between two sequences.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            sequence1: List of comparable elements (typically lines)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            sequence2: List of comparable elements (typically lines)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List containing the longest common subsequence elements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create DP table with dimensions (len(seq1)+1) x (len(seq2)+1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize first row and column to 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Fill DP table using recurrence relation:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         if seq1[i-1] == seq2[j-1]: dp[i][j] = dp[i-1][j-1] + 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Backtrack from dp[len(seq1)][len(seq2)] to recover actual LCS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the LCS elements in correct order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span><span style=\"color:#6A737D\">  # Student implements this</span></span></code></pre></div>\n\n<p><strong>Diff Generator (for student implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert LCS results into unified diff format hunks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_diff</span><span style=\"color:#E1E4E8\">(self, lines1, lines2, lcs, context_lines</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate unified diff hunks from LCS computation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lines1: Original file lines</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lines2: Modified file lines  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lcs: Longest common subsequence from LCS engine</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context_lines: Number of context lines around changes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of Hunk objects ready for formatting</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create edit script marking each line as UNCHANGED, DELETED, or ADDED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Group consecutive changes together</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add context lines before and after each change group</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Merge overlapping hunks when context causes overlap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create Hunk objects with line ranges and content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span><span style=\"color:#6A737D\">  # Student implements this</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-commands\">Milestone Validation Commands</h4>\n<p><strong>Milestone 1 - File Reading:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create test files with different encodings</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"Line 1\\nLine 2\\nLine 3\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> test1.txt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"Line 1\\nModified Line 2\\nLine 3\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test basic file reading</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from src.file_reader import read_file_lines</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">lines = read_file_lines('test1.txt')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Read {len(lines)} lines')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">for i, line in enumerate(lines): print(f'{i}: {repr(line)}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected: Clean line reading without encoding errors, proper line ending normalization.</p>\n<p><strong>Milestone 2 - LCS Algorithm:</strong>  </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test LCS computation with known examples</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from src.lcs_engine import LCSEngine</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">engine = LCSEngine()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Simple test case</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">seq1 = ['A', 'B', 'C', 'D']</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">seq2 = ['A', 'X', 'C', 'Y'] </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">lcs = engine.compute_lcs(seq1, seq2)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'LCS: {lcs}')  # Should be ['A', 'C']</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\"># Empty sequence test</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">lcs_empty = engine.compute_lcs([], ['A', 'B'])</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(f'Empty LCS: {lcs_empty}')  # Should be []</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected: Correct LCS results for known inputs, graceful handling of empty sequences.</p>\n<p><strong>Milestone 3 - Diff Generation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Generate actual diff output</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify unified format structure</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -10</span></span></code></pre></div>\n\n<p>Expected: Proper unified diff headers, hunk markers with @@ format, correct line prefixes.</p>\n<p><strong>Milestone 4 - CLI Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test all CLI options</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#79B8FF\"> --help</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#79B8FF\"> --context</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#79B8FF\"> --no-color</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify exit codes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Exit code: </span><span style=\"color:#79B8FF\">$?</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">  # Should be 0</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> src/main.py</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Exit code: </span><span style=\"color:#79B8FF\">$?</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">  # Should be 1</span></span></code></pre></div>\n\n<p>Expected: Help output displays, context option changes output, colors work in terminal but not in pipes, correct exit codes.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — the component architecture forms the foundation for implementing line tokenization, LCS computation, diff generation, and CLI output</p>\n</blockquote>\n<p>The diff tool follows a pipeline architecture where data flows through four specialized components, each with a distinct responsibility. Think of this like an assembly line in a publishing house: manuscripts arrive at the <strong>Document Preparation</strong> station (FileReader) where they&#39;re standardized and broken into comparable units, then move to the <strong>Analysis</strong> station (LCSEngine) where editors identify common content, followed by the <strong>Editorial</strong> station (DiffGenerator) where change instructions are created, and finally the <strong>Publishing</strong> station (OutputFormatter) where changes are formatted for readers.</p>\n<p>This pipeline design provides clear separation of concerns, making each component independently testable and allowing us to swap implementations (for example, replacing the LCS algorithm with Myers&#39; algorithm) without affecting other parts of the system. The unidirectional data flow also makes the system easier to reason about and debug — we can examine the output of each stage to isolate problems.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"System Component Architecture\"></p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The diff tool architecture consists of four main components that transform input files into formatted diff output through a series of well-defined stages. Each component has a specific responsibility and interfaces with adjacent components through structured data types.</p>\n<h4 id=\"filereader-component\">FileReader Component</h4>\n<p>The <strong>FileReader</strong> serves as the entry point to our diff pipeline, responsible for converting raw file data into normalized line sequences that can be compared. This component handles the complexities of file encoding detection, line ending normalization, and memory-efficient reading of potentially large files.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Input</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Encoding Detection</td>\n<td>Automatically detect file encoding (UTF-8, Latin-1)</td>\n<td>File path</td>\n<td>Encoding identifier</td>\n</tr>\n<tr>\n<td>Line Tokenization</td>\n<td>Split file content into individual lines</td>\n<td>Raw file bytes</td>\n<td>Array of line strings</td>\n</tr>\n<tr>\n<td>Normalization</td>\n<td>Handle different line endings (LF, CRLF, CR)</td>\n<td>Raw lines</td>\n<td>Normalized line array</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Detect binary files and encoding failures</td>\n<td>File system data</td>\n<td>Error messages or success</td>\n</tr>\n</tbody></table>\n<p>The FileReader abstracts away platform-specific file handling concerns, ensuring that subsequent components receive clean, predictable input regardless of the original file format. This isolation is crucial because text files can vary dramatically in encoding, line endings, and structure across different operating systems and editors.</p>\n<blockquote>\n<p><strong>Decision: Line-Based Tokenization</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to decide the granularity of comparison — character-level, word-level, or line-level tokenization</li>\n<li><strong>Options Considered</strong>: Character diff (fine-grained but noisy), word diff (semantic but complex), line diff (standard and readable)</li>\n<li><strong>Decision</strong>: Line-based tokenization with optional future word-level support</li>\n<li><strong>Rationale</strong>: Line-based diffs match user expectations from tools like <code>git diff</code> and <code>unified diff</code>, provide good balance between granularity and readability, and align with how developers think about code changes</li>\n<li><strong>Consequences</strong>: May miss fine-grained changes within lines, but produces familiar output format that integrates well with existing tooling</li>\n</ul>\n</blockquote>\n<h4 id=\"lcsengine-component\">LCSEngine Component</h4>\n<p>The <strong>LCSEngine</strong> implements the core algorithmic logic for finding the longest common subsequence between two line arrays using dynamic programming. This component encapsulates the computational complexity of sequence alignment, providing a clean interface that hides the matrix operations and backtracking logic.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>compute_lcs</code></td>\n<td><code>sequence1: list, sequence2: list</code></td>\n<td><code>CommonSubsequence</code></td>\n<td>Finds longest common subsequence using DP</td>\n</tr>\n<tr>\n<td><code>build_matrix</code></td>\n<td><code>lines1: list, lines2: list</code></td>\n<td><code>Matrix[int]</code></td>\n<td>Constructs LCS length matrix</td>\n</tr>\n<tr>\n<td><code>backtrack</code></td>\n<td><code>matrix: Matrix, seq1: list, seq2: list</code></td>\n<td><code>list[str]</code></td>\n<td>Recovers actual LCS from matrix</td>\n</tr>\n<tr>\n<td><code>optimize_memory</code></td>\n<td><code>matrix: Matrix</code></td>\n<td><code>Matrix[int]</code></td>\n<td>Applies space optimization for large inputs</td>\n</tr>\n</tbody></table>\n<p>The LCSEngine abstracts the mathematical complexity of dynamic programming, allowing other components to request sequence alignment without understanding matrix operations or backtracking algorithms. This separation enables us to experiment with different optimization strategies (like Hirschberg&#39;s algorithm for space efficiency) without affecting the rest of the system.</p>\n<blockquote>\n<p><strong>Decision: Dynamic Programming Over Naive Comparison</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple algorithms exist for finding common subsequences with different time/space trade-offs</li>\n<li><strong>Options Considered</strong>: Naive O(2^n) recursive approach, memoized recursion, bottom-up dynamic programming</li>\n<li><strong>Decision</strong>: Bottom-up dynamic programming with optional space optimization</li>\n<li><strong>Rationale</strong>: DP provides guaranteed O(mn) time complexity, iterative approach avoids stack overflow on large inputs, and the matrix structure enables future optimizations like Myers&#39; algorithm</li>\n<li><strong>Consequences</strong>: Uses O(mn) space which can be prohibitive for very large files, but provides predictable performance and clear upgrade path to space-optimized variants</li>\n</ul>\n</blockquote>\n<h4 id=\"diffgenerator-component\">DiffGenerator Component</h4>\n<p>The <strong>DiffGenerator</strong> transforms the abstract common subsequence result into concrete diff operations and organizes them into contextual hunks for human consumption. This component bridges between the mathematical result of sequence alignment and the practical needs of presenting changes in a readable format.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Symbol</th>\n<th>Description</th>\n<th>Context Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UNCHANGED</td>\n<td><code> </code></td>\n<td>Lines present in both files</td>\n<td>Forms context around changes</td>\n</tr>\n<tr>\n<td>ADDED</td>\n<td><code>+</code></td>\n<td>Lines only in second file</td>\n<td>Grouped into hunks with context</td>\n</tr>\n<tr>\n<td>DELETED</td>\n<td><code>-</code></td>\n<td>Lines only in first file</td>\n<td>Marked with original line numbers</td>\n</tr>\n<tr>\n<td>CONTEXT</td>\n<td><code> </code></td>\n<td>Surrounding unchanged lines</td>\n<td>Configurable count (default 3)</td>\n</tr>\n</tbody></table>\n<p>The DiffGenerator must solve the challenging problem of grouping individual edit operations into meaningful chunks while preserving enough context for users to understand the changes. This involves complex logic for determining hunk boundaries, handling overlapping context, and generating accurate line number ranges.</p>\n<blockquote>\n<p>The critical insight here is that raw edit operations are too granular for human consumption — users need changes grouped into logical chunks with surrounding context to understand the intent behind modifications.</p>\n</blockquote>\n<h4 id=\"outputformatter-component\">OutputFormatter Component</h4>\n<p>The <strong>OutputFormatter</strong> handles the final presentation layer, converting structured diff hunks into various output formats with optional visual enhancements. This component manages the complexity of terminal capabilities, color support detection, and format compatibility with standard tools.</p>\n<table>\n<thead>\n<tr>\n<th>Format Type</th>\n<th>Use Case</th>\n<th>Features</th>\n<th>Compatibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unified Diff</td>\n<td>Standard text output</td>\n<td>Header lines, hunk markers, line prefixes</td>\n<td><code>patch</code>, <code>git apply</code></td>\n</tr>\n<tr>\n<td>Colored Terminal</td>\n<td>Interactive viewing</td>\n<td>ANSI color codes, TTY detection</td>\n<td>Modern terminals</td>\n</tr>\n<tr>\n<td>Plain Text</td>\n<td>Scripting, pipes</td>\n<td>No color codes, clean parsing</td>\n<td>All environments</td>\n</tr>\n<tr>\n<td>Side-by-Side</td>\n<td>Visual comparison</td>\n<td>Parallel columns, alignment</td>\n<td>Wide terminals</td>\n</tr>\n</tbody></table>\n<p>The OutputFormatter must handle the subtleties of terminal capabilities, ensuring that color codes appear only when appropriate and that output remains parseable by other tools when redirected to files or pipes.</p>\n<h3 id=\"component-communication-patterns\">Component Communication Patterns</h3>\n<p>The components communicate through well-defined interfaces that pass structured data types rather than exposing internal implementation details. This design enables testing each component in isolation and supports future enhancements without cascading changes.</p>\n<table>\n<thead>\n<tr>\n<th>Interface</th>\n<th>Data Type</th>\n<th>Direction</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>FileReader → LCSEngine</td>\n<td><code>Sequence[str]</code></td>\n<td>Forward</td>\n<td>Normalized line arrays</td>\n</tr>\n<tr>\n<td>LCSEngine → DiffGenerator</td>\n<td><code>CommonSubsequence</code></td>\n<td>Forward</td>\n<td>Alignment result</td>\n</tr>\n<tr>\n<td>DiffGenerator → OutputFormatter</td>\n<td><code>list[Hunk]</code></td>\n<td>Forward</td>\n<td>Structured diff hunks</td>\n</tr>\n<tr>\n<td>All Components → CLI</td>\n<td><code>Result[T, Error]</code></td>\n<td>Return</td>\n<td>Success/failure reporting</td>\n</tr>\n</tbody></table>\n<p>The unidirectional flow simplifies reasoning about data transformations and makes the system more predictable. Each component can focus on its specific responsibility without worrying about side effects or circular dependencies.</p>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>The codebase organization reflects the component architecture, with each major component isolated in its own module to support independent development and testing. This structure helps prevent circular dependencies and makes the system easier to understand for new contributors.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff-tool/\n├── src/\n│   ├── __init__.py                 ← Package initialization\n│   ├── main.py                     ← CLI entry point and argument parsing\n│   ├── file_reader.py              ← FileReader component implementation\n│   ├── lcs_engine.py               ← LCSEngine with dynamic programming\n│   ├── diff_generator.py           ← DiffGenerator for hunk creation\n│   ├── output_formatter.py         ← OutputFormatter with color support\n│   └── types.py                    ← Shared data structures and enums\n├── tests/\n│   ├── test_file_reader.py         ← FileReader component tests\n│   ├── test_lcs_engine.py          ← LCS algorithm correctness tests  \n│   ├── test_diff_generator.py      ← Diff generation and hunk tests\n│   ├── test_output_formatter.py    ← Format and color output tests\n│   ├── test_integration.py         ← End-to-end pipeline tests\n│   └── fixtures/                   ← Test files with various encodings\n│       ├── utf8_sample.txt\n│       ├── latin1_sample.txt\n│       ├── mixed_endings.txt\n│       └── binary_file.bin\n└── README.md                       ← Usage examples and installation</code></pre></div>\n\n<p>This structure separates concerns at the file level, making it easy to locate and modify specific functionality. The <code>types.py</code> module contains shared data structures, preventing circular imports while keeping related types together.</p>\n<blockquote>\n<p><strong>Decision: Separate Module per Component</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to organize code to support independent development and testing of each component</li>\n<li><strong>Options Considered</strong>: Single large file, functional modules, class-based components in separate files</li>\n<li><strong>Decision</strong>: One module per major component with shared types module</li>\n<li><strong>Rationale</strong>: Enables parallel development, simplifies testing setup, prevents circular dependencies, and makes the codebase easier to navigate for newcomers</li>\n<li><strong>Consequences</strong>: More files to manage but clearer separation of responsibilities and better support for future team development</li>\n</ul>\n</blockquote>\n<p>The test structure mirrors the source structure, with additional integration tests to verify the complete pipeline. The fixtures directory provides a variety of test files to validate handling of different encodings and edge cases.</p>\n<h3 id=\"data-flow-architecture\">Data Flow Architecture</h3>\n<p>The pipeline processes data through distinct transformation stages, with each component adding structure and semantic meaning to the information. Understanding this flow is crucial for debugging issues and optimizing performance.</p>\n<p><strong>Stage 1: File Input → Line Sequences</strong>\nRaw file bytes are transformed into normalized arrays of strings, with encoding detection and line ending standardization applied. The FileReader produces clean, comparable sequences regardless of input file variations.</p>\n<p><strong>Stage 2: Line Sequences → Common Subsequence</strong><br>The LCSEngine processes both line arrays simultaneously, building a dynamic programming matrix to identify the optimal alignment. The result identifies which lines are shared between the files and in what order.</p>\n<p><strong>Stage 3: Common Subsequence → Edit Operations</strong>\nThe DiffGenerator compares the original sequences against the common subsequence to determine which lines were added, deleted, or unchanged. These operations are then grouped into hunks with appropriate context.</p>\n<p><strong>Stage 4: Edit Operations → Formatted Output</strong>\nThe OutputFormatter converts the structured hunks into human-readable text, applying color formatting when appropriate and generating output compatible with standard diff tools.</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input Type</th>\n<th>Processing</th>\n<th>Output Type</th>\n<th>Key Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Raw bytes</td>\n<td>Encoding + tokenization</td>\n<td><code>Sequence[str]</code></td>\n<td>Encoding detection</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Two sequences</td>\n<td>Dynamic programming</td>\n<td><code>CommonSubsequence</code></td>\n<td>Memory efficiency</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Sequences + LCS</td>\n<td>Edit script generation</td>\n<td><code>list[Hunk]</code></td>\n<td>Context grouping</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Structured hunks</td>\n<td>Format generation</td>\n<td>Formatted text</td>\n<td>Color/compatibility</td>\n</tr>\n</tbody></table>\n<p>This staged approach allows us to validate data at each transformation point and provides clear interfaces for testing. Each stage adds semantic value while maintaining the information needed for subsequent processing.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Circular Dependencies Between Components</strong>\nComponent modules importing each other creates circular dependency errors and makes testing difficult. This typically happens when components directly reference each other&#39;s implementation details rather than using shared data types. Fix by moving shared types to a separate module and ensuring unidirectional data flow.</p>\n<p>⚠️ <strong>Pitfall: Tight Coupling Through Implementation Details</strong>\nComponents that depend on internal implementation details of other components become fragile and hard to modify. For example, if DiffGenerator directly accesses LCSEngine&#39;s matrix rather than using the public interface, changes to the matrix representation break the diff generator. Always use well-defined interfaces and data types.</p>\n<p>⚠️ <strong>Pitfall: Missing Error Propagation Between Components</strong>\nErrors that occur in one component but aren&#39;t properly propagated to the CLI result in confusing failure modes where the program appears to succeed but produces incorrect output. Each component must properly handle errors from upstream components and provide meaningful error messages.</p>\n<p>⚠️ <strong>Pitfall: Memory Accumulation Across Pipeline Stages</strong>\nKeeping references to large intermediate data structures throughout the pipeline can cause memory usage to grow unnecessarily. For example, retaining the full LCS matrix after backtracking completes wastes space. Design components to release large intermediate data once no longer needed.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The component architecture provides a clean foundation for implementation, with each component focused on a specific aspect of the diff computation. This guidance helps translate the architectural design into working code.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Reading</td>\n<td><code>open()</code> with try/except</td>\n<td><code>chardet</code> library + streaming</td>\n<td>Simple for learning</td>\n</tr>\n<tr>\n<td>LCS Computation</td>\n<td>2D list matrix</td>\n<td>NumPy arrays</td>\n<td>Simple 2D list</td>\n</tr>\n<tr>\n<td>Hunk Generation</td>\n<td>List comprehensions</td>\n<td>Generator functions</td>\n<td>List comprehensions</td>\n</tr>\n<tr>\n<td>Color Output</td>\n<td>String concatenation</td>\n<td><code>colorama</code> library</td>\n<td>String concatenation</td>\n</tr>\n<tr>\n<td>CLI Parsing</td>\n<td><code>sys.argv</code> manually</td>\n<td><code>argparse</code> module</td>\n<td><code>argparse</code> module</td>\n</tr>\n</tbody></table>\n<p>For a learning project, the simple approaches provide better understanding of the underlying concepts without external dependencies obscuring the core algorithms.</p>\n<h4 id=\"project-structure-setup\">Project Structure Setup</h4>\n<p>Start by creating the directory structure and basic module files:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/types.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Shared data structures for the diff tool pipeline.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNCHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unchanged\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ADDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"added\"</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"deleted\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffLine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_type: LineType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Hunk</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines: List[DiffLine]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CommonSubsequence</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elements: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    positions_seq1: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    positions_seq2: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<h4 id=\"core-component-interfaces\">Core Component Interfaces</h4>\n<p>Each component should expose a clean interface that hides implementation complexity:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/file_reader.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"File reading and line tokenization component.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_file_encoding</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determine file encoding, trying UTF-8 first, then Latin-1.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: Path to the file to analyze</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Encoding name ('utf-8' or 'latin-1')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        FileNotFoundError: If file doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        PermissionError: If file can't be read</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Try to open file with UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If UnicodeDecodeError, try Latin-1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If both fail, raise encoding detection error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return successful encoding name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_file_lines</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Read file with encoding detection and line normalization.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        filepath: Path to the file to read</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        List of lines with normalized endings (no trailing </span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">n)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        FileNotFoundError: If file doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        PermissionError: If file can't be read  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        UnicodeDecodeError: If file encoding cannot be determined</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Detect file encoding using detect_file_encoding()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Open file with detected encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Read all lines preserving empty lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Normalize line endings (remove \\\\r\\\\n, \\\\r, \\\\n)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return normalized line list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/lcs_engine.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Longest Common Subsequence computation using dynamic programming.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CommonSubsequence</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> compute_lcs</span><span style=\"color:#E1E4E8\">(sequence1: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], sequence2: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Find longest common subsequence using dynamic programming.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        sequence1: First sequence (lines from file 1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        sequence2: Second sequence (lines from file 2)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        CommonSubsequence containing the LCS and position mappings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle empty sequence edge cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build LCS length matrix using dynamic programming</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Backtrack through matrix to find actual LCS elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record positions in both original sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return CommonSubsequence with elements and positions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> build_lcs_matrix</span><span style=\"color:#E1E4E8\">(seq1: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], seq2: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Build the LCS length matrix using dynamic programming.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        seq1: First sequence</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        seq2: Second sequence</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        2D matrix where matrix[i][j] = LCS length of seq1[:i] and seq2[:j]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize matrix with dimensions (len(seq1)+1) x (len(seq2)+1)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Fill first row and column with zeros</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each cell, if elements match: matrix[i][j] = matrix[i-1][j-1] + 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If elements don't match: matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return completed matrix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"component-integration-pattern\">Component Integration Pattern</h4>\n<p>Use a main pipeline function that coordinates the components:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/main.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Main CLI entry point and component coordination.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> argparse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .file_reader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> read_file_lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .lcs_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> compute_lcs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .diff_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> generate_diff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .output_formatter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> format_unified_diff, ColorFormatter</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main entry point for diff tool CLI.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse command line arguments (file1, file2, --context, --no-color)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Read both files using FileReader component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compute LCS using LCSEngine component  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate diff hunks using DiffGenerator component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Format and output using OutputFormatter component</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Set appropriate exit code (0 if same, 1 if different)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_argument_parser</span><span style=\"color:#E1E4E8\">() -> argparse.ArgumentParser:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create CLI argument parser with diff tool options.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create ArgumentParser with description</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add positional arguments for file1 and file2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add --context option with integer argument (default 3)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add --no-color flag for plain text output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return configured parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    main()</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Line Tokenization):</strong>\nRun <code>python -m src.file_reader test_file.txt</code> to verify file reading works correctly. You should see line count output and proper handling of different encodings. Test with UTF-8, Latin-1, and binary files to ensure encoding detection works.</p>\n<p><strong>After Milestone 2 (LCS Algorithm):</strong><br>Run <code>python -c &quot;from src.lcs_engine import compute_lcs; print(compute_lcs([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;], [&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]))&quot;</code> to verify LCS computation. The result should show common subsequence [&#39;a&#39;,&#39;c&#39;] with correct position mappings.</p>\n<p><strong>After Milestone 3 (Diff Generation):</strong>\nRun <code>python -m src.main file1.txt file2.txt</code> to see unified diff output. Verify that hunks are properly formed with @@ headers and correct line numbers.</p>\n<p><strong>After Milestone 4 (CLI and Color):</strong>\nTest <code>python -m src.main file1.txt file2.txt --context 5 --no-color</code> to verify all CLI options work correctly. Check that colors appear in terminal but not when redirected to a file.</p>\n<h4 id=\"language-specific-implementation-notes\">Language-Specific Implementation Notes</h4>\n<p><strong>Python File Handling:</strong></p>\n<ul>\n<li>Use <code>open(filepath, &#39;r&#39;, encoding=encoding)</code> for text files</li>\n<li>Handle <code>UnicodeDecodeError</code> when trying different encodings  </li>\n<li>Use <code>str.splitlines(keepends=False)</code> to normalize line endings</li>\n<li>Check <code>sys.stdout.isatty()</code> for TTY detection</li>\n</ul>\n<p><strong>Python Data Structures:</strong></p>\n<ul>\n<li>Use <code>List[List[int]]</code> for the LCS matrix (simple and clear)</li>\n<li>Use <code>dataclasses</code> for structured types like <code>Hunk</code> and <code>DiffLine</code></li>\n<li>Use <code>typing.Optional</code> for fields that may be None</li>\n<li>Use <code>enum.Enum</code> for constants like line types and colors</li>\n</ul>\n<p><strong>Python Testing:</strong></p>\n<ul>\n<li>Use <code>unittest</code> module for component tests</li>\n<li>Create fixtures in <code>tests/fixtures/</code> directory</li>\n<li>Use <code>tempfile</code> module for creating test files</li>\n<li>Mock file system errors using <code>unittest.mock</code></li>\n</ul>\n<p>This implementation guidance provides the scaffolding for building the diff tool while leaving the core algorithmic challenges for the learner to solve. The clear separation of components makes testing straightforward and debugging manageable.</p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — the data model forms the foundation that connects line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)</p>\n</blockquote>\n<p>The data model serves as the architectural backbone of our diff tool, defining how information flows from raw file content through algorithmic processing to formatted output. Think of the data model as the <strong>vocabulary and grammar</strong> of our diff system — just as human language needs nouns, verbs, and sentence structures to convey meaning, our diff tool needs well-defined types and relationships to represent files, changes, and output formats.</p>\n<p>Understanding the data model is crucial because it determines how each component communicates with others. A poorly designed data model leads to awkward conversions, performance bottlenecks, and maintenance headaches. Our design prioritizes clarity and efficiency, ensuring that data transformations feel natural and that the types directly reflect the problem domain.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Data Model Relationships\"></p>\n<p>The mental model for our data structures follows the <strong>document comparison workflow</strong>: we start with raw files, break them into comparable units (lines), find commonalities and differences, group related changes together, and finally format them for human consumption. Each data structure represents a specific stage in this transformation pipeline.</p>\n<h3 id=\"core-types-and-structures\">Core Types and Structures</h3>\n<p>Our data model consists of four primary structures that represent different abstraction levels in the diff process. Each structure encapsulates specific responsibilities and provides a clean interface for the components that manipulate it.</p>\n<h4 id=\"filecontent-structure\">FileContent Structure</h4>\n<p>The <code>FileContent</code> structure represents the parsed and normalized content of a single input file. This is the first structured representation we create from raw file data, serving as the foundation for all subsequent processing.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>filepath</code></td>\n<td><code>str</code></td>\n<td>Original file path for error reporting and output headers</td>\n</tr>\n<tr>\n<td><code>lines</code></td>\n<td><code>list[str]</code></td>\n<td>Normalized lines with consistent line endings removed</td>\n</tr>\n<tr>\n<td><code>line_count</code></td>\n<td><code>int</code></td>\n<td>Total number of lines including empty lines</td>\n</tr>\n<tr>\n<td><code>encoding</code></td>\n<td><code>str</code></td>\n<td>Detected encoding used to read the file (UTF-8, Latin-1)</td>\n</tr>\n<tr>\n<td><code>original_endings</code></td>\n<td><code>str</code></td>\n<td>Original line ending type detected (LF, CRLF, CR) for preservation</td>\n</tr>\n</tbody></table>\n<p>The <code>FileContent</code> structure encapsulates the preprocessing decisions made during file reading. By storing the original encoding and line endings, we preserve information that might be needed for error reporting or round-trip compatibility. The normalized <code>lines</code> array provides a clean interface for comparison algorithms while maintaining traceability to the original file structure.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Separating file metadata from content allows components to work with clean line arrays while preserving the ability to generate accurate error messages and output headers that reference original file characteristics.</p>\n</blockquote>\n<h4 id=\"diffline-structure\">DiffLine Structure</h4>\n<p>The <code>DiffLine</code> structure represents a single line in the final diff output, combining content with presentation metadata. This structure bridges the gap between algorithmic results and formatted output.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>content</code></td>\n<td><code>str</code></td>\n<td>The actual line text without diff prefixes or formatting</td>\n</tr>\n<tr>\n<td><code>line_type</code></td>\n<td><code>LineType</code></td>\n<td>Classification as UNCHANGED, ADDED, or DELETED</td>\n</tr>\n<tr>\n<td><code>old_line_num</code></td>\n<td><code>Optional[int]</code></td>\n<td>Line number in original file (None for ADDED lines)</td>\n</tr>\n<tr>\n<td><code>new_line_num</code></td>\n<td><code>Optional[int]</code></td>\n<td>Line number in modified file (None for DELETED lines)</td>\n</tr>\n</tbody></table>\n<p>The dual line numbering system enables generation of accurate unified diff headers while supporting other output formats. The optional nature of line numbers reflects the logical reality that added lines don&#39;t exist in the original file and deleted lines don&#39;t exist in the modified file.</p>\n<h4 id=\"linetype-enumeration\">LineType Enumeration</h4>\n<p>The <code>LineType</code> enumeration provides a clear classification system for diff operations, avoiding magic strings or numeric codes that could lead to confusion.</p>\n<table>\n<thead>\n<tr>\n<th>Enum Value</th>\n<th>Description</th>\n<th>Unified Diff Prefix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>UNCHANGED</code></td>\n<td>Line exists in both files with identical content</td>\n<td><code> </code> (space)</td>\n</tr>\n<tr>\n<td><code>ADDED</code></td>\n<td>Line exists only in the new file</td>\n<td><code>+</code></td>\n</tr>\n<tr>\n<td><code>DELETED</code></td>\n<td>Line exists only in the old file</td>\n<td><code>-</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Explicit LineType Enumeration</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to classify lines for diff output formatting</li>\n<li><strong>Options Considered</strong>: String constants (&quot;added&quot;, &quot;deleted&quot;), integer codes (0, 1, 2), enumeration</li>\n<li><strong>Decision</strong>: Use explicit enumeration with descriptive names</li>\n<li><strong>Rationale</strong>: Type safety prevents invalid values, IDE autocompletion reduces errors, self-documenting code</li>\n<li><strong>Consequences</strong>: Slightly more verbose than strings but eliminates entire class of typo bugs</li>\n</ul>\n</blockquote>\n<h4 id=\"hunk-structure\">Hunk Structure</h4>\n<p>The <code>Hunk</code> structure represents a group of consecutive changes along with surrounding context lines. This is the fundamental unit of diff output, corresponding to the sections marked with <code>@@</code> headers in unified diff format.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>old_start</code></td>\n<td><code>int</code></td>\n<td>Starting line number in original file (1-indexed for diff format)</td>\n</tr>\n<tr>\n<td><code>old_count</code></td>\n<td><code>int</code></td>\n<td>Number of lines from original file included in this hunk</td>\n</tr>\n<tr>\n<td><code>new_start</code></td>\n<td><code>int</code></td>\n<td>Starting line number in modified file (1-indexed for diff format)</td>\n</tr>\n<tr>\n<td><code>new_count</code></td>\n<td><code>int</code></td>\n<td>Number of lines from modified file included in this hunk</td>\n</tr>\n<tr>\n<td><code>lines</code></td>\n<td><code>list[DiffLine]</code></td>\n<td>All lines in this hunk including context and changes</td>\n</tr>\n<tr>\n<td><code>context_before</code></td>\n<td><code>int</code></td>\n<td>Number of context lines before first change</td>\n</tr>\n<tr>\n<td><code>context_after</code></td>\n<td><code>int</code></td>\n<td>Number of context lines after last change</td>\n</tr>\n</tbody></table>\n<p>The hunk structure encapsulates both the logical grouping of changes and the metadata needed to generate proper unified diff headers. The context tracking enables intelligent hunk merging when changes are close together.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Storing context line counts separately from the line array enables algorithms to distinguish between context and actual changes without scanning the entire line list.</p>\n</blockquote>\n<h4 id=\"commonsubsequence-structure\">CommonSubsequence Structure</h4>\n<p>The <code>CommonSubsequence</code> structure represents the result of LCS computation, containing both the matching elements and metadata about the comparison process.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>elements</code></td>\n<td><code>list[str]</code></td>\n<td>The actual longest common subsequence of lines</td>\n</tr>\n<tr>\n<td><code>length</code></td>\n<td><code>int</code></td>\n<td>Length of the common subsequence for quick access</td>\n</tr>\n<tr>\n<td><code>positions1</code></td>\n<td><code>list[int]</code></td>\n<td>Indices of LCS elements in the first sequence</td>\n</tr>\n<tr>\n<td><code>positions2</code></td>\n<td><code>list[int]</code></td>\n<td>Indices of LCS elements in the second sequence</td>\n</tr>\n</tbody></table>\n<p>The position arrays enable efficient conversion from LCS results to edit operations without re-scanning the input sequences. This design trades memory for computational efficiency, a worthwhile exchange given that diff operations are typically performed once per file pair.</p>\n<h4 id=\"editdistance-structure\">EditDistance Structure</h4>\n<p>The <code>EditDistance</code> structure captures metrics about the differences between two files, useful for summary reporting and algorithm validation.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>insertions</code></td>\n<td><code>int</code></td>\n<td>Number of lines added in the new file</td>\n</tr>\n<tr>\n<td><code>deletions</code></td>\n<td><code>int</code></td>\n<td>Number of lines removed from the old file</td>\n</tr>\n<tr>\n<td><code>unchanged</code></td>\n<td><code>int</code></td>\n<td>Number of lines that remain identical</td>\n</tr>\n<tr>\n<td><code>total_operations</code></td>\n<td><code>int</code></td>\n<td>Sum of insertions and deletions (Levenshtein distance)</td>\n</tr>\n</tbody></table>\n<p>This structure provides quick access to diff statistics without requiring traversal of the entire diff output. It supports both user-facing summary information and internal algorithm validation.</p>\n<h3 id=\"type-relationships\">Type Relationships</h3>\n<p>The data structures form a <strong>transformation pipeline</strong> where each type represents a different level of abstraction and processing. Understanding these relationships is crucial for implementing the component interfaces correctly.</p>\n<h4 id=\"file-processing-flow\">File Processing Flow</h4>\n<p>The transformation begins with raw file data and progresses through increasingly structured representations:</p>\n<ol>\n<li><p><strong>Raw File Data</strong> → <code>FileContent</code>: The file reader component processes binary file content, detects encoding, normalizes line endings, and splits into line arrays. This transformation handles the messiness of real-world files and produces clean input for algorithms.</p>\n</li>\n<li><p><strong>FileContent Pairs</strong> → <code>CommonSubsequence</code>: The LCS engine takes two <code>FileContent</code> structures and produces a <code>CommonSubsequence</code> representing the optimal alignment. This is where the core algorithmic work happens, using dynamic programming to find the longest matching sequence.</p>\n</li>\n<li><p><strong>CommonSubsequence</strong> + <strong>FileContent Pairs</strong> → <strong>Edit Operations</strong>: The diff generator combines the LCS result with the original file contents to produce a sequence of edit operations. This step determines which lines are insertions, deletions, or unchanged content.</p>\n</li>\n<li><p><strong>Edit Operations</strong> → <code>Hunk</code> <strong>List</strong>: The diff generator groups consecutive changes into hunks, adding configurable context lines around each change group. This transformation makes the diff human-readable by providing surrounding context.</p>\n</li>\n<li><p><strong>Hunk List</strong> → <strong>Formatted Output</strong>: The output formatter takes the structured hunk representation and generates the final diff format, whether unified diff, colored terminal output, or other presentation formats.</p>\n</li>\n</ol>\n<h4 id=\"data-flow-dependencies\">Data Flow Dependencies</h4>\n<p>The type relationships create specific dependency requirements that influence component design:</p>\n<table>\n<thead>\n<tr>\n<th>Source Type</th>\n<th>Target Type</th>\n<th>Transformation Component</th>\n<th>Key Operations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw bytes</td>\n<td><code>FileContent</code></td>\n<td>FileReader</td>\n<td>Encoding detection, line splitting, normalization</td>\n</tr>\n<tr>\n<td><code>FileContent</code> × 2</td>\n<td><code>CommonSubsequence</code></td>\n<td>LCSEngine</td>\n<td>Dynamic programming matrix computation</td>\n</tr>\n<tr>\n<td><code>CommonSubsequence</code> + <code>FileContent</code> × 2</td>\n<td><code>list[DiffLine]</code></td>\n<td>DiffGenerator</td>\n<td>Edit script generation, line classification</td>\n</tr>\n<tr>\n<td><code>list[DiffLine]</code></td>\n<td><code>list[Hunk]</code></td>\n<td>DiffGenerator</td>\n<td>Context addition, hunk boundary detection</td>\n</tr>\n<tr>\n<td><code>list[Hunk]</code></td>\n<td>Formatted output</td>\n<td>OutputFormatter</td>\n<td>Unified diff formatting, color application</td>\n</tr>\n</tbody></table>\n<h4 id=\"memory-and-performance-implications\">Memory and Performance Implications</h4>\n<p>The type relationships have important implications for memory usage and performance characteristics:</p>\n<p><strong>Memory Growth Pattern</strong>: Each transformation step typically increases memory usage as we add metadata and structure to the raw content. The peak memory usage occurs during hunk generation when we hold both the original file contents and the complete diff structure simultaneously.</p>\n<p><strong>Processing Efficiency</strong>: The position arrays in <code>CommonSubsequence</code> eliminate the need for repeated searches during edit script generation. Similarly, storing line numbers in <code>DiffLine</code> avoids recalculation during output formatting.</p>\n<p><strong>Streaming Opportunities</strong>: While the current design loads entire files into memory, the type structure supports future streaming implementations. The <code>Hunk</code> structure could be generated and output incrementally for large files.</p>\n<h4 id=\"error-propagation-through-types\">Error Propagation Through Types</h4>\n<p>Each type transformation introduces potential failure modes that must be handled gracefully:</p>\n<table>\n<thead>\n<tr>\n<th>Transformation</th>\n<th>Potential Failures</th>\n<th>Error Information Preserved</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bytes → <code>FileContent</code></td>\n<td>Encoding errors, I/O failures</td>\n<td>Original filepath, detected encoding</td>\n</tr>\n<tr>\n<td><code>FileContent</code> → <code>CommonSubsequence</code></td>\n<td>Memory exhaustion</td>\n<td>File sizes, available memory</td>\n</tr>\n<tr>\n<td><code>CommonSubsequence</code> → Edit operations</td>\n<td>Logic errors in backtracking</td>\n<td>LCS length, sequence lengths</td>\n</tr>\n<tr>\n<td>Edit operations → <code>Hunk</code></td>\n<td>Configuration errors</td>\n<td>Context line settings, hunk boundaries</td>\n</tr>\n</tbody></table>\n<p>The data model preserves enough context information to generate meaningful error messages that help users diagnose problems with their input files or configuration.</p>\n<h3 id=\"architecture-decision-records\">Architecture Decision Records</h3>\n<blockquote>\n<p><strong>Decision: Separate Line Content from Metadata</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to represent lines in diff output with various metadata (line numbers, change type, formatting)</li>\n<li><strong>Options Considered</strong>: Store everything in strings with prefixes, use tuples, create structured DiffLine type</li>\n<li><strong>Decision</strong>: Create structured <code>DiffLine</code> type with separate content and metadata fields</li>\n<li><strong>Rationale</strong>: Enables clean separation between algorithmic processing (works on content) and presentation (uses metadata), supports multiple output formats without re-parsing</li>\n<li><strong>Consequences</strong>: Slightly higher memory usage but eliminates string parsing and enables type-safe metadata access</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Position Arrays in CommonSubsequence</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to convert LCS results into edit operations efficiently</li>\n<li><strong>Options Considered</strong>: Store only the LCS elements, include position information, use iterator-based approach</li>\n<li><strong>Decision</strong>: Include position arrays mapping LCS elements back to original sequences</li>\n<li><strong>Rationale</strong>: Eliminates O(n²) search during edit script generation, enables parallel processing of multiple LCS results</li>\n<li><strong>Consequences</strong>: Higher memory usage but significantly faster diff generation for large files</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Context Metadata in Hunk Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to distinguish between actual changes and context lines within hunks</li>\n<li><strong>Options Considered</strong>: Mark context lines in DiffLine type, store context counts in Hunk, compute context dynamically</li>\n<li><strong>Decision</strong>: Store context counts as separate fields in Hunk structure</li>\n<li><strong>Rationale</strong>: Enables hunk merging algorithms without scanning line arrays, supports configurable context without re-processing</li>\n<li><strong>Consequences</strong>: Small amount of redundant information but significantly cleaner hunk manipulation code</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Mixing Zero-Based and One-Based Indexing</strong>\nThe internal algorithms use zero-based indexing for array access, but unified diff format requires one-based line numbers. Mixing these conventions leads to off-by-one errors in output. Always convert to one-based indexing only in the final formatting stage, and document which fields use which convention.</p>\n<p>⚠️ <strong>Pitfall: Forgetting Optional Line Numbers</strong>\n<code>DiffLine</code> uses optional line numbers because added lines don&#39;t exist in the original file and deleted lines don&#39;t exist in the new file. Code that assumes line numbers are always present will crash on these cases. Always check for <code>None</code> before using line numbers or provide sensible defaults for display.</p>\n<p>⚠️ <strong>Pitfall: Immutable vs Mutable Structures</strong>\nThe data structures are designed to be immutable after creation to prevent accidental modification during processing. Code that tries to modify structures in-place (like changing <code>line_type</code> after creation) violates this design and can lead to inconsistent state. Create new instances rather than modifying existing ones.</p>\n<p>⚠️ <strong>Pitfall: Context Line Double-Counting</strong>\nWhen generating hunks, it&#39;s easy to double-count context lines that appear in multiple hunks or include context lines in the change counts. The <code>old_count</code> and <code>new_count</code> fields should include context lines, while the separate context counters track how many lines are context versus actual changes.</p>\n<p>⚠️ <strong>Pitfall: Encoding Information Loss</strong>\nThe <code>FileContent</code> structure preserves original encoding information, but it&#39;s easy to lose this during processing and end up with encoding errors in output. Always propagate encoding information through the pipeline and use it when generating error messages or file headers.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The data model implementation focuses on creating clean, type-safe structures that guide correct usage and prevent common mistakes. The design emphasizes immutability and clear ownership to support both single-threaded and potential future multi-threaded implementations.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type Definitions</td>\n<td><code>dataclass</code> with frozen=True</td>\n<td><code>pydantic</code> models with validation</td>\n</tr>\n<tr>\n<td>Enumerations</td>\n<td><code>enum.Enum</code> with string values</td>\n<td><code>enum.Enum</code> with custom methods</td>\n</tr>\n<tr>\n<td>Optional Types</td>\n<td><code>typing.Optional</code> for clarity</td>\n<td><code>typing.Union</code> with None</td>\n</tr>\n<tr>\n<td>Collections</td>\n<td>Built-in <code>list</code> and <code>dict</code></td>\n<td><code>typing.NamedTuple</code> for small structures</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff_tool/\n  models/\n    __init__.py              ← export all public types\n    file_content.py          ← FileContent and related types\n    diff_line.py            ← DiffLine and LineType enum\n    hunk.py                 ← Hunk structure and hunk-related logic\n    lcs_types.py            ← CommonSubsequence and EditDistance\n  tests/\n    test_models/\n      test_file_content.py   ← test file content creation and validation\n      test_diff_line.py      ← test line type behavior and formatting\n      test_hunk.py          ← test hunk creation and manipulation</code></pre></div>\n\n<h4 id=\"core-type-definitions\">Core Type Definitions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileContent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents processed file content ready for comparison.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filepath: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoding: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_endings: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that line_count matches len(lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that encoding is supported ('utf-8', 'latin-1')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that original_endings is valid ('LF', 'CRLF', 'CR')</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Classification of lines in diff output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNCHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unchanged\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ADDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"added\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"deleted\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_diff_prefix</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert to unified diff prefix character.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return ' ' for UNCHANGED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return '+' for ADDED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return '-' for DELETED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffLine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Single line in diff output with metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_type: LineType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that ADDED lines have old_line_num = None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that DELETED lines have new_line_num = None  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that UNCHANGED lines have both line numbers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CommonSubsequence</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of LCS computation with position tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elements: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    positions1: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    positions2: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that length == len(elements)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that len(positions1) == len(positions2) == length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that positions are in ascending order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Hunk</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Group of consecutive changes with context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines: List[DiffLine]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_before: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_after: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_header</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate unified diff hunk header.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Format as \"@@ -old_start,old_count +new_start,new_count @@\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle special case where count is 1 (omit count in header)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure line numbers are 1-indexed for output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EditDistance</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Metrics about differences between files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    insertions: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deletions: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    unchanged: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_operations: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_diff_lines</span><span style=\"color:#E1E4E8\">(cls, lines: List[DiffLine]) -> </span><span style=\"color:#9ECBFF\">'EditDistance'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compute edit distance metrics from diff output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Count lines by LineType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate total_operations as insertions + deletions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that counts are non-negative</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"helper-functions\">Helper Functions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_file_content</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, raw_content: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, encoding: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       line_ending: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> FileContent:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Factory function for FileContent creation with validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Decode raw_content using specified encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Split content into lines preserving empty lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Normalize line endings to \\n for internal processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Count total lines including final empty line if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return FileContent with all fields populated</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> merge_hunks</span><span style=\"color:#E1E4E8\">(hunk1: Hunk, hunk2: Hunk, max_gap: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) -> Optional[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Merge two adjacent hunks if they're close enough.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if hunks are adjacent (gap &#x3C;= max_gap)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Combine line arrays with bridging context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Recalculate hunk boundaries and counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return merged hunk or None if unmergeable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_hunk_consistency</span><span style=\"color:#E1E4E8\">(hunk: Hunk) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify that hunk line counts match actual line content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Count UNCHANGED and DELETED lines, verify equals old_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Count UNCHANGED and ADDED lines, verify equals new_count  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that context counts don't exceed total lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify that line numbers are consecutive within each file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"type-conversion-utilities\">Type Conversion Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> diff_lines_to_hunks</span><span style=\"color:#E1E4E8\">(lines: List[DiffLine], context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert flat diff line list to structured hunks with context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify change boundaries (sequences of ADDED/DELETED lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add context_lines before and after each change group  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Merge hunks that overlap due to context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate correct line numbers and counts for each hunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return list of Hunk objects ready for formatting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> lcs_to_edit_operations</span><span style=\"color:#E1E4E8\">(lcs: CommonSubsequence, file1: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          file2: FileContent) -> List[DiffLine]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert LCS result to sequence of edit operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Walk through both files using LCS positions as anchors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Lines in LCS become UNCHANGED DiffLines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Lines in file1 not in LCS become DELETED DiffLines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Lines in file2 not in LCS become ADDED DiffLines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assign correct line numbers from original files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing basic types:</strong></p>\n<ul>\n<li>Run <code>python -m pytest tests/test_models/</code> — all type creation and validation tests should pass</li>\n<li>Create sample <code>FileContent</code> objects — verify encoding and line count are correct</li>\n<li>Test <code>LineType</code> enum — verify <code>to_diff_prefix()</code> returns correct characters</li>\n<li>Check immutability — attempting to modify frozen dataclass fields should raise <code>FrozenInstanceError</code></li>\n</ul>\n<p><strong>After implementing conversion functions:</strong></p>\n<ul>\n<li>Test <code>create_file_content()</code> with files containing different line endings — should normalize internally but preserve original format metadata</li>\n<li>Test <code>diff_lines_to_hunks()</code> with sample edit sequences — verify context lines and hunk boundaries are correct</li>\n<li>Verify hunk merging logic — adjacent hunks within context distance should merge, distant hunks should remain separate</li>\n</ul>\n<p><strong>After implementing validation:</strong></p>\n<ul>\n<li>Test edge cases: empty files, files with only additions/deletions, files with no common lines</li>\n<li>Verify error handling: invalid encodings, inconsistent line counts, malformed hunk data</li>\n<li>Check memory usage with large files — data structures should scale linearly with file size</li>\n</ul>\n<p>Signs of correct implementation:</p>\n<ul>\n<li>Type constructors reject invalid combinations (e.g., ADDED line with old_line_num set)</li>\n<li>Conversion between types preserves information (round-trip testing)</li>\n<li>Hunk generation produces output compatible with standard diff tools</li>\n<li>Memory usage grows predictably with input size</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Off-by-one errors in diff output</td>\n<td>Mixing zero-based and one-based indexing</td>\n<td>Print line numbers at each conversion step</td>\n<td>Use zero-based internally, convert to one-based only for output</td>\n</tr>\n<tr>\n<td>Missing lines in hunks</td>\n<td>Incorrect context line calculation</td>\n<td>Check <code>context_before</code> and <code>context_after</code> values</td>\n<td>Ensure context doesn&#39;t exceed file boundaries</td>\n</tr>\n<tr>\n<td>Hunk merge failures</td>\n<td>Overlapping context not detected</td>\n<td>Log hunk boundaries before merge attempts</td>\n<td>Fix gap calculation to account for context overlap</td>\n</tr>\n<tr>\n<td>Type validation errors</td>\n<td>Invalid field combinations</td>\n<td>Enable dataclass validation in <code>__post_init__</code></td>\n<td>Add comprehensive validation for all field constraints</td>\n</tr>\n<tr>\n<td>Memory errors with large files</td>\n<td>Storing redundant data</td>\n<td>Profile memory usage by component</td>\n<td>Consider streaming or lazy evaluation for large files</td>\n</tr>\n</tbody></table>\n<h2 id=\"file-reader-component\">File Reader Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Line Tokenization — handles file reading, encoding detection, line splitting, and text normalization that forms the foundation for all subsequent comparison operations</p>\n</blockquote>\n<p>The File Reader Component serves as the entry point to our diff tool, responsible for transforming raw file data into structured, comparable sequences of lines. This component must handle the messy realities of text files while providing clean, normalized input to downstream components.</p>\n<h3 id=\"mental-model-document-preparation\">Mental Model: Document Preparation</h3>\n<p>Think of the File Reader Component like a librarian preparing two historical manuscripts for scholarly comparison. Before scholars can analyze differences in content, the librarian must first standardize the physical presentation: ensuring both documents use the same character encoding (like translating from different alphabets to a common script), normalizing page breaks and line endings (like converting scrolls and bound books to the same format), and cataloging each line with consistent numbering. Just as manuscripts might use different writing systems, line spacing, or organizational structures, text files arrive with varying encodings, line endings, and formatting conventions that must be reconciled before meaningful comparison can begin.</p>\n<p>The librarian&#39;s careful preparation work — though invisible to the final scholarly analysis — determines whether the comparison will be accurate and meaningful. Similarly, our File Reader Component performs the crucial but often overlooked work of transforming arbitrary text files into clean, comparable data structures that enable accurate diff computation.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Ffile-processing-states.svg\" alt=\"File Processing State Machine\"></p>\n<p>The component operates as a state machine, progressing through distinct phases: initial file discovery, encoding detection, content reading, line tokenization, and normalization. Each state transition represents a validation checkpoint where errors can be detected and handled gracefully.</p>\n<h3 id=\"encoding-detection-and-handling\">Encoding Detection and Handling</h3>\n<p>Text encoding represents one of the most complex challenges in file processing, as files rarely declare their encoding explicitly. The component must make intelligent decisions about how to interpret byte sequences while providing fallback strategies when detection fails.</p>\n<blockquote>\n<p><strong>Decision: UTF-8 First, Latin-1 Fallback Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Files can use dozens of different encodings, but detection libraries are complex dependencies that may not be available in all target languages. Many diff tools fail entirely on encoding mismatches.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Require explicit encoding specification via command-line flags</li>\n<li>Use comprehensive encoding detection library (chardet/uchardet)</li>\n<li>Try UTF-8 first, fallback to Latin-1, fail on other encodings</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement UTF-8-first with Latin-1 fallback strategy</li>\n<li><strong>Rationale</strong>: UTF-8 handles 90%+ of modern text files and is backward-compatible with ASCII. Latin-1 can represent any byte sequence without errors, providing a universal fallback. This covers the vast majority of real-world scenarios while keeping dependencies minimal.</li>\n<li><strong>Consequences</strong>: Enables robust handling of common encodings while maintaining simplicity. May misinterpret files using other encodings (like Shift-JIS or UTF-16), but these represent edge cases for a learning project.</li>\n</ul>\n</blockquote>\n<p>The encoding detection process follows a systematic approach designed to maximize success while minimizing complexity:</p>\n<ol>\n<li><p><strong>UTF-8 Validation Attempt</strong>: Read the entire file as bytes and attempt UTF-8 decoding. UTF-8 has strict byte sequence rules, so invalid sequences will trigger decode errors immediately.</p>\n</li>\n<li><p><strong>Latin-1 Fallback</strong>: If UTF-8 decoding fails, retry with Latin-1 encoding. Latin-1 assigns meaning to every possible byte value (0-255), so this step cannot fail.</p>\n</li>\n<li><p><strong>Binary File Detection</strong>: During encoding attempts, detect likely binary files by scanning for null bytes or high percentages of non-printable characters. Binary files should be rejected early with clear error messages.</p>\n</li>\n<li><p><strong>Encoding Metadata Preservation</strong>: Store the detected encoding in the <code>FileContent</code> structure for debugging and potential future use in output formatting.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Detection Step</th>\n<th>Trigger Condition</th>\n<th>Action Taken</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UTF-8 Attempt</td>\n<td>Initial file read</td>\n<td>Decode entire file as UTF-8</td>\n<td>UnicodeDecodeError → proceed to fallback</td>\n</tr>\n<tr>\n<td>Binary Detection</td>\n<td>During UTF-8 attempt</td>\n<td>Scan for null bytes, control chars</td>\n<td>Reject with &quot;binary file&quot; error</td>\n</tr>\n<tr>\n<td>Latin-1 Fallback</td>\n<td>UTF-8 decode failure</td>\n<td>Re-read file with Latin-1</td>\n<td>Cannot fail (covers all byte values)</td>\n</tr>\n<tr>\n<td>Success Recording</td>\n<td>Successful decode</td>\n<td>Store encoding in FileContent</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: The encoding detection strategy prioritizes predictable behavior over perfect accuracy. It&#39;s better to consistently handle 95% of files correctly than to sometimes handle 100% of files but fail unpredictably on edge cases.</p>\n</blockquote>\n<h3 id=\"line-normalization\">Line Normalization</h3>\n<p>Once file content is successfully decoded to Unicode strings, the component must address the complexities of line ending conventions and whitespace handling. Different operating systems, text editors, and historical contexts have produced a variety of line ending formats that must be reconciled for accurate comparison.</p>\n<p>The normalization process preserves the logical structure of the file while standardizing physical representation details that should not affect diff computation. This requires careful balance between normalization and preservation — we want to eliminate spurious differences while maintaining meaningful distinctions.</p>\n<h4 id=\"line-ending-standardization\">Line Ending Standardization</h4>\n<p>Line endings present a classic compatibility challenge in text processing. The component must detect and normalize different line ending conventions while preserving the original format information for potential restoration.</p>\n<table>\n<thead>\n<tr>\n<th>Line Ending Type</th>\n<th>Byte Sequence</th>\n<th>Origin</th>\n<th>Detection Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unix LF</td>\n<td><code>\\n</code> (0x0A)</td>\n<td>Unix, Linux, macOS</td>\n<td>Single byte 0x0A</td>\n</tr>\n<tr>\n<td>Windows CRLF</td>\n<td><code>\\r\\n</code> (0x0D 0x0A)</td>\n<td>Windows, DOS</td>\n<td>Two-byte sequence, must check \\r\\n together</td>\n</tr>\n<tr>\n<td>Classic Mac CR</td>\n<td><code>\\r</code> (0x0D)</td>\n<td>Pre-OSX Mac</td>\n<td>Single byte 0x0D not followed by 0x0A</td>\n</tr>\n<tr>\n<td>Mixed Endings</td>\n<td>Various combinations</td>\n<td>Corrupted or manually edited files</td>\n<td>Count each type, report inconsistency</td>\n</tr>\n</tbody></table>\n<p>The normalization algorithm processes line endings in a specific order to avoid misdetection:</p>\n<ol>\n<li><p><strong>CRLF Detection First</strong>: Scan for <code>\\r\\n</code> sequences and replace with internal line separator markers. This must happen before individual <code>\\r</code> or <code>\\n</code> processing to avoid splitting CRLF pairs.</p>\n</li>\n<li><p><strong>Individual CR/LF Processing</strong>: After CRLF removal, remaining <code>\\r</code> or <code>\\n</code> characters represent Mac or Unix line endings respectively.</p>\n</li>\n<li><p><strong>Consistency Validation</strong>: Track the types of line endings found and warn if multiple types appear in the same file, as this often indicates file corruption or manual editing errors.</p>\n</li>\n<li><p><strong>Original Format Preservation</strong>: Store the detected line ending type in <code>FileContent.original_endings</code> for potential use in output formatting or debugging.</p>\n</li>\n</ol>\n<h4 id=\"whitespace-and-empty-line-handling\">Whitespace and Empty Line Handling</h4>\n<p>Whitespace handling requires nuanced decisions about what constitutes meaningful content versus formatting artifacts. The component must preserve structural elements like empty lines while potentially normalizing trailing whitespace that rarely carries semantic meaning.</p>\n<blockquote>\n<p><strong>Decision: Preserve Empty Lines, Optional Trailing Whitespace Normalization</strong></p>\n<ul>\n<li><strong>Context</strong>: Empty lines often carry semantic meaning (paragraph breaks, logical sections), but trailing whitespace is usually incidental formatting that creates spurious diff noise.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Preserve all whitespace exactly as found in files</li>\n<li>Strip all trailing whitespace from every line</li>\n<li>Configurable whitespace normalization with sensible defaults</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Always preserve empty lines, provide optional trailing whitespace normalization (default: enabled)</li>\n<li><strong>Rationale</strong>: Empty lines structure documents and should be preserved for meaningful diffs. Trailing whitespace rarely carries meaning and often creates noise when files are edited with different editors. Making it configurable allows power users to override when needed.</li>\n<li><strong>Consequences</strong>: Reduces spurious whitespace diffs while maintaining document structure. May occasionally hide meaningful trailing whitespace, but this represents an edge case.</li>\n</ul>\n</blockquote>\n<p>The whitespace normalization process operates on each line individually after line ending processing:</p>\n<ol>\n<li><p><strong>Empty Line Preservation</strong>: Lines containing only whitespace are preserved as truly empty lines (<code>&quot;&quot;</code>) to maintain document structure.</p>\n</li>\n<li><p><strong>Trailing Whitespace Handling</strong>: Based on configuration, either preserve or strip whitespace from the end of non-empty lines.</p>\n</li>\n<li><p><strong>Leading Whitespace Preservation</strong>: Always preserve leading whitespace as it commonly carries meaning (indentation, alignment).</p>\n</li>\n<li><p><strong>Tab/Space Normalization</strong>: Preserve tabs and spaces exactly as found, as the choice between them often carries semantic meaning or project-specific conventions.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Whitespace Type</th>\n<th>Handling Strategy</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leading spaces/tabs</td>\n<td>Always preserve</td>\n<td>Carries semantic meaning (indentation)</td>\n</tr>\n<tr>\n<td>Trailing spaces/tabs</td>\n<td>Configurable strip (default: remove)</td>\n<td>Usually formatting artifacts</td>\n</tr>\n<tr>\n<td>Empty lines (whitespace-only)</td>\n<td>Convert to truly empty</td>\n<td>Preserves structure, eliminates noise</td>\n</tr>\n<tr>\n<td>Internal spaces/tabs</td>\n<td>Always preserve</td>\n<td>Part of content, never normalize</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>The File Reader Component encounters several categories of errors that can cascade into confusing failures in downstream components. Understanding these pitfalls helps implementers build robust error handling and provide clear diagnostic messages.</p>\n<h4 id=\"-pitfall-binary-file-encoding-explosion\">⚠️ <strong>Pitfall: Binary File Encoding Explosion</strong></h4>\n<p><strong>Problem</strong>: Attempting to decode binary files (executables, images, compressed archives) as text causes encoding errors that propagate through the entire diff pipeline, often manifesting as cryptic Unicode exceptions far from the actual problem.</p>\n<p><strong>Why It Happens</strong>: Binary files contain byte sequences that violate UTF-8 encoding rules or produce invalid Unicode code points. When these sequences reach the LCS algorithm, they can cause comparison failures or generate nonsensical diff output.</p>\n<p><strong>Detection Strategy</strong>: Scan file content during encoding detection for binary indicators: null bytes (<code>\\0</code>), high percentages of non-printable characters, or known binary file signatures (magic numbers).</p>\n<p><strong>Prevention</strong>: Implement binary detection early in the encoding process and fail fast with clear error messages like &quot;Cannot diff binary file: detected null bytes at position X&quot;.</p>\n<h4 id=\"-pitfall-memory-exhaustion-on-large-files\">⚠️ <strong>Pitfall: Memory Exhaustion on Large Files</strong></h4>\n<p><strong>Problem</strong>: Loading entire large files into memory for line processing can exhaust available RAM, causing the process to crash or swap heavily, especially when processing log files or data dumps.</p>\n<p><strong>Why It Happens</strong>: The naive approach reads the complete file content into a string, then splits into lines, temporarily holding both the original content and the line array in memory simultaneously.</p>\n<p><strong>Detection Strategy</strong>: Monitor file sizes during initial file stat operations and warn when files exceed reasonable thresholds (e.g., 100MB).</p>\n<p><strong>Mitigation</strong>: Implement streaming line reading that processes files incrementally, or provide configuration options for memory limits with clear error messages when exceeded.</p>\n<h4 id=\"-pitfall-trailing-newline-inconsistency\">⚠️ <strong>Pitfall: Trailing Newline Inconsistency</strong></h4>\n<p><strong>Problem</strong>: Different text editors handle final newlines inconsistently — some always add a trailing newline, others preserve files exactly as edited. This creates spurious diffs where files differ only in their final newline presence.</p>\n<p><strong>Why It Happens</strong>: POSIX defines text files as sequences of lines where each line ends with a newline, but many editors don&#39;t enforce this. When one file ends with a newline and another doesn&#39;t, the line count differs, causing alignment issues in the LCS algorithm.</p>\n<p><strong>Detection Strategy</strong>: Check whether file content ends with a line ending sequence and track this information separately from line content.</p>\n<p><strong>Handling Options</strong>: Either normalize by always ensuring a final newline, or preserve the distinction but mark it clearly in diff output with messages like &quot;No newline at end of file&quot;.</p>\n<h4 id=\"-pitfall-line-ending-mixed-mode-corruption\">⚠️ <strong>Pitfall: Line Ending Mixed Mode Corruption</strong></h4>\n<p><strong>Problem</strong>: Files containing mixed line endings (some lines end with LF, others with CRLF) can indicate file corruption or editing across different systems. Naive splitting creates inconsistent line parsing where some lines retain carriage returns.</p>\n<p><strong>Why It Happens</strong>: Files transferred between systems without proper conversion, or edited with tools that don&#39;t normalize line endings consistently.</p>\n<p><strong>Detection Strategy</strong>: Count occurrences of each line ending type during normalization and flag files with multiple types.</p>\n<p><strong>Resolution</strong>: Provide clear warnings about mixed line endings and document the normalization strategy used, allowing users to fix their files if needed.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Early Detection Signal</th>\n<th>Recommended Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary files</td>\n<td>Null bytes, high non-printable ratio</td>\n<td>Fail fast with clear error message</td>\n</tr>\n<tr>\n<td>Large files</td>\n<td>File size &gt; memory threshold</td>\n<td>Warn user, implement streaming if possible</td>\n</tr>\n<tr>\n<td>Encoding failures</td>\n<td>UnicodeDecodeError in both UTF-8 and Latin-1</td>\n<td>Report unsupported encoding, suggest alternatives</td>\n</tr>\n<tr>\n<td>Mixed line endings</td>\n<td>Multiple line ending types detected</td>\n<td>Warn user, document normalization applied</td>\n</tr>\n<tr>\n<td>Trailing newline inconsistency</td>\n<td>One file ends with newline, other doesn&#39;t</td>\n<td>Mark in diff output, consider normalization option</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The File Reader Component bridges the gap between raw file system operations and the structured data required for diff computation. The implementation must balance robust error handling with clean abstractions that hide complexity from downstream components.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File I/O</td>\n<td>Built-in file operations (<code>open</code>, <code>read</code>)</td>\n<td>Memory-mapped files for large file optimization</td>\n</tr>\n<tr>\n<td>Encoding Detection</td>\n<td>Try UTF-8, fallback to Latin-1</td>\n<td><code>chardet</code>/<code>uchardet</code> library for comprehensive detection</td>\n</tr>\n<tr>\n<td>Line Splitting</td>\n<td>String <code>split</code> with line ending normalization</td>\n<td>Streaming line reader with configurable buffers</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception propagation with context</td>\n<td>Structured error types with recovery suggestions</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff-tool/\n  src/\n    file_reader/\n      __init__.py              ← Component interface\n      reader.py                ← Core FileReader class  \n      encoding.py              ← Encoding detection utilities\n      normalization.py         ← Line ending and whitespace handling\n      errors.py                ← File reading error types\n    tests/\n      test_file_reader.py      ← Comprehensive test suite\n      fixtures/                ← Test files with various encodings\n        utf8_unix.txt\n        latin1_windows.txt\n        binary_file.exe\n        mixed_endings.txt</code></pre></div>\n\n<h4 id=\"core-data-structures\">Core Data Structures</h4>\n<p>The File Reader Component works primarily with the <code>FileContent</code> structure that encapsulates all information needed for downstream processing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileContent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Complete representation of a file prepared for diff processing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                    # Original file path for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]                </span><span style=\"color:#6A737D\"># Normalized line content (no line endings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">                 # Total number of lines for validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    encoding: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">                   # Detected encoding (utf-8 or latin-1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_endings: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">           # Original line ending style (LF/CRLF/CR/mixed)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_file_content</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, raw_content: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       encoding: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, line_ending: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> FileContent:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Factory function for validated FileContent creation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Normalize line endings according to detected type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Split content into lines while preserving empty lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Apply whitespace normalization based on configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Validate line count matches actual content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 5: Return populated FileContent with all metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"encoding-detection-infrastructure\">Encoding Detection Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_file_encoding</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determine file encoding trying UTF-8 then Latin-1.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns the encoding name that successfully decoded the file.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises BinaryFileError if file appears to be binary.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Read file as bytes for encoding detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for binary file indicators (null bytes, high non-printable ratio)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Attempt UTF-8 decoding on entire content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: On UTF-8 failure, attempt Latin-1 decoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return successful encoding name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _is_binary_content</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, sample_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8192</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detect if content appears to be binary rather than text.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Check for null bytes in content sample</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Count printable vs non-printable characters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Return True if binary indicators exceed threshold</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_file_lines</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Read file with encoding detection and line normalization.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Validate file exists and is readable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Detect encoding using detect_file_encoding()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Read content with detected encoding  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Normalize line endings and split into lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 5: Apply whitespace normalization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 6: Return clean list of line strings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"line-normalization-utilities\">Line Normalization Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Normalize line endings and detect original format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns normalized content and detected line ending type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Count occurrences of CRLF, LF, and CR</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Determine predominant line ending style</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Warn if mixed line endings detected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert all line endings to LF for internal processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return normalized content and original ending type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> split_preserving_empty_lines</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Split content into lines while preserving empty lines.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Split on normalized line endings (LF)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Handle final newline correctly (don't create extra empty line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Preserve truly empty lines in sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Return list of line content without line ending characters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_whitespace</span><span style=\"color:#E1E4E8\">(lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], strip_trailing: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Apply whitespace normalization to line list.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Process each line individually</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Preserve leading whitespace (semantic meaning)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Optionally strip trailing whitespace based on configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Convert whitespace-only lines to empty strings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 5: Return normalized line list</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"error-handling-and-recovery\">Error Handling and Recovery</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileReaderError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for file reading operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BinaryFileError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">FileReaderError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when attempting to process binary files as text.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, indicator: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot diff binary file </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">indicator</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EncodingDetectionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">FileReaderError</span><span style=\"color:#E1E4E8\">):  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when file encoding cannot be determined.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, attempted_encodings: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        encodings </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \", \"</span><span style=\"color:#E1E4E8\">.join(attempted_encodings)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot detect encoding for </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, tried: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">encodings</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LargeFileError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">FileReaderError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when file exceeds memory or processing limits.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, limit: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"File </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">size</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes) exceeds limit (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">limit</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes)\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the File Reader Component, verify correct behavior with these test scenarios:</p>\n<p><strong>Test Command</strong>: </p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_file_reader.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>UTF-8 files read correctly with proper line splitting</li>\n<li>Latin-1 files fall back gracefully when UTF-8 fails  </li>\n<li>Binary files rejected with clear error messages</li>\n<li>Mixed line endings detected and normalized consistently</li>\n<li>Empty lines preserved in output</li>\n<li>Trailing whitespace handled according to configuration</li>\n</ul>\n<p><strong>Manual Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> file_reader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> read_file_lines</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test various file types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">utf8_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> read_file_lines(</span><span style=\"color:#9ECBFF\">'test_files/utf8_sample.txt'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">latin1_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> read_file_lines(</span><span style=\"color:#9ECBFF\">'test_files/latin1_sample.txt'</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"UTF-8 file: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(utf8_lines)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> lines\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Latin-1 file: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(latin1_lines)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> lines\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify empty line preservation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> utf8_lines:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Empty lines preserved\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Debugging Signs</strong>:</p>\n<ul>\n<li><strong>Files appear to have wrong line counts</strong>: Check line ending normalization — mixed CRLF/LF can cause double-counting</li>\n<li><strong>Unicode decode errors</strong>: Verify binary file detection is working and catching non-text files early</li>\n<li><strong>Memory usage spikes</strong>: Implement file size checking and streaming for large files</li>\n<li><strong>Spurious whitespace diffs</strong>: Confirm trailing whitespace normalization is applied consistently</li>\n</ul>\n<h2 id=\"lcs-engine-component\">LCS Engine Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2: LCS Algorithm — implements the core dynamic programming algorithm for finding longest common subsequences, which forms the foundation for all diff generation in subsequent milestones</p>\n</blockquote>\n<p>The LCS Engine represents the mathematical heart of our diff tool, where we transform the abstract problem of &quot;what changed between two files&quot; into a concrete algorithmic solution. This component encapsulates the dynamic programming approach to finding the Longest Common Subsequence, serving as the bridge between raw line data from the File Reader and meaningful diff operations for the Diff Generator.</p>\n<h3 id=\"mental-model-finding-common-ground\">Mental Model: Finding Common Ground</h3>\n<p>Think of the LCS algorithm like finding the longest sequence of topics two people agree on during a complex conversation. Imagine Alice and Bob are discussing a project, and you&#39;re taking notes on their areas of agreement. Alice says: &quot;We need planning, design, implementation, testing, deployment.&quot; Bob says: &quot;We should do planning, prototyping, implementation, review, testing, launch.&quot; </p>\n<p>Your job is to find the longest sequence of topics they both mentioned in the same order. You can&#39;t rearrange their words, but you can skip disagreements to find the common thread. The result might be: &quot;planning, implementation, testing&quot; — a subsequence that appears in both conversations while preserving the original order.</p>\n<p>The LCS algorithm works similarly with text lines. Given two files, it finds the longest sequence of lines that appear in both files in the same relative order. These common lines represent the unchanged &quot;skeleton&quot; of the document, while everything else represents insertions or deletions. This common skeleton becomes the foundation for generating meaningful diff output that humans can understand.</p>\n<p>The power of this approach lies in its optimality guarantee. Among all possible ways to align two sequences, the LCS algorithm finds the alignment that maximizes preserved content and minimizes the number of changes needed. This mathematical property ensures our diff output shows the most intuitive representation of what actually changed between files.</p>\n<h3 id=\"dynamic-programming-algorithm\">Dynamic Programming Algorithm</h3>\n<p>The LCS algorithm employs dynamic programming to solve what would otherwise be an exponentially complex problem. The core insight is that the LCS of two sequences can be computed by solving smaller subproblems and combining their results systematically.</p>\n<blockquote>\n<p><strong>Decision: Dynamic Programming Matrix Approach</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple algorithms exist for computing LCS, including recursive, memoized recursive, and dynamic programming approaches</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Naive recursive: Simple but exponential time complexity O(2^n)</li>\n<li>Memoized recursive: Better performance but complex stack management</li>\n<li>Dynamic programming matrix: O(mn) time and space with clear implementation</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Use bottom-up dynamic programming with explicit matrix construction</li>\n<li><strong>Rationale</strong>: Provides predictable O(mn) performance, easier debugging through matrix inspection, and straightforward backtracking for sequence recovery</li>\n<li><strong>Consequences</strong>: Higher memory usage for large files but excellent performance characteristics and implementation clarity for learning purposes</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Algorithm Approach</th>\n<th>Time Complexity</th>\n<th>Space Complexity</th>\n<th>Debuggability</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Naive Recursive</td>\n<td>O(2^n)</td>\n<td>O(n) stack</td>\n<td>Poor</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td>Memoized Recursive</td>\n<td>O(mn)</td>\n<td>O(mn) + stack</td>\n<td>Medium</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td><strong>DP Matrix (Chosen)</strong></td>\n<td><strong>O(mn)</strong></td>\n<td><strong>O(mn)</strong></td>\n<td><strong>Excellent</strong></td>\n<td><strong>Medium</strong></td>\n</tr>\n</tbody></table>\n<p>The dynamic programming solution builds a two-dimensional matrix where each cell <code>[i][j]</code> represents the length of the LCS for the first <code>i</code> elements of sequence 1 and the first <code>j</code> elements of sequence 2. This bottom-up approach systematically solves smaller subproblems to construct the solution for the full problem.</p>\n<h4 id=\"matrix-construction-algorithm\">Matrix Construction Algorithm</h4>\n<p>The matrix construction follows a systematic pattern that builds the LCS length table:</p>\n<ol>\n<li><p><strong>Initialize the matrix</strong> with dimensions <code>(len(sequence1) + 1) × (len(sequence2) + 1)</code> to accommodate empty sequence cases. The extra row and column represent empty prefixes with LCS length zero.</p>\n</li>\n<li><p><strong>Set base cases</strong> by filling the first row and first column with zeros, representing that the LCS of any sequence with an empty sequence has length zero.</p>\n</li>\n<li><p><strong>Fill the matrix iteratively</strong> using the recurrence relation. For each cell <code>[i][j]</code>, compare <code>sequence1[i-1]</code> with <code>sequence2[j-1]</code> (subtracting 1 because matrix indices are offset by 1).</p>\n</li>\n<li><p><strong>Apply the recurrence relation</strong>: If the elements match, set <code>matrix[i][j] = matrix[i-1][j-1] + 1</code> (extending the LCS of the prefixes). If they don&#39;t match, set <code>matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1])</code> (taking the better of excluding one element or the other).</p>\n</li>\n<li><p><strong>Complete the matrix</strong> by processing all cells in row-major order, ensuring each cell depends only on previously computed values.</p>\n</li>\n<li><p><strong>Extract the LCS length</strong> from the bottom-right cell <code>matrix[len(sequence1)][len(sequence2)]</code>, which represents the LCS length for the complete sequences.</p>\n</li>\n</ol>\n<p>The recurrence relation captures the essential logic of LCS computation. When elements match, we can extend the best solution for the shorter prefixes. When they don&#39;t match, we take the better of two options: either exclude the current element from sequence 1 or exclude it from sequence 2. This greedy choice at each step leads to the globally optimal solution due to the optimal substructure property.</p>\n<h4 id=\"backtracking-algorithm-for-sequence-recovery\">Backtracking Algorithm for Sequence Recovery</h4>\n<p>Building the matrix gives us the LCS length, but we need the actual sequence for diff generation. The backtracking algorithm reconstructs the LCS by tracing backwards through the matrix:</p>\n<ol>\n<li><p><strong>Start at the bottom-right corner</strong> <code>[len(sequence1)][len(sequence2)]</code> where the complete LCS length is stored.</p>\n</li>\n<li><p><strong>Initialize tracking variables</strong> for the current matrix position <code>(i, j)</code> and an empty list to collect LCS elements in reverse order.</p>\n</li>\n<li><p><strong>Trace backwards through the matrix</strong> by examining how each cell was computed. If <code>sequence1[i-1] == sequence2[j-1]</code>, this element is part of the LCS, so add it to the result and move diagonally to <code>[i-1][j-1]</code>.</p>\n</li>\n<li><p><strong>Handle non-matching elements</strong> by moving toward the cell that contributed the maximum value. If <code>matrix[i-1][j] &gt; matrix[i][j-1]</code>, move up to <code>[i-1][j]</code>. Otherwise, move left to <code>[i][j-1]</code>.</p>\n</li>\n<li><p><strong>Continue until reaching the top or left edge</strong> where the matrix values are zero, indicating we&#39;ve traced back to empty sequence prefixes.</p>\n</li>\n<li><p><strong>Reverse the collected elements</strong> since backtracking produces them in reverse order, yielding the actual LCS.</p>\n</li>\n</ol>\n<p>The backtracking process also captures the positions where LCS elements occur in both original sequences, which becomes crucial for diff generation. By tracking the <code>(i-1, j-1)</code> coordinates when we find matching elements, we build a mapping showing where each common line appears in both files.</p>\n<h4 id=\"lcs-engine-data-structures\">LCS Engine Data Structures</h4>\n<p>The <code>LCSEngine</code> component manages the dynamic programming computation and provides a clean interface for the rest of the system:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>matrix</code></td>\n<td><code>list[list[int]]</code></td>\n<td>The dynamic programming table storing LCS lengths for all subproblems</td>\n</tr>\n<tr>\n<td><code>sequence1</code></td>\n<td><code>Sequence</code></td>\n<td>The first input sequence (typically lines from file 1)</td>\n</tr>\n<tr>\n<td><code>sequence2</code></td>\n<td><code>Sequence</code></td>\n<td>The second input sequence (typically lines from file 2)</td>\n</tr>\n<tr>\n<td><code>lcs_length</code></td>\n<td><code>int</code></td>\n<td>The length of the computed LCS, cached after matrix construction</td>\n</tr>\n<tr>\n<td><code>computation_stats</code></td>\n<td><code>dict</code></td>\n<td>Performance metrics including matrix size and computation time</td>\n</tr>\n</tbody></table>\n<p>The <code>CommonSubsequence</code> structure encapsulates the complete LCS result:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>elements</code></td>\n<td><code>list[str]</code></td>\n<td>The actual LCS elements in sequence order</td>\n</tr>\n<tr>\n<td><code>length</code></td>\n<td><code>int</code></td>\n<td>The number of elements in the LCS</td>\n</tr>\n<tr>\n<td><code>positions1</code></td>\n<td><code>list[int]</code></td>\n<td>Zero-based indices where LCS elements appear in sequence1</td>\n</tr>\n<tr>\n<td><code>positions2</code></td>\n<td><code>list[int]</code></td>\n<td>Zero-based indices where LCS elements appear in sequence2</td>\n</tr>\n</tbody></table>\n<p>The position lists enable the Diff Generator to identify exactly which lines are unchanged and where they occur in both files, forming the anchor points around which insertions and deletions are organized.</p>\n<h4 id=\"lcs-engine-interface\">LCS Engine Interface</h4>\n<p>The <code>LCSEngine</code> exposes a focused interface that encapsulates the dynamic programming complexity:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>compute_lcs</code></td>\n<td><code>sequence1: Sequence, sequence2: Sequence</code></td>\n<td><code>CommonSubsequence</code></td>\n<td>Main entry point that builds matrix and extracts LCS</td>\n</tr>\n<tr>\n<td><code>build_lcs_matrix</code></td>\n<td><code>seq1: Sequence, seq2: Sequence</code></td>\n<td><code>list[list[int]]</code></td>\n<td>Constructs the dynamic programming matrix</td>\n</tr>\n<tr>\n<td><code>backtrack</code></td>\n<td><code>matrix: list[list[int]], seq1: Sequence, seq2: Sequence</code></td>\n<td><code>CommonSubsequence</code></td>\n<td>Recovers the actual LCS from the completed matrix</td>\n</tr>\n<tr>\n<td><code>get_matrix_cell</code></td>\n<td><code>i: int, j: int</code></td>\n<td><code>int</code></td>\n<td>Safe matrix access with bounds checking</td>\n</tr>\n<tr>\n<td><code>clear_matrix</code></td>\n<td><code>None</code></td>\n<td><code>None</code></td>\n<td>Releases matrix memory after computation</td>\n</tr>\n</tbody></table>\n<h3 id=\"memory-optimization-strategies\">Memory Optimization Strategies</h3>\n<p>The standard LCS dynamic programming approach requires O(mn) space for the matrix, which becomes problematic for large files. A 10,000-line file compared against another 10,000-line file requires a 100-million-cell matrix, consuming significant memory.</p>\n<blockquote>\n<p><strong>Decision: Adaptive Memory Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Large files can exhaust available memory with O(mn) matrix storage, but different use cases have different memory constraints</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Always use O(mn) matrix: Simple but fails on large files</li>\n<li>Always use Hirschberg&#39;s algorithm: O(n) space but complex implementation</li>\n<li>Adaptive approach: Choose strategy based on input size</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement adaptive memory management with configurable thresholds</li>\n<li><strong>Rationale</strong>: Provides optimal performance for small-medium files while gracefully handling large files through space-efficient algorithms</li>\n<li><strong>Consequences</strong>: More complex implementation but handles full range of input sizes from small config files to large source files</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Space Complexity</th>\n<th>Implementation Complexity</th>\n<th>Performance</th>\n<th>File Size Limit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Standard Matrix (Chosen for &lt;1M cells)</strong></td>\n<td><strong>O(mn)</strong></td>\n<td><strong>Low</strong></td>\n<td><strong>Best</strong></td>\n<td><strong>~1000×1000 lines</strong></td>\n</tr>\n<tr>\n<td><strong>Two-Row Optimization</strong></td>\n<td><strong>O(min(m,n))</strong></td>\n<td><strong>Medium</strong></td>\n<td><strong>Good</strong></td>\n<td><strong>~10K×10K lines</strong></td>\n</tr>\n<tr>\n<td><strong>Hirschberg&#39;s Algorithm</strong></td>\n<td><strong>O(m+n)</strong></td>\n<td><strong>High</strong></td>\n<td><strong>Slower</strong></td>\n<td><strong>Unlimited</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"two-row-optimization\">Two-Row Optimization</h4>\n<p>For computing just the LCS length without sequence recovery, we can reduce space complexity to O(min(m,n)) by observing that each matrix row depends only on the previous row. This optimization maintains two arrays instead of the full matrix:</p>\n<p>The algorithm maintains <code>current_row</code> and <code>previous_row</code> arrays, updating them as it processes each row of the conceptual matrix. After processing each row, the roles swap: <code>current_row</code> becomes <code>previous_row</code> for the next iteration. This approach reduces memory usage by a factor of max(m,n) while maintaining the same time complexity.</p>\n<p>However, this optimization complicates backtracking since we no longer have the full matrix. For diff tools, we need the actual LCS sequence, not just its length, so this optimization applies primarily to preliminary size checking or when combined with more sophisticated space-efficient algorithms.</p>\n<h4 id=\"hirschberg39s-algorithm-consideration\">Hirschberg&#39;s Algorithm Consideration</h4>\n<p>Hirschberg&#39;s algorithm achieves O(m+n) space complexity while still recovering the actual LCS through a divide-and-conquer approach. The algorithm recursively splits the problem in half, using the two-row optimization to find the optimal splitting point, then recursively processes each half.</p>\n<p>For our diff tool, Hirschberg&#39;s algorithm becomes relevant when comparing very large files that exceed available memory with the standard matrix approach. The implementation complexity significantly increases, involving recursive partitioning and careful coordinate tracking across subproblems.</p>\n<blockquote>\n<p>The key insight is that Hirschberg&#39;s algorithm trades time for space — it performs multiple passes over the data to avoid storing the complete matrix, resulting in roughly double the computation time but dramatically reduced memory usage.</p>\n</blockquote>\n<h4 id=\"adaptive-memory-management-implementation\">Adaptive Memory Management Implementation</h4>\n<p>Our LCS engine implements adaptive memory management by estimating memory requirements before choosing the algorithm:</p>\n<ol>\n<li><p><strong>Calculate matrix size requirements</strong> by multiplying sequence lengths and estimating memory per cell (typically 4-8 bytes for integers).</p>\n</li>\n<li><p><strong>Compare against available memory</strong> using system memory detection and configured memory limits for the diff process.</p>\n</li>\n<li><p><strong>Select algorithm based on thresholds</strong>: Use standard matrix for small files, two-row optimization for medium files, and Hirschberg&#39;s algorithm for large files that would exceed memory limits.</p>\n</li>\n<li><p><strong>Provide progress feedback</strong> for large file processing, since space-efficient algorithms take longer and users need feedback on processing status.</p>\n</li>\n<li><p><strong>Implement graceful degradation</strong> by falling back to simpler diff approaches (like line-by-line comparison without LCS optimization) if even the space-efficient algorithms encounter memory pressure.</p>\n</li>\n</ol>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Understanding the typical mistakes in LCS implementation helps avoid debugging sessions and ensures robust diff functionality.</p>\n<p>⚠️ <strong>Pitfall: Off-by-One Matrix Indexing</strong></p>\n<p>The most frequent LCS implementation error involves matrix indexing confusion between sequence positions and matrix positions. The matrix has dimensions <code>(m+1) × (n+1)</code> to include empty sequence cases, but sequence elements are accessed using 0-based indexing.</p>\n<p>When filling matrix cell <code>[i][j]</code>, the corresponding sequence elements are <code>sequence1[i-1]</code> and <code>sequence2[j-1]</code>. Forgetting this offset leads to index out-of-bounds errors or comparing wrong elements. The bug manifests as either runtime crashes on boundary cases or subtly incorrect LCS results where elements appear to match when they shouldn&#39;t.</p>\n<p><strong>Fix</strong>: Always use <code>sequence1[i-1]</code> and <code>sequence2[j-1]</code> when filling matrix cell <code>[i][j]</code>, and carefully trace through boundary cases with empty sequences to verify indexing logic.</p>\n<p>⚠️ <strong>Pitfall: Empty Sequence Handling</strong></p>\n<p>Empty files or sequences with no matching elements create edge cases that break poorly implemented LCS algorithms. Common issues include division by zero when calculating progress percentages, null pointer exceptions when accessing empty sequence elements, or infinite loops in backtracking when no valid LCS exists.</p>\n<p>The algorithm should handle empty inputs gracefully: empty sequences have LCS length zero, and backtracking should immediately return an empty result. Additionally, sequences with no common elements should produce an empty LCS, not crash the algorithm.</p>\n<p><strong>Fix</strong>: Explicitly test with empty sequences and implement early returns for trivial cases. Add null checks and boundary validation before accessing sequence elements or matrix cells.</p>\n<p>⚠️ <strong>Pitfall: Memory Explosion on Large Files</strong></p>\n<p>Large files can quickly exhaust available memory without appropriate safeguards. A 50,000-line file compared against another similar file requires a 2.5-billion-cell matrix, consuming 10+ GB of memory with standard integer storage.</p>\n<p>Without memory limits or adaptive algorithms, the diff tool becomes unusable on realistic large files like database dumps, log files, or generated code. The system may freeze, swap thrash, or crash with out-of-memory errors, providing no useful feedback to the user.</p>\n<p><strong>Fix</strong>: Implement memory estimation before matrix allocation, provide user feedback about memory requirements, and implement fallback algorithms for large files. Consider streaming approaches or approximate diff algorithms when exact LCS computation exceeds practical memory limits.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Backtracking Logic</strong></p>\n<p>Backtracking errors produce incorrect LCS sequences even when the matrix construction is correct. Common mistakes include wrong direction choices when matrix values are equal, failing to handle diagonal moves correctly, or reconstructing the sequence in the wrong order.</p>\n<p>These bugs are particularly insidious because the LCS length might be correct while the actual sequence is wrong, leading to malformed diffs that incorrectly identify changed lines. The resulting diff output becomes unreliable and may show spurious additions or deletions.</p>\n<p><strong>Fix</strong>: Implement comprehensive backtracking tests with known input-output pairs, carefully handle tie-breaking when multiple cells have equal values, and verify that backtracking produces sequences that actually appear in both original inputs.</p>\n<p>⚠️ <strong>Pitfall: Performance Degradation with Repetitive Content</strong></p>\n<p>Files with highly repetitive content (like configuration templates, generated code, or data dumps) create performance challenges for LCS algorithms. Many potential matches exist at each step, leading to large matrices with complex backtracking paths.</p>\n<p>While the algorithm complexity remains O(mn), the constant factors become significant, and cache performance degrades due to poor locality of access patterns. The user experiences slow performance even on moderately-sized files with repetitive structure.</p>\n<p><strong>Fix</strong>: Implement preprocessing to identify and handle repetitive patterns efficiently, consider approximate algorithms for files with low diversity, and provide progress feedback for long-running computations on repetitive content.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Flcs-algorithm-flow.svg\" alt=\"LCS Algorithm Execution Flow\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Matrix Storage</td>\n<td><code>list[list[int]]</code> (Python native lists)</td>\n<td><code>numpy.ndarray</code> for large matrices with better memory layout</td>\n</tr>\n<tr>\n<td>Sequence Representation</td>\n<td><code>list[str]</code> (Python native strings)</td>\n<td>Custom <code>Sequence</code> class with lazy loading for large files</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Manual size checking with <code>sys.getsizeof()</code></td>\n<td>Memory-mapped files with <code>mmap</code> for huge sequences</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Simple time tracking with <code>time.perf_counter()</code></td>\n<td><code>cProfile</code> integration for detailed algorithm profiling</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The LCS Engine fits into the project structure as a focused algorithmic component:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff_tool/\n├── core/\n│   ├── __init__.py\n│   ├── lcs_engine.py          ← main LCS implementation\n│   ├── lcs_types.py           ← CommonSubsequence and related types\n│   └── memory_optimizer.py    ← adaptive memory management\n├── utils/\n│   ├── sequence_utils.py      ← sequence preprocessing helpers  \n│   └── performance_monitor.py ← computation timing and stats\n└── tests/\n    ├── test_lcs_engine.py     ← comprehensive LCS algorithm tests\n    ├── test_lcs_edge_cases.py ← empty sequences, large files, etc.\n    └── fixtures/              ← test data files with known LCS results</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Memory Management Helper</strong> (<code>core/memory_optimizer.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple, Literal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MemoryStrategy</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm: Literal[</span><span style=\"color:#9ECBFF\">\"matrix\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"two_row\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"hirschberg\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_memory_mb: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    estimated_time_factor: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MemoryOptimizer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determines optimal LCS algorithm based on available memory and input size.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_memory_percent: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_memory_percent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_memory_percent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        available_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.virtual_memory().available</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_memory_bytes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> available_memory </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> max_memory_percent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> choose_strategy</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> MemoryStrategy:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Choose LCS algorithm based on memory requirements and available resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        matrix_cells </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (seq1_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> (seq2_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        matrix_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> matrix_cells </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#6A737D\">  # 8 bytes per int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> matrix_memory </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.max_memory_bytes:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> MemoryStrategy(</span><span style=\"color:#9ECBFF\">\"matrix\"</span><span style=\"color:#E1E4E8\">, matrix_memory </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> seq1_len </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.max_memory_bytes:  </span><span style=\"color:#6A737D\"># Two row optimization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> MemoryStrategy(</span><span style=\"color:#9ECBFF\">\"two_row\"</span><span style=\"color:#E1E4E8\">, seq1_len </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> MemoryStrategy(</span><span style=\"color:#9ECBFF\">\"hirschberg\"</span><span style=\"color:#E1E4E8\">, (seq1_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> seq2_len) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2.5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> estimate_computation_time</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, strategy: MemoryStrategy) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Estimate computation time in seconds based on sequence length and strategy.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_operations </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq1_len </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> seq2_len</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Rough estimate: 1M operations per second baseline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base_operations </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1_000_000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> base_time </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> strategy.estimated_time_factor</span></span></code></pre></div>\n\n<p><strong>Complete Performance Monitor</strong> (<code>utils/performance_monitor.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ComputationStats</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Statistics collected during LCS computation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_time: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.perf_counter)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    end_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matrix_size: Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_used_mb: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm_used: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"matrix\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lcs_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">property</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> computation_time</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end_time </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> time.perf_counter() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finish</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark computation as complete.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceMonitor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Tracks performance metrics during LCS computation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_stats: Optional[ComputationStats] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_computation</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> ComputationStats:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Begin tracking a new LCS computation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ComputationStats(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            matrix_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">(seq1_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, seq2_len </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            algorithm_used</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">algorithm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finish_computation</span><span style=\"color:#E1E4E8\">(self, lcs_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> ComputationStats:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Complete the current computation tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_stats </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No computation in progress\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_stats.lcs_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lcs_length</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_stats.finish()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_stats</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> report_progress</span><span style=\"color:#E1E4E8\">(self, current_row: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, total_rows: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Report progress during matrix construction.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_stats </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> current_row </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            progress </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (current_row </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> total_rows) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_stats.start_time</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"LCS Progress: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">progress</span><span style=\"color:#F97583\">:.1f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">% (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">current_row</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">total_rows</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> rows, </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">elapsed</span><span style=\"color:#F97583\">:.1f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">s)\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main LCS Engine</strong> (<code>core/lcs_engine.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .lcs_types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> CommonSubsequence, Sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .memory_optimizer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> MemoryOptimizer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.performance_monitor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PerformanceMonitor</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LCSEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Implements dynamic programming LCS algorithm with adaptive memory management.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_memory_percent: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.memory_optimizer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MemoryOptimizer(max_memory_percent)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.performance_monitor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PerformanceMonitor()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.matrix: Optional[List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compute_lcs</span><span style=\"color:#E1E4E8\">(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Find the longest common subsequence using dynamic programming.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This is the main entry point that orchestrates matrix construction,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        backtracking, and memory optimization based on input size.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Choose memory strategy based on sequence lengths using memory_optimizer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Start performance monitoring for the computation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Build the LCS matrix using the chosen strategy </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract the LCS through backtracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Clean up matrix memory and finish performance monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return CommonSubsequence with elements and position mappings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Handle empty sequences as a special case before matrix construction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> build_lcs_matrix</span><span style=\"color:#E1E4E8\">(self, seq1: Sequence, seq2: Sequence) -> List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Construct the dynamic programming matrix for LCS computation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Creates an (m+1) x (n+1) matrix where matrix[i][j] represents</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        the LCS length for seq1[:i] and seq2[:j].</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create matrix with dimensions (len(seq1)+1) x (len(seq2)+1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize first row and column to zero (base cases)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Fill matrix using double loop over sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For each cell [i,j], compare seq1[i-1] with seq2[j-1]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If elements match: matrix[i][j] = matrix[i-1][j-1] + 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If different: matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1])</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Report progress every 1000 rows for large matrices</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Remember the +1 offset between matrix indices and sequence indices</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> backtrack</span><span style=\"color:#E1E4E8\">(self, matrix: List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]], seq1: Sequence, seq2: Sequence) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Recover the actual LCS from the completed matrix.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Traces backwards from matrix[m][n] to reconstruct the LCS elements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        and their positions in both original sequences.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize tracking variables: i=len(seq1), j=len(seq2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create empty lists for LCS elements and position tracking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: While both i>0 and j>0, examine current matrix cell</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If seq1[i-1] == seq2[j-1], add to LCS and move diagonally</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Otherwise, move toward cell that contributed the maximum value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle remaining elements if one sequence is exhausted first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Reverse collected elements (backtracking gives reverse order)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return CommonSubsequence with elements and position arrays</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Track positions as (i-1, j-1) when adding matching elements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear_matrix</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Release matrix memory after computation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set self.matrix to None to allow garbage collection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Optionally call gc.collect() for immediate memory release</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>LCS Data Types</strong> (<code>core/lcs_types.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type alias for sequence of comparable elements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Sequence </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CommonSubsequence</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of LCS computation with elements and position tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elements: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    positions1: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Indices in first sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    positions2: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Indices in second sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that all lists have consistent lengths.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check that len(elements) == length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check that len(positions1) == len(positions2) == length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Raise ValueError if any length mismatches found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">property</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_empty</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if the LCS is empty (no common elements).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.length </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_element_at_position</span><span style=\"color:#E1E4E8\">(self, lcs_index: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get LCS element and its positions in both original sequences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate lcs_index is within bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return tuple of (element, pos1, pos2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python-Specific Optimizations:</strong></p>\n<ul>\n<li>Use <code>list</code> comprehensions for matrix initialization: <code>[[0] * cols for _ in range(rows)]</code> avoids reference sharing bugs</li>\n<li>Consider <code>array.array(&#39;i&#39;)</code> instead of lists for large matrices to reduce memory overhead</li>\n<li>Use <code>sys.getsizeof()</code> to measure actual memory usage of data structures</li>\n<li>Profile with <code>cProfile</code> to identify bottlenecks in matrix construction vs. backtracking</li>\n<li>For very large sequences, consider <code>numpy</code> arrays with <code>dtype=np.int32</code> for better cache performance</li>\n</ul>\n<p><strong>Memory Management:</strong></p>\n<ul>\n<li>Monitor memory usage with <code>psutil.Process().memory_info().rss</code> during computation</li>\n<li>Implement matrix chunking for files larger than available memory</li>\n<li>Use <code>gc.collect()</code> after clearing large matrices to ensure immediate memory release</li>\n<li>Consider <code>mmap</code> for reading very large files without loading entirely into memory</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the LCS Engine component, verify the following behavior:</p>\n<p><strong>Unit Test Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_lcs_engine.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Test Results:</strong></p>\n<ul>\n<li><code>test_empty_sequences</code>: LCS of empty sequences returns empty CommonSubsequence</li>\n<li><code>test_identical_sequences</code>: LCS of identical sequences returns the full sequence</li>\n<li><code>test_no_common_elements</code>: LCS of completely different sequences returns empty result</li>\n<li><code>test_simple_lcs</code>: Known input-output pairs produce expected LCS elements and positions</li>\n<li><code>test_matrix_construction</code>: Matrix dimensions and values match hand-calculated examples</li>\n<li><code>test_backtracking_accuracy</code>: Backtracking produces sequences that actually exist in both inputs</li>\n</ul>\n<p><strong>Manual Verification:</strong></p>\n<p>Create test files with known LCS results:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test with simple sequences</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">seq1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"D\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"E\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">seq2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"E\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"F\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected LCS: [\"A\", \"C\", \"E\"] at positions ([0,2,4], [0,1,2])</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LCSEngine()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> engine.compute_lcs(seq1, seq2)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"LCS: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result.elements</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Should show [\"A\", \"C\", \"E\"]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Length: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result.length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\"># Should show 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Positions: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result.positions1</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">result.positions2</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\"># Should show [0,2,4], [0,1,2]</span></span></code></pre></div>\n\n<p><strong>Performance Verification:</strong></p>\n<p>Test memory optimization with large sequences:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Generate large test sequences</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">seq1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"line_</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">seq2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"line_</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> else</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"different_</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LCSEngine(</span><span style=\"color:#FFAB70\">max_memory_percent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Restrict memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> engine.compute_lcs(seq1, seq2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should complete without memory errors and choose appropriate algorithm</span></span></code></pre></div>\n\n<p><strong>Signs of Problems:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IndexError during matrix construction</td>\n<td>Off-by-one in sequence access</td>\n<td>Use <code>seq[i-1]</code> when filling <code>matrix[i][j]</code></td>\n</tr>\n<tr>\n<td>Wrong LCS length but no crash</td>\n<td>Incorrect recurrence relation</td>\n<td>Verify max() logic and diagonal increment</td>\n</tr>\n<tr>\n<td>Empty LCS for sequences with obvious matches</td>\n<td>Backtracking logic error</td>\n<td>Check direction choices and sequence comparison</td>\n</tr>\n<tr>\n<td>Memory errors on medium files</td>\n<td>No memory optimization</td>\n<td>Implement strategy selection based on input size</td>\n</tr>\n<tr>\n<td>Slow performance on repetitive content</td>\n<td>Poor cache locality</td>\n<td>Consider preprocessing or approximate algorithms</td>\n</tr>\n</tbody></table>\n<h2 id=\"diff-generator-component\">Diff Generator Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3: Diff Generation — converts LCS results into edit operations and groups them into contextual hunks with unified diff format</p>\n</blockquote>\n<p>The <code>DiffGenerator</code> component bridges the gap between algorithmic computation and human-readable output. While the <code>LCSEngine</code> identifies which lines are common between files, the diff generator transforms this mathematical result into actionable editing instructions that clearly communicate what changed, where it changed, and how much context surrounds each change.</p>\n<h3 id=\"mental-model-editorial-instructions\">Mental Model: Editorial Instructions</h3>\n<p>Think of the <code>DiffGenerator</code> as a professional editor creating revision instructions for a manuscript. When an editor compares two drafts of a document, they don&#39;t just identify differences—they create clear, structured instructions that tell the author exactly what to add, delete, or keep unchanged. These instructions are grouped into logical sections with enough surrounding context that the author can understand the intent behind each change.</p>\n<p>Just as an editor might group related changes together (&quot;In the third paragraph, delete the second sentence and add these two new sentences&quot;), our diff generator groups nearby line changes into <strong>hunks</strong> with surrounding <strong>context lines</strong>. The editor provides context by showing unchanged sentences around the edits, and our diff generator includes unchanged lines around modifications so readers can orient themselves within the file structure.</p>\n<p>The editorial analogy extends to the output format: professional editing uses standardized notation (strike-through for deletions, highlights for additions, margin notes for instructions), while our diff generator uses the <strong>unified diff format</strong> with <code>-</code> for deletions, <code>+</code> for additions, and space-prefixed lines for context. Both systems prioritize clarity and actionability over raw algorithmic output.</p>\n<h3 id=\"edit-script-generation\">Edit Script Generation</h3>\n<p>The process of converting LCS results into edit operations requires translating from the mathematical representation of common subsequences to the practical representation of file modifications. The LCS algorithm identifies which lines exist in both files, but the diff generator must determine the editing operations needed to transform the first file into the second file.</p>\n<p>The conversion algorithm works by walking through both input files simultaneously while consulting the LCS result to determine the fate of each line. This three-way comparison—original file, target file, and common subsequence—allows the generator to categorize every line as unchanged, deleted, or added.</p>\n<blockquote>\n<p><strong>Decision: Line-by-Line Edit Operation Classification</strong></p>\n<ul>\n<li><strong>Context</strong>: The LCS result identifies common lines but doesn&#39;t directly specify edit operations. We need to transform this into explicit ADD, DELETE, and UNCHANGED classifications.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Generate edit operations directly from LCS positions</li>\n<li>Use diff algorithm to reconstruct operations from LCS</li>\n<li>Implement Myers&#39; algorithm for direct edit script generation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Generate edit operations by comparing file positions against LCS positions</li>\n<li><strong>Rationale</strong>: This approach leverages our existing LCS implementation while remaining conceptually straightforward for learners. Myers&#39; algorithm is more efficient but adds complexity beyond the core learning goals.</li>\n<li><strong>Consequences</strong>: Enables clear separation between LCS computation and diff generation, making the code more modular and easier to debug. Performance is adequate for typical file sizes.</li>\n</ul>\n</blockquote>\n<p>The <code>lcs_to_edit_operations</code> function implements this classification by maintaining three pointers: one for each input file and one for the LCS positions. As it advances through the files, it determines whether each line should be classified as unchanged (present in LCS), deleted (in first file but not LCS), or added (in second file but not LCS).</p>\n<table>\n<thead>\n<tr>\n<th>Edit Operation</th>\n<th>Detection Logic</th>\n<th>Line Numbering</th>\n<th>Content Source</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>UNCHANGED</code></td>\n<td>Line position matches LCS position</td>\n<td>Both old and new line numbers</td>\n<td>Content from either file (identical)</td>\n</tr>\n<tr>\n<td><code>DELETED</code></td>\n<td>Line in file1 but not at current LCS position</td>\n<td>Old line number only</td>\n<td>Content from first file</td>\n</tr>\n<tr>\n<td><code>ADDED</code></td>\n<td>Line in file2 but not at current LCS position</td>\n<td>New line number only</td>\n<td>Content from second file</td>\n</tr>\n</tbody></table>\n<p>The algorithm maintains careful tracking of line numbers for each file, as the unified diff format requires accurate position information. Deleted lines reference their position in the original file, added lines reference their position in the target file, and unchanged lines reference positions in both files.</p>\n<p>Consider a concrete example where the LCS identifies that lines 2, 4, and 7 from the first file correspond to lines 2, 5, and 8 in the second file. The edit script generation proceeds as follows:</p>\n<ol>\n<li><strong>Line 1 of file1</strong>: Not in LCS positions, so mark as <code>DELETED</code> with <code>old_line_num=1</code></li>\n<li><strong>Line 1 of file2</strong>: Not in LCS positions, so mark as <code>ADDED</code> with <code>new_line_num=1</code>  </li>\n<li><strong>Line 2 of both files</strong>: Matches LCS position, so mark as <code>UNCHANGED</code> with <code>old_line_num=2, new_line_num=2</code></li>\n<li><strong>Line 3 of file1</strong>: Not in LCS positions, so mark as <code>DELETED</code> with <code>old_line_num=3</code></li>\n<li><strong>Lines 3-4 of file2</strong>: Line 3 not in LCS, line 4 not in LCS, so both marked as <code>ADDED</code></li>\n<li>Continue this pattern through both files</li>\n</ol>\n<p>The resulting edit script provides a complete transformation recipe that can convert the first file into the second file through a sequence of line operations.</p>\n<blockquote>\n<p>The critical insight is that edit operations are not just about identifying changes—they must preserve enough information to reconstruct either file from the other. This is why line numbering accuracy is essential for tools that apply diff output.</p>\n</blockquote>\n<h3 id=\"hunk-formation-and-context\">Hunk Formation and Context</h3>\n<p>Raw edit operations provide complete transformation information but lack the contextual grouping that makes diffs readable and actionable. <strong>Hunk formation</strong> addresses this by clustering nearby changes together and surrounding them with unchanged lines that provide visual and logical context.</p>\n<p>The hunk formation algorithm operates on the principle that changes separated by only a few unchanged lines are more comprehensible when presented together rather than as separate modification blocks. This mirrors how readers naturally process textual changes—they need enough surrounding context to understand the purpose and scope of modifications.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fhunk-formation-flow.svg\" alt=\"Hunk Formation Process\"></p>\n<p>The <code>diff_lines_to_hunks</code> function implements a sliding window approach to group edit operations. It scans through the sequence of <code>DiffLine</code> objects, identifying boundaries where hunks should begin and end based on configurable <strong>context line</strong> counts and gap thresholds between changes.</p>\n<table>\n<thead>\n<tr>\n<th>Hunk Formation Parameter</th>\n<th>Default Value</th>\n<th>Purpose</th>\n<th>Impact of Increasing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>context_lines</code></td>\n<td>3</td>\n<td>Lines of unchanged context around each change</td>\n<td>More context but larger hunks</td>\n</tr>\n<tr>\n<td><code>max_gap</code></td>\n<td>2 × <code>context_lines</code></td>\n<td>Maximum unchanged lines between changes in same hunk</td>\n<td>Fewer, larger hunks</td>\n</tr>\n<tr>\n<td><code>min_hunk_size</code></td>\n<td>1</td>\n<td>Minimum number of changed lines per hunk</td>\n<td>Filters out tiny modifications</td>\n</tr>\n</tbody></table>\n<p>The algorithm maintains state about the current hunk being constructed and decides whether to extend it or start a new one based on the gap between changes. When encountering a sequence of unchanged lines, it determines whether these should become inter-change context (keeping the hunk open) or hunk separator lines (closing the current hunk and starting a new one).</p>\n<blockquote>\n<p><strong>Decision: Context Line Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Diffs need surrounding unchanged lines for readability, but too much context creates overwhelming output while too little context provides insufficient orientation.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fixed context count (e.g., always 3 lines before and after)</li>\n<li>Adaptive context based on change density</li>\n<li>Configurable context with intelligent merging</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable fixed context with automatic hunk merging when gaps are small</li>\n<li><strong>Rationale</strong>: Provides predictable output size while allowing users to adjust based on their needs. Automatic merging prevents fragmentation of closely-related changes.</li>\n<li><strong>Consequences</strong>: Simple implementation that covers most use cases. Users can increase context for complex changes or decrease it for focused reviews.</li>\n</ul>\n</blockquote>\n<p>The hunk boundary detection logic examines sequences of unchanged lines to determine their role:</p>\n<ol>\n<li><strong>Leading context</strong>: Up to <code>context_lines</code> unchanged lines before the first change in a hunk</li>\n<li><strong>Inter-change context</strong>: Unchanged lines between two changes within the same hunk</li>\n<li><strong>Trailing context</strong>: Up to <code>context_lines</code> unchanged lines after the last change in a hunk</li>\n<li><strong>Separator lines</strong>: Unchanged lines that are too numerous to serve as context, indicating a hunk boundary</li>\n</ol>\n<p>Each <code>Hunk</code> object encapsulates a complete modification unit with its surrounding context:</p>\n<table>\n<thead>\n<tr>\n<th>Hunk Field</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>old_start</code></td>\n<td>int</td>\n<td>Starting line number in original file (1-indexed)</td>\n<td>45</td>\n</tr>\n<tr>\n<td><code>old_count</code></td>\n<td>int</td>\n<td>Number of lines from original file in this hunk</td>\n<td>7</td>\n</tr>\n<tr>\n<td><code>new_start</code></td>\n<td>int</td>\n<td>Starting line number in target file (1-indexed)</td>\n<td>45</td>\n</tr>\n<tr>\n<td><code>new_count</code></td>\n<td>int</td>\n<td>Number of lines from target file in this hunk</td>\n<td>9</td>\n</tr>\n<tr>\n<td><code>lines</code></td>\n<td>list[DiffLine]</td>\n<td>Complete sequence of context and changed lines</td>\n<td>[context, deletion, addition, context]</td>\n</tr>\n<tr>\n<td><code>context_before</code></td>\n<td>int</td>\n<td>Actual leading context lines included</td>\n<td>3</td>\n</tr>\n<tr>\n<td><code>context_after</code></td>\n<td>int</td>\n<td>Actual trailing context lines included</td>\n<td>2</td>\n</tr>\n</tbody></table>\n<p>The unified diff format represents each hunk with a header line that summarizes its scope: <code>@@ -45,7 +45,9 @@</code>. This header communicates that the hunk starts at line 45 in the original file and includes 7 lines, while starting at line 45 in the target file and including 9 lines. The difference in line counts (9 - 7 = 2) immediately indicates that this hunk represents a net addition of 2 lines.</p>\n<p>Context line management requires careful boundary handling to avoid duplicating lines between adjacent hunks or exceeding file boundaries. The algorithm tracks available context at the beginning and end of files, adjusting the actual context counts when insufficient lines exist.</p>\n<p>Consider the hunk merging decision process for two potential hunks separated by 4 unchanged lines when <code>context_lines=3</code>:</p>\n<ol>\n<li><strong>First hunk</strong>: Wants 3 lines of trailing context</li>\n<li><strong>Gap</strong>: 4 unchanged lines exist between hunks  </li>\n<li><strong>Second hunk</strong>: Wants 3 lines of leading context</li>\n<li><strong>Total requirement</strong>: 3 + 4 + 3 = 10 lines to represent separately</li>\n<li><strong>Merged requirement</strong>: 4 lines as inter-change context</li>\n<li><strong>Decision</strong>: Merge hunks since merged representation is more compact</li>\n</ol>\n<p>The <code>merge_hunks</code> function implements this logic by checking whether the combined representation would be more efficient than separate hunks. This prevents the creation of tiny hunks separated by minimal context, which creates fragmented and hard-to-follow diffs.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Understanding where diff generation commonly goes wrong helps developers avoid frustrating debugging sessions and incorrect output. These pitfalls often stem from the impedance mismatch between zero-indexed programming languages and one-indexed diff formats, as well as edge cases in file structure and algorithm logic.</p>\n<p>⚠️ <strong>Pitfall: Zero-Based vs One-Based Line Numbering</strong></p>\n<p>Programming languages use zero-based indexing for arrays and lists, but the unified diff format uses one-based line numbering for human readability. This creates a persistent source of off-by-one errors that manifest as incorrect <code>@@ -start,count +start,count @@</code> headers.</p>\n<p>The error typically appears when developers directly use list indices as line numbers in the diff output. For example, if a change occurs at index 5 in a Python list, the correct diff line number is 6, not 5. This mistake becomes particularly problematic when tools attempt to apply the generated diff, as they expect standard one-based numbering.</p>\n<p>The fix requires consistent application of <code>+1</code> conversion when generating line numbers for <code>DiffLine</code> objects and hunk headers. However, the conversion must only apply to external output—internal algorithm logic should continue using zero-based indices for array access.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># WRONG: Using zero-based indices directly\nhunk.old_start = first_change_index  # Results in line 0, which is invalid\n\n# CORRECT: Converting to one-based for external format  \nhunk.old_start = first_change_index + 1  # Results in line 1</code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Files With No Common Lines</strong></p>\n<p>When two files share no common content, the LCS algorithm returns an empty subsequence, which can cause the diff generator to produce degenerate output or crash entirely. This scenario occurs more frequently than expected—when comparing completely different files, generated files with different content, or files where one is empty.</p>\n<p>The symptom appears as either a single massive hunk containing all deletions followed by all additions, or as an error when the algorithm assumes at least some common content exists. Some implementations incorrectly try to create context lines when none exist, leading to array access errors.</p>\n<p>The correct approach treats files with no common lines as a special case: create a single hunk that deletes all lines from the first file and adds all lines from the second file. No context lines exist by definition, so the hunk contains only change operations.</p>\n<p>⚠️ <strong>Pitfall: Context Line Overlap Between Adjacent Hunks</strong></p>\n<p>When changes occur close together in files, the trailing context of one hunk may overlap with the leading context of the next hunk. Naive implementations either duplicate these lines (creating invalid diffs) or crash when trying to create conflicting line number ranges.</p>\n<p>This manifests as hunks with overlapping line number ranges in their headers, such as <code>@@ -10,8 +10,9 @@</code> followed immediately by <code>@@ -15,6 +16,7 @@</code>. The overlap between lines 15-17 creates ambiguity about which hunk owns those lines.</p>\n<p>The solution requires either automatic hunk merging when overlap is detected, or intelligent context truncation that ensures clean boundaries between hunks. The <code>merge_hunks</code> function should be called whenever the distance between hunks is less than <code>2 * context_lines + 1</code>.</p>\n<p>⚠️ <strong>Pitfall: Empty File Handling</strong></p>\n<p>Empty files create edge cases in multiple parts of the diff generation pipeline. When one or both input files are empty, the LCS algorithm may return unexpected results, line numbering becomes ambiguous, and hunk generation may fail to handle the boundary conditions properly.</p>\n<p>The specific failure modes include attempting to access line indices that don&#39;t exist, creating hunks with invalid start positions (like line 0), and generating context lines from files that have no content. Some implementations crash when trying to create <code>DiffLine</code> objects from non-existent content.</p>\n<p>Proper empty file handling requires explicit checks at the beginning of the diff generation process. Empty files should generate straightforward hunks: if the first file is empty, create a single hunk that adds all lines from the second file starting at line 1. If the second file is empty, create a single hunk that deletes all lines from the first file.</p>\n<p>⚠️ <strong>Pitfall: Line Content Modification vs Line Replacement</strong></p>\n<p>The unified diff format represents modified lines as a deletion followed by an addition, not as a single &quot;change&quot; operation. Developers familiar with other diff tools may attempt to create a &quot;MODIFIED&quot; line type, which doesn&#39;t exist in the standard format and breaks compatibility with external tools.</p>\n<p>This misconception leads to implementations that try to highlight changed portions within lines or create custom diff formats that aren&#39;t interoperable with standard tools like <code>patch</code>, <code>git apply</code>, or text editors that understand unified diff format.</p>\n<p>The correct approach always represents line modifications as separate DELETE and ADD operations, even when the lines are nearly identical. Word-level or character-level highlighting is a presentation concern that should be handled by output formatting, not by the core diff generation logic.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Off-by-one line numbers</td>\n<td><code>patch</code> command fails to apply diff</td>\n<td>Using zero-based indices in output</td>\n<td>Add 1 when generating line numbers for external format</td>\n</tr>\n<tr>\n<td>No common lines crash</td>\n<td>Algorithm error with empty LCS</td>\n<td>Assuming LCS contains elements</td>\n<td>Check for empty LCS and handle as special case</td>\n</tr>\n<tr>\n<td>Overlapping hunk contexts</td>\n<td>Invalid diff with conflicting line ranges</td>\n<td>Not merging nearby changes</td>\n<td>Implement hunk merging when gap &lt; 2*context + 1</td>\n</tr>\n<tr>\n<td>Empty file errors</td>\n<td>Array access errors or invalid hunks</td>\n<td>Not handling missing content</td>\n<td>Explicit empty file checks with appropriate hunk generation</td>\n</tr>\n<tr>\n<td>Invalid &quot;MODIFIED&quot; operations</td>\n<td>Incompatible diff output</td>\n<td>Misunderstanding unified diff format</td>\n<td>Always use separate DELETE + ADD for changed lines</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The <code>DiffGenerator</code> component transforms the mathematical output from <code>LCSEngine</code> into human-readable editing instructions. This implementation bridges algorithmic computation with practical text processing requirements.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Edit Operation Storage</td>\n<td>Python lists with dataclasses</td>\n<td>Custom linked list for memory efficiency</td>\n</tr>\n<tr>\n<td>Hunk Generation</td>\n<td>Linear scan with state machine</td>\n<td>Streaming parser for large files</td>\n</tr>\n<tr>\n<td>Line Number Tracking</td>\n<td>Separate counters for each file</td>\n<td>Unified position tracker with offsets</td>\n</tr>\n<tr>\n<td>Context Management</td>\n<td>Fixed-size windows</td>\n<td>Adaptive context based on change density</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff_tool/\n  src/\n    diff_generator/\n      __init__.py              ← exports DiffGenerator, LineType, Hunk\n      diff_generator.py        ← main DiffGenerator class\n      edit_operations.py       ← DiffLine, LineType, edit script generation\n      hunk_formatter.py        ← Hunk class and formation logic\n      context_manager.py       ← context line extraction and merging\n    tests/\n      test_diff_generator.py   ← comprehensive test suite\n      test_hunk_formation.py   ← hunk boundary and merging tests\n      fixtures/\n        simple_diff/           ← basic test cases\n        edge_cases/            ← empty files, no common lines\n        large_files/           ← performance test cases</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>edit_operations.py</strong> - Complete implementation for line classification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Classification of lines in diff output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNCHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unchanged\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ADDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"added\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"deleted\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffLine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a single line in the diff with its classification and position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_type: LineType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># None for ADDED lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># None for DELETED lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_change</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Returns True if this line represents a modification (ADD or DELETE).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.line_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (LineType.</span><span style=\"color:#79B8FF\">ADDED</span><span style=\"color:#E1E4E8\">, LineType.</span><span style=\"color:#79B8FF\">DELETED</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_unified_diff_line</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format this line for unified diff output with appropriate prefix.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.line_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LineType.</span><span style=\"color:#79B8FF\">ADDED</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"+</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.content</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.line_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LineType.</span><span style=\"color:#79B8FF\">DELETED</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"-</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.content</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># UNCHANGED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.content</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_diff_line</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, line_type: LineType, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    old_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    new_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> DiffLine:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Factory function for creating properly validated DiffLine objects.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Validate line number consistency with line type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> line_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LineType.</span><span style=\"color:#79B8FF\">ADDED</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> old_num </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"ADDED lines should not have old_line_num\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> line_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LineType.</span><span style=\"color:#79B8FF\">DELETED</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> new_num </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"DELETED lines should not have new_line_num\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> line_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LineType.</span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> (old_num </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> or</span><span style=\"color:#E1E4E8\"> new_num </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"UNCHANGED lines must have both line numbers\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DiffLine(content, line_type, old_num, new_num)</span></span></code></pre></div>\n\n<p><strong>hunk_formatter.py</strong> - Complete implementation for hunk data structure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .edit_operations </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DiffLine, LineType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Hunk</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a group of related changes with surrounding context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_start: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">          # Starting line number in original file (1-indexed)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">          # Number of lines from original file in this hunk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_start: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">          # Starting line number in target file (1-indexed) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">          # Number of lines from target file in this hunk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines: List[DiffLine]   </span><span style=\"color:#6A737D\"># Complete sequence of context and changed lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_before: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">     # Actual leading context lines included</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_after: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#6A737D\">      # Actual trailing context lines included</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_hunk_header</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate the @@ header line for this hunk.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"@@ -</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.old_start</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.old_count</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> +</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.new_start</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.new_count</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> @@\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_unified_diff</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate complete unified diff output for this hunk.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.format_hunk_header()]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.extend(line.format_unified_diff_line() </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.lines)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> change_count</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Count the number of actual changes (non-context lines) in this hunk.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.lines </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> line.is_change())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_hunk_consistency</span><span style=\"color:#E1E4E8\">(hunk: Hunk) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify that hunk line counts match actual content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> hunk.lines </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   if</span><span style=\"color:#E1E4E8\"> line.line_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (LineType.</span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#E1E4E8\">, LineType.</span><span style=\"color:#79B8FF\">DELETED</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> hunk.lines </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                   if</span><span style=\"color:#E1E4E8\"> line.line_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (LineType.</span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#E1E4E8\">, LineType.</span><span style=\"color:#79B8FF\">ADDED</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (old_lines </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> hunk.old_count </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            new_lines </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> hunk.new_count)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> merge_hunks</span><span style=\"color:#E1E4E8\">(hunk1: Hunk, hunk2: Hunk, max_gap: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Optional[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Merge two adjacent hunks if the gap between them is small enough.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Calculate gap between hunks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hunk1_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk1.old_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> hunk1.old_count </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gap_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk2.old_start </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> hunk1_end </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> gap_size </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> max_gap:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Gap too large to merge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create merged hunk</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    merged_old_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk1.old_start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    merged_old_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk2.old_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> hunk2.old_count </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> hunk1.old_start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    merged_new_start </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk1.new_start  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    merged_new_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk2.new_start </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> hunk2.new_count </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> hunk1.new_start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Combine line sequences (implementation would need gap lines added)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    merged_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk1.lines </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> hunk2.lines  </span><span style=\"color:#6A737D\"># Simplified - needs gap handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> Hunk(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        old_start</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">merged_old_start,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        old_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">merged_old_count,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        new_start</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">merged_new_start,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        new_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">merged_new_count,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        lines</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">merged_lines,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        context_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">hunk1.context_before,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        context_after</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">hunk2.context_after</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p><strong>diff_generator.py</strong> - Main component for learners to implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .edit_operations </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DiffLine, LineType, create_diff_line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .hunk_formatter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Hunk, validate_hunk_consistency, merge_hunks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Converts LCS results into edit operations and groups them into hunks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.default_context_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> default_context_lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> lcs_to_edit_operations</span><span style=\"color:#E1E4E8\">(self, lcs: </span><span style=\"color:#9ECBFF\">'CommonSubsequence'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             file1_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             file2_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> List[DiffLine]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert LCS result to sequence of edit operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lcs: CommonSubsequence result from LCSEngine</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file1_lines: Lines from original file  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file2_lines: Lines from target file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Complete sequence of DiffLine objects representing the transformation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle empty LCS case (no common lines between files)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize pointers for file1, file2, and LCS positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create main loop that advances through both files simultaneously</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For each position, check if current lines match LCS positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If lines match LCS, create UNCHANGED DiffLine with both line numbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If file1 line doesn't match LCS, create DELETED DiffLine </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If file2 line doesn't match LCS, create ADDED DiffLine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Advance appropriate pointers based on operation type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Handle remaining lines when one file is exhausted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Return complete sequence of DiffLine objects</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use enumerate() to track line numbers while iterating</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: LCS positions list tells you which lines are common</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Convert 0-based list indices to 1-based line numbers for output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> diff_lines_to_hunks</span><span style=\"color:#E1E4E8\">(self, diff_lines: List[DiffLine], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Group edit operations into hunks with surrounding context.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            diff_lines: Sequence of DiffLine objects from lcs_to_edit_operations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context_lines: Number of context lines around changes (uses default if None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of Hunk objects with changes grouped and context included</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> context_lines </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.default_context_lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle empty diff_lines list (identical files)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Scan through diff_lines to identify change boundaries  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each change group, collect surrounding context lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Determine hunk start/end positions in both files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Extract context_before lines (up to context_lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Include all change lines in the group</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Extract context_after lines (up to context_lines) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Create Hunk object with proper line counts and positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Validate hunk consistency using validate_hunk_consistency()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Check if adjacent hunks should be merged using merge_hunks()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Return final list of non-overlapping hunks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Track current position in both original and target files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use sliding window to collect context around changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: max_gap for merging should be 2 * context_lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_diff</span><span style=\"color:#E1E4E8\">(self, file1_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], file2_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     lcs: </span><span style=\"color:#9ECBFF\">'CommonSubsequence'</span><span style=\"color:#E1E4E8\">, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Main entry point: convert LCS result to structured diff hunks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file1_lines: Lines from original file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file2_lines: Lines from target file  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lcs: CommonSubsequence result from LCSEngine.compute_lcs()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context_lines: Number of context lines around changes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of Hunk objects ready for formatting and output</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call lcs_to_edit_operations() to get edit sequence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call diff_lines_to_hunks() to group operations with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return structured hunks ready for output formatting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This is the main pipeline function that coordinates the conversion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Line Number Handling</strong>: Python lists are 0-indexed but diff format uses 1-indexed line numbers. Always add 1 when creating external output.</li>\n<li><strong>Dataclass Usage</strong>: Use <code>@dataclass</code> for <code>DiffLine</code> and <code>Hunk</code> to get automatic <code>__init__</code>, <code>__repr__</code>, and comparison methods.</li>\n<li><strong>Enum for LineType</strong>: Use <code>enum.Enum</code> for <code>LineType</code> to ensure type safety and prevent invalid line classifications.</li>\n<li><strong>List Slicing</strong>: Use <code>lines[start:end]</code> for extracting context windows around changes.</li>\n<li><strong>Optional Type Hints</strong>: Use <code>Optional[int]</code> for line numbers that may be None (deleted lines don&#39;t have new numbers, added lines don&#39;t have old numbers).</li>\n<li><strong>Generator Functions</strong>: Consider using <code>yield</code> for large files to avoid loading entire diff in memory.</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the <code>DiffGenerator</code> component, verify correct behavior:</p>\n<p><strong>Test Command</strong>: <code>python -m pytest tests/test_diff_generator.py -v</code></p>\n<p><strong>Expected Output</strong>: All tests pass, including edge cases for empty files, no common lines, and context merging.</p>\n<p><strong>Manual Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test with simple two-line change</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> diff_tool.py</span><span style=\"color:#9ECBFF\"> file1.txt</span><span style=\"color:#9ECBFF\"> file2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output format:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># @@ -1,4 +1,5 @@</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#  unchanged line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># -deleted line  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># +added line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># +another added line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#  unchanged line</span></span></code></pre></div>\n\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>Line numbers start at 0 instead of 1 → Check line number conversion</li>\n<li>Context lines missing → Check hunk boundary calculation  </li>\n<li>Overlapping hunks → Implement hunk merging logic</li>\n<li>Crash on empty files → Add empty file handling</li>\n</ul>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>patch</code> command rejects diff</td>\n<td>Incorrect line numbering</td>\n<td>Check hunk headers for 0-based numbers</td>\n<td>Add 1 to all line numbers in output</td>\n</tr>\n<tr>\n<td>Missing context lines</td>\n<td>Wrong boundary calculation</td>\n<td>Print hunk start/end positions</td>\n<td>Fix context extraction window logic</td>\n</tr>\n<tr>\n<td>Duplicate lines in output</td>\n<td>Overlapping hunks not merged</td>\n<td>Check gap calculation between hunks</td>\n<td>Implement merge_hunks() properly</td>\n</tr>\n<tr>\n<td>Crash on identical files</td>\n<td>Empty diff_lines list not handled</td>\n<td>Test with identical input files</td>\n<td>Add empty list check in diff_lines_to_hunks</td>\n</tr>\n<tr>\n<td>Wrong hunk line counts</td>\n<td>Inconsistent counting logic</td>\n<td>Use validate_hunk_consistency()</td>\n<td>Count UNCHANGED+DELETED for old, UNCHANGED+ADDED for new</td>\n</tr>\n</tbody></table>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fdiff-generation-sequence.svg\" alt=\"Diff Generation Sequence\"></p>\n<p>The <code>DiffGenerator</code> component completes the transformation from mathematical algorithm output to practical editing instructions. When properly implemented, it provides the foundation for human-readable diffs that clearly communicate file changes while maintaining compatibility with standard diff tools and workflows.</p>\n<h2 id=\"output-formatter-component\">Output Formatter Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4: CLI and Color Output — builds command-line interface with colored output and options, plus foundational unified diff format from Milestone 3</p>\n</blockquote>\n<p>The <code>OutputFormatter</code> component represents the final stage in our diff processing pipeline, transforming structured <code>Hunk</code> objects into human-readable unified diff format with optional color highlighting and command-line interface integration. This component bridges the gap between our internal diff representation and the standardized output formats that users expect from professional diff tools.</p>\n<h3 id=\"mental-model-publishing-changes\">Mental Model: Publishing Changes</h3>\n<p>Think of the <code>OutputFormatter</code> as a publishing house editor preparing editorial changes for publication. When an author submits a revised manuscript, the editor doesn&#39;t just show the raw list of insertions and deletions. Instead, they format the changes using standardized editorial notation — strikethroughs for deletions, highlighting for additions, section markers to show where changes occur, and surrounding context so readers can understand the modifications in their proper setting.</p>\n<p>Similarly, our formatter takes the structured diff information from the <code>DiffGenerator</code> and presents it using the universally recognized unified diff format. Just as a publisher might produce different versions of the same content — a black-and-white edition for print, a colorized version for digital readers, or a plain text version for accessibility — our formatter adapts its output based on the target audience and display capabilities.</p>\n<p>The unified diff format serves as the &quot;standard editorial notation&quot; of the software world. Every developer recognizes the <code>-</code> and <code>+</code> prefixes, the <code>@@</code> hunk markers, and the context lines surrounding changes. Our job is to generate this format correctly while enhancing it with modern features like color highlighting when appropriate.</p>\n<h3 id=\"unified-diff-format\">Unified Diff Format</h3>\n<p>The unified diff format represents the lingua franca of change visualization in software development. This standardized format emerged from the Unix <code>diff</code> utility and has been adopted across virtually every version control system, code review tool, and text comparison application. Understanding its structure is crucial for generating output that integrates seamlessly with existing development workflows.</p>\n<h4 id=\"format-structure-and-components\">Format Structure and Components</h4>\n<p>The unified diff format consists of several distinct sections, each serving a specific purpose in communicating changes between files. At the highest level, a unified diff contains a header section identifying the files being compared, followed by one or more hunks representing groups of changes.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Format</th>\n<th>Purpose</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Headers</td>\n<td><code>--- filename1</code> and <code>+++ filename2</code></td>\n<td>Identify source and target files</td>\n<td><code>--- file1.txt</code></td>\n</tr>\n<tr>\n<td>Hunk Header</td>\n<td><code>@@ -old_start,old_count +new_start,new_count @@</code></td>\n<td>Define line ranges for changes</td>\n<td><code>@@ -15,7 +15,9 @@</code></td>\n</tr>\n<tr>\n<td>Context Lines</td>\n<td><code> content</code> (space prefix)</td>\n<td>Show unchanged lines around changes</td>\n<td><code> def calculate_sum():</code></td>\n</tr>\n<tr>\n<td>Deleted Lines</td>\n<td><code>-content</code> (minus prefix)</td>\n<td>Show lines removed from original</td>\n<td><code>-    return x + y</code></td>\n</tr>\n<tr>\n<td>Added Lines</td>\n<td><code>+content</code> (plus prefix)</td>\n<td>Show lines added in new version</td>\n<td><code>+    return x + y + z</code></td>\n</tr>\n<tr>\n<td>Optional Context</td>\n<td>Additional metadata after <code>@@</code></td>\n<td>Provide semantic context</td>\n<td><code>@@ -15,7 +15,9 @@ class Calculator:</code></td>\n</tr>\n</tbody></table>\n<p>The mathematical precision of the hunk header format deserves special attention. The <code>@@ -old_start,old_count +new_start,new_count @@</code> syntax encodes exactly which lines from each file are represented in the hunk. The <code>old_start</code> indicates the line number where the hunk begins in the original file, while <code>old_count</code> specifies how many lines from the original file are included (both context and deleted lines). Similarly, <code>new_start</code> and <code>new_count</code> define the corresponding range in the modified file.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: The unified diff format uses <strong>one-indexed line numbers</strong> for human readability, while most programming languages use zero-indexed arrays internally. This off-by-one translation is a frequent source of bugs in diff implementations.</p>\n</blockquote>\n<h4 id=\"hunk-formation-and-context-integration\">Hunk Formation and Context Integration</h4>\n<p>The process of converting our internal <code>Hunk</code> structures into unified diff format requires careful attention to line numbering, prefix selection, and context integration. Each <code>DiffLine</code> within a hunk must be formatted according to its <code>LineType</code>, with appropriate prefixes and line number tracking.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Format Generation Algorithm:\n1. Generate file headers using original file paths\n2. For each hunk in the diff:\n   a. Calculate actual line ranges including context\n   b. Generate hunk header with @@ syntax\n   c. Format each DiffLine with appropriate prefix\n   d. Track line numbers for both files separately\n   e. Ensure context lines appear in correct positions\n3. Validate that line counts match hunk headers</code></pre></div>\n\n<p>The line number calculation requires maintaining separate counters for the original and modified files as we process each hunk. Context lines contribute to both file&#39;s line counts, deleted lines only increment the original file counter, and added lines only increment the modified file counter.</p>\n<blockquote>\n<p><strong>Decision: Line Number Tracking Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to generate accurate hunk headers with correct line ranges</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Pre-calculate all line numbers before formatting</li>\n<li>Track incrementally during formatting</li>\n<li>Store line numbers in DiffLine structures</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Track incrementally during formatting with validation</li>\n<li><strong>Rationale</strong>: Incremental tracking is memory-efficient and naturally handles edge cases like empty files or hunks with only additions/deletions</li>\n<li><strong>Consequences</strong>: Requires careful counter management but provides flexibility for different output formats</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Line Type</th>\n<th>Original Counter</th>\n<th>Modified Counter</th>\n<th>Output Prefix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UNCHANGED</td>\n<td>+1</td>\n<td>+1</td>\n<td><code> </code> (space)</td>\n</tr>\n<tr>\n<td>DELETED</td>\n<td>+1</td>\n<td>+0</td>\n<td><code>-</code></td>\n</tr>\n<tr>\n<td>ADDED</td>\n<td>+0</td>\n<td>+1</td>\n<td><code>+</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"header-generation-and-file-identification\">Header Generation and File Identification</h4>\n<p>The unified diff header serves a crucial role in identifying the files being compared and providing metadata for tools that consume the diff output. The standard format uses <code>---</code> to identify the original file and <code>+++</code> to identify the modified file, followed by optional timestamps and file mode information.</p>\n<p>Our implementation focuses on the essential file identification while remaining compatible with standard diff consumers. The header generation must handle several edge cases, including missing files (for new file creation or deletion scenarios), different file paths, and special cases like comparing content from standard input.</p>\n<table>\n<thead>\n<tr>\n<th>Header Type</th>\n<th>Format</th>\n<th>Usage</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Original File</td>\n<td><code>--- filepath</code></td>\n<td>Identifies source file</td>\n<td><code>--- /path/to/original.txt</code></td>\n</tr>\n<tr>\n<td>Modified File</td>\n<td><code>+++ filepath</code></td>\n<td>Identifies target file</td>\n<td><code>+++ /path/to/modified.txt</code></td>\n</tr>\n<tr>\n<td>New File</td>\n<td><code>--- /dev/null</code></td>\n<td>Indicates file creation</td>\n<td>When comparing against empty</td>\n</tr>\n<tr>\n<td>Deleted File</td>\n<td><code>+++ /dev/null</code></td>\n<td>Indicates file deletion</td>\n<td>When file was removed</td>\n</tr>\n<tr>\n<td>Stdin Input</td>\n<td><code>--- -</code> or <code>+++ -</code></td>\n<td>Standard input source</td>\n<td>For pipe input scenarios</td>\n</tr>\n</tbody></table>\n<h3 id=\"color-output-and-cli-interface\">Color Output and CLI Interface</h3>\n<p>Modern terminal applications enhance user experience through visual highlighting and interactive features. Our color output system must intelligently detect terminal capabilities, provide user control over formatting, and gracefully degrade when colors are inappropriate or unsupported.</p>\n<h4 id=\"ansi-color-support-and-tty-detection\">ANSI Color Support and TTY Detection</h4>\n<p>Color output relies on ANSI escape sequences to control text formatting in compatible terminals. However, these control codes can corrupt output when redirected to files or consumed by tools that don&#39;t understand ANSI formatting. Our implementation must detect the output destination and apply colors appropriately.</p>\n<table>\n<thead>\n<tr>\n<th>ANSI Code</th>\n<th>Constant</th>\n<th>Purpose</th>\n<th>Terminal Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>\\033[31m</code></td>\n<td><code>RED</code></td>\n<td>Highlight deletions</td>\n<td>Red text</td>\n</tr>\n<tr>\n<td><code>\\033[32m</code></td>\n<td><code>GREEN</code></td>\n<td>Highlight additions</td>\n<td>Green text</td>\n</tr>\n<tr>\n<td><code>\\033[0m</code></td>\n<td><code>RESET</code></td>\n<td>Reset formatting</td>\n<td>Return to normal</td>\n</tr>\n<tr>\n<td><code>\\033[1m</code></td>\n<td><code>BOLD</code></td>\n<td>Emphasize headers</td>\n<td>Bold text</td>\n</tr>\n<tr>\n<td><code>\\033[2m</code></td>\n<td><code>DIM</code></td>\n<td>De-emphasize context</td>\n<td>Dimmed text</td>\n</tr>\n</tbody></table>\n<p>The TTY detection process determines whether the output destination supports color formatting. This involves checking if the output is connected to a terminal device rather than being redirected to a file or piped to another program.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>TTY Detection Algorithm:\n1. Check if output destination is a terminal device\n2. Verify TERM environment variable indicates color support\n3. Respect user preferences via --no-color flag\n4. Default to plain text for non-interactive environments\n5. Provide --force-color flag for special cases</code></pre></div>\n\n<blockquote>\n<p><strong>Decision: Color Application Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to provide helpful visual highlighting while maintaining compatibility with scripts and tools</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Always apply colors and let users disable with flags</li>\n<li>Auto-detect TTY and apply colors only when appropriate</li>\n<li>Default to no colors and require explicit enabling</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Auto-detect TTY with explicit override flags</li>\n<li><strong>Rationale</strong>: Provides the best user experience for interactive use while being safe for scripting and tool integration</li>\n<li><strong>Consequences</strong>: Requires platform-specific TTY detection but maximizes compatibility</li>\n</ul>\n</blockquote>\n<h4 id=\"command-line-argument-processing\">Command-Line Argument Processing</h4>\n<p>The CLI interface provides users with control over diff formatting, output options, and comparison behavior. The argument parsing system must handle file path validation, option conflicts, and provide helpful error messages for invalid usage.</p>\n<table>\n<thead>\n<tr>\n<th>Argument</th>\n<th>Type</th>\n<th>Purpose</th>\n<th>Default</th>\n<th>Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>file1</code></td>\n<td>positional</td>\n<td>First file to compare</td>\n<td>required</td>\n<td>Must exist and be readable</td>\n</tr>\n<tr>\n<td><code>file2</code></td>\n<td>positional</td>\n<td>Second file to compare</td>\n<td>required</td>\n<td>Must exist and be readable</td>\n</tr>\n<tr>\n<td><code>--context N</code></td>\n<td>optional</td>\n<td>Context lines around changes</td>\n<td>3</td>\n<td>Must be non-negative integer</td>\n</tr>\n<tr>\n<td><code>--no-color</code></td>\n<td>flag</td>\n<td>Disable ANSI color output</td>\n<td>false</td>\n<td>Conflicts with --force-color</td>\n</tr>\n<tr>\n<td><code>--force-color</code></td>\n<td>flag</td>\n<td>Enable color even for non-TTY</td>\n<td>false</td>\n<td>Conflicts with --no-color</td>\n</tr>\n<tr>\n<td><code>--side-by-side</code></td>\n<td>flag</td>\n<td>Enable parallel display mode</td>\n<td>false</td>\n<td>Future extension</td>\n</tr>\n<tr>\n<td><code>--unified N</code></td>\n<td>optional</td>\n<td>Unified format context lines</td>\n<td>3</td>\n<td>Synonym for --context</td>\n</tr>\n</tbody></table>\n<p>The argument validation process must handle various error conditions gracefully, providing specific guidance for common mistakes. File path validation should distinguish between non-existent files, permission errors, and binary file detection.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Argument Processing Flow:\n1. Parse command-line arguments using standard library\n2. Validate file paths and check accessibility\n3. Resolve option conflicts with clear error messages\n4. Set up formatting preferences based on TTY detection\n5. Initialize OutputFormatter with validated configuration</code></pre></div>\n\n<h4 id=\"exit-code-conventions\">Exit Code Conventions</h4>\n<p>Following Unix conventions, our diff tool communicates results through exit codes that scripts and automation tools can interpret programmatically. The exit code convention allows other programs to determine the comparison result without parsing output text.</p>\n<table>\n<thead>\n<tr>\n<th>Exit Code</th>\n<th>Condition</th>\n<th>Meaning</th>\n<th>Script Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>Files identical</td>\n<td>No differences found</td>\n<td>Success in automation</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Files differ</td>\n<td>Differences detected</td>\n<td>Expected in many workflows</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Error occurred</td>\n<td>File access, parsing, or system error</td>\n<td>Requires intervention</td>\n</tr>\n</tbody></table>\n<p>The exit code generation must occur after all processing completes successfully. Even if differences are found, the program should exit with code 1 (not an error condition) only after generating complete diff output.</p>\n<h4 id=\"colorformatter-helper-implementation\">ColorFormatter Helper Implementation</h4>\n<p>The <code>ColorFormatter</code> component encapsulates ANSI color logic and provides a clean interface for applying formatting to diff output. This separation allows the main formatting logic to remain readable while isolating platform-specific color handling.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>red(text)</code></td>\n<td>text: str</td>\n<td>str</td>\n<td>Apply red formatting to text</td>\n</tr>\n<tr>\n<td><code>green(text)</code></td>\n<td>text: str</td>\n<td>str</td>\n<td>Apply green formatting to text</td>\n</tr>\n<tr>\n<td><code>bold(text)</code></td>\n<td>text: str</td>\n<td>str</td>\n<td>Apply bold formatting to text</td>\n</tr>\n<tr>\n<td><code>reset()</code></td>\n<td>none</td>\n<td>str</td>\n<td>Return RESET escape code</td>\n</tr>\n<tr>\n<td><code>is_color_enabled()</code></td>\n<td>none</td>\n<td>bool</td>\n<td>Check if colors should be applied</td>\n</tr>\n<tr>\n<td><code>format_diff_line(line, line_type)</code></td>\n<td>line: str, line_type: LineType</td>\n<td>str</td>\n<td>Apply appropriate color for line type</td>\n</tr>\n</tbody></table>\n<p>The color formatting methods should be designed to be no-ops when color output is disabled, allowing the main formatting code to call them unconditionally without performance concerns.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Understanding the common mistakes in diff output formatting helps avoid compatibility issues and user experience problems that can make an otherwise correct diff tool frustrating to use.</p>\n<p>⚠️ <strong>Pitfall: ANSI Codes in Redirected Output</strong></p>\n<p>One of the most frequent issues occurs when ANSI color codes are written to files or pipes, corrupting the output for tools that expect plain text. This happens when developers test their diff tool in a terminal (where colors work correctly) but don&#39;t verify behavior when output is redirected.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Problem: ANSI codes corrupt piped output\n./diff file1.txt file2.txt | less\n# Shows: ^[[32m+added line^[[0m instead of: +added line\n\n# Problem: ANSI codes in saved files  \n./diff file1.txt file2.txt &gt; changes.diff\n# File contains control characters unusable by other tools</code></pre></div>\n\n<p>The root cause is failing to detect that output is being redirected rather than displayed in a terminal. The solution requires proper TTY detection that checks whether standard output is connected to a terminal device.</p>\n<p><strong>Detection Strategy</strong>: Check if <code>sys.stdout.isatty()</code> returns <code>True</code> in Python, or equivalent platform-specific calls. Only enable colors when output goes to an actual terminal.</p>\n<p><strong>Recovery Approach</strong>: Provide <code>--no-color</code> and <code>--force-color</code> flags so users can override automatic detection when needed for special cases.</p>\n<p>⚠️ <strong>Pitfall: Windows Console Color Handling</strong></p>\n<p>Windows terminals historically required special initialization to enable ANSI color support, leading to diff tools that work correctly on Unix systems but display raw escape codes on Windows. Modern Windows terminals support ANSI codes, but older systems and certain console applications may not.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Problem on older Windows: Raw escape codes displayed\nC:\\&gt; diff file1.txt file2.txt\n←[31m-deleted line←[0m  # Shows literal escape characters</code></pre></div>\n\n<p><strong>Detection Strategy</strong>: On Windows, attempt to enable ANSI support using platform-specific APIs, and fall back to plain text if unsuccessful.</p>\n<p><strong>Compatibility Approach</strong>: Consider providing Windows-specific color APIs as an alternative to ANSI codes for maximum compatibility.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Line Number Indexing</strong></p>\n<p>The unified diff format uses one-indexed line numbers for human readability, but internal processing typically uses zero-indexed arrays. This mismatch creates off-by-one errors that make the diff output incompatible with other tools.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Problem: Zero-indexed line numbers in output\n@@ -0,5 +0,7 @@  # Should be @@ -1,5 +1,7 @@\n context line\n-deleted line\n+added line</code></pre></div>\n\n<p><strong>Root Cause</strong>: Directly using internal array indices in hunk headers without converting to one-indexed format.</p>\n<p><strong>Solution Pattern</strong>: Maintain separate counters for display line numbers that start at 1, while keeping internal processing zero-indexed.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Exit Code Usage</strong></p>\n<p>Scripts and automation tools rely on exit codes to determine diff results programmatically. Using non-standard exit codes or returning error codes when files simply differ breaks integration with existing workflows.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Problem: Wrong exit code for differences\n$ diff file1.txt file2.txt; echo $?\nFiles differ\n2  # Should be 1, not 2 (2 indicates error, not differences)</code></pre></div>\n\n<p><strong>Standard Convention</strong>: Exit 0 for identical files, exit 1 for different files, exit 2 for errors (file not found, permission denied, etc.).</p>\n<p><strong>Implementation Pattern</strong>: Distinguish between &quot;differences found&quot; (expected outcome, exit 1) and &quot;processing failed&quot; (unexpected error, exit 2).</p>\n<p>⚠️ <strong>Pitfall: Context Line Count Mismatches</strong></p>\n<p>The hunk header declares how many lines from each file are included in the hunk, but counting errors in the implementation can cause the declared counts to mismatch the actual line content, breaking tools that parse diff output.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Problem: Header claims 5 lines but content shows 6\n@@ -10,5 +10,5 @@\n context1\n context2  \n-deleted line\n+added line\n context3\n context4  # 6th line but header claims 5</code></pre></div>\n\n<p><strong>Root Cause</strong>: Forgetting to include context lines in the count, or miscounting when changes affect the total line count.</p>\n<p><strong>Validation Strategy</strong>: After generating each hunk, verify that the actual line count matches the declared count in the header.</p>\n<p>⚠️ <strong>Pitfall: Missing File Header Information</strong></p>\n<p>Some diff output omits the required <code>---</code> and <code>+++</code> file headers, making the output incompatible with patch tools and version control systems that expect standard unified diff format.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Problem: Missing file identification headers\n@@ -1,3 +1,3 @@  # Where are the --- and +++ headers?\n-old line\n+new line\n context</code></pre></div>\n\n<p><strong>Standard Requirement</strong>: Every unified diff must begin with <code>--- original_file</code> and <code>+++ modified_file</code> headers before any hunk content.</p>\n<p><strong>Implementation Pattern</strong>: Always generate file headers as the first output, even for simple file comparisons.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The <code>OutputFormatter</code> transforms structured diff data into human-readable unified diff format with optional color enhancement and CLI integration. This component requires careful attention to formatting standards, terminal compatibility, and command-line conventions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Color Support</td>\n<td>Basic ANSI codes with TTY detection</td>\n<td>Rich color library with theme support</td>\n</tr>\n<tr>\n<td>CLI Parsing</td>\n<td>argparse standard library</td>\n<td>Click framework with subcommands</td>\n</tr>\n<tr>\n<td>Text Formatting</td>\n<td>String formatting with templates</td>\n<td>Dedicated template engine</td>\n</tr>\n<tr>\n<td>Terminal Detection</td>\n<td>sys.stdout.isatty() check</td>\n<td>termcolor library with capability detection</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── src/\n│   ├── diff_tool/\n│   │   ├── formatters/\n│   │   │   ├── __init__.py\n│   │   │   ├── output_formatter.py     ← Main OutputFormatter class\n│   │   │   ├── color_formatter.py      ← ANSI color helper\n│   │   │   └── unified_diff.py         ← Unified diff format logic\n│   │   ├── cli/\n│   │   │   ├── __init__.py\n│   │   │   ├── argument_parser.py      ← CLI argument processing\n│   │   │   └── main.py                 ← Entry point with exit codes\n│   │   └── models/\n│   │       └── diff_types.py           ← Hunk, DiffLine types\n├── tests/\n│   ├── formatters/\n│   │   ├── test_output_formatter.py\n│   │   └── test_color_formatter.py\n└── main.py                             ← Application entry point</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Color Formatter Helper</strong> (<code>src/diff_tool/formatters/color_formatter.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ColorMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUTO</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"auto\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ALWAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"always\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NEVER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"never\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ColorFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # ANSI color constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[31m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    GREEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[32m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BOLD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[1m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DIM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[2m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RESET</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[0m\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, color_mode: ColorMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">AUTO</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> color_mode</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._color_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._determine_color_support()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _determine_color_support</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine if color output should be enabled based on mode and terminal.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">NEVER</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">ALWAYS</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># AUTO mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sys.stdout.isatty() </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                os.getenv(</span><span style=\"color:#9ECBFF\">'TERM'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'dumb'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> 'dumb'</span><span style=\"color:#F97583\"> and</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                os.getenv(</span><span style=\"color:#9ECBFF\">'NO_COLOR'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_color_enabled</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> red</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RED}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> green</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">GREEN}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> bold</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">BOLD}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> dim</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">DIM}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span></code></pre></div>\n\n<p><strong>CLI Argument Parser</strong> (<code>src/diff_tool/cli/argument_parser.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> argparse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..formatters.color_formatter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ColorMode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffArguments</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, file1: Path, file2: Path, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 color_mode: ColorMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">AUTO</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.file1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.file2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file2</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context_lines</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> color_mode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_arguments</span><span style=\"color:#E1E4E8\">() -> DiffArguments:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> argparse.ArgumentParser(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        description</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Compare two text files and show differences\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        formatter_class</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">argparse.RawDescriptionHelpFormatter,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        epilog</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Exit codes:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  0 - files are identical</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  1 - files differ</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  2 - error occurred</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'file1'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'First file to compare'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'file2'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">Path, </span><span style=\"color:#FFAB70\">help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Second file to compare'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'-c'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'--context'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">default</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                       help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Number of context lines around changes (default: 3)'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.add_argument(</span><span style=\"color:#9ECBFF\">'-u'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'--unified'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dest</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'context'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                       help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Unified format with N context lines (synonym for --context)'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    color_group </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.add_mutually_exclusive_group()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    color_group.add_argument(</span><span style=\"color:#9ECBFF\">'--color'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">action</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'store_const'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                           dest</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'color_mode'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">const</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ColorMode.</span><span style=\"color:#79B8FF\">ALWAYS</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                           help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Force color output even when not a TTY'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    color_group.add_argument(</span><span style=\"color:#9ECBFF\">'--no-color'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">action</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'store_const'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                           dest</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'color_mode'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">const</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ColorMode.</span><span style=\"color:#79B8FF\">NEVER</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                           help</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Disable color output'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.set_defaults(</span><span style=\"color:#FFAB70\">color_mode</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">ColorMode.</span><span style=\"color:#79B8FF\">AUTO</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parser.parse_args()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Validate files exist and are readable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> file_path </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [args.file1, args.file2]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> file_path.exists():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: File '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">file_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' not found\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sys.exit(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> file_path.is_file():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">file_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' is not a regular file\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sys.exit(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Validate context lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> args.context </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Error: Context lines must be non-negative\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DiffArguments(args.file1, args.file2, args.context, args.color_mode)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Output Formatter Main Class</strong> (<code>src/diff_tool/formatters/output_formatter.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, TextIO</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models.diff_types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Hunk, DiffLine, LineType, FileContent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .color_formatter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ColorFormatter, ColorMode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OutputFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, color_mode: ColorMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">AUTO</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.color_formatter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ColorFormatter(color_mode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_unified_diff</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          hunks: List[Hunk], output: TextIO </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sys.stdout) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate complete unified diff output with headers and hunks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate and write file headers (--- and +++ lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Iterate through hunks and format each one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each hunk, write hunk header then format all diff lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle empty hunks list (files are identical)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use _format_file_headers() and _format_hunk() helper methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _format_file_headers</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate --- and +++ header lines identifying the files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create --- header with file1 path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create +++ header with file2 path  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle special cases like /dev/null for new/deleted files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return list of header lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Standard format is \"--- filepath\" and \"+++ filepath\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _format_hunk</span><span style=\"color:#E1E4E8\">(self, hunk: Hunk) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format a single hunk with header and diff lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate hunk header with @@ -old_start,old_count +new_start,new_count @@</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Iterate through hunk.lines and format each DiffLine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply appropriate prefix (space, -, +) based on line_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply color formatting if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate that actual line count matches header declaration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use _format_hunk_header() and _format_diff_line() helpers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _format_hunk_header</span><span style=\"color:#E1E4E8\">(self, hunk: Hunk) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate the @@ header line for a hunk.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract old_start, old_count, new_start, new_count from hunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Format as \"@@ -old_start,old_count +new_start,new_count @@\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle special case where count is 1 (can omit ,1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply bold formatting if colors are enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Standard unified diff format specification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _format_diff_line</span><span style=\"color:#E1E4E8\">(self, diff_line: DiffLine) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format a single diff line with appropriate prefix and color.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Determine prefix character based on diff_line.line_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         UNCHANGED -> ' ', DELETED -> '-', ADDED -> '+'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Combine prefix with diff_line.content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply color formatting based on line type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         DELETED -> red, ADDED -> green, UNCHANGED -> no color</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle empty lines and lines with only whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use self.color_formatter.red/green methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _calculate_line_counts</span><span style=\"color:#E1E4E8\">(self, diff_lines: List[DiffLine]) -> tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Calculate old and new line counts for hunk header.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Count lines that appear in old file (UNCHANGED + DELETED)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Count lines that appear in new file (UNCHANGED + ADDED)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return (old_count, new_count) tuple</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Context lines count toward both files</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Unified Diff Format Logic</strong> (<code>src/diff_tool/formatters/unified_diff.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..models.diff_types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Hunk, DiffLine, LineType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_hunk_consistency</span><span style=\"color:#E1E4E8\">(hunk: Hunk) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify that hunk line counts match actual content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Count actual UNCHANGED and DELETED lines in hunk.lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Count actual UNCHANGED and ADDED lines in hunk.lines  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare with hunk.old_count and hunk.new_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return True only if counts match exactly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: This catches common off-by-one errors in hunk generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> merge_adjacent_hunks</span><span style=\"color:#E1E4E8\">(hunk1: Hunk, hunk2: Hunk, max_gap: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) -> Optional[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Merge two hunks if they are close enough together.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate gap between end of hunk1 and start of hunk2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If gap &#x3C;= max_gap, create merged hunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Combine line lists and recalculate ranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return merged hunk or None if too far apart</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: This improves readability by reducing fragmented hunks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> format_line_prefix</span><span style=\"color:#E1E4E8\">(line_type: LineType) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Get the standard unified diff prefix for a line type.\"\"\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return ' ' for UNCHANGED lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return '-' for DELETED lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return '+' for ADDED lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise exception for invalid line types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: These prefixes are defined by unified diff standard</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python-Specific Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>sys.stdout.isatty()</code> for TTY detection on Unix systems</li>\n<li>Handle Windows console with <code>colorama</code> library if advanced color support needed</li>\n<li>Use <code>argparse</code> for CLI parsing - it handles help text and error messages automatically</li>\n<li>File encoding detection can use <code>chardet</code> library for robust encoding detection</li>\n<li>Use <code>pathlib.Path</code> for cross-platform file path handling</li>\n</ul>\n<p><strong>Exit Code Management:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In main.py entry point</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> diff_tool.cli.argument_parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse_arguments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> diff_tool.core.diff_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DiffEngine</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        args </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse_arguments()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DiffEngine()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> engine.compare_files(args.file1, args.file2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        formatter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> OutputFormatter(args.color_mode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        formatter.format_unified_diff(file1, file2, hunks)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Exit 0 if no differences, 1 if differences found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        exit_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> hunks </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(exit_code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> FileNotFoundError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> PermissionError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unexpected error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the OutputFormatter component, verify correct behavior with these tests:</p>\n<p><strong>Basic Functionality Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create test files</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"line1\\nline2\\nline3\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> test1.txt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> -e</span><span style=\"color:#9ECBFF\"> \"line1\\nmodified\\nline3\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run your diff tool</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span></span></code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>--- test1.txt\n+++ test2.txt\n@@ -1,3 +1,3 @@\n line1\n-line2\n+modified\n line3</code></pre></div>\n\n<p><strong>Color Output Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Should show colors in terminal</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show no colors when redirected</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> output.diff</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cat</span><span style=\"color:#9ECBFF\"> output.diff</span><span style=\"color:#6A737D\">  # Should contain no ANSI codes</span></span></code></pre></div>\n\n<p><strong>Exit Code Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test identical files</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">cp</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test1_copy.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test1_copy.txt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $?</span><span style=\"color:#6A737D\">  # Should print 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test different files  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> test2.txt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $?</span><span style=\"color:#6A737D\">  # Should print 1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test missing file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#9ECBFF\"> test1.txt</span><span style=\"color:#9ECBFF\"> nonexistent.txt</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#79B8FF\"> $?</span><span style=\"color:#6A737D\">  # Should print 2</span></span></code></pre></div>\n\n<p><strong>Context Lines Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create larger test file</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> large1.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">seq</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> sed</span><span style=\"color:#9ECBFF\"> 's/10/modified/'</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> large2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test different context amounts</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#79B8FF\"> --context</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#9ECBFF\"> large1.txt</span><span style=\"color:#9ECBFF\"> large2.txt</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> diff_tool</span><span style=\"color:#79B8FF\"> --context</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> large1.txt</span><span style=\"color:#9ECBFF\"> large2.txt</span></span></code></pre></div>\n\n<p>Signs that implementation is working correctly:</p>\n<ul>\n<li>Output matches standard <code>diff -u</code> format exactly</li>\n<li>Colors appear in terminal but not in redirected output</li>\n<li>Exit codes follow Unix conventions (0=same, 1=different, 2=error)</li>\n<li>Context lines appear symmetrically around changes</li>\n<li>Line numbers in @@ headers are one-indexed and accurate</li>\n</ul>\n<p>Common issues to debug:</p>\n<ul>\n<li>Zero-indexed line numbers in output (should be one-indexed)</li>\n<li>ANSI codes in redirected output (TTY detection failed)</li>\n<li>Wrong exit codes (check error vs difference handling)</li>\n<li>Missing file headers (every diff needs --- and +++ lines)</li>\n</ul>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — the component interactions and data flow span from line tokenization (Milestone 1) through LCS computation (Milestone 2), diff generation (Milestone 3), to final CLI output (Milestone 4)</p>\n</blockquote>\n<p>Understanding how components communicate and data flows through our diff tool requires grasping the orchestrated sequence of operations that transforms two input files into meaningful, formatted output. Think of this process like an assembly line in a document processing facility, where each station (component) performs specialized operations on standardized work units, passing refined products to the next station until the final formatted comparison report emerges.</p>\n<p>The interactions between <code>FileReader</code>, <code>LCSEngine</code>, <code>DiffGenerator</code>, and <code>OutputFormatter</code> follow a pipeline pattern where each component has clearly defined input and output contracts. This architectural choice ensures loose coupling between components while maintaining predictable data transformations throughout the diff computation process.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"System Component Architecture\"></p>\n<h3 id=\"component-communication\">Component Communication</h3>\n<p>The communication between components follows a <strong>message-passing interface pattern</strong> where each component exposes well-defined methods that accept standardized data structures and return predictable outputs. This design choice eliminates tight coupling while ensuring type safety and clear responsibility boundaries.</p>\n<blockquote>\n<p><strong>Mental Model: Document Processing Pipeline</strong></p>\n<p>Imagine a document processing service where manuscripts arrive at different stations. The intake clerk standardizes format and breaks documents into pages. The analysis department compares pages to find similarities. The editorial team converts similarities into editing instructions. Finally, the publishing department formats instructions for readers. Each department has specific input requirements and output formats, communicating through standardized forms rather than direct collaboration.</p>\n</blockquote>\n<p><strong>Inter-Component Interface Contracts</strong></p>\n<p>The component interfaces define the message formats and method signatures that enable seamless communication throughout the diff pipeline:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Input Interface</th>\n<th>Output Interface</th>\n<th>Communication Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FileReader</code></td>\n<td>File paths (strings)</td>\n<td><code>FileContent</code> structures</td>\n<td>Synchronous method calls</td>\n</tr>\n<tr>\n<td><code>LCSEngine</code></td>\n<td>Two <code>Sequence</code> objects</td>\n<td><code>CommonSubsequence</code> structure</td>\n<td>Synchronous computation</td>\n</tr>\n<tr>\n<td><code>DiffGenerator</code></td>\n<td><code>CommonSubsequence</code> + original files</td>\n<td><code>List[Hunk]</code> structures</td>\n<td>Synchronous transformation</td>\n</tr>\n<tr>\n<td><code>OutputFormatter</code></td>\n<td><code>List[Hunk]</code> + formatting options</td>\n<td>Formatted string output</td>\n<td>Synchronous rendering</td>\n</tr>\n</tbody></table>\n<p><strong>FileReader Communication Interface</strong></p>\n<p>The <code>FileReader</code> component exposes methods that abstract file system operations and return standardized <code>FileContent</code> structures. This interface insulates downstream components from file system complexities and encoding variations:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>read_file_lines(filepath)</code></td>\n<td><code>filepath: str</code></td>\n<td><code>List[str]</code></td>\n<td>Reads file with encoding detection and normalization</td>\n</tr>\n<tr>\n<td><code>detect_file_encoding(filepath)</code></td>\n<td><code>filepath: str</code></td>\n<td><code>str</code></td>\n<td>Returns detected encoding (UTF-8 or Latin-1)</td>\n</tr>\n<tr>\n<td><code>create_file_content(filepath, raw_content, encoding, line_ending)</code></td>\n<td><code>filepath: str, raw_content: str, encoding: str, line_ending: str</code></td>\n<td><code>FileContent</code></td>\n<td>Factory method for validated content creation</td>\n</tr>\n<tr>\n<td><code>normalize_line_endings(content)</code></td>\n<td><code>content: str</code></td>\n<td><code>Tuple[str, str]</code></td>\n<td>Returns normalized content and detected ending type</td>\n</tr>\n</tbody></table>\n<p>The <code>FileReader</code> component communicates through <code>FileContent</code> structures that encapsulate all necessary metadata alongside the processed line arrays:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>filepath</code></td>\n<td><code>str</code></td>\n<td>Original file path for reference and error reporting</td>\n</tr>\n<tr>\n<td><code>lines</code></td>\n<td><code>List[str]</code></td>\n<td>Normalized line array with consistent endings removed</td>\n</tr>\n<tr>\n<td><code>line_count</code></td>\n<td><code>int</code></td>\n<td>Total number of lines including empty lines</td>\n</tr>\n<tr>\n<td><code>encoding</code></td>\n<td><code>str</code></td>\n<td>Detected encoding (UTF-8 or LATIN-1)</td>\n</tr>\n<tr>\n<td><code>original_endings</code></td>\n<td><code>str</code></td>\n<td>Original line ending type (LF, CRLF, or CR)</td>\n</tr>\n</tbody></table>\n<p><strong>LCSEngine Communication Interface</strong></p>\n<p>The <code>LCSEngine</code> component receives <code>Sequence</code> objects (type alias for <code>List[str]</code>) and returns detailed <code>CommonSubsequence</code> structures that contain both the subsequence elements and their positions in the original sequences:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>compute_lcs(sequence1, sequence2)</code></td>\n<td><code>sequence1: Sequence, sequence2: Sequence</code></td>\n<td><code>CommonSubsequence</code></td>\n<td>Main entry point with memory optimization</td>\n</tr>\n<tr>\n<td><code>build_lcs_matrix(seq1, seq2)</code></td>\n<td><code>seq1: Sequence, seq2: Sequence</code></td>\n<td><code>List[List[int]]</code></td>\n<td>Constructs dynamic programming matrix</td>\n</tr>\n<tr>\n<td><code>backtrack(matrix, seq1, seq2)</code></td>\n<td><code>matrix: List[List[int]], seq1: Sequence, seq2: Sequence</code></td>\n<td><code>List[str]</code></td>\n<td>Recovers actual LCS from completed matrix</td>\n</tr>\n<tr>\n<td><code>choose_strategy(seq1_len, seq2_len)</code></td>\n<td><code>seq1_len: int, seq2_len: int</code></td>\n<td><code>str</code></td>\n<td>Selects algorithm based on memory constraints</td>\n</tr>\n</tbody></table>\n<p>The <code>CommonSubsequence</code> structure provides comprehensive information about the longest common subsequence and its relationship to the original sequences:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>elements</code></td>\n<td><code>List[str]</code></td>\n<td>The actual longest common subsequence elements</td>\n</tr>\n<tr>\n<td><code>length</code></td>\n<td><code>int</code></td>\n<td>Count of elements in the common subsequence</td>\n</tr>\n<tr>\n<td><code>positions1</code></td>\n<td><code>List[int]</code></td>\n<td>Indices of LCS elements in first sequence</td>\n</tr>\n<tr>\n<td><code>positions2</code></td>\n<td><code>List[int]</code></td>\n<td>Indices of LCS elements in second sequence</td>\n</tr>\n</tbody></table>\n<p><strong>DiffGenerator Communication Interface</strong></p>\n<p>The <code>DiffGenerator</code> component transforms LCS results into structured edit operations and groups them into contextual hunks for readable output:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>generate_diff(file1_lines, file2_lines, lcs, context_lines)</code></td>\n<td><code>file1_lines: List[str], file2_lines: List[str], lcs: CommonSubsequence, context_lines: int</code></td>\n<td><code>List[Hunk]</code></td>\n<td>Main entry point for diff generation</td>\n</tr>\n<tr>\n<td><code>lcs_to_edit_operations(lcs, file1_lines, file2_lines)</code></td>\n<td><code>lcs: CommonSubsequence, file1_lines: List[str], file2_lines: List[str]</code></td>\n<td><code>List[DiffLine]</code></td>\n<td>Converts LCS to flat edit operations</td>\n</tr>\n<tr>\n<td><code>diff_lines_to_hunks(lines, context_lines)</code></td>\n<td><code>lines: List[DiffLine], context_lines: int</code></td>\n<td><code>List[Hunk]</code></td>\n<td>Groups operations into contextual hunks</td>\n</tr>\n<tr>\n<td><code>create_diff_line(content, line_type, old_num, new_num)</code></td>\n<td><code>content: str, line_type: LineType, old_num: Optional[int], new_num: Optional[int]</code></td>\n<td><code>DiffLine</code></td>\n<td>Factory method for validated line creation</td>\n</tr>\n</tbody></table>\n<p>The <code>DiffLine</code> structure represents individual edit operations with complete metadata for formatting:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>content</code></td>\n<td><code>str</code></td>\n<td>The actual line content without diff prefixes</td>\n</tr>\n<tr>\n<td><code>line_type</code></td>\n<td><code>LineType</code></td>\n<td>Operation type (UNCHANGED, ADDED, DELETED)</td>\n</tr>\n<tr>\n<td><code>old_line_num</code></td>\n<td><code>Optional[int]</code></td>\n<td>Line number in original file (None for ADDED)</td>\n</tr>\n<tr>\n<td><code>new_line_num</code></td>\n<td><code>Optional[int]</code></td>\n<td>Line number in new file (None for DELETED)</td>\n</tr>\n</tbody></table>\n<p><strong>OutputFormatter Communication Interface</strong></p>\n<p>The <code>OutputFormatter</code> component receives structured hunks and produces formatted output with optional color support and various output modes:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>format_unified_diff(file1, file2, hunks, output)</code></td>\n<td><code>file1: FileContent, file2: FileContent, hunks: List[Hunk], output: TextIO</code></td>\n<td><code>None</code></td>\n<td>Main entry point for generating unified diff output</td>\n</tr>\n<tr>\n<td><code>red(text)</code></td>\n<td><code>text: str</code></td>\n<td><code>str</code></td>\n<td>Format text with red ANSI codes if enabled</td>\n</tr>\n<tr>\n<td><code>green(text)</code></td>\n<td><code>text: str</code></td>\n<td><code>str</code></td>\n<td>Format text with green ANSI codes if enabled</td>\n</tr>\n<tr>\n<td><code>bold(text)</code></td>\n<td><code>text: str</code></td>\n<td><code>str</code></td>\n<td>Format text with bold ANSI codes if enabled</td>\n</tr>\n<tr>\n<td><code>is_color_enabled()</code></td>\n<td>None</td>\n<td><code>bool</code></td>\n<td>Check if color output is currently enabled</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Synchronous Pipeline Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Components need to communicate and pass data through multiple transformation stages</li>\n<li><strong>Options Considered</strong>: Asynchronous message passing, synchronous method calls, shared memory with notifications</li>\n<li><strong>Decision</strong>: Synchronous method calls with standardized data structures</li>\n<li><strong>Rationale</strong>: Diff computation is inherently sequential (cannot generate hunks until LCS completes), synchronous calls simplify error handling and debugging, standardized structures ensure type safety</li>\n<li><strong>Consequences</strong>: Simple to implement and reason about, clear error propagation, but no parallelization opportunities for large files</li>\n</ul>\n</blockquote>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Data Model Relationships\"></p>\n<h3 id=\"operation-sequence\">Operation Sequence</h3>\n<p>The operation sequence follows a <strong>linear pipeline pattern</strong> where each component completes its processing before passing results to the next stage. This sequential approach matches the mathematical dependencies inherent in diff computation, where each stage requires complete results from the previous stage.</p>\n<p>The overall flow proceeds through four distinct phases: <strong>file preparation</strong>, <strong>similarity analysis</strong>, <strong>difference generation</strong>, and <strong>output formatting</strong>. Each phase has specific responsibilities and produces intermediate results that serve as inputs for subsequent phases.</p>\n<p><strong>Phase 1: File Preparation and Normalization</strong></p>\n<p>The operation sequence begins when the main program invokes the <code>FileReader</code> component with two file paths. This phase focuses on converting raw file system data into normalized, comparable sequences:</p>\n<ol>\n<li><p><strong>File System Access</strong>: The <code>FileReader</code> component attempts to open both files, checking for existence and read permissions before proceeding with content extraction.</p>\n</li>\n<li><p><strong>Encoding Detection</strong>: For each file, <code>detect_file_encoding()</code> is called to determine character encoding by attempting UTF-8 decoding first, falling back to Latin-1 for universal byte coverage.</p>\n</li>\n<li><p><strong>Content Reading</strong>: The <code>read_file_lines()</code> method loads the entire file content into memory and applies encoding decoding based on the detected character set.</p>\n</li>\n<li><p><strong>Line Ending Normalization</strong>: The <code>normalize_line_endings()</code> function identifies the original line ending type (LF, CRLF, or CR) and converts all endings to LF for consistent processing.</p>\n</li>\n<li><p><strong>Line Tokenization</strong>: The <code>split_preserving_empty_lines()</code> method breaks content into individual line strings while maintaining empty lines that provide structural information.</p>\n</li>\n<li><p><strong>Structure Creation</strong>: Two <code>FileContent</code> objects are created using <code>create_file_content()</code>, encapsulating the normalized line arrays along with metadata about encoding and original line endings.</p>\n</li>\n</ol>\n<p>The phase completes when both <code>FileContent</code> structures are available, containing clean line arrays ready for algorithmic comparison.</p>\n<p><strong>Decision Point: Memory vs. Streaming Trade-off</strong></p>\n<p>At this stage, the system has loaded both complete files into memory as line arrays. This approach enables random access during LCS computation but limits scalability for extremely large files:</p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Memory Usage</th>\n<th>Algorithm Support</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Full Load</td>\n<td>O(n) per file</td>\n<td>Supports all LCS variants</td>\n<td>Simple, enables backtracking</td>\n</tr>\n<tr>\n<td>Streaming</td>\n<td>O(1) per file</td>\n<td>Limited algorithm options</td>\n<td>Complex, requires specialized algorithms</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>O(k) sliding window</td>\n<td>Most algorithms with modifications</td>\n<td>Moderate, good for very large files</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The full-load approach was chosen because it enables efficient backtracking during LCS computation and supports future algorithm optimizations while maintaining reasonable memory usage for typical source files.</p>\n</blockquote>\n<p><strong>Phase 2: Similarity Analysis Through LCS</strong></p>\n<p>The similarity analysis phase transforms the normalized line sequences into a mathematical representation of their longest common subsequence, which forms the foundation for identifying unchanged regions:</p>\n<ol>\n<li><p><strong>Strategy Selection</strong>: The <code>LCSEngine</code> calls <code>choose_strategy()</code> to select an appropriate algorithm variant based on sequence lengths and available memory, choosing between standard dynamic programming, two-row optimization, or Hirschberg&#39;s space-efficient approach.</p>\n</li>\n<li><p><strong>Matrix Construction</strong>: The <code>build_lcs_matrix()</code> method constructs the dynamic programming matrix by iterating through both sequences and applying the LCS recurrence relation to build up optimal subproblem solutions.</p>\n</li>\n<li><p><strong>Optimal Length Computation</strong>: The matrix construction completes when the bottom-right cell contains the length of the longest common subsequence between the two input sequences.</p>\n</li>\n<li><p><strong>Subsequence Recovery</strong>: The <code>backtrack()</code> method traverses the completed matrix from bottom-right to top-left, reconstructing the actual common subsequence elements by following optimal paths through the matrix.</p>\n</li>\n<li><p><strong>Position Tracking</strong>: During backtracking, the algorithm records the original positions of each LCS element in both input sequences, enabling precise identification of unchanged regions.</p>\n</li>\n<li><p><strong>Result Packaging</strong>: The <code>CommonSubsequence</code> structure is populated with the recovered elements, their positions in both sequences, and metadata about the computation process.</p>\n</li>\n</ol>\n<p>The similarity analysis phase completes when the <code>CommonSubsequence</code> structure contains complete information about shared content between the two files, ready for transformation into edit operations.</p>\n<p><img src=\"/api/project/diff-tool/architecture-doc/asset?path=diagrams%2Fdiff-generation-sequence.svg\" alt=\"Diff Generation Sequence\"></p>\n<p><strong>Phase 3: Difference Generation and Contextualization</strong></p>\n<p>The difference generation phase converts the mathematical LCS result into human-readable edit operations and groups them into contextual hunks for presentation:</p>\n<ol>\n<li><p><strong>Edit Operation Generation</strong>: The <code>lcs_to_edit_operations()</code> method processes the <code>CommonSubsequence</code> alongside the original line sequences to identify which lines should be marked as UNCHANGED, ADDED, or DELETED.</p>\n</li>\n<li><p><strong>Line-by-Line Classification</strong>: The algorithm iterates through both input sequences simultaneously, using LCS position information to classify each line according to whether it appears in the common subsequence or represents an insertion or deletion.</p>\n</li>\n<li><p><strong>Metadata Assignment</strong>: Each edit operation is wrapped in a <code>DiffLine</code> structure that includes the line content, operation type, and line numbers from both original files for accurate reporting.</p>\n</li>\n<li><p><strong>Hunk Formation</strong>: The <code>diff_lines_to_hunks()</code> method analyzes the flat sequence of edit operations to identify natural groupings where changes occur close together, forming coherent hunks.</p>\n</li>\n<li><p><strong>Context Integration</strong>: For each hunk, the algorithm adds configurable numbers of unchanged lines before and after the changes to provide context that helps readers understand the modifications.</p>\n</li>\n<li><p><strong>Hunk Optimization</strong>: Adjacent hunks with small gaps between them are merged using <code>merge_adjacent_hunks()</code> to reduce fragmentation and improve readability of the final output.</p>\n</li>\n</ol>\n<p>The difference generation phase produces a list of <code>Hunk</code> structures, each containing a coherent group of changes with appropriate context for human consumption.</p>\n<p><strong>Decision Point: Context Line Strategy</strong></p>\n<p>The system must decide how many unchanged lines to include around each change group and when to merge nearby hunks:</p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Context Lines</th>\n<th>Hunk Merging</th>\n<th>Readability</th>\n<th>Output Size</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Minimal</td>\n<td>0-1 lines</td>\n<td>Aggressive merging</td>\n<td>Poor for large changes</td>\n<td>Compact</td>\n</tr>\n<tr>\n<td>Standard</td>\n<td>3 lines</td>\n<td>Merge if gap ≤ 6</td>\n<td>Good balance</td>\n<td>Moderate</td>\n</tr>\n<tr>\n<td>Generous</td>\n<td>5-10 lines</td>\n<td>Conservative merging</td>\n<td>Excellent readability</td>\n<td>Large</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The standard strategy (3 context lines, merge if gap ≤ 6) was chosen to match conventional diff tool behavior and provide good readability without excessive output size.</p>\n</blockquote>\n<p><strong>Phase 4: Output Formatting and Presentation</strong></p>\n<p>The final phase transforms structured hunks into formatted output with appropriate visual styling and standard diff format compliance:</p>\n<ol>\n<li><p><strong>Output Stream Preparation</strong>: The <code>OutputFormatter</code> component determines the target output stream and checks for TTY capabilities to decide whether color formatting should be applied.</p>\n</li>\n<li><p><strong>File Header Generation</strong>: The <code>_format_file_headers()</code> method creates the standard diff header lines that identify the compared files, including timestamps and file paths using the --- and +++ prefix convention.</p>\n</li>\n<li><p><strong>Hunk Processing</strong>: For each hunk in the input list, <code>_format_hunk()</code> generates the complete hunk representation including the @@ header line and all constituent diff lines.</p>\n</li>\n<li><p><strong>Line Formatting</strong>: Individual <code>DiffLine</code> objects are processed by <code>_format_diff_line()</code> to add appropriate prefixes (space for unchanged, - for deleted, + for added) and apply color formatting when enabled.</p>\n</li>\n<li><p><strong>Color Application</strong>: When color output is enabled, the <code>red()</code>, <code>green()</code>, and <code>bold()</code> methods apply ANSI escape sequences to highlight deletions, additions, and headers respectively.</p>\n</li>\n<li><p><strong>Output Generation</strong>: The formatted strings are written to the specified output stream, producing unified diff format that is compatible with standard tools and human-readable.</p>\n</li>\n</ol>\n<p>The operation sequence completes when all hunks have been formatted and written to the output stream, providing users with a comprehensive view of differences between the compared files.</p>\n<p><strong>Error Propagation Throughout the Pipeline</strong></p>\n<p>Error handling follows a <strong>fail-fast strategy</strong> where problems at any stage immediately terminate the pipeline and propagate detailed error information to the user:</p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Potential Failures</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Preparation</td>\n<td>Missing files, encoding errors, permission issues</td>\n<td>Exception handling during file operations</td>\n<td>Report specific file system error and exit</td>\n</tr>\n<tr>\n<td>Similarity Analysis</td>\n<td>Memory exhaustion, algorithm failures</td>\n<td>Memory monitoring and computation validation</td>\n<td>Switch to memory-efficient algorithm or report limitations</td>\n</tr>\n<tr>\n<td>Difference Generation</td>\n<td>Logic errors, inconsistent state</td>\n<td>Assertion checks and data validation</td>\n<td>Report internal error with diagnostic information</td>\n</tr>\n<tr>\n<td>Output Formatting</td>\n<td>I/O errors, formatting failures</td>\n<td>Stream writing exception handling</td>\n<td>Report output error and attempt graceful termination</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Insight: Pipeline Simplicity vs. Performance</strong></p>\n<p>The sequential pipeline design prioritizes correctness and debuggability over performance optimization. While this approach prevents parallelization opportunities, it ensures that each component can be tested independently and errors can be precisely attributed to specific pipeline stages.</p>\n</blockquote>\n<p><strong>Performance Characteristics of the Pipeline</strong></p>\n<p>The overall performance characteristics are dominated by the LCS computation phase, which has O(mn) time complexity and determines the processing time for most file comparisons:</p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Time Complexity</th>\n<th>Space Complexity</th>\n<th>Dominant Factor</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Preparation</td>\n<td>O(n + m)</td>\n<td>O(n + m)</td>\n<td>File I/O and line tokenization</td>\n</tr>\n<tr>\n<td>Similarity Analysis</td>\n<td>O(mn)</td>\n<td>O(mn) or O(min(m,n))</td>\n<td>Dynamic programming matrix</td>\n</tr>\n<tr>\n<td>Difference Generation</td>\n<td>O(n + m)</td>\n<td>O(n + m)</td>\n<td>Linear scan through sequences</td>\n</tr>\n<tr>\n<td>Output Formatting</td>\n<td>O(d) where d = diff lines</td>\n<td>O(1)</td>\n<td>I/O bandwidth to output stream</td>\n</tr>\n</tbody></table>\n<p>The pipeline design enables future optimizations such as streaming file reading, memory-efficient LCS variants, or parallel hunk formatting without requiring architectural changes to component interfaces.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Assuming Synchronous Operations Are Thread-Safe</strong></p>\n<p>Many developers assume that because the pipeline uses synchronous method calls, the components can be safely accessed from multiple threads. However, the <code>LCSEngine</code> maintains internal state in its matrix field, and the <code>OutputFormatter</code> may cache color settings.</p>\n<p><strong>Why this is wrong</strong>: Concurrent access to shared component instances can lead to matrix corruption during LCS computation or inconsistent color formatting. The symptoms include incorrect diff results or garbled output formatting.</p>\n<p><strong>How to fix</strong>: Create separate component instances for each diff operation, or add explicit synchronization around stateful operations. The recommended approach is to treat components as stateless service objects and pass all necessary state as method parameters.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Memory Implications of Full Pipeline</strong></p>\n<p>Developers often focus on optimizing individual components without considering the cumulative memory usage of the entire pipeline. Each phase creates intermediate data structures that exist simultaneously in memory.</p>\n<p><strong>Why this is wrong</strong>: For large files, the memory footprint includes original file content, normalized line arrays, LCS matrix, edit operations list, and formatted output buffers all existing at once. This can lead to memory exhaustion even when individual components seem efficient.</p>\n<p><strong>How to fix</strong>: Implement pipeline streaming where intermediate results are processed and discarded. Consider using generator patterns for large file processing, or implement explicit memory management with cleanup between phases.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Error Context Across Component Boundaries</strong></p>\n<p>When errors occur deep in the pipeline, developers often lose important context about which files were being processed or what stage failed. Generic exception handling obscures the specific operation that encountered problems.</p>\n<p><strong>Why this is wrong</strong>: Users receive unhelpful error messages like &quot;encoding error&quot; without knowing which file caused the problem or what encoding was detected. This makes debugging extremely difficult for end users.</p>\n<p><strong>How to fix</strong>: Wrap exceptions with additional context at each component boundary. Include file paths, detected encodings, sequence lengths, and operation phase in error messages. Create structured error types that carry diagnostic information through the pipeline.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The interaction and data flow implementation requires careful orchestration of component method calls while maintaining clean separation of concerns and robust error handling throughout the pipeline.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component Interface</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Handling</td>\n<td>Basic try/catch with print statements</td>\n<td>Structured logging with error types and context</td>\n</tr>\n<tr>\n<td>Data Validation</td>\n<td>Manual assertions in component methods</td>\n<td>Formal contracts with pre/post-condition checking</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Default garbage collection</td>\n<td>Explicit memory monitoring and optimization strategies</td>\n</tr>\n<tr>\n<td>Pipeline Orchestration</td>\n<td>Direct method calls in main function</td>\n<td>Pipeline builder pattern with configurable stages</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff-tool/\n  main.py                          ← pipeline orchestration and CLI entry point\n  components/\n    file_reader.py                 ← FileReader component implementation\n    lcs_engine.py                  ← LCSEngine component implementation  \n    diff_generator.py              ← DiffGenerator component implementation\n    output_formatter.py            ← OutputFormatter component implementation\n  data_model/\n    types.py                       ← FileContent, CommonSubsequence, Hunk, DiffLine\n    enums.py                       ← LineType, ColorMode constants\n  utils/\n    error_handling.py              ← Pipeline error types and context management\n    memory_monitoring.py           ← Memory usage tracking and optimization\n  tests/\n    test_pipeline_integration.py   ← End-to-end pipeline testing\n    test_component_interfaces.py   ← Component boundary and contract testing</code></pre></div>\n\n<p><strong>C. Pipeline Orchestration Infrastructure</strong></p>\n<p>Complete pipeline coordinator that manages component interaction and error propagation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Pipeline orchestrator that coordinates component interactions and manages</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">error propagation throughout the diff computation process.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> traceback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, TextIO</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> components.file_reader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileReader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> components.lcs_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LCSEngine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> components.diff_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DiffGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> components.output_formatter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> OutputFormatter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> data_model.types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileContent, CommonSubsequence, Hunk</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PipelineContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Context information passed through pipeline stages for error reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file1_path: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    file2_path: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_stage: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stage_progress: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_limit_mb: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_mode: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PipelineError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for pipeline errors with context information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: PipelineContext, cause: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cause </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cause</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffPipeline</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main pipeline coordinator managing component interactions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">, enable_color: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.file_reader </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FileReader()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lcs_engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LCSEngine()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.diff_generator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DiffGenerator()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.output_formatter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> OutputFormatter(</span><span style=\"color:#FFAB70\">enable_color</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">enable_color)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context_lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> run_diff</span><span style=\"color:#E1E4E8\">(self, file1_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, file2_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, output: TextIO </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sys.stdout) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Execute complete diff pipeline and return exit code.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns 0 if files identical, 1 if different, 2 if error.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PipelineContext(file1_path, file2_path, </span><span style=\"color:#9ECBFF\">\"initialization\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 1: File preparation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.current_stage </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"file_preparation\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.stage_progress </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            file1_content, file2_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._prepare_files(context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 2: LCS computation  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.current_stage </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"lcs_computation\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.stage_progress </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lcs_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._compute_similarity(file1_content, file2_content, context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 3: Diff generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.current_stage </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"diff_generation\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.stage_progress </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.7</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._generate_differences(file1_content, file2_content, lcs_result, context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 4: Output formatting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.current_stage </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"output_formatting\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.stage_progress </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.9</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._format_output(file1_content, file2_content, hunks, output, context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Return appropriate exit code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(hunks) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> PipelineError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._handle_pipeline_error(e, output)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            pipeline_error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PipelineError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unexpected error in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context.current_stage</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, context, e)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._handle_pipeline_error(pipeline_error, output)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _prepare_files</span><span style=\"color:#E1E4E8\">(self, context: PipelineContext) -> tuple[FileContent, FileContent]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Phase 1: Read and normalize both input files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            file1_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.file_reader.read_file_content(context.file1_path)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            file2_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.file_reader.read_file_content(context.file2_path) </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> file1_content, file2_content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> PipelineError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to read input files: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, context, e)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _compute_similarity</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, context: PipelineContext) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Phase 2: Compute longest common subsequence.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sequence1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file1.lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            sequence2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file2.lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.lcs_engine.compute_lcs(sequence1, sequence2)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> PipelineError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"LCS computation failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, context, e)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _generate_differences</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            lcs: CommonSubsequence, context: PipelineContext) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Phase 3: Convert LCS to diff hunks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.diff_generator.generate_diff(file1.lines, file2.lines, lcs, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.context_lines)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> PipelineError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Diff generation failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, context, e)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _format_output</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      hunks: List[Hunk], output: TextIO, context: PipelineContext):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Phase 4: Format and write output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.output_formatter.format_unified_diff(file1, file2, hunks, output)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> PipelineError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Output formatting failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, context, e)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _handle_pipeline_error</span><span style=\"color:#E1E4E8\">(self, error: PipelineError, output: TextIO):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle pipeline errors with appropriate user messaging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"diff-tool: error in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error.context.current_stage</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Files: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error.context.file1_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error.context.file2_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(error)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> error.context.debug_mode </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> error.cause:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Debug traceback:\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">sys.stderr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            traceback.print_exception(</span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">(error.cause), error.cause, error.cause.</span><span style=\"color:#79B8FF\">__traceback__</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>D. Component Interface Contracts</strong></p>\n<p>Interface validation utilities that ensure components conform to expected contracts:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Component interface validation and contract enforcement for pipeline integrity.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Protocol</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> data_model.types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileContent, CommonSubsequence, Hunk, Sequence</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileReaderInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Protocol</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Contract for file reading components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_file_content</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> FileContent:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read file with encoding detection and normalization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> detect_file_encoding</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Detect file encoding, returns 'UTF-8' or 'LATIN-1'.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LCSEngineInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Protocol</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Contract for LCS computation components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compute_lcs</span><span style=\"color:#E1E4E8\">(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compute longest common subsequence with position tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> choose_strategy</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Select algorithm strategy based on input size.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffGeneratorInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Protocol</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Contract for diff generation components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_diff</span><span style=\"color:#E1E4E8\">(self, file1_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], file2_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     lcs: CommonSubsequence, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate contextual diff hunks from LCS result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OutputFormatterInterface</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Protocol</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Contract for output formatting components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_unified_diff</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          hunks: List[Hunk], output) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format hunks as unified diff with optional color.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_component_contracts</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Runtime validation that components implement required interfaces.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # This would contain runtime checks for interface compliance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>E. Core Pipeline Logic Skeleton</strong></p>\n<p>Main pipeline orchestration with detailed TODO comments for implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> run_diff_pipeline</span><span style=\"color:#E1E4E8\">(file1_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, file2_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Execute the complete diff pipeline from file input to formatted output.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns exit code: 0 if identical, 1 if different, 2 if error.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize all four pipeline components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Create FileReader instance for file operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Create LCSEngine instance for similarity computation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Create DiffGenerator instance for edit operation generation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Create OutputFormatter instance with color settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Phase 1 - File Preparation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Call file_reader.read_file_content() for both files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Handle file system errors (missing files, permissions, encoding)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Store FileContent structures for both input files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Validate that both files were read successfully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Phase 2 - LCS Computation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Extract line sequences from FileContent.lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Call lcs_engine.compute_lcs() with both sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Handle potential memory exhaustion for large files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Store CommonSubsequence result for next phase</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Phase 3 - Diff Generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Call diff_generator.generate_diff() with files, LCS, and context_lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Handle edge cases (no common lines, identical files)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Store List[Hunk] result for formatting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Phase 4 - Output Formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Call output_formatter.format_unified_diff() with all hunks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Handle output stream errors and color formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Ensure proper unified diff format compliance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Exit Code Logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Return 0 if hunks list is empty (files identical)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Return 1 if hunks exist (files different)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # - Return 2 if any phase encountered errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: len(hunks) == 0 indicates identical files</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span><span style=\"color:#6A737D\">  # Replace with implementation</span></span></code></pre></div>\n\n<p><strong>F. Error Context Management</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Error handling utilities for maintaining context through pipeline stages.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Tracks pipeline execution context for detailed error reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, file1_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, file2_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.file1_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file1_path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.file2_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> file2_path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"initialization\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.phase_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enter_phase</span><span style=\"color:#E1E4E8\">(self, phase_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">phase_info):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Enter new pipeline phase with context information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store phase name and optional phase-specific data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Record timestamp for performance monitoring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_context</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add contextual information for current phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store key-value context data for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_error_message</span><span style=\"color:#E1E4E8\">(self, error: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format error with full pipeline context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create comprehensive error message including:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - File paths being processed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Current pipeline phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Phase-specific context data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Original exception message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>G. Milestone Checkpoints</strong></p>\n<p>After implementing the component interactions and data flow:</p>\n<p><strong>Checkpoint 1: Pipeline Assembly</strong></p>\n<ul>\n<li>Run: <code>python main.py file1.txt file2.txt</code></li>\n<li>Expected: Program executes without import errors and attempts file reading</li>\n<li>Verify: Error messages mention specific pipeline phases when components are missing</li>\n<li>Signs of problems: Import errors, component instantiation failures, missing method errors</li>\n</ul>\n<p><strong>Checkpoint 2: Component Communication</strong></p>\n<ul>\n<li>Create two simple text files with known differences</li>\n<li>Run pipeline and verify each component receives expected inputs</li>\n<li>Expected: FileReader produces FileContent, LCSEngine receives line sequences  </li>\n<li>Signs of problems: Type errors at component boundaries, None values passed between stages</li>\n</ul>\n<p><strong>Checkpoint 3: Error Propagation</strong></p>\n<ul>\n<li>Test with non-existent file, binary file, and permission-denied file</li>\n<li>Expected: Specific error messages identifying problem file and pipeline stage</li>\n<li>Verify: Exit codes match conventions (0=same, 1=different, 2=error)</li>\n<li>Signs of problems: Generic error messages, wrong exit codes, unhandled exceptions</li>\n</ul>\n<p><strong>H. Debugging Pipeline Issues</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pipeline hangs indefinitely</td>\n<td>LCS matrix too large for memory</td>\n<td>Monitor memory usage during execution</td>\n<td>Implement memory-efficient LCS strategy</td>\n</tr>\n<tr>\n<td>Wrong exit codes returned</td>\n<td>Logic error in hunk counting</td>\n<td>Print len(hunks) before return statement</td>\n<td>Fix identical file detection logic</td>\n</tr>\n<tr>\n<td>Components can&#39;t communicate</td>\n<td>Interface mismatch between components</td>\n<td>Check method signatures and return types</td>\n<td>Ensure consistent data structure usage</td>\n</tr>\n<tr>\n<td>Memory usage grows without bound</td>\n<td>Intermediate results not freed</td>\n<td>Profile memory usage by phase</td>\n<td>Add explicit cleanup between phases</td>\n</tr>\n<tr>\n<td>Error messages lack context</td>\n<td>Generic exception handling</td>\n<td>Add logging at each component boundary</td>\n<td>Implement structured error context</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — robust error handling is essential throughout line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)</p>\n</blockquote>\n<p>Think of error handling in a diff tool like building a bridge across a river. The bridge must withstand not just normal traffic, but also storms, floods, and unexpected loads. Similarly, our diff tool must handle not just well-formed text files, but also missing files, permission denied errors, binary content, memory exhaustion, and malformed inputs. A diff tool that crashes on edge cases is like a bridge that collapses in bad weather — it fails exactly when users need it most.</p>\n<p>The complexity of error handling in text comparison tools comes from the intersection of multiple failure domains: the file system layer can fail with I/O errors, the encoding detection layer can encounter binary or malformed data, the algorithm layer can exhaust memory on large inputs, and the output layer can fail when writing to pipes or terminals. Each layer must fail gracefully while preserving enough context for meaningful error messages and recovery strategies.</p>\n<p>Our error handling strategy follows a <strong>fail-fast principle</strong> with <strong>contextual error propagation</strong>. Rather than attempting to recover from fundamental errors like missing files, we detect problems early and provide clear diagnostic information. This approach prevents cascading failures where one component&#39;s silent error leads to mysterious failures in downstream components.</p>\n<blockquote>\n<p><strong>Design Principle:</strong> Error messages should answer three questions: What went wrong? Why did it happen? What can the user do about it?</p>\n</blockquote>\n<h3 id=\"file-system-errors\">File System Errors</h3>\n<p>The <code>FileReader</code> component operates at the boundary between our application and the unreliable external world of file systems. File system operations can fail in numerous ways, each requiring different detection strategies and recovery approaches.</p>\n<p><strong>Encoding Detection Failures</strong></p>\n<p>Encoding detection represents one of the most subtle error scenarios in text processing. The <code>detect_file_encoding</code> function attempts UTF-8 decoding first, falling back to Latin-1 if UTF-8 fails. However, this process can encounter several failure modes that require careful handling.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Mode</th>\n<th>Detection Strategy</th>\n<th>Recovery Approach</th>\n<th>Error Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary File</td>\n<td>UTF-8 decode raises <code>UnicodeDecodeError</code> with null bytes</td>\n<td>Detect binary content and refuse to process</td>\n<td>&quot;File appears to be binary (contains null bytes at position X)&quot;</td>\n</tr>\n<tr>\n<td>Truncated UTF-8</td>\n<td>Incomplete multibyte sequence at file end</td>\n<td>Check for incomplete sequences in last 4 bytes</td>\n<td>&quot;File contains truncated UTF-8 sequence at end&quot;</td>\n</tr>\n<tr>\n<td>Mixed Encodings</td>\n<td>UTF-8 decode succeeds partially then fails</td>\n<td>Track decode position and report first failure</td>\n<td>&quot;File contains mixed encodings starting at line X&quot;</td>\n</tr>\n<tr>\n<td>Zero-Length File</td>\n<td>File exists but contains no data</td>\n<td>Check file size before encoding detection</td>\n<td>&quot;Empty file - no content to compare&quot;</td>\n</tr>\n<tr>\n<td>Very Large File</td>\n<td>File size exceeds available memory</td>\n<td>Check file size against memory limits</td>\n<td>&quot;File too large (X MB) - exceeds memory limit (Y MB)&quot;</td>\n</tr>\n</tbody></table>\n<p>The encoding detection process must distinguish between recoverable encoding issues and fundamental problems. Binary files containing executable code or images should be rejected with clear error messages, while text files with minor encoding issues might be processable with warnings.</p>\n<p><strong>File Access Permission Errors</strong></p>\n<p>File permission errors occur at multiple points in the pipeline and require different handling strategies depending on when they&#39;re encountered:</p>\n<table>\n<thead>\n<tr>\n<th>Access Phase</th>\n<th>Error Scenarios</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Initial Open</td>\n<td>File doesn&#39;t exist, permission denied, directory instead of file</td>\n<td><code>os.open()</code> raises <code>FileNotFoundError</code>, <code>PermissionError</code>, <code>IsADirectoryError</code></td>\n<td>Immediate failure with specific error message</td>\n</tr>\n<tr>\n<td>Size Check</td>\n<td>File exists but <code>stat()</code> permission denied</td>\n<td><code>os.stat()</code> raises <code>PermissionError</code></td>\n<td>Skip size optimization, attempt direct read</td>\n</tr>\n<tr>\n<td>Content Read</td>\n<td>Partial read permission (some bytes readable)</td>\n<td><code>file.read()</code> returns fewer bytes than expected</td>\n<td>Report partial read with byte counts</td>\n</tr>\n<tr>\n<td>Lock Conflicts</td>\n<td>Another process has exclusive lock on file</td>\n<td>Read operation blocks or raises OS-specific error</td>\n<td>Timeout with suggestion to check file usage</td>\n</tr>\n</tbody></table>\n<p>Permission errors must be reported with sufficient context for users to understand the problem. Rather than generic &quot;access denied&quot; messages, we provide specific information about which operation failed and potential causes.</p>\n<p><strong>Line Ending and Structure Errors</strong></p>\n<p>The line tokenization process can encounter malformed file structures that challenge our assumptions about text format:</p>\n<table>\n<thead>\n<tr>\n<th>Structure Issue</th>\n<th>Detection Approach</th>\n<th>Handling Strategy</th>\n<th>User Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mixed Line Endings</td>\n<td>Track <code>\\n</code>, <code>\\r\\n</code>, <code>\\r</code> patterns across file</td>\n<td>Normalize to LF, warn about mixed format</td>\n<td>&quot;Warning: File contains mixed line endings (X Unix, Y Windows, Z Mac)&quot;</td>\n</tr>\n<tr>\n<td>Very Long Lines</td>\n<td>Line exceeds reasonable length threshold (e.g., 1MB)</td>\n<td>Split at threshold with continuation marker</td>\n<td>&quot;Warning: Lines truncated at 1MB limit (affects lines X, Y, Z)&quot;</td>\n</tr>\n<tr>\n<td>Null Characters</td>\n<td>Embedded null bytes in otherwise text file</td>\n<td>Count nulls and report positions</td>\n<td>&quot;Warning: Text file contains X null characters (binary data?)&quot;</td>\n</tr>\n<tr>\n<td>Control Characters</td>\n<td>Non-printable characters except common whitespace</td>\n<td>Track unusual control character usage</td>\n<td>&quot;Warning: File contains unusual control characters&quot;</td>\n</tr>\n</tbody></table>\n<p>The <code>split_preserving_empty_lines</code> function must handle these edge cases while maintaining the structural integrity needed for accurate line-by-line comparison. Each anomaly should be logged with sufficient detail for debugging while not preventing comparison when possible.</p>\n<blockquote>\n<p><strong>Decision: Graceful Degradation for File Structure Issues</strong></p>\n<ul>\n<li><strong>Context</strong>: Text files in practice contain various anomalies that shouldn&#39;t prevent comparison</li>\n<li><strong>Options Considered</strong>: Strict rejection, silent normalization, graceful degradation with warnings</li>\n<li><strong>Decision</strong>: Graceful degradation with detailed warnings</li>\n<li><strong>Rationale</strong>: Users often need to compare imperfect files; warnings preserve utility while flagging issues</li>\n<li><strong>Consequences</strong>: Requires careful anomaly detection and clear warning messages, but maximizes tool usefulness</li>\n</ul>\n</blockquote>\n<h3 id=\"algorithm-edge-cases\">Algorithm Edge Cases</h3>\n<p>The LCS algorithm and diff generation process encounter mathematical and computational edge cases that can cause subtle bugs or catastrophic failures. These scenarios often arise from boundary conditions in the dynamic programming algorithm or resource exhaustion during computation.</p>\n<p><strong>Empty and Identical File Scenarios</strong></p>\n<p>Empty files and identical files represent the mathematical boundaries of the diff problem space. These cases must be handled efficiently without invoking the full LCS computation:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Detection Point</th>\n<th>Optimization Strategy</th>\n<th>Expected Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Both Files Empty</td>\n<td>After line tokenization, both <code>line_count</code> == 0</td>\n<td>Skip LCS computation entirely</td>\n<td>&quot;Files are identical (both empty)&quot;</td>\n</tr>\n<tr>\n<td>One File Empty</td>\n<td>One <code>line_count</code> == 0, other &gt; 0</td>\n<td>Generate pure addition or deletion diff</td>\n<td>All lines marked as ADDED or DELETED</td>\n</tr>\n<tr>\n<td>Files Identical</td>\n<td>Early hash comparison or line-by-line check</td>\n<td>Skip LCS computation</td>\n<td>&quot;Files are identical&quot;</td>\n</tr>\n<tr>\n<td>Single Line Files</td>\n<td>Both <code>line_count</code> == 1</td>\n<td>Direct comparison without matrix</td>\n<td>Either identical or single-line diff</td>\n</tr>\n</tbody></table>\n<p>The <code>LCSEngine</code> component must detect these scenarios before constructing the dynamic programming matrix. Attempting to build a matrix for empty sequences can cause index errors, while building matrices for identical files wastes computational resources.</p>\n<p><strong>Memory Exhaustion Scenarios</strong></p>\n<p>Large file comparisons can exhaust available memory during LCS matrix construction. The standard dynamic programming approach requires O(m×n) space, which becomes prohibitive for files with hundreds of thousands of lines:</p>\n<table>\n<thead>\n<tr>\n<th>File Size Scenario</th>\n<th>Memory Requirements</th>\n<th>Detection Strategy</th>\n<th>Mitigation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Small Files (&lt;1000 lines each)</td>\n<td>&lt;1MB matrix memory</td>\n<td>No detection needed</td>\n<td>Standard O(mn) algorithm</td>\n</tr>\n<tr>\n<td>Medium Files (1000-10000 lines)</td>\n<td>1-100MB matrix memory</td>\n<td>Check available system memory</td>\n<td>Standard algorithm with progress monitoring</td>\n</tr>\n<tr>\n<td>Large Files (10000-100000 lines)</td>\n<td>100MB-10GB matrix memory</td>\n<td>Pre-calculate memory needs</td>\n<td>Switch to two-row optimization</td>\n</tr>\n<tr>\n<td>Huge Files (&gt;100000 lines)</td>\n<td>&gt;10GB matrix memory</td>\n<td>Memory requirement exceeds limits</td>\n<td>Switch to Hirschberg&#39;s algorithm or refuse</td>\n</tr>\n</tbody></table>\n<p>The <code>choose_strategy</code> method in <code>LCSEngine</code> must evaluate these scenarios before beginning computation. Memory estimation must account for the matrix storage plus additional structures like the backtracking path and intermediate results.</p>\n<p><strong>LCS Computation Edge Cases</strong></p>\n<p>The dynamic programming algorithm itself can encounter numerical and logical edge cases that lead to incorrect results or infinite loops:</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Manifestation</th>\n<th>Detection Method</th>\n<th>Correction Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Off-by-One Indexing</td>\n<td>Matrix bounds errors, incorrect LCS length</td>\n<td>Boundary condition testing with known inputs</td>\n<td>Careful index validation in matrix construction</td>\n</tr>\n<tr>\n<td>No Common Lines</td>\n<td>LCS length is 0, backtracking finds empty sequence</td>\n<td>Check <code>lcs.length == 0</code> after computation</td>\n<td>Generate pure addition/deletion diff</td>\n</tr>\n<tr>\n<td>All Lines Identical</td>\n<td>LCS equals entire shorter file</td>\n<td><code>lcs.length == min(len(seq1), len(seq2))</code></td>\n<td>Optimize to avoid full matrix computation</td>\n</tr>\n<tr>\n<td>Repeated Line Patterns</td>\n<td>Multiple valid LCS paths of same length</td>\n<td>Backtracking algorithm must choose consistently</td>\n<td>Use consistent tie-breaking rules</td>\n</tr>\n</tbody></table>\n<p>The backtracking algorithm in particular must handle cases where multiple paths through the matrix yield equally valid longest common subsequences. Consistency in tie-breaking ensures that repeated runs on the same input produce identical output.</p>\n<p><strong>Diff Generation Edge Cases</strong></p>\n<p>Converting LCS results to edit operations and hunks introduces additional edge cases related to line numbering and hunk boundary detection:</p>\n<table>\n<thead>\n<tr>\n<th>Generation Issue</th>\n<th>Problem Manifestation</th>\n<th>Detection Approach</th>\n<th>Resolution Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Line Number Misalignment</td>\n<td>Hunk headers show wrong line ranges</td>\n<td>Validate line counts against actual content</td>\n<td>Recalculate line numbers during hunk formation</td>\n</tr>\n<tr>\n<td>Empty Hunks</td>\n<td>Hunk contains no actual changes</td>\n<td>Check that <code>hunk.lines</code> contains at least one ADD or DELETE</td>\n<td>Filter empty hunks before output</td>\n</tr>\n<tr>\n<td>Overlapping Context</td>\n<td>Adjacent hunks have overlapping context lines</td>\n<td>Calculate context overlap during hunk merging</td>\n<td>Merge hunks or adjust context boundaries</td>\n</tr>\n<tr>\n<td>File Boundary Context</td>\n<td>Context lines requested beyond file start/end</td>\n<td>Check context line numbers against file bounds</td>\n<td>Clamp context to file boundaries</td>\n</tr>\n</tbody></table>\n<p>The <code>diff_lines_to_hunks</code> function must validate hunk consistency after formation. Each hunk&#39;s line count claims must match the actual number of lines in its content, and line numbering must remain consistent across hunk boundaries.</p>\n<p><strong>Resource Limit Enforcement</strong></p>\n<p>Beyond memory exhaustion, the diff tool must handle other resource constraints that can cause degraded performance or failures:</p>\n<table>\n<thead>\n<tr>\n<th>Resource Constraint</th>\n<th>Limit Detection</th>\n<th>Graceful Degradation</th>\n<th>User Communication</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU Time</td>\n<td>Track computation elapsed time</td>\n<td>Interrupt after timeout, provide partial results</td>\n<td>&quot;Computation timed out after X seconds - files too complex&quot;</td>\n</tr>\n<tr>\n<td>File Handle Limits</td>\n<td>Monitor open file descriptors</td>\n<td>Close files promptly, reopen as needed</td>\n<td>&quot;System file handle limit reached&quot;</td>\n</tr>\n<tr>\n<td>Disk Space</td>\n<td>Check available space before writing output</td>\n<td>Stream output, avoid temporary files</td>\n<td>&quot;Insufficient disk space for output&quot;</td>\n</tr>\n<tr>\n<td>Network File Systems</td>\n<td>Detect network mount points</td>\n<td>Warn about potential latency</td>\n<td>&quot;Warning: Comparing files over network - may be slow&quot;</td>\n</tr>\n</tbody></table>\n<p>The <code>PerformanceMonitor</code> component tracks these resource constraints and provides early warnings when limits are approached. Rather than silent failures or mysterious hangs, users receive clear information about resource constraints and potential workarounds.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Silent Memory Exhaustion</strong></p>\n<p>A common mistake is allowing the LCS matrix construction to consume all available memory, causing the system to swap heavily or the process to be killed by the OS. This manifests as extreme slowness or sudden termination without error messages. The fix is to estimate memory requirements before allocation and either use memory-efficient algorithms or refuse to process files that exceed reasonable limits. Always check <code>matrix_size * sizeof(int) &lt; available_memory</code> before proceeding.</p>\n</blockquote>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Integer Overflow in Line Counting</strong></p>\n<p>Very large files can cause integer overflow when calculating line numbers or matrix indices, leading to negative line numbers or array bounds errors. This typically occurs with files containing millions of lines. The fix is to use appropriate integer types (64-bit integers in most cases) and validate that line counts remain within reasonable bounds. Check for <code>line_count &gt; MAX_SAFE_LINES</code> and refuse to process impossibly large files.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation must balance comprehensive coverage with maintainable code structure. Python&#39;s exception hierarchy and context managers provide excellent tools for building robust error handling.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Handling Aspect</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Exception Types</td>\n<td>Built-in exceptions (<code>FileNotFoundError</code>, <code>MemoryError</code>)</td>\n<td>Custom exception hierarchy with error codes</td>\n</tr>\n<tr>\n<td>Memory Monitoring</td>\n<td><code>psutil.virtual_memory()</code></td>\n<td>Custom memory tracking with allocation hooks</td>\n</tr>\n<tr>\n<td>File Operations</td>\n<td>Standard <code>open()</code> with try/except</td>\n<td><code>pathlib.Path</code> with comprehensive error mapping</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Python <code>logging</code> module</td>\n<td>Structured logging with JSON output</td>\n</tr>\n<tr>\n<td>Resource Limits</td>\n<td>Manual checks before operations</td>\n<td><code>resource</code> module with automatic enforcement</td>\n</tr>\n</tbody></table>\n<p><strong>File Structure for Error Handling</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff_tool/\n  src/\n    exceptions.py           ← Custom exception definitions\n    error_handlers.py       ← Error detection and recovery strategies\n    resource_monitor.py     ← Memory and resource tracking\n    file_reader.py         ← File operations with error handling\n    lcs_engine.py          ← Algorithm with memory management\n    diff_generator.py      ← Generation with validation\n    output_formatter.py    ← Output with I/O error handling\n  tests/\n    test_error_cases.py    ← Comprehensive error scenario testing\n    fixtures/\n      binary_file.exe      ← Test fixture for binary detection\n      empty_file.txt       ← Empty file test case\n      huge_file.txt        ← Large file for memory testing</code></pre></div>\n\n<p><strong>Custom Exception Hierarchy (Complete Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Custom exceptions for diff tool with structured error information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides context and recovery suggestions for different failure modes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffToolError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all diff tool errors with context tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, context</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, suggestion</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.suggestion </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> suggestion</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> getattr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'ERROR_CODE'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'UNKNOWN'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_error</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format error with context and suggestions for user display.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{self}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.context:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lines.append(</span><span style=\"color:#9ECBFF\">\"Context:\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> key, value </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.context.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                lines.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"  </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">key</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.suggestion:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lines.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Suggestion: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.suggestion</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">.join(lines)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> FileSystemError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">DiffToolError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"File system operation failures with specific error codes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'FILE_SYSTEM'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EncodingError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">DiffToolError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"File encoding detection and processing failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'ENCODING'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">DiffToolError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"LCS computation and diff generation failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'ALGORITHM'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ResourceError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">DiffToolError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Memory, time, or other resource exhaustion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'RESOURCE'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OutputError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">DiffToolError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Output formatting and writing failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'OUTPUT'</span></span></code></pre></div>\n\n<p><strong>Resource Monitor (Complete Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Resource monitoring and limit enforcement for diff operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Prevents memory exhaustion and provides early warnings for resource constraints.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ResourceMonitor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Monitors memory usage, computation time, and other system resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, memory_limit_mb: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">, time_limit_seconds: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 300</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.memory_limit_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> memory_limit_mb</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.time_limit_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time_limit_seconds</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.start_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.peak_memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_monitoring</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Begin resource monitoring for an operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.peak_memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._get_memory_usage_mb()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_limits</span><span style=\"color:#E1E4E8\">(self) -> Optional[ResourceError]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if resource limits have been exceeded.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check time limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> elapsed </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.time_limit_seconds:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ResourceError(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Operation timed out after </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">elapsed</span><span style=\"color:#F97583\">:.1f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> seconds\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"time_limit\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.time_limit_seconds, </span><span style=\"color:#9ECBFF\">\"elapsed\"</span><span style=\"color:#E1E4E8\">: elapsed},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                suggestion</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Try smaller files or increase time limit\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check memory limit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._get_memory_usage_mb()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.peak_memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.peak_memory_mb, current_memory)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> current_memory </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.memory_limit_mb:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ResourceError(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Memory usage (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">current_memory</span><span style=\"color:#F97583\">:.1f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> MB) exceeds limit (</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.memory_limit_mb</span><span style=\"color:#F97583\">:.1f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> MB)\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"memory_used\"</span><span style=\"color:#E1E4E8\">: current_memory, </span><span style=\"color:#9ECBFF\">\"memory_limit\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.memory_limit_mb},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                suggestion</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Try using memory-optimized algorithms or increase memory limit\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> estimate_matrix_memory</span><span style=\"color:#E1E4E8\">(self, rows: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, cols: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Estimate memory requirements for LCS matrix in MB.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Each matrix cell is typically 4 bytes (32-bit int)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bytes_needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rows </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cols </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> bytes_needed </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_memory_usage_mb</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current process memory usage in MB.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.Process()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> process.memory_info().rss </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_stats</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get monitoring statistics for reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"peak_memory_mb\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.peak_memory_mb,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"elapsed_seconds\"</span><span style=\"color:#E1E4E8\">: time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"memory_limit_mb\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.memory_limit_mb,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"time_limit_seconds\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.time_limit_seconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeletons with Error Handling</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_file_encoding</span><span style=\"color:#E1E4E8\">(filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Detect file encoding trying UTF-8 then Latin-1 with comprehensive error handling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns encoding string or raises EncodingError with specific failure details.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if file exists and is readable - raise FileSystemError with context if not</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check file size - if zero bytes, raise EncodingError indicating empty file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Read first 1024 bytes for encoding detection without loading entire file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Attempt UTF-8 decoding - catch UnicodeDecodeError and check for null bytes (binary file)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If UTF-8 fails, attempt Latin-1 decoding - Latin-1 should always succeed for binary data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If both fail (shouldn't happen), raise EncodingError with detection failure details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: For successful detection, validate by trying to decode a larger sample</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use try/except blocks for each encoding attempt and preserve original exception details</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> compute_lcs_with_limits</span><span style=\"color:#E1E4E8\">(sequence1: Sequence, sequence2: Sequence, monitor: ResourceMonitor) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compute LCS with resource monitoring and graceful degradation on limits.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Switches algorithms based on input size and available resources.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start resource monitoring and get initial memory baseline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle empty sequence edge cases - return appropriate CommonSubsequence immediately  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Estimate memory requirements for full matrix algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If memory estimate exceeds limits, choose memory-efficient algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Periodically check resource limits during matrix construction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If limits exceeded during computation, clean up and raise ResourceError with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Validate result consistency - LCS length should not exceed shorter sequence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return CommonSubsequence with computation statistics attached</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use monitor.check_limits() after each major step, clean up matrix on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_diff_with_validation</span><span style=\"color:#E1E4E8\">(file1_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], file2_lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 lcs: CommonSubsequence, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate diff hunks with comprehensive validation and error recovery.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validates line numbering consistency and hunk boundary correctness.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate LCS result consistency against input files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert LCS to edit operations, tracking line numbers carefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate that edit operations account for all lines in both files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Group operations into hunks with requested context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate each hunk's line count claims against actual content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Check for overlapping context between adjacent hunks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Merge or adjust hunks to resolve context overlaps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Final validation pass - ensure line numbers are monotonic and complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Keep running totals of processed lines to catch numbering errors early</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints for Error Handling</strong></p>\n<p>After implementing error handling for each milestone, verify these specific behaviors:</p>\n<p><strong>Milestone 1 Checkpoint - File Reading Errors:</strong></p>\n<ul>\n<li>Command: <code>python diff_tool.py nonexistent.txt other.txt</code></li>\n<li>Expected: Clear error message about missing file, exit code 1</li>\n<li>Command: <code>python diff_tool.py /dev/null /dev/null</code> (Unix) or empty files</li>\n<li>Expected: &quot;Both files are empty&quot; message, exit code 0</li>\n<li>Command: <code>python diff_tool.py binary_file.exe text_file.txt</code></li>\n<li>Expected: Error about binary file detection with null byte position</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint - Algorithm Limits:</strong></p>\n<ul>\n<li>Create test files with 10,000+ lines each</li>\n<li>Command: <code>python diff_tool.py huge1.txt huge2.txt</code></li>\n<li>Expected: Either successful completion with memory monitoring or graceful failure with resource limit message</li>\n<li>Verify memory usage doesn&#39;t exceed system limits</li>\n<li>Check that empty file comparisons complete instantly without matrix construction</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint - Diff Validation:</strong></p>\n<ul>\n<li>Create files with edge cases: no common lines, all identical lines, single character differences</li>\n<li>Verify hunk line counts match content</li>\n<li>Check that all input lines appear exactly once in diff output</li>\n<li>Validate line numbers are consistent and monotonic</li>\n</ul>\n<p><strong>Milestone 4 Checkpoint - CLI Error Handling:</strong></p>\n<ul>\n<li>Test all error scenarios produce appropriate exit codes (0 for success, 1 for differences, 2 for errors)</li>\n<li>Verify color codes don&#39;t appear when output is piped: <code>python diff_tool.py file1.txt file2.txt | cat</code></li>\n<li>Check that Ctrl+C interruption cleans up resources properly</li>\n</ul>\n<p><strong>Debugging Tips for Error Handling</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tool crashes silently</td>\n<td>Unhandled exception or resource exhaustion</td>\n<td>Check system logs, monitor memory usage during run</td>\n<td>Add try/catch blocks around main operations, implement resource monitoring</td>\n</tr>\n<tr>\n<td>&quot;Binary file&quot; error on text files</td>\n<td>Encoding detection failing, or file contains null bytes</td>\n<td>Examine file with hex editor, check for encoding issues</td>\n<td>Improve encoding detection logic, handle mixed encodings gracefully</td>\n</tr>\n<tr>\n<td>Line numbers in diff output are wrong</td>\n<td>Off-by-one errors in hunk generation</td>\n<td>Compare line numbers in hunks against original files manually</td>\n<td>Validate line counting logic, use 1-indexed line numbers consistently</td>\n</tr>\n<tr>\n<td>Memory usage grows without bound</td>\n<td>LCS matrix not being garbage collected</td>\n<td>Profile memory usage during algorithm execution</td>\n<td>Implement matrix cleanup, use memory-efficient algorithms for large inputs</td>\n</tr>\n<tr>\n<td>Tool hangs on large files</td>\n<td>Infinite loop in algorithm or excessive memory swapping</td>\n<td>Use profiler to identify bottleneck, monitor system resources</td>\n<td>Add progress monitoring, implement timeouts, detect swap thrashing</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — comprehensive testing ensures correctness throughout line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)</p>\n</blockquote>\n<p>Testing a diff tool requires a systematic approach that validates both algorithmic correctness and practical usability. The core challenge lies in verifying that complex dynamic programming algorithms produce correct results while handling the myriad edge cases that arise from real-world file formats and user scenarios.</p>\n<h3 id=\"mental-model-quality-assurance-chain\">Mental Model: Quality Assurance Chain</h3>\n<p>Think of testing a diff tool like quality assurance in a publishing house that compares manuscript versions. The QA process has multiple checkpoints: first, verify that each editor (component) correctly identifies their assigned changes; then, confirm that all editorial notes (diff operations) accurately reflect the differences; finally, ensure the published comparison (formatted output) is readable and follows industry standards. Each checkpoint catches different types of errors, and the chain is only as strong as its weakest link.</p>\n<p>The testing strategy mirrors this approach by validating each component individually, then verifying their integration produces correct end-to-end behavior. Just as a publishing house maintains reference examples of well-executed comparisons, our test suite relies on golden files and known-correct diff outputs to validate algorithmic behavior.</p>\n<h3 id=\"unit-testing-approach\">Unit Testing Approach</h3>\n<p>Unit testing for a diff tool requires careful construction of test cases that isolate component behavior while exercising the full range of inputs each component might encounter. The strategy focuses on testing individual components with known input-output pairs, systematic edge case coverage, and algorithmic validation using reference implementations.</p>\n<h4 id=\"component-isolation-strategy\">Component Isolation Strategy</h4>\n<p>Each component in the diff pipeline requires different testing approaches based on its algorithmic complexity and interaction patterns. The <code>FileReader</code> component primarily handles I/O and text processing, making it suitable for file-based testing with various encodings and formats. The <code>LCSEngine</code> involves complex dynamic programming algorithms that benefit from mathematical verification against known solutions. The <code>DiffGenerator</code> transforms algorithmic results into structured output, requiring format validation and context handling verification. The <code>OutputFormatter</code> handles presentation logic that needs both visual verification and compatibility testing.</p>\n<blockquote>\n<p><strong>Decision: Component-First Testing Approach</strong></p>\n<ul>\n<li><strong>Context</strong>: Testing can proceed component-by-component or through integrated scenarios. Component-first testing isolates failures but may miss integration issues.</li>\n<li><strong>Options Considered</strong>: Component isolation, integration-first testing, hybrid approach</li>\n<li><strong>Decision</strong>: Start with component isolation, then build integration tests</li>\n<li><strong>Rationale</strong>: Dynamic programming algorithms are complex enough to warrant isolated verification before adding integration complexity. Individual component bugs are easier to diagnose and fix than integration failures.</li>\n<li><strong>Consequences</strong>: Enables parallel test development, simplifies debugging, but requires additional integration test layer</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Testing Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Component Isolation</td>\n<td>Clear failure attribution, parallel development, algorithmic focus</td>\n<td>May miss integration issues, duplicate test data</td>\n<td>✓ Primary</td>\n</tr>\n<tr>\n<td>Integration-First</td>\n<td>Tests real scenarios, catches interface mismatches early</td>\n<td>Complex failure diagnosis, coupled test development</td>\n<td>Secondary</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Balances isolation and integration, comprehensive coverage</td>\n<td>Longer test development time, more complex test suite</td>\n<td>Long-term goal</td>\n</tr>\n</tbody></table>\n<h4 id=\"filereader-component-testing\">FileReader Component Testing</h4>\n<p>The <code>FileReader</code> component requires extensive testing of file I/O edge cases, encoding detection, and line normalization behavior. Test cases must cover different file encodings, line ending formats, and boundary conditions that real-world files present.</p>\n<p><strong>Encoding Detection Test Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>File Content</th>\n<th>Expected Encoding</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure ASCII text</td>\n<td>UTF-8</td>\n<td>Basic encoding detection</td>\n</tr>\n<tr>\n<td>UTF-8 with BOM</td>\n<td>UTF-8</td>\n<td>BOM handling verification</td>\n</tr>\n<tr>\n<td>UTF-8 without BOM</td>\n<td>UTF-8</td>\n<td>Standard UTF-8 detection</td>\n</tr>\n<tr>\n<td>Latin-1 characters (é, ñ, ü)</td>\n<td>Latin-1</td>\n<td>Fallback encoding detection</td>\n</tr>\n<tr>\n<td>Binary data (null bytes)</td>\n<td>Error</td>\n<td>Binary file rejection</td>\n</tr>\n<tr>\n<td>Empty file</td>\n<td>UTF-8 (default)</td>\n<td>Edge case handling</td>\n</tr>\n<tr>\n<td>Mixed valid UTF-8 and invalid sequences</td>\n<td>Error</td>\n<td>Encoding corruption detection</td>\n</tr>\n</tbody></table>\n<p><strong>Line Ending Normalization Test Cases:</strong></p>\n<p>The <code>normalize_line_endings</code> function must handle all combinations of line ending types while preserving the original format information for diff headers. Test cases verify that different line ending formats are correctly detected and normalized to a consistent internal representation.</p>\n<table>\n<thead>\n<tr>\n<th>Input Content</th>\n<th>Expected Normalized</th>\n<th>Expected Original Format</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&quot;line1\\nline2\\n&quot;</code></td>\n<td><code>[&quot;line1&quot;, &quot;line2&quot;]</code></td>\n<td><code>LF</code></td>\n<td>Unix format handling</td>\n</tr>\n<tr>\n<td><code>&quot;line1\\r\\nline2\\r\\n&quot;</code></td>\n<td><code>[&quot;line1&quot;, &quot;line2&quot;]</code></td>\n<td><code>CRLF</code></td>\n<td>Windows format handling</td>\n</tr>\n<tr>\n<td><code>&quot;line1\\rline2\\r&quot;</code></td>\n<td><code>[&quot;line1&quot;, &quot;line2&quot;]</code></td>\n<td><code>CR</code></td>\n<td>Classic Mac format handling</td>\n</tr>\n<tr>\n<td><code>&quot;line1\\r\\nline2\\n&quot;</code></td>\n<td><code>[&quot;line1&quot;, &quot;line2&quot;]</code></td>\n<td><code>&quot;mixed&quot;</code></td>\n<td>Mixed format detection</td>\n</tr>\n<tr>\n<td><code>&quot;line1\\nline2&quot;</code></td>\n<td><code>[&quot;line1&quot;, &quot;line2&quot;]</code></td>\n<td><code>&quot;no_final_newline&quot;</code></td>\n<td>Missing final newline</td>\n</tr>\n<tr>\n<td><code>&quot;&quot;</code></td>\n<td><code>[]</code></td>\n<td><code>&quot;empty&quot;</code></td>\n<td>Empty file handling</td>\n</tr>\n<tr>\n<td><code>&quot;\\n\\n\\n&quot;</code></td>\n<td><code>[&quot;&quot;, &quot;&quot;, &quot;&quot;]</code></td>\n<td><code>LF</code></td>\n<td>Multiple empty lines</td>\n</tr>\n</tbody></table>\n<p><strong>File Content Creation Test Scenarios:</strong></p>\n<p>The <code>create_file_content</code> factory function requires validation of its input normalization and validation logic. Tests must verify that invalid combinations are rejected and valid inputs produce correctly structured <code>FileContent</code> objects.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test case structure for FileContent creation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'filepath'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'/path/to/file.txt'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'raw_content'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'line1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">line2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">line3'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'encoding'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'UTF-8'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'line_ending'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'LF'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected_lines'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">'line1'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'line2'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'line3'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected_line_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'filepath'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'/path/to/empty.txt'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'raw_content'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'encoding'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'UTF-8'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'line_ending'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'empty'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected_lines'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected_line_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<h4 id=\"lcs-engine-component-testing\">LCS Engine Component Testing</h4>\n<p>The <code>LCSEngine</code> requires rigorous algorithmic testing since dynamic programming implementations are prone to off-by-one errors, incorrect recurrence relations, and backtracking mistakes. Testing approaches include mathematical verification against known solutions, property-based testing, and performance validation.</p>\n<p><strong>Known Solution Verification:</strong></p>\n<p>LCS algorithms can be verified against manually computed solutions for small inputs, then scaled to larger inputs with predictable patterns. The test suite includes carefully constructed examples where the correct LCS is obvious and can be manually verified.</p>\n<table>\n<thead>\n<tr>\n<th>Sequence 1</th>\n<th>Sequence 2</th>\n<th>Expected LCS</th>\n<th>Expected Length</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td>3</td>\n<td>Identical sequences</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td><code>[&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]</code></td>\n<td><code>[]</code></td>\n<td>0</td>\n<td>No common elements</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]</code></td>\n<td><code>[&quot;B&quot;, &quot;D&quot;, &quot;F&quot;]</code></td>\n<td><code>[&quot;B&quot;, &quot;D&quot;]</code></td>\n<td>2</td>\n<td>Partial overlap</td>\n</tr>\n<tr>\n<td><code>[]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>[]</code></td>\n<td>0</td>\n<td>Empty first sequence</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>[]</code></td>\n<td><code>[]</code></td>\n<td>0</td>\n<td>Empty second sequence</td>\n</tr>\n<tr>\n<td><code>[]</code></td>\n<td><code>[]</code></td>\n<td><code>[]</code></td>\n<td>0</td>\n<td>Both sequences empty</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;A&quot;, &quot;A&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;A&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;A&quot;]</code></td>\n<td>2</td>\n<td>Repeated elements</td>\n</tr>\n</tbody></table>\n<p><strong>Matrix Construction Verification:</strong></p>\n<p>The <code>build_lcs_matrix</code> function requires validation of its dynamic programming table construction. Tests verify that the matrix dimensions are correct and that each cell contains the expected LCS length for its corresponding subsequences.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example matrix verification for sequences [\"A\", \"B\"] and [\"A\", \"C\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expected_matrix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">],  </span><span style=\"color:#6A737D\"># Row 0: empty vs [\"A\", \"C\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">],  </span><span style=\"color:#6A737D\"># Row 1: [\"A\"] vs [\"A\", \"C\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    [</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]   </span><span style=\"color:#6A737D\"># Row 2: [\"A\", \"B\"] vs [\"A\", \"C\"]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Matrix[i][j] represents LCS length of first i elements vs first j elements</span></span></code></pre></div>\n\n<p><strong>Backtracking Algorithm Verification:</strong></p>\n<p>The <code>backtrack</code> function must correctly reconstruct the actual LCS from the completed matrix. Tests verify that backtracking produces a valid LCS (present in both sequences in order) and that multiple valid LCS paths are handled consistently.</p>\n<table>\n<thead>\n<tr>\n<th>Matrix State</th>\n<th>Expected Backtrack Path</th>\n<th>Expected LCS</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single optimal path</td>\n<td>Deterministic trace</td>\n<td>Unique LCS</td>\n<td>Standard case</td>\n</tr>\n<tr>\n<td>Multiple optimal paths</td>\n<td>Consistent tie-breaking</td>\n<td>One valid LCS</td>\n<td>Tie-breaking rules</td>\n</tr>\n<tr>\n<td>All zeros matrix</td>\n<td>No backtrack moves</td>\n<td>Empty LCS</td>\n<td>No common elements</td>\n</tr>\n<tr>\n<td>Diagonal matrix</td>\n<td>Straight diagonal trace</td>\n<td>Full common sequence</td>\n<td>Identical inputs</td>\n</tr>\n</tbody></table>\n<p><strong>Performance and Memory Testing:</strong></p>\n<p>The <code>LCSEngine</code> must handle large inputs without memory exhaustion while maintaining reasonable performance. Tests verify that the memory optimization strategies work correctly and that resource limits are respected.</p>\n<table>\n<thead>\n<tr>\n<th>Sequence Length</th>\n<th>Expected Algorithm</th>\n<th>Expected Memory</th>\n<th>Expected Time</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100 x 100</td>\n<td><code>matrix</code></td>\n<td>~80KB</td>\n<td>&lt;1ms</td>\n<td>Small input baseline</td>\n</tr>\n<tr>\n<td>1000 x 1000</td>\n<td><code>matrix</code></td>\n<td>~8MB</td>\n<td>&lt;100ms</td>\n<td>Medium input handling</td>\n</tr>\n<tr>\n<td>10000 x 10000</td>\n<td><code>two_row</code></td>\n<td>~80KB</td>\n<td>&lt;10s</td>\n<td>Memory optimization</td>\n</tr>\n<tr>\n<td>50000 x 50000</td>\n<td><code>hirschberg</code></td>\n<td>~800KB</td>\n<td>&lt;5min</td>\n<td>Large input handling</td>\n</tr>\n</tbody></table>\n<h4 id=\"diffgenerator-component-testing\">DiffGenerator Component Testing</h4>\n<p>The <code>DiffGenerator</code> transforms LCS results into structured diff operations and hunks. Testing focuses on correct edit operation generation, proper hunk formation with context lines, and unified diff format compliance.</p>\n<p><strong>Edit Operation Generation Testing:</strong></p>\n<p>The <code>lcs_to_edit_operations</code> function must correctly identify which lines are unchanged (in LCS), added (in sequence2 but not LCS), or deleted (in sequence1 but not LCS). Tests verify that the generated operations correctly represent the transformation from sequence1 to sequence2.</p>\n<table>\n<thead>\n<tr>\n<th>File1 Lines</th>\n<th>File2 Lines</th>\n<th>LCS</th>\n<th>Expected Operations</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></td>\n<td>All <code>UNCHANGED</code></td>\n<td>Identical files</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;X&quot;, &quot;B&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>UNCHANGED</code>, <code>ADDED</code>, <code>UNCHANGED</code></td>\n<td>Single insertion</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;X&quot;, &quot;B&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>UNCHANGED</code>, <code>DELETED</code>, <code>UNCHANGED</code></td>\n<td>Single deletion</td>\n</tr>\n<tr>\n<td><code>[&quot;A&quot;, &quot;B&quot;]</code></td>\n<td><code>[&quot;X&quot;, &quot;Y&quot;]</code></td>\n<td><code>[]</code></td>\n<td><code>DELETED</code>, <code>DELETED</code>, <code>ADDED</code>, <code>ADDED</code></td>\n<td>Complete replacement</td>\n</tr>\n</tbody></table>\n<p><strong>Hunk Formation Testing:</strong></p>\n<p>The <code>diff_lines_to_hunks</code> function groups nearby changes into hunks with appropriate context lines. Tests verify that hunks are formed correctly, context lines are included properly, and adjacent hunks are merged when appropriate.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test case: Context line grouping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">diff_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DiffLine(</span><span style=\"color:#9ECBFF\">\"line1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DiffLine(</span><span style=\"color:#9ECBFF\">\"line2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DiffLine(</span><span style=\"color:#9ECBFF\">\"old_line\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DELETED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DiffLine(</span><span style=\"color:#9ECBFF\">\"new_line\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ADDED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DiffLine(</span><span style=\"color:#9ECBFF\">\"line4\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DiffLine(</span><span style=\"color:#9ECBFF\">\"line5\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">UNCHANGED</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># With context_lines=2, expect single hunk:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expected_hunk </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Hunk(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    old_start</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">old_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    new_start</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">new_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    lines</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">diff_lines,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    context_before</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    context_after</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Hunk Merging Logic Testing:</strong></p>\n<p>The <code>merge_adjacent_hunks</code> function combines hunks that are close enough together to warrant merging. Tests verify the merging distance calculation and ensure that merged hunks maintain correct line counts and ranges.</p>\n<table>\n<thead>\n<tr>\n<th>Hunk1 Range</th>\n<th>Hunk2 Range</th>\n<th>Context Lines</th>\n<th>Max Gap</th>\n<th>Should Merge?</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lines 1-5</td>\n<td>Lines 8-12</td>\n<td>2</td>\n<td>3</td>\n<td>Yes</td>\n<td>Close hunks merge</td>\n</tr>\n<tr>\n<td>Lines 1-5</td>\n<td>Lines 15-20</td>\n<td>2</td>\n<td>3</td>\n<td>No</td>\n<td>Distant hunks separate</td>\n</tr>\n<tr>\n<td>Lines 1-5</td>\n<td>Lines 6-10</td>\n<td>1</td>\n<td>0</td>\n<td>Yes</td>\n<td>Adjacent hunks merge</td>\n</tr>\n<tr>\n<td>Lines 1-5</td>\n<td>Lines 7-10</td>\n<td>0</td>\n<td>1</td>\n<td>No</td>\n<td>Context gap prevents merge</td>\n</tr>\n</tbody></table>\n<h4 id=\"outputformatter-component-testing\">OutputFormatter Component Testing</h4>\n<p>The <code>OutputFormatter</code> handles presentation logic including unified diff format generation, ANSI color application, and CLI integration. Testing verifies format compliance, color handling, and cross-platform compatibility.</p>\n<p><strong>Unified Diff Format Compliance:</strong></p>\n<p>The <code>format_unified_diff</code> function must generate output that complies with the standard unified diff format. Tests verify header generation, hunk marker format, line prefix correctness, and overall format structure.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Expected unified diff format structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expected_format </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"--- file1.txt</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">original_timestamp\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"+++ file2.txt</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">modified_timestamp\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"@@ -1,3 +1,3 @@\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \" unchanged_line\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"-deleted_line\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"+added_line\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \" another_unchanged_line\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<p><strong>ANSI Color Testing:</strong></p>\n<p>The <code>ColorFormatter</code> must correctly apply ANSI color codes when appropriate and strip them when color is disabled. Tests verify color application, TTY detection, and cross-platform compatibility.</p>\n<table>\n<thead>\n<tr>\n<th>Input Line</th>\n<th>Color Enabled</th>\n<th>Expected Output</th>\n<th>Test Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DiffLine(&quot;text&quot;, DELETED, 1, None)</code></td>\n<td>True</td>\n<td><code>&quot;\\033[31m-text\\033[0m&quot;</code></td>\n<td>Red deletion color</td>\n</tr>\n<tr>\n<td><code>DiffLine(&quot;text&quot;, ADDED, None, 1)</code></td>\n<td>True</td>\n<td><code>&quot;\\033[32m+text\\033[0m&quot;</code></td>\n<td>Green addition color</td>\n</tr>\n<tr>\n<td><code>DiffLine(&quot;text&quot;, UNCHANGED, 1, 1)</code></td>\n<td>True</td>\n<td><code>&quot; text&quot;</code></td>\n<td>No color for unchanged</td>\n</tr>\n<tr>\n<td><code>DiffLine(&quot;text&quot;, DELETED, 1, None)</code></td>\n<td>False</td>\n<td><code>&quot;-text&quot;</code></td>\n<td>No color when disabled</td>\n</tr>\n</tbody></table>\n<p><strong>CLI Argument Processing Testing:</strong></p>\n<p>The argument parsing logic must correctly handle all supported command-line options and provide appropriate error messages for invalid usage. Tests verify option parsing, file path validation, and help text generation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># CLI argument test cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">cli_test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'args'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">'file1.txt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'file2.txt'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected'</span><span style=\"color:#E1E4E8\">: DiffArguments(</span><span style=\"color:#FFAB70\">file1</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'file1.txt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file2</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'file2.txt'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                 color</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">context_lines</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'description'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Basic two-file comparison'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'args'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">'--no-color'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'file1.txt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'file2.txt'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected'</span><span style=\"color:#E1E4E8\">: DiffArguments(</span><span style=\"color:#FFAB70\">file1</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'file1.txt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file2</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'file2.txt'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                 color</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">context_lines</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'description'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Color disabled'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'args'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">'--context'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'5'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'file1.txt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'file2.txt'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'expected'</span><span style=\"color:#E1E4E8\">: DiffArguments(</span><span style=\"color:#FFAB70\">file1</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'file1.txt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">file2</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'file2.txt'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                                 color</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">context_lines</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'description'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Custom context lines'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<h4 id=\"property-based-testing-strategy\">Property-Based Testing Strategy</h4>\n<p>Property-based testing generates random inputs and verifies that certain properties always hold, regardless of the specific input values. This approach is particularly valuable for diff algorithms because it can discover edge cases that manual test case construction might miss.</p>\n<p><strong>LCS Properties to Verify:</strong></p>\n<ol>\n<li><strong>Symmetry Property</strong>: The LCS length of (A, B) equals the LCS length of (B, A)</li>\n<li><strong>Subsequence Property</strong>: The returned LCS must be a valid subsequence of both input sequences</li>\n<li><strong>Optimality Property</strong>: No longer common subsequence should exist than the one returned</li>\n<li><strong>Prefix Property</strong>: LCS(A[0:i], B[0:j]) should be consistent with the full LCS computation</li>\n</ol>\n<p><strong>Diff Generation Properties:</strong></p>\n<ol>\n<li><strong>Roundtrip Property</strong>: Applying the generated diff operations should transform sequence1 into sequence2</li>\n<li><strong>Line Conservation</strong>: The total number of unchanged + deleted lines should equal the original file length</li>\n<li><strong>Hunk Completeness</strong>: All diff operations should appear in exactly one hunk</li>\n<li><strong>Context Consistency</strong>: Context lines in hunks should match the original file content</li>\n</ol>\n<h4 id=\"error-condition-testing\">Error Condition Testing</h4>\n<p>Each component must handle error conditions gracefully and provide meaningful error messages. Error testing verifies that components fail fast with appropriate error types and context information.</p>\n<p><strong>FileReader Error Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Expected Exception</th>\n<th>Expected Message Pattern</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File not found</td>\n<td><code>FileSystemError</code></td>\n<td>&quot;File not found: {filepath}&quot;</td>\n<td>Prompt user for correct path</td>\n</tr>\n<tr>\n<td>Permission denied</td>\n<td><code>FileSystemError</code></td>\n<td>&quot;Permission denied: {filepath}&quot;</td>\n<td>Check file permissions</td>\n</tr>\n<tr>\n<td>Binary file detection</td>\n<td><code>EncodingError</code></td>\n<td>&quot;Binary file detected: {filepath}&quot;</td>\n<td>Skip or warn user</td>\n</tr>\n<tr>\n<td>Mixed line endings</td>\n<td>Warning</td>\n<td>&quot;Mixed line endings detected&quot;</td>\n<td>Continue with normalization</td>\n</tr>\n<tr>\n<td>Encoding detection failure</td>\n<td><code>EncodingError</code></td>\n<td>&quot;Could not determine encoding&quot;</td>\n<td>Prompt user for encoding</td>\n</tr>\n</tbody></table>\n<p><strong>LCSEngine Error Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Expected Exception</th>\n<th>Expected Message Pattern</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory limit exceeded</td>\n<td><code>ResourceError</code></td>\n<td>&quot;LCS matrix too large: {size}MB &gt; {limit}MB&quot;</td>\n<td>Suggest memory optimization</td>\n</tr>\n<tr>\n<td>Time limit exceeded</td>\n<td><code>ResourceError</code></td>\n<td>&quot;LCS computation timeout after {seconds}s&quot;</td>\n<td>Suggest algorithm optimization</td>\n</tr>\n<tr>\n<td>Invalid sequence input</td>\n<td><code>AlgorithmError</code></td>\n<td>&quot;Invalid sequence type: expected List[str]&quot;</td>\n<td>Validate input format</td>\n</tr>\n<tr>\n<td>Empty matrix allocation</td>\n<td><code>ResourceError</code></td>\n<td>&quot;Cannot allocate matrix of size {rows}x{cols}&quot;</td>\n<td>Check available memory</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-testing\">Common Pitfalls in Testing</h3>\n<p>Testing diff algorithms presents several common pitfalls that can lead to false confidence in correctness or missed edge cases. Understanding these pitfalls helps construct more robust test suites.</p>\n<p>⚠️ <strong>Pitfall: Testing Only Happy Path Scenarios</strong></p>\n<p>Many developers focus testing on scenarios where files have clear, obvious differences and ignore the edge cases where algorithms are most likely to fail. Testing only well-formed text files with consistent line endings misses the real-world complexity of mixed encodings, binary data, and malformed input.</p>\n<p>The fix involves systematically constructing adversarial test cases: files with no common lines, files where one is empty, files with only whitespace differences, and files with encoding issues. Create a test matrix that covers all combinations of edge conditions rather than just the scenarios that work smoothly.</p>\n<p>⚠️ <strong>Pitfall: Assuming LCS Uniqueness</strong></p>\n<p>LCS algorithms can produce multiple valid results when there are multiple longest common subsequences of equal length. Tests that expect a specific LCS may fail when the algorithm chooses a different but equally valid path through the edit graph.</p>\n<p>The solution is to test LCS properties rather than exact content. Verify that the returned LCS has the correct length, appears in both sequences in the correct order, and that no longer common subsequence exists. This allows the algorithm flexibility in tie-breaking while ensuring correctness.</p>\n<p>⚠️ <strong>Pitfall: Off-by-One Line Number Testing</strong></p>\n<p>Unified diff format uses one-indexed line numbers, but most programming languages use zero-indexed arrays. Tests that don&#39;t account for this indexing difference may pass with incorrect line numbering that breaks compatibility with standard diff tools.</p>\n<p>Create test cases that specifically verify line numbering in hunk headers matches the expected unified diff format. Compare generated output with the output of system diff tools to ensure compatibility. Pay special attention to edge cases like single-line files and changes at the beginning or end of files.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Context Line Testing</strong></p>\n<p>Context line generation involves complex boundary conditions when changes occur near file boundaries or when hunks would overlap. Tests that don&#39;t exercise these boundary conditions miss scenarios where context line calculation fails.</p>\n<p>Construct test cases where changes occur on the first line, last line, and cases where requested context extends beyond file boundaries. Verify that hunk merging works correctly when context lines overlap and that merged hunks maintain correct line counts.</p>\n<p>⚠️ <strong>Pitfall: Platform-Specific Color Testing</strong></p>\n<p>ANSI color code handling varies significantly between operating systems and terminal types. Tests that work on one platform may fail on others due to different color support, TTY detection, or output redirection behavior.</p>\n<p>Create platform-specific test configurations that verify color output under different conditions: interactive terminal, redirected output, Windows command prompt, and Unix terminals. Mock TTY detection to ensure consistent behavior across environments.</p>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Each milestone in the diff tool implementation requires specific validation checkpoints that verify both individual component functionality and integration with previous components. These checkpoints provide concrete verification steps and expected outcomes.</p>\n<h4 id=\"milestone-1-checkpoint-line-tokenization\">Milestone 1 Checkpoint: Line Tokenization</h4>\n<p>After implementing the <code>FileReader</code> component, the following validation steps ensure correct file reading and line processing behavior:</p>\n<p><strong>Validation Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Basic functionality test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_file_reader.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Encoding detection test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> test_encoding_detection.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Line normalization verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> test_line_endings.py</span></span></code></pre></div>\n\n<p><strong>Expected Behavior Verification:</strong></p>\n<ol>\n<li><p><strong>File Reading Test</strong>: Create test files in different encodings (UTF-8, Latin-1) with various content types. The <code>read_file_lines</code> function should correctly detect encoding and return a list of strings representing file lines.</p>\n</li>\n<li><p><strong>Line Ending Normalization</strong>: Create files with different line endings (LF, CRLF, CR, mixed) and verify that <code>normalize_line_endings</code> correctly detects the original format while producing consistent internal representation.</p>\n</li>\n<li><p><strong>Empty Line Preservation</strong>: Files with empty lines should preserve those empty lines in the output. The line count should match the actual number of lines including empty ones.</p>\n</li>\n<li><p><strong>Error Handling Verification</strong>: Binary files should be rejected with appropriate error messages. Files with permission issues should produce clear error descriptions.</p>\n</li>\n</ol>\n<p><strong>Success Indicators:</strong></p>\n<ul>\n<li>All encoding detection tests pass with correct UTF-8/Latin-1 identification</li>\n<li>Line count reported matches manual line count for various file types</li>\n<li>Empty lines are preserved in output without being filtered</li>\n<li>Binary file detection prevents processing of non-text files</li>\n<li>Error messages provide actionable information for file access issues</li>\n</ul>\n<p><strong>Troubleshooting Common Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary files accepted</td>\n<td>Missing binary detection</td>\n<td>Check for null bytes in content</td>\n<td>Add binary detection logic</td>\n</tr>\n<tr>\n<td>Line count mismatch</td>\n<td>Trailing newline handling</td>\n<td>Compare with <code>wc -l</code> output</td>\n<td>Handle final newline consistently</td>\n</tr>\n<tr>\n<td>Encoding errors</td>\n<td>Detection order wrong</td>\n<td>Test with Latin-1 content</td>\n<td>Try UTF-8 first, fallback to Latin-1</td>\n</tr>\n<tr>\n<td>Empty lines missing</td>\n<td>Split logic incorrect</td>\n<td>Check split algorithm</td>\n<td>Use split that preserves empty strings</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-2-checkpoint-lcs-algorithm\">Milestone 2 Checkpoint: LCS Algorithm</h4>\n<p>The LCS implementation requires verification of correct dynamic programming matrix construction and backtracking logic:</p>\n<p><strong>Validation Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># LCS algorithm correctness</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_lcs_engine.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Performance and memory testing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> test_lcs_performance.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Matrix construction verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> test_matrix_building.py</span></span></code></pre></div>\n\n<p><strong>Expected Behavior Verification:</strong></p>\n<ol>\n<li><p><strong>Algorithm Correctness</strong>: Test with known LCS examples where the result can be manually verified. The <code>compute_lcs</code> function should return the correct longest common subsequence and length.</p>\n</li>\n<li><p><strong>Matrix Construction</strong>: The <code>build_lcs_matrix</code> function should produce a properly sized matrix where each cell contains the correct LCS length for the corresponding subsequences.</p>\n</li>\n<li><p><strong>Backtracking Verification</strong>: The <code>backtrack</code> function should reconstruct a valid LCS that appears in both input sequences in the correct order.</p>\n</li>\n<li><p><strong>Memory Optimization</strong>: Large inputs should trigger memory optimization strategies without affecting correctness.</p>\n</li>\n</ol>\n<p><strong>Success Indicators:</strong></p>\n<ul>\n<li>All known LCS test cases produce correct results</li>\n<li>Matrix dimensions match input sequence lengths plus one</li>\n<li>Backtracked LCS is a valid subsequence of both inputs</li>\n<li>Memory usage stays within configured limits for large inputs</li>\n<li>Performance scales reasonably with input size</li>\n</ul>\n<p><strong>Troubleshooting Common Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wrong LCS length</td>\n<td>Matrix construction error</td>\n<td>Print matrix values manually</td>\n<td>Check recurrence relation</td>\n</tr>\n<tr>\n<td>Backtrack fails</td>\n<td>Index boundaries wrong</td>\n<td>Trace backtrack path</td>\n<td>Fix matrix indexing</td>\n</tr>\n<tr>\n<td>Memory explosion</td>\n<td>No optimization triggered</td>\n<td>Check input size thresholds</td>\n<td>Lower optimization trigger point</td>\n</tr>\n<tr>\n<td>Performance issues</td>\n<td>Inefficient matrix access</td>\n<td>Profile algorithm execution</td>\n<td>Optimize inner loop</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-3-checkpoint-diff-generation\">Milestone 3 Checkpoint: Diff Generation</h4>\n<p>The diff generation component transforms LCS results into structured hunks with unified diff format:</p>\n<p><strong>Validation Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Diff generation correctness</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_diff_generator.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Hunk formation testing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> test_hunk_generation.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Format compliance verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> test_unified_diff_format.py</span></span></code></pre></div>\n\n<p><strong>Expected Behavior Verification:</strong></p>\n<ol>\n<li><p><strong>Edit Operations</strong>: The <code>lcs_to_edit_operations</code> function should correctly identify added, deleted, and unchanged lines based on LCS results.</p>\n</li>\n<li><p><strong>Hunk Formation</strong>: The <code>diff_lines_to_hunks</code> function should group nearby changes with appropriate context lines and generate correct hunk boundaries.</p>\n</li>\n<li><p><strong>Line Numbering</strong>: All line numbers in hunks should be one-indexed and accurately reflect positions in the original files.</p>\n</li>\n<li><p><strong>Context Handling</strong>: Context lines should be included around changes, and overlapping contexts should trigger hunk merging.</p>\n</li>\n</ol>\n<p><strong>Success Indicators:</strong></p>\n<ul>\n<li>Edit operations correctly represent file transformation</li>\n<li>Hunk line counts match actual line content</li>\n<li>Line numbering follows unified diff conventions (one-indexed)</li>\n<li>Context lines accurately match original file content</li>\n<li>Adjacent hunks merge appropriately based on context overlap</li>\n</ul>\n<p><strong>Troubleshooting Common Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wrong line numbers</td>\n<td>Zero-based indexing used</td>\n<td>Check hunk headers against file</td>\n<td>Convert to one-based numbering</td>\n</tr>\n<tr>\n<td>Missing context lines</td>\n<td>Context calculation error</td>\n<td>Verify context boundaries</td>\n<td>Fix context line extraction</td>\n</tr>\n<tr>\n<td>Hunks not merging</td>\n<td>Merge distance wrong</td>\n<td>Check overlap calculation</td>\n<td>Adjust merge threshold</td>\n</tr>\n<tr>\n<td>Line count mismatch</td>\n<td>Hunk calculation error</td>\n<td>Sum hunk lines vs file lines</td>\n<td>Fix hunk line counting</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-4-checkpoint-cli-and-color-output\">Milestone 4 Checkpoint: CLI and Color Output</h4>\n<p>The final milestone integrates all components into a complete CLI tool with colored output:</p>\n<p><strong>Validation Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Complete integration test</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> diff_tool.py</span><span style=\"color:#9ECBFF\"> file1.txt</span><span style=\"color:#9ECBFF\"> file2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Color output verification</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> diff_tool.py</span><span style=\"color:#79B8FF\"> --color</span><span style=\"color:#9ECBFF\"> file1.txt</span><span style=\"color:#9ECBFF\"> file2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Context line configuration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> diff_tool.py</span><span style=\"color:#79B8FF\"> --context</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#9ECBFF\"> file1.txt</span><span style=\"color:#9ECBFF\"> file2.txt</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># No-color mode testing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> diff_tool.py</span><span style=\"color:#79B8FF\"> --no-color</span><span style=\"color:#9ECBFF\"> file1.txt</span><span style=\"color:#9ECBFF\"> file2.txt</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> output.diff</span></span></code></pre></div>\n\n<p><strong>Expected Behavior Verification:</strong></p>\n<ol>\n<li><p><strong>CLI Integration</strong>: Command-line arguments should be parsed correctly with appropriate defaults and error messages for invalid usage.</p>\n</li>\n<li><p><strong>Color Output</strong>: Terminal output should include ANSI color codes for additions (green) and deletions (red) when appropriate, but strip colors when output is redirected.</p>\n</li>\n<li><p><strong>Format Compatibility</strong>: Generated diff output should be compatible with standard diff tools and patch utilities.</p>\n</li>\n<li><p><strong>Exit Codes</strong>: Program should return 0 for identical files, 1 for different files, and 2 for errors.</p>\n</li>\n</ol>\n<p><strong>Success Indicators:</strong></p>\n<ul>\n<li>CLI accepts all documented arguments correctly</li>\n<li>Color output appears properly in terminal</li>\n<li>No-color mode produces clean output suitable for redirection</li>\n<li>Generated diffs can be applied using standard patch tools</li>\n<li>Exit codes match diff tool conventions</li>\n<li>Error messages provide helpful guidance for incorrect usage</li>\n</ul>\n<p><strong>Integration Verification Steps:</strong></p>\n<ol>\n<li><p><strong>Compare with System Diff</strong>: Run both your tool and system diff on the same files and verify that the essential differences are captured correctly (line numbers and change indicators may vary slightly due to different algorithms).</p>\n</li>\n<li><p><strong>Patch Application Test</strong>: Generate a diff with your tool and verify it can be applied using standard patch utilities to reproduce the target file.</p>\n</li>\n<li><p><strong>Performance Validation</strong>: Verify that the complete pipeline handles reasonably sized files (1000+ lines) within acceptable time limits.</p>\n</li>\n<li><p><strong>Cross-Platform Testing</strong>: Test CLI behavior on different operating systems to ensure consistent argument parsing and color output.</p>\n</li>\n</ol>\n<p><strong>Final Integration Troubleshooting:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Colors in redirected output</td>\n<td>TTY detection failed</td>\n<td>Test with <code>diff_tool.py &gt; file</code></td>\n<td>Fix TTY detection logic</td>\n</tr>\n<tr>\n<td>Patch application fails</td>\n<td>Format compliance issue</td>\n<td>Compare with system diff output</td>\n<td>Align format with standards</td>\n</tr>\n<tr>\n<td>Wrong exit codes</td>\n<td>Exit code logic missing</td>\n<td>Test with identical/different files</td>\n<td>Implement proper exit codes</td>\n</tr>\n<tr>\n<td>Performance degradation</td>\n<td>Component integration overhead</td>\n<td>Profile pipeline execution</td>\n<td>Optimize data passing between components</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing implementation focuses on creating a comprehensive test suite that validates each component individually and verifies their integration. The approach emphasizes systematic test case construction, property-based testing, and milestone-driven validation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Testing Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td><code>unittest</code> (built-in)</td>\n<td><code>pytest</code> with fixtures</td>\n</tr>\n<tr>\n<td>Property Testing</td>\n<td>Manual test case construction</td>\n<td><code>hypothesis</code> for property-based testing</td>\n</tr>\n<tr>\n<td>Performance Testing</td>\n<td>Basic timing with <code>time.time()</code></td>\n<td><code>pytest-benchmark</code> with statistical analysis</td>\n</tr>\n<tr>\n<td>Test Data Management</td>\n<td>Hardcoded test strings</td>\n<td>External test files with various encodings</td>\n</tr>\n<tr>\n<td>Coverage Analysis</td>\n<td>Manual verification</td>\n<td><code>coverage.py</code> with branch coverage</td>\n</tr>\n<tr>\n<td>CLI Testing</td>\n<td>Direct function calls</td>\n<td><code>click.testing.CliRunner</code> for CLI simulation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── src/\n│   ├── diff_tool/\n│   │   ├── __init__.py\n│   │   ├── file_reader.py      ← FileReader component\n│   │   ├── lcs_engine.py       ← LCSEngine component\n│   │   ├── diff_generator.py   ← DiffGenerator component\n│   │   ├── output_formatter.py ← OutputFormatter component\n│   │   └── main.py            ← CLI entry point\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py            ← pytest fixtures and shared test utilities\n│   ├── test_file_reader.py    ← FileReader unit tests\n│   ├── test_lcs_engine.py     ← LCSEngine unit tests\n│   ├── test_diff_generator.py ← DiffGenerator unit tests\n│   ├── test_output_formatter.py ← OutputFormatter unit tests\n│   ├── test_integration.py    ← End-to-end integration tests\n│   ├── test_properties.py     ← Property-based testing\n│   ├── test_data/            ← Test files with various encodings\n│   │   ├── utf8_sample.txt\n│   │   ├── latin1_sample.txt\n│   │   ├── binary_sample.bin\n│   │   ├── empty_file.txt\n│   │   └── mixed_endings.txt\n│   └── performance/\n│       ├── test_lcs_performance.py\n│       └── test_memory_usage.py\n├── pytest.ini                ← pytest configuration\n└── requirements-test.txt      ← testing dependencies</code></pre></div>\n\n<h4 id=\"test-fixture-infrastructure\">Test Fixture Infrastructure</h4>\n<p>Create reusable test fixtures that provide consistent test data and component instances across the test suite:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/conftest.py - Shared test fixtures and utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.file_reader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileReader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.lcs_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LCSEngine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.diff_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DiffGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.output_formatter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> OutputFormatter</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> file_reader</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provide a configured FileReader instance for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> FileReader()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> lcs_engine</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provide a configured LCSEngine instance for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LCSEngine()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> diff_generator</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provide a configured DiffGenerator instance for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> DiffGenerator()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> output_formatter</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provide a configured OutputFormatter instance for testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> OutputFormatter()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_data_dir</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provide path to test data directory.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> Path(</span><span style=\"color:#79B8FF\">__file__</span><span style=\"color:#E1E4E8\">).parent </span><span style=\"color:#F97583\">/</span><span style=\"color:#9ECBFF\"> \"test_data\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> sample_files</span><span style=\"color:#E1E4E8\">(test_data_dir, tmp_path):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create sample test files with known content and encoding.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create UTF-8 file with known content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create Latin-1 file with accented characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create file with mixed line endings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create empty file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return dict mapping file types to file paths</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> known_lcs_cases</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provide test cases with known LCS solutions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'seq1'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"D\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'seq2'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"X\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Y\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'expected_lcs'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'expected_length'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add more known LCS test cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include edge cases: empty sequences, no common elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include cases with repeated elements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span></code></pre></div>\n\n<h4 id=\"component-test-skeletons\">Component Test Skeletons</h4>\n<p>Provide test class structures for each component with TODO comments mapping to specific test requirements:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/test_file_reader.py - FileReader component tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.file_reader </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileReader, FileContent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileSystemError, EncodingError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestFileReader</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test FileReader component functionality.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_detect_file_encoding_utf8</span><span style=\"color:#E1E4E8\">(self, test_data_dir):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test UTF-8 encoding detection for files with UTF-8 content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create test file with UTF-8 content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call detect_file_encoding on test file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert encoding is detected as 'UTF-8'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_detect_file_encoding_latin1</span><span style=\"color:#E1E4E8\">(self, test_data_dir):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test Latin-1 encoding detection for files with Latin-1 content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create test file with Latin-1 content (accented characters)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call detect_file_encoding on test file</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert encoding is detected as 'Latin-1'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_read_file_lines_basic</span><span style=\"color:#E1E4E8\">(self, sample_files, file_reader):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic file reading with line splitting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use sample UTF-8 file from fixture</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call read_file_lines to get FileContent object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert lines list matches expected content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert line_count matches len(lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert encoding is correctly detected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_normalize_line_endings_unix</span><span style=\"color:#E1E4E8\">(self, file_reader):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test normalization of Unix LF line endings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"line1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">line2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">line3</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call normalize_line_endings on content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert normalized lines are [\"line1\", \"line2\", \"line3\"]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert original_endings is \"LF\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_normalize_line_endings_windows</span><span style=\"color:#E1E4E8\">(self, file_reader):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test normalization of Windows CRLF line endings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test content with \\r\\n line endings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify normalization produces correct line list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify original format detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_binary_file_detection</span><span style=\"color:#E1E4E8\">(self, test_data_dir, file_reader):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that binary files are detected and rejected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create binary file with null bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify EncodingError is raised when reading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify error message indicates binary file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_file_not_found_error</span><span style=\"color:#E1E4E8\">(self, file_reader):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test appropriate error for nonexistent files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call read_file_lines on nonexistent file path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert FileSystemError is raised</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify error message contains file path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/test_lcs_engine.py - LCSEngine component tests  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestLCSEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test LCSEngine dynamic programming implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_compute_lcs_identical_sequences</span><span style=\"color:#E1E4E8\">(self, lcs_engine):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test LCS computation for identical sequences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        seq1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        seq2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call compute_lcs on identical sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert returned LCS equals input sequence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert LCS length equals sequence length</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_compute_lcs_no_common_elements</span><span style=\"color:#E1E4E8\">(self, lcs_engine):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test LCS computation when sequences share no elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create sequences with no common elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify LCS is empty list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify LCS length is 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_build_lcs_matrix_dimensions</span><span style=\"color:#E1E4E8\">(self, lcs_engine):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that LCS matrix has correct dimensions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        seq1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        seq2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"X\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Y\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Z\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call build_lcs_matrix on test sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert matrix has (len(seq1) + 1) rows</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert matrix has (len(seq2) + 1) columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify matrix[0][j] == 0 for all j (empty sequence base case)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify matrix[i][0] == 0 for all i (empty sequence base case)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_backtrack_simple_case</span><span style=\"color:#E1E4E8\">(self, lcs_engine, known_lcs_cases):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test backtracking for known LCS cases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> test_case </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> known_lcs_cases:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Build LCS matrix for test case sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call backtrack on completed matrix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert backtracked LCS matches expected result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify LCS is valid subsequence of both inputs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_memory_optimization_trigger</span><span style=\"color:#E1E4E8\">(self, lcs_engine):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that memory optimization triggers for large inputs.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create large test sequences that exceed memory threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Mock memory monitoring to verify optimization triggered  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify algorithm switches to memory-efficient version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure result correctness is maintained</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/test_diff_generator.py - DiffGenerator component tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestDiffGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test DiffGenerator hunk formation and edit operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_lcs_to_edit_operations_basic</span><span style=\"color:#E1E4E8\">(self, diff_generator):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test conversion of LCS to basic edit operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file1_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"B\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file2_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"X\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lcs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"A\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"C\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call lcs_to_edit_operations with test data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert operations are [UNCHANGED, DELETED, ADDED, UNCHANGED]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify line numbers are correctly assigned</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that content matches source lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_diff_lines_to_hunks_single_change</span><span style=\"color:#E1E4E8\">(self, diff_generator):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test hunk formation for single isolated change.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create DiffLine list with single change surrounded by unchanged lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call diff_lines_to_hunks with context_lines=2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert single hunk is created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify hunk contains appropriate context lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check hunk line counts and ranges</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_merge_adjacent_hunks</span><span style=\"color:#E1E4E8\">(self, diff_generator):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test merging of hunks that are close together.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create two hunks with small gap between them</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call merge_adjacent_hunks with appropriate max_gap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert hunks are merged into single hunk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify merged hunk has correct line counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that all lines from both hunks are preserved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_hunk_line_numbering</span><span style=\"color:#E1E4E8\">(self, diff_generator):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that hunk line numbers follow one-indexed conventions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create test diff operations with known line positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate hunks from operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify hunk headers use one-based line numbering</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check old_start, old_count, new_start, new_count values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/test_output_formatter.py - OutputFormatter component tests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestOutputFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test OutputFormatter unified diff generation and color output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_format_unified_diff_headers</span><span style=\"color:#E1E4E8\">(self, output_formatter):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test generation of unified diff file headers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FileContent(</span><span style=\"color:#9ECBFF\">\"file1.txt\"</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#9ECBFF\">\"line1\"</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UTF-8\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"LF\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        file2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> FileContent(</span><span style=\"color:#9ECBFF\">\"file2.txt\"</span><span style=\"color:#E1E4E8\">, [</span><span style=\"color:#9ECBFF\">\"line2\"</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"UTF-8\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"LF\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hunks </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Call format_unified_diff to generate output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert output starts with \"--- file1.txt\" header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert second line is \"+++ file2.txt\" header</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify header format matches unified diff standard</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_ansi_color_formatting</span><span style=\"color:#E1E4E8\">(self, output_formatter):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test ANSI color code application.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create DiffLine with DELETED type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Format line with colors enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert output contains red ANSI codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test ADDED lines get green colors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify UNCHANGED lines have no color</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_no_color_mode</span><span style=\"color:#E1E4E8\">(self, output_formatter):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test plain text output when colors are disabled.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Configure formatter with colors disabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Format diff lines of various types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert no ANSI codes appear in output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify line prefixes are still correct</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tests/test_integration.py - End-to-end integration tests  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestIntegration</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test complete diff tool pipeline integration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_complete_diff_pipeline</span><span style=\"color:#E1E4E8\">(self, sample_files):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test full pipeline from file reading to diff output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use sample files with known differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run complete diff pipeline: read -> LCS -> generate -> format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify output contains expected diff structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that generated diff could be applied with patch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_identical_files_handling</span><span style=\"color:#E1E4E8\">(self, sample_files):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test behavior when comparing identical files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare file with itself</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify no hunks are generated  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check appropriate exit code (0 for identical)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_performance_large_files</span><span style=\"color:#E1E4E8\">(self, tmp_path):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test performance with reasonably large files.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate large test files (1000+ lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run diff pipeline with timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify completion within reasonable time limit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check memory usage stays within bounds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"property-based-test-implementation\">Property-Based Test Implementation</h4>\n<p>Property-based testing automatically generates test inputs and verifies that important properties hold across all generated cases:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tests/test_properties.py - Property-based testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> hypothesis </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> given, strategies </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> st</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.lcs_engine </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LCSEngine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.diff_tool.diff_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DiffGenerator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestLCSProperties</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Property-based tests for LCS algorithm correctness.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @given</span><span style=\"color:#E1E4E8\">(st.lists(st.text(</span><span style=\"color:#FFAB70\">min_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_lcs_subsequence_property</span><span style=\"color:#E1E4E8\">(self, sequence):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that LCS result is valid subsequence of both inputs.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lcs_engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LCSEngine()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate second sequence as permutation/subset of first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compute LCS of both sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify LCS appears in both sequences in correct order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert LCS length &#x3C;= min(len(seq1), len(seq2))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @given</span><span style=\"color:#E1E4E8\">(st.lists(st.text(), </span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">), st.lists(st.text(), </span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">15</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_lcs_symmetry_property</span><span style=\"color:#E1E4E8\">(self, seq1, seq2):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that LCS(A,B) has same length as LCS(B,A).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lcs_engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LCSEngine()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compute LCS length for (seq1, seq2)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compute LCS length for (seq2, seq1) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert both lengths are equal</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestDiffProperties</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Property-based tests for diff generation correctness.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @given</span><span style=\"color:#E1E4E8\">(st.lists(st.text(), </span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">), st.lists(st.text(), </span><span style=\"color:#FFAB70\">max_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_diff_roundtrip_property</span><span style=\"color:#E1E4E8\">(self, file1_lines, file2_lines):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that applying diff operations transforms file1 to file2.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compute LCS of input files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate edit operations from LCS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply operations to file1_lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert result equals file2_lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-scripts\">Milestone Validation Scripts</h4>\n<p>Create standalone validation scripts that can be run after completing each milestone:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># scripts/validate_milestone_1.py - File reading validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#!/usr/bin/env python3</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Validate Milestone 1: Line Tokenization implementation.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_file_reading</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate basic file reading functionality.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== Milestone 1 Validation: Line Tokenization ===\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test encoding detection with sample files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify line normalization with different endings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check empty line preservation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test binary file rejection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Report validation results with pass/fail status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Validation complete. Check results above.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validate_file_reading()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># scripts/validate_milestone_2.py - LCS algorithm validation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#!/usr/bin/env python3</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Validate Milestone 2: LCS Algorithm implementation.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_lcs_computation</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate LCS dynamic programming correctness.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"=== Milestone 2 Validation: LCS Algorithm ===\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test with known LCS examples</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify matrix construction correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check backtracking produces valid LCS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test memory optimization for large inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Report algorithm performance metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Validation complete. Check results above.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validate_lcs_computation()</span></span></code></pre></div>\n\n<h4 id=\"debugging-and-performance-analysis-tools\">Debugging and Performance Analysis Tools</h4>\n<p>Create utilities to help diagnose issues and analyze performance during development:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tools/debug_lcs.py - LCS algorithm debugging utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> visualize_lcs_matrix</span><span style=\"color:#E1E4E8\">(seq1, seq2, matrix):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Print LCS matrix in readable format for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Print sequence labels across top and side</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Display matrix values in aligned grid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Highlight backtrack path if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Show final LCS result below matrix</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> trace_backtrack_path</span><span style=\"color:#E1E4E8\">(matrix, seq1, seq2):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Show step-by-step backtracking process.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Start from bottom-right matrix cell</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Print each backtrack decision and reasoning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Show how LCS is built in reverse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Display final LCS reconstruction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># tools/performance_profiler.py - Performance analysis utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> profile_lcs_performance</span><span style=\"color:#E1E4E8\">(sequence_lengths):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Profile LCS performance across different input sizes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate test sequences of specified lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Time LCS computation for each size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Measure memory usage during computation  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Plot performance curves</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify performance bottlenecks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> memory_usage_analyzer</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Analyze memory usage patterns during LCS computation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Monitor memory allocation during matrix building</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Track peak memory usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify memory optimization triggers correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Report memory efficiency metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — debugging skills are essential throughout line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4), with algorithm-specific techniques for each stage</p>\n</blockquote>\n<p><strong>Mental Model: Medical Diagnosis for Algorithms</strong> — Debugging a diff tool is like diagnosing a patient with multiple interconnected systems. Each component (File Reader, LCS Engine, Diff Generator, Output Formatter) represents an organ system, and symptoms in one area often indicate problems elsewhere. Just as doctors use systematic diagnostic procedures, we need structured approaches to identify the root cause of algorithmic failures. The key is understanding which symptoms point to which underlying conditions, and having the right diagnostic tools to peer inside each &quot;organ&quot; of our diff algorithm.</p>\n<p>Debugging diff algorithms presents unique challenges because failures can cascade through the pipeline in subtle ways. A file encoding issue in the File Reader can manifest as incorrect LCS computation, which then produces malformed diff hunks, ultimately resulting in garbled terminal output. The dynamic programming nature of LCS computation means that small indexing errors can propagate exponentially, while the contextual grouping in diff generation creates complex interdependencies between seemingly unrelated lines.</p>\n<p>The debugging process requires both systematic symptom analysis and deep algorithmic understanding. Unlike simple business logic bugs, diff algorithm failures often involve mathematical properties like optimal substructure, correctness of recurrence relations, and invariant preservation across component boundaries. This section provides learners with diagnostic frameworks specifically designed for these algorithmic challenges.</p>\n<h3 id=\"symptom-cause-fix-reference\">Symptom-Cause-Fix Reference</h3>\n<p>The following comprehensive reference table maps common symptoms encountered during diff tool implementation to their likely root causes and specific remediation strategies. Each entry includes detection techniques and step-by-step resolution procedures.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Detection Technique</th>\n<th>Specific Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Matrix index out of bounds during LCS computation</strong></td>\n<td>Off-by-one error in matrix dimensions or loop bounds</td>\n<td>Add boundary checks: <code>if i &lt; 0 or i &gt;= len(matrix)</code> before every access</td>\n<td>Matrix should be <code>(len(seq1)+1) x (len(seq2)+1)</code>. Loop indices should use <code>range(1, len(seq1)+1)</code> and <code>range(1, len(seq2)+1)</code> for filling</td>\n</tr>\n<tr>\n<td><strong>LCS returns empty result for files with obvious common lines</strong></td>\n<td>Backtracking algorithm moving in wrong direction through matrix</td>\n<td>Print backtrack path: log each <code>(i,j)</code> position and movement decision</td>\n<td>Fix backtracking conditions: move diagonally when <code>seq1[i-1] == seq2[j-1]</code>, not when matrix values are equal</td>\n</tr>\n<tr>\n<td><strong>Memory error or system freeze during LCS on large files</strong></td>\n<td>Algorithm using O(mn) space without optimization</td>\n<td>Monitor memory usage: <code>psutil.Process().memory_info().rss</code> during computation</td>\n<td>Implement two-row optimization: only keep current and previous matrix rows, or switch to Hirschberg&#39;s algorithm</td>\n</tr>\n<tr>\n<td><strong>Diff output shows wrong line numbers in hunk headers</strong></td>\n<td>Confusion between 0-indexed internal arrays and 1-indexed diff format</td>\n<td>Verify: print internal line numbers vs diff output line numbers side by side</td>\n<td>Add 1 to all line numbers when formatting: <code>old_line_num + 1</code> and <code>new_line_num + 1</code> in hunk headers</td>\n</tr>\n<tr>\n<td><strong>Missing lines or duplicated content in diff hunks</strong></td>\n<td>Incorrect edit operation assignment from LCS result</td>\n<td>Trace edit script generation: log every ADD/DELETE/UNCHANGED decision with line content</td>\n<td>Fix <code>lcs_to_edit_operations</code>: ensure each line from both files appears exactly once in edit operations</td>\n</tr>\n<tr>\n<td><strong>Hunk context lines show incorrect content</strong></td>\n<td>Context extraction using wrong line indices or ranges</td>\n<td>Print context ranges: log <code>start_idx</code> and <code>end_idx</code> for each context region</td>\n<td>Context should use original file line indices, not edit operation indices. Verify bounds checking against <code>len(file_lines)</code></td>\n</tr>\n<tr>\n<td><strong>File reading fails with encoding errors</strong></td>\n<td>Binary file processed as text, or wrong encoding assumption</td>\n<td>Check file type: <code>file --mime-type filename</code> and inspect first 100 bytes as hex</td>\n<td>Implement binary detection: if file contains null bytes or high percentage of non-printable characters, reject as binary</td>\n</tr>\n<tr>\n<td><strong>Line endings inconsistent in output</strong></td>\n<td>Mixed line ending normalization or preservation failure</td>\n<td>Hexdump file endings: `od -c filename</td>\n<td>tail` to see actual line terminators</td>\n</tr>\n<tr>\n<td><strong>Empty files cause crashes</strong></td>\n<td>Missing edge case handling for zero-length sequences</td>\n<td>Test with: <code>touch empty.txt &amp;&amp; diff_tool empty.txt nonempty.txt</code></td>\n<td>Add checks: if <code>len(sequence) == 0</code>, return appropriate empty results instead of processing through normal algorithm</td>\n</tr>\n<tr>\n<td><strong>Identical files show differences</strong></td>\n<td>Whitespace normalization inconsistency or trailing newline handling</td>\n<td>Compare raw bytes: <code>cmp file1 file2</code> vs your tool&#39;s result</td>\n<td>Ensure identical normalization: both files must undergo same whitespace trimming and line ending conversion</td>\n</tr>\n<tr>\n<td><strong>Color codes appear in redirected output</strong></td>\n<td>TTY detection failure or missing --no-color support</td>\n<td>Test: <code>diff_tool file1 file2 &gt; output.txt &amp;&amp; cat output.txt</code></td>\n<td>Fix TTY detection: use <code>sys.stdout.isatty()</code> and respect <code>--no-color</code> flag to disable ANSI codes</td>\n</tr>\n<tr>\n<td><strong>Hunks merge incorrectly or stay separate unexpectedly</strong></td>\n<td>Hunk merging logic using wrong distance calculation</td>\n<td>Print hunk gaps: log line numbers between consecutive hunks and merge decisions</td>\n<td>Gap calculation should be <code>hunk2.old_start - (hunk1.old_start + hunk1.old_count + hunk1.context_after)</code>. Merge if gap ≤ 2 * context_lines</td>\n</tr>\n<tr>\n<td><strong>Program hangs during file processing</strong></td>\n<td>Infinite loop in backtracking or file reading without progress</td>\n<td>Add progress logging: print percentage completion every 1000 iterations</td>\n<td>Check loop termination: backtracking should always decrease <code>i</code> or <code>j</code>, file reading should check for EOF after each read operation</td>\n</tr>\n<tr>\n<td><strong>Diff output missing @@ hunk headers</strong></td>\n<td>Hunk header generation skipped or formatted incorrectly</td>\n<td>Verify header format: should match regex <code>@@\\s-\\d+,\\d+\\s\\+\\d+,\\d+\\s@@</code></td>\n<td>Header format: <code>@@ -{old_start},{old_count} +{new_start},{new_count} @@</code> with 1-indexed line numbers</td>\n</tr>\n<tr>\n<td><strong>Exit code always 0 regardless of differences</strong></td>\n<td>Exit code logic not implemented or wrong conditions</td>\n<td>Test: <code>diff_tool identical.txt identical.txt; echo $?</code> should be 0, different files should be 1</td>\n<td>Set exit code based on diff result: <code>sys.exit(0)</code> if no differences found, <code>sys.exit(1)</code> if differences exist</td>\n</tr>\n<tr>\n<td><strong>Context lines duplicated at hunk boundaries</strong></td>\n<td>Overlapping context regions not handled during hunk merging</td>\n<td>Check context overlap: log context ranges when merging adjacent hunks</td>\n<td>When merging hunks, deduplicate overlapping context: shared lines should appear once, not in both hunks</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Debugging with Print Statements</strong>\nMany learners add <code>print()</code> statements throughout their algorithm but this creates several problems. Print debugging can mask timing issues, produce overwhelming output that obscures the actual problem, and interfere with proper output formatting (especially with color codes). Instead, use structured logging with levels (<code>logging.debug()</code>, <code>logging.info()</code>) and enable debug output only when needed via command-line flags.</p>\n<p>⚠️ <strong>Pitfall: Testing Only with Small Files</strong>\nAlgorithms that work perfectly on 10-line files can fail catastrophically on 1000-line files due to memory exhaustion, indexing errors that only manifest at scale, or performance degradation that reveals algorithmic flaws. Always test with files of varying sizes: empty files, single-line files, files with thousands of lines, and files with very long individual lines.</p>\n<h3 id=\"debugging-techniques\">Debugging Techniques</h3>\n<p>The following systematic approaches provide structured methods for diagnosing and resolving issues specific to diff algorithm implementation. Each technique targets different aspects of the algorithm pipeline and provides concrete steps for investigation.</p>\n<h4 id=\"matrix-inspection-and-visualization\">Matrix Inspection and Visualization</h4>\n<p>The LCS dynamic programming matrix contains the complete computational history and can reveal algorithmic errors that are invisible from final output alone. Understanding how to read and interpret the matrix is crucial for debugging the core algorithm.</p>\n<p><strong>Matrix Validation Technique:</strong></p>\n<p>Create a matrix visualization function that displays the LCS matrix with sequence elements as headers. For sequences <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code> and <code>[&quot;a&quot;, &quot;c&quot;]</code>, the correct matrix should show:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>    &quot;&quot;  a   c\n&quot;&quot;   0  0   0\na    0  1   1  \nb    0  1   1\nc    0  1   2</code></pre></div>\n\n<p>The matrix reveals several key properties that must hold for correct LCS computation. Each cell <code>(i,j)</code> represents the LCS length for the first <code>i</code> elements of sequence 1 and first <code>j</code> elements of sequence 2. Values should never decrease when moving right or down through the matrix. The bottom-right cell contains the final LCS length. Diagonal moves (when characters match) should increment the value from the diagonal predecessor.</p>\n<p><strong>Backtracking Path Verification:</strong></p>\n<p>Implement a path tracer that logs each backtracking decision with its rationale. The backtracking algorithm should follow these decision rules consistently:</p>\n<ol>\n<li>If characters match (<code>seq1[i-1] == seq2[j-1]</code>), move diagonally and include the character in LCS</li>\n<li>If <code>matrix[i-1][j] &gt; matrix[i][j-1]</code>, move up (deletion from sequence 1)  </li>\n<li>Otherwise, move left (insertion into sequence 1)</li>\n</ol>\n<p>Log each decision: <code>&quot;At (3,2): seq1[2]=&#39;c&#39; != seq2[1]=&#39;c&#39; - MISMATCH. matrix[2][2]=1, matrix[3][1]=1. Moving left.&quot;</code> This reveals logic errors in the backtracking conditions.</p>\n<p><strong>Common Matrix Debugging Patterns:</strong></p>\n<p>Values that are too high indicate incorrect recurrence relation implementation - check that matches only increment by 1 and non-matches take the maximum of adjacent cells. Zeros appearing in unexpected locations suggest initialization problems or boundary condition errors. A matrix filled entirely with 1s typically indicates the loop is only comparing the first characters repeatedly rather than iterating through sequences correctly.</p>\n<h4 id=\"algorithm-execution-tracing\">Algorithm Execution Tracing</h4>\n<p>Step-by-step execution tracing reveals the decision-making process within each algorithm component and helps identify where expectations diverge from reality.</p>\n<p><strong>LCS Computation Tracing:</strong></p>\n<p>Implement detailed logging for each matrix cell computation. For each <code>(i,j)</code> position, log the comparison being made, the predecessor values consulted, and the resulting cell value. This creates an audit trail of the dynamic programming process:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Computing cell (2,3): comparing seq1[1]='b' with seq2[2]='c'\n  Characters don't match\n  Left neighbor matrix[2][2] = 1  \n  Top neighbor matrix[1][3] = 1\n  Taking max(1,1) = 1\n  Setting matrix[2][3] = 1</code></pre></div>\n\n<p>This granular tracing immediately reveals whether the algorithm is accessing correct sequence positions, using proper indexing, and applying the recurrence relation correctly.</p>\n<p><strong>Edit Operation Generation Tracing:</strong></p>\n<p>When converting LCS results to edit operations, trace each decision point that determines whether a line should be marked as UNCHANGED, ADDED, or DELETED. Log the current positions in both sequences, the characters being compared, and the reasoning for the operation type assignment:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>LCS position 5: seq1[7]='def' matches seq2[12]='def' → UNCHANGED\nBetween matches: seq1[8]='ghi' not in LCS → DELETED  \nNext LCS match at seq2[13]='jkl', gap seq2[13]='extra' → ADDED</code></pre></div>\n\n<p>This reveals gaps in LCS coverage and ensures every line from both input sequences is properly classified in the edit script.</p>\n<p><strong>Hunk Formation Tracing:</strong></p>\n<p>The process of grouping edit operations into hunks with context involves complex boundary calculations and merging decisions. Trace each step of hunk formation:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Found change block: lines 10-15 (3 deletions, 2 additions)\nAdding context: before=[7,8,9] after=[16,17,18]  \nHunk created: old_start=8 old_count=9 new_start=8 new_count=8\nChecking merge with next hunk at line 25: gap=7 &gt; 2*context(3) → separate hunks</code></pre></div>\n\n<p>This debugging approach reveals incorrect line counting, context boundary errors, and merging logic failures.</p>\n<h4 id=\"output-format-validation\">Output Format Validation</h4>\n<p>Diff output must conform to standardized formats that other tools can parse correctly. Validation techniques ensure compliance with format specifications.</p>\n<p><strong>Unified Diff Format Compliance:</strong></p>\n<p>Implement a format validator that checks each element of the unified diff output against the specification. The validator should verify:</p>\n<ul>\n<li>File headers use exactly <code>---</code> and <code>+++</code> prefixes with proper spacing</li>\n<li>Hunk headers match the pattern <code>@@ -{old_start},{old_count} +{new_start},{new_count} @@</code></li>\n<li>Line prefixes are exactly one character: space for unchanged, <code>-</code> for deleted, <code>+</code> for added</li>\n<li>Line numbers in headers are 1-indexed and match the actual line counts in the hunk body</li>\n<li>No trailing whitespace on empty lines (represented as single prefix character)</li>\n</ul>\n<p><strong>ANSI Color Code Validation:</strong></p>\n<p>When color output is enabled, verify that ANSI codes are properly paired and don&#39;t interfere with format parsing. Create a validator that strips ANSI codes and confirms the underlying text still matches unified diff format:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_color_output</span><span style=\"color:#E1E4E8\">(colored_line):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stripped </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.sub(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\033\\[</span><span style=\"color:#79B8FF\">[0-9;]</span><span style=\"color:#F97583\">*</span><span style=\"color:#DBEDFF\">m</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">, colored_line)  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> validate_diff_line_format(stripped)</span></span></code></pre></div>\n\n<p>Color codes should only wrap the content portion of diff lines, not the prefix characters or line numbers that tools use for parsing.</p>\n<p><strong>Line Number Consistency Checking:</strong></p>\n<p>Implement a checker that verifies line number consistency throughout the diff output. Track running totals of old and new line numbers as you process each hunk, ensuring that:</p>\n<ul>\n<li>Hunk header line counts match the actual number of lines in the hunk body</li>\n<li>Line number sequences are continuous with no gaps or duplicates  </li>\n<li>UNCHANGED lines increment both old and new line counters</li>\n<li>DELETED lines increment only old line counter</li>\n<li>ADDED lines increment only new line counter</li>\n</ul>\n<p>This catches off-by-one errors and incorrect line counting that can make diff output unusable by other tools.</p>\n<h4 id=\"memory-and-performance-debugging\">Memory and Performance Debugging</h4>\n<p>Large file processing reveals memory leaks, inefficient algorithms, and resource management issues that don&#39;t appear with small test cases.</p>\n<p><strong>Memory Usage Monitoring:</strong></p>\n<p>Implement memory tracking that monitors heap usage throughout algorithm execution. Track peak memory usage during matrix construction, backtracking, and diff generation phases:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> gc</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> track_memory</span><span style=\"color:#E1E4E8\">(phase_name):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    gc.collect()  </span><span style=\"color:#6A737D\"># Force garbage collection  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.Process()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> process.memory_info().rss </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">phase_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">memory_mb</span><span style=\"color:#F97583\">:.1f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> MB\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>Monitor for memory growth that doesn&#39;t match algorithmic expectations. The LCS matrix should require approximately <code>len(seq1) * len(seq2) * 8 bytes</code> for integer storage. Significantly higher usage indicates data structure inefficiency or memory leaks.</p>\n<p><strong>Algorithm Complexity Verification:</strong></p>\n<p>Measure actual runtime against theoretical complexity expectations. For sequences of length <code>m</code> and <code>n</code>, LCS computation should exhibit O(mn) time complexity. Test with progressively larger inputs and verify that runtime scales predictably:</p>\n<ul>\n<li>100x100 sequences → baseline time T</li>\n<li>200x200 sequences → approximately 4T  </li>\n<li>1000x1000 sequences → approximately 100T</li>\n</ul>\n<p>Deviation from expected scaling indicates algorithmic inefficiency or implementation errors that cause redundant computation.</p>\n<p><strong>Resource Limit Testing:</strong></p>\n<p>Test algorithm behavior at system resource boundaries. Create test cases that approach memory limits, processing time limits, and file system constraints. This reveals whether the algorithm fails gracefully or crashes unpredictably:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test with files approaching memory limits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">large_file_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.virtual_memory().available </span><span style=\"color:#F97583\">//</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">create_test_file(large_file_size)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test with deep recursion (for recursive implementations)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sys.setrecursionlimit(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Lower than default</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">test_with_long_sequences()</span></span></code></pre></div>\n\n<h4 id=\"property-based-testing-integration\">Property-Based Testing Integration</h4>\n<p>Property-based testing generates random inputs and verifies that algorithmic properties hold across diverse scenarios.</p>\n<p><strong>LCS Property Verification:</strong></p>\n<p>Implement property tests that verify fundamental LCS properties:</p>\n<ul>\n<li><strong>Subsequence Property</strong>: Every element in the returned LCS must appear in both original sequences in the same relative order</li>\n<li><strong>Optimality Property</strong>: No longer common subsequence should exist (verify by checking all possible extensions)</li>\n<li><strong>Symmetry Property</strong>: <code>lcs(A, B)</code> should have the same length as <code>lcs(B, A)</code> (though elements may differ if multiple optimal solutions exist)</li>\n</ul>\n<p><strong>Edit Script Property Verification:</strong></p>\n<p>Verify that edit scripts correctly transform one sequence into another:</p>\n<ul>\n<li><strong>Transformation Property</strong>: Applying all edit operations to sequence 1 should yield sequence 2</li>\n<li><strong>Minimality Property</strong>: The total number of ADD and DELETE operations should equal the edit distance</li>\n<li><strong>Coverage Property</strong>: Every line from both input sequences should appear exactly once across all edit operations</li>\n</ul>\n<p><strong>Round-Trip Testing:</strong></p>\n<p>Implement round-trip tests that verify the complete pipeline preserves information correctly:</p>\n<ol>\n<li>Start with two known file contents</li>\n<li>Process through complete diff pipeline  </li>\n<li>Apply the generated diff operations to reconstruct the second file</li>\n<li>Verify the reconstructed content matches the original second file exactly</li>\n</ol>\n<p>This end-to-end testing catches subtle bugs that unit tests might miss, especially issues involving line ending preservation, whitespace handling, and context line selection.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging Framework</td>\n<td>Python <code>logging</code> with console handler</td>\n<td>Structured logging with JSON output and log levels</td>\n</tr>\n<tr>\n<td>Memory Profiling</td>\n<td><code>psutil</code> for basic memory monitoring</td>\n<td><code>memory_profiler</code> with line-by-line analysis</td>\n</tr>\n<tr>\n<td>Test Generation</td>\n<td>Manual test cases with known outputs</td>\n<td><code>hypothesis</code> for property-based test generation</td>\n</tr>\n<tr>\n<td>Performance Measurement</td>\n<td><code>time.time()</code> for basic timing</td>\n<td><code>cProfile</code> with statistical analysis</td>\n</tr>\n<tr>\n<td>Matrix Visualization</td>\n<td>Print statements with formatted output</td>\n<td>Rich terminal UI with color-coded matrices</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  debug/\n    matrix_visualizer.py     ← LCS matrix inspection tools\n    trace_logger.py          ← Algorithm execution tracing\n    property_tester.py       ← Property-based test generators\n    memory_profiler.py       ← Resource usage monitoring\n    format_validator.py      ← Output format compliance checking\n  tests/\n    debug_test_cases/       ← Problematic cases for debugging\n      edge_cases.py         ← Empty files, identical files, etc.\n      large_files.py        ← Memory and performance stress tests\n      malformed_input.py    ← Binary files, encoding issues\n  src/\n    diff_tool/\n      debug_hooks.py        ← Integration points for debugging tools</code></pre></div>\n\n<h4 id=\"debugging-infrastructure-starter-code\">Debugging Infrastructure Starter Code</h4>\n<p><strong>Complete Matrix Visualizer:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Matrix visualization and validation tools for LCS debugging.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MatrixVisualizer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides visualization and validation for LCS dynamic programming matrices.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, seq1: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], seq2: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], matrix: List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.seq1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.seq2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq2  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.matrix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> matrix</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> display_matrix</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate a formatted matrix display with sequence headers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Calculate column widths for proper alignment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        col_widths </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(val))) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> val </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq2]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        row_headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Build header row</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        header </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">val</span><span style=\"color:#F97583\">:></span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">width</span><span style=\"color:#79B8FF\">}}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> val, width </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">([</span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.seq2, col_widths))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [header]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Build data rows  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, row_header </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(row_headers):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            row_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [row_header] </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix[i][j]) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix[i]))]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">val</span><span style=\"color:#F97583\">:></span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">width</span><span style=\"color:#79B8FF\">}}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> val, width </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(row_data, col_widths))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lines.append(line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">.join(lines)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_matrix_properties</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that matrix satisfies LCS properties.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check dimensions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected_rows </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq1) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected_cols </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq2) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected_rows:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Wrong row count: got </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_rows</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(row) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected_cols </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> row </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Inconsistent column count: expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_cols</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check boundary conditions (first row and column should be zeros)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">][j] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]))):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#9ECBFF\">\"First row should be all zeros\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix[i][</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix))):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#9ECBFF\">\"First column should be all zeros\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check monotonicity (values never decrease moving right or down)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix)):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.matrix[i])):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix[i][j]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                left </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix[i][j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                top </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">][j]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> left:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Value decreased moving right at (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">left</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> -> </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">current</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> top:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Value decreased moving down at (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">): </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">top</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> -> </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">current</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BacktrackTracer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Traces backtracking path through LCS matrix for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, matrix: List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]], seq1: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], seq2: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.matrix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> matrix</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.seq1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.seq2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> seq2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace_backtrack</span><span style=\"color:#E1E4E8\">(self) -> Tuple[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], List[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Perform backtracking with detailed logging of each decision.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lcs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        i, j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq1), </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix[i][j]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.seq1[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.seq2[j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Characters match - move diagonally</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                lcs.append(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.seq1[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                path.append((i, j, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"MATCH: '</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.seq1[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' - diagonal to (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                i </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                j </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">][j] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.matrix[i][j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Deletion from seq1 - move up</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                path.append((i, j, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"DELETE seq1[</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">]='</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.seq1[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' - up to (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                i </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Insertion into seq1 - move left  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                path.append((i, j, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"INSERT seq2[</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">]='</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.seq2[j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' - left to (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">,</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                j </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Handle remaining elements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            path.append((i, j, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"DELETE remaining seq1[</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">]='</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.seq1[i</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            i </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            path.append((i, j, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"INSERT remaining seq2[</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1}</span><span style=\"color:#9ECBFF\">]='</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.seq2[j</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            j </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lcs.reverse()  </span><span style=\"color:#6A737D\"># Backtracking builds LCS in reverse order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> lcs, path</span></span></code></pre></div>\n\n<p><strong>Complete Performance Monitor:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Performance and resource monitoring for diff algorithm debugging.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> gc</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceStats</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Statistics collected during algorithm execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_time: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    end_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peak_memory_mb: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operations_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matrix_size: Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm_phase: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">property</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> elapsed_time</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end_time </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceMonitor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Monitors resource usage during algorithm execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stats: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PerformanceStats] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_phase: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_phase</span><span style=\"color:#E1E4E8\">(self, phase_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, matrix_size: Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Begin monitoring a specific algorithm phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.end_phase()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> phase_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        gc.collect()  </span><span style=\"color:#6A737D\"># Clean slate for memory measurement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stats[phase_name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PerformanceStats(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            start_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            end_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            peak_memory_mb</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._get_memory_usage_mb(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            operations_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            matrix_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">matrix_size,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            algorithm_phase</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">phase_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> end_phase</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Complete monitoring of current phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stats.peak_memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(stats.peak_memory_mb, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._get_memory_usage_mb())</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_operation</span><span style=\"color:#E1E4E8\">(self, count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record completion of algorithm operations (e.g., matrix cell computations).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase].operations_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Update peak memory periodically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase].operations_count </span><span style=\"color:#F97583\">%</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._get_memory_usage_mb()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase].peak_memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase].peak_memory_mb, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    current_memory</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_report</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate performance report for all monitored phases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        report </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> phase_name, stats </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            complexity_score </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"N/A\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> stats.matrix_size[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> stats.matrix_size[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                expected_ops </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> stats.matrix_size[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> stats.matrix_size[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> expected_ops </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    complexity_score </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">stats.operations_count </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> expected_ops</span><span style=\"color:#F97583\">:.2f</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">x expected\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            report[phase_name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"elapsed_time\"</span><span style=\"color:#E1E4E8\">: stats.elapsed_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"peak_memory_mb\"</span><span style=\"color:#E1E4E8\">: stats.peak_memory_mb,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"operations\"</span><span style=\"color:#E1E4E8\">: stats.operations_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"matrix_size\"</span><span style=\"color:#E1E4E8\">: stats.matrix_size,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"complexity_score\"</span><span style=\"color:#E1E4E8\">: complexity_score</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> report</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_memory_usage_mb</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current process memory usage in MB.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.Process()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> process.memory_info().rss </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> 1024</span></span></code></pre></div>\n\n<h4 id=\"core-debugging-integration-points\">Core Debugging Integration Points</h4>\n<p><strong>Debug-Enhanced LCS Engine:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DebugLCSEngine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LCSEngine</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"LCS engine with debugging capabilities enabled.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, debug_enabled: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.debug_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> debug_enabled</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.visualizer: Optional[MatrixVisualizer] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tracer: Optional[BacktrackTracer] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.monitor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PerformanceMonitor()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compute_lcs</span><span style=\"color:#E1E4E8\">(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compute LCS with optional debugging instrumentation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start performance monitoring for matrix construction phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Build LCS matrix with debug logging if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create matrix visualizer if debug mode active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate matrix properties and report any violations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Start performance monitoring for backtracking phase  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Perform backtracking with path tracing if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Generate performance report and debug output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return CommonSubsequence with debug metadata attached</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _debug_matrix_construction</span><span style=\"color:#E1E4E8\">(self, seq1: Sequence, seq2: Sequence) -> List[List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Build matrix with detailed logging for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Log matrix dimensions and expected memory usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize matrix with boundary condition logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Fill matrix with cell-by-cell operation logging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate intermediate results every N operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check for memory usage spikes during construction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_and_report</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate comprehensive debugging report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Run matrix property validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate matrix visualization if requested</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create backtracking trace log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Compile performance statistics  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Write debug report to configured output stream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-debugging-hints\">Language-Specific Debugging Hints</h4>\n<p><strong>Python Debugging Tools:</strong></p>\n<ul>\n<li>Use <code>pdb.set_trace()</code> for interactive debugging at algorithm decision points</li>\n<li>Install <code>memory_profiler</code>: <code>pip install memory_profiler</code> for line-by-line memory analysis  </li>\n<li>Use <code>sys.getsizeof()</code> to measure data structure memory usage</li>\n<li>Enable warnings: <code>python -W all diff_tool.py</code> to catch potential issues</li>\n<li>Use <code>tracemalloc</code> module for detailed memory allocation tracking</li>\n</ul>\n<p><strong>Matrix Indexing Safety:</strong></p>\n<ul>\n<li>Always use <code>range(1, len(seq)+1)</code> for matrix filling loops to avoid off-by-one errors</li>\n<li>Add assertions: <code>assert 0 &lt;= i &lt; len(matrix)</code> before every matrix access</li>\n<li>Use <code>matrix[i][j] if i &lt; len(matrix) and j &lt; len(matrix[i]) else 0</code> for safe access</li>\n</ul>\n<p><strong>File Handling Edge Cases:</strong></p>\n<ul>\n<li>Test with <code>os.devnull</code> as input to verify empty file handling</li>\n<li>Use <code>tempfile.NamedTemporaryFile()</code> for creating test files with specific encodings</li>\n<li>Test with files lacking trailing newlines: <code>echo -n &quot;content&quot; &gt; test.txt</code></li>\n</ul>\n<h4 id=\"milestone-checkpoint-integration\">Milestone Checkpoint Integration</h4>\n<p><strong>After Milestone 1 (Line Tokenization):</strong>\nExpected behavior: <code>python debug/test_tokenization.py</code> should validate file reading with various encodings and line endings. Manual verification: create files with different encodings and verify line counts match <code>wc -l</code> output.</p>\n<p><strong>After Milestone 2 (LCS Algorithm):</strong><br>Expected behavior: <code>python debug/matrix_validator.py</code> should confirm matrix properties hold for test cases. Debug output should show matrix visualization for small examples. Performance monitor should report O(mn) complexity scaling.</p>\n<p><strong>After Milestone 3 (Diff Generation):</strong>\nExpected behavior: <code>python debug/format_validator.py</code> should verify unified diff format compliance. Round-trip tests should successfully reconstruct target files from diff operations.</p>\n<p><strong>After Milestone 4 (CLI and Color Output):</strong>\nExpected behavior: All debugging tools should work through CLI interface. Color output should validate correctly in both TTY and pipe modes. Exit codes should match diff result status.</p>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — future extensions build upon the complete foundation from line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)</p>\n</blockquote>\n<p>The current diff tool design provides a solid foundation that can accommodate numerous enhancements while maintaining architectural integrity. Like building a house with a strong foundation that can support additional floors, our component-based architecture with clear separation between <code>FileReader</code>, <code>LCSEngine</code>, <code>DiffGenerator</code>, and <code>OutputFormatter</code> allows for incremental improvements without requiring fundamental restructuring.</p>\n<p>The extension strategy follows a principle of <strong>progressive enhancement</strong> — each improvement builds upon existing capabilities while preserving backward compatibility. This approach ensures that basic diff functionality remains stable while advanced features can be added, disabled, or modified independently. The modular design means that algorithm improvements can be implemented as alternative strategies within the <code>LCSEngine</code>, while output enhancements can be added as new formatters alongside the existing <code>OutputFormatter</code>.</p>\n<h3 id=\"algorithm-improvements\">Algorithm Improvements</h3>\n<p>The current LCS-based approach represents just one point in the rich landscape of diff algorithms. Like choosing between different route-finding algorithms for navigation — some optimize for shortest distance, others for fastest time, others for avoiding traffic — different diff algorithms optimize for different characteristics. Our architecture anticipates this diversity by encapsulating algorithm choice within the <code>LCSEngine</code> component.</p>\n<h4 id=\"myers39-algorithm-implementation\">Myers&#39; Algorithm Implementation</h4>\n<p><strong>Mental Model: The Shortest Edit Path</strong><br>Think of text comparison as finding the shortest path through a maze where each cell represents a comparison between characters or lines. Myers&#39; algorithm is like having a GPS that explores multiple paths simultaneously, always pursuing the most promising routes first. Instead of filling out the entire maze (like our current LCS matrix approach), Myers&#39; algorithm uses an <strong>edit graph</strong> where diagonal moves represent matches and horizontal/vertical moves represent insertions/deletions.</p>\n<p>The algorithm maintains a concept of <strong>edit distance</strong> — the minimum number of operations needed to transform one sequence into another. Myers&#39; algorithm achieves O(n+d²) expected performance where d is the actual edit distance, making it significantly faster than O(mn) LCS when files are similar.</p>\n<blockquote>\n<p><strong>Decision: Myers&#39; Algorithm Integration Strategy</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Current O(mn) LCS algorithm becomes prohibitively slow for large files, especially when most content is similar  </li>\n<li><strong>Options Considered</strong>: Replace LCS entirely, implement Myers&#39; as alternative strategy, hybrid approach  </li>\n<li><strong>Decision</strong>: Implement Myers&#39; as selectable strategy within existing <code>LCSEngine</code> architecture  </li>\n<li><strong>Rationale</strong>: Preserves backward compatibility while providing performance benefits; allows algorithm comparison and fallback behavior  </li>\n<li><strong>Consequences</strong>: Enables handling larger files efficiently while maintaining simple LCS for educational purposes and edge cases</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Algorithm Aspect</th>\n<th>LCS Dynamic Programming</th>\n<th>Myers&#39; Algorithm</th>\n<th>Implementation Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time Complexity</td>\n<td>O(mn) always</td>\n<td>O(n+d²) expected</td>\n<td>Myers&#39; much faster for similar files</td>\n</tr>\n<tr>\n<td>Space Complexity</td>\n<td>O(mn) or O(min(m,n)) optimized</td>\n<td>O(n+d)</td>\n<td>Myers&#39; uses less memory</td>\n</tr>\n<tr>\n<td>Implementation Complexity</td>\n<td>Straightforward DP table</td>\n<td>Complex edit graph traversal</td>\n<td>Myers&#39; requires more sophisticated code</td>\n</tr>\n<tr>\n<td>Educational Value</td>\n<td>Excellent for learning DP</td>\n<td>Advanced algorithm concepts</td>\n<td>Keep both for different learning objectives</td>\n</tr>\n<tr>\n<td>Worst-Case Behavior</td>\n<td>Predictable O(mn)</td>\n<td>Can degrade to O(mn) for very different files</td>\n<td>Need fallback strategy</td>\n</tr>\n</tbody></table>\n<p>The <code>LCSEngine</code> would be enhanced with a strategy selection mechanism. The <code>choose_strategy(seq1_len, seq2_len)</code> method would analyze input characteristics and select the optimal algorithm. For files under 1000 lines or when educational mode is enabled, the system would use traditional LCS. For larger files, Myers&#39; algorithm would be preferred.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Enhanced LCSEngine with algorithm selection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> choose_strategy</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> MemoryStrategy:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    estimated_lcs_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (seq1_len </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> seq2_len </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># MB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.educational_mode </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> seq1_len </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#F97583\"> or</span><span style=\"color:#E1E4E8\"> seq2_len </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> MemoryStrategy(</span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"lcs_matrix\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_memory_mb</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">estimated_lcs_memory, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                            estimated_time_factor</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> estimated_lcs_memory </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.memory_optimizer.max_memory_mb:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> MemoryStrategy(</span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"myers\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_memory_mb</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">estimated_lcs_memory </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                            estimated_time_factor</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0.3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> MemoryStrategy(</span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"lcs_matrix\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max_memory_mb</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">estimated_lcs_memory,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                            estimated_time_factor</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>The Myers&#39; implementation would require a new <code>EditGraph</code> data structure and <code>MyersEngine</code> class that implements the same interface as the current LCS approach but uses fundamentally different internal algorithms.</p>\n<h4 id=\"word-level-and-character-level-diffing\">Word-Level and Character-Level Diffing</h4>\n<p><strong>Mental Model: Zoom Levels in Image Editing</strong><br>Current line-level diffing is like viewing an image at 100% zoom — you see the overall structure but miss fine details. Word-level diffing is like zooming to 200% to see individual pixels, while character-level diffing is like examining the image at 400% magnification. Each zoom level reveals different types of changes that matter for different use cases.</p>\n<p>Word-level diffing becomes essential when comparing prose documents, configuration files, or code where line boundaries don&#39;t align with logical changes. A developer who renames a variable or fixes a typo shouldn&#39;t see the entire line marked as deleted and re-added — they should see the specific word that changed highlighted within the line context.</p>\n<blockquote>\n<p><strong>Decision: Hierarchical Diffing Architecture</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Line-level diffing misses granular changes within lines, making output less readable for small modifications  </li>\n<li><strong>Options Considered</strong>: Replace line diffing with word diffing, implement separate word-diff tool, hierarchical approach  </li>\n<li><strong>Decision</strong>: Implement hierarchical diffing where line-level diff identifies changed lines, then word-level diff analyzes differences within those lines  </li>\n<li><strong>Rationale</strong>: Provides both structural overview and detailed changes; leverages existing line-level infrastructure  </li>\n<li><strong>Consequences</strong>: More complex output format but significantly improved usability for code review and document editing</li>\n</ul>\n</blockquote>\n<p>The architecture would extend the <code>DiffGenerator</code> component with a <code>HierarchicalDiffGenerator</code> that performs multi-level analysis:</p>\n<table>\n<thead>\n<tr>\n<th>Diff Level</th>\n<th>Input Unit</th>\n<th>Algorithm</th>\n<th>Use Case</th>\n<th>Output Enhancement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Line</td>\n<td>File lines</td>\n<td>Current LCS/Myers&#39;</td>\n<td>Structural changes</td>\n<td>Current unified diff format</td>\n</tr>\n<tr>\n<td>Word</td>\n<td>Line tokens split by whitespace/punctuation</td>\n<td>LCS on word sequences</td>\n<td>Variable renames, text editing</td>\n<td>Highlighted words within unchanged lines</td>\n</tr>\n<tr>\n<td>Character</td>\n<td>Individual characters</td>\n<td>Character-level LCS</td>\n<td>Typo fixes, small edits</td>\n<td>Precise change highlighting</td>\n</tr>\n<tr>\n<td>Semantic</td>\n<td>AST nodes (future)</td>\n<td>Tree diff algorithms</td>\n<td>Code refactoring</td>\n<td>Semantic change descriptions</td>\n</tr>\n</tbody></table>\n<p>The word-level implementation would introduce a <code>TokenizerEngine</code> that splits lines into meaningful units:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> tokenize_line</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, mode: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[Token]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Split line into tokens based on mode (word, character, semantic)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Apply appropriate tokenization strategy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Preserve whitespace information for reconstruction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle punctuation and special characters appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return Token objects with position and type metadata</span></span></code></pre></div>\n\n<p>Each <code>Token</code> would maintain enough information to reconstruct the original line while enabling granular diff analysis. The <code>DiffGenerator</code> would first perform line-level diffing, then apply word-level analysis to lines marked as changed, producing nested <code>DiffLine</code> objects that contain both line-level and word-level change information.</p>\n<h4 id=\"semantic-diffing-for-code\">Semantic Diffing for Code</h4>\n<p><strong>Mental Model: Understanding vs. Memorizing</strong><br>Traditional diff algorithms are like students who memorize text without understanding — they notice every character change but miss the logical meaning. Semantic diffing is like a teacher who understands the subject matter and can recognize when two different explanations convey the same concept. For code, this means understanding that <code>if (x == true)</code> and <code>if (x)</code> are semantically equivalent even though they&#39;re textually different.</p>\n<p>Semantic diffing requires parsing code into Abstract Syntax Trees (AST) and comparing structural relationships rather than textual representation. This approach can identify meaningful changes like algorithm modifications while ignoring cosmetic changes like formatting, variable renames that don&#39;t affect logic, or comment additions.</p>\n<p>The implementation would extend our architecture with a <code>SemanticDiffEngine</code> that operates on AST representations:</p>\n<table>\n<thead>\n<tr>\n<th>Code Change Type</th>\n<th>Traditional Diff View</th>\n<th>Semantic Diff View</th>\n<th>Business Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Variable Rename</td>\n<td>Every line changed</td>\n<td>&quot;Renamed variable: oldName → newName&quot;</td>\n<td>Ignore cosmetic changes</td>\n</tr>\n<tr>\n<td>Function Move</td>\n<td>Large deletion + addition</td>\n<td>&quot;Moved function: Class1 → Class2&quot;</td>\n<td>Focus on structural changes</td>\n</tr>\n<tr>\n<td>Comment Addition</td>\n<td>Line additions throughout</td>\n<td>No change reported</td>\n<td>Hide documentation updates</td>\n</tr>\n<tr>\n<td>Whitespace/Formatting</td>\n<td>Extensive line changes</td>\n<td>No change reported</td>\n<td>Ignore style-only changes</td>\n</tr>\n<tr>\n<td>Algorithm Change</td>\n<td>Mixed line changes</td>\n<td>&quot;Modified sorting algorithm&quot;</td>\n<td>Highlight logic changes</td>\n</tr>\n</tbody></table>\n<p>The semantic engine would require language-specific parsers but could integrate with existing tools like Python&#39;s <code>ast</code> module, JavaScript&#39;s Babel parser, or tree-sitter for multi-language support.</p>\n<h3 id=\"output-format-enhancements\">Output Format Enhancements</h3>\n<p>The current unified diff format serves as a solid foundation, but different use cases demand different presentation approaches. Like a newspaper that might present the same information as a headline, detailed article, or infographic depending on the audience, our diff tool should support multiple output formats optimized for different consumption patterns.</p>\n<h4 id=\"side-by-side-display\">Side-by-Side Display</h4>\n<p><strong>Mental Model: Parallel Reading</strong><br>Think of side-by-side diff display like reading parallel translations of a book — you can see both versions simultaneously and easily correlate changes across the two texts. This is particularly valuable for code review where understanding the context around changes is crucial, or for document editing where you need to see both the original intent and the revised version.</p>\n<p>Side-by-side display requires fundamentally different layout calculations compared to unified diff format. Instead of interleaving changes in a single column, the formatter must align corresponding sections and handle cases where insertions and deletions don&#39;t match up cleanly.</p>\n<blockquote>\n<p><strong>Decision: Responsive Side-by-Side Layout</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Unified diff format becomes difficult to read for large changes; reviewers need to see both versions simultaneously  </li>\n<li><strong>Options Considered</strong>: Fixed two-column layout, responsive width adaptation, horizontal scrolling  </li>\n<li><strong>Decision</strong>: Implement responsive layout that adapts to terminal width with graceful degradation  </li>\n<li><strong>Rationale</strong>: Maximizes readability across different terminal sizes while providing side-by-side benefits  </li>\n<li><strong>Consequences</strong>: More complex rendering logic but significantly improved user experience for code review</li>\n</ul>\n</blockquote>\n<p>The implementation would extend <code>OutputFormatter</code> with a <code>SideBySideFormatter</code> class:</p>\n<table>\n<thead>\n<tr>\n<th>Layout Challenge</th>\n<th>Solution Approach</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Terminal Width Detection</td>\n<td>Query terminal size, fall back to 80 columns</td>\n<td>Use <code>shutil.get_terminal_size()</code> with fallback</td>\n</tr>\n<tr>\n<td>Column Width Calculation</td>\n<td>Dynamic split based on content + minimum readability</td>\n<td>Reserve space for line numbers and separators</td>\n</tr>\n<tr>\n<td>Line Alignment</td>\n<td>Match corresponding lines, insert blanks for unmatched</td>\n<td>Complex alignment algorithm for deletions vs insertions</td>\n</tr>\n<tr>\n<td>Long Line Handling</td>\n<td>Wrap lines within column boundaries</td>\n<td>Preserve indentation and syntax highlighting</td>\n</tr>\n<tr>\n<td>Color Synchronization</td>\n<td>Coordinate color schemes across both columns</td>\n<td>Ensure consistent highlighting between sides</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SideBySideFormatter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">OutputFormatter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_hunk_side_by_side</span><span style=\"color:#E1E4E8\">(self, hunk: Hunk, column_width: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format hunk in side-by-side layout with proper alignment\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate optimal column widths based on terminal size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Align old and new lines, inserting blanks for unmatched content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle long lines by wrapping within column boundaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply consistent color schemes to both columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add separator column with change indicators</span></span></code></pre></div>\n\n<p>The side-by-side formatter would also need to handle edge cases like very long lines, mixed content types, and terminal resizing during output generation.</p>\n<h4 id=\"html-output-with-interactive-features\">HTML Output with Interactive Features</h4>\n<p><strong>Mental Model: Document Publishing</strong><br>Think of HTML diff output like converting a manuscript draft into a published article with interactive annotations. While command-line output serves developers working in terminals, HTML output serves broader audiences including project managers, documentation reviewers, and stakeholders who need to understand changes in a more accessible format.</p>\n<p>HTML output enables rich interactivity that&#39;s impossible in terminal displays: collapsible sections, syntax highlighting, inline comments, change summaries, and navigation aids. This transforms the diff from a developer tool into a communication medium.</p>\n<p>The architecture would add an <code>HTMLFormatter</code> that generates self-contained HTML documents:</p>\n<table>\n<thead>\n<tr>\n<th>HTML Feature</th>\n<th>Technical Implementation</th>\n<th>User Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Syntax Highlighting</td>\n<td>Integration with Pygments or highlight.js</td>\n<td>Improved code readability</td>\n</tr>\n<tr>\n<td>Collapsible Hunks</td>\n<td>JavaScript accordions with CSS transitions</td>\n<td>Focus on relevant changes</td>\n</tr>\n<tr>\n<td>Change Statistics</td>\n<td>Summary panels with charts</td>\n<td>Quick overview of modification scope</td>\n</tr>\n<tr>\n<td>Navigation Sidebar</td>\n<td>Generated table of contents with anchor links</td>\n<td>Easy movement through large diffs</td>\n</tr>\n<tr>\n<td>Inline Annotations</td>\n<td>Hover tooltips and expandable comments</td>\n<td>Additional context without clutter</td>\n</tr>\n<tr>\n<td>Export Options</td>\n<td>Print-friendly CSS and PDF generation</td>\n<td>Documentation and archival</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HTMLFormatter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">OutputFormatter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_interactive_diff</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 hunks: List[Hunk]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate complete HTML document with interactive diff features\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate HTML structure with navigation and content areas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply syntax highlighting based on file extension detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create collapsible hunk sections with JavaScript controls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add change statistics summary with visual indicators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Include CSS for responsive design and print compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Embed JavaScript for interactive features without external dependencies</span></span></code></pre></div>\n\n<p>The HTML formatter would generate self-contained documents that work offline and can be shared easily. Integration with existing syntax highlighting libraries would provide language-aware formatting that surpasses terminal capabilities.</p>\n<h4 id=\"integration-with-version-control-systems\">Integration with Version Control Systems</h4>\n<p><strong>Mental Model: Native Git Citizen</strong><br>Think of VCS integration like making our diff tool a native speaker of Git&#39;s language rather than a foreign translator. Instead of just comparing two arbitrary files, the tool would understand repository context, branch relationships, commit history, and merge conflicts. This transforms it from a generic comparison tool into a specialized Git companion.</p>\n<p>Version control integration opens up powerful workflows: comparing working directory against specific commits, analyzing changes across branch merges, generating release notes from commit ranges, and providing enhanced conflict resolution during merges.</p>\n<blockquote>\n<p><strong>Decision: Git Protocol Integration</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Developers primarily work within Git repositories where file comparison needs repository context  </li>\n<li><strong>Options Considered</strong>: Shell wrapper scripts, native Git integration, separate VCS adapter layer  </li>\n<li><strong>Decision</strong>: Implement VCS adapter pattern with Git as primary target, using libgit2 bindings  </li>\n<li><strong>Rationale</strong>: Provides deep Git integration while maintaining extensibility for other VCS systems  </li>\n<li><strong>Consequences</strong>: More complex dependency management but enables sophisticated repository-aware features</li>\n</ul>\n</blockquote>\n<p>The implementation would add a <code>VCSAdapter</code> interface with Git-specific implementation:</p>\n<table>\n<thead>\n<tr>\n<th>VCS Feature</th>\n<th>Implementation Approach</th>\n<th>Diff Enhancement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Commit Range Comparison</td>\n<td>Use libgit2 to traverse commit history</td>\n<td>Compare any two points in project history</td>\n</tr>\n<tr>\n<td>Branch Diff Analysis</td>\n<td>Identify merge bases and divergence points</td>\n<td>Show changes unique to each branch</td>\n</tr>\n<tr>\n<td>Working Directory Integration</td>\n<td>Monitor file status and staged changes</td>\n<td>Compare working files against index or HEAD</td>\n</tr>\n<tr>\n<td>Merge Conflict Resolution</td>\n<td>Parse conflict markers and provide 3-way diff</td>\n<td>Enhanced conflict visualization</td>\n</tr>\n<tr>\n<td>Blame Integration</td>\n<td>Correlate changes with commit authors and dates</td>\n<td>Attribution information in diff output</td>\n</tr>\n<tr>\n<td>Submodule Awareness</td>\n<td>Handle submodule boundary detection</td>\n<td>Proper handling of nested repositories</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GitAdapter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">VCSAdapter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_file_at_commit</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, commit_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> FileContent:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve file content at specific commit for comparison\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use libgit2 to access repository object database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Resolve commit hash to tree object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Navigate tree to find file blob</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract blob content with proper encoding detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create FileContent with commit metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare_commit_range</span><span style=\"color:#E1E4E8\">(self, start_commit: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, end_commit: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate diff for file changes across commit range\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate commit range and file existence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Retrieve file content at both commits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply standard diff pipeline to historical content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Annotate output with commit metadata</span></span></code></pre></div>\n\n<p>The VCS integration would also enable advanced features like <strong>change velocity analysis</strong> (tracking how frequently different parts of files change over time) and <strong>collaboration patterns</strong> (identifying areas where multiple developers frequently make conflicting changes).</p>\n<h4 id=\"advanced-output-customization\">Advanced Output Customization</h4>\n<p><strong>Mental Model: Custom Report Generation</strong><br>Think of output customization like a newspaper editor who can present the same story as a front-page headline, detailed investigative piece, or statistical infographic depending on the audience and purpose. Different stakeholders need different levels of detail and different presentation formats from the same underlying diff analysis.</p>\n<p>Advanced customization goes beyond simple formatting to include <strong>content filtering</strong>, <strong>aggregation strategies</strong>, and <strong>presentation modes</strong> tailored to specific workflows.</p>\n<p>The architecture would support customizable output pipelines through a <strong>template system</strong> and <strong>filter chain</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Customization Type</th>\n<th>Configuration Approach</th>\n<th>Example Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content Filtering</td>\n<td>YAML configuration files</td>\n<td>Hide whitespace changes for code review</td>\n</tr>\n<tr>\n<td>Aggregation Rules</td>\n<td>Python expressions for grouping</td>\n<td>Summarize changes by file type or author</td>\n</tr>\n<tr>\n<td>Template Systems</td>\n<td>Jinja2 templates for output format</td>\n<td>Custom corporate report formats</td>\n</tr>\n<tr>\n<td>Notification Integration</td>\n<td>Webhook and email template support</td>\n<td>Automated change notifications</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Plugin system for change analysis</td>\n<td>Code quality and complexity metrics</td>\n</tr>\n</tbody></table>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CustomizableOutputPipeline</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> apply_filter_chain</span><span style=\"color:#E1E4E8\">(self, hunks: List[Hunk], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          filters: List[DiffFilter]) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Apply sequence of filters to diff output\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load filter configuration from YAML or Python modules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply each filter in sequence, allowing early termination</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Support filter parameterization and conditional application</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Maintain audit trail of applied filters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_from_template</span><span style=\"color:#E1E4E8\">(self, template_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             diff_data: DiffData) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate output using specified template\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load template from filesystem or embedded templates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Prepare template context with diff statistics and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply template engine with safety restrictions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Post-process output for format-specific requirements</span></span></code></pre></div>\n\n<h3 id=\"implementation-strategy-and-migration-path\">Implementation Strategy and Migration Path</h3>\n<p>The extension implementation follows a <strong>progressive enhancement strategy</strong> that maintains backward compatibility while enabling advanced features. Like adding floors to a building without disrupting the ground floor, each enhancement builds upon existing architecture without breaking current functionality.</p>\n<h4 id=\"phase-1-algorithm-enhancement-3-4-weeks\">Phase 1: Algorithm Enhancement (3-4 weeks)</h4>\n<ol>\n<li>Implement <code>StrategySelector</code> within existing <code>LCSEngine</code></li>\n<li>Add Myers&#39; algorithm as alternative computation strategy</li>\n<li>Create performance benchmarking suite to validate improvements</li>\n<li>Implement algorithm fallback mechanisms for edge cases</li>\n</ol>\n<h4 id=\"phase-2-multi-level-diffing-4-5-weeks\">Phase 2: Multi-Level Diffing (4-5 weeks)</h4>\n<ol>\n<li>Develop <code>TokenizerEngine</code> for word and character level analysis</li>\n<li>Extend <code>DiffGenerator</code> with hierarchical diffing capabilities</li>\n<li>Enhance <code>DiffLine</code> data model to support nested change information</li>\n<li>Create unified API that maintains existing interface compatibility</li>\n</ol>\n<h4 id=\"phase-3-output-format-extensions-3-4-weeks\">Phase 3: Output Format Extensions (3-4 weeks)</h4>\n<ol>\n<li>Implement <code>SideBySideFormatter</code> with terminal width adaptation</li>\n<li>Develop <code>HTMLFormatter</code> with syntax highlighting integration</li>\n<li>Create template system for custom output formats</li>\n<li>Add format auto-detection based on output destination</li>\n</ol>\n<h4 id=\"phase-4-vcs-integration-5-6-weeks\">Phase 4: VCS Integration (5-6 weeks)</h4>\n<ol>\n<li>Design <code>VCSAdapter</code> interface with Git implementation</li>\n<li>Integrate libgit2 bindings for repository access</li>\n<li>Implement commit range comparison and working directory integration</li>\n<li>Add merge conflict resolution enhancements</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Feature Creep Management</strong><br>The abundance of possible enhancements can lead to <strong>scope creep</strong> where the simple diff tool becomes an overly complex Swiss Army knife. Each enhancement should be evaluated against core use cases and implemented as optional, configurable features that don&#39;t complicate the basic diff workflow. Maintain separate command-line flags and configuration options so users can opt into complexity rather than having it imposed.</p>\n<p>⚠️ <strong>Pitfall: Performance Regression</strong><br>Adding multiple algorithms and output formats can introduce performance overhead even when advanced features aren&#39;t used. Implement <strong>lazy loading</strong> and <strong>strategy selection</strong> so that basic diff operations maintain their current performance characteristics. The <code>choose_strategy</code> method should default to simple approaches for small inputs and only engage complex algorithms when they provide clear benefits.</p>\n<p>⚠️ <strong>Pitfall: Configuration Complexity</strong><br>Advanced customization can create a configuration nightmare where users need extensive setup before the tool becomes useful. Design configuration with <strong>smart defaults</strong> and <strong>progressive disclosure</strong> — the tool should work well without any configuration, provide simple options for common customizations, and only expose complex configuration for power users who explicitly seek advanced capabilities.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The future extensions leverage modern Python ecosystem capabilities while maintaining the educational value of the core implementation. The extensions are designed as <strong>optional enhancements</strong> that students can explore after mastering the fundamental concepts.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Area</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTML Generation</td>\n<td>String templating with f-strings</td>\n<td>Jinja2 template engine with Pygments syntax highlighting</td>\n</tr>\n<tr>\n<td>VCS Integration</td>\n<td>subprocess calls to git command</td>\n<td>pygit2 (libgit2 bindings) for native Git access</td>\n</tr>\n<tr>\n<td>Algorithm Selection</td>\n<td>Simple if/else strategy selection</td>\n<td>Strategy pattern with performance profiling</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Command-line arguments only</td>\n<td>YAML configuration files with schema validation</td>\n</tr>\n<tr>\n<td>Testing Extensions</td>\n<td>Manual verification of output</td>\n<td>Automated visual diff testing with image comparison</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-enhancement\">Recommended File Structure Enhancement</h4>\n<p>The extensions maintain the existing modular structure while adding specialized components:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff-tool/\n├── core/                    # Existing core components\n│   ├── file_reader.py\n│   ├── lcs_engine.py\n│   ├── diff_generator.py\n│   └── output_formatter.py\n├── algorithms/              # Algorithm implementations\n│   ├── __init__.py\n│   ├── lcs_traditional.py   # Current implementation\n│   ├── myers_algorithm.py   # Myers' diff algorithm\n│   └── strategy_selector.py # Algorithm selection logic\n├── formatters/              # Output format extensions\n│   ├── __init__.py\n│   ├── unified_formatter.py # Current implementation\n│   ├── side_by_side.py     # Side-by-side display\n│   ├── html_formatter.py   # HTML output with highlighting\n│   └── template_engine.py  # Custom template support\n├── vcs/                     # Version control integration\n│   ├── __init__.py\n│   ├── vcs_adapter.py      # Abstract VCS interface\n│   ├── git_adapter.py      # Git-specific implementation\n│   └── conflict_resolver.py # Enhanced merge conflict handling\n├── tokenizers/              # Multi-level diffing support\n│   ├── __init__.py\n│   ├── line_tokenizer.py   # Current line-based approach\n│   ├── word_tokenizer.py   # Word-level analysis\n│   └── semantic_tokenizer.py # AST-based semantic diffing\n├── config/                  # Configuration management\n│   ├── __init__.py\n│   ├── settings.py         # Configuration schema and defaults\n│   └── templates/          # Built-in output templates\n├── tests/\n│   ├── extensions/         # Tests for extension components\n│   ├── integration/        # End-to-end extension testing\n│   └── performance/        # Algorithm performance benchmarks\n└── examples/\n    ├── custom_templates/   # Example template configurations\n    └── vcs_integration/    # Git workflow examples</code></pre></div>\n\n<h4 id=\"algorithm-strategy-infrastructure\">Algorithm Strategy Infrastructure</h4>\n<p>The strategy selection system provides a clean way to add new algorithms without breaking existing functionality:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># algorithms/strategy_selector.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Sequence, CommonSubsequence, MemoryStrategy</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffAlgorithm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract interface for different diff algorithms\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compute_lcs</span><span style=\"color:#E1E4E8\">(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compute longest common subsequence using this algorithm\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> estimate_performance</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return (time_factor, memory_mb) estimates for input size\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StrategySelector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Selects optimal diff algorithm based on input characteristics\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.algorithms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'lcs_matrix'</span><span style=\"color:#E1E4E8\">: TraditionalLCSAlgorithm(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'myers'</span><span style=\"color:#E1E4E8\">: MyersAlgorithm(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'hirschberg'</span><span style=\"color:#E1E4E8\">: HirschbergAlgorithm()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.performance_history </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}  </span><span style=\"color:#6A737D\"># Track actual performance for tuning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> choose_algorithm</span><span style=\"color:#E1E4E8\">(self, seq1_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, seq2_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        memory_limit_mb: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1024.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Select best algorithm for given constraints\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate performance estimates for each available algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Filter algorithms that exceed memory constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Consider historical performance data for similar input sizes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply user preferences and educational mode settings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return algorithm name with fallback to 'lcs_matrix'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        estimates </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> name, algorithm </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.algorithms.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time_factor, memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> algorithm.estimate_performance(seq1_len, seq2_len)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> memory_mb </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> memory_limit_mb:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                estimates[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (time_factor, memory_mb)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Default to fastest algorithm that fits in memory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> estimates:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> 'lcs_matrix'</span><span style=\"color:#6A737D\">  # Fallback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(estimates.keys(), </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\"> k: estimates[k][</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span></code></pre></div>\n\n<h4 id=\"html-output-infrastructure\">HTML Output Infrastructure</h4>\n<p>The HTML formatter demonstrates how to create rich, interactive output while maintaining clean separation from core diff logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># formatters/html_formatter.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> html</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileContent, Hunk, DiffLine, LineType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HTMLFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generates interactive HTML diff displays\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, syntax_highlighting: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 interactive_features: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.syntax_highlighting </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> syntax_highlighting</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.interactive_features </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interactive_features</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.css_template </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._load_css_template()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.js_template </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._load_js_template()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_diff_document</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             hunks: List[Hunk]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate complete HTML document with embedded CSS and JavaScript\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate HTML document structure with metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Embed CSS styles for diff formatting and responsive design</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create navigation sidebar with hunk links</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate main diff content with syntax highlighting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add interactive JavaScript for collapsible sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Include print-friendly CSS media queries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        document_parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._generate_html_header(file1.filepath, file2.filepath),</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._generate_navigation_sidebar(hunks),</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._generate_diff_content(file1, file2, hunks),</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._generate_html_footer()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">.join(document_parts)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _generate_diff_content</span><span style=\"color:#E1E4E8\">(self, file1: FileContent, file2: FileContent, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             hunks: List[Hunk]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate main diff content area with syntax highlighting\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Apply syntax highlighting based on file extension</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create hunk sections with collapsible controls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Format line numbers and change indicators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add hover tooltips for additional context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate change statistics summary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _apply_syntax_highlighting</span><span style=\"color:#E1E4E8\">(self, content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, language: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Apply syntax highlighting using Pygments or similar\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Detect language from file extension or content analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use Pygments to generate highlighted HTML</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Preserve diff markers and line structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle edge cases like mixed languages or plain text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"vcs-integration-foundation\">VCS Integration Foundation</h4>\n<p>The Git integration shows how to extend the diff tool with repository awareness:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># vcs/git_adapter.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> FileContent, DiffLine, Hunk</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .vcs_adapter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> VCSAdapter</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> GitAdapter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">VCSAdapter</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Git-specific version control integration\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, repository_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.repo_path </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> repository_path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.git_cmd </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'git'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'-C'</span><span style=\"color:#E1E4E8\">, repository_path]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_file_at_commit</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, commit_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[FileContent]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve file content at specific commit\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that commit_hash exists in repository</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use 'git show commit:filepath' to get file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle files that don't exist at specified commit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Detect encoding and normalize line endings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create FileContent with commit metadata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> subprocess.run(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.git_cmd </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'show'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">commit_hash</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                capture_output</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">text</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">check</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._create_file_content_from_git(filepath, result.stdout, commit_hash)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> subprocess.CalledProcessError:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare_working_directory</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 against_commit: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'HEAD'</span><span style=\"color:#E1E4E8\">) -> List[Hunk]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compare working directory file against specified commit\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get current working directory file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get file content at specified commit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply standard diff pipeline to compare versions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add Git-specific metadata to hunk headers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_merge_conflicts</span><span style=\"color:#E1E4E8\">(self, filepath: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse merge conflict markers and return conflict regions\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Read file and detect conflict markers (&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; ======= >>>>>>>)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse conflict regions into (start_line, end_line, conflict_type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract 'ours', 'theirs', and 'base' content sections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return structured conflict information for enhanced resolution UI</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p>Each extension area provides clear validation steps:</p>\n<p><strong>Algorithm Enhancement Checkpoint:</strong></p>\n<ul>\n<li>Run: <code>python -m diff_tool --algorithm=myers large_file1.txt large_file2.txt</code></li>\n<li>Expected: Significantly faster execution on large files with similar content</li>\n<li>Validation: Performance improvement of 50%+ for files &gt;10MB with &lt;10% changes</li>\n<li>Debug check: Algorithm selection logging shows Myers&#39; chosen for large inputs</li>\n</ul>\n<p><strong>HTML Output Checkpoint:</strong></p>\n<ul>\n<li>Run: <code>python -m diff_tool --format=html file1.py file2.py &gt; diff.html</code></li>\n<li>Expected: Self-contained HTML file with syntax highlighting and interactive features</li>\n<li>Validation: Open diff.html in browser, verify collapsible hunks and color coding</li>\n<li>Debug check: HTML validates and includes embedded CSS/JavaScript</li>\n</ul>\n<p><strong>VCS Integration Checkpoint:</strong></p>\n<ul>\n<li>Run: <code>python -m diff_tool --git-compare HEAD~1 HEAD src/main.py</code></li>\n<li>Expected: Diff between current file and previous commit version</li>\n<li>Validation: Output includes commit metadata and matches <code>git diff HEAD~1 HEAD src/main.py</code></li>\n<li>Debug check: Git repository detection and commit resolution working correctly</li>\n</ul>\n<h4 id=\"common-extension-pitfalls\">Common Extension Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Algorithm Selection Overhead</strong><br>Adding multiple algorithms can introduce selection overhead that exceeds the benefits for small files. The strategy selector should cache performance characteristics and default to simple algorithms for inputs under 1000 lines. Measure actual selection time and ensure it&#39;s under 10ms for typical use cases.</p>\n<p>⚠️ <strong>Pitfall: HTML Output Security</strong><br>When generating HTML output, especially with user-provided content, ensure proper HTML escaping to prevent XSS vulnerabilities. Use <code>html.escape()</code> for all user content and avoid generating JavaScript from user input. The HTML should be safe to open in any browser without security warnings.</p>\n<p>⚠️ <strong>Pitfall: Git Dependency Management</strong><br>VCS integration can fail silently if Git isn&#39;t available or repository detection fails. Implement graceful degradation where VCS features are simply unavailable rather than causing tool failure. Provide clear error messages when Git operations fail and suggest fallback approaches.</p>\n<p>⚠️ <strong>Pitfall: Configuration File Complexity</strong><br>Advanced configuration options can overwhelm users and make the tool difficult to adopt. Design configuration with progressive disclosure: simple command-line flags for common options, optional configuration files for advanced users, and comprehensive defaults that work well without any configuration.</p>\n<p>The extension architecture ensures that the diff tool can grow from a simple educational project into a sophisticated development tool while maintaining its core educational value and simplicity for basic use cases.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones — comprehensive terminology reference supporting line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)</p>\n</blockquote>\n<p>The diff tool implementation involves specialized terminology from multiple domains including dynamic programming, text processing, file system operations, and command-line interface design. This glossary provides precise definitions for all technical terms, algorithms, and domain-specific vocabulary used throughout the design document, organized to support both immediate reference during implementation and deeper understanding of the underlying concepts.</p>\n<h3 id=\"core-algorithm-terms\">Core Algorithm Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>LCS</strong></td>\n<td>Longest Common Subsequence algorithm using dynamic programming to find the longest sequence of elements that appear in the same order in both input sequences, though not necessarily consecutively</td>\n<td>Core algorithm in Milestone 2 for finding matching lines between files before generating diff output</td>\n</tr>\n<tr>\n<td><strong>dynamic programming</strong></td>\n<td>Algorithmic technique for solving optimization problems by building solutions from optimal subproblems, storing intermediate results to avoid recomputation</td>\n<td>Foundation of LCS implementation in Milestone 2, where we build a matrix of optimal subsequence lengths</td>\n</tr>\n<tr>\n<td><strong>edit graph</strong></td>\n<td>Graph representation where moves represent edit operations - horizontal moves are deletions, vertical moves are insertions, diagonal moves are matches</td>\n<td>Conceptual model underlying Myers&#39; algorithm and visualizing the relationship between sequences</td>\n</tr>\n<tr>\n<td><strong>edit distance</strong></td>\n<td>Minimum number of operations needed to transform one sequence into another, typically counting insertions, deletions, and substitutions</td>\n<td>Quantifies the difference between files and guides optimization decisions in diff generation</td>\n</tr>\n<tr>\n<td><strong>recurrence relation</strong></td>\n<td>Mathematical relationship defining how optimal solutions to subproblems combine to form solutions to larger problems</td>\n<td>Defines how LCS matrix cells are computed based on neighboring cells and sequence element matches</td>\n</tr>\n<tr>\n<td><strong>optimal substructure</strong></td>\n<td>Property where optimal solutions to a problem contain optimal solutions to subproblems</td>\n<td>Key property that makes dynamic programming applicable to LCS - optimal subsequences contain optimal shorter subsequences</td>\n</tr>\n<tr>\n<td><strong>backtracking</strong></td>\n<td>Process of reconstructing the optimal solution by tracing backwards through the dynamic programming matrix</td>\n<td>Used in Milestone 2 to recover the actual LCS from the completed matrix of lengths</td>\n</tr>\n<tr>\n<td><strong>tie-breaking rules</strong></td>\n<td>Consistent handling of multiple valid LCS paths when backtracking through matrix cells with equal values</td>\n<td>Ensures deterministic output when multiple equally valid longest common subsequences exist</td>\n</tr>\n</tbody></table>\n<h3 id=\"text-processing-and-file-handling-terms\">Text Processing and File Handling Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>encoding detection</strong></td>\n<td>Process of determining the character encoding of a file by attempting to decode with common encodings like UTF-8 and Latin-1</td>\n<td>Essential in Milestone 1 for reading files correctly before line comparison can begin</td>\n</tr>\n<tr>\n<td><strong>line normalization</strong></td>\n<td>Standardizing line endings, whitespace handling, and text structure while preserving meaningful content differences</td>\n<td>Critical preprocessing step in Milestone 1 that affects all subsequent comparison accuracy</td>\n</tr>\n<tr>\n<td><strong>binary file detection</strong></td>\n<td>Identifying non-text files that contain binary data and cannot be meaningfully diffed as text</td>\n<td>Prevents encoding errors and provides appropriate error messages when comparing unsupported file types</td>\n</tr>\n<tr>\n<td><strong>trailing newline</strong></td>\n<td>Final newline character at the end of a file, whose presence or absence can affect diff output</td>\n<td>Common source of unexpected diff results that must be handled consistently across different editors and platforms</td>\n</tr>\n<tr>\n<td><strong>mixed line endings</strong></td>\n<td>File containing multiple line ending types (LF, CRLF, CR) which may indicate file corruption or cross-platform editing</td>\n<td>Detected during line normalization in Milestone 1 and can indicate data integrity issues requiring user attention</td>\n</tr>\n<tr>\n<td><strong>UTF-8</strong></td>\n<td>Unicode encoding that can represent any character while maintaining ASCII compatibility</td>\n<td>Primary encoding attempt in file reading, supporting international characters and modern text files</td>\n</tr>\n<tr>\n<td><strong>LATIN-1</strong></td>\n<td>Single-byte character encoding covering Western European languages</td>\n<td>Fallback encoding when UTF-8 decoding fails, ensuring maximum compatibility with legacy text files</td>\n</tr>\n<tr>\n<td><strong>LF</strong></td>\n<td>Unix line ending character (0x0A) representing a single line feed</td>\n<td>Standard line ending for Unix/Linux systems, requiring normalization for cross-platform compatibility</td>\n</tr>\n<tr>\n<td><strong>CRLF</strong></td>\n<td>Windows line ending sequence (0x0D 0x0A) combining carriage return and line feed</td>\n<td>Standard line ending for Windows systems, must be normalized to prevent false differences</td>\n</tr>\n<tr>\n<td><strong>CR</strong></td>\n<td>Classic Mac line ending character (0x0D) representing a single carriage return</td>\n<td>Legacy line ending from pre-OS X Mac systems, rarely encountered but must be handled for completeness</td>\n</tr>\n</tbody></table>\n<h3 id=\"diff-format-and-output-terms\">Diff Format and Output Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>unified diff</strong></td>\n<td>Standard diff output format using -/+ prefixes to mark deletions and additions, with context lines for readability</td>\n<td>Target output format generated in Milestone 3, compatible with standard Unix diff tools and version control systems</td>\n</tr>\n<tr>\n<td><strong>context lines</strong></td>\n<td>Unchanged lines displayed around changes to provide readability and help locate modifications within the file</td>\n<td>Configurable feature in Milestone 4 that affects hunk formation and overall diff readability</td>\n</tr>\n<tr>\n<td><strong>hunk</strong></td>\n<td>Group of consecutive changes with surrounding context lines, representing a logical block of modifications</td>\n<td>Fundamental unit of diff output generated in Milestone 3, containing related changes grouped for human readability</td>\n</tr>\n<tr>\n<td><strong>edit script</strong></td>\n<td>Sequence of ADD, DELETE, and UNCHANGED operations that transform one file into another</td>\n<td>Intermediate representation in Milestone 3 that bridges between LCS results and formatted hunk output</td>\n</tr>\n<tr>\n<td><strong>one-indexed</strong></td>\n<td>Line numbering convention starting at 1 rather than 0, used for human readability in diff output</td>\n<td>Standard convention for diff format line numbers, requiring careful conversion from zero-indexed internal arrays</td>\n</tr>\n<tr>\n<td><strong>hunk header</strong></td>\n<td>@@ line range markers showing the position and size of changes in both files using format @@old_start,old_count +new_start,new_count@@</td>\n<td>Essential component of unified diff format that allows diff consumers to locate and apply changes</td>\n</tr>\n<tr>\n<td><strong>file headers</strong></td>\n<td>--- and +++ lines at the beginning of diff output that identify the compared files</td>\n<td>Standard unified diff format requirement that provides context about which files are being compared</td>\n</tr>\n<tr>\n<td><strong>edit operations</strong></td>\n<td>Classification of lines as ADD (inserted), DELETE (removed), or UNCHANGED (identical)</td>\n<td>Core abstraction in Milestone 3 that represents the transformation between file versions</td>\n</tr>\n</tbody></table>\n<h3 id=\"command-line-interface-and-display-terms\">Command-Line Interface and Display Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>ANSI color codes</strong></td>\n<td>Terminal control sequences that format text with colors, bold, and other visual effects</td>\n<td>Used in Milestone 4 to provide visual distinction between additions (green) and deletions (red)</td>\n</tr>\n<tr>\n<td><strong>TTY detection</strong></td>\n<td>Determining whether output is directed to a terminal or being piped to a file or another program</td>\n<td>Critical for deciding when to apply ANSI color codes - colors should only appear in interactive terminal sessions</td>\n</tr>\n<tr>\n<td><strong>exit codes</strong></td>\n<td>Numeric values returned to the shell indicating program success (0) or failure (non-zero), with specific meanings</td>\n<td>Standard convention where 0 indicates identical files and 1 indicates differences, used by scripts and automation</td>\n</tr>\n<tr>\n<td><strong>color mode</strong></td>\n<td>Configuration setting controlling when ANSI color formatting is applied to output</td>\n<td>Allows users to force color on/off regardless of TTY detection, important for testing and special terminal scenarios</td>\n</tr>\n<tr>\n<td><strong>side-by-side display</strong></td>\n<td>Parallel presentation of both file versions showing changes in adjacent columns</td>\n<td>Alternative output format that makes it easier to see before/after states of modified content</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-structure-and-architecture-terms\">Data Structure and Architecture Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>pipeline pattern</strong></td>\n<td>Sequential processing architecture where data flows through distinct stages with well-defined interfaces</td>\n<td>Architectural approach used for FileReader → LCSEngine → DiffGenerator → OutputFormatter flow</td>\n</tr>\n<tr>\n<td><strong>message-passing interface</strong></td>\n<td>Communication pattern where components interact through standardized method calls rather than shared state</td>\n<td>Ensures clean separation between components and makes testing individual components easier</td>\n</tr>\n<tr>\n<td><strong>fail-fast strategy</strong></td>\n<td>Design principle of detecting and reporting errors immediately rather than allowing invalid state to propagate</td>\n<td>Implemented throughout error handling to provide clear diagnostics and prevent cascading failures</td>\n</tr>\n<tr>\n<td><strong>contextual error propagation</strong></td>\n<td>Preserving error context and adding relevant information as errors bubble up through component layers</td>\n<td>Ensures that error messages include enough context for users to understand and fix problems</td>\n</tr>\n<tr>\n<td><strong>progressive enhancement</strong></td>\n<td>Design approach that starts with basic functionality and adds advanced features without breaking core behavior</td>\n<td>Guides the milestone progression from basic line comparison to advanced output formatting</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-memory-management-terms\">Performance and Memory Management Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>memory optimization</strong></td>\n<td>Techniques to reduce space complexity for large inputs, such as using only two matrix rows instead of full matrix storage</td>\n<td>Essential for handling large files in LCS computation without exhausting system memory</td>\n</tr>\n<tr>\n<td><strong>Hirschberg&#39;s algorithm</strong></td>\n<td>Space-efficient LCS algorithm using divide-and-conquer approach that achieves O(m+n) space complexity</td>\n<td>Advanced optimization considered for very large file comparison when standard O(mn) approach fails</td>\n</tr>\n<tr>\n<td><strong>memory exhaustion</strong></td>\n<td>Condition where the algorithm attempts to allocate more memory than available, causing program failure</td>\n<td>Primary risk when comparing large files using standard LCS matrix approach</td>\n</tr>\n<tr>\n<td><strong>resource limit enforcement</strong></td>\n<td>Preventing operations from exceeding system constraints through monitoring and early termination</td>\n<td>Safety mechanism to prevent system instability when processing unexpectedly large inputs</td>\n</tr>\n<tr>\n<td><strong>graceful degradation</strong></td>\n<td>System behavior that maintains partial functionality when encountering resource constraints or errors</td>\n<td>Design principle ensuring the tool provides useful output even when optimal algorithms cannot complete</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-and-testing-terms\">Implementation and Testing Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>edge cases</strong></td>\n<td>Boundary conditions and unusual input scenarios that test the limits of algorithm correctness</td>\n<td>Include empty files, identical files, files with no common lines, and files exceeding memory limits</td>\n</tr>\n<tr>\n<td><strong>off-by-one indexing</strong></td>\n<td>Common programming error involving incorrect array bounds or counting, especially critical in matrix operations</td>\n<td>Frequent source of bugs in LCS matrix construction and line number calculations for diff output</td>\n</tr>\n<tr>\n<td><strong>hunk validation</strong></td>\n<td>Ensuring diff hunk consistency by verifying that line counts match actual content and ranges are correct</td>\n<td>Quality assurance step that catches bugs in diff generation before output formatting</td>\n</tr>\n<tr>\n<td><strong>milestone checkpoints</strong></td>\n<td>Validation steps after completing each implementation stage to verify correct behavior before proceeding</td>\n<td>Structured testing approach ensuring each component works correctly before building dependent components</td>\n</tr>\n<tr>\n<td><strong>property-based testing</strong></td>\n<td>Automated test generation that verifies algorithmic properties across many random inputs</td>\n<td>Advanced testing strategy for validating LCS properties like optimality and consistency across different inputs</td>\n</tr>\n<tr>\n<td><strong>matrix inspection</strong></td>\n<td>Debugging technique involving visualization and validation of LCS dynamic programming matrices</td>\n<td>Essential debugging tool for understanding why LCS algorithms produce unexpected results</td>\n</tr>\n<tr>\n<td><strong>round-trip testing</strong></td>\n<td>End-to-end verification that the complete pipeline preserves information and produces consistent results</td>\n<td>Comprehensive testing approach ensuring the diff tool works correctly in real-world usage scenarios</td>\n</tr>\n</tbody></table>\n<h3 id=\"algorithm-complexity-and-optimization-terms\">Algorithm Complexity and Optimization Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>O(mn) time complexity</strong></td>\n<td>Algorithmic performance characteristic where execution time grows proportionally to the product of input sizes</td>\n<td>Standard LCS algorithm performance - comparing files with m and n lines requires m×n operations</td>\n</tr>\n<tr>\n<td><strong>O(mn) space complexity</strong></td>\n<td>Memory usage that grows proportionally to the product of input sizes due to storing the full LCS matrix</td>\n<td>Memory limitation that necessitates optimization techniques for large file comparison</td>\n</tr>\n<tr>\n<td><strong>matrix</strong></td>\n<td>Standard LCS algorithm using full O(mn) space to store complete dynamic programming table</td>\n<td>Default implementation providing full algorithm transparency and debugging capability</td>\n</tr>\n<tr>\n<td><strong>two_row</strong></td>\n<td>Space optimization that uses only two matrix rows, reducing space complexity to O(min(m,n))</td>\n<td>First-level optimization that significantly reduces memory usage while maintaining algorithm simplicity</td>\n</tr>\n<tr>\n<td><strong>hirschberg</strong></td>\n<td>Advanced space optimization using divide-and-conquer to achieve O(m+n) space complexity</td>\n<td>Most advanced optimization for handling very large files when even two-row optimization insufficient</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-classification-and-handling-terms\">Error Classification and Handling Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>ERROR_CODE</strong></td>\n<td>Standardized error classification system enabling programmatic error handling and user guidance</td>\n<td>Structured approach to error handling that provides specific error codes for different failure categories</td>\n</tr>\n<tr>\n<td><strong>FileSystemError</strong></td>\n<td>Error category for file access problems including missing files, permission issues, and I/O failures</td>\n<td>Handles failures in Milestone 1 file reading operations with appropriate error messages and suggestions</td>\n</tr>\n<tr>\n<td><strong>EncodingError</strong></td>\n<td>Error category for character encoding detection and conversion failures</td>\n<td>Addresses text decoding problems in Milestone 1 when files contain invalid character sequences</td>\n</tr>\n<tr>\n<td><strong>AlgorithmError</strong></td>\n<td>Error category for computational problems including matrix overflow and infinite loops</td>\n<td>Covers failures in Milestone 2 LCS computation when algorithm encounters unexpected conditions</td>\n</tr>\n<tr>\n<td><strong>ResourceError</strong></td>\n<td>Error category for memory exhaustion, timeout, and system resource limitations</td>\n<td>Prevents system instability when processing very large files exceeds available resources</td>\n</tr>\n<tr>\n<td><strong>OutputError</strong></td>\n<td>Error category for formatting and display problems including ANSI code issues and file write failures</td>\n<td>Handles problems in Milestone 4 output generation and CLI interface operations</td>\n</tr>\n</tbody></table>\n<h3 id=\"development-and-extension-terms\">Development and Extension Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>scope creep</strong></td>\n<td>Uncontrolled expansion of project requirements that adds complexity without corresponding learning benefit</td>\n<td>Avoided through clear non-goals definition and focus on core diff algorithm learning objectives</td>\n</tr>\n<tr>\n<td><strong>lazy loading</strong></td>\n<td>Design pattern that delays component initialization until actually needed, improving startup time and memory usage</td>\n<td>Optimization strategy for loading heavyweight components like syntax highlighters only when required</td>\n</tr>\n<tr>\n<td><strong>smart defaults</strong></td>\n<td>Configuration that works well for most users without requiring manual setup or deep understanding</td>\n<td>User experience principle ensuring the tool is immediately useful while supporting advanced customization</td>\n</tr>\n<tr>\n<td><strong>progressive disclosure</strong></td>\n<td>Interface design that reveals advanced features gradually rather than overwhelming users with options</td>\n<td>Guides CLI design to present essential options prominently while making advanced features discoverable</td>\n</tr>\n<tr>\n<td><strong>algorithm fallback</strong></td>\n<td>Graceful degradation strategy where simpler algorithms are used when preferred approaches fail</td>\n<td>Ensures reliability by providing backup computation strategies when resource-intensive algorithms cannot complete</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-features-and-algorithms-terms\">Advanced Features and Algorithms Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Myers algorithm</strong></td>\n<td>Efficient diff algorithm with O(n+d²) expected performance where d is the edit distance between sequences</td>\n<td>Advanced algorithm suitable for future extension when basic LCS approach proves insufficient for large files</td>\n</tr>\n<tr>\n<td><strong>hierarchical diffing</strong></td>\n<td>Multi-level analysis that compares files at different granularities from lines to words to characters</td>\n<td>Extension capability that can provide more precise diff information by analyzing changes at multiple levels</td>\n</tr>\n<tr>\n<td><strong>semantic diffing</strong></td>\n<td>Comparing code meaning rather than text representation by operating on abstract syntax trees</td>\n<td>Advanced feature for code-aware diffing that understands programming language structure rather than treating code as plain text</td>\n</tr>\n<tr>\n<td><strong>VCS integration</strong></td>\n<td>Version control system awareness allowing the diff tool to work with Git, SVN, and other repositories</td>\n<td>Extension path that enables the tool to compare file versions across commits and branches</td>\n</tr>\n<tr>\n<td><strong>strategy selection</strong></td>\n<td>Algorithm that chooses optimal diff approach based on input characteristics like file size and available memory</td>\n<td>Intelligent system that automatically selects the best algorithm variant for given constraints</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-structure-and-type-system-terms\">Data Structure and Type System Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Sequence</strong></td>\n<td>Type alias for List[str] representing an ordered collection of lines for comparison</td>\n<td>Fundamental type used throughout LCS computation and diff generation for consistent sequence handling</td>\n</tr>\n<tr>\n<td><strong>CommonSubsequence</strong></td>\n<td>Data structure containing the actual LCS elements along with their positions in both original sequences</td>\n<td>Result type from LCS computation that provides both the subsequence and positional information for diff generation</td>\n</tr>\n<tr>\n<td><strong>EditDistance</strong></td>\n<td>Quantitative measure of file differences including counts of insertions, deletions, unchanged lines, and total operations</td>\n<td>Provides statistical summary of changes that can guide performance optimization and user feedback</td>\n</tr>\n<tr>\n<td><strong>DiffLine</strong></td>\n<td>Representation of a single line in the diff output with content, type classification, and line numbers from both files</td>\n<td>Core data structure in Milestone 3 that bridges between algorithm output and formatted display</td>\n</tr>\n<tr>\n<td><strong>LineType</strong></td>\n<td>Enumeration distinguishing between UNCHANGED, ADDED, and DELETED lines in the diff output</td>\n<td>Type safety mechanism ensuring consistent handling of different line classifications throughout the pipeline</td>\n</tr>\n<tr>\n<td><strong>Hunk</strong></td>\n<td>Structured representation of a group of changes with context, including line ranges and formatting information</td>\n<td>Primary output unit in Milestone 3 that packages related changes with sufficient context for human readability</td>\n</tr>\n<tr>\n<td><strong>FileContent</strong></td>\n<td>Complete representation of a file including filepath, lines, metadata, and encoding information</td>\n<td>Comprehensive file abstraction from Milestone 1 that carries all necessary information through the diff pipeline</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-monitoring-and-resource-management-terms\">Performance Monitoring and Resource Management Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>MemoryStrategy</strong></td>\n<td>Configuration object specifying algorithm choice, memory limits, and performance trade-offs for LCS computation</td>\n<td>Enables intelligent selection between different algorithm variants based on available resources and input size</td>\n</tr>\n<tr>\n<td><strong>ComputationStats</strong></td>\n<td>Performance metrics including execution time, memory usage, matrix dimensions, and algorithm selection</td>\n<td>Provides detailed performance information for optimization and debugging of LCS computation</td>\n</tr>\n<tr>\n<td><strong>PerformanceMonitor</strong></td>\n<td>Component that tracks resource usage and execution statistics across different algorithm phases</td>\n<td>Enables performance analysis and resource limit enforcement during expensive dynamic programming operations</td>\n</tr>\n<tr>\n<td><strong>ResourceMonitor</strong></td>\n<td>System that enforces memory and time limits to prevent resource exhaustion during large file processing</td>\n<td>Safety mechanism that prevents system instability when processing unexpectedly large inputs</td>\n</tr>\n<tr>\n<td><strong>MAX_SAFE_LINES</strong></td>\n<td>Constant defining maximum line count to prevent integer overflow and memory exhaustion</td>\n<td>Practical limit that guides when to apply memory optimizations or reject inputs as too large</td>\n</tr>\n</tbody></table>\n<h3 id=\"command-line-interface-and-user-experience-terms\">Command-Line Interface and User Experience Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>DiffArguments</strong></td>\n<td>Container for parsed command-line arguments including file paths, context settings, and formatting options</td>\n<td>Central configuration object in Milestone 4 that controls all aspects of diff tool behavior</td>\n</tr>\n<tr>\n<td><strong>ColorMode</strong></td>\n<td>Enumeration controlling when ANSI color codes are applied to output (always, never, auto based on TTY)</td>\n<td>User preference system in Milestone 4 that balances visual enhancement with compatibility requirements</td>\n</tr>\n<tr>\n<td><strong>ColorFormatter</strong></td>\n<td>Utility class providing ANSI color code helpers for terminal text formatting</td>\n<td>Encapsulates color handling logic in Milestone 4, supporting both colored and plain text output modes</td>\n</tr>\n</tbody></table>\n<h3 id=\"architecture-and-design-pattern-terms\">Architecture and Design Pattern Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>PipelineContext</strong></td>\n<td>Execution context tracking current processing stage and progress for monitoring and error reporting</td>\n<td>Provides visibility into diff tool execution progress and helps with debugging when operations fail</td>\n</tr>\n<tr>\n<td><strong>PipelineError</strong></td>\n<td>Exception type that preserves context information about where and why pipeline processing failed</td>\n<td>Structured error handling that maintains enough information for meaningful error messages and debugging</td>\n</tr>\n<tr>\n<td><strong>DiffPipeline</strong></td>\n<td>Main coordinator component that orchestrates the flow from file reading through LCS computation to formatted output</td>\n<td>Central control component that manages the interaction between FileReader, LCSEngine, DiffGenerator, and OutputFormatter</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-development-terms\">Debugging and Development Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>MatrixVisualizer</strong></td>\n<td>Debugging utility that generates formatted display of LCS matrices with sequence headers for inspection</td>\n<td>Essential debugging tool for understanding LCS algorithm behavior and diagnosing incorrect results</td>\n</tr>\n<tr>\n<td><strong>BacktrackTracer</strong></td>\n<td>Debugging component that logs detailed information about backtracking decisions and path selection</td>\n<td>Helps diagnose issues with LCS reconstruction by providing step-by-step trace of algorithm decisions</td>\n</tr>\n<tr>\n<td><strong>DebugLCSEngine</strong></td>\n<td>Enhanced LCS engine with additional debugging capabilities including matrix inspection and validation</td>\n<td>Development tool that extends basic LCS engine with comprehensive debugging features for learning and troubleshooting</td>\n</tr>\n<tr>\n<td><strong>algorithm execution tracing</strong></td>\n<td>Step-by-step logging of algorithm decision-making process including matrix construction and backtracking</td>\n<td>Debugging technique that provides detailed visibility into how the LCS algorithm processes input sequences</td>\n</tr>\n<tr>\n<td><strong>output format validation</strong></td>\n<td>Verification that generated diff output conforms to standard unified diff format requirements</td>\n<td>Quality assurance process ensuring compatibility with existing tools and systems that consume diff output</td>\n</tr>\n</tbody></table>\n<h3 id=\"memory-management-and-optimization-terms\">Memory Management and Optimization Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>memory exhaustion</strong></td>\n<td>Condition where algorithm memory requirements exceed available system resources</td>\n<td>Primary failure mode for large file comparison that necessitates algorithm selection and resource monitoring</td>\n</tr>\n<tr>\n<td><strong>space-time trade-off</strong></td>\n<td>Algorithm design decision balancing memory usage against computational complexity</td>\n<td>Fundamental consideration in choosing between different LCS implementation strategies</td>\n</tr>\n<tr>\n<td><strong>memory-efficient backtracking</strong></td>\n<td>Techniques for reconstructing LCS without storing the complete matrix</td>\n<td>Advanced optimization that enables LCS computation for very large files</td>\n</tr>\n<tr>\n<td><strong>incremental processing</strong></td>\n<td>Strategy of processing input in chunks rather than loading entire files into memory</td>\n<td>Potential optimization for handling files larger than available system memory</td>\n</tr>\n</tbody></table>\n<h3 id=\"future-extension-and-advanced-feature-terms\">Future Extension and Advanced Feature Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Token</strong></td>\n<td>Granular unit of text (character, word, line) that serves as the basic comparison element</td>\n<td>Abstraction that enables hierarchical diffing by supporting different levels of text granularity</td>\n</tr>\n<tr>\n<td><strong>TokenizerEngine</strong></td>\n<td>Component responsible for splitting text into meaningful comparison units based on selected granularity</td>\n<td>Enables word-level and character-level diffing as extensions beyond basic line-based comparison</td>\n</tr>\n<tr>\n<td><strong>HierarchicalDiffGenerator</strong></td>\n<td>Extended diff generator that analyzes changes at multiple levels of granularity</td>\n<td>Advanced feature that can provide more detailed change analysis by examining lines, words, and characters</td>\n</tr>\n<tr>\n<td><strong>SemanticDiffEngine</strong></td>\n<td>Diff engine that operates on abstract syntax trees rather than raw text</td>\n<td>Code-aware diffing capability that understands programming language structure</td>\n</tr>\n<tr>\n<td><strong>SideBySideFormatter</strong></td>\n<td>Output formatter that presents changes in parallel columns rather than unified format</td>\n<td>Alternative display format that makes before/after comparison more intuitive for human readers</td>\n</tr>\n<tr>\n<td><strong>HTMLFormatter</strong></td>\n<td>Output formatter that generates interactive web-based diff displays</td>\n<td>Rich output format supporting folding, syntax highlighting, and interactive navigation</td>\n</tr>\n<tr>\n<td><strong>VCSAdapter</strong></td>\n<td>Abstract interface enabling integration with version control systems</td>\n<td>Extension point for comparing file versions across commits and branches</td>\n</tr>\n<tr>\n<td><strong>StrategySelector</strong></td>\n<td>Component that analyzes input characteristics and selects optimal algorithm variant</td>\n<td>Intelligent system that automatically chooses the best approach based on file size, available memory, and performance requirements</td>\n</tr>\n</tbody></table>\n<h3 id=\"quality-assurance-and-validation-terms\">Quality Assurance and Validation Terms</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Project</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>hunk consistency validation</strong></td>\n<td>Verification that hunk line counts accurately reflect the contained changes</td>\n<td>Quality assurance check that prevents malformed diff output</td>\n</tr>\n<tr>\n<td><strong>LCS property verification</strong></td>\n<td>Testing that computed longest common subsequences satisfy mathematical correctness properties</td>\n<td>Ensures algorithm implementation correctness through property-based validation</td>\n</tr>\n<tr>\n<td><strong>format compliance checking</strong></td>\n<td>Validation that generated output conforms to standard unified diff format specifications</td>\n<td>Compatibility assurance ensuring output works with existing tools and systems</td>\n</tr>\n<tr>\n<td><strong>cross-platform compatibility</strong></td>\n<td>Ensuring consistent behavior across different operating systems and terminal environments</td>\n<td>Critical requirement for a generally useful diff tool</td>\n</tr>\n</tbody></table>\n<p>This comprehensive glossary serves as both a reference during implementation and a learning resource for understanding the deeper concepts behind text comparison algorithms. Each term is defined with sufficient detail to understand its role in the overall system while maintaining connections to the specific milestones where these concepts become practically important.</p>\n<p>The terminology spans from fundamental computer science concepts like dynamic programming and algorithmic complexity to practical implementation concerns like file encoding and terminal color handling. Understanding these terms and their relationships is essential for successfully implementing a robust diff tool that handles real-world text comparison scenarios effectively.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CLI Parsing</td>\n<td><code>argparse</code> module with basic argument handling</td>\n<td><code>click</code> library with rich help formatting and command groups</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td><code>open()</code> with try/except encoding detection</td>\n<td><code>pathlib</code> with <code>chardet</code> library for robust encoding detection</td>\n</tr>\n<tr>\n<td>ANSI Colors</td>\n<td>String constants with manual concatenation</td>\n<td><code>colorama</code> library for cross-platform color support</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Simple time/memory measurement</td>\n<td><code>memory_profiler</code> and <code>cProfile</code> for detailed analysis</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in <code>unittest</code> module</td>\n<td><code>pytest</code> with fixtures and parameterized testing</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended Project Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>diff-tool/\n├── src/\n│   ├── __init__.py\n│   ├── main.py                 # CLI entry point and argument parsing\n│   ├── data_model.py           # Core types and data structures\n│   ├── file_reader.py          # FileReader component\n│   ├── lcs_engine.py           # LCS computation and optimization\n│   ├── diff_generator.py       # Edit operations and hunk formation\n│   ├── output_formatter.py     # Unified diff formatting and colors\n│   ├── error_handling.py       # Error types and handling utilities\n│   └── utils/\n│       ├── __init__.py\n│       ├── colors.py           # ANSI color utilities\n│       ├── performance.py      # Performance monitoring\n│       └── validation.py       # Data validation helpers\n├── tests/\n│   ├── __init__.py\n│   ├── test_file_reader.py\n│   ├── test_lcs_engine.py\n│   ├── test_diff_generator.py\n│   ├── test_output_formatter.py\n│   └── fixtures/               # Test files with various encodings\n│       ├── utf8_sample.txt\n│       ├── latin1_sample.txt\n│       └── binary_sample.bin\n├── docs/\n│   ├── design_document.md\n│   └── api_reference.md\n├── requirements.txt\n├── setup.py\n└── README.md</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p><strong>File: <code>src/utils/colors.py</code></strong> (Complete ANSI color utilities)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ColorMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Controls when ANSI color codes are applied to output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AUTO</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"auto\"</span><span style=\"color:#6A737D\">      # Color when output is to TTY</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ALWAYS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"always\"</span><span style=\"color:#6A737D\">  # Force color regardless of output</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NEVER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"never\"</span><span style=\"color:#6A737D\">    # Never use color</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ANSI color constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[31m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">GREEN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[32m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BOLD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[1m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DIM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[2m\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RESET</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\033</span><span style=\"color:#9ECBFF\">[0m\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ColorFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"ANSI color helper with TTY detection and mode control.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, color_mode: ColorMode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">AUTO</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> color_mode</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._color_enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._determine_color_enabled()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _determine_color_enabled</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine if color should be enabled based on mode and TTY detection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">NEVER</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.color_mode </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ColorMode.</span><span style=\"color:#79B8FF\">ALWAYS</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># AUTO mode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> sys.stdout.isatty() </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> os.getenv(</span><span style=\"color:#9ECBFF\">'NO_COLOR'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> red</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format text with red ANSI codes if color enabled.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{RED}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> green</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format text with green ANSI codes if color enabled.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{GREEN}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> bold</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format text with bold ANSI codes if color enabled.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{BOLD}{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}{RESET}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_color_enabled</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if color output is currently enabled.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._color_enabled</span></span></code></pre></div>\n\n<p><strong>File: <code>src/utils/performance.py</code></strong> (Complete performance monitoring)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, Tuple, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceStats</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Performance statistics for a specific algorithm phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_time: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    end_time: Optional[</span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peak_memory_mb: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operations_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matrix_size: Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm_phase: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceMonitor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Monitors and reports performance statistics for diff operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stats: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PerformanceStats] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_phase: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.Process()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_phase</span><span style=\"color:#E1E4E8\">(self, phase_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, matrix_size: Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Begin monitoring a specific algorithm phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> phase_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stats[phase_name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PerformanceStats(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            start_time</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            matrix_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">matrix_size,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            algorithm_phase</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">phase_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> end_phase</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Complete monitoring of current phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stats.peak_memory_mb </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._get_memory_usage_mb()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_operation</span><span style=\"color:#E1E4E8\">(self, count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record completion of algorithm operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.current_phase </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.stats[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.current_phase].operations_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _get_memory_usage_mb</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get current process memory usage in MB.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._process.memory_info().rss </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_report</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate comprehensive performance report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        report </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> phase_name, stats </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stats.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            duration </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (stats.end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> stats.start_time) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> stats.end_time </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            report[phase_name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'duration_seconds'</span><span style=\"color:#E1E4E8\">: duration,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'peak_memory_mb'</span><span style=\"color:#E1E4E8\">: stats.peak_memory_mb,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'operations_count'</span><span style=\"color:#E1E4E8\">: stats.operations_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'matrix_size'</span><span style=\"color:#E1E4E8\">: stats.matrix_size,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'ops_per_second'</span><span style=\"color:#E1E4E8\">: stats.operations_count </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> duration </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> report</span></span></code></pre></div>\n\n<p><strong>File: <code>src/utils/validation.py</code></strong> (Complete validation utilities)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_hunk_consistency</span><span style=\"color:#E1E4E8\">(hunk) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify that hunk line counts match actual content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Count actual additions and deletions in hunk lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actual_deletions </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> hunk.lines </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> line.line_type.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"DELETED\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actual_additions </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> hunk.lines </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> line.line_type.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"ADDED\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actual_unchanged </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> hunk.lines </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> line.line_type.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"UNCHANGED\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Calculate expected counts from hunk header</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_old_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk.old_count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_new_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hunk.new_count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Validate that header counts match actual line content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    calculated_old </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_deletions </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> actual_unchanged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    calculated_new </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_additions </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> actual_unchanged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (calculated_old </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected_old_count </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            calculated_new </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected_new_count)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Normalize line endings and detect original format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Detect original line ending format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        original_ending </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'CRLF'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        original_ending </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'CR'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        original_ending </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'LF'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        original_ending </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'NONE'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Normalize to LF</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    normalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> normalized, original_ending</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> split_preserving_empty_lines</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Split content into lines while preserving empty lines in sequence.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> content:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Split on normalized line endings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Handle trailing newline - if content ends with newline,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # split will create an empty string at the end that we should remove</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> content.endswith(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> lines </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> lines[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines.pop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> lines</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_binary_content</span><span style=\"color:#E1E4E8\">(content: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, sample_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8192</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detect if file content appears to be binary rather than text.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check first sample_size bytes for null bytes or high percentage of non-printable chars</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sample </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content[:sample_size]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Presence of null bytes strongly indicates binary content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\x00</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> sample:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Count printable ASCII and common extended characters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    printable_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> byte </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> sample </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                         if</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> byte </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 126</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> byte </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">9</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # If less than 95% printable characters, likely binary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(sample) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        printable_ratio </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> printable_count </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(sample)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> printable_ratio </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.95</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p><strong>File: <code>src/data_model.py</code></strong> (Core types with method skeletons)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Classification of lines in diff output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNCHANGED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"UNCHANGED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ADDED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ADDED\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELETED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DELETED\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DiffLine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a single line in diff output with metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_type: LineType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_line_num: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_unified_diff_line</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format line with appropriate unified diff prefix.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get prefix character for line type (space, +, -)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Combine prefix with line content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle lines that don't end with newline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_change</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Returns True for ADD or DELETE lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if line_type is ADDED or DELETED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return False for UNCHANGED lines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Hunk</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Group of consecutive changes with surrounding context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    old_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_start: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines: List[DiffLine]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_before: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context_after: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_hunk_header</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate @@ header line for unified diff format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Format old file range as start,count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Format new file range as +start,count  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Combine into @@ -old_range +new_range @@</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle special case where count is 1 (omit ,1)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Implementation Hints:</strong></p>\n<ul>\n<li><strong>File Encoding</strong>: Use <code>open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;)</code> first, catch <code>UnicodeDecodeError</code> and retry with <code>encoding=&#39;latin-1&#39;</code></li>\n<li><strong>Memory Monitoring</strong>: Use <code>psutil.Process().memory_info().rss</code> to get current memory usage in bytes</li>\n<li><strong>Cross-Platform Paths</strong>: Use <code>pathlib.Path</code> instead of string concatenation for file path handling</li>\n<li><strong>ANSI Color Detection</strong>: Check <code>sys.stdout.isatty()</code> and absence of <code>NO_COLOR</code> environment variable</li>\n<li><strong>Matrix Operations</strong>: Use list comprehensions for matrix initialization: <code>[[0 for _ in range(n)] for _ in range(m)]</code></li>\n<li><strong>Error Context</strong>: Use <code>try/except</code> blocks that catch specific exceptions and re-raise with additional context</li>\n<li><strong>String Comparison</strong>: Use <code>==</code> for exact line matching - Python handles Unicode comparison correctly</li>\n<li><strong>Performance Timing</strong>: Use <code>time.perf_counter()</code> for high-resolution timing measurements</li>\n</ul>\n<p><strong>F. Milestone Checkpoint Verification:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Milestone</th>\n<th>Command to Run</th>\n<th>Expected Output</th>\n<th>Manual Verification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1: Line Tokenization</td>\n<td><code>python -m pytest tests/test_file_reader.py -v</code></td>\n<td>All file reading tests pass</td>\n<td>Create test files with different encodings, run <code>detect_file_encoding()</code></td>\n</tr>\n<tr>\n<td>2: LCS Algorithm</td>\n<td><code>python -m pytest tests/test_lcs_engine.py -v</code></td>\n<td>LCS computation tests pass with correct subsequences</td>\n<td>Compare simple text files manually, verify LCS makes sense</td>\n</tr>\n<tr>\n<td>3: Diff Generation</td>\n<td><code>python -m pytest tests/test_diff_generator.py -v</code></td>\n<td>Hunk generation tests pass with proper context</td>\n<td>Generate diff for known files, check hunk boundaries and line numbers</td>\n</tr>\n<tr>\n<td>4: CLI Integration</td>\n<td><code>python src/main.py file1.txt file2.txt</code></td>\n<td>Colored diff output in unified format</td>\n<td>Test with <code>--no-color</code> flag, verify exit codes with <code>echo $?</code></td>\n</tr>\n</tbody></table>\n<p><strong>G. Common Implementation Patterns:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Error handling with context preservation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> read_file_lines(filepath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#79B8FF\"> UnicodeDecodeError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    raise</span><span style=\"color:#E1E4E8\"> EncodingError(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        f</span><span style=\"color:#9ECBFF\">\"Cannot decode file </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">filepath</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"filepath\"</span><span style=\"color:#E1E4E8\">: filepath, </span><span style=\"color:#9ECBFF\">\"encoding_attempts\"</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"utf-8\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"latin-1\"</span><span style=\"color:#E1E4E8\">]},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">        suggestion</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"File may be binary or use unsupported encoding\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Resource monitoring pattern</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">monitor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ResourceMonitor(</span><span style=\"color:#FFAB70\">memory_limit_mb</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">512</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">time_limit_seconds</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">monitor.start_monitoring()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expensive_operation()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> error </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> monitor.check_limits():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> monitor.get_stats()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Safe matrix construction with memory estimation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> estimate_matrix_memory</span><span style=\"color:#E1E4E8\">(rows: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, cols: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Estimate LCS matrix memory requirements in MB.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Each cell stores an integer (typically 8 bytes on 64-bit systems)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bytes_needed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rows </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> cols </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> bytes_needed </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n","toc":[{"level":1,"text":"Diff Tool: Design Document","id":"diff-tool-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: DNA Sequence Alignment","id":"mental-model-dna-sequence-alignment"},{"level":3,"text":"Existing Diff Algorithms","id":"existing-diff-algorithms"},{"level":4,"text":"Naive Character-by-Character Comparison","id":"naive-character-by-character-comparison"},{"level":4,"text":"Line-by-Line Comparison","id":"line-by-line-comparison"},{"level":4,"text":"Longest Common Subsequence (LCS) Approach","id":"longest-common-subsequence-lcs-approach"},{"level":4,"text":"Myers&#39; Diff Algorithm","id":"myers39-diff-algorithm"},{"level":4,"text":"Algorithm Comparison and Selection Criteria","id":"algorithm-comparison-and-selection-criteria"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Research and Analysis Recommendations","id":"a-research-and-analysis-recommendations"},{"level":4,"text":"B. Conceptual Validation Exercises","id":"b-conceptual-validation-exercises"},{"level":4,"text":"C. Key Terminology and Concepts","id":"c-key-terminology-and-concepts"},{"level":4,"text":"D. Problem Decomposition Strategy","id":"d-problem-decomposition-strategy"},{"level":4,"text":"E. Design Principles for Implementation","id":"e-design-principles-for-implementation"},{"level":4,"text":"F. Milestone Checkpoint Expectations","id":"f-milestone-checkpoint-expectations"},{"level":4,"text":"G. Common Conceptual Pitfalls","id":"g-common-conceptual-pitfalls"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Core Text Comparison Capabilities","id":"core-text-comparison-capabilities"},{"level":4,"text":"Unified Diff Format Output","id":"unified-diff-format-output"},{"level":4,"text":"Configurable Context Display","id":"configurable-context-display"},{"level":4,"text":"Command-Line Interface","id":"command-line-interface"},{"level":4,"text":"Visual Enhancement Features","id":"visual-enhancement-features"},{"level":3,"text":"Non-Goals","id":"non-goals"},{"level":4,"text":"Advanced Diff Algorithms","id":"advanced-diff-algorithms"},{"level":4,"text":"Multi-File and Directory Operations","id":"multi-file-and-directory-operations"},{"level":4,"text":"Binary File Support","id":"binary-file-support"},{"level":4,"text":"Advanced Output Formats","id":"advanced-output-formats"},{"level":4,"text":"Three-Way Merge and Conflict Resolution","id":"three-way-merge-and-conflict-resolution"},{"level":4,"text":"Performance Optimization Features","id":"performance-optimization-features"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Scope Validation Checklist","id":"scope-validation-checklist"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Common Scope Creep Pitfalls","id":"common-scope-creep-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Stack Recommendations","id":"technology-stack-recommendations"},{"level":4,"text":"Essential Infrastructure Code","id":"essential-infrastructure-code"},{"level":4,"text":"Core Component Skeletons","id":"core-component-skeletons"},{"level":4,"text":"Milestone Validation Commands","id":"milestone-validation-commands"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"FileReader Component","id":"filereader-component"},{"level":4,"text":"LCSEngine Component","id":"lcsengine-component"},{"level":4,"text":"DiffGenerator Component","id":"diffgenerator-component"},{"level":4,"text":"OutputFormatter Component","id":"outputformatter-component"},{"level":3,"text":"Component Communication Patterns","id":"component-communication-patterns"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"Data Flow Architecture","id":"data-flow-architecture"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Project Structure Setup","id":"project-structure-setup"},{"level":4,"text":"Core Component Interfaces","id":"core-component-interfaces"},{"level":4,"text":"Component Integration Pattern","id":"component-integration-pattern"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Language-Specific Implementation Notes","id":"language-specific-implementation-notes"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Core Types and Structures","id":"core-types-and-structures"},{"level":4,"text":"FileContent Structure","id":"filecontent-structure"},{"level":4,"text":"DiffLine Structure","id":"diffline-structure"},{"level":4,"text":"LineType Enumeration","id":"linetype-enumeration"},{"level":4,"text":"Hunk Structure","id":"hunk-structure"},{"level":4,"text":"CommonSubsequence Structure","id":"commonsubsequence-structure"},{"level":4,"text":"EditDistance Structure","id":"editdistance-structure"},{"level":3,"text":"Type Relationships","id":"type-relationships"},{"level":4,"text":"File Processing Flow","id":"file-processing-flow"},{"level":4,"text":"Data Flow Dependencies","id":"data-flow-dependencies"},{"level":4,"text":"Memory and Performance Implications","id":"memory-and-performance-implications"},{"level":4,"text":"Error Propagation Through Types","id":"error-propagation-through-types"},{"level":3,"text":"Architecture Decision Records","id":"architecture-decision-records"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Type Definitions","id":"core-type-definitions"},{"level":4,"text":"Helper Functions","id":"helper-functions"},{"level":4,"text":"Type Conversion Utilities","id":"type-conversion-utilities"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"File Reader Component","id":"file-reader-component"},{"level":3,"text":"Mental Model: Document Preparation","id":"mental-model-document-preparation"},{"level":3,"text":"Encoding Detection and Handling","id":"encoding-detection-and-handling"},{"level":3,"text":"Line Normalization","id":"line-normalization"},{"level":4,"text":"Line Ending Standardization","id":"line-ending-standardization"},{"level":4,"text":"Whitespace and Empty Line Handling","id":"whitespace-and-empty-line-handling"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":4,"text":"⚠️ Pitfall: Binary File Encoding Explosion","id":"-pitfall-binary-file-encoding-explosion"},{"level":4,"text":"⚠️ Pitfall: Memory Exhaustion on Large Files","id":"-pitfall-memory-exhaustion-on-large-files"},{"level":4,"text":"⚠️ Pitfall: Trailing Newline Inconsistency","id":"-pitfall-trailing-newline-inconsistency"},{"level":4,"text":"⚠️ Pitfall: Line Ending Mixed Mode Corruption","id":"-pitfall-line-ending-mixed-mode-corruption"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structures","id":"core-data-structures"},{"level":4,"text":"Encoding Detection Infrastructure","id":"encoding-detection-infrastructure"},{"level":4,"text":"Line Normalization Utilities","id":"line-normalization-utilities"},{"level":4,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"LCS Engine Component","id":"lcs-engine-component"},{"level":3,"text":"Mental Model: Finding Common Ground","id":"mental-model-finding-common-ground"},{"level":3,"text":"Dynamic Programming Algorithm","id":"dynamic-programming-algorithm"},{"level":4,"text":"Matrix Construction Algorithm","id":"matrix-construction-algorithm"},{"level":4,"text":"Backtracking Algorithm for Sequence Recovery","id":"backtracking-algorithm-for-sequence-recovery"},{"level":4,"text":"LCS Engine Data Structures","id":"lcs-engine-data-structures"},{"level":4,"text":"LCS Engine Interface","id":"lcs-engine-interface"},{"level":3,"text":"Memory Optimization Strategies","id":"memory-optimization-strategies"},{"level":4,"text":"Two-Row Optimization","id":"two-row-optimization"},{"level":4,"text":"Hirschberg&#39;s Algorithm Consideration","id":"hirschberg39s-algorithm-consideration"},{"level":4,"text":"Adaptive Memory Management Implementation","id":"adaptive-memory-management-implementation"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Diff Generator Component","id":"diff-generator-component"},{"level":3,"text":"Mental Model: Editorial Instructions","id":"mental-model-editorial-instructions"},{"level":3,"text":"Edit Script Generation","id":"edit-script-generation"},{"level":3,"text":"Hunk Formation and Context","id":"hunk-formation-and-context"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Output Formatter Component","id":"output-formatter-component"},{"level":3,"text":"Mental Model: Publishing Changes","id":"mental-model-publishing-changes"},{"level":3,"text":"Unified Diff Format","id":"unified-diff-format"},{"level":4,"text":"Format Structure and Components","id":"format-structure-and-components"},{"level":4,"text":"Hunk Formation and Context Integration","id":"hunk-formation-and-context-integration"},{"level":4,"text":"Header Generation and File Identification","id":"header-generation-and-file-identification"},{"level":3,"text":"Color Output and CLI Interface","id":"color-output-and-cli-interface"},{"level":4,"text":"ANSI Color Support and TTY Detection","id":"ansi-color-support-and-tty-detection"},{"level":4,"text":"Command-Line Argument Processing","id":"command-line-argument-processing"},{"level":4,"text":"Exit Code Conventions","id":"exit-code-conventions"},{"level":4,"text":"ColorFormatter Helper Implementation","id":"colorformatter-helper-implementation"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Component Communication","id":"component-communication"},{"level":3,"text":"Operation Sequence","id":"operation-sequence"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"File System Errors","id":"file-system-errors"},{"level":3,"text":"Algorithm Edge Cases","id":"algorithm-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: Quality Assurance Chain","id":"mental-model-quality-assurance-chain"},{"level":3,"text":"Unit Testing Approach","id":"unit-testing-approach"},{"level":4,"text":"Component Isolation Strategy","id":"component-isolation-strategy"},{"level":4,"text":"FileReader Component Testing","id":"filereader-component-testing"},{"level":4,"text":"LCS Engine Component Testing","id":"lcs-engine-component-testing"},{"level":4,"text":"DiffGenerator Component Testing","id":"diffgenerator-component-testing"},{"level":4,"text":"OutputFormatter Component Testing","id":"outputformatter-component-testing"},{"level":4,"text":"Property-Based Testing Strategy","id":"property-based-testing-strategy"},{"level":4,"text":"Error Condition Testing","id":"error-condition-testing"},{"level":3,"text":"Common Pitfalls in Testing","id":"common-pitfalls-in-testing"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1 Checkpoint: Line Tokenization","id":"milestone-1-checkpoint-line-tokenization"},{"level":4,"text":"Milestone 2 Checkpoint: LCS Algorithm","id":"milestone-2-checkpoint-lcs-algorithm"},{"level":4,"text":"Milestone 3 Checkpoint: Diff Generation","id":"milestone-3-checkpoint-diff-generation"},{"level":4,"text":"Milestone 4 Checkpoint: CLI and Color Output","id":"milestone-4-checkpoint-cli-and-color-output"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Test Fixture Infrastructure","id":"test-fixture-infrastructure"},{"level":4,"text":"Component Test Skeletons","id":"component-test-skeletons"},{"level":4,"text":"Property-Based Test Implementation","id":"property-based-test-implementation"},{"level":4,"text":"Milestone Validation Scripts","id":"milestone-validation-scripts"},{"level":4,"text":"Debugging and Performance Analysis Tools","id":"debugging-and-performance-analysis-tools"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Symptom-Cause-Fix Reference","id":"symptom-cause-fix-reference"},{"level":3,"text":"Debugging Techniques","id":"debugging-techniques"},{"level":4,"text":"Matrix Inspection and Visualization","id":"matrix-inspection-and-visualization"},{"level":4,"text":"Algorithm Execution Tracing","id":"algorithm-execution-tracing"},{"level":4,"text":"Output Format Validation","id":"output-format-validation"},{"level":4,"text":"Memory and Performance Debugging","id":"memory-and-performance-debugging"},{"level":4,"text":"Property-Based Testing Integration","id":"property-based-testing-integration"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Debugging Infrastructure Starter Code","id":"debugging-infrastructure-starter-code"},{"level":4,"text":"Core Debugging Integration Points","id":"core-debugging-integration-points"},{"level":4,"text":"Language-Specific Debugging Hints","id":"language-specific-debugging-hints"},{"level":4,"text":"Milestone Checkpoint Integration","id":"milestone-checkpoint-integration"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Algorithm Improvements","id":"algorithm-improvements"},{"level":4,"text":"Myers&#39; Algorithm Implementation","id":"myers39-algorithm-implementation"},{"level":4,"text":"Word-Level and Character-Level Diffing","id":"word-level-and-character-level-diffing"},{"level":4,"text":"Semantic Diffing for Code","id":"semantic-diffing-for-code"},{"level":3,"text":"Output Format Enhancements","id":"output-format-enhancements"},{"level":4,"text":"Side-by-Side Display","id":"side-by-side-display"},{"level":4,"text":"HTML Output with Interactive Features","id":"html-output-with-interactive-features"},{"level":4,"text":"Integration with Version Control Systems","id":"integration-with-version-control-systems"},{"level":4,"text":"Advanced Output Customization","id":"advanced-output-customization"},{"level":3,"text":"Implementation Strategy and Migration Path","id":"implementation-strategy-and-migration-path"},{"level":4,"text":"Phase 1: Algorithm Enhancement (3-4 weeks)","id":"phase-1-algorithm-enhancement-3-4-weeks"},{"level":4,"text":"Phase 2: Multi-Level Diffing (4-5 weeks)","id":"phase-2-multi-level-diffing-4-5-weeks"},{"level":4,"text":"Phase 3: Output Format Extensions (3-4 weeks)","id":"phase-3-output-format-extensions-3-4-weeks"},{"level":4,"text":"Phase 4: VCS Integration (5-6 weeks)","id":"phase-4-vcs-integration-5-6-weeks"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure Enhancement","id":"recommended-file-structure-enhancement"},{"level":4,"text":"Algorithm Strategy Infrastructure","id":"algorithm-strategy-infrastructure"},{"level":4,"text":"HTML Output Infrastructure","id":"html-output-infrastructure"},{"level":4,"text":"VCS Integration Foundation","id":"vcs-integration-foundation"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Common Extension Pitfalls","id":"common-extension-pitfalls"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Core Algorithm Terms","id":"core-algorithm-terms"},{"level":3,"text":"Text Processing and File Handling Terms","id":"text-processing-and-file-handling-terms"},{"level":3,"text":"Diff Format and Output Terms","id":"diff-format-and-output-terms"},{"level":3,"text":"Command-Line Interface and Display Terms","id":"command-line-interface-and-display-terms"},{"level":3,"text":"Data Structure and Architecture Terms","id":"data-structure-and-architecture-terms"},{"level":3,"text":"Performance and Memory Management Terms","id":"performance-and-memory-management-terms"},{"level":3,"text":"Implementation and Testing Terms","id":"implementation-and-testing-terms"},{"level":3,"text":"Algorithm Complexity and Optimization Terms","id":"algorithm-complexity-and-optimization-terms"},{"level":3,"text":"Error Classification and Handling Terms","id":"error-classification-and-handling-terms"},{"level":3,"text":"Development and Extension Terms","id":"development-and-extension-terms"},{"level":3,"text":"Advanced Features and Algorithms Terms","id":"advanced-features-and-algorithms-terms"},{"level":3,"text":"Data Structure and Type System Terms","id":"data-structure-and-type-system-terms"},{"level":3,"text":"Performance Monitoring and Resource Management Terms","id":"performance-monitoring-and-resource-management-terms"},{"level":3,"text":"Command-Line Interface and User Experience Terms","id":"command-line-interface-and-user-experience-terms"},{"level":3,"text":"Architecture and Design Pattern Terms","id":"architecture-and-design-pattern-terms"},{"level":3,"text":"Debugging and Development Terms","id":"debugging-and-development-terms"},{"level":3,"text":"Memory Management and Optimization Terms","id":"memory-management-and-optimization-terms"},{"level":3,"text":"Future Extension and Advanced Feature Terms","id":"future-extension-and-advanced-feature-terms"},{"level":3,"text":"Quality Assurance and Validation Terms","id":"quality-assurance-and-validation-terms"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"}],"title":"Diff Tool: Design Document","markdown":"# Diff Tool: Design Document\n\n\n## Overview\n\nA text comparison tool that identifies differences between two files using the Longest Common Subsequence algorithm and Myers' diff algorithm to generate unified diff output. The key architectural challenge is efficiently computing optimal edit sequences using dynamic programming while providing readable output formats.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** All milestones — understanding the fundamental problem drives all implementation decisions\n\nText comparison appears deceptively simple on the surface. Given two files, we want to identify what changed — which lines were added, deleted, or remained the same. However, this seemingly straightforward task reveals deep complexity when we consider the numerous ways text can be modified and the challenge of presenting changes in a meaningful, readable format.\n\nThe core challenge lies in defining what constitutes the \"best\" representation of differences between two text sequences. When a user edits a document, they don't simply perform random insertions and deletions — they make logical changes like adding paragraphs, moving sections, or revising sentences. Our diff algorithm must reverse-engineer these intentions from the final result, identifying the most intuitive way to express the transformation from one version to another.\n\nConsider a simple example where we compare two versions of a function. The original version might have five lines, and the modified version might have seven lines. There could be multiple valid ways to represent this change: we could show that two lines were added at the end, or that the entire function was deleted and replaced, or that specific lines were inserted at particular positions. The algorithm must choose the representation that minimizes cognitive load for the human reader while accurately capturing the semantic changes.\n\nThe problem becomes even more complex when we consider that text files can contain thousands of lines, use different encodings, have varying line ending conventions, and may share very few common elements. A naive approach that compares every character or line against every other character or line quickly becomes computationally prohibitive. We need algorithms that can efficiently find optimal solutions while handling edge cases gracefully.\n\n### Mental Model: DNA Sequence Alignment\n\nThe most intuitive way to understand text comparison is through the lens of **DNA sequence alignment**, a fundamental problem in bioinformatics. Just as biologists compare genetic sequences to understand evolutionary relationships and identify mutations, we compare text files to understand editorial changes and identify modifications.\n\nIn DNA sequence alignment, scientists start with two genetic sequences — strings of nucleotides represented as letters (A, T, G, C). They want to find the optimal alignment that maximizes matching bases while minimizing the number of insertions, deletions, and substitutions needed to transform one sequence into another. The key insight is that not all differences are equally meaningful — some represent genuine evolutionary changes, while others might be artifacts of sequencing errors or irrelevant variations.\n\nSimilarly, when comparing text files, we have two sequences of lines (instead of nucleotides). Our goal is to find the optimal alignment that maximizes matching lines while minimizing the number of insertions and deletions needed to transform the first file into the second. Just as DNA alignment algorithms identify the longest matching subsequences to infer evolutionary relationships, diff algorithms identify the **longest common subsequence** of lines to infer editorial relationships.\n\n> **Key Insight**: The longest common subsequence represents the \"evolutionary backbone\" — the content that remained stable between versions. Everything else represents editorial mutations that need to be highlighted.\n\nThis biological analogy illuminates several important aspects of the diff problem. First, **order matters** — just as the sequence of nucleotides in DNA determines genetic function, the sequence of lines in a text file determines logical structure. We can't arbitrarily rearrange lines to maximize matches without losing semantic meaning. Second, **context is crucial** — just as biologists present alignments with surrounding sequences to help interpret the significance of mutations, diff tools must present changes with surrounding context lines to help readers understand the scope and impact of modifications.\n\nThird, **optimal alignment requires global perspective** — we can't make locally optimal decisions about matching lines without considering the global structure. A line that appears in both files might seem like an obvious match, but if aligning those lines forces many other lines to appear as insertions and deletions, a different alignment might produce a cleaner, more readable result.\n\nThe DNA analogy also reveals why this problem is computationally challenging. With sequences of length m and n, there are exponentially many possible alignments to consider. Dynamic programming algorithms like those used in bioinformatics provide a systematic way to explore all possibilities efficiently, building up optimal solutions for smaller subsequences and combining them to solve the larger problem.\n\n### Existing Diff Algorithms\n\nThe evolution of diff algorithms reflects a progression from simple, intuitive approaches to sophisticated techniques that balance computational efficiency with output quality. Understanding this progression helps us appreciate the design decisions in modern diff tools and choose the right algorithm for our specific requirements.\n\n> **Decision: Algorithm Selection Strategy**\n> - **Context**: Need to choose between multiple diff algorithms with different performance and quality characteristics\n> - **Options Considered**: Naive character comparison, line-by-line comparison, LCS-based approach, Myers' algorithm\n> - **Decision**: Implement LCS-based approach first, with Myers' algorithm as future enhancement\n> - **Rationale**: LCS provides optimal results for learning dynamic programming concepts, while Myers' offers better performance for large files\n> - **Consequences**: Excellent output quality but O(mn) space complexity; Myers' extension will require significant architectural changes\n\n#### Naive Character-by-Character Comparison\n\nThe most straightforward approach treats files as sequences of characters and attempts to find character-level differences. This algorithm scans through both files simultaneously, marking characters as matching or different based on direct comparison.\n\nThe naive character approach works by maintaining two pointers, one for each file, and advancing them in lockstep. When characters match, both pointers advance. When characters differ, the algorithm faces a decision: should it treat this as a substitution, or should it look ahead to see if one file has an insertion or deletion at this position?\n\nThe fundamental problem with character-level comparison is **alignment ambiguity**. Consider comparing \"abcde\" with \"axbcde\". The naive algorithm might identify 'a' as matching, then encounter 'b' versus 'x' and incorrectly conclude that 'b' was substituted with 'x', 'c' was substituted with 'b', and so on. The correct interpretation — that 'x' was inserted between 'a' and 'b' — requires lookahead or backtracking capabilities that the naive approach lacks.\n\n| Aspect | Character-by-Character Approach |\n|--------|--------------------------------|\n| **Time Complexity** | O(n) for simple scan, O(nm) with backtracking |\n| **Space Complexity** | O(1) for simple scan, O(nm) for optimal alignment |\n| **Output Quality** | Poor - many false substitutions, misaligned content |\n| **Implementation Complexity** | Very simple for basic version, complex for quality results |\n| **Use Cases** | Binary file comparison, simple text validation |\n\nDespite these limitations, character-level comparison remains valuable for specific scenarios. Binary file comparison often uses this approach because line-based comparison is meaningless for non-text data. Additionally, character-level diffs can provide fine-grained analysis within lines that have been identified as changed by higher-level algorithms.\n\n#### Line-by-Line Comparison\n\nRecognizing that most text editing operations work at the line level, line-by-line comparison treats files as sequences of line strings rather than character sequences. This approach significantly reduces the search space and produces more semantically meaningful results for typical text files.\n\nLine-based comparison begins by tokenizing both files into arrays of lines, preserving the original line structure including empty lines. The algorithm then applies sequence comparison techniques to these line arrays, treating each line as an atomic unit. This abstraction level matches how humans typically think about text editing — we add paragraphs, delete sections, and modify sentences, rather than randomly inserting and deleting characters.\n\nThe line-based approach immediately solves several problems that plague character-level comparison. **Alignment ambiguity** is greatly reduced because entire lines serve as strong anchors for alignment. **Semantic coherence** improves because the algorithm naturally preserves logical text structure. **Performance** increases dramatically because we're comparing hundreds or thousands of lines instead of millions of characters.\n\nHowever, line-based comparison introduces its own challenges. **Whitespace sensitivity** can cause semantically identical lines to appear different due to trailing spaces or tab-versus-space differences. **Line ending variations** (LF, CRLF, CR) can create spurious differences between files created on different operating systems. **Granularity limitations** mean that changes within a line appear as complete line replacements, even if only a single word was modified.\n\n| Aspect | Line-by-Line Approach |\n|--------|----------------------|\n| **Time Complexity** | O(n) for simple scan, depends on subsequence algorithm for quality results |\n| **Space Complexity** | O(n + m) for line storage plus algorithm-specific requirements |\n| **Output Quality** | Good - matches human editing patterns, preserves document structure |\n| **Implementation Complexity** | Moderate - requires tokenization, normalization, and subsequence algorithms |\n| **Use Cases** | Most text files, source code, configuration files, documentation |\n\nModern diff tools universally adopt line-based comparison as their foundation, then apply various algorithms to find optimal line sequence alignments. The choice of subsequence algorithm determines the tool's performance characteristics and output quality.\n\n#### Longest Common Subsequence (LCS) Approach\n\nThe **Longest Common Subsequence** algorithm provides a rigorous mathematical foundation for optimal sequence comparison. Unlike heuristic approaches, LCS guarantees finding the longest sequence of lines that appear in both files in the same order, providing a principled way to identify what remained unchanged between versions.\n\nLCS operates on the insight that the optimal diff should maximize the amount of content marked as \"unchanged\" while minimizing the content marked as \"added\" or \"deleted\". By finding the longest possible common subsequence, we identify the maximum amount of shared content, and everything else naturally falls into insertion or deletion categories.\n\nThe algorithm uses **dynamic programming** to build up optimal solutions systematically. It constructs a two-dimensional matrix where entry (i,j) represents the length of the LCS between the first i lines of file A and the first j lines of file B. The recurrence relation captures the essential logic: if lines i and j match, we can extend the LCS from position (i-1, j-1); otherwise, we take the better of the two options where one file advances and the other doesn't.\n\nThis mathematical rigor comes with computational costs. The classic LCS algorithm requires O(mn) time and O(mn) space, where m and n are the lengths of the input sequences. For large files, this can consume substantial memory. However, the algorithm's guarantee of optimal results makes it an excellent choice for learning dynamic programming concepts and understanding the theoretical foundation of diff algorithms.\n\n| Aspect | LCS-Based Approach |\n|--------|-------------------|\n| **Time Complexity** | O(mn) - must consider all position pairs |\n| **Space Complexity** | O(mn) for full matrix, O(min(m,n)) with optimization |\n| **Output Quality** | Optimal - guaranteed to find longest common subsequence |\n| **Implementation Complexity** | Moderate - requires understanding of dynamic programming |\n| **Use Cases** | Educational purposes, small to medium files, maximum quality required |\n\nThe LCS approach serves as an excellent foundation for understanding diff algorithms because it makes the optimization goal explicit and provides a clear algorithmic framework. Once developers understand how LCS works, they can appreciate the trade-offs made by more advanced algorithms.\n\n#### Myers' Diff Algorithm\n\n**Myers' algorithm** represents the state-of-the-art in diff algorithm design, providing the same optimal results as LCS while offering significantly better performance characteristics for typical use cases. Developed by Eugene Myers in 1986, this algorithm powers many modern version control systems and diff tools.\n\nMyers' key insight is that most real-world file comparisons involve relatively few changes compared to the total file size. While the worst-case scenario still requires O(mn) time, the expected case for files with few differences runs in O(n + d²) time, where d is the number of differences. This makes the algorithm extremely fast for the common case of comparing similar files with localized changes.\n\nThe algorithm reconceptualizes the diff problem as a **graph traversal** problem. Instead of building a complete dynamic programming matrix, Myers' algorithm explores only the portions of the search space that are likely to contain optimal solutions. It uses a clever **edit graph** representation where horizontal moves represent insertions, vertical moves represent deletions, and diagonal moves represent matches.\n\nThe graph traversal proceeds in **waves**, exploring all possible paths that require exactly k edit operations before exploring paths that require k+1 operations. This breadth-first approach guarantees that the first path to reach the end represents an optimal solution, allowing the algorithm to terminate early without exploring the entire search space.\n\n| Aspect | Myers' Algorithm |\n|--------|------------------|\n| **Time Complexity** | O(n + d²) expected case, O(mn) worst case |\n| **Space Complexity** | O(d) for the search frontier |\n| **Output Quality** | Optimal - same results as LCS but computed more efficiently |\n| **Implementation Complexity** | High - requires understanding of graph algorithms and optimization techniques |\n| **Use Cases** | Production diff tools, version control systems, large file comparison |\n\nMyers' algorithm also provides natural opportunities for further optimizations. The **linear space** variant reduces memory usage to O(d), making it practical for comparing very large files. **Patience diff** and **histogram diff** build on Myers' foundation to handle common patterns like code movement and repeated sections more elegantly.\n\n#### Algorithm Comparison and Selection Criteria\n\nThe choice between diff algorithms depends on multiple factors including file size, expected difference density, performance requirements, implementation complexity, and output quality needs. Understanding these trade-offs helps architects make informed decisions for their specific use cases.\n\n| Algorithm | Best For | Avoid When | Key Advantage | Major Limitation |\n|-----------|----------|------------|---------------|------------------|\n| **Naive Character** | Binary files, simple validation | Text files, quality matters | Simple implementation | Poor alignment quality |\n| **Line-by-Line Heuristic** | Quick prototypes, approximations | Optimal results required | Fast implementation | Suboptimal results |\n| **LCS Dynamic Programming** | Learning, guaranteed optimal results | Large files, memory constrained | Theoretical foundation | High memory usage |\n| **Myers' Algorithm** | Production systems, large files | Educational contexts | Best practical performance | Implementation complexity |\n\n> **Architecture Insight**: The progression from naive approaches to Myers' algorithm illustrates a fundamental pattern in algorithm design — starting with simple, correct solutions and then optimizing based on real-world usage patterns and constraints.\n\nFor our diff tool implementation, we'll begin with the LCS approach because it provides the clearest path for learning dynamic programming concepts while guaranteeing optimal results. The mathematical rigor of LCS helps developers understand exactly what \"optimal\" means in the context of sequence comparison, providing a solid foundation for appreciating the optimizations made by more advanced algorithms.\n\nThe modular architecture we'll design can accommodate future algorithm upgrades. By separating the sequence comparison logic from file handling and output formatting, we can later swap in Myers' algorithm or other approaches without affecting the rest of the system. This extensibility principle ensures that our learning-focused implementation can evolve into a production-quality tool.\n\n### Implementation Guidance\n\nThe context and problem understanding phase requires no code implementation, but establishing the right mental models and terminology now will guide all subsequent development decisions. This section provides the conceptual foundation and research direction for implementing a robust diff tool.\n\n#### A. Research and Analysis Recommendations\n\n| Activity | Beginner Approach | Advanced Exploration |\n|----------|------------------|---------------------|\n| **Algorithm Study** | Implement LCS by hand on paper with 3-4 line examples | Study Myers' paper and implement edit graph traversal |\n| **Tool Analysis** | Run `diff -u` on sample files, analyze output format | Compare `diff`, `git diff`, and specialized tools like `wdiff` |\n| **Performance Testing** | Time algorithms on files with 100-1000 lines | Benchmark with real codebases, measure memory usage |\n| **Format Research** | Study unified diff format specification | Explore side-by-side, context, and HTML output formats |\n\n#### B. Conceptual Validation Exercises\n\nBefore writing any code, validate your understanding of the core concepts through these exercises:\n\n**Exercise 1: Manual LCS Computation**\nTake two short text sequences (5-8 lines each) and manually compute their LCS using the dynamic programming matrix. This hands-on experience will reveal common indexing pitfalls and help you understand the backtracking process.\n\nExample sequences for practice:\n```\nFile A: [\"apple\", \"banana\", \"cherry\", \"date\"]\nFile B: [\"banana\", \"cherry\", \"elderberry\", \"fig\"]\n```\n\n**Exercise 2: Diff Format Analysis**\nCreate several test file pairs and run them through standard `diff -u` command. Analyze the output format, paying attention to:\n- How line numbers are calculated and displayed\n- Where context lines appear and how many are included\n- How consecutive changes are grouped into hunks\n- What happens with edge cases like empty files or no common lines\n\n**Exercise 3: Algorithm Comparison**\nFor the same file pair, manually trace through different algorithmic approaches:\n- Naive character-by-character (identify where it fails)\n- Simple line matching without LCS (show suboptimal results)\n- LCS-based approach (demonstrate optimal alignment)\n\n#### C. Key Terminology and Concepts\n\nEstablish consistent vocabulary that will be used throughout the implementation:\n\n| Term | Definition | Example |\n|------|------------|---------|\n| **Sequence** | Ordered collection of comparable elements | Array of lines from a text file |\n| **Common Subsequence** | Elements appearing in both sequences in same order | Lines present in both file versions |\n| **Edit Distance** | Minimum operations to transform one sequence to another | Number of insertions + deletions needed |\n| **Hunk** | Group of consecutive changes with surrounding context | Block of diff output starting with @@ |\n| **Context Lines** | Unchanged lines displayed around changes for readability | Lines before/after changes in diff output |\n\n#### D. Problem Decomposition Strategy\n\nBreak down the overall diff problem into manageable subproblems that map to our milestone structure:\n\n1. **File Representation Problem**: How do we convert file bytes into comparable line sequences while handling encoding and line ending variations?\n\n2. **Sequence Alignment Problem**: How do we find the optimal way to align two line sequences to minimize apparent changes?\n\n3. **Change Classification Problem**: How do we convert the alignment result into explicit add/delete/unchanged operations?\n\n4. **Output Formatting Problem**: How do we present the change operations in a readable, standard format?\n\n5. **User Interface Problem**: How do we provide command-line access with appropriate options and error handling?\n\n#### E. Design Principles for Implementation\n\nEstablish core principles that will guide implementation decisions:\n\n> **Principle 1: Correctness Over Performance**\n> Prioritize producing correct, optimal results over algorithmic optimizations. Performance improvements can come later without changing the external interface.\n\n> **Principle 2: Modularity for Learning**\n> Design each component to be independently testable and understandable. A learner should be able to focus on one algorithmic concept at a time.\n\n> **Principle 3: Standard Compatibility**\n> Produce output that matches established diff tool conventions. This allows comparison with reference implementations for validation.\n\n> **Principle 4: Graceful Degradation**\n> Handle edge cases and errors gracefully, providing helpful error messages rather than crashing or producing incorrect output.\n\n#### F. Milestone Checkpoint Expectations\n\nAfter completing this context and problem statement analysis, you should be able to:\n\n- [ ] **Explain the LCS concept** using the DNA alignment analogy to someone unfamiliar with algorithms\n- [ ] **Manually compute** the LCS for simple 4-5 line file examples using the dynamic programming matrix\n- [ ] **Identify the trade-offs** between naive, LCS-based, and Myers' algorithmic approaches\n- [ ] **Analyze diff output** from standard tools, understanding the unified format structure\n- [ ] **Decompose the overall problem** into the specific subproblems addressed by each milestone\n\n#### G. Common Conceptual Pitfalls\n\n⚠️ **Pitfall: Confusing LCS with String Edit Distance**\nLCS finds the longest common subsequence, while edit distance finds the minimum number of operations needed for transformation. These are related but different concepts. LCS focuses on what stays the same; edit distance focuses on what changes.\n\n⚠️ **Pitfall: Assuming Character-Level Comparison is Simpler**\nCharacter-level comparison seems simpler but produces poor results for text files. Line-level comparison is actually easier to implement correctly and produces much better output.\n\n⚠️ **Pitfall: Underestimating Memory Requirements**\nThe naive LCS algorithm requires O(mn) space, which can be substantial for large files. A 10,000-line file comparison needs 100 million matrix entries, potentially several gigabytes of memory.\n\n⚠️ **Pitfall: Ignoring File Encoding Issues**\nText files can use various encodings (UTF-8, Latin-1, ASCII) and line endings (LF, CRLF, CR). Ignoring these differences can cause identical files to appear different or cause decoding errors.\n\nThis conceptual foundation prepares you for the detailed architectural design and implementation phases. The mental models and terminology established here will guide decision-making throughout the development process, ensuring that implementation details serve the larger goal of creating an intuitive, correct, and efficient diff tool.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** All milestones — clearly defining scope prevents feature creep and guides implementation decisions throughout the project\n\nSetting clear boundaries for our diff tool implementation is crucial for maintaining focus and delivering a working solution within reasonable complexity. This section establishes what we will build, what we explicitly won't build, and the rationale behind these decisions. By defining these boundaries upfront, we can make consistent architectural decisions and avoid the temptation to add features that would complicate the core learning objectives.\n\nThe scope definition serves multiple purposes beyond project management. It helps us choose the right algorithms and data structures for our specific use case, guides our testing strategy by defining the expected behavior boundaries, and sets realistic expectations for performance and functionality. Most importantly for a learning project, it keeps us focused on the core concepts of dynamic programming, edit distance computation, and diff algorithm implementation without getting distracted by peripheral concerns.\n\n### Functional Goals\n\nOur diff tool will implement a focused set of core capabilities that demonstrate the fundamental concepts of text comparison algorithms while providing practical utility. These goals are designed to cover the essential user workflows for comparing text files while maintaining implementation simplicity.\n\n**Mental Model: Essential Workshop Tools** — Think of our functional goals like selecting tools for a woodworking workshop. We're not trying to build every possible tool, but rather the essential ones that can handle 80% of common tasks well. A good plane, saw, and chisel will accomplish most woodworking projects, even if specialized tools might be marginally better for specific tasks. Similarly, our diff tool focuses on the core comparison operations that handle the vast majority of real-world text comparison needs.\n\n#### Core Text Comparison Capabilities\n\nThe foundation of our tool is reliable text comparison between two files using the Longest Common Subsequence algorithm. This provides the theoretical correctness that many users expect from a diff tool — finding the optimal sequence of changes that transforms one file into another.\n\n| Capability | Implementation Approach | Success Criteria |\n|------------|------------------------|------------------|\n| Line-based comparison | Split files into line arrays, compare using LCS | Identical results to reference implementations |\n| UTF-8 and Latin-1 encoding support | Automatic encoding detection with fallback | Handles common text file encodings without corruption |\n| Multiple line ending formats | Normalize LF, CRLF, and CR during tokenization | Consistent behavior across Windows, Unix, and Mac files |\n| Empty file handling | Special case detection with appropriate output | Graceful handling without algorithm failures |\n| Large file support | Streaming line reading with memory management | Process files up to several MB without memory exhaustion |\n\nThe line-based approach aligns with how humans naturally think about text changes — additions, deletions, and modifications typically happen at the granularity of lines rather than individual characters. This choice also significantly reduces the computational complexity compared to character-level diffing while still providing useful results for most text files.\n\n#### Unified Diff Format Output\n\nOur output format will conform to the unified diff standard, ensuring compatibility with existing tools and user expectations. The unified format strikes an optimal balance between human readability and machine parseability.\n\n| Format Element | Structure | Example |\n|----------------|-----------|---------|\n| File headers | `--- filename1` and `+++ filename2` | `--- original.txt` |\n| Hunk headers | `@@ -start,count +start,count @@` | `@@ -15,7 +15,9 @@` |\n| Context lines | Lines without prefix | `    unchanged line` |\n| Deletion markers | Lines prefixed with `-` | `-   deleted content` |\n| Addition markers | Lines prefixed with `+` | `+   added content` |\n\nThe unified format provides several advantages over alternatives like side-by-side or context diff formats. It's compact for large changes, clearly shows the relationship between deletions and additions, and is universally supported by version control systems, patch utilities, and code review tools.\n\n#### Configurable Context Display\n\nContext lines around changes provide crucial readability for understanding the location and nature of modifications. Our implementation will support configurable context amounts to balance between providing sufficient context and keeping output concise.\n\n> **Decision: Default Context Lines**\n> - **Context**: Users need context to understand where changes occur, but too much context clutters output\n> - **Options Considered**: 0 lines (minimal), 3 lines (git default), 5 lines (traditional diff)\n> - **Decision**: Default to 3 context lines with configurable override\n> - **Rationale**: Matches git behavior for user familiarity, provides sufficient context for most changes, keeps output manageable for review\n> - **Consequences**: Enables intuitive usage while allowing customization for specific needs\n\n| Context Setting | Use Case | Output Characteristics |\n|-----------------|----------|----------------------|\n| 0 lines | Minimal output, large files | Only changed lines shown |\n| 1-2 lines | Quick scanning | Limited context, compact |\n| 3 lines (default) | Code review, general use | Good balance of context and brevity |\n| 5+ lines | Understanding complex changes | Extensive context, verbose output |\n\n#### Command-Line Interface\n\nThe CLI provides the primary user interaction with our diff tool, emphasizing simplicity and following Unix conventions for predictable behavior.\n\n| Interface Element | Specification | Rationale |\n|------------------|---------------|-----------|\n| Basic invocation | `difftool file1 file2` | Matches standard diff utility patterns |\n| Context control | `--context N` or `-c N` | Standard flag naming for context lines |\n| Color control | `--no-color` | Disable ANSI codes for piping/redirection |\n| Help output | `--help` or `-h` | Standard help flag conventions |\n| Exit codes | 0 (identical), 1 (different), 2 (error) | Scriptable behavior matching diff standards |\n\nThe interface design prioritizes discoverability and consistency with existing tools. Users familiar with standard diff utilities should be able to use our tool immediately without consulting documentation for basic operations.\n\n#### Visual Enhancement Features\n\nColor output significantly improves the readability of diff results in terminal environments by providing immediate visual cues about change types.\n\n| Enhancement | Implementation | Benefit |\n|-------------|----------------|---------|\n| Colored additions | Green text for `+` lines | Immediate recognition of new content |\n| Colored deletions | Red text for `-` lines | Clear identification of removed content |\n| TTY detection | Automatic color disabling for non-terminals | Prevents ANSI codes in files/pipes |\n| Color override | Manual disable via flag | User control for accessibility needs |\n\nThe color scheme follows conventional diff tool coloring that users expect, reducing cognitive load when interpreting results. Automatic TTY detection ensures that color codes don't interfere with file output or shell scripting scenarios.\n\n### Non-Goals\n\nExplicitly defining what we will not implement is equally important as defining what we will build. These exclusions keep our scope manageable while focusing on the core learning objectives around dynamic programming and diff algorithms.\n\n**Mental Model: Focused Learning Path** — Think of non-goals like choosing a hiking trail. When learning to hike, you pick a trail that matches your current skill level and available time. You don't attempt advanced mountaineering techniques or multi-day expeditions on your first outing. Similarly, our non-goals represent advanced features that would distract from mastering the fundamental concepts of text comparison algorithms.\n\n#### Advanced Diff Algorithms\n\nWhile Myers' algorithm offers superior performance characteristics, implementing it properly requires understanding edit graphs, diagonal traversal, and complex optimization techniques that go beyond the scope of a beginner project focused on dynamic programming concepts.\n\n| Excluded Algorithm | Complexity Reason | Alternative Learning Path |\n|--------------------|-------------------|-------------------------|\n| Myers' algorithm | Edit graph theory, O(ND) complexity analysis | Advanced algorithms course |\n| Patience diff | Requires understanding of unique line identification | Specialized diff algorithm study |\n| Histogram diff | Statistical analysis of file content patterns | Machine learning or statistics focus |\n| Semantic diff | Language parsing, AST comparison | Compiler design or language processing |\n\nOur LCS-based approach provides the theoretical foundation that makes these advanced algorithms comprehensible later. Students who master the dynamic programming approach will be well-prepared to understand how Myers' algorithm optimizes the same underlying problem.\n\n#### Multi-File and Directory Operations\n\nDirectory comparison introduces file system traversal, recursive algorithms, and complex output formatting that would overshadow the core diff algorithm learning objectives.\n\n| Excluded Feature | Implementation Complexity | Focus Dilution |\n|------------------|--------------------------|----------------|\n| Directory diffing | Recursive tree traversal, file matching | File system operations vs. algorithms |\n| Batch file comparison | Process management, parallel execution | Concurrency vs. dynamic programming |\n| Archive comparison | Compression format handling | File format parsing vs. text comparison |\n| Remote file access | Network protocols, authentication | Distributed systems vs. local algorithms |\n\nThese features require substantial infrastructure code that doesn't contribute to understanding text comparison algorithms. Students can add these capabilities later once they've mastered the core diff computation.\n\n#### Binary File Support\n\nBinary file comparison requires fundamentally different algorithms and output formats that don't align with our text-focused learning objectives.\n\n> **Decision: Text Files Only**\n> - **Context**: Binary files require byte-level comparison with different visualization needs\n> - **Options Considered**: Hex dump diff, binary detection with error, universal byte comparison\n> - **Decision**: Detect binary files and report error with helpful message\n> - **Rationale**: Keeps focus on text algorithms, avoids complex binary visualization, provides clear user feedback\n> - **Consequences**: Users must use specialized tools for binary comparison, but get clear guidance on limitation\n\n| Binary Scenario | Our Behavior | User Guidance |\n|-----------------|--------------|---------------|\n| Pure binary files | Error with detection message | Suggest `cmp` or `xxd` utilities |\n| Mixed text/binary | Attempt text processing, may show garbage | Warning about potential binary content |\n| Large binary files | Early detection to avoid memory issues | Clear error before processing begins |\n\n#### Advanced Output Formats\n\nSupporting multiple output formats would require complex formatting infrastructure that distracts from the algorithmic learning goals.\n\n| Excluded Format | Implementation Overhead | Learning Distraction |\n|-----------------|------------------------|---------------------|\n| Side-by-side display | Terminal width detection, column alignment | UI formatting vs. algorithm implementation |\n| HTML output | Web formatting, CSS styling, escaping | Web development vs. text processing |\n| JSON/XML structured output | Schema definition, serialization libraries | Data formats vs. diff computation |\n| Patch file generation | Advanced header formatting, metadata handling | File format specifications vs. algorithms |\n\nThe unified diff format provides sufficient functionality for learning purposes while maintaining compatibility with existing tools. Students can explore alternative formats in follow-up projects once they understand the underlying comparison logic.\n\n#### Three-Way Merge and Conflict Resolution\n\nMerge algorithms introduce conflict detection, resolution strategies, and complex user interaction patterns that represent a separate area of study from basic two-way comparison.\n\n| Merge Feature | Algorithmic Complexity | UI Complexity |\n|---------------|----------------------|---------------|\n| Three-way merge | Multiple LCS computations, conflict detection | Interactive conflict resolution |\n| Automatic resolution | Heuristic development, edge case handling | Strategy configuration interfaces |\n| Manual conflict editing | Text editor integration, temporary files | File manipulation, process management |\n| Merge base detection | Version control concepts, graph algorithms | Repository integration requirements |\n\nThree-way merging builds upon two-way diffing but requires additional theoretical knowledge about merge bases, conflict categories, and resolution strategies. This complexity would double the scope of our project without proportional learning benefit for the core dynamic programming concepts.\n\n#### Performance Optimization Features\n\nAdvanced performance optimizations require profiling tools, memory management techniques, and algorithmic analysis that extend beyond the introductory scope.\n\n| Optimization | Technical Requirements | Learning Prerequisites |\n|--------------|----------------------|----------------------|\n| Memory streaming | Chunk-based processing, temporary storage | Systems programming concepts |\n| Parallel processing | Thread management, work distribution | Concurrency programming |\n| Caching systems | Hash computation, cache invalidation | Performance engineering |\n| Incremental diffing | Change detection, partial recomputation | Advanced algorithm optimization |\n\nStudents benefit more from implementing a correct, straightforward algorithm first, then learning optimization techniques in dedicated performance-focused projects. The educational value comes from understanding the algorithmic complexity and correctness, not from premature optimization.\n\n### Implementation Guidance\n\nThe scope decisions outlined above directly influence our technology choices and code organization. This guidance provides concrete recommendations for translating these goals into a working implementation.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| File I/O | Built-in file operations (`open`, `read`) | Memory-mapped files (`mmap`) |\n| Encoding Detection | Try UTF-8, fallback to Latin-1 | `chardet` library with confidence scoring |\n| CLI Parsing | Manual `sys.argv` processing | `argparse` with subcommands and validation |\n| Color Output | Simple ANSI escape sequences | `colorama` for cross-platform support |\n| Testing Framework | Built-in `unittest` module | `pytest` with fixtures and parameterization |\n\nFor learning purposes, the simple options provide direct control and understanding of the underlying operations. Students can upgrade to advanced options in later iterations once they understand the basic functionality.\n\n#### Recommended File Structure\n\nOrganizing code to match our functional goals helps maintain clear separation of concerns:\n\n```\ndiff-tool/\n├── src/\n│   ├── __init__.py\n│   ├── main.py                 # CLI entry point and argument parsing\n│   ├── file_reader.py          # File I/O and line tokenization\n│   ├── lcs_engine.py          # LCS algorithm implementation\n│   ├── diff_generator.py      # Edit script and hunk formation\n│   └── output_formatter.py    # Unified diff format generation\n├── tests/\n│   ├── test_file_reader.py    # File I/O edge cases\n│   ├── test_lcs_engine.py     # Algorithm correctness\n│   ├── test_diff_generator.py # Hunk formation logic\n│   └── test_integration.py    # End-to-end scenarios\n├── examples/\n│   ├── sample1.txt           # Test files for manual verification\n│   ├── sample2.txt\n│   └── expected_output.diff\n└── README.md                 # Usage instructions and examples\n```\n\nThis structure isolates each major component in its own module, making it easier to test individual pieces and understand the data flow between components.\n\n#### Scope Validation Checklist\n\nUse this checklist during implementation to ensure you stay within the defined scope:\n\n**Functional Goals Checklist:**\n- [ ] Reads two text files specified as command-line arguments\n- [ ] Handles UTF-8 and Latin-1 encoding automatically\n- [ ] Normalizes different line ending formats (LF, CRLF, CR)\n- [ ] Implements LCS algorithm with dynamic programming\n- [ ] Generates unified diff format output\n- [ ] Supports configurable context lines (default 3)\n- [ ] Provides colored output in terminal environments\n- [ ] Returns appropriate exit codes (0, 1, 2)\n- [ ] Includes `--help` and `--no-color` flags\n\n**Non-Goals Validation:**\n- [ ] No directory comparison features\n- [ ] No binary file processing (error with clear message)\n- [ ] No side-by-side or HTML output formats\n- [ ] No three-way merge capabilities\n- [ ] No advanced performance optimizations\n- [ ] No network or remote file access\n- [ ] No Myers' algorithm implementation\n\n#### Milestone Checkpoints\n\nEach milestone should be validated against our scope boundaries:\n\n**Milestone 1 Checkpoint (Line Tokenization):**\n```bash\n# Test basic functionality\npython src/main.py examples/sample1.txt examples/sample2.txt\n\n# Verify encoding handling\npython src/main.py utf8_file.txt latin1_file.txt\n\n# Check line ending normalization\npython src/main.py windows_file.txt unix_file.txt\n```\n\nExpected behavior: Files read successfully, line counts reported, no encoding errors for supported formats, binary files rejected with clear error message.\n\n**Milestone 2 Checkpoint (LCS Algorithm):**\n```python\n# Manual LCS verification\nfrom src.lcs_engine import LCSEngine\n\nengine = LCSEngine()\nlines1 = [\"A\", \"B\", \"C\"]\nlines2 = [\"A\", \"X\", \"C\"]\nlcs = engine.compute_lcs(lines1, lines2)\nassert lcs == [\"A\", \"C\"]  # Expected longest common subsequence\n```\n\nExpected behavior: LCS algorithm produces correct results for known inputs, handles empty files gracefully, completes in reasonable time for moderately sized files.\n\n**Milestone 3 Checkpoint (Diff Generation):**\n```bash\n# Generate diff output\npython src/main.py file1.txt file2.txt > output.diff\n\n# Verify unified format\ngrep \"^@@\" output.diff  # Should show hunk headers\ngrep \"^-\" output.diff   # Should show deletions\ngrep \"^+\" output.diff   # Should show additions\n```\n\nExpected behavior: Output follows unified diff format, hunk headers show correct line numbers, context lines appear around changes, output is compatible with patch utilities.\n\n**Milestone 4 Checkpoint (CLI and Color):**\n```bash\n# Test CLI options\npython src/main.py --help                    # Shows usage information\npython src/main.py --context 5 file1 file2  # Uses 5 context lines\npython src/main.py --no-color file1 file2   # No ANSI codes in output\n\n# Test exit codes\npython src/main.py identical1.txt identical2.txt; echo $?  # Should print 0\npython src/main.py different1.txt different2.txt; echo $?  # Should print 1\n```\n\nExpected behavior: Help text displays correctly, context option changes output, no-color flag removes ANSI codes, exit codes match file comparison results.\n\n#### Common Scope Creep Pitfalls\n\n⚠️ **Pitfall: Adding Word-Level Diffing**\nBeginning programmers often want to add word-level or character-level diffing when they see that line-level changes don't show small modifications clearly. This significantly increases algorithm complexity and output formatting requirements. Instead, focus on making the line-level algorithm robust and correct. Word-level diffing can be a follow-up project.\n\n⚠️ **Pitfall: Implementing Directory Recursion**\nThe temptation to add `diff -r` functionality is strong, but directory traversal introduces file system edge cases, symbolic link handling, and complex output organization. These concerns distract from the core algorithmic learning. Stick to two-file comparison.\n\n⚠️ **Pitfall: Premature Performance Optimization**\nStudents often worry about performance and want to add caching, parallel processing, or memory optimization before the basic algorithm works correctly. Focus on correctness first. Performance optimization requires profiling and measurement that's beyond the scope of learning dynamic programming concepts.\n\n⚠️ **Pitfall: Over-Engineering the CLI**\nRich command-line interfaces with subcommands, configuration files, and extensive options seem professional but require significant infrastructure code. Keep the CLI simple and focused on the core comparison operation. Advanced CLI features can be added in later iterations.\n\nThe key to successful scope management is recognizing when a feature request or implementation idea moves beyond the learning objectives. Ask yourself: \"Does this help me understand dynamic programming and diff algorithms better, or does it distract from that goal?\" Use that question to guide scope decisions throughout development.\n\n### Implementation Guidance\n\n#### Technology Stack Recommendations\n\n| Component | Beginner Choice | Rationale |\n|-----------|----------------|-----------|\n| Language | Python 3.8+ | Built-in file I/O, string handling, clear syntax for algorithm focus |\n| CLI Framework | `argparse` module | Standard library, sufficient for simple flag handling |\n| File I/O | Built-in `open()` with encoding parameter | Direct control over encoding, no external dependencies |\n| Testing | `unittest` module | Standard library, familiar structure, good for learning TDD |\n| Color Output | Manual ANSI escape codes | Understanding of terminal control, no dependencies |\n\n#### Essential Infrastructure Code\n\n**File Encoding Detection Helper:**\n```python\nimport codecs\n\ndef detect_file_encoding(filepath):\n    \"\"\"Detect file encoding, trying UTF-8 first, then Latin-1.\"\"\"\n    encodings = ['utf-8', 'latin-1']\n    \n    for encoding in encodings:\n        try:\n            with open(filepath, 'r', encoding=encoding) as f:\n                f.read()  # Try to read entire file\n            return encoding\n        except UnicodeDecodeError:\n            continue\n    \n    raise ValueError(f\"Could not decode {filepath} with supported encodings\")\n\ndef read_file_lines(filepath):\n    \"\"\"Read file lines with automatic encoding detection.\"\"\"\n    encoding = detect_file_encoding(filepath)\n    \n    with open(filepath, 'r', encoding=encoding, newline='') as f:\n        content = f.read()\n    \n    # Normalize line endings and split\n    content = content.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    lines = content.split('\\n')\n    \n    # Handle trailing newline consistently\n    if lines and lines[-1] == '':\n        lines.pop()\n    \n    return lines\n```\n\n**ANSI Color Helper:**\n```python\nimport sys\n\nclass ColorFormatter:\n    \"\"\"Handle colored output with automatic TTY detection.\"\"\"\n    \n    RED = '\\033[31m'\n    GREEN = '\\033[32m'\n    RESET = '\\033[0m'\n    \n    def __init__(self, use_color=None):\n        if use_color is None:\n            self.use_color = sys.stdout.isatty()\n        else:\n            self.use_color = use_color\n    \n    def red(self, text):\n        \"\"\"Format text in red for deletions.\"\"\"\n        if self.use_color:\n            return f\"{self.RED}{text}{self.RESET}\"\n        return text\n    \n    def green(self, text):\n        \"\"\"Format text in green for additions.\"\"\"\n        if self.use_color:\n            return f\"{self.GREEN}{text}{self.RESET}\"\n        return text\n```\n\n#### Core Component Skeletons\n\n**LCS Engine (for student implementation):**\n```python\nclass LCSEngine:\n    \"\"\"Implement Longest Common Subsequence using dynamic programming.\"\"\"\n    \n    def compute_lcs(self, sequence1, sequence2):\n        \"\"\"\n        Find the longest common subsequence between two sequences.\n        \n        Args:\n            sequence1: List of comparable elements (typically lines)\n            sequence2: List of comparable elements (typically lines)\n            \n        Returns:\n            List containing the longest common subsequence elements\n        \"\"\"\n        # TODO 1: Create DP table with dimensions (len(seq1)+1) x (len(seq2)+1)\n        # TODO 2: Initialize first row and column to 0\n        # TODO 3: Fill DP table using recurrence relation:\n        #         if seq1[i-1] == seq2[j-1]: dp[i][j] = dp[i-1][j-1] + 1\n        #         else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # TODO 4: Backtrack from dp[len(seq1)][len(seq2)] to recover actual LCS\n        # TODO 5: Return the LCS elements in correct order\n        \n        pass  # Student implements this\n```\n\n**Diff Generator (for student implementation):**\n```python\nclass DiffGenerator:\n    \"\"\"Convert LCS results into unified diff format hunks.\"\"\"\n    \n    def generate_diff(self, lines1, lines2, lcs, context_lines=3):\n        \"\"\"\n        Generate unified diff hunks from LCS computation.\n        \n        Args:\n            lines1: Original file lines\n            lines2: Modified file lines  \n            lcs: Longest common subsequence from LCS engine\n            context_lines: Number of context lines around changes\n            \n        Returns:\n            List of Hunk objects ready for formatting\n        \"\"\"\n        # TODO 1: Create edit script marking each line as UNCHANGED, DELETED, or ADDED\n        # TODO 2: Group consecutive changes together\n        # TODO 3: Add context lines before and after each change group\n        # TODO 4: Merge overlapping hunks when context causes overlap\n        # TODO 5: Create Hunk objects with line ranges and content\n        \n        pass  # Student implements this\n```\n\n#### Milestone Validation Commands\n\n**Milestone 1 - File Reading:**\n```bash\n# Create test files with different encodings\necho -e \"Line 1\\nLine 2\\nLine 3\" > test1.txt\necho -e \"Line 1\\nModified Line 2\\nLine 3\" > test2.txt\n\n# Test basic file reading\npython -c \"\nfrom src.file_reader import read_file_lines\nlines = read_file_lines('test1.txt')\nprint(f'Read {len(lines)} lines')\nfor i, line in enumerate(lines): print(f'{i}: {repr(line)}')\n\"\n```\n\nExpected: Clean line reading without encoding errors, proper line ending normalization.\n\n**Milestone 2 - LCS Algorithm:**  \n```bash\n# Test LCS computation with known examples\npython -c \"\nfrom src.lcs_engine import LCSEngine\nengine = LCSEngine()\n\n# Simple test case\nseq1 = ['A', 'B', 'C', 'D']\nseq2 = ['A', 'X', 'C', 'Y'] \nlcs = engine.compute_lcs(seq1, seq2)\nprint(f'LCS: {lcs}')  # Should be ['A', 'C']\n\n# Empty sequence test\nlcs_empty = engine.compute_lcs([], ['A', 'B'])\nprint(f'Empty LCS: {lcs_empty}')  # Should be []\n\"\n```\n\nExpected: Correct LCS results for known inputs, graceful handling of empty sequences.\n\n**Milestone 3 - Diff Generation:**\n```bash\n# Generate actual diff output\npython src/main.py test1.txt test2.txt\n\n# Verify unified format structure\npython src/main.py test1.txt test2.txt | head -10\n```\n\nExpected: Proper unified diff headers, hunk markers with @@ format, correct line prefixes.\n\n**Milestone 4 - CLI Interface:**\n```bash\n# Test all CLI options\npython src/main.py --help\npython src/main.py --context 1 test1.txt test2.txt\npython src/main.py --no-color test1.txt test2.txt\n\n# Verify exit codes\npython src/main.py test1.txt test1.txt; echo \"Exit code: $?\"  # Should be 0\npython src/main.py test1.txt test2.txt; echo \"Exit code: $?\"  # Should be 1\n```\n\nExpected: Help output displays, context option changes output, colors work in terminal but not in pipes, correct exit codes.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** All milestones — the component architecture forms the foundation for implementing line tokenization, LCS computation, diff generation, and CLI output\n\nThe diff tool follows a pipeline architecture where data flows through four specialized components, each with a distinct responsibility. Think of this like an assembly line in a publishing house: manuscripts arrive at the **Document Preparation** station (FileReader) where they're standardized and broken into comparable units, then move to the **Analysis** station (LCSEngine) where editors identify common content, followed by the **Editorial** station (DiffGenerator) where change instructions are created, and finally the **Publishing** station (OutputFormatter) where changes are formatted for readers.\n\nThis pipeline design provides clear separation of concerns, making each component independently testable and allowing us to swap implementations (for example, replacing the LCS algorithm with Myers' algorithm) without affecting other parts of the system. The unidirectional data flow also makes the system easier to reason about and debug — we can examine the output of each stage to isolate problems.\n\n![System Component Architecture](./diagrams/system-components.svg)\n\n### Component Overview\n\nThe diff tool architecture consists of four main components that transform input files into formatted diff output through a series of well-defined stages. Each component has a specific responsibility and interfaces with adjacent components through structured data types.\n\n#### FileReader Component\n\nThe **FileReader** serves as the entry point to our diff pipeline, responsible for converting raw file data into normalized line sequences that can be compared. This component handles the complexities of file encoding detection, line ending normalization, and memory-efficient reading of potentially large files.\n\n| Responsibility | Description | Input | Output |\n|---|---|---|---|\n| Encoding Detection | Automatically detect file encoding (UTF-8, Latin-1) | File path | Encoding identifier |\n| Line Tokenization | Split file content into individual lines | Raw file bytes | Array of line strings |\n| Normalization | Handle different line endings (LF, CRLF, CR) | Raw lines | Normalized line array |\n| Error Handling | Detect binary files and encoding failures | File system data | Error messages or success |\n\nThe FileReader abstracts away platform-specific file handling concerns, ensuring that subsequent components receive clean, predictable input regardless of the original file format. This isolation is crucial because text files can vary dramatically in encoding, line endings, and structure across different operating systems and editors.\n\n> **Decision: Line-Based Tokenization**\n> - **Context**: We need to decide the granularity of comparison — character-level, word-level, or line-level tokenization\n> - **Options Considered**: Character diff (fine-grained but noisy), word diff (semantic but complex), line diff (standard and readable)\n> - **Decision**: Line-based tokenization with optional future word-level support\n> - **Rationale**: Line-based diffs match user expectations from tools like `git diff` and `unified diff`, provide good balance between granularity and readability, and align with how developers think about code changes\n> - **Consequences**: May miss fine-grained changes within lines, but produces familiar output format that integrates well with existing tooling\n\n#### LCSEngine Component\n\nThe **LCSEngine** implements the core algorithmic logic for finding the longest common subsequence between two line arrays using dynamic programming. This component encapsulates the computational complexity of sequence alignment, providing a clean interface that hides the matrix operations and backtracking logic.\n\n| Method | Parameters | Returns | Description |\n|---|---|---|---|\n| `compute_lcs` | `sequence1: list, sequence2: list` | `CommonSubsequence` | Finds longest common subsequence using DP |\n| `build_matrix` | `lines1: list, lines2: list` | `Matrix[int]` | Constructs LCS length matrix |\n| `backtrack` | `matrix: Matrix, seq1: list, seq2: list` | `list[str]` | Recovers actual LCS from matrix |\n| `optimize_memory` | `matrix: Matrix` | `Matrix[int]` | Applies space optimization for large inputs |\n\nThe LCSEngine abstracts the mathematical complexity of dynamic programming, allowing other components to request sequence alignment without understanding matrix operations or backtracking algorithms. This separation enables us to experiment with different optimization strategies (like Hirschberg's algorithm for space efficiency) without affecting the rest of the system.\n\n> **Decision: Dynamic Programming Over Naive Comparison**\n> - **Context**: Multiple algorithms exist for finding common subsequences with different time/space trade-offs\n> - **Options Considered**: Naive O(2^n) recursive approach, memoized recursion, bottom-up dynamic programming\n> - **Decision**: Bottom-up dynamic programming with optional space optimization\n> - **Rationale**: DP provides guaranteed O(mn) time complexity, iterative approach avoids stack overflow on large inputs, and the matrix structure enables future optimizations like Myers' algorithm\n> - **Consequences**: Uses O(mn) space which can be prohibitive for very large files, but provides predictable performance and clear upgrade path to space-optimized variants\n\n#### DiffGenerator Component\n\nThe **DiffGenerator** transforms the abstract common subsequence result into concrete diff operations and organizes them into contextual hunks for human consumption. This component bridges between the mathematical result of sequence alignment and the practical needs of presenting changes in a readable format.\n\n| Operation Type | Symbol | Description | Context Requirements |\n|---|---|---|---|\n| UNCHANGED | ` ` | Lines present in both files | Forms context around changes |\n| ADDED | `+` | Lines only in second file | Grouped into hunks with context |\n| DELETED | `-` | Lines only in first file | Marked with original line numbers |\n| CONTEXT | ` ` | Surrounding unchanged lines | Configurable count (default 3) |\n\nThe DiffGenerator must solve the challenging problem of grouping individual edit operations into meaningful chunks while preserving enough context for users to understand the changes. This involves complex logic for determining hunk boundaries, handling overlapping context, and generating accurate line number ranges.\n\n> The critical insight here is that raw edit operations are too granular for human consumption — users need changes grouped into logical chunks with surrounding context to understand the intent behind modifications.\n\n#### OutputFormatter Component\n\nThe **OutputFormatter** handles the final presentation layer, converting structured diff hunks into various output formats with optional visual enhancements. This component manages the complexity of terminal capabilities, color support detection, and format compatibility with standard tools.\n\n| Format Type | Use Case | Features | Compatibility |\n|---|---|---|---|\n| Unified Diff | Standard text output | Header lines, hunk markers, line prefixes | `patch`, `git apply` |\n| Colored Terminal | Interactive viewing | ANSI color codes, TTY detection | Modern terminals |\n| Plain Text | Scripting, pipes | No color codes, clean parsing | All environments |\n| Side-by-Side | Visual comparison | Parallel columns, alignment | Wide terminals |\n\nThe OutputFormatter must handle the subtleties of terminal capabilities, ensuring that color codes appear only when appropriate and that output remains parseable by other tools when redirected to files or pipes.\n\n### Component Communication Patterns\n\nThe components communicate through well-defined interfaces that pass structured data types rather than exposing internal implementation details. This design enables testing each component in isolation and supports future enhancements without cascading changes.\n\n| Interface | Data Type | Direction | Purpose |\n|---|---|---|---|\n| FileReader → LCSEngine | `Sequence[str]` | Forward | Normalized line arrays |\n| LCSEngine → DiffGenerator | `CommonSubsequence` | Forward | Alignment result |\n| DiffGenerator → OutputFormatter | `list[Hunk]` | Forward | Structured diff hunks |\n| All Components → CLI | `Result[T, Error]` | Return | Success/failure reporting |\n\nThe unidirectional flow simplifies reasoning about data transformations and makes the system more predictable. Each component can focus on its specific responsibility without worrying about side effects or circular dependencies.\n\n### Recommended File Structure\n\nThe codebase organization reflects the component architecture, with each major component isolated in its own module to support independent development and testing. This structure helps prevent circular dependencies and makes the system easier to understand for new contributors.\n\n```\ndiff-tool/\n├── src/\n│   ├── __init__.py                 ← Package initialization\n│   ├── main.py                     ← CLI entry point and argument parsing\n│   ├── file_reader.py              ← FileReader component implementation\n│   ├── lcs_engine.py               ← LCSEngine with dynamic programming\n│   ├── diff_generator.py           ← DiffGenerator for hunk creation\n│   ├── output_formatter.py         ← OutputFormatter with color support\n│   └── types.py                    ← Shared data structures and enums\n├── tests/\n│   ├── test_file_reader.py         ← FileReader component tests\n│   ├── test_lcs_engine.py          ← LCS algorithm correctness tests  \n│   ├── test_diff_generator.py      ← Diff generation and hunk tests\n│   ├── test_output_formatter.py    ← Format and color output tests\n│   ├── test_integration.py         ← End-to-end pipeline tests\n│   └── fixtures/                   ← Test files with various encodings\n│       ├── utf8_sample.txt\n│       ├── latin1_sample.txt\n│       ├── mixed_endings.txt\n│       └── binary_file.bin\n└── README.md                       ← Usage examples and installation\n```\n\nThis structure separates concerns at the file level, making it easy to locate and modify specific functionality. The `types.py` module contains shared data structures, preventing circular imports while keeping related types together.\n\n> **Decision: Separate Module per Component**\n> - **Context**: We need to organize code to support independent development and testing of each component\n> - **Options Considered**: Single large file, functional modules, class-based components in separate files\n> - **Decision**: One module per major component with shared types module\n> - **Rationale**: Enables parallel development, simplifies testing setup, prevents circular dependencies, and makes the codebase easier to navigate for newcomers\n> - **Consequences**: More files to manage but clearer separation of responsibilities and better support for future team development\n\nThe test structure mirrors the source structure, with additional integration tests to verify the complete pipeline. The fixtures directory provides a variety of test files to validate handling of different encodings and edge cases.\n\n### Data Flow Architecture\n\nThe pipeline processes data through distinct transformation stages, with each component adding structure and semantic meaning to the information. Understanding this flow is crucial for debugging issues and optimizing performance.\n\n**Stage 1: File Input → Line Sequences**\nRaw file bytes are transformed into normalized arrays of strings, with encoding detection and line ending standardization applied. The FileReader produces clean, comparable sequences regardless of input file variations.\n\n**Stage 2: Line Sequences → Common Subsequence**  \nThe LCSEngine processes both line arrays simultaneously, building a dynamic programming matrix to identify the optimal alignment. The result identifies which lines are shared between the files and in what order.\n\n**Stage 3: Common Subsequence → Edit Operations**\nThe DiffGenerator compares the original sequences against the common subsequence to determine which lines were added, deleted, or unchanged. These operations are then grouped into hunks with appropriate context.\n\n**Stage 4: Edit Operations → Formatted Output**\nThe OutputFormatter converts the structured hunks into human-readable text, applying color formatting when appropriate and generating output compatible with standard diff tools.\n\n| Stage | Input Type | Processing | Output Type | Key Challenge |\n|---|---|---|---|---|\n| 1 | Raw bytes | Encoding + tokenization | `Sequence[str]` | Encoding detection |\n| 2 | Two sequences | Dynamic programming | `CommonSubsequence` | Memory efficiency |  \n| 3 | Sequences + LCS | Edit script generation | `list[Hunk]` | Context grouping |\n| 4 | Structured hunks | Format generation | Formatted text | Color/compatibility |\n\nThis staged approach allows us to validate data at each transformation point and provides clear interfaces for testing. Each stage adds semantic value while maintaining the information needed for subsequent processing.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Circular Dependencies Between Components**\nComponent modules importing each other creates circular dependency errors and makes testing difficult. This typically happens when components directly reference each other's implementation details rather than using shared data types. Fix by moving shared types to a separate module and ensuring unidirectional data flow.\n\n⚠️ **Pitfall: Tight Coupling Through Implementation Details**\nComponents that depend on internal implementation details of other components become fragile and hard to modify. For example, if DiffGenerator directly accesses LCSEngine's matrix rather than using the public interface, changes to the matrix representation break the diff generator. Always use well-defined interfaces and data types.\n\n⚠️ **Pitfall: Missing Error Propagation Between Components**\nErrors that occur in one component but aren't properly propagated to the CLI result in confusing failure modes where the program appears to succeed but produces incorrect output. Each component must properly handle errors from upstream components and provide meaningful error messages.\n\n⚠️ **Pitfall: Memory Accumulation Across Pipeline Stages**\nKeeping references to large intermediate data structures throughout the pipeline can cause memory usage to grow unnecessarily. For example, retaining the full LCS matrix after backtracking completes wastes space. Design components to release large intermediate data once no longer needed.\n\n### Implementation Guidance\n\nThe component architecture provides a clean foundation for implementation, with each component focused on a specific aspect of the diff computation. This guidance helps translate the architectural design into working code.\n\n#### Technology Recommendations\n\n| Component | Simple Approach | Advanced Approach | Recommendation |\n|---|---|---|---|\n| File Reading | `open()` with try/except | `chardet` library + streaming | Simple for learning |\n| LCS Computation | 2D list matrix | NumPy arrays | Simple 2D list |\n| Hunk Generation | List comprehensions | Generator functions | List comprehensions |\n| Color Output | String concatenation | `colorama` library | String concatenation |\n| CLI Parsing | `sys.argv` manually | `argparse` module | `argparse` module |\n\nFor a learning project, the simple approaches provide better understanding of the underlying concepts without external dependencies obscuring the core algorithms.\n\n#### Project Structure Setup\n\nStart by creating the directory structure and basic module files:\n\n```python\n# src/types.py\n\"\"\"Shared data structures for the diff tool pipeline.\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum\n\nclass LineType(Enum):\n    UNCHANGED = \"unchanged\"\n    ADDED = \"added\"  \n    DELETED = \"deleted\"\n\n@dataclass\nclass DiffLine:\n    content: str\n    line_type: LineType\n    old_line_num: Optional[int] = None\n    new_line_num: Optional[int] = None\n\n@dataclass  \nclass Hunk:\n    old_start: int\n    old_count: int\n    new_start: int\n    new_count: int\n    lines: List[DiffLine]\n\n@dataclass\nclass CommonSubsequence:\n    elements: List[str]\n    positions_seq1: List[int]\n    positions_seq2: List[int]\n```\n\n#### Core Component Interfaces\n\nEach component should expose a clean interface that hides implementation complexity:\n\n```python\n# src/file_reader.py\n\"\"\"File reading and line tokenization component.\"\"\"\n\ndef detect_file_encoding(filepath: str) -> str:\n    \"\"\"Determine file encoding, trying UTF-8 first, then Latin-1.\n    \n    Args:\n        filepath: Path to the file to analyze\n        \n    Returns:\n        Encoding name ('utf-8' or 'latin-1')\n        \n    Raises:\n        FileNotFoundError: If file doesn't exist\n        PermissionError: If file can't be read\n    \"\"\"\n    # TODO 1: Try to open file with UTF-8 encoding\n    # TODO 2: If UnicodeDecodeError, try Latin-1\n    # TODO 3: If both fail, raise encoding detection error\n    # TODO 4: Return successful encoding name\n    pass\n\ndef read_file_lines(filepath: str) -> List[str]:\n    \"\"\"Read file with encoding detection and line normalization.\n    \n    Args:\n        filepath: Path to the file to read\n        \n    Returns:\n        List of lines with normalized endings (no trailing \\\\n)\n        \n    Raises:\n        FileNotFoundError: If file doesn't exist\n        PermissionError: If file can't be read  \n        UnicodeDecodeError: If file encoding cannot be determined\n    \"\"\"\n    # TODO 1: Detect file encoding using detect_file_encoding()\n    # TODO 2: Open file with detected encoding\n    # TODO 3: Read all lines preserving empty lines\n    # TODO 4: Normalize line endings (remove \\\\r\\\\n, \\\\r, \\\\n)\n    # TODO 5: Return normalized line list\n    pass\n```\n\n```python\n# src/lcs_engine.py\n\"\"\"Longest Common Subsequence computation using dynamic programming.\"\"\"\n\nfrom typing import List\nfrom .types import CommonSubsequence\n\ndef compute_lcs(sequence1: List[str], sequence2: List[str]) -> CommonSubsequence:\n    \"\"\"Find longest common subsequence using dynamic programming.\n    \n    Args:\n        sequence1: First sequence (lines from file 1)\n        sequence2: Second sequence (lines from file 2)\n        \n    Returns:\n        CommonSubsequence containing the LCS and position mappings\n    \"\"\"\n    # TODO 1: Handle empty sequence edge cases\n    # TODO 2: Build LCS length matrix using dynamic programming\n    # TODO 3: Backtrack through matrix to find actual LCS elements\n    # TODO 4: Record positions in both original sequences\n    # TODO 5: Return CommonSubsequence with elements and positions\n    pass\n\ndef build_lcs_matrix(seq1: List[str], seq2: List[str]) -> List[List[int]]:\n    \"\"\"Build the LCS length matrix using dynamic programming.\n    \n    Args:\n        seq1: First sequence\n        seq2: Second sequence\n        \n    Returns:\n        2D matrix where matrix[i][j] = LCS length of seq1[:i] and seq2[:j]\n    \"\"\"\n    # TODO 1: Initialize matrix with dimensions (len(seq1)+1) x (len(seq2)+1)  \n    # TODO 2: Fill first row and column with zeros\n    # TODO 3: For each cell, if elements match: matrix[i][j] = matrix[i-1][j-1] + 1\n    # TODO 4: If elements don't match: matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1])\n    # TODO 5: Return completed matrix\n    pass\n```\n\n#### Component Integration Pattern\n\nUse a main pipeline function that coordinates the components:\n\n```python\n# src/main.py\n\"\"\"Main CLI entry point and component coordination.\"\"\"\n\nimport sys\nimport argparse\nfrom typing import Optional\n\nfrom .file_reader import read_file_lines\nfrom .lcs_engine import compute_lcs\nfrom .diff_generator import generate_diff\nfrom .output_formatter import format_unified_diff, ColorFormatter\n\ndef main():\n    \"\"\"Main entry point for diff tool CLI.\"\"\"\n    # TODO 1: Parse command line arguments (file1, file2, --context, --no-color)\n    # TODO 2: Read both files using FileReader component\n    # TODO 3: Compute LCS using LCSEngine component  \n    # TODO 4: Generate diff hunks using DiffGenerator component\n    # TODO 5: Format and output using OutputFormatter component\n    # TODO 6: Set appropriate exit code (0 if same, 1 if different)\n    pass\n\ndef create_argument_parser() -> argparse.ArgumentParser:\n    \"\"\"Create CLI argument parser with diff tool options.\"\"\"\n    # TODO 1: Create ArgumentParser with description\n    # TODO 2: Add positional arguments for file1 and file2\n    # TODO 3: Add --context option with integer argument (default 3)\n    # TODO 4: Add --no-color flag for plain text output\n    # TODO 5: Return configured parser\n    pass\n\nif __name__ == \"__main__\":\n    main()\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Line Tokenization):**\nRun `python -m src.file_reader test_file.txt` to verify file reading works correctly. You should see line count output and proper handling of different encodings. Test with UTF-8, Latin-1, and binary files to ensure encoding detection works.\n\n**After Milestone 2 (LCS Algorithm):**  \nRun `python -c \"from src.lcs_engine import compute_lcs; print(compute_lcs(['a','b','c'], ['a','c','d']))\"` to verify LCS computation. The result should show common subsequence ['a','c'] with correct position mappings.\n\n**After Milestone 3 (Diff Generation):**\nRun `python -m src.main file1.txt file2.txt` to see unified diff output. Verify that hunks are properly formed with @@ headers and correct line numbers.\n\n**After Milestone 4 (CLI and Color):**\nTest `python -m src.main file1.txt file2.txt --context 5 --no-color` to verify all CLI options work correctly. Check that colors appear in terminal but not when redirected to a file.\n\n#### Language-Specific Implementation Notes\n\n**Python File Handling:**\n- Use `open(filepath, 'r', encoding=encoding)` for text files\n- Handle `UnicodeDecodeError` when trying different encodings  \n- Use `str.splitlines(keepends=False)` to normalize line endings\n- Check `sys.stdout.isatty()` for TTY detection\n\n**Python Data Structures:**\n- Use `List[List[int]]` for the LCS matrix (simple and clear)\n- Use `dataclasses` for structured types like `Hunk` and `DiffLine`\n- Use `typing.Optional` for fields that may be None\n- Use `enum.Enum` for constants like line types and colors\n\n**Python Testing:**\n- Use `unittest` module for component tests\n- Create fixtures in `tests/fixtures/` directory\n- Use `tempfile` module for creating test files\n- Mock file system errors using `unittest.mock`\n\nThis implementation guidance provides the scaffolding for building the diff tool while leaving the core algorithmic challenges for the learner to solve. The clear separation of components makes testing straightforward and debugging manageable.\n\n\n## Data Model\n\n> **Milestone(s):** All milestones — the data model forms the foundation that connects line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)\n\nThe data model serves as the architectural backbone of our diff tool, defining how information flows from raw file content through algorithmic processing to formatted output. Think of the data model as the **vocabulary and grammar** of our diff system — just as human language needs nouns, verbs, and sentence structures to convey meaning, our diff tool needs well-defined types and relationships to represent files, changes, and output formats.\n\nUnderstanding the data model is crucial because it determines how each component communicates with others. A poorly designed data model leads to awkward conversions, performance bottlenecks, and maintenance headaches. Our design prioritizes clarity and efficiency, ensuring that data transformations feel natural and that the types directly reflect the problem domain.\n\n![Data Model Relationships](./diagrams/data-model.svg)\n\nThe mental model for our data structures follows the **document comparison workflow**: we start with raw files, break them into comparable units (lines), find commonalities and differences, group related changes together, and finally format them for human consumption. Each data structure represents a specific stage in this transformation pipeline.\n\n### Core Types and Structures\n\nOur data model consists of four primary structures that represent different abstraction levels in the diff process. Each structure encapsulates specific responsibilities and provides a clean interface for the components that manipulate it.\n\n#### FileContent Structure\n\nThe `FileContent` structure represents the parsed and normalized content of a single input file. This is the first structured representation we create from raw file data, serving as the foundation for all subsequent processing.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `filepath` | `str` | Original file path for error reporting and output headers |\n| `lines` | `list[str]` | Normalized lines with consistent line endings removed |\n| `line_count` | `int` | Total number of lines including empty lines |\n| `encoding` | `str` | Detected encoding used to read the file (UTF-8, Latin-1) |\n| `original_endings` | `str` | Original line ending type detected (LF, CRLF, CR) for preservation |\n\nThe `FileContent` structure encapsulates the preprocessing decisions made during file reading. By storing the original encoding and line endings, we preserve information that might be needed for error reporting or round-trip compatibility. The normalized `lines` array provides a clean interface for comparison algorithms while maintaining traceability to the original file structure.\n\n> **Design Insight**: Separating file metadata from content allows components to work with clean line arrays while preserving the ability to generate accurate error messages and output headers that reference original file characteristics.\n\n#### DiffLine Structure\n\nThe `DiffLine` structure represents a single line in the final diff output, combining content with presentation metadata. This structure bridges the gap between algorithmic results and formatted output.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `content` | `str` | The actual line text without diff prefixes or formatting |\n| `line_type` | `LineType` | Classification as UNCHANGED, ADDED, or DELETED |\n| `old_line_num` | `Optional[int]` | Line number in original file (None for ADDED lines) |\n| `new_line_num` | `Optional[int]` | Line number in modified file (None for DELETED lines) |\n\nThe dual line numbering system enables generation of accurate unified diff headers while supporting other output formats. The optional nature of line numbers reflects the logical reality that added lines don't exist in the original file and deleted lines don't exist in the modified file.\n\n#### LineType Enumeration\n\nThe `LineType` enumeration provides a clear classification system for diff operations, avoiding magic strings or numeric codes that could lead to confusion.\n\n| Enum Value | Description | Unified Diff Prefix |\n|------------|-------------|-------------------|\n| `UNCHANGED` | Line exists in both files with identical content | ` ` (space) |\n| `ADDED` | Line exists only in the new file | `+` |\n| `DELETED` | Line exists only in the old file | `-` |\n\n> **Decision: Explicit LineType Enumeration**\n> - **Context**: Need to classify lines for diff output formatting\n> - **Options Considered**: String constants (\"added\", \"deleted\"), integer codes (0, 1, 2), enumeration\n> - **Decision**: Use explicit enumeration with descriptive names\n> - **Rationale**: Type safety prevents invalid values, IDE autocompletion reduces errors, self-documenting code\n> - **Consequences**: Slightly more verbose than strings but eliminates entire class of typo bugs\n\n#### Hunk Structure\n\nThe `Hunk` structure represents a group of consecutive changes along with surrounding context lines. This is the fundamental unit of diff output, corresponding to the sections marked with `@@` headers in unified diff format.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `old_start` | `int` | Starting line number in original file (1-indexed for diff format) |\n| `old_count` | `int` | Number of lines from original file included in this hunk |\n| `new_start` | `int` | Starting line number in modified file (1-indexed for diff format) |\n| `new_count` | `int` | Number of lines from modified file included in this hunk |\n| `lines` | `list[DiffLine]` | All lines in this hunk including context and changes |\n| `context_before` | `int` | Number of context lines before first change |\n| `context_after` | `int` | Number of context lines after last change |\n\nThe hunk structure encapsulates both the logical grouping of changes and the metadata needed to generate proper unified diff headers. The context tracking enables intelligent hunk merging when changes are close together.\n\n> **Design Insight**: Storing context line counts separately from the line array enables algorithms to distinguish between context and actual changes without scanning the entire line list.\n\n#### CommonSubsequence Structure\n\nThe `CommonSubsequence` structure represents the result of LCS computation, containing both the matching elements and metadata about the comparison process.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `elements` | `list[str]` | The actual longest common subsequence of lines |\n| `length` | `int` | Length of the common subsequence for quick access |\n| `positions1` | `list[int]` | Indices of LCS elements in the first sequence |\n| `positions2` | `list[int]` | Indices of LCS elements in the second sequence |\n\nThe position arrays enable efficient conversion from LCS results to edit operations without re-scanning the input sequences. This design trades memory for computational efficiency, a worthwhile exchange given that diff operations are typically performed once per file pair.\n\n#### EditDistance Structure\n\nThe `EditDistance` structure captures metrics about the differences between two files, useful for summary reporting and algorithm validation.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `insertions` | `int` | Number of lines added in the new file |\n| `deletions` | `int` | Number of lines removed from the old file |\n| `unchanged` | `int` | Number of lines that remain identical |\n| `total_operations` | `int` | Sum of insertions and deletions (Levenshtein distance) |\n\nThis structure provides quick access to diff statistics without requiring traversal of the entire diff output. It supports both user-facing summary information and internal algorithm validation.\n\n### Type Relationships\n\nThe data structures form a **transformation pipeline** where each type represents a different level of abstraction and processing. Understanding these relationships is crucial for implementing the component interfaces correctly.\n\n#### File Processing Flow\n\nThe transformation begins with raw file data and progresses through increasingly structured representations:\n\n1. **Raw File Data** → `FileContent`: The file reader component processes binary file content, detects encoding, normalizes line endings, and splits into line arrays. This transformation handles the messiness of real-world files and produces clean input for algorithms.\n\n2. **FileContent Pairs** → `CommonSubsequence`: The LCS engine takes two `FileContent` structures and produces a `CommonSubsequence` representing the optimal alignment. This is where the core algorithmic work happens, using dynamic programming to find the longest matching sequence.\n\n3. **CommonSubsequence** + **FileContent Pairs** → **Edit Operations**: The diff generator combines the LCS result with the original file contents to produce a sequence of edit operations. This step determines which lines are insertions, deletions, or unchanged content.\n\n4. **Edit Operations** → `Hunk` **List**: The diff generator groups consecutive changes into hunks, adding configurable context lines around each change group. This transformation makes the diff human-readable by providing surrounding context.\n\n5. **Hunk List** → **Formatted Output**: The output formatter takes the structured hunk representation and generates the final diff format, whether unified diff, colored terminal output, or other presentation formats.\n\n#### Data Flow Dependencies\n\nThe type relationships create specific dependency requirements that influence component design:\n\n| Source Type | Target Type | Transformation Component | Key Operations |\n|-------------|-------------|------------------------|----------------|\n| Raw bytes | `FileContent` | FileReader | Encoding detection, line splitting, normalization |\n| `FileContent` × 2 | `CommonSubsequence` | LCSEngine | Dynamic programming matrix computation |\n| `CommonSubsequence` + `FileContent` × 2 | `list[DiffLine]` | DiffGenerator | Edit script generation, line classification |\n| `list[DiffLine]` | `list[Hunk]` | DiffGenerator | Context addition, hunk boundary detection |\n| `list[Hunk]` | Formatted output | OutputFormatter | Unified diff formatting, color application |\n\n#### Memory and Performance Implications\n\nThe type relationships have important implications for memory usage and performance characteristics:\n\n**Memory Growth Pattern**: Each transformation step typically increases memory usage as we add metadata and structure to the raw content. The peak memory usage occurs during hunk generation when we hold both the original file contents and the complete diff structure simultaneously.\n\n**Processing Efficiency**: The position arrays in `CommonSubsequence` eliminate the need for repeated searches during edit script generation. Similarly, storing line numbers in `DiffLine` avoids recalculation during output formatting.\n\n**Streaming Opportunities**: While the current design loads entire files into memory, the type structure supports future streaming implementations. The `Hunk` structure could be generated and output incrementally for large files.\n\n#### Error Propagation Through Types\n\nEach type transformation introduces potential failure modes that must be handled gracefully:\n\n| Transformation | Potential Failures | Error Information Preserved |\n|----------------|-------------------|----------------------------|\n| Bytes → `FileContent` | Encoding errors, I/O failures | Original filepath, detected encoding |\n| `FileContent` → `CommonSubsequence` | Memory exhaustion | File sizes, available memory |\n| `CommonSubsequence` → Edit operations | Logic errors in backtracking | LCS length, sequence lengths |\n| Edit operations → `Hunk` | Configuration errors | Context line settings, hunk boundaries |\n\nThe data model preserves enough context information to generate meaningful error messages that help users diagnose problems with their input files or configuration.\n\n### Architecture Decision Records\n\n> **Decision: Separate Line Content from Metadata**\n> - **Context**: Need to represent lines in diff output with various metadata (line numbers, change type, formatting)\n> - **Options Considered**: Store everything in strings with prefixes, use tuples, create structured DiffLine type\n> - **Decision**: Create structured `DiffLine` type with separate content and metadata fields\n> - **Rationale**: Enables clean separation between algorithmic processing (works on content) and presentation (uses metadata), supports multiple output formats without re-parsing\n> - **Consequences**: Slightly higher memory usage but eliminates string parsing and enables type-safe metadata access\n\n> **Decision: Position Arrays in CommonSubsequence**\n> - **Context**: Need to convert LCS results into edit operations efficiently\n> - **Options Considered**: Store only the LCS elements, include position information, use iterator-based approach\n> - **Decision**: Include position arrays mapping LCS elements back to original sequences\n> - **Rationale**: Eliminates O(n²) search during edit script generation, enables parallel processing of multiple LCS results\n> - **Consequences**: Higher memory usage but significantly faster diff generation for large files\n\n> **Decision: Context Metadata in Hunk Structure**\n> - **Context**: Need to distinguish between actual changes and context lines within hunks\n> - **Options Considered**: Mark context lines in DiffLine type, store context counts in Hunk, compute context dynamically\n> - **Decision**: Store context counts as separate fields in Hunk structure\n> - **Rationale**: Enables hunk merging algorithms without scanning line arrays, supports configurable context without re-processing\n> - **Consequences**: Small amount of redundant information but significantly cleaner hunk manipulation code\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Mixing Zero-Based and One-Based Indexing**\nThe internal algorithms use zero-based indexing for array access, but unified diff format requires one-based line numbers. Mixing these conventions leads to off-by-one errors in output. Always convert to one-based indexing only in the final formatting stage, and document which fields use which convention.\n\n⚠️ **Pitfall: Forgetting Optional Line Numbers**\n`DiffLine` uses optional line numbers because added lines don't exist in the original file and deleted lines don't exist in the new file. Code that assumes line numbers are always present will crash on these cases. Always check for `None` before using line numbers or provide sensible defaults for display.\n\n⚠️ **Pitfall: Immutable vs Mutable Structures**\nThe data structures are designed to be immutable after creation to prevent accidental modification during processing. Code that tries to modify structures in-place (like changing `line_type` after creation) violates this design and can lead to inconsistent state. Create new instances rather than modifying existing ones.\n\n⚠️ **Pitfall: Context Line Double-Counting**\nWhen generating hunks, it's easy to double-count context lines that appear in multiple hunks or include context lines in the change counts. The `old_count` and `new_count` fields should include context lines, while the separate context counters track how many lines are context versus actual changes.\n\n⚠️ **Pitfall: Encoding Information Loss**\nThe `FileContent` structure preserves original encoding information, but it's easy to lose this during processing and end up with encoding errors in output. Always propagate encoding information through the pipeline and use it when generating error messages or file headers.\n\n### Implementation Guidance\n\nThe data model implementation focuses on creating clean, type-safe structures that guide correct usage and prevent common mistakes. The design emphasizes immutability and clear ownership to support both single-threaded and potential future multi-threaded implementations.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Type Definitions | `dataclass` with frozen=True | `pydantic` models with validation |\n| Enumerations | `enum.Enum` with string values | `enum.Enum` with custom methods |\n| Optional Types | `typing.Optional` for clarity | `typing.Union` with None |\n| Collections | Built-in `list` and `dict` | `typing.NamedTuple` for small structures |\n\n#### Recommended File Structure\n\n```\ndiff_tool/\n  models/\n    __init__.py              ← export all public types\n    file_content.py          ← FileContent and related types\n    diff_line.py            ← DiffLine and LineType enum\n    hunk.py                 ← Hunk structure and hunk-related logic\n    lcs_types.py            ← CommonSubsequence and EditDistance\n  tests/\n    test_models/\n      test_file_content.py   ← test file content creation and validation\n      test_diff_line.py      ← test line type behavior and formatting\n      test_hunk.py          ← test hunk creation and manipulation\n```\n\n#### Core Type Definitions\n\n```python\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List, Optional\n\n@dataclass(frozen=True)\nclass FileContent:\n    \"\"\"Represents processed file content ready for comparison.\"\"\"\n    filepath: str\n    lines: List[str]\n    line_count: int\n    encoding: str\n    original_endings: str\n    \n    def __post_init__(self):\n        # TODO: Validate that line_count matches len(lines)\n        # TODO: Validate that encoding is supported ('utf-8', 'latin-1')\n        # TODO: Validate that original_endings is valid ('LF', 'CRLF', 'CR')\n        pass\n\nclass LineType(Enum):\n    \"\"\"Classification of lines in diff output.\"\"\"\n    UNCHANGED = \"unchanged\"\n    ADDED = \"added\" \n    DELETED = \"deleted\"\n    \n    def to_diff_prefix(self) -> str:\n        \"\"\"Convert to unified diff prefix character.\"\"\"\n        # TODO: Return ' ' for UNCHANGED\n        # TODO: Return '+' for ADDED\n        # TODO: Return '-' for DELETED\n        pass\n\n@dataclass(frozen=True)\nclass DiffLine:\n    \"\"\"Single line in diff output with metadata.\"\"\"\n    content: str\n    line_type: LineType\n    old_line_num: Optional[int]\n    new_line_num: Optional[int]\n    \n    def __post_init__(self):\n        # TODO: Validate that ADDED lines have old_line_num = None\n        # TODO: Validate that DELETED lines have new_line_num = None  \n        # TODO: Validate that UNCHANGED lines have both line numbers\n        pass\n\n@dataclass(frozen=True)\nclass CommonSubsequence:\n    \"\"\"Result of LCS computation with position tracking.\"\"\"\n    elements: List[str]\n    length: int\n    positions1: List[int]\n    positions2: List[int]\n    \n    def __post_init__(self):\n        # TODO: Validate that length == len(elements)\n        # TODO: Validate that len(positions1) == len(positions2) == length\n        # TODO: Validate that positions are in ascending order\n        pass\n\n@dataclass(frozen=True)  \nclass Hunk:\n    \"\"\"Group of consecutive changes with context.\"\"\"\n    old_start: int\n    old_count: int\n    new_start: int\n    new_count: int\n    lines: List[DiffLine]\n    context_before: int\n    context_after: int\n    \n    def format_header(self) -> str:\n        \"\"\"Generate unified diff hunk header.\"\"\"\n        # TODO: Format as \"@@ -old_start,old_count +new_start,new_count @@\"\n        # TODO: Handle special case where count is 1 (omit count in header)\n        # TODO: Ensure line numbers are 1-indexed for output\n        pass\n\n@dataclass(frozen=True)\nclass EditDistance:\n    \"\"\"Metrics about differences between files.\"\"\"\n    insertions: int\n    deletions: int\n    unchanged: int\n    total_operations: int\n    \n    @classmethod\n    def from_diff_lines(cls, lines: List[DiffLine]) -> 'EditDistance':\n        \"\"\"Compute edit distance metrics from diff output.\"\"\"\n        # TODO: Count lines by LineType\n        # TODO: Calculate total_operations as insertions + deletions\n        # TODO: Validate that counts are non-negative\n        pass\n```\n\n#### Helper Functions\n\n```python\ndef create_file_content(filepath: str, raw_content: bytes, encoding: str, \n                       line_ending: str) -> FileContent:\n    \"\"\"Factory function for FileContent creation with validation.\"\"\"\n    # TODO: Decode raw_content using specified encoding\n    # TODO: Split content into lines preserving empty lines\n    # TODO: Normalize line endings to \\n for internal processing\n    # TODO: Count total lines including final empty line if present\n    # TODO: Return FileContent with all fields populated\n    pass\n\ndef merge_hunks(hunk1: Hunk, hunk2: Hunk, max_gap: int = 3) -> Optional[Hunk]:\n    \"\"\"Merge two adjacent hunks if they're close enough.\"\"\"\n    # TODO: Check if hunks are adjacent (gap <= max_gap)\n    # TODO: Combine line arrays with bridging context\n    # TODO: Recalculate hunk boundaries and counts\n    # TODO: Return merged hunk or None if unmergeable\n    pass\n\ndef validate_hunk_consistency(hunk: Hunk) -> bool:\n    \"\"\"Verify that hunk line counts match actual line content.\"\"\"\n    # TODO: Count UNCHANGED and DELETED lines, verify equals old_count\n    # TODO: Count UNCHANGED and ADDED lines, verify equals new_count  \n    # TODO: Check that context counts don't exceed total lines\n    # TODO: Verify that line numbers are consecutive within each file\n    pass\n```\n\n#### Type Conversion Utilities\n\n```python\ndef diff_lines_to_hunks(lines: List[DiffLine], context_lines: int = 3) -> List[Hunk]:\n    \"\"\"Convert flat diff line list to structured hunks with context.\"\"\"\n    # TODO: Identify change boundaries (sequences of ADDED/DELETED lines)\n    # TODO: Add context_lines before and after each change group  \n    # TODO: Merge hunks that overlap due to context\n    # TODO: Calculate correct line numbers and counts for each hunk\n    # TODO: Return list of Hunk objects ready for formatting\n    pass\n\ndef lcs_to_edit_operations(lcs: CommonSubsequence, file1: FileContent, \n                          file2: FileContent) -> List[DiffLine]:\n    \"\"\"Convert LCS result to sequence of edit operations.\"\"\"\n    # TODO: Walk through both files using LCS positions as anchors\n    # TODO: Lines in LCS become UNCHANGED DiffLines\n    # TODO: Lines in file1 not in LCS become DELETED DiffLines\n    # TODO: Lines in file2 not in LCS become ADDED DiffLines\n    # TODO: Assign correct line numbers from original files\n    pass\n```\n\n#### Milestone Checkpoints\n\n**After implementing basic types:**\n- Run `python -m pytest tests/test_models/` — all type creation and validation tests should pass\n- Create sample `FileContent` objects — verify encoding and line count are correct\n- Test `LineType` enum — verify `to_diff_prefix()` returns correct characters\n- Check immutability — attempting to modify frozen dataclass fields should raise `FrozenInstanceError`\n\n**After implementing conversion functions:**\n- Test `create_file_content()` with files containing different line endings — should normalize internally but preserve original format metadata\n- Test `diff_lines_to_hunks()` with sample edit sequences — verify context lines and hunk boundaries are correct\n- Verify hunk merging logic — adjacent hunks within context distance should merge, distant hunks should remain separate\n\n**After implementing validation:**\n- Test edge cases: empty files, files with only additions/deletions, files with no common lines\n- Verify error handling: invalid encodings, inconsistent line counts, malformed hunk data\n- Check memory usage with large files — data structures should scale linearly with file size\n\nSigns of correct implementation:\n- Type constructors reject invalid combinations (e.g., ADDED line with old_line_num set)\n- Conversion between types preserves information (round-trip testing)\n- Hunk generation produces output compatible with standard diff tools\n- Memory usage grows predictably with input size\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Off-by-one errors in diff output | Mixing zero-based and one-based indexing | Print line numbers at each conversion step | Use zero-based internally, convert to one-based only for output |\n| Missing lines in hunks | Incorrect context line calculation | Check `context_before` and `context_after` values | Ensure context doesn't exceed file boundaries |\n| Hunk merge failures | Overlapping context not detected | Log hunk boundaries before merge attempts | Fix gap calculation to account for context overlap |\n| Type validation errors | Invalid field combinations | Enable dataclass validation in `__post_init__` | Add comprehensive validation for all field constraints |\n| Memory errors with large files | Storing redundant data | Profile memory usage by component | Consider streaming or lazy evaluation for large files |\n\n\n## File Reader Component\n\n> **Milestone(s):** Milestone 1: Line Tokenization — handles file reading, encoding detection, line splitting, and text normalization that forms the foundation for all subsequent comparison operations\n\nThe File Reader Component serves as the entry point to our diff tool, responsible for transforming raw file data into structured, comparable sequences of lines. This component must handle the messy realities of text files while providing clean, normalized input to downstream components.\n\n### Mental Model: Document Preparation\n\nThink of the File Reader Component like a librarian preparing two historical manuscripts for scholarly comparison. Before scholars can analyze differences in content, the librarian must first standardize the physical presentation: ensuring both documents use the same character encoding (like translating from different alphabets to a common script), normalizing page breaks and line endings (like converting scrolls and bound books to the same format), and cataloging each line with consistent numbering. Just as manuscripts might use different writing systems, line spacing, or organizational structures, text files arrive with varying encodings, line endings, and formatting conventions that must be reconciled before meaningful comparison can begin.\n\nThe librarian's careful preparation work — though invisible to the final scholarly analysis — determines whether the comparison will be accurate and meaningful. Similarly, our File Reader Component performs the crucial but often overlooked work of transforming arbitrary text files into clean, comparable data structures that enable accurate diff computation.\n\n![File Processing State Machine](./diagrams/file-processing-states.svg)\n\nThe component operates as a state machine, progressing through distinct phases: initial file discovery, encoding detection, content reading, line tokenization, and normalization. Each state transition represents a validation checkpoint where errors can be detected and handled gracefully.\n\n### Encoding Detection and Handling\n\nText encoding represents one of the most complex challenges in file processing, as files rarely declare their encoding explicitly. The component must make intelligent decisions about how to interpret byte sequences while providing fallback strategies when detection fails.\n\n> **Decision: UTF-8 First, Latin-1 Fallback Strategy**\n> - **Context**: Files can use dozens of different encodings, but detection libraries are complex dependencies that may not be available in all target languages. Many diff tools fail entirely on encoding mismatches.\n> - **Options Considered**: \n>   1. Require explicit encoding specification via command-line flags\n>   2. Use comprehensive encoding detection library (chardet/uchardet)\n>   3. Try UTF-8 first, fallback to Latin-1, fail on other encodings\n> - **Decision**: Implement UTF-8-first with Latin-1 fallback strategy\n> - **Rationale**: UTF-8 handles 90%+ of modern text files and is backward-compatible with ASCII. Latin-1 can represent any byte sequence without errors, providing a universal fallback. This covers the vast majority of real-world scenarios while keeping dependencies minimal.\n> - **Consequences**: Enables robust handling of common encodings while maintaining simplicity. May misinterpret files using other encodings (like Shift-JIS or UTF-16), but these represent edge cases for a learning project.\n\nThe encoding detection process follows a systematic approach designed to maximize success while minimizing complexity:\n\n1. **UTF-8 Validation Attempt**: Read the entire file as bytes and attempt UTF-8 decoding. UTF-8 has strict byte sequence rules, so invalid sequences will trigger decode errors immediately.\n\n2. **Latin-1 Fallback**: If UTF-8 decoding fails, retry with Latin-1 encoding. Latin-1 assigns meaning to every possible byte value (0-255), so this step cannot fail.\n\n3. **Binary File Detection**: During encoding attempts, detect likely binary files by scanning for null bytes or high percentages of non-printable characters. Binary files should be rejected early with clear error messages.\n\n4. **Encoding Metadata Preservation**: Store the detected encoding in the `FileContent` structure for debugging and potential future use in output formatting.\n\n| Detection Step | Trigger Condition | Action Taken | Error Handling |\n|---|---|---|---|\n| UTF-8 Attempt | Initial file read | Decode entire file as UTF-8 | UnicodeDecodeError → proceed to fallback |\n| Binary Detection | During UTF-8 attempt | Scan for null bytes, control chars | Reject with \"binary file\" error |\n| Latin-1 Fallback | UTF-8 decode failure | Re-read file with Latin-1 | Cannot fail (covers all byte values) |\n| Success Recording | Successful decode | Store encoding in FileContent | None |\n\n> **Critical Insight**: The encoding detection strategy prioritizes predictable behavior over perfect accuracy. It's better to consistently handle 95% of files correctly than to sometimes handle 100% of files but fail unpredictably on edge cases.\n\n### Line Normalization\n\nOnce file content is successfully decoded to Unicode strings, the component must address the complexities of line ending conventions and whitespace handling. Different operating systems, text editors, and historical contexts have produced a variety of line ending formats that must be reconciled for accurate comparison.\n\nThe normalization process preserves the logical structure of the file while standardizing physical representation details that should not affect diff computation. This requires careful balance between normalization and preservation — we want to eliminate spurious differences while maintaining meaningful distinctions.\n\n#### Line Ending Standardization\n\nLine endings present a classic compatibility challenge in text processing. The component must detect and normalize different line ending conventions while preserving the original format information for potential restoration.\n\n| Line Ending Type | Byte Sequence | Origin | Detection Strategy |\n|---|---|---|---|\n| Unix LF | `\\n` (0x0A) | Unix, Linux, macOS | Single byte 0x0A |\n| Windows CRLF | `\\r\\n` (0x0D 0x0A) | Windows, DOS | Two-byte sequence, must check \\r\\n together |\n| Classic Mac CR | `\\r` (0x0D) | Pre-OSX Mac | Single byte 0x0D not followed by 0x0A |\n| Mixed Endings | Various combinations | Corrupted or manually edited files | Count each type, report inconsistency |\n\nThe normalization algorithm processes line endings in a specific order to avoid misdetection:\n\n1. **CRLF Detection First**: Scan for `\\r\\n` sequences and replace with internal line separator markers. This must happen before individual `\\r` or `\\n` processing to avoid splitting CRLF pairs.\n\n2. **Individual CR/LF Processing**: After CRLF removal, remaining `\\r` or `\\n` characters represent Mac or Unix line endings respectively.\n\n3. **Consistency Validation**: Track the types of line endings found and warn if multiple types appear in the same file, as this often indicates file corruption or manual editing errors.\n\n4. **Original Format Preservation**: Store the detected line ending type in `FileContent.original_endings` for potential use in output formatting or debugging.\n\n#### Whitespace and Empty Line Handling\n\nWhitespace handling requires nuanced decisions about what constitutes meaningful content versus formatting artifacts. The component must preserve structural elements like empty lines while potentially normalizing trailing whitespace that rarely carries semantic meaning.\n\n> **Decision: Preserve Empty Lines, Optional Trailing Whitespace Normalization**\n> - **Context**: Empty lines often carry semantic meaning (paragraph breaks, logical sections), but trailing whitespace is usually incidental formatting that creates spurious diff noise.\n> - **Options Considered**:\n>   1. Preserve all whitespace exactly as found in files\n>   2. Strip all trailing whitespace from every line\n>   3. Configurable whitespace normalization with sensible defaults\n> - **Decision**: Always preserve empty lines, provide optional trailing whitespace normalization (default: enabled)\n> - **Rationale**: Empty lines structure documents and should be preserved for meaningful diffs. Trailing whitespace rarely carries meaning and often creates noise when files are edited with different editors. Making it configurable allows power users to override when needed.\n> - **Consequences**: Reduces spurious whitespace diffs while maintaining document structure. May occasionally hide meaningful trailing whitespace, but this represents an edge case.\n\nThe whitespace normalization process operates on each line individually after line ending processing:\n\n1. **Empty Line Preservation**: Lines containing only whitespace are preserved as truly empty lines (`\"\"`) to maintain document structure.\n\n2. **Trailing Whitespace Handling**: Based on configuration, either preserve or strip whitespace from the end of non-empty lines.\n\n3. **Leading Whitespace Preservation**: Always preserve leading whitespace as it commonly carries meaning (indentation, alignment).\n\n4. **Tab/Space Normalization**: Preserve tabs and spaces exactly as found, as the choice between them often carries semantic meaning or project-specific conventions.\n\n| Whitespace Type | Handling Strategy | Rationale |\n|---|---|---|\n| Leading spaces/tabs | Always preserve | Carries semantic meaning (indentation) |\n| Trailing spaces/tabs | Configurable strip (default: remove) | Usually formatting artifacts |\n| Empty lines (whitespace-only) | Convert to truly empty | Preserves structure, eliminates noise |\n| Internal spaces/tabs | Always preserve | Part of content, never normalize |\n\n### Common Pitfalls\n\nThe File Reader Component encounters several categories of errors that can cascade into confusing failures in downstream components. Understanding these pitfalls helps implementers build robust error handling and provide clear diagnostic messages.\n\n#### ⚠️ **Pitfall: Binary File Encoding Explosion**\n\n**Problem**: Attempting to decode binary files (executables, images, compressed archives) as text causes encoding errors that propagate through the entire diff pipeline, often manifesting as cryptic Unicode exceptions far from the actual problem.\n\n**Why It Happens**: Binary files contain byte sequences that violate UTF-8 encoding rules or produce invalid Unicode code points. When these sequences reach the LCS algorithm, they can cause comparison failures or generate nonsensical diff output.\n\n**Detection Strategy**: Scan file content during encoding detection for binary indicators: null bytes (`\\0`), high percentages of non-printable characters, or known binary file signatures (magic numbers).\n\n**Prevention**: Implement binary detection early in the encoding process and fail fast with clear error messages like \"Cannot diff binary file: detected null bytes at position X\".\n\n#### ⚠️ **Pitfall: Memory Exhaustion on Large Files**\n\n**Problem**: Loading entire large files into memory for line processing can exhaust available RAM, causing the process to crash or swap heavily, especially when processing log files or data dumps.\n\n**Why It Happens**: The naive approach reads the complete file content into a string, then splits into lines, temporarily holding both the original content and the line array in memory simultaneously.\n\n**Detection Strategy**: Monitor file sizes during initial file stat operations and warn when files exceed reasonable thresholds (e.g., 100MB).\n\n**Mitigation**: Implement streaming line reading that processes files incrementally, or provide configuration options for memory limits with clear error messages when exceeded.\n\n#### ⚠️ **Pitfall: Trailing Newline Inconsistency**\n\n**Problem**: Different text editors handle final newlines inconsistently — some always add a trailing newline, others preserve files exactly as edited. This creates spurious diffs where files differ only in their final newline presence.\n\n**Why It Happens**: POSIX defines text files as sequences of lines where each line ends with a newline, but many editors don't enforce this. When one file ends with a newline and another doesn't, the line count differs, causing alignment issues in the LCS algorithm.\n\n**Detection Strategy**: Check whether file content ends with a line ending sequence and track this information separately from line content.\n\n**Handling Options**: Either normalize by always ensuring a final newline, or preserve the distinction but mark it clearly in diff output with messages like \"No newline at end of file\".\n\n#### ⚠️ **Pitfall: Line Ending Mixed Mode Corruption**\n\n**Problem**: Files containing mixed line endings (some lines end with LF, others with CRLF) can indicate file corruption or editing across different systems. Naive splitting creates inconsistent line parsing where some lines retain carriage returns.\n\n**Why It Happens**: Files transferred between systems without proper conversion, or edited with tools that don't normalize line endings consistently.\n\n**Detection Strategy**: Count occurrences of each line ending type during normalization and flag files with multiple types.\n\n**Resolution**: Provide clear warnings about mixed line endings and document the normalization strategy used, allowing users to fix their files if needed.\n\n| Error Category | Early Detection Signal | Recommended Response |\n|---|---|---|\n| Binary files | Null bytes, high non-printable ratio | Fail fast with clear error message |\n| Large files | File size > memory threshold | Warn user, implement streaming if possible |\n| Encoding failures | UnicodeDecodeError in both UTF-8 and Latin-1 | Report unsupported encoding, suggest alternatives |\n| Mixed line endings | Multiple line ending types detected | Warn user, document normalization applied |\n| Trailing newline inconsistency | One file ends with newline, other doesn't | Mark in diff output, consider normalization option |\n\n### Implementation Guidance\n\nThe File Reader Component bridges the gap between raw file system operations and the structured data required for diff computation. The implementation must balance robust error handling with clean abstractions that hide complexity from downstream components.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| File I/O | Built-in file operations (`open`, `read`) | Memory-mapped files for large file optimization |\n| Encoding Detection | Try UTF-8, fallback to Latin-1 | `chardet`/`uchardet` library for comprehensive detection |\n| Line Splitting | String `split` with line ending normalization | Streaming line reader with configurable buffers |\n| Error Handling | Exception propagation with context | Structured error types with recovery suggestions |\n\n#### Recommended File Structure\n\n```\ndiff-tool/\n  src/\n    file_reader/\n      __init__.py              ← Component interface\n      reader.py                ← Core FileReader class  \n      encoding.py              ← Encoding detection utilities\n      normalization.py         ← Line ending and whitespace handling\n      errors.py                ← File reading error types\n    tests/\n      test_file_reader.py      ← Comprehensive test suite\n      fixtures/                ← Test files with various encodings\n        utf8_unix.txt\n        latin1_windows.txt\n        binary_file.exe\n        mixed_endings.txt\n```\n\n#### Core Data Structures\n\nThe File Reader Component works primarily with the `FileContent` structure that encapsulates all information needed for downstream processing:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n@dataclass\nclass FileContent:\n    \"\"\"Complete representation of a file prepared for diff processing.\"\"\"\n    filepath: str                    # Original file path for error reporting\n    lines: List[str]                # Normalized line content (no line endings)\n    line_count: int                 # Total number of lines for validation\n    encoding: str                   # Detected encoding (utf-8 or latin-1)\n    original_endings: str           # Original line ending style (LF/CRLF/CR/mixed)\n\ndef create_file_content(filepath: str, raw_content: bytes, \n                       encoding: str, line_ending: str) -> FileContent:\n    \"\"\"Factory function for validated FileContent creation.\n    \n    TODO 1: Normalize line endings according to detected type\n    TODO 2: Split content into lines while preserving empty lines\n    TODO 3: Apply whitespace normalization based on configuration\n    TODO 4: Validate line count matches actual content\n    TODO 5: Return populated FileContent with all metadata\n    \"\"\"\n    pass\n```\n\n#### Encoding Detection Infrastructure\n\n```python\nimport os\nfrom typing import Tuple\n\ndef detect_file_encoding(filepath: str) -> str:\n    \"\"\"Determine file encoding trying UTF-8 then Latin-1.\n    \n    Returns the encoding name that successfully decoded the file.\n    Raises BinaryFileError if file appears to be binary.\n    \"\"\"\n    # TODO 1: Read file as bytes for encoding detection\n    # TODO 2: Check for binary file indicators (null bytes, high non-printable ratio)\n    # TODO 3: Attempt UTF-8 decoding on entire content\n    # TODO 4: On UTF-8 failure, attempt Latin-1 decoding\n    # TODO 5: Return successful encoding name\n    pass\n\ndef _is_binary_content(content: bytes, sample_size: int = 8192) -> bool:\n    \"\"\"Detect if content appears to be binary rather than text.\n    \n    TODO 1: Check for null bytes in content sample\n    TODO 2: Count printable vs non-printable characters\n    TODO 3: Return True if binary indicators exceed threshold\n    \"\"\"\n    pass\n\ndef read_file_lines(filepath: str) -> List[str]:\n    \"\"\"Read file with encoding detection and line normalization.\n    \n    TODO 1: Validate file exists and is readable\n    TODO 2: Detect encoding using detect_file_encoding()\n    TODO 3: Read content with detected encoding  \n    TODO 4: Normalize line endings and split into lines\n    TODO 5: Apply whitespace normalization\n    TODO 6: Return clean list of line strings\n    \"\"\"\n    pass\n```\n\n#### Line Normalization Utilities\n\n```python\nfrom typing import Tuple, List\nimport re\n\ndef normalize_line_endings(content: str) -> Tuple[str, str]:\n    \"\"\"Normalize line endings and detect original format.\n    \n    Returns normalized content and detected line ending type.\n    \"\"\"\n    # TODO 1: Count occurrences of CRLF, LF, and CR\n    # TODO 2: Determine predominant line ending style\n    # TODO 3: Warn if mixed line endings detected\n    # TODO 4: Convert all line endings to LF for internal processing\n    # TODO 5: Return normalized content and original ending type\n    pass\n\ndef split_preserving_empty_lines(content: str) -> List[str]:\n    \"\"\"Split content into lines while preserving empty lines.\n    \n    TODO 1: Split on normalized line endings (LF)\n    TODO 2: Handle final newline correctly (don't create extra empty line)\n    TODO 3: Preserve truly empty lines in sequence\n    TODO 4: Return list of line content without line ending characters\n    \"\"\"\n    pass\n\ndef normalize_whitespace(lines: List[str], strip_trailing: bool = True) -> List[str]:\n    \"\"\"Apply whitespace normalization to line list.\n    \n    TODO 1: Process each line individually\n    TODO 2: Preserve leading whitespace (semantic meaning)\n    TODO 3: Optionally strip trailing whitespace based on configuration\n    TODO 4: Convert whitespace-only lines to empty strings\n    TODO 5: Return normalized line list\n    \"\"\"\n    pass\n```\n\n#### Error Handling and Recovery\n\n```python\nclass FileReaderError(Exception):\n    \"\"\"Base exception for file reading operations.\"\"\"\n    pass\n\nclass BinaryFileError(FileReaderError):\n    \"\"\"Raised when attempting to process binary files as text.\"\"\"\n    def __init__(self, filepath: str, indicator: str):\n        super().__init__(f\"Cannot diff binary file {filepath}: {indicator}\")\n\nclass EncodingDetectionError(FileReaderError):  \n    \"\"\"Raised when file encoding cannot be determined.\"\"\"\n    def __init__(self, filepath: str, attempted_encodings: List[str]):\n        encodings = \", \".join(attempted_encodings)\n        super().__init__(f\"Cannot detect encoding for {filepath}, tried: {encodings}\")\n\nclass LargeFileError(FileReaderError):\n    \"\"\"Raised when file exceeds memory or processing limits.\"\"\"\n    def __init__(self, filepath: str, size: int, limit: int):\n        super().__init__(f\"File {filepath} ({size} bytes) exceeds limit ({limit} bytes)\")\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the File Reader Component, verify correct behavior with these test scenarios:\n\n**Test Command**: \n```bash\npython -m pytest tests/test_file_reader.py -v\n```\n\n**Expected Behavior**:\n- UTF-8 files read correctly with proper line splitting\n- Latin-1 files fall back gracefully when UTF-8 fails  \n- Binary files rejected with clear error messages\n- Mixed line endings detected and normalized consistently\n- Empty lines preserved in output\n- Trailing whitespace handled according to configuration\n\n**Manual Verification**:\n```python\nfrom file_reader import read_file_lines\n\n# Test various file types\nutf8_lines = read_file_lines('test_files/utf8_sample.txt')\nlatin1_lines = read_file_lines('test_files/latin1_sample.txt') \nprint(f\"UTF-8 file: {len(utf8_lines)} lines\")\nprint(f\"Latin-1 file: {len(latin1_lines)} lines\")\n\n# Verify empty line preservation\nif \"\" in utf8_lines:\n    print(\"✓ Empty lines preserved\")\n```\n\n**Debugging Signs**:\n- **Files appear to have wrong line counts**: Check line ending normalization — mixed CRLF/LF can cause double-counting\n- **Unicode decode errors**: Verify binary file detection is working and catching non-text files early\n- **Memory usage spikes**: Implement file size checking and streaming for large files\n- **Spurious whitespace diffs**: Confirm trailing whitespace normalization is applied consistently\n\n\n## LCS Engine Component\n\n> **Milestone(s):** Milestone 2: LCS Algorithm — implements the core dynamic programming algorithm for finding longest common subsequences, which forms the foundation for all diff generation in subsequent milestones\n\nThe LCS Engine represents the mathematical heart of our diff tool, where we transform the abstract problem of \"what changed between two files\" into a concrete algorithmic solution. This component encapsulates the dynamic programming approach to finding the Longest Common Subsequence, serving as the bridge between raw line data from the File Reader and meaningful diff operations for the Diff Generator.\n\n### Mental Model: Finding Common Ground\n\nThink of the LCS algorithm like finding the longest sequence of topics two people agree on during a complex conversation. Imagine Alice and Bob are discussing a project, and you're taking notes on their areas of agreement. Alice says: \"We need planning, design, implementation, testing, deployment.\" Bob says: \"We should do planning, prototyping, implementation, review, testing, launch.\" \n\nYour job is to find the longest sequence of topics they both mentioned in the same order. You can't rearrange their words, but you can skip disagreements to find the common thread. The result might be: \"planning, implementation, testing\" — a subsequence that appears in both conversations while preserving the original order.\n\nThe LCS algorithm works similarly with text lines. Given two files, it finds the longest sequence of lines that appear in both files in the same relative order. These common lines represent the unchanged \"skeleton\" of the document, while everything else represents insertions or deletions. This common skeleton becomes the foundation for generating meaningful diff output that humans can understand.\n\nThe power of this approach lies in its optimality guarantee. Among all possible ways to align two sequences, the LCS algorithm finds the alignment that maximizes preserved content and minimizes the number of changes needed. This mathematical property ensures our diff output shows the most intuitive representation of what actually changed between files.\n\n### Dynamic Programming Algorithm\n\nThe LCS algorithm employs dynamic programming to solve what would otherwise be an exponentially complex problem. The core insight is that the LCS of two sequences can be computed by solving smaller subproblems and combining their results systematically.\n\n> **Decision: Dynamic Programming Matrix Approach**\n> - **Context**: Multiple algorithms exist for computing LCS, including recursive, memoized recursive, and dynamic programming approaches\n> - **Options Considered**: \n>   - Naive recursive: Simple but exponential time complexity O(2^n)\n>   - Memoized recursive: Better performance but complex stack management\n>   - Dynamic programming matrix: O(mn) time and space with clear implementation\n> - **Decision**: Use bottom-up dynamic programming with explicit matrix construction\n> - **Rationale**: Provides predictable O(mn) performance, easier debugging through matrix inspection, and straightforward backtracking for sequence recovery\n> - **Consequences**: Higher memory usage for large files but excellent performance characteristics and implementation clarity for learning purposes\n\n| Algorithm Approach | Time Complexity | Space Complexity | Debuggability | Implementation Complexity |\n|-------------------|-----------------|------------------|---------------|--------------------------|\n| Naive Recursive | O(2^n) | O(n) stack | Poor | Simple |\n| Memoized Recursive | O(mn) | O(mn) + stack | Medium | Medium |\n| **DP Matrix (Chosen)** | **O(mn)** | **O(mn)** | **Excellent** | **Medium** |\n\nThe dynamic programming solution builds a two-dimensional matrix where each cell `[i][j]` represents the length of the LCS for the first `i` elements of sequence 1 and the first `j` elements of sequence 2. This bottom-up approach systematically solves smaller subproblems to construct the solution for the full problem.\n\n#### Matrix Construction Algorithm\n\nThe matrix construction follows a systematic pattern that builds the LCS length table:\n\n1. **Initialize the matrix** with dimensions `(len(sequence1) + 1) × (len(sequence2) + 1)` to accommodate empty sequence cases. The extra row and column represent empty prefixes with LCS length zero.\n\n2. **Set base cases** by filling the first row and first column with zeros, representing that the LCS of any sequence with an empty sequence has length zero.\n\n3. **Fill the matrix iteratively** using the recurrence relation. For each cell `[i][j]`, compare `sequence1[i-1]` with `sequence2[j-1]` (subtracting 1 because matrix indices are offset by 1).\n\n4. **Apply the recurrence relation**: If the elements match, set `matrix[i][j] = matrix[i-1][j-1] + 1` (extending the LCS of the prefixes). If they don't match, set `matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1])` (taking the better of excluding one element or the other).\n\n5. **Complete the matrix** by processing all cells in row-major order, ensuring each cell depends only on previously computed values.\n\n6. **Extract the LCS length** from the bottom-right cell `matrix[len(sequence1)][len(sequence2)]`, which represents the LCS length for the complete sequences.\n\nThe recurrence relation captures the essential logic of LCS computation. When elements match, we can extend the best solution for the shorter prefixes. When they don't match, we take the better of two options: either exclude the current element from sequence 1 or exclude it from sequence 2. This greedy choice at each step leads to the globally optimal solution due to the optimal substructure property.\n\n#### Backtracking Algorithm for Sequence Recovery\n\nBuilding the matrix gives us the LCS length, but we need the actual sequence for diff generation. The backtracking algorithm reconstructs the LCS by tracing backwards through the matrix:\n\n1. **Start at the bottom-right corner** `[len(sequence1)][len(sequence2)]` where the complete LCS length is stored.\n\n2. **Initialize tracking variables** for the current matrix position `(i, j)` and an empty list to collect LCS elements in reverse order.\n\n3. **Trace backwards through the matrix** by examining how each cell was computed. If `sequence1[i-1] == sequence2[j-1]`, this element is part of the LCS, so add it to the result and move diagonally to `[i-1][j-1]`.\n\n4. **Handle non-matching elements** by moving toward the cell that contributed the maximum value. If `matrix[i-1][j] > matrix[i][j-1]`, move up to `[i-1][j]`. Otherwise, move left to `[i][j-1]`.\n\n5. **Continue until reaching the top or left edge** where the matrix values are zero, indicating we've traced back to empty sequence prefixes.\n\n6. **Reverse the collected elements** since backtracking produces them in reverse order, yielding the actual LCS.\n\nThe backtracking process also captures the positions where LCS elements occur in both original sequences, which becomes crucial for diff generation. By tracking the `(i-1, j-1)` coordinates when we find matching elements, we build a mapping showing where each common line appears in both files.\n\n#### LCS Engine Data Structures\n\nThe `LCSEngine` component manages the dynamic programming computation and provides a clean interface for the rest of the system:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `matrix` | `list[list[int]]` | The dynamic programming table storing LCS lengths for all subproblems |\n| `sequence1` | `Sequence` | The first input sequence (typically lines from file 1) |\n| `sequence2` | `Sequence` | The second input sequence (typically lines from file 2) |\n| `lcs_length` | `int` | The length of the computed LCS, cached after matrix construction |\n| `computation_stats` | `dict` | Performance metrics including matrix size and computation time |\n\nThe `CommonSubsequence` structure encapsulates the complete LCS result:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `elements` | `list[str]` | The actual LCS elements in sequence order |\n| `length` | `int` | The number of elements in the LCS |\n| `positions1` | `list[int]` | Zero-based indices where LCS elements appear in sequence1 |\n| `positions2` | `list[int]` | Zero-based indices where LCS elements appear in sequence2 |\n\nThe position lists enable the Diff Generator to identify exactly which lines are unchanged and where they occur in both files, forming the anchor points around which insertions and deletions are organized.\n\n#### LCS Engine Interface\n\nThe `LCSEngine` exposes a focused interface that encapsulates the dynamic programming complexity:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `compute_lcs` | `sequence1: Sequence, sequence2: Sequence` | `CommonSubsequence` | Main entry point that builds matrix and extracts LCS |\n| `build_lcs_matrix` | `seq1: Sequence, seq2: Sequence` | `list[list[int]]` | Constructs the dynamic programming matrix |\n| `backtrack` | `matrix: list[list[int]], seq1: Sequence, seq2: Sequence` | `CommonSubsequence` | Recovers the actual LCS from the completed matrix |\n| `get_matrix_cell` | `i: int, j: int` | `int` | Safe matrix access with bounds checking |\n| `clear_matrix` | `None` | `None` | Releases matrix memory after computation |\n\n### Memory Optimization Strategies\n\nThe standard LCS dynamic programming approach requires O(mn) space for the matrix, which becomes problematic for large files. A 10,000-line file compared against another 10,000-line file requires a 100-million-cell matrix, consuming significant memory.\n\n> **Decision: Adaptive Memory Strategy**\n> - **Context**: Large files can exhaust available memory with O(mn) matrix storage, but different use cases have different memory constraints\n> - **Options Considered**:\n>   - Always use O(mn) matrix: Simple but fails on large files\n>   - Always use Hirschberg's algorithm: O(n) space but complex implementation\n>   - Adaptive approach: Choose strategy based on input size\n> - **Decision**: Implement adaptive memory management with configurable thresholds\n> - **Rationale**: Provides optimal performance for small-medium files while gracefully handling large files through space-efficient algorithms\n> - **Consequences**: More complex implementation but handles full range of input sizes from small config files to large source files\n\n| Strategy | Space Complexity | Implementation Complexity | Performance | File Size Limit |\n|----------|------------------|--------------------------|-------------|----------------|\n| **Standard Matrix (Chosen for <1M cells)** | **O(mn)** | **Low** | **Best** | **~1000×1000 lines** |\n| **Two-Row Optimization** | **O(min(m,n))** | **Medium** | **Good** | **~10K×10K lines** |\n| **Hirschberg's Algorithm** | **O(m+n)** | **High** | **Slower** | **Unlimited** |\n\n#### Two-Row Optimization\n\nFor computing just the LCS length without sequence recovery, we can reduce space complexity to O(min(m,n)) by observing that each matrix row depends only on the previous row. This optimization maintains two arrays instead of the full matrix:\n\nThe algorithm maintains `current_row` and `previous_row` arrays, updating them as it processes each row of the conceptual matrix. After processing each row, the roles swap: `current_row` becomes `previous_row` for the next iteration. This approach reduces memory usage by a factor of max(m,n) while maintaining the same time complexity.\n\nHowever, this optimization complicates backtracking since we no longer have the full matrix. For diff tools, we need the actual LCS sequence, not just its length, so this optimization applies primarily to preliminary size checking or when combined with more sophisticated space-efficient algorithms.\n\n#### Hirschberg's Algorithm Consideration\n\nHirschberg's algorithm achieves O(m+n) space complexity while still recovering the actual LCS through a divide-and-conquer approach. The algorithm recursively splits the problem in half, using the two-row optimization to find the optimal splitting point, then recursively processes each half.\n\nFor our diff tool, Hirschberg's algorithm becomes relevant when comparing very large files that exceed available memory with the standard matrix approach. The implementation complexity significantly increases, involving recursive partitioning and careful coordinate tracking across subproblems.\n\n> The key insight is that Hirschberg's algorithm trades time for space — it performs multiple passes over the data to avoid storing the complete matrix, resulting in roughly double the computation time but dramatically reduced memory usage.\n\n#### Adaptive Memory Management Implementation\n\nOur LCS engine implements adaptive memory management by estimating memory requirements before choosing the algorithm:\n\n1. **Calculate matrix size requirements** by multiplying sequence lengths and estimating memory per cell (typically 4-8 bytes for integers).\n\n2. **Compare against available memory** using system memory detection and configured memory limits for the diff process.\n\n3. **Select algorithm based on thresholds**: Use standard matrix for small files, two-row optimization for medium files, and Hirschberg's algorithm for large files that would exceed memory limits.\n\n4. **Provide progress feedback** for large file processing, since space-efficient algorithms take longer and users need feedback on processing status.\n\n5. **Implement graceful degradation** by falling back to simpler diff approaches (like line-by-line comparison without LCS optimization) if even the space-efficient algorithms encounter memory pressure.\n\n### Common Pitfalls\n\nUnderstanding the typical mistakes in LCS implementation helps avoid debugging sessions and ensures robust diff functionality.\n\n⚠️ **Pitfall: Off-by-One Matrix Indexing**\n\nThe most frequent LCS implementation error involves matrix indexing confusion between sequence positions and matrix positions. The matrix has dimensions `(m+1) × (n+1)` to include empty sequence cases, but sequence elements are accessed using 0-based indexing.\n\nWhen filling matrix cell `[i][j]`, the corresponding sequence elements are `sequence1[i-1]` and `sequence2[j-1]`. Forgetting this offset leads to index out-of-bounds errors or comparing wrong elements. The bug manifests as either runtime crashes on boundary cases or subtly incorrect LCS results where elements appear to match when they shouldn't.\n\n**Fix**: Always use `sequence1[i-1]` and `sequence2[j-1]` when filling matrix cell `[i][j]`, and carefully trace through boundary cases with empty sequences to verify indexing logic.\n\n⚠️ **Pitfall: Empty Sequence Handling**\n\nEmpty files or sequences with no matching elements create edge cases that break poorly implemented LCS algorithms. Common issues include division by zero when calculating progress percentages, null pointer exceptions when accessing empty sequence elements, or infinite loops in backtracking when no valid LCS exists.\n\nThe algorithm should handle empty inputs gracefully: empty sequences have LCS length zero, and backtracking should immediately return an empty result. Additionally, sequences with no common elements should produce an empty LCS, not crash the algorithm.\n\n**Fix**: Explicitly test with empty sequences and implement early returns for trivial cases. Add null checks and boundary validation before accessing sequence elements or matrix cells.\n\n⚠️ **Pitfall: Memory Explosion on Large Files**\n\nLarge files can quickly exhaust available memory without appropriate safeguards. A 50,000-line file compared against another similar file requires a 2.5-billion-cell matrix, consuming 10+ GB of memory with standard integer storage.\n\nWithout memory limits or adaptive algorithms, the diff tool becomes unusable on realistic large files like database dumps, log files, or generated code. The system may freeze, swap thrash, or crash with out-of-memory errors, providing no useful feedback to the user.\n\n**Fix**: Implement memory estimation before matrix allocation, provide user feedback about memory requirements, and implement fallback algorithms for large files. Consider streaming approaches or approximate diff algorithms when exact LCS computation exceeds practical memory limits.\n\n⚠️ **Pitfall: Incorrect Backtracking Logic**\n\nBacktracking errors produce incorrect LCS sequences even when the matrix construction is correct. Common mistakes include wrong direction choices when matrix values are equal, failing to handle diagonal moves correctly, or reconstructing the sequence in the wrong order.\n\nThese bugs are particularly insidious because the LCS length might be correct while the actual sequence is wrong, leading to malformed diffs that incorrectly identify changed lines. The resulting diff output becomes unreliable and may show spurious additions or deletions.\n\n**Fix**: Implement comprehensive backtracking tests with known input-output pairs, carefully handle tie-breaking when multiple cells have equal values, and verify that backtracking produces sequences that actually appear in both original inputs.\n\n⚠️ **Pitfall: Performance Degradation with Repetitive Content**\n\nFiles with highly repetitive content (like configuration templates, generated code, or data dumps) create performance challenges for LCS algorithms. Many potential matches exist at each step, leading to large matrices with complex backtracking paths.\n\nWhile the algorithm complexity remains O(mn), the constant factors become significant, and cache performance degrades due to poor locality of access patterns. The user experiences slow performance even on moderately-sized files with repetitive structure.\n\n**Fix**: Implement preprocessing to identify and handle repetitive patterns efficiently, consider approximate algorithms for files with low diversity, and provide progress feedback for long-running computations on repetitive content.\n\n![LCS Algorithm Execution Flow](./diagrams/lcs-algorithm-flow.svg)\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Matrix Storage | `list[list[int]]` (Python native lists) | `numpy.ndarray` for large matrices with better memory layout |\n| Sequence Representation | `list[str]` (Python native strings) | Custom `Sequence` class with lazy loading for large files |\n| Memory Management | Manual size checking with `sys.getsizeof()` | Memory-mapped files with `mmap` for huge sequences |\n| Performance Monitoring | Simple time tracking with `time.perf_counter()` | `cProfile` integration for detailed algorithm profiling |\n\n#### Recommended File Structure\n\nThe LCS Engine fits into the project structure as a focused algorithmic component:\n\n```\ndiff_tool/\n├── core/\n│   ├── __init__.py\n│   ├── lcs_engine.py          ← main LCS implementation\n│   ├── lcs_types.py           ← CommonSubsequence and related types\n│   └── memory_optimizer.py    ← adaptive memory management\n├── utils/\n│   ├── sequence_utils.py      ← sequence preprocessing helpers  \n│   └── performance_monitor.py ← computation timing and stats\n└── tests/\n    ├── test_lcs_engine.py     ← comprehensive LCS algorithm tests\n    ├── test_lcs_edge_cases.py ← empty sequences, large files, etc.\n    └── fixtures/              ← test data files with known LCS results\n```\n\n#### Infrastructure Starter Code\n\n**Complete Memory Management Helper** (`core/memory_optimizer.py`):\n\n```python\nimport sys\nimport psutil\nfrom typing import Tuple, Literal\nfrom dataclasses import dataclass\n\n@dataclass\nclass MemoryStrategy:\n    algorithm: Literal[\"matrix\", \"two_row\", \"hirschberg\"]\n    max_memory_mb: float\n    estimated_time_factor: float\n\nclass MemoryOptimizer:\n    \"\"\"Determines optimal LCS algorithm based on available memory and input size.\"\"\"\n    \n    def __init__(self, max_memory_percent: float = 0.5):\n        self.max_memory_percent = max_memory_percent\n        available_memory = psutil.virtual_memory().available\n        self.max_memory_bytes = available_memory * max_memory_percent\n    \n    def choose_strategy(self, seq1_len: int, seq2_len: int) -> MemoryStrategy:\n        \"\"\"Choose LCS algorithm based on memory requirements and available resources.\"\"\"\n        matrix_cells = (seq1_len + 1) * (seq2_len + 1)\n        matrix_memory = matrix_cells * 8  # 8 bytes per int64\n        \n        if matrix_memory <= self.max_memory_bytes:\n            return MemoryStrategy(\"matrix\", matrix_memory / 1024 / 1024, 1.0)\n        elif seq1_len * 8 <= self.max_memory_bytes:  # Two row optimization\n            return MemoryStrategy(\"two_row\", seq1_len * 16 / 1024 / 1024, 1.2)\n        else:\n            return MemoryStrategy(\"hirschberg\", (seq1_len + seq2_len) * 8 / 1024 / 1024, 2.5)\n    \n    def estimate_computation_time(self, seq1_len: int, seq2_len: int, strategy: MemoryStrategy) -> float:\n        \"\"\"Estimate computation time in seconds based on sequence length and strategy.\"\"\"\n        base_operations = seq1_len * seq2_len\n        # Rough estimate: 1M operations per second baseline\n        base_time = base_operations / 1_000_000\n        return base_time * strategy.estimated_time_factor\n```\n\n**Complete Performance Monitor** (`utils/performance_monitor.py`):\n\n```python\nimport time\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass ComputationStats:\n    \"\"\"Statistics collected during LCS computation.\"\"\"\n    start_time: float = field(default_factory=time.perf_counter)\n    end_time: Optional[float] = None\n    matrix_size: Tuple[int, int] = (0, 0)\n    memory_used_mb: float = 0.0\n    algorithm_used: str = \"matrix\"\n    lcs_length: int = 0\n    \n    @property\n    def computation_time(self) -> float:\n        if self.end_time is None:\n            return time.perf_counter() - self.start_time\n        return self.end_time - self.start_time\n    \n    def finish(self):\n        \"\"\"Mark computation as complete.\"\"\"\n        self.end_time = time.perf_counter()\n\nclass PerformanceMonitor:\n    \"\"\"Tracks performance metrics during LCS computation.\"\"\"\n    \n    def __init__(self):\n        self.current_stats: Optional[ComputationStats] = None\n    \n    def start_computation(self, seq1_len: int, seq2_len: int, algorithm: str) -> ComputationStats:\n        \"\"\"Begin tracking a new LCS computation.\"\"\"\n        self.current_stats = ComputationStats(\n            matrix_size=(seq1_len + 1, seq2_len + 1),\n            algorithm_used=algorithm\n        )\n        return self.current_stats\n    \n    def finish_computation(self, lcs_length: int) -> ComputationStats:\n        \"\"\"Complete the current computation tracking.\"\"\"\n        if self.current_stats is None:\n            raise ValueError(\"No computation in progress\")\n        \n        self.current_stats.lcs_length = lcs_length\n        self.current_stats.finish()\n        return self.current_stats\n    \n    def report_progress(self, current_row: int, total_rows: int) -> None:\n        \"\"\"Report progress during matrix construction.\"\"\"\n        if self.current_stats and current_row % 1000 == 0:\n            progress = (current_row / total_rows) * 100\n            elapsed = time.perf_counter() - self.current_stats.start_time\n            print(f\"LCS Progress: {progress:.1f}% ({current_row}/{total_rows} rows, {elapsed:.1f}s)\")\n```\n\n#### Core Logic Skeleton Code\n\n**Main LCS Engine** (`core/lcs_engine.py`):\n\n```python\nfrom typing import List, Optional\nfrom dataclasses import dataclass\nfrom .lcs_types import CommonSubsequence, Sequence\nfrom .memory_optimizer import MemoryOptimizer\nfrom ..utils.performance_monitor import PerformanceMonitor\n\nclass LCSEngine:\n    \"\"\"Implements dynamic programming LCS algorithm with adaptive memory management.\"\"\"\n    \n    def __init__(self, max_memory_percent: float = 0.5):\n        self.memory_optimizer = MemoryOptimizer(max_memory_percent)\n        self.performance_monitor = PerformanceMonitor()\n        self.matrix: Optional[List[List[int]]] = None\n    \n    def compute_lcs(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:\n        \"\"\"\n        Find the longest common subsequence using dynamic programming.\n        \n        This is the main entry point that orchestrates matrix construction,\n        backtracking, and memory optimization based on input size.\n        \"\"\"\n        # TODO 1: Choose memory strategy based on sequence lengths using memory_optimizer\n        # TODO 2: Start performance monitoring for the computation\n        # TODO 3: Build the LCS matrix using the chosen strategy \n        # TODO 4: Extract the LCS through backtracking\n        # TODO 5: Clean up matrix memory and finish performance monitoring\n        # TODO 6: Return CommonSubsequence with elements and position mappings\n        # Hint: Handle empty sequences as a special case before matrix construction\n        pass\n    \n    def build_lcs_matrix(self, seq1: Sequence, seq2: Sequence) -> List[List[int]]:\n        \"\"\"\n        Construct the dynamic programming matrix for LCS computation.\n        \n        Creates an (m+1) x (n+1) matrix where matrix[i][j] represents\n        the LCS length for seq1[:i] and seq2[:j].\n        \"\"\"\n        # TODO 1: Create matrix with dimensions (len(seq1)+1) x (len(seq2)+1)\n        # TODO 2: Initialize first row and column to zero (base cases)\n        # TODO 3: Fill matrix using double loop over sequences\n        # TODO 4: For each cell [i,j], compare seq1[i-1] with seq2[j-1]\n        # TODO 5: If elements match: matrix[i][j] = matrix[i-1][j-1] + 1\n        # TODO 6: If different: matrix[i][j] = max(matrix[i-1][j], matrix[i][j-1])\n        # TODO 7: Report progress every 1000 rows for large matrices\n        # Hint: Remember the +1 offset between matrix indices and sequence indices\n        pass\n    \n    def backtrack(self, matrix: List[List[int]], seq1: Sequence, seq2: Sequence) -> CommonSubsequence:\n        \"\"\"\n        Recover the actual LCS from the completed matrix.\n        \n        Traces backwards from matrix[m][n] to reconstruct the LCS elements\n        and their positions in both original sequences.\n        \"\"\"\n        # TODO 1: Initialize tracking variables: i=len(seq1), j=len(seq2)\n        # TODO 2: Create empty lists for LCS elements and position tracking\n        # TODO 3: While both i>0 and j>0, examine current matrix cell\n        # TODO 4: If seq1[i-1] == seq2[j-1], add to LCS and move diagonally\n        # TODO 5: Otherwise, move toward cell that contributed the maximum value\n        # TODO 6: Handle remaining elements if one sequence is exhausted first\n        # TODO 7: Reverse collected elements (backtracking gives reverse order)\n        # TODO 8: Return CommonSubsequence with elements and position arrays\n        # Hint: Track positions as (i-1, j-1) when adding matching elements\n        pass\n    \n    def clear_matrix(self) -> None:\n        \"\"\"Release matrix memory after computation.\"\"\"\n        # TODO 1: Set self.matrix to None to allow garbage collection\n        # TODO 2: Optionally call gc.collect() for immediate memory release\n        pass\n```\n\n**LCS Data Types** (`core/lcs_types.py`):\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n# Type alias for sequence of comparable elements\nSequence = List[str]\n\n@dataclass\nclass CommonSubsequence:\n    \"\"\"Result of LCS computation with elements and position tracking.\"\"\"\n    elements: List[str]\n    length: int\n    positions1: List[int]  # Indices in first sequence\n    positions2: List[int]  # Indices in second sequence\n    \n    def __post_init__(self):\n        \"\"\"Validate that all lists have consistent lengths.\"\"\"\n        # TODO 1: Check that len(elements) == length\n        # TODO 2: Check that len(positions1) == len(positions2) == length\n        # TODO 3: Raise ValueError if any length mismatches found\n        pass\n    \n    @property\n    def is_empty(self) -> bool:\n        \"\"\"Check if the LCS is empty (no common elements).\"\"\"\n        return self.length == 0\n    \n    def get_element_at_position(self, lcs_index: int) -> tuple[str, int, int]:\n        \"\"\"Get LCS element and its positions in both original sequences.\"\"\"\n        # TODO 1: Validate lcs_index is within bounds\n        # TODO 2: Return tuple of (element, pos1, pos2)\n        pass\n```\n\n#### Language-Specific Hints\n\n**Python-Specific Optimizations:**\n\n- Use `list` comprehensions for matrix initialization: `[[0] * cols for _ in range(rows)]` avoids reference sharing bugs\n- Consider `array.array('i')` instead of lists for large matrices to reduce memory overhead\n- Use `sys.getsizeof()` to measure actual memory usage of data structures\n- Profile with `cProfile` to identify bottlenecks in matrix construction vs. backtracking\n- For very large sequences, consider `numpy` arrays with `dtype=np.int32` for better cache performance\n\n**Memory Management:**\n\n- Monitor memory usage with `psutil.Process().memory_info().rss` during computation\n- Implement matrix chunking for files larger than available memory\n- Use `gc.collect()` after clearing large matrices to ensure immediate memory release\n- Consider `mmap` for reading very large files without loading entirely into memory\n\n#### Milestone Checkpoint\n\nAfter implementing the LCS Engine component, verify the following behavior:\n\n**Unit Test Verification:**\n```bash\npython -m pytest tests/test_lcs_engine.py -v\n```\n\n**Expected Test Results:**\n- `test_empty_sequences`: LCS of empty sequences returns empty CommonSubsequence\n- `test_identical_sequences`: LCS of identical sequences returns the full sequence\n- `test_no_common_elements`: LCS of completely different sequences returns empty result\n- `test_simple_lcs`: Known input-output pairs produce expected LCS elements and positions\n- `test_matrix_construction`: Matrix dimensions and values match hand-calculated examples\n- `test_backtracking_accuracy`: Backtracking produces sequences that actually exist in both inputs\n\n**Manual Verification:**\n\nCreate test files with known LCS results:\n```python\n# Test with simple sequences\nseq1 = [\"A\", \"B\", \"C\", \"D\", \"E\"]\nseq2 = [\"A\", \"C\", \"E\", \"F\"]\n# Expected LCS: [\"A\", \"C\", \"E\"] at positions ([0,2,4], [0,1,2])\n\nengine = LCSEngine()\nresult = engine.compute_lcs(seq1, seq2)\nprint(f\"LCS: {result.elements}\")  # Should show [\"A\", \"C\", \"E\"]\nprint(f\"Length: {result.length}\") # Should show 3\nprint(f\"Positions: {result.positions1}, {result.positions2}\") # Should show [0,2,4], [0,1,2]\n```\n\n**Performance Verification:**\n\nTest memory optimization with large sequences:\n```python\n# Generate large test sequences\nseq1 = [f\"line_{i}\" for i in range(10000)]\nseq2 = [f\"line_{i}\" if i % 2 == 0 else f\"different_{i}\" for i in range(10000)]\n\nengine = LCSEngine(max_memory_percent=0.1)  # Restrict memory\nresult = engine.compute_lcs(seq1, seq2)\n# Should complete without memory errors and choose appropriate algorithm\n```\n\n**Signs of Problems:**\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| IndexError during matrix construction | Off-by-one in sequence access | Use `seq[i-1]` when filling `matrix[i][j]` |\n| Wrong LCS length but no crash | Incorrect recurrence relation | Verify max() logic and diagonal increment |\n| Empty LCS for sequences with obvious matches | Backtracking logic error | Check direction choices and sequence comparison |\n| Memory errors on medium files | No memory optimization | Implement strategy selection based on input size |\n| Slow performance on repetitive content | Poor cache locality | Consider preprocessing or approximate algorithms |\n\n\n## Diff Generator Component\n\n> **Milestone(s):** Milestone 3: Diff Generation — converts LCS results into edit operations and groups them into contextual hunks with unified diff format\n\nThe `DiffGenerator` component bridges the gap between algorithmic computation and human-readable output. While the `LCSEngine` identifies which lines are common between files, the diff generator transforms this mathematical result into actionable editing instructions that clearly communicate what changed, where it changed, and how much context surrounds each change.\n\n### Mental Model: Editorial Instructions\n\nThink of the `DiffGenerator` as a professional editor creating revision instructions for a manuscript. When an editor compares two drafts of a document, they don't just identify differences—they create clear, structured instructions that tell the author exactly what to add, delete, or keep unchanged. These instructions are grouped into logical sections with enough surrounding context that the author can understand the intent behind each change.\n\nJust as an editor might group related changes together (\"In the third paragraph, delete the second sentence and add these two new sentences\"), our diff generator groups nearby line changes into **hunks** with surrounding **context lines**. The editor provides context by showing unchanged sentences around the edits, and our diff generator includes unchanged lines around modifications so readers can orient themselves within the file structure.\n\nThe editorial analogy extends to the output format: professional editing uses standardized notation (strike-through for deletions, highlights for additions, margin notes for instructions), while our diff generator uses the **unified diff format** with `-` for deletions, `+` for additions, and space-prefixed lines for context. Both systems prioritize clarity and actionability over raw algorithmic output.\n\n### Edit Script Generation\n\nThe process of converting LCS results into edit operations requires translating from the mathematical representation of common subsequences to the practical representation of file modifications. The LCS algorithm identifies which lines exist in both files, but the diff generator must determine the editing operations needed to transform the first file into the second file.\n\nThe conversion algorithm works by walking through both input files simultaneously while consulting the LCS result to determine the fate of each line. This three-way comparison—original file, target file, and common subsequence—allows the generator to categorize every line as unchanged, deleted, or added.\n\n> **Decision: Line-by-Line Edit Operation Classification**\n> - **Context**: The LCS result identifies common lines but doesn't directly specify edit operations. We need to transform this into explicit ADD, DELETE, and UNCHANGED classifications.\n> - **Options Considered**: \n>   1. Generate edit operations directly from LCS positions\n>   2. Use diff algorithm to reconstruct operations from LCS\n>   3. Implement Myers' algorithm for direct edit script generation\n> - **Decision**: Generate edit operations by comparing file positions against LCS positions\n> - **Rationale**: This approach leverages our existing LCS implementation while remaining conceptually straightforward for learners. Myers' algorithm is more efficient but adds complexity beyond the core learning goals.\n> - **Consequences**: Enables clear separation between LCS computation and diff generation, making the code more modular and easier to debug. Performance is adequate for typical file sizes.\n\nThe `lcs_to_edit_operations` function implements this classification by maintaining three pointers: one for each input file and one for the LCS positions. As it advances through the files, it determines whether each line should be classified as unchanged (present in LCS), deleted (in first file but not LCS), or added (in second file but not LCS).\n\n| Edit Operation | Detection Logic | Line Numbering | Content Source |\n|----------------|-----------------|----------------|----------------|\n| `UNCHANGED` | Line position matches LCS position | Both old and new line numbers | Content from either file (identical) |\n| `DELETED` | Line in file1 but not at current LCS position | Old line number only | Content from first file |\n| `ADDED` | Line in file2 but not at current LCS position | New line number only | Content from second file |\n\nThe algorithm maintains careful tracking of line numbers for each file, as the unified diff format requires accurate position information. Deleted lines reference their position in the original file, added lines reference their position in the target file, and unchanged lines reference positions in both files.\n\nConsider a concrete example where the LCS identifies that lines 2, 4, and 7 from the first file correspond to lines 2, 5, and 8 in the second file. The edit script generation proceeds as follows:\n\n1. **Line 1 of file1**: Not in LCS positions, so mark as `DELETED` with `old_line_num=1`\n2. **Line 1 of file2**: Not in LCS positions, so mark as `ADDED` with `new_line_num=1`  \n3. **Line 2 of both files**: Matches LCS position, so mark as `UNCHANGED` with `old_line_num=2, new_line_num=2`\n4. **Line 3 of file1**: Not in LCS positions, so mark as `DELETED` with `old_line_num=3`\n5. **Lines 3-4 of file2**: Line 3 not in LCS, line 4 not in LCS, so both marked as `ADDED`\n6. Continue this pattern through both files\n\nThe resulting edit script provides a complete transformation recipe that can convert the first file into the second file through a sequence of line operations.\n\n> The critical insight is that edit operations are not just about identifying changes—they must preserve enough information to reconstruct either file from the other. This is why line numbering accuracy is essential for tools that apply diff output.\n\n### Hunk Formation and Context\n\nRaw edit operations provide complete transformation information but lack the contextual grouping that makes diffs readable and actionable. **Hunk formation** addresses this by clustering nearby changes together and surrounding them with unchanged lines that provide visual and logical context.\n\nThe hunk formation algorithm operates on the principle that changes separated by only a few unchanged lines are more comprehensible when presented together rather than as separate modification blocks. This mirrors how readers naturally process textual changes—they need enough surrounding context to understand the purpose and scope of modifications.\n\n![Hunk Formation Process](./diagrams/hunk-formation-flow.svg)\n\nThe `diff_lines_to_hunks` function implements a sliding window approach to group edit operations. It scans through the sequence of `DiffLine` objects, identifying boundaries where hunks should begin and end based on configurable **context line** counts and gap thresholds between changes.\n\n| Hunk Formation Parameter | Default Value | Purpose | Impact of Increasing |\n|--------------------------|---------------|---------|---------------------|\n| `context_lines` | 3 | Lines of unchanged context around each change | More context but larger hunks |\n| `max_gap` | 2 × `context_lines` | Maximum unchanged lines between changes in same hunk | Fewer, larger hunks |\n| `min_hunk_size` | 1 | Minimum number of changed lines per hunk | Filters out tiny modifications |\n\nThe algorithm maintains state about the current hunk being constructed and decides whether to extend it or start a new one based on the gap between changes. When encountering a sequence of unchanged lines, it determines whether these should become inter-change context (keeping the hunk open) or hunk separator lines (closing the current hunk and starting a new one).\n\n> **Decision: Context Line Strategy**\n> - **Context**: Diffs need surrounding unchanged lines for readability, but too much context creates overwhelming output while too little context provides insufficient orientation.\n> - **Options Considered**:\n>   1. Fixed context count (e.g., always 3 lines before and after)\n>   2. Adaptive context based on change density\n>   3. Configurable context with intelligent merging\n> - **Decision**: Configurable fixed context with automatic hunk merging when gaps are small\n> - **Rationale**: Provides predictable output size while allowing users to adjust based on their needs. Automatic merging prevents fragmentation of closely-related changes.\n> - **Consequences**: Simple implementation that covers most use cases. Users can increase context for complex changes or decrease it for focused reviews.\n\nThe hunk boundary detection logic examines sequences of unchanged lines to determine their role:\n\n1. **Leading context**: Up to `context_lines` unchanged lines before the first change in a hunk\n2. **Inter-change context**: Unchanged lines between two changes within the same hunk\n3. **Trailing context**: Up to `context_lines` unchanged lines after the last change in a hunk\n4. **Separator lines**: Unchanged lines that are too numerous to serve as context, indicating a hunk boundary\n\nEach `Hunk` object encapsulates a complete modification unit with its surrounding context:\n\n| Hunk Field | Type | Description | Example Value |\n|------------|------|-------------|---------------|\n| `old_start` | int | Starting line number in original file (1-indexed) | 45 |\n| `old_count` | int | Number of lines from original file in this hunk | 7 |\n| `new_start` | int | Starting line number in target file (1-indexed) | 45 |\n| `new_count` | int | Number of lines from target file in this hunk | 9 |\n| `lines` | list[DiffLine] | Complete sequence of context and changed lines | [context, deletion, addition, context] |\n| `context_before` | int | Actual leading context lines included | 3 |\n| `context_after` | int | Actual trailing context lines included | 2 |\n\nThe unified diff format represents each hunk with a header line that summarizes its scope: `@@ -45,7 +45,9 @@`. This header communicates that the hunk starts at line 45 in the original file and includes 7 lines, while starting at line 45 in the target file and including 9 lines. The difference in line counts (9 - 7 = 2) immediately indicates that this hunk represents a net addition of 2 lines.\n\nContext line management requires careful boundary handling to avoid duplicating lines between adjacent hunks or exceeding file boundaries. The algorithm tracks available context at the beginning and end of files, adjusting the actual context counts when insufficient lines exist.\n\nConsider the hunk merging decision process for two potential hunks separated by 4 unchanged lines when `context_lines=3`:\n\n1. **First hunk**: Wants 3 lines of trailing context\n2. **Gap**: 4 unchanged lines exist between hunks  \n3. **Second hunk**: Wants 3 lines of leading context\n4. **Total requirement**: 3 + 4 + 3 = 10 lines to represent separately\n5. **Merged requirement**: 4 lines as inter-change context\n6. **Decision**: Merge hunks since merged representation is more compact\n\nThe `merge_hunks` function implements this logic by checking whether the combined representation would be more efficient than separate hunks. This prevents the creation of tiny hunks separated by minimal context, which creates fragmented and hard-to-follow diffs.\n\n### Common Pitfalls\n\nUnderstanding where diff generation commonly goes wrong helps developers avoid frustrating debugging sessions and incorrect output. These pitfalls often stem from the impedance mismatch between zero-indexed programming languages and one-indexed diff formats, as well as edge cases in file structure and algorithm logic.\n\n⚠️ **Pitfall: Zero-Based vs One-Based Line Numbering**\n\nProgramming languages use zero-based indexing for arrays and lists, but the unified diff format uses one-based line numbering for human readability. This creates a persistent source of off-by-one errors that manifest as incorrect `@@ -start,count +start,count @@` headers.\n\nThe error typically appears when developers directly use list indices as line numbers in the diff output. For example, if a change occurs at index 5 in a Python list, the correct diff line number is 6, not 5. This mistake becomes particularly problematic when tools attempt to apply the generated diff, as they expect standard one-based numbering.\n\nThe fix requires consistent application of `+1` conversion when generating line numbers for `DiffLine` objects and hunk headers. However, the conversion must only apply to external output—internal algorithm logic should continue using zero-based indices for array access.\n\n```\n# WRONG: Using zero-based indices directly\nhunk.old_start = first_change_index  # Results in line 0, which is invalid\n\n# CORRECT: Converting to one-based for external format  \nhunk.old_start = first_change_index + 1  # Results in line 1\n```\n\n⚠️ **Pitfall: Files With No Common Lines**\n\nWhen two files share no common content, the LCS algorithm returns an empty subsequence, which can cause the diff generator to produce degenerate output or crash entirely. This scenario occurs more frequently than expected—when comparing completely different files, generated files with different content, or files where one is empty.\n\nThe symptom appears as either a single massive hunk containing all deletions followed by all additions, or as an error when the algorithm assumes at least some common content exists. Some implementations incorrectly try to create context lines when none exist, leading to array access errors.\n\nThe correct approach treats files with no common lines as a special case: create a single hunk that deletes all lines from the first file and adds all lines from the second file. No context lines exist by definition, so the hunk contains only change operations.\n\n⚠️ **Pitfall: Context Line Overlap Between Adjacent Hunks**\n\nWhen changes occur close together in files, the trailing context of one hunk may overlap with the leading context of the next hunk. Naive implementations either duplicate these lines (creating invalid diffs) or crash when trying to create conflicting line number ranges.\n\nThis manifests as hunks with overlapping line number ranges in their headers, such as `@@ -10,8 +10,9 @@` followed immediately by `@@ -15,6 +16,7 @@`. The overlap between lines 15-17 creates ambiguity about which hunk owns those lines.\n\nThe solution requires either automatic hunk merging when overlap is detected, or intelligent context truncation that ensures clean boundaries between hunks. The `merge_hunks` function should be called whenever the distance between hunks is less than `2 * context_lines + 1`.\n\n⚠️ **Pitfall: Empty File Handling**\n\nEmpty files create edge cases in multiple parts of the diff generation pipeline. When one or both input files are empty, the LCS algorithm may return unexpected results, line numbering becomes ambiguous, and hunk generation may fail to handle the boundary conditions properly.\n\nThe specific failure modes include attempting to access line indices that don't exist, creating hunks with invalid start positions (like line 0), and generating context lines from files that have no content. Some implementations crash when trying to create `DiffLine` objects from non-existent content.\n\nProper empty file handling requires explicit checks at the beginning of the diff generation process. Empty files should generate straightforward hunks: if the first file is empty, create a single hunk that adds all lines from the second file starting at line 1. If the second file is empty, create a single hunk that deletes all lines from the first file.\n\n⚠️ **Pitfall: Line Content Modification vs Line Replacement**\n\nThe unified diff format represents modified lines as a deletion followed by an addition, not as a single \"change\" operation. Developers familiar with other diff tools may attempt to create a \"MODIFIED\" line type, which doesn't exist in the standard format and breaks compatibility with external tools.\n\nThis misconception leads to implementations that try to highlight changed portions within lines or create custom diff formats that aren't interoperable with standard tools like `patch`, `git apply`, or text editors that understand unified diff format.\n\nThe correct approach always represents line modifications as separate DELETE and ADD operations, even when the lines are nearly identical. Word-level or character-level highlighting is a presentation concern that should be handled by output formatting, not by the core diff generation logic.\n\n| Pitfall | Symptom | Root Cause | Fix |\n|---------|---------|------------|-----|\n| Off-by-one line numbers | `patch` command fails to apply diff | Using zero-based indices in output | Add 1 when generating line numbers for external format |\n| No common lines crash | Algorithm error with empty LCS | Assuming LCS contains elements | Check for empty LCS and handle as special case |\n| Overlapping hunk contexts | Invalid diff with conflicting line ranges | Not merging nearby changes | Implement hunk merging when gap < 2*context + 1 |\n| Empty file errors | Array access errors or invalid hunks | Not handling missing content | Explicit empty file checks with appropriate hunk generation |\n| Invalid \"MODIFIED\" operations | Incompatible diff output | Misunderstanding unified diff format | Always use separate DELETE + ADD for changed lines |\n\n### Implementation Guidance\n\nThe `DiffGenerator` component transforms the mathematical output from `LCSEngine` into human-readable editing instructions. This implementation bridges algorithmic computation with practical text processing requirements.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Edit Operation Storage | Python lists with dataclasses | Custom linked list for memory efficiency |\n| Hunk Generation | Linear scan with state machine | Streaming parser for large files |\n| Line Number Tracking | Separate counters for each file | Unified position tracker with offsets |\n| Context Management | Fixed-size windows | Adaptive context based on change density |\n\n**B. Recommended File Structure**\n\n```\ndiff_tool/\n  src/\n    diff_generator/\n      __init__.py              ← exports DiffGenerator, LineType, Hunk\n      diff_generator.py        ← main DiffGenerator class\n      edit_operations.py       ← DiffLine, LineType, edit script generation\n      hunk_formatter.py        ← Hunk class and formation logic\n      context_manager.py       ← context line extraction and merging\n    tests/\n      test_diff_generator.py   ← comprehensive test suite\n      test_hunk_formation.py   ← hunk boundary and merging tests\n      fixtures/\n        simple_diff/           ← basic test cases\n        edge_cases/            ← empty files, no common lines\n        large_files/           ← performance test cases\n```\n\n**C. Infrastructure Starter Code**\n\n**edit_operations.py** - Complete implementation for line classification:\n\n```python\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Tuple\n\nclass LineType(Enum):\n    \"\"\"Classification of lines in diff output.\"\"\"\n    UNCHANGED = \"unchanged\"\n    ADDED = \"added\" \n    DELETED = \"deleted\"\n\n@dataclass\nclass DiffLine:\n    \"\"\"Represents a single line in the diff with its classification and position.\"\"\"\n    content: str\n    line_type: LineType\n    old_line_num: Optional[int]  # None for ADDED lines\n    new_line_num: Optional[int]  # None for DELETED lines\n    \n    def is_change(self) -> bool:\n        \"\"\"Returns True if this line represents a modification (ADD or DELETE).\"\"\"\n        return self.line_type in (LineType.ADDED, LineType.DELETED)\n    \n    def format_unified_diff_line(self) -> str:\n        \"\"\"Format this line for unified diff output with appropriate prefix.\"\"\"\n        if self.line_type == LineType.ADDED:\n            return f\"+{self.content}\"\n        elif self.line_type == LineType.DELETED:\n            return f\"-{self.content}\"\n        else:  # UNCHANGED\n            return f\" {self.content}\"\n\ndef create_diff_line(content: str, line_type: LineType, \n                    old_num: Optional[int] = None, \n                    new_num: Optional[int] = None) -> DiffLine:\n    \"\"\"Factory function for creating properly validated DiffLine objects.\"\"\"\n    # Validate line number consistency with line type\n    if line_type == LineType.ADDED and old_num is not None:\n        raise ValueError(\"ADDED lines should not have old_line_num\")\n    if line_type == LineType.DELETED and new_num is not None:\n        raise ValueError(\"DELETED lines should not have new_line_num\")\n    if line_type == LineType.UNCHANGED and (old_num is None or new_num is None):\n        raise ValueError(\"UNCHANGED lines must have both line numbers\")\n    \n    return DiffLine(content, line_type, old_num, new_num)\n```\n\n**hunk_formatter.py** - Complete implementation for hunk data structure:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom .edit_operations import DiffLine, LineType\n\n@dataclass\nclass Hunk:\n    \"\"\"Represents a group of related changes with surrounding context.\"\"\"\n    old_start: int          # Starting line number in original file (1-indexed)\n    old_count: int          # Number of lines from original file in this hunk\n    new_start: int          # Starting line number in target file (1-indexed) \n    new_count: int          # Number of lines from target file in this hunk\n    lines: List[DiffLine]   # Complete sequence of context and changed lines\n    context_before: int     # Actual leading context lines included\n    context_after: int      # Actual trailing context lines included\n    \n    def format_hunk_header(self) -> str:\n        \"\"\"Generate the @@ header line for this hunk.\"\"\"\n        return f\"@@ -{self.old_start},{self.old_count} +{self.new_start},{self.new_count} @@\"\n    \n    def format_unified_diff(self) -> List[str]:\n        \"\"\"Generate complete unified diff output for this hunk.\"\"\"\n        result = [self.format_hunk_header()]\n        result.extend(line.format_unified_diff_line() for line in self.lines)\n        return result\n    \n    def change_count(self) -> int:\n        \"\"\"Count the number of actual changes (non-context lines) in this hunk.\"\"\"\n        return sum(1 for line in self.lines if line.is_change())\n\ndef validate_hunk_consistency(hunk: Hunk) -> bool:\n    \"\"\"Verify that hunk line counts match actual content.\"\"\"\n    old_lines = sum(1 for line in hunk.lines \n                   if line.line_type in (LineType.UNCHANGED, LineType.DELETED))\n    new_lines = sum(1 for line in hunk.lines \n                   if line.line_type in (LineType.UNCHANGED, LineType.ADDED))\n    \n    return (old_lines == hunk.old_count and \n            new_lines == hunk.new_count)\n\ndef merge_hunks(hunk1: Hunk, hunk2: Hunk, max_gap: int) -> Optional[Hunk]:\n    \"\"\"Merge two adjacent hunks if the gap between them is small enough.\"\"\"\n    # Calculate gap between hunks\n    hunk1_end = hunk1.old_start + hunk1.old_count - 1\n    gap_size = hunk2.old_start - hunk1_end - 1\n    \n    if gap_size > max_gap:\n        return None  # Gap too large to merge\n    \n    # Create merged hunk\n    merged_old_start = hunk1.old_start\n    merged_old_count = hunk2.old_start + hunk2.old_count - hunk1.old_start\n    merged_new_start = hunk1.new_start  \n    merged_new_count = hunk2.new_start + hunk2.new_count - hunk1.new_start\n    \n    # Combine line sequences (implementation would need gap lines added)\n    merged_lines = hunk1.lines + hunk2.lines  # Simplified - needs gap handling\n    \n    return Hunk(\n        old_start=merged_old_start,\n        old_count=merged_old_count,\n        new_start=merged_new_start,\n        new_count=merged_new_count,\n        lines=merged_lines,\n        context_before=hunk1.context_before,\n        context_after=hunk2.context_after\n    )\n```\n\n**D. Core Logic Skeleton Code**\n\n**diff_generator.py** - Main component for learners to implement:\n\n```python\nfrom typing import List, Tuple\nfrom .edit_operations import DiffLine, LineType, create_diff_line\nfrom .hunk_formatter import Hunk, validate_hunk_consistency, merge_hunks\n\nclass DiffGenerator:\n    \"\"\"Converts LCS results into edit operations and groups them into hunks.\"\"\"\n    \n    def __init__(self, default_context_lines: int = 3):\n        self.default_context_lines = default_context_lines\n    \n    def lcs_to_edit_operations(self, lcs: 'CommonSubsequence', \n                             file1_lines: List[str], \n                             file2_lines: List[str]) -> List[DiffLine]:\n        \"\"\"Convert LCS result to sequence of edit operations.\n        \n        Args:\n            lcs: CommonSubsequence result from LCSEngine\n            file1_lines: Lines from original file  \n            file2_lines: Lines from target file\n            \n        Returns:\n            Complete sequence of DiffLine objects representing the transformation\n        \"\"\"\n        # TODO 1: Handle empty LCS case (no common lines between files)\n        # TODO 2: Initialize pointers for file1, file2, and LCS positions\n        # TODO 3: Create main loop that advances through both files simultaneously\n        # TODO 4: For each position, check if current lines match LCS positions\n        # TODO 5: If lines match LCS, create UNCHANGED DiffLine with both line numbers\n        # TODO 6: If file1 line doesn't match LCS, create DELETED DiffLine \n        # TODO 7: If file2 line doesn't match LCS, create ADDED DiffLine\n        # TODO 8: Advance appropriate pointers based on operation type\n        # TODO 9: Handle remaining lines when one file is exhausted\n        # TODO 10: Return complete sequence of DiffLine objects\n        \n        # Hint: Use enumerate() to track line numbers while iterating\n        # Hint: LCS positions list tells you which lines are common\n        # Hint: Convert 0-based list indices to 1-based line numbers for output\n        pass\n    \n    def diff_lines_to_hunks(self, diff_lines: List[DiffLine], \n                           context_lines: int = None) -> List[Hunk]:\n        \"\"\"Group edit operations into hunks with surrounding context.\n        \n        Args:\n            diff_lines: Sequence of DiffLine objects from lcs_to_edit_operations\n            context_lines: Number of context lines around changes (uses default if None)\n            \n        Returns:\n            List of Hunk objects with changes grouped and context included\n        \"\"\"\n        if context_lines is None:\n            context_lines = self.default_context_lines\n            \n        # TODO 1: Handle empty diff_lines list (identical files)\n        # TODO 2: Scan through diff_lines to identify change boundaries  \n        # TODO 3: For each change group, collect surrounding context lines\n        # TODO 4: Determine hunk start/end positions in both files\n        # TODO 5: Extract context_before lines (up to context_lines)\n        # TODO 6: Include all change lines in the group\n        # TODO 7: Extract context_after lines (up to context_lines) \n        # TODO 8: Create Hunk object with proper line counts and positions\n        # TODO 9: Validate hunk consistency using validate_hunk_consistency()\n        # TODO 10: Check if adjacent hunks should be merged using merge_hunks()\n        # TODO 11: Return final list of non-overlapping hunks\n        \n        # Hint: Track current position in both original and target files\n        # Hint: Use sliding window to collect context around changes\n        # Hint: max_gap for merging should be 2 * context_lines\n        pass\n    \n    def generate_diff(self, file1_lines: List[str], file2_lines: List[str], \n                     lcs: 'CommonSubsequence', context_lines: int = None) -> List[Hunk]:\n        \"\"\"Main entry point: convert LCS result to structured diff hunks.\n        \n        Args:\n            file1_lines: Lines from original file\n            file2_lines: Lines from target file  \n            lcs: CommonSubsequence result from LCSEngine.compute_lcs()\n            context_lines: Number of context lines around changes\n            \n        Returns:\n            List of Hunk objects ready for formatting and output\n        \"\"\"\n        # TODO 1: Call lcs_to_edit_operations() to get edit sequence\n        # TODO 2: Call diff_lines_to_hunks() to group operations with context\n        # TODO 3: Return structured hunks ready for output formatting\n        \n        # This is the main pipeline function that coordinates the conversion\n        pass\n```\n\n**E. Language-Specific Hints**\n\n- **Line Number Handling**: Python lists are 0-indexed but diff format uses 1-indexed line numbers. Always add 1 when creating external output.\n- **Dataclass Usage**: Use `@dataclass` for `DiffLine` and `Hunk` to get automatic `__init__`, `__repr__`, and comparison methods.\n- **Enum for LineType**: Use `enum.Enum` for `LineType` to ensure type safety and prevent invalid line classifications.\n- **List Slicing**: Use `lines[start:end]` for extracting context windows around changes.\n- **Optional Type Hints**: Use `Optional[int]` for line numbers that may be None (deleted lines don't have new numbers, added lines don't have old numbers).\n- **Generator Functions**: Consider using `yield` for large files to avoid loading entire diff in memory.\n\n**F. Milestone Checkpoint**\n\nAfter implementing the `DiffGenerator` component, verify correct behavior:\n\n**Test Command**: `python -m pytest tests/test_diff_generator.py -v`\n\n**Expected Output**: All tests pass, including edge cases for empty files, no common lines, and context merging.\n\n**Manual Verification**:\n```bash\n# Test with simple two-line change\npython diff_tool.py file1.txt file2.txt\n\n# Expected output format:\n# @@ -1,4 +1,5 @@\n#  unchanged line\n# -deleted line  \n# +added line\n# +another added line\n#  unchanged line\n```\n\n**Signs of Problems**:\n- Line numbers start at 0 instead of 1 → Check line number conversion\n- Context lines missing → Check hunk boundary calculation  \n- Overlapping hunks → Implement hunk merging logic\n- Crash on empty files → Add empty file handling\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| `patch` command rejects diff | Incorrect line numbering | Check hunk headers for 0-based numbers | Add 1 to all line numbers in output |\n| Missing context lines | Wrong boundary calculation | Print hunk start/end positions | Fix context extraction window logic |\n| Duplicate lines in output | Overlapping hunks not merged | Check gap calculation between hunks | Implement merge_hunks() properly |\n| Crash on identical files | Empty diff_lines list not handled | Test with identical input files | Add empty list check in diff_lines_to_hunks |\n| Wrong hunk line counts | Inconsistent counting logic | Use validate_hunk_consistency() | Count UNCHANGED+DELETED for old, UNCHANGED+ADDED for new |\n\n![Diff Generation Sequence](./diagrams/diff-generation-sequence.svg)\n\nThe `DiffGenerator` component completes the transformation from mathematical algorithm output to practical editing instructions. When properly implemented, it provides the foundation for human-readable diffs that clearly communicate file changes while maintaining compatibility with standard diff tools and workflows.\n\n\n## Output Formatter Component\n\n> **Milestone(s):** Milestone 4: CLI and Color Output — builds command-line interface with colored output and options, plus foundational unified diff format from Milestone 3\n\nThe `OutputFormatter` component represents the final stage in our diff processing pipeline, transforming structured `Hunk` objects into human-readable unified diff format with optional color highlighting and command-line interface integration. This component bridges the gap between our internal diff representation and the standardized output formats that users expect from professional diff tools.\n\n### Mental Model: Publishing Changes\n\nThink of the `OutputFormatter` as a publishing house editor preparing editorial changes for publication. When an author submits a revised manuscript, the editor doesn't just show the raw list of insertions and deletions. Instead, they format the changes using standardized editorial notation — strikethroughs for deletions, highlighting for additions, section markers to show where changes occur, and surrounding context so readers can understand the modifications in their proper setting.\n\nSimilarly, our formatter takes the structured diff information from the `DiffGenerator` and presents it using the universally recognized unified diff format. Just as a publisher might produce different versions of the same content — a black-and-white edition for print, a colorized version for digital readers, or a plain text version for accessibility — our formatter adapts its output based on the target audience and display capabilities.\n\nThe unified diff format serves as the \"standard editorial notation\" of the software world. Every developer recognizes the `-` and `+` prefixes, the `@@` hunk markers, and the context lines surrounding changes. Our job is to generate this format correctly while enhancing it with modern features like color highlighting when appropriate.\n\n### Unified Diff Format\n\nThe unified diff format represents the lingua franca of change visualization in software development. This standardized format emerged from the Unix `diff` utility and has been adopted across virtually every version control system, code review tool, and text comparison application. Understanding its structure is crucial for generating output that integrates seamlessly with existing development workflows.\n\n#### Format Structure and Components\n\nThe unified diff format consists of several distinct sections, each serving a specific purpose in communicating changes between files. At the highest level, a unified diff contains a header section identifying the files being compared, followed by one or more hunks representing groups of changes.\n\n| Component | Format | Purpose | Example |\n|-----------|---------|---------|---------|\n| File Headers | `--- filename1` and `+++ filename2` | Identify source and target files | `--- file1.txt` |\n| Hunk Header | `@@ -old_start,old_count +new_start,new_count @@` | Define line ranges for changes | `@@ -15,7 +15,9 @@` |\n| Context Lines | ` content` (space prefix) | Show unchanged lines around changes | ` def calculate_sum():` |\n| Deleted Lines | `-content` (minus prefix) | Show lines removed from original | `-    return x + y` |\n| Added Lines | `+content` (plus prefix) | Show lines added in new version | `+    return x + y + z` |\n| Optional Context | Additional metadata after `@@` | Provide semantic context | `@@ -15,7 +15,9 @@ class Calculator:` |\n\nThe mathematical precision of the hunk header format deserves special attention. The `@@ -old_start,old_count +new_start,new_count @@` syntax encodes exactly which lines from each file are represented in the hunk. The `old_start` indicates the line number where the hunk begins in the original file, while `old_count` specifies how many lines from the original file are included (both context and deleted lines). Similarly, `new_start` and `new_count` define the corresponding range in the modified file.\n\n> **Critical Insight**: The unified diff format uses **one-indexed line numbers** for human readability, while most programming languages use zero-indexed arrays internally. This off-by-one translation is a frequent source of bugs in diff implementations.\n\n#### Hunk Formation and Context Integration\n\nThe process of converting our internal `Hunk` structures into unified diff format requires careful attention to line numbering, prefix selection, and context integration. Each `DiffLine` within a hunk must be formatted according to its `LineType`, with appropriate prefixes and line number tracking.\n\n```\nFormat Generation Algorithm:\n1. Generate file headers using original file paths\n2. For each hunk in the diff:\n   a. Calculate actual line ranges including context\n   b. Generate hunk header with @@ syntax\n   c. Format each DiffLine with appropriate prefix\n   d. Track line numbers for both files separately\n   e. Ensure context lines appear in correct positions\n3. Validate that line counts match hunk headers\n```\n\nThe line number calculation requires maintaining separate counters for the original and modified files as we process each hunk. Context lines contribute to both file's line counts, deleted lines only increment the original file counter, and added lines only increment the modified file counter.\n\n> **Decision: Line Number Tracking Strategy**\n> - **Context**: Need to generate accurate hunk headers with correct line ranges\n> - **Options Considered**: \n>   1. Pre-calculate all line numbers before formatting\n>   2. Track incrementally during formatting\n>   3. Store line numbers in DiffLine structures\n> - **Decision**: Track incrementally during formatting with validation\n> - **Rationale**: Incremental tracking is memory-efficient and naturally handles edge cases like empty files or hunks with only additions/deletions\n> - **Consequences**: Requires careful counter management but provides flexibility for different output formats\n\n| Line Type | Original Counter | Modified Counter | Output Prefix |\n|-----------|------------------|------------------|---------------|\n| UNCHANGED | +1 | +1 | ` ` (space) |\n| DELETED | +1 | +0 | `-` |\n| ADDED | +0 | +1 | `+` |\n\n#### Header Generation and File Identification\n\nThe unified diff header serves a crucial role in identifying the files being compared and providing metadata for tools that consume the diff output. The standard format uses `---` to identify the original file and `+++` to identify the modified file, followed by optional timestamps and file mode information.\n\nOur implementation focuses on the essential file identification while remaining compatible with standard diff consumers. The header generation must handle several edge cases, including missing files (for new file creation or deletion scenarios), different file paths, and special cases like comparing content from standard input.\n\n| Header Type | Format | Usage | Example |\n|-------------|---------|-------|---------|\n| Original File | `--- filepath` | Identifies source file | `--- /path/to/original.txt` |\n| Modified File | `+++ filepath` | Identifies target file | `+++ /path/to/modified.txt` |\n| New File | `--- /dev/null` | Indicates file creation | When comparing against empty |\n| Deleted File | `+++ /dev/null` | Indicates file deletion | When file was removed |\n| Stdin Input | `--- -` or `+++ -` | Standard input source | For pipe input scenarios |\n\n### Color Output and CLI Interface\n\nModern terminal applications enhance user experience through visual highlighting and interactive features. Our color output system must intelligently detect terminal capabilities, provide user control over formatting, and gracefully degrade when colors are inappropriate or unsupported.\n\n#### ANSI Color Support and TTY Detection\n\nColor output relies on ANSI escape sequences to control text formatting in compatible terminals. However, these control codes can corrupt output when redirected to files or consumed by tools that don't understand ANSI formatting. Our implementation must detect the output destination and apply colors appropriately.\n\n| ANSI Code | Constant | Purpose | Terminal Effect |\n|-----------|----------|---------|-----------------|\n| `\\033[31m` | `RED` | Highlight deletions | Red text |\n| `\\033[32m` | `GREEN` | Highlight additions | Green text |\n| `\\033[0m` | `RESET` | Reset formatting | Return to normal |\n| `\\033[1m` | `BOLD` | Emphasize headers | Bold text |\n| `\\033[2m` | `DIM` | De-emphasize context | Dimmed text |\n\nThe TTY detection process determines whether the output destination supports color formatting. This involves checking if the output is connected to a terminal device rather than being redirected to a file or piped to another program.\n\n```\nTTY Detection Algorithm:\n1. Check if output destination is a terminal device\n2. Verify TERM environment variable indicates color support\n3. Respect user preferences via --no-color flag\n4. Default to plain text for non-interactive environments\n5. Provide --force-color flag for special cases\n```\n\n> **Decision: Color Application Strategy**\n> - **Context**: Need to provide helpful visual highlighting while maintaining compatibility with scripts and tools\n> - **Options Considered**:\n>   1. Always apply colors and let users disable with flags\n>   2. Auto-detect TTY and apply colors only when appropriate\n>   3. Default to no colors and require explicit enabling\n> - **Decision**: Auto-detect TTY with explicit override flags\n> - **Rationale**: Provides the best user experience for interactive use while being safe for scripting and tool integration\n> - **Consequences**: Requires platform-specific TTY detection but maximizes compatibility\n\n#### Command-Line Argument Processing\n\nThe CLI interface provides users with control over diff formatting, output options, and comparison behavior. The argument parsing system must handle file path validation, option conflicts, and provide helpful error messages for invalid usage.\n\n| Argument | Type | Purpose | Default | Validation |\n|----------|------|---------|---------|------------|\n| `file1` | positional | First file to compare | required | Must exist and be readable |\n| `file2` | positional | Second file to compare | required | Must exist and be readable |\n| `--context N` | optional | Context lines around changes | 3 | Must be non-negative integer |\n| `--no-color` | flag | Disable ANSI color output | false | Conflicts with --force-color |\n| `--force-color` | flag | Enable color even for non-TTY | false | Conflicts with --no-color |\n| `--side-by-side` | flag | Enable parallel display mode | false | Future extension |\n| `--unified N` | optional | Unified format context lines | 3 | Synonym for --context |\n\nThe argument validation process must handle various error conditions gracefully, providing specific guidance for common mistakes. File path validation should distinguish between non-existent files, permission errors, and binary file detection.\n\n```\nArgument Processing Flow:\n1. Parse command-line arguments using standard library\n2. Validate file paths and check accessibility\n3. Resolve option conflicts with clear error messages\n4. Set up formatting preferences based on TTY detection\n5. Initialize OutputFormatter with validated configuration\n```\n\n#### Exit Code Conventions\n\nFollowing Unix conventions, our diff tool communicates results through exit codes that scripts and automation tools can interpret programmatically. The exit code convention allows other programs to determine the comparison result without parsing output text.\n\n| Exit Code | Condition | Meaning | Script Usage |\n|-----------|-----------|---------|--------------|\n| 0 | Files identical | No differences found | Success in automation |\n| 1 | Files differ | Differences detected | Expected in many workflows |\n| 2 | Error occurred | File access, parsing, or system error | Requires intervention |\n\nThe exit code generation must occur after all processing completes successfully. Even if differences are found, the program should exit with code 1 (not an error condition) only after generating complete diff output.\n\n#### ColorFormatter Helper Implementation\n\nThe `ColorFormatter` component encapsulates ANSI color logic and provides a clean interface for applying formatting to diff output. This separation allows the main formatting logic to remain readable while isolating platform-specific color handling.\n\n| Method | Parameters | Returns | Purpose |\n|--------|------------|---------|---------|\n| `red(text)` | text: str | str | Apply red formatting to text |\n| `green(text)` | text: str | str | Apply green formatting to text |\n| `bold(text)` | text: str | str | Apply bold formatting to text |\n| `reset()` | none | str | Return RESET escape code |\n| `is_color_enabled()` | none | bool | Check if colors should be applied |\n| `format_diff_line(line, line_type)` | line: str, line_type: LineType | str | Apply appropriate color for line type |\n\nThe color formatting methods should be designed to be no-ops when color output is disabled, allowing the main formatting code to call them unconditionally without performance concerns.\n\n### Common Pitfalls\n\nUnderstanding the common mistakes in diff output formatting helps avoid compatibility issues and user experience problems that can make an otherwise correct diff tool frustrating to use.\n\n⚠️ **Pitfall: ANSI Codes in Redirected Output**\n\nOne of the most frequent issues occurs when ANSI color codes are written to files or pipes, corrupting the output for tools that expect plain text. This happens when developers test their diff tool in a terminal (where colors work correctly) but don't verify behavior when output is redirected.\n\n```\n# Problem: ANSI codes corrupt piped output\n./diff file1.txt file2.txt | less\n# Shows: ^[[32m+added line^[[0m instead of: +added line\n\n# Problem: ANSI codes in saved files  \n./diff file1.txt file2.txt > changes.diff\n# File contains control characters unusable by other tools\n```\n\nThe root cause is failing to detect that output is being redirected rather than displayed in a terminal. The solution requires proper TTY detection that checks whether standard output is connected to a terminal device.\n\n**Detection Strategy**: Check if `sys.stdout.isatty()` returns `True` in Python, or equivalent platform-specific calls. Only enable colors when output goes to an actual terminal.\n\n**Recovery Approach**: Provide `--no-color` and `--force-color` flags so users can override automatic detection when needed for special cases.\n\n⚠️ **Pitfall: Windows Console Color Handling**\n\nWindows terminals historically required special initialization to enable ANSI color support, leading to diff tools that work correctly on Unix systems but display raw escape codes on Windows. Modern Windows terminals support ANSI codes, but older systems and certain console applications may not.\n\n```\n# Problem on older Windows: Raw escape codes displayed\nC:\\> diff file1.txt file2.txt\n←[31m-deleted line←[0m  # Shows literal escape characters\n```\n\n**Detection Strategy**: On Windows, attempt to enable ANSI support using platform-specific APIs, and fall back to plain text if unsuccessful.\n\n**Compatibility Approach**: Consider providing Windows-specific color APIs as an alternative to ANSI codes for maximum compatibility.\n\n⚠️ **Pitfall: Incorrect Line Number Indexing**\n\nThe unified diff format uses one-indexed line numbers for human readability, but internal processing typically uses zero-indexed arrays. This mismatch creates off-by-one errors that make the diff output incompatible with other tools.\n\n```\n# Problem: Zero-indexed line numbers in output\n@@ -0,5 +0,7 @@  # Should be @@ -1,5 +1,7 @@\n context line\n-deleted line\n+added line\n```\n\n**Root Cause**: Directly using internal array indices in hunk headers without converting to one-indexed format.\n\n**Solution Pattern**: Maintain separate counters for display line numbers that start at 1, while keeping internal processing zero-indexed.\n\n⚠️ **Pitfall: Inconsistent Exit Code Usage**\n\nScripts and automation tools rely on exit codes to determine diff results programmatically. Using non-standard exit codes or returning error codes when files simply differ breaks integration with existing workflows.\n\n```\n# Problem: Wrong exit code for differences\n$ diff file1.txt file2.txt; echo $?\nFiles differ\n2  # Should be 1, not 2 (2 indicates error, not differences)\n```\n\n**Standard Convention**: Exit 0 for identical files, exit 1 for different files, exit 2 for errors (file not found, permission denied, etc.).\n\n**Implementation Pattern**: Distinguish between \"differences found\" (expected outcome, exit 1) and \"processing failed\" (unexpected error, exit 2).\n\n⚠️ **Pitfall: Context Line Count Mismatches**\n\nThe hunk header declares how many lines from each file are included in the hunk, but counting errors in the implementation can cause the declared counts to mismatch the actual line content, breaking tools that parse diff output.\n\n```\n# Problem: Header claims 5 lines but content shows 6\n@@ -10,5 +10,5 @@\n context1\n context2  \n-deleted line\n+added line\n context3\n context4  # 6th line but header claims 5\n```\n\n**Root Cause**: Forgetting to include context lines in the count, or miscounting when changes affect the total line count.\n\n**Validation Strategy**: After generating each hunk, verify that the actual line count matches the declared count in the header.\n\n⚠️ **Pitfall: Missing File Header Information**\n\nSome diff output omits the required `---` and `+++` file headers, making the output incompatible with patch tools and version control systems that expect standard unified diff format.\n\n```\n# Problem: Missing file identification headers\n@@ -1,3 +1,3 @@  # Where are the --- and +++ headers?\n-old line\n+new line\n context\n```\n\n**Standard Requirement**: Every unified diff must begin with `--- original_file` and `+++ modified_file` headers before any hunk content.\n\n**Implementation Pattern**: Always generate file headers as the first output, even for simple file comparisons.\n\n### Implementation Guidance\n\nThe `OutputFormatter` transforms structured diff data into human-readable unified diff format with optional color enhancement and CLI integration. This component requires careful attention to formatting standards, terminal compatibility, and command-line conventions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Color Support | Basic ANSI codes with TTY detection | Rich color library with theme support |\n| CLI Parsing | argparse standard library | Click framework with subcommands |\n| Text Formatting | String formatting with templates | Dedicated template engine |\n| Terminal Detection | sys.stdout.isatty() check | termcolor library with capability detection |\n\n#### Recommended File Structure\n\n```\nproject-root/\n├── src/\n│   ├── diff_tool/\n│   │   ├── formatters/\n│   │   │   ├── __init__.py\n│   │   │   ├── output_formatter.py     ← Main OutputFormatter class\n│   │   │   ├── color_formatter.py      ← ANSI color helper\n│   │   │   └── unified_diff.py         ← Unified diff format logic\n│   │   ├── cli/\n│   │   │   ├── __init__.py\n│   │   │   ├── argument_parser.py      ← CLI argument processing\n│   │   │   └── main.py                 ← Entry point with exit codes\n│   │   └── models/\n│   │       └── diff_types.py           ← Hunk, DiffLine types\n├── tests/\n│   ├── formatters/\n│   │   ├── test_output_formatter.py\n│   │   └── test_color_formatter.py\n└── main.py                             ← Application entry point\n```\n\n#### Infrastructure Starter Code\n\n**Color Formatter Helper** (`src/diff_tool/formatters/color_formatter.py`):\n```python\nimport sys\nimport os\nfrom typing import Optional\nfrom enum import Enum\n\nclass ColorMode(Enum):\n    AUTO = \"auto\"\n    ALWAYS = \"always\" \n    NEVER = \"never\"\n\nclass ColorFormatter:\n    # ANSI color constants\n    RED = \"\\033[31m\"\n    GREEN = \"\\033[32m\"\n    BOLD = \"\\033[1m\"\n    DIM = \"\\033[2m\"\n    RESET = \"\\033[0m\"\n    \n    def __init__(self, color_mode: ColorMode = ColorMode.AUTO):\n        self.color_mode = color_mode\n        self._color_enabled = self._determine_color_support()\n    \n    def _determine_color_support(self) -> bool:\n        \"\"\"Determine if color output should be enabled based on mode and terminal.\"\"\"\n        if self.color_mode == ColorMode.NEVER:\n            return False\n        elif self.color_mode == ColorMode.ALWAYS:\n            return True\n        else:  # AUTO mode\n            return (\n                sys.stdout.isatty() and \n                os.getenv('TERM', 'dumb') != 'dumb' and\n                os.getenv('NO_COLOR') is None\n            )\n    \n    def is_color_enabled(self) -> bool:\n        return self._color_enabled\n    \n    def red(self, text: str) -> str:\n        if self._color_enabled:\n            return f\"{self.RED}{text}{self.RESET}\"\n        return text\n    \n    def green(self, text: str) -> str:\n        if self._color_enabled:\n            return f\"{self.GREEN}{text}{self.RESET}\"\n        return text\n    \n    def bold(self, text: str) -> str:\n        if self._color_enabled:\n            return f\"{self.BOLD}{text}{self.RESET}\"\n        return text\n    \n    def dim(self, text: str) -> str:\n        if self._color_enabled:\n            return f\"{self.DIM}{text}{self.RESET}\"\n        return text\n```\n\n**CLI Argument Parser** (`src/diff_tool/cli/argument_parser.py`):\n```python\nimport argparse\nimport sys\nfrom pathlib import Path\nfrom typing import Tuple, Optional\nfrom ..formatters.color_formatter import ColorMode\n\nclass DiffArguments:\n    def __init__(self, file1: Path, file2: Path, context_lines: int = 3, \n                 color_mode: ColorMode = ColorMode.AUTO):\n        self.file1 = file1\n        self.file2 = file2\n        self.context_lines = context_lines\n        self.color_mode = color_mode\n\ndef parse_arguments() -> DiffArguments:\n    parser = argparse.ArgumentParser(\n        description=\"Compare two text files and show differences\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExit codes:\n  0 - files are identical\n  1 - files differ\n  2 - error occurred\n        \"\"\"\n    )\n    \n    parser.add_argument('file1', type=Path, help='First file to compare')\n    parser.add_argument('file2', type=Path, help='Second file to compare')\n    \n    parser.add_argument('-c', '--context', type=int, default=3,\n                       help='Number of context lines around changes (default: 3)')\n    parser.add_argument('-u', '--unified', type=int, dest='context',\n                       help='Unified format with N context lines (synonym for --context)')\n    \n    color_group = parser.add_mutually_exclusive_group()\n    color_group.add_argument('--color', action='store_const', \n                           dest='color_mode', const=ColorMode.ALWAYS,\n                           help='Force color output even when not a TTY')\n    color_group.add_argument('--no-color', action='store_const',\n                           dest='color_mode', const=ColorMode.NEVER, \n                           help='Disable color output')\n    \n    parser.set_defaults(color_mode=ColorMode.AUTO)\n    \n    args = parser.parse_args()\n    \n    # Validate files exist and are readable\n    for file_path in [args.file1, args.file2]:\n        if not file_path.exists():\n            print(f\"Error: File '{file_path}' not found\", file=sys.stderr)\n            sys.exit(2)\n        if not file_path.is_file():\n            print(f\"Error: '{file_path}' is not a regular file\", file=sys.stderr)\n            sys.exit(2)\n    \n    # Validate context lines\n    if args.context < 0:\n        print(\"Error: Context lines must be non-negative\", file=sys.stderr)\n        sys.exit(2)\n    \n    return DiffArguments(args.file1, args.file2, args.context, args.color_mode)\n```\n\n#### Core Logic Skeleton Code\n\n**Output Formatter Main Class** (`src/diff_tool/formatters/output_formatter.py`):\n```python\nfrom typing import List, TextIO\nimport sys\nfrom ..models.diff_types import Hunk, DiffLine, LineType, FileContent\nfrom .color_formatter import ColorFormatter, ColorMode\n\nclass OutputFormatter:\n    def __init__(self, color_mode: ColorMode = ColorMode.AUTO):\n        self.color_formatter = ColorFormatter(color_mode)\n    \n    def format_unified_diff(self, file1: FileContent, file2: FileContent, \n                          hunks: List[Hunk], output: TextIO = sys.stdout) -> None:\n        \"\"\"Generate complete unified diff output with headers and hunks.\"\"\"\n        # TODO 1: Generate and write file headers (--- and +++ lines)\n        # TODO 2: Iterate through hunks and format each one\n        # TODO 3: For each hunk, write hunk header then format all diff lines\n        # TODO 4: Handle empty hunks list (files are identical)\n        # Hint: Use _format_file_headers() and _format_hunk() helper methods\n        pass\n    \n    def _format_file_headers(self, file1: FileContent, file2: FileContent) -> List[str]:\n        \"\"\"Generate --- and +++ header lines identifying the files.\"\"\"\n        # TODO 1: Create --- header with file1 path\n        # TODO 2: Create +++ header with file2 path  \n        # TODO 3: Handle special cases like /dev/null for new/deleted files\n        # TODO 4: Return list of header lines\n        # Hint: Standard format is \"--- filepath\" and \"+++ filepath\"\n        pass\n    \n    def _format_hunk(self, hunk: Hunk) -> List[str]:\n        \"\"\"Format a single hunk with header and diff lines.\"\"\"\n        lines = []\n        \n        # TODO 1: Generate hunk header with @@ -old_start,old_count +new_start,new_count @@\n        # TODO 2: Iterate through hunk.lines and format each DiffLine\n        # TODO 3: Apply appropriate prefix (space, -, +) based on line_type\n        # TODO 4: Apply color formatting if enabled\n        # TODO 5: Validate that actual line count matches header declaration\n        # Hint: Use _format_hunk_header() and _format_diff_line() helpers\n        \n        return lines\n    \n    def _format_hunk_header(self, hunk: Hunk) -> str:\n        \"\"\"Generate the @@ header line for a hunk.\"\"\"\n        # TODO 1: Extract old_start, old_count, new_start, new_count from hunk\n        # TODO 2: Format as \"@@ -old_start,old_count +new_start,new_count @@\"\n        # TODO 3: Handle special case where count is 1 (can omit ,1)\n        # TODO 4: Apply bold formatting if colors are enabled\n        # Hint: Standard unified diff format specification\n        pass\n    \n    def _format_diff_line(self, diff_line: DiffLine) -> str:\n        \"\"\"Format a single diff line with appropriate prefix and color.\"\"\"\n        # TODO 1: Determine prefix character based on diff_line.line_type\n        #         UNCHANGED -> ' ', DELETED -> '-', ADDED -> '+'\n        # TODO 2: Combine prefix with diff_line.content\n        # TODO 3: Apply color formatting based on line type\n        #         DELETED -> red, ADDED -> green, UNCHANGED -> no color\n        # TODO 4: Handle empty lines and lines with only whitespace\n        # Hint: Use self.color_formatter.red/green methods\n        pass\n    \n    def _calculate_line_counts(self, diff_lines: List[DiffLine]) -> tuple[int, int]:\n        \"\"\"Calculate old and new line counts for hunk header.\"\"\"\n        # TODO 1: Count lines that appear in old file (UNCHANGED + DELETED)\n        # TODO 2: Count lines that appear in new file (UNCHANGED + ADDED)  \n        # TODO 3: Return (old_count, new_count) tuple\n        # Hint: Context lines count toward both files\n        pass\n```\n\n**Unified Diff Format Logic** (`src/diff_tool/formatters/unified_diff.py`):\n```python\nfrom typing import List, Optional\nfrom ..models.diff_types import Hunk, DiffLine, LineType\n\ndef validate_hunk_consistency(hunk: Hunk) -> bool:\n    \"\"\"Verify that hunk line counts match actual content.\"\"\"\n    # TODO 1: Count actual UNCHANGED and DELETED lines in hunk.lines\n    # TODO 2: Count actual UNCHANGED and ADDED lines in hunk.lines  \n    # TODO 3: Compare with hunk.old_count and hunk.new_count\n    # TODO 4: Return True only if counts match exactly\n    # Hint: This catches common off-by-one errors in hunk generation\n    pass\n\ndef merge_adjacent_hunks(hunk1: Hunk, hunk2: Hunk, max_gap: int = 3) -> Optional[Hunk]:\n    \"\"\"Merge two hunks if they are close enough together.\"\"\"\n    # TODO 1: Calculate gap between end of hunk1 and start of hunk2\n    # TODO 2: If gap <= max_gap, create merged hunk\n    # TODO 3: Combine line lists and recalculate ranges\n    # TODO 4: Return merged hunk or None if too far apart\n    # Hint: This improves readability by reducing fragmented hunks\n    pass\n\ndef format_line_prefix(line_type: LineType) -> str:\n    \"\"\"Get the standard unified diff prefix for a line type.\"\"\" \n    # TODO 1: Return ' ' for UNCHANGED lines\n    # TODO 2: Return '-' for DELETED lines\n    # TODO 3: Return '+' for ADDED lines\n    # TODO 4: Raise exception for invalid line types\n    # Hint: These prefixes are defined by unified diff standard\n    pass\n```\n\n#### Language-Specific Hints\n\n**Python-Specific Implementation Tips:**\n- Use `sys.stdout.isatty()` for TTY detection on Unix systems\n- Handle Windows console with `colorama` library if advanced color support needed\n- Use `argparse` for CLI parsing - it handles help text and error messages automatically\n- File encoding detection can use `chardet` library for robust encoding detection\n- Use `pathlib.Path` for cross-platform file path handling\n\n**Exit Code Management:**\n```python\n# In main.py entry point\nimport sys\nfrom diff_tool.cli.argument_parser import parse_arguments\nfrom diff_tool.core.diff_engine import DiffEngine\n\ndef main():\n    try:\n        args = parse_arguments()\n        engine = DiffEngine()\n        hunks = engine.compare_files(args.file1, args.file2)\n        \n        formatter = OutputFormatter(args.color_mode)\n        formatter.format_unified_diff(file1, file2, hunks)\n        \n        # Exit 0 if no differences, 1 if differences found\n        exit_code = 0 if not hunks else 1\n        sys.exit(exit_code)\n        \n    except FileNotFoundError as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        sys.exit(2)\n    except PermissionError as e:\n        print(f\"Error: {e}\", file=sys.stderr) \n        sys.exit(2)\n    except Exception as e:\n        print(f\"Unexpected error: {e}\", file=sys.stderr)\n        sys.exit(2)\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the OutputFormatter component, verify correct behavior with these tests:\n\n**Basic Functionality Test:**\n```bash\n# Create test files\necho -e \"line1\\nline2\\nline3\" > test1.txt\necho -e \"line1\\nmodified\\nline3\" > test2.txt\n\n# Run your diff tool\npython -m diff_tool test1.txt test2.txt\n```\n\n**Expected Output:**\n```\n--- test1.txt\n+++ test2.txt\n@@ -1,3 +1,3 @@\n line1\n-line2\n+modified\n line3\n```\n\n**Color Output Test:**\n```bash\n# Should show colors in terminal\npython -m diff_tool test1.txt test2.txt\n\n# Should show no colors when redirected\npython -m diff_tool test1.txt test2.txt > output.diff\ncat output.diff  # Should contain no ANSI codes\n```\n\n**Exit Code Verification:**\n```bash\n# Test identical files\ncp test1.txt test1_copy.txt\npython -m diff_tool test1.txt test1_copy.txt\necho $?  # Should print 0\n\n# Test different files  \npython -m diff_tool test1.txt test2.txt\necho $?  # Should print 1\n\n# Test missing file\npython -m diff_tool test1.txt nonexistent.txt\necho $?  # Should print 2\n```\n\n**Context Lines Test:**\n```bash\n# Create larger test file\nseq 1 20 > large1.txt\nseq 1 20 | sed 's/10/modified/' > large2.txt\n\n# Test different context amounts\npython -m diff_tool --context 1 large1.txt large2.txt\npython -m diff_tool --context 5 large1.txt large2.txt\n```\n\nSigns that implementation is working correctly:\n- Output matches standard `diff -u` format exactly\n- Colors appear in terminal but not in redirected output\n- Exit codes follow Unix conventions (0=same, 1=different, 2=error)\n- Context lines appear symmetrically around changes\n- Line numbers in @@ headers are one-indexed and accurate\n\nCommon issues to debug:\n- Zero-indexed line numbers in output (should be one-indexed)\n- ANSI codes in redirected output (TTY detection failed)\n- Wrong exit codes (check error vs difference handling)\n- Missing file headers (every diff needs --- and +++ lines)\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** All milestones — the component interactions and data flow span from line tokenization (Milestone 1) through LCS computation (Milestone 2), diff generation (Milestone 3), to final CLI output (Milestone 4)\n\nUnderstanding how components communicate and data flows through our diff tool requires grasping the orchestrated sequence of operations that transforms two input files into meaningful, formatted output. Think of this process like an assembly line in a document processing facility, where each station (component) performs specialized operations on standardized work units, passing refined products to the next station until the final formatted comparison report emerges.\n\nThe interactions between `FileReader`, `LCSEngine`, `DiffGenerator`, and `OutputFormatter` follow a pipeline pattern where each component has clearly defined input and output contracts. This architectural choice ensures loose coupling between components while maintaining predictable data transformations throughout the diff computation process.\n\n![System Component Architecture](./diagrams/system-components.svg)\n\n### Component Communication\n\nThe communication between components follows a **message-passing interface pattern** where each component exposes well-defined methods that accept standardized data structures and return predictable outputs. This design choice eliminates tight coupling while ensuring type safety and clear responsibility boundaries.\n\n> **Mental Model: Document Processing Pipeline**\n> \n> Imagine a document processing service where manuscripts arrive at different stations. The intake clerk standardizes format and breaks documents into pages. The analysis department compares pages to find similarities. The editorial team converts similarities into editing instructions. Finally, the publishing department formats instructions for readers. Each department has specific input requirements and output formats, communicating through standardized forms rather than direct collaboration.\n\n**Inter-Component Interface Contracts**\n\nThe component interfaces define the message formats and method signatures that enable seamless communication throughout the diff pipeline:\n\n| Component | Input Interface | Output Interface | Communication Pattern |\n|-----------|----------------|------------------|----------------------|\n| `FileReader` | File paths (strings) | `FileContent` structures | Synchronous method calls |\n| `LCSEngine` | Two `Sequence` objects | `CommonSubsequence` structure | Synchronous computation |\n| `DiffGenerator` | `CommonSubsequence` + original files | `List[Hunk]` structures | Synchronous transformation |\n| `OutputFormatter` | `List[Hunk]` + formatting options | Formatted string output | Synchronous rendering |\n\n**FileReader Communication Interface**\n\nThe `FileReader` component exposes methods that abstract file system operations and return standardized `FileContent` structures. This interface insulates downstream components from file system complexities and encoding variations:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `read_file_lines(filepath)` | `filepath: str` | `List[str]` | Reads file with encoding detection and normalization |\n| `detect_file_encoding(filepath)` | `filepath: str` | `str` | Returns detected encoding (UTF-8 or Latin-1) |\n| `create_file_content(filepath, raw_content, encoding, line_ending)` | `filepath: str, raw_content: str, encoding: str, line_ending: str` | `FileContent` | Factory method for validated content creation |\n| `normalize_line_endings(content)` | `content: str` | `Tuple[str, str]` | Returns normalized content and detected ending type |\n\nThe `FileReader` component communicates through `FileContent` structures that encapsulate all necessary metadata alongside the processed line arrays:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `filepath` | `str` | Original file path for reference and error reporting |\n| `lines` | `List[str]` | Normalized line array with consistent endings removed |\n| `line_count` | `int` | Total number of lines including empty lines |\n| `encoding` | `str` | Detected encoding (UTF-8 or LATIN-1) |\n| `original_endings` | `str` | Original line ending type (LF, CRLF, or CR) |\n\n**LCSEngine Communication Interface**\n\nThe `LCSEngine` component receives `Sequence` objects (type alias for `List[str]`) and returns detailed `CommonSubsequence` structures that contain both the subsequence elements and their positions in the original sequences:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `compute_lcs(sequence1, sequence2)` | `sequence1: Sequence, sequence2: Sequence` | `CommonSubsequence` | Main entry point with memory optimization |\n| `build_lcs_matrix(seq1, seq2)` | `seq1: Sequence, seq2: Sequence` | `List[List[int]]` | Constructs dynamic programming matrix |\n| `backtrack(matrix, seq1, seq2)` | `matrix: List[List[int]], seq1: Sequence, seq2: Sequence` | `List[str]` | Recovers actual LCS from completed matrix |\n| `choose_strategy(seq1_len, seq2_len)` | `seq1_len: int, seq2_len: int` | `str` | Selects algorithm based on memory constraints |\n\nThe `CommonSubsequence` structure provides comprehensive information about the longest common subsequence and its relationship to the original sequences:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `elements` | `List[str]` | The actual longest common subsequence elements |\n| `length` | `int` | Count of elements in the common subsequence |\n| `positions1` | `List[int]` | Indices of LCS elements in first sequence |\n| `positions2` | `List[int]` | Indices of LCS elements in second sequence |\n\n**DiffGenerator Communication Interface**\n\nThe `DiffGenerator` component transforms LCS results into structured edit operations and groups them into contextual hunks for readable output:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `generate_diff(file1_lines, file2_lines, lcs, context_lines)` | `file1_lines: List[str], file2_lines: List[str], lcs: CommonSubsequence, context_lines: int` | `List[Hunk]` | Main entry point for diff generation |\n| `lcs_to_edit_operations(lcs, file1_lines, file2_lines)` | `lcs: CommonSubsequence, file1_lines: List[str], file2_lines: List[str]` | `List[DiffLine]` | Converts LCS to flat edit operations |\n| `diff_lines_to_hunks(lines, context_lines)` | `lines: List[DiffLine], context_lines: int` | `List[Hunk]` | Groups operations into contextual hunks |\n| `create_diff_line(content, line_type, old_num, new_num)` | `content: str, line_type: LineType, old_num: Optional[int], new_num: Optional[int]` | `DiffLine` | Factory method for validated line creation |\n\nThe `DiffLine` structure represents individual edit operations with complete metadata for formatting:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `content` | `str` | The actual line content without diff prefixes |\n| `line_type` | `LineType` | Operation type (UNCHANGED, ADDED, DELETED) |\n| `old_line_num` | `Optional[int]` | Line number in original file (None for ADDED) |\n| `new_line_num` | `Optional[int]` | Line number in new file (None for DELETED) |\n\n**OutputFormatter Communication Interface**\n\nThe `OutputFormatter` component receives structured hunks and produces formatted output with optional color support and various output modes:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `format_unified_diff(file1, file2, hunks, output)` | `file1: FileContent, file2: FileContent, hunks: List[Hunk], output: TextIO` | `None` | Main entry point for generating unified diff output |\n| `red(text)` | `text: str` | `str` | Format text with red ANSI codes if enabled |\n| `green(text)` | `text: str` | `str` | Format text with green ANSI codes if enabled |\n| `bold(text)` | `text: str` | `str` | Format text with bold ANSI codes if enabled |\n| `is_color_enabled()` | None | `bool` | Check if color output is currently enabled |\n\n> **Decision: Synchronous Pipeline Architecture**\n> - **Context**: Components need to communicate and pass data through multiple transformation stages\n> - **Options Considered**: Asynchronous message passing, synchronous method calls, shared memory with notifications\n> - **Decision**: Synchronous method calls with standardized data structures\n> - **Rationale**: Diff computation is inherently sequential (cannot generate hunks until LCS completes), synchronous calls simplify error handling and debugging, standardized structures ensure type safety\n> - **Consequences**: Simple to implement and reason about, clear error propagation, but no parallelization opportunities for large files\n\n![Data Model Relationships](./diagrams/data-model.svg)\n\n### Operation Sequence\n\nThe operation sequence follows a **linear pipeline pattern** where each component completes its processing before passing results to the next stage. This sequential approach matches the mathematical dependencies inherent in diff computation, where each stage requires complete results from the previous stage.\n\nThe overall flow proceeds through four distinct phases: **file preparation**, **similarity analysis**, **difference generation**, and **output formatting**. Each phase has specific responsibilities and produces intermediate results that serve as inputs for subsequent phases.\n\n**Phase 1: File Preparation and Normalization**\n\nThe operation sequence begins when the main program invokes the `FileReader` component with two file paths. This phase focuses on converting raw file system data into normalized, comparable sequences:\n\n1. **File System Access**: The `FileReader` component attempts to open both files, checking for existence and read permissions before proceeding with content extraction.\n\n2. **Encoding Detection**: For each file, `detect_file_encoding()` is called to determine character encoding by attempting UTF-8 decoding first, falling back to Latin-1 for universal byte coverage.\n\n3. **Content Reading**: The `read_file_lines()` method loads the entire file content into memory and applies encoding decoding based on the detected character set.\n\n4. **Line Ending Normalization**: The `normalize_line_endings()` function identifies the original line ending type (LF, CRLF, or CR) and converts all endings to LF for consistent processing.\n\n5. **Line Tokenization**: The `split_preserving_empty_lines()` method breaks content into individual line strings while maintaining empty lines that provide structural information.\n\n6. **Structure Creation**: Two `FileContent` objects are created using `create_file_content()`, encapsulating the normalized line arrays along with metadata about encoding and original line endings.\n\nThe phase completes when both `FileContent` structures are available, containing clean line arrays ready for algorithmic comparison.\n\n**Decision Point: Memory vs. Streaming Trade-off**\n\nAt this stage, the system has loaded both complete files into memory as line arrays. This approach enables random access during LCS computation but limits scalability for extremely large files:\n\n| Approach | Memory Usage | Algorithm Support | Implementation Complexity |\n|----------|-------------|-------------------|-------------------------|\n| Full Load | O(n) per file | Supports all LCS variants | Simple, enables backtracking |\n| Streaming | O(1) per file | Limited algorithm options | Complex, requires specialized algorithms |\n| Hybrid | O(k) sliding window | Most algorithms with modifications | Moderate, good for very large files |\n\n> The full-load approach was chosen because it enables efficient backtracking during LCS computation and supports future algorithm optimizations while maintaining reasonable memory usage for typical source files.\n\n**Phase 2: Similarity Analysis Through LCS**\n\nThe similarity analysis phase transforms the normalized line sequences into a mathematical representation of their longest common subsequence, which forms the foundation for identifying unchanged regions:\n\n1. **Strategy Selection**: The `LCSEngine` calls `choose_strategy()` to select an appropriate algorithm variant based on sequence lengths and available memory, choosing between standard dynamic programming, two-row optimization, or Hirschberg's space-efficient approach.\n\n2. **Matrix Construction**: The `build_lcs_matrix()` method constructs the dynamic programming matrix by iterating through both sequences and applying the LCS recurrence relation to build up optimal subproblem solutions.\n\n3. **Optimal Length Computation**: The matrix construction completes when the bottom-right cell contains the length of the longest common subsequence between the two input sequences.\n\n4. **Subsequence Recovery**: The `backtrack()` method traverses the completed matrix from bottom-right to top-left, reconstructing the actual common subsequence elements by following optimal paths through the matrix.\n\n5. **Position Tracking**: During backtracking, the algorithm records the original positions of each LCS element in both input sequences, enabling precise identification of unchanged regions.\n\n6. **Result Packaging**: The `CommonSubsequence` structure is populated with the recovered elements, their positions in both sequences, and metadata about the computation process.\n\nThe similarity analysis phase completes when the `CommonSubsequence` structure contains complete information about shared content between the two files, ready for transformation into edit operations.\n\n![Diff Generation Sequence](./diagrams/diff-generation-sequence.svg)\n\n**Phase 3: Difference Generation and Contextualization**\n\nThe difference generation phase converts the mathematical LCS result into human-readable edit operations and groups them into contextual hunks for presentation:\n\n1. **Edit Operation Generation**: The `lcs_to_edit_operations()` method processes the `CommonSubsequence` alongside the original line sequences to identify which lines should be marked as UNCHANGED, ADDED, or DELETED.\n\n2. **Line-by-Line Classification**: The algorithm iterates through both input sequences simultaneously, using LCS position information to classify each line according to whether it appears in the common subsequence or represents an insertion or deletion.\n\n3. **Metadata Assignment**: Each edit operation is wrapped in a `DiffLine` structure that includes the line content, operation type, and line numbers from both original files for accurate reporting.\n\n4. **Hunk Formation**: The `diff_lines_to_hunks()` method analyzes the flat sequence of edit operations to identify natural groupings where changes occur close together, forming coherent hunks.\n\n5. **Context Integration**: For each hunk, the algorithm adds configurable numbers of unchanged lines before and after the changes to provide context that helps readers understand the modifications.\n\n6. **Hunk Optimization**: Adjacent hunks with small gaps between them are merged using `merge_adjacent_hunks()` to reduce fragmentation and improve readability of the final output.\n\nThe difference generation phase produces a list of `Hunk` structures, each containing a coherent group of changes with appropriate context for human consumption.\n\n**Decision Point: Context Line Strategy**\n\nThe system must decide how many unchanged lines to include around each change group and when to merge nearby hunks:\n\n| Strategy | Context Lines | Hunk Merging | Readability | Output Size |\n|----------|---------------|--------------|-------------|-------------|\n| Minimal | 0-1 lines | Aggressive merging | Poor for large changes | Compact |\n| Standard | 3 lines | Merge if gap ≤ 6 | Good balance | Moderate |\n| Generous | 5-10 lines | Conservative merging | Excellent readability | Large |\n\n> The standard strategy (3 context lines, merge if gap ≤ 6) was chosen to match conventional diff tool behavior and provide good readability without excessive output size.\n\n**Phase 4: Output Formatting and Presentation**\n\nThe final phase transforms structured hunks into formatted output with appropriate visual styling and standard diff format compliance:\n\n1. **Output Stream Preparation**: The `OutputFormatter` component determines the target output stream and checks for TTY capabilities to decide whether color formatting should be applied.\n\n2. **File Header Generation**: The `_format_file_headers()` method creates the standard diff header lines that identify the compared files, including timestamps and file paths using the --- and +++ prefix convention.\n\n3. **Hunk Processing**: For each hunk in the input list, `_format_hunk()` generates the complete hunk representation including the @@ header line and all constituent diff lines.\n\n4. **Line Formatting**: Individual `DiffLine` objects are processed by `_format_diff_line()` to add appropriate prefixes (space for unchanged, - for deleted, + for added) and apply color formatting when enabled.\n\n5. **Color Application**: When color output is enabled, the `red()`, `green()`, and `bold()` methods apply ANSI escape sequences to highlight deletions, additions, and headers respectively.\n\n6. **Output Generation**: The formatted strings are written to the specified output stream, producing unified diff format that is compatible with standard tools and human-readable.\n\nThe operation sequence completes when all hunks have been formatted and written to the output stream, providing users with a comprehensive view of differences between the compared files.\n\n**Error Propagation Throughout the Pipeline**\n\nError handling follows a **fail-fast strategy** where problems at any stage immediately terminate the pipeline and propagate detailed error information to the user:\n\n| Phase | Potential Failures | Detection Method | Recovery Action |\n|-------|-------------------|------------------|----------------|\n| File Preparation | Missing files, encoding errors, permission issues | Exception handling during file operations | Report specific file system error and exit |\n| Similarity Analysis | Memory exhaustion, algorithm failures | Memory monitoring and computation validation | Switch to memory-efficient algorithm or report limitations |\n| Difference Generation | Logic errors, inconsistent state | Assertion checks and data validation | Report internal error with diagnostic information |\n| Output Formatting | I/O errors, formatting failures | Stream writing exception handling | Report output error and attempt graceful termination |\n\n> **Insight: Pipeline Simplicity vs. Performance**\n> \n> The sequential pipeline design prioritizes correctness and debuggability over performance optimization. While this approach prevents parallelization opportunities, it ensures that each component can be tested independently and errors can be precisely attributed to specific pipeline stages.\n\n**Performance Characteristics of the Pipeline**\n\nThe overall performance characteristics are dominated by the LCS computation phase, which has O(mn) time complexity and determines the processing time for most file comparisons:\n\n| Phase | Time Complexity | Space Complexity | Dominant Factor |\n|-------|----------------|------------------|----------------|\n| File Preparation | O(n + m) | O(n + m) | File I/O and line tokenization |\n| Similarity Analysis | O(mn) | O(mn) or O(min(m,n)) | Dynamic programming matrix |\n| Difference Generation | O(n + m) | O(n + m) | Linear scan through sequences |\n| Output Formatting | O(d) where d = diff lines | O(1) | I/O bandwidth to output stream |\n\nThe pipeline design enables future optimizations such as streaming file reading, memory-efficient LCS variants, or parallel hunk formatting without requiring architectural changes to component interfaces.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Assuming Synchronous Operations Are Thread-Safe**\n\nMany developers assume that because the pipeline uses synchronous method calls, the components can be safely accessed from multiple threads. However, the `LCSEngine` maintains internal state in its matrix field, and the `OutputFormatter` may cache color settings.\n\n**Why this is wrong**: Concurrent access to shared component instances can lead to matrix corruption during LCS computation or inconsistent color formatting. The symptoms include incorrect diff results or garbled output formatting.\n\n**How to fix**: Create separate component instances for each diff operation, or add explicit synchronization around stateful operations. The recommended approach is to treat components as stateless service objects and pass all necessary state as method parameters.\n\n⚠️ **Pitfall: Ignoring Memory Implications of Full Pipeline**\n\nDevelopers often focus on optimizing individual components without considering the cumulative memory usage of the entire pipeline. Each phase creates intermediate data structures that exist simultaneously in memory.\n\n**Why this is wrong**: For large files, the memory footprint includes original file content, normalized line arrays, LCS matrix, edit operations list, and formatted output buffers all existing at once. This can lead to memory exhaustion even when individual components seem efficient.\n\n**How to fix**: Implement pipeline streaming where intermediate results are processed and discarded. Consider using generator patterns for large file processing, or implement explicit memory management with cleanup between phases.\n\n⚠️ **Pitfall: Inadequate Error Context Across Component Boundaries**\n\nWhen errors occur deep in the pipeline, developers often lose important context about which files were being processed or what stage failed. Generic exception handling obscures the specific operation that encountered problems.\n\n**Why this is wrong**: Users receive unhelpful error messages like \"encoding error\" without knowing which file caused the problem or what encoding was detected. This makes debugging extremely difficult for end users.\n\n**How to fix**: Wrap exceptions with additional context at each component boundary. Include file paths, detected encodings, sequence lengths, and operation phase in error messages. Create structured error types that carry diagnostic information through the pipeline.\n\n### Implementation Guidance\n\nThe interaction and data flow implementation requires careful orchestration of component method calls while maintaining clean separation of concerns and robust error handling throughout the pipeline.\n\n**A. Technology Recommendations**\n\n| Component Interface | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Error Handling | Basic try/catch with print statements | Structured logging with error types and context |\n| Data Validation | Manual assertions in component methods | Formal contracts with pre/post-condition checking |\n| Memory Management | Default garbage collection | Explicit memory monitoring and optimization strategies |\n| Pipeline Orchestration | Direct method calls in main function | Pipeline builder pattern with configurable stages |\n\n**B. Recommended File Structure**\n\n```\ndiff-tool/\n  main.py                          ← pipeline orchestration and CLI entry point\n  components/\n    file_reader.py                 ← FileReader component implementation\n    lcs_engine.py                  ← LCSEngine component implementation  \n    diff_generator.py              ← DiffGenerator component implementation\n    output_formatter.py            ← OutputFormatter component implementation\n  data_model/\n    types.py                       ← FileContent, CommonSubsequence, Hunk, DiffLine\n    enums.py                       ← LineType, ColorMode constants\n  utils/\n    error_handling.py              ← Pipeline error types and context management\n    memory_monitoring.py           ← Memory usage tracking and optimization\n  tests/\n    test_pipeline_integration.py   ← End-to-end pipeline testing\n    test_component_interfaces.py   ← Component boundary and contract testing\n```\n\n**C. Pipeline Orchestration Infrastructure**\n\nComplete pipeline coordinator that manages component interaction and error propagation:\n\n```python\n\"\"\"\nPipeline orchestrator that coordinates component interactions and manages\nerror propagation throughout the diff computation process.\n\"\"\"\n\nimport sys\nimport traceback\nfrom typing import List, Optional, TextIO\nfrom dataclasses import dataclass\nfrom components.file_reader import FileReader\nfrom components.lcs_engine import LCSEngine\nfrom components.diff_generator import DiffGenerator\nfrom components.output_formatter import OutputFormatter\nfrom data_model.types import FileContent, CommonSubsequence, Hunk\n\n@dataclass\nclass PipelineContext:\n    \"\"\"Context information passed through pipeline stages for error reporting.\"\"\"\n    file1_path: str\n    file2_path: str\n    current_stage: str\n    stage_progress: float\n    memory_limit_mb: Optional[float] = None\n    debug_mode: bool = False\n\nclass PipelineError(Exception):\n    \"\"\"Base exception for pipeline errors with context information.\"\"\"\n    def __init__(self, message: str, context: PipelineContext, cause: Exception = None):\n        super().__init__(message)\n        self.context = context\n        self.cause = cause\n\nclass DiffPipeline:\n    \"\"\"Main pipeline coordinator managing component interactions.\"\"\"\n    \n    def __init__(self, context_lines: int = 3, enable_color: bool = True):\n        self.file_reader = FileReader()\n        self.lcs_engine = LCSEngine()\n        self.diff_generator = DiffGenerator()\n        self.output_formatter = OutputFormatter(enable_color=enable_color)\n        self.context_lines = context_lines\n    \n    def run_diff(self, file1_path: str, file2_path: str, output: TextIO = sys.stdout) -> int:\n        \"\"\"\n        Execute complete diff pipeline and return exit code.\n        Returns 0 if files identical, 1 if different, 2 if error.\n        \"\"\"\n        context = PipelineContext(file1_path, file2_path, \"initialization\", 0.0)\n        \n        try:\n            # Phase 1: File preparation\n            context.current_stage = \"file_preparation\"\n            context.stage_progress = 0.1\n            file1_content, file2_content = self._prepare_files(context)\n            \n            # Phase 2: LCS computation  \n            context.current_stage = \"lcs_computation\"\n            context.stage_progress = 0.3\n            lcs_result = self._compute_similarity(file1_content, file2_content, context)\n            \n            # Phase 3: Diff generation\n            context.current_stage = \"diff_generation\" \n            context.stage_progress = 0.7\n            hunks = self._generate_differences(file1_content, file2_content, lcs_result, context)\n            \n            # Phase 4: Output formatting\n            context.current_stage = \"output_formatting\"\n            context.stage_progress = 0.9\n            self._format_output(file1_content, file2_content, hunks, output, context)\n            \n            # Return appropriate exit code\n            return 0 if len(hunks) == 0 else 1\n            \n        except PipelineError as e:\n            self._handle_pipeline_error(e, output)\n            return 2\n        except Exception as e:\n            pipeline_error = PipelineError(f\"Unexpected error in {context.current_stage}\", context, e)\n            self._handle_pipeline_error(pipeline_error, output)\n            return 2\n\n    def _prepare_files(self, context: PipelineContext) -> tuple[FileContent, FileContent]:\n        \"\"\"Phase 1: Read and normalize both input files.\"\"\"\n        try:\n            file1_content = self.file_reader.read_file_content(context.file1_path)\n            file2_content = self.file_reader.read_file_content(context.file2_path) \n            return file1_content, file2_content\n        except Exception as e:\n            raise PipelineError(f\"Failed to read input files: {str(e)}\", context, e)\n\n    def _compute_similarity(self, file1: FileContent, file2: FileContent, context: PipelineContext) -> CommonSubsequence:\n        \"\"\"Phase 2: Compute longest common subsequence.\"\"\"\n        try:\n            sequence1 = file1.lines\n            sequence2 = file2.lines\n            return self.lcs_engine.compute_lcs(sequence1, sequence2)\n        except Exception as e:\n            raise PipelineError(f\"LCS computation failed: {str(e)}\", context, e)\n\n    def _generate_differences(self, file1: FileContent, file2: FileContent, \n                            lcs: CommonSubsequence, context: PipelineContext) -> List[Hunk]:\n        \"\"\"Phase 3: Convert LCS to diff hunks.\"\"\"\n        try:\n            return self.diff_generator.generate_diff(file1.lines, file2.lines, lcs, self.context_lines)\n        except Exception as e:\n            raise PipelineError(f\"Diff generation failed: {str(e)}\", context, e)\n\n    def _format_output(self, file1: FileContent, file2: FileContent, \n                      hunks: List[Hunk], output: TextIO, context: PipelineContext):\n        \"\"\"Phase 4: Format and write output.\"\"\"\n        try:\n            self.output_formatter.format_unified_diff(file1, file2, hunks, output)\n        except Exception as e:\n            raise PipelineError(f\"Output formatting failed: {str(e)}\", context, e)\n\n    def _handle_pipeline_error(self, error: PipelineError, output: TextIO):\n        \"\"\"Handle pipeline errors with appropriate user messaging.\"\"\"\n        print(f\"diff-tool: error in {error.context.current_stage}\", file=sys.stderr)\n        print(f\"Files: {error.context.file1_path}, {error.context.file2_path}\", file=sys.stderr)\n        print(f\"Error: {str(error)}\", file=sys.stderr)\n        \n        if error.context.debug_mode and error.cause:\n            print(\"Debug traceback:\", file=sys.stderr)\n            traceback.print_exception(type(error.cause), error.cause, error.cause.__traceback__)\n```\n\n**D. Component Interface Contracts**\n\nInterface validation utilities that ensure components conform to expected contracts:\n\n```python\n\"\"\"\nComponent interface validation and contract enforcement for pipeline integrity.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import List, Protocol\nfrom data_model.types import FileContent, CommonSubsequence, Hunk, Sequence\n\nclass FileReaderInterface(Protocol):\n    \"\"\"Contract for file reading components.\"\"\"\n    \n    def read_file_content(self, filepath: str) -> FileContent:\n        \"\"\"Read file with encoding detection and normalization.\"\"\"\n        pass\n    \n    def detect_file_encoding(self, filepath: str) -> str:\n        \"\"\"Detect file encoding, returns 'UTF-8' or 'LATIN-1'.\"\"\"\n        pass\n\nclass LCSEngineInterface(Protocol):\n    \"\"\"Contract for LCS computation components.\"\"\"\n    \n    def compute_lcs(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:\n        \"\"\"Compute longest common subsequence with position tracking.\"\"\"\n        pass\n    \n    def choose_strategy(self, seq1_len: int, seq2_len: int) -> str:\n        \"\"\"Select algorithm strategy based on input size.\"\"\"\n        pass\n\nclass DiffGeneratorInterface(Protocol):\n    \"\"\"Contract for diff generation components.\"\"\"\n    \n    def generate_diff(self, file1_lines: List[str], file2_lines: List[str], \n                     lcs: CommonSubsequence, context_lines: int) -> List[Hunk]:\n        \"\"\"Generate contextual diff hunks from LCS result.\"\"\"\n        pass\n\nclass OutputFormatterInterface(Protocol):\n    \"\"\"Contract for output formatting components.\"\"\"\n    \n    def format_unified_diff(self, file1: FileContent, file2: FileContent,\n                          hunks: List[Hunk], output) -> None:\n        \"\"\"Format hunks as unified diff with optional color.\"\"\"\n        pass\n\ndef validate_component_contracts():\n    \"\"\"Runtime validation that components implement required interfaces.\"\"\"\n    # This would contain runtime checks for interface compliance\n    pass\n```\n\n**E. Core Pipeline Logic Skeleton**\n\nMain pipeline orchestration with detailed TODO comments for implementation:\n\n```python\ndef run_diff_pipeline(file1_path: str, file2_path: str, context_lines: int = 3) -> int:\n    \"\"\"\n    Execute the complete diff pipeline from file input to formatted output.\n    Returns exit code: 0 if identical, 1 if different, 2 if error.\n    \"\"\"\n    \n    # TODO 1: Initialize all four pipeline components\n    # - Create FileReader instance for file operations\n    # - Create LCSEngine instance for similarity computation\n    # - Create DiffGenerator instance for edit operation generation  \n    # - Create OutputFormatter instance with color settings\n    \n    # TODO 2: Phase 1 - File Preparation\n    # - Call file_reader.read_file_content() for both files\n    # - Handle file system errors (missing files, permissions, encoding)\n    # - Store FileContent structures for both input files\n    # - Validate that both files were read successfully\n    \n    # TODO 3: Phase 2 - LCS Computation\n    # - Extract line sequences from FileContent.lines\n    # - Call lcs_engine.compute_lcs() with both sequences\n    # - Handle potential memory exhaustion for large files\n    # - Store CommonSubsequence result for next phase\n    \n    # TODO 4: Phase 3 - Diff Generation\n    # - Call diff_generator.generate_diff() with files, LCS, and context_lines\n    # - Handle edge cases (no common lines, identical files)\n    # - Store List[Hunk] result for formatting\n    \n    # TODO 5: Phase 4 - Output Formatting\n    # - Call output_formatter.format_unified_diff() with all hunks\n    # - Handle output stream errors and color formatting\n    # - Ensure proper unified diff format compliance\n    \n    # TODO 6: Exit Code Logic\n    # - Return 0 if hunks list is empty (files identical)\n    # - Return 1 if hunks exist (files different)  \n    # - Return 2 if any phase encountered errors\n    # Hint: len(hunks) == 0 indicates identical files\n    \n    pass  # Replace with implementation\n```\n\n**F. Error Context Management**\n\n```python\n\"\"\"Error handling utilities for maintaining context through pipeline stages.\"\"\"\n\nclass ErrorContext:\n    \"\"\"Tracks pipeline execution context for detailed error reporting.\"\"\"\n    \n    def __init__(self, file1_path: str, file2_path: str):\n        self.file1_path = file1_path\n        self.file2_path = file2_path\n        self.current_phase = \"initialization\"\n        self.phase_data = {}\n    \n    def enter_phase(self, phase_name: str, **phase_info):\n        \"\"\"Enter new pipeline phase with context information.\"\"\"\n        # TODO: Store phase name and optional phase-specific data\n        # TODO: Record timestamp for performance monitoring\n        pass\n    \n    def add_context(self, key: str, value):\n        \"\"\"Add contextual information for current phase.\"\"\"\n        # TODO: Store key-value context data for error reporting\n        pass\n    \n    def format_error_message(self, error: Exception) -> str:\n        \"\"\"Format error with full pipeline context.\"\"\"\n        # TODO: Create comprehensive error message including:\n        # - File paths being processed\n        # - Current pipeline phase\n        # - Phase-specific context data\n        # - Original exception message\n        pass\n```\n\n**G. Milestone Checkpoints**\n\nAfter implementing the component interactions and data flow:\n\n**Checkpoint 1: Pipeline Assembly**\n- Run: `python main.py file1.txt file2.txt`\n- Expected: Program executes without import errors and attempts file reading\n- Verify: Error messages mention specific pipeline phases when components are missing\n- Signs of problems: Import errors, component instantiation failures, missing method errors\n\n**Checkpoint 2: Component Communication**\n- Create two simple text files with known differences\n- Run pipeline and verify each component receives expected inputs\n- Expected: FileReader produces FileContent, LCSEngine receives line sequences  \n- Signs of problems: Type errors at component boundaries, None values passed between stages\n\n**Checkpoint 3: Error Propagation**\n- Test with non-existent file, binary file, and permission-denied file\n- Expected: Specific error messages identifying problem file and pipeline stage\n- Verify: Exit codes match conventions (0=same, 1=different, 2=error)\n- Signs of problems: Generic error messages, wrong exit codes, unhandled exceptions\n\n**H. Debugging Pipeline Issues**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Pipeline hangs indefinitely | LCS matrix too large for memory | Monitor memory usage during execution | Implement memory-efficient LCS strategy |\n| Wrong exit codes returned | Logic error in hunk counting | Print len(hunks) before return statement | Fix identical file detection logic |\n| Components can't communicate | Interface mismatch between components | Check method signatures and return types | Ensure consistent data structure usage |\n| Memory usage grows without bound | Intermediate results not freed | Profile memory usage by phase | Add explicit cleanup between phases |\n| Error messages lack context | Generic exception handling | Add logging at each component boundary | Implement structured error context |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones — robust error handling is essential throughout line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)\n\nThink of error handling in a diff tool like building a bridge across a river. The bridge must withstand not just normal traffic, but also storms, floods, and unexpected loads. Similarly, our diff tool must handle not just well-formed text files, but also missing files, permission denied errors, binary content, memory exhaustion, and malformed inputs. A diff tool that crashes on edge cases is like a bridge that collapses in bad weather — it fails exactly when users need it most.\n\nThe complexity of error handling in text comparison tools comes from the intersection of multiple failure domains: the file system layer can fail with I/O errors, the encoding detection layer can encounter binary or malformed data, the algorithm layer can exhaust memory on large inputs, and the output layer can fail when writing to pipes or terminals. Each layer must fail gracefully while preserving enough context for meaningful error messages and recovery strategies.\n\nOur error handling strategy follows a **fail-fast principle** with **contextual error propagation**. Rather than attempting to recover from fundamental errors like missing files, we detect problems early and provide clear diagnostic information. This approach prevents cascading failures where one component's silent error leads to mysterious failures in downstream components.\n\n> **Design Principle:** Error messages should answer three questions: What went wrong? Why did it happen? What can the user do about it?\n\n### File System Errors\n\nThe `FileReader` component operates at the boundary between our application and the unreliable external world of file systems. File system operations can fail in numerous ways, each requiring different detection strategies and recovery approaches.\n\n**Encoding Detection Failures**\n\nEncoding detection represents one of the most subtle error scenarios in text processing. The `detect_file_encoding` function attempts UTF-8 decoding first, falling back to Latin-1 if UTF-8 fails. However, this process can encounter several failure modes that require careful handling.\n\n| Failure Mode | Detection Strategy | Recovery Approach | Error Context |\n|--------------|-------------------|-------------------|---------------|\n| Binary File | UTF-8 decode raises `UnicodeDecodeError` with null bytes | Detect binary content and refuse to process | \"File appears to be binary (contains null bytes at position X)\" |\n| Truncated UTF-8 | Incomplete multibyte sequence at file end | Check for incomplete sequences in last 4 bytes | \"File contains truncated UTF-8 sequence at end\" |\n| Mixed Encodings | UTF-8 decode succeeds partially then fails | Track decode position and report first failure | \"File contains mixed encodings starting at line X\" |\n| Zero-Length File | File exists but contains no data | Check file size before encoding detection | \"Empty file - no content to compare\" |\n| Very Large File | File size exceeds available memory | Check file size against memory limits | \"File too large (X MB) - exceeds memory limit (Y MB)\" |\n\nThe encoding detection process must distinguish between recoverable encoding issues and fundamental problems. Binary files containing executable code or images should be rejected with clear error messages, while text files with minor encoding issues might be processable with warnings.\n\n**File Access Permission Errors**\n\nFile permission errors occur at multiple points in the pipeline and require different handling strategies depending on when they're encountered:\n\n| Access Phase | Error Scenarios | Detection Method | Recovery Strategy |\n|--------------|-----------------|------------------|------------------|\n| Initial Open | File doesn't exist, permission denied, directory instead of file | `os.open()` raises `FileNotFoundError`, `PermissionError`, `IsADirectoryError` | Immediate failure with specific error message |\n| Size Check | File exists but `stat()` permission denied | `os.stat()` raises `PermissionError` | Skip size optimization, attempt direct read |\n| Content Read | Partial read permission (some bytes readable) | `file.read()` returns fewer bytes than expected | Report partial read with byte counts |\n| Lock Conflicts | Another process has exclusive lock on file | Read operation blocks or raises OS-specific error | Timeout with suggestion to check file usage |\n\nPermission errors must be reported with sufficient context for users to understand the problem. Rather than generic \"access denied\" messages, we provide specific information about which operation failed and potential causes.\n\n**Line Ending and Structure Errors**\n\nThe line tokenization process can encounter malformed file structures that challenge our assumptions about text format:\n\n| Structure Issue | Detection Approach | Handling Strategy | User Impact |\n|----------------|-------------------|-------------------|-------------|\n| Mixed Line Endings | Track `\\n`, `\\r\\n`, `\\r` patterns across file | Normalize to LF, warn about mixed format | \"Warning: File contains mixed line endings (X Unix, Y Windows, Z Mac)\" |\n| Very Long Lines | Line exceeds reasonable length threshold (e.g., 1MB) | Split at threshold with continuation marker | \"Warning: Lines truncated at 1MB limit (affects lines X, Y, Z)\" |\n| Null Characters | Embedded null bytes in otherwise text file | Count nulls and report positions | \"Warning: Text file contains X null characters (binary data?)\" |\n| Control Characters | Non-printable characters except common whitespace | Track unusual control character usage | \"Warning: File contains unusual control characters\" |\n\nThe `split_preserving_empty_lines` function must handle these edge cases while maintaining the structural integrity needed for accurate line-by-line comparison. Each anomaly should be logged with sufficient detail for debugging while not preventing comparison when possible.\n\n> **Decision: Graceful Degradation for File Structure Issues**\n> - **Context**: Text files in practice contain various anomalies that shouldn't prevent comparison\n> - **Options Considered**: Strict rejection, silent normalization, graceful degradation with warnings\n> - **Decision**: Graceful degradation with detailed warnings\n> - **Rationale**: Users often need to compare imperfect files; warnings preserve utility while flagging issues\n> - **Consequences**: Requires careful anomaly detection and clear warning messages, but maximizes tool usefulness\n\n### Algorithm Edge Cases\n\nThe LCS algorithm and diff generation process encounter mathematical and computational edge cases that can cause subtle bugs or catastrophic failures. These scenarios often arise from boundary conditions in the dynamic programming algorithm or resource exhaustion during computation.\n\n**Empty and Identical File Scenarios**\n\nEmpty files and identical files represent the mathematical boundaries of the diff problem space. These cases must be handled efficiently without invoking the full LCS computation:\n\n| Scenario | Detection Point | Optimization Strategy | Expected Output |\n|----------|----------------|----------------------|-----------------|\n| Both Files Empty | After line tokenization, both `line_count` == 0 | Skip LCS computation entirely | \"Files are identical (both empty)\" |\n| One File Empty | One `line_count` == 0, other > 0 | Generate pure addition or deletion diff | All lines marked as ADDED or DELETED |\n| Files Identical | Early hash comparison or line-by-line check | Skip LCS computation | \"Files are identical\" |\n| Single Line Files | Both `line_count` == 1 | Direct comparison without matrix | Either identical or single-line diff |\n\nThe `LCSEngine` component must detect these scenarios before constructing the dynamic programming matrix. Attempting to build a matrix for empty sequences can cause index errors, while building matrices for identical files wastes computational resources.\n\n**Memory Exhaustion Scenarios**\n\nLarge file comparisons can exhaust available memory during LCS matrix construction. The standard dynamic programming approach requires O(m×n) space, which becomes prohibitive for files with hundreds of thousands of lines:\n\n| File Size Scenario | Memory Requirements | Detection Strategy | Mitigation Approach |\n|--------------------|-------------------|-------------------|-------------------|\n| Small Files (<1000 lines each) | <1MB matrix memory | No detection needed | Standard O(mn) algorithm |\n| Medium Files (1000-10000 lines) | 1-100MB matrix memory | Check available system memory | Standard algorithm with progress monitoring |\n| Large Files (10000-100000 lines) | 100MB-10GB matrix memory | Pre-calculate memory needs | Switch to two-row optimization |\n| Huge Files (>100000 lines) | >10GB matrix memory | Memory requirement exceeds limits | Switch to Hirschberg's algorithm or refuse |\n\nThe `choose_strategy` method in `LCSEngine` must evaluate these scenarios before beginning computation. Memory estimation must account for the matrix storage plus additional structures like the backtracking path and intermediate results.\n\n**LCS Computation Edge Cases**\n\nThe dynamic programming algorithm itself can encounter numerical and logical edge cases that lead to incorrect results or infinite loops:\n\n| Edge Case | Manifestation | Detection Method | Correction Strategy |\n|-----------|---------------|------------------|-------------------|\n| Off-by-One Indexing | Matrix bounds errors, incorrect LCS length | Boundary condition testing with known inputs | Careful index validation in matrix construction |\n| No Common Lines | LCS length is 0, backtracking finds empty sequence | Check `lcs.length == 0` after computation | Generate pure addition/deletion diff |\n| All Lines Identical | LCS equals entire shorter file | `lcs.length == min(len(seq1), len(seq2))` | Optimize to avoid full matrix computation |\n| Repeated Line Patterns | Multiple valid LCS paths of same length | Backtracking algorithm must choose consistently | Use consistent tie-breaking rules |\n\nThe backtracking algorithm in particular must handle cases where multiple paths through the matrix yield equally valid longest common subsequences. Consistency in tie-breaking ensures that repeated runs on the same input produce identical output.\n\n**Diff Generation Edge Cases**\n\nConverting LCS results to edit operations and hunks introduces additional edge cases related to line numbering and hunk boundary detection:\n\n| Generation Issue | Problem Manifestation | Detection Approach | Resolution Method |\n|------------------|----------------------|-------------------|-------------------|\n| Line Number Misalignment | Hunk headers show wrong line ranges | Validate line counts against actual content | Recalculate line numbers during hunk formation |\n| Empty Hunks | Hunk contains no actual changes | Check that `hunk.lines` contains at least one ADD or DELETE | Filter empty hunks before output |\n| Overlapping Context | Adjacent hunks have overlapping context lines | Calculate context overlap during hunk merging | Merge hunks or adjust context boundaries |\n| File Boundary Context | Context lines requested beyond file start/end | Check context line numbers against file bounds | Clamp context to file boundaries |\n\nThe `diff_lines_to_hunks` function must validate hunk consistency after formation. Each hunk's line count claims must match the actual number of lines in its content, and line numbering must remain consistent across hunk boundaries.\n\n**Resource Limit Enforcement**\n\nBeyond memory exhaustion, the diff tool must handle other resource constraints that can cause degraded performance or failures:\n\n| Resource Constraint | Limit Detection | Graceful Degradation | User Communication |\n|-------------------|-----------------|---------------------|-------------------|\n| CPU Time | Track computation elapsed time | Interrupt after timeout, provide partial results | \"Computation timed out after X seconds - files too complex\" |\n| File Handle Limits | Monitor open file descriptors | Close files promptly, reopen as needed | \"System file handle limit reached\" |\n| Disk Space | Check available space before writing output | Stream output, avoid temporary files | \"Insufficient disk space for output\" |\n| Network File Systems | Detect network mount points | Warn about potential latency | \"Warning: Comparing files over network - may be slow\" |\n\nThe `PerformanceMonitor` component tracks these resource constraints and provides early warnings when limits are approached. Rather than silent failures or mysterious hangs, users receive clear information about resource constraints and potential workarounds.\n\n> ⚠️ **Pitfall: Silent Memory Exhaustion**\n> \n> A common mistake is allowing the LCS matrix construction to consume all available memory, causing the system to swap heavily or the process to be killed by the OS. This manifests as extreme slowness or sudden termination without error messages. The fix is to estimate memory requirements before allocation and either use memory-efficient algorithms or refuse to process files that exceed reasonable limits. Always check `matrix_size * sizeof(int) < available_memory` before proceeding.\n\n> ⚠️ **Pitfall: Integer Overflow in Line Counting**\n> \n> Very large files can cause integer overflow when calculating line numbers or matrix indices, leading to negative line numbers or array bounds errors. This typically occurs with files containing millions of lines. The fix is to use appropriate integer types (64-bit integers in most cases) and validate that line counts remain within reasonable bounds. Check for `line_count > MAX_SAFE_LINES` and refuse to process impossibly large files.\n\n### Implementation Guidance\n\nThe error handling implementation must balance comprehensive coverage with maintainable code structure. Python's exception hierarchy and context managers provide excellent tools for building robust error handling.\n\n**Technology Recommendations**\n\n| Error Handling Aspect | Simple Option | Advanced Option |\n|----------------------|---------------|-----------------|\n| Exception Types | Built-in exceptions (`FileNotFoundError`, `MemoryError`) | Custom exception hierarchy with error codes |\n| Memory Monitoring | `psutil.virtual_memory()` | Custom memory tracking with allocation hooks |\n| File Operations | Standard `open()` with try/except | `pathlib.Path` with comprehensive error mapping |\n| Logging | Python `logging` module | Structured logging with JSON output |\n| Resource Limits | Manual checks before operations | `resource` module with automatic enforcement |\n\n**File Structure for Error Handling**\n\n```\ndiff_tool/\n  src/\n    exceptions.py           ← Custom exception definitions\n    error_handlers.py       ← Error detection and recovery strategies\n    resource_monitor.py     ← Memory and resource tracking\n    file_reader.py         ← File operations with error handling\n    lcs_engine.py          ← Algorithm with memory management\n    diff_generator.py      ← Generation with validation\n    output_formatter.py    ← Output with I/O error handling\n  tests/\n    test_error_cases.py    ← Comprehensive error scenario testing\n    fixtures/\n      binary_file.exe      ← Test fixture for binary detection\n      empty_file.txt       ← Empty file test case\n      huge_file.txt        ← Large file for memory testing\n```\n\n**Custom Exception Hierarchy (Complete Implementation)**\n\n```python\n\"\"\"\nCustom exceptions for diff tool with structured error information.\nProvides context and recovery suggestions for different failure modes.\n\"\"\"\n\nclass DiffToolError(Exception):\n    \"\"\"Base exception for all diff tool errors with context tracking.\"\"\"\n    \n    def __init__(self, message, context=None, suggestion=None):\n        super().__init__(message)\n        self.context = context or {}\n        self.suggestion = suggestion\n        self.error_code = getattr(self.__class__, 'ERROR_CODE', 'UNKNOWN')\n    \n    def format_error(self):\n        \"\"\"Format error with context and suggestions for user display.\"\"\"\n        lines = [f\"Error: {self}\"]\n        \n        if self.context:\n            lines.append(\"Context:\")\n            for key, value in self.context.items():\n                lines.append(f\"  {key}: {value}\")\n        \n        if self.suggestion:\n            lines.append(f\"Suggestion: {self.suggestion}\")\n        \n        return \"\\n\".join(lines)\n\nclass FileSystemError(DiffToolError):\n    \"\"\"File system operation failures with specific error codes.\"\"\"\n    ERROR_CODE = 'FILE_SYSTEM'\n\nclass EncodingError(DiffToolError):\n    \"\"\"File encoding detection and processing failures.\"\"\"\n    ERROR_CODE = 'ENCODING'\n\nclass AlgorithmError(DiffToolError):\n    \"\"\"LCS computation and diff generation failures.\"\"\"\n    ERROR_CODE = 'ALGORITHM'\n\nclass ResourceError(DiffToolError):\n    \"\"\"Memory, time, or other resource exhaustion.\"\"\"\n    ERROR_CODE = 'RESOURCE'\n\nclass OutputError(DiffToolError):\n    \"\"\"Output formatting and writing failures.\"\"\"\n    ERROR_CODE = 'OUTPUT'\n```\n\n**Resource Monitor (Complete Implementation)**\n\n```python\n\"\"\"\nResource monitoring and limit enforcement for diff operations.\nPrevents memory exhaustion and provides early warnings for resource constraints.\n\"\"\"\n\nimport psutil\nimport time\nfrom typing import Optional, Dict, Any\n\nclass ResourceMonitor:\n    \"\"\"Monitors memory usage, computation time, and other system resources.\"\"\"\n    \n    def __init__(self, memory_limit_mb: float = 1024, time_limit_seconds: int = 300):\n        self.memory_limit_mb = memory_limit_mb\n        self.time_limit_seconds = time_limit_seconds\n        self.start_time: Optional[float] = None\n        self.peak_memory_mb = 0.0\n        \n    def start_monitoring(self):\n        \"\"\"Begin resource monitoring for an operation.\"\"\"\n        self.start_time = time.time()\n        self.peak_memory_mb = self._get_memory_usage_mb()\n    \n    def check_limits(self) -> Optional[ResourceError]:\n        \"\"\"Check if resource limits have been exceeded.\"\"\"\n        if self.start_time is None:\n            return None\n            \n        # Check time limit\n        elapsed = time.time() - self.start_time\n        if elapsed > self.time_limit_seconds:\n            return ResourceError(\n                f\"Operation timed out after {elapsed:.1f} seconds\",\n                context={\"time_limit\": self.time_limit_seconds, \"elapsed\": elapsed},\n                suggestion=\"Try smaller files or increase time limit\"\n            )\n        \n        # Check memory limit\n        current_memory = self._get_memory_usage_mb()\n        self.peak_memory_mb = max(self.peak_memory_mb, current_memory)\n        \n        if current_memory > self.memory_limit_mb:\n            return ResourceError(\n                f\"Memory usage ({current_memory:.1f} MB) exceeds limit ({self.memory_limit_mb:.1f} MB)\",\n                context={\"memory_used\": current_memory, \"memory_limit\": self.memory_limit_mb},\n                suggestion=\"Try using memory-optimized algorithms or increase memory limit\"\n            )\n        \n        return None\n    \n    def estimate_matrix_memory(self, rows: int, cols: int) -> float:\n        \"\"\"Estimate memory requirements for LCS matrix in MB.\"\"\"\n        # Each matrix cell is typically 4 bytes (32-bit int)\n        bytes_needed = rows * cols * 4\n        return bytes_needed / (1024 * 1024)\n    \n    def _get_memory_usage_mb(self) -> float:\n        \"\"\"Get current process memory usage in MB.\"\"\"\n        process = psutil.Process()\n        return process.memory_info().rss / (1024 * 1024)\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get monitoring statistics for reporting.\"\"\"\n        return {\n            \"peak_memory_mb\": self.peak_memory_mb,\n            \"elapsed_seconds\": time.time() - self.start_time if self.start_time else 0,\n            \"memory_limit_mb\": self.memory_limit_mb,\n            \"time_limit_seconds\": self.time_limit_seconds\n        }\n```\n\n**Core Logic Skeletons with Error Handling**\n\n```python\ndef detect_file_encoding(filepath: str) -> str:\n    \"\"\"\n    Detect file encoding trying UTF-8 then Latin-1 with comprehensive error handling.\n    Returns encoding string or raises EncodingError with specific failure details.\n    \"\"\"\n    # TODO 1: Check if file exists and is readable - raise FileSystemError with context if not\n    # TODO 2: Check file size - if zero bytes, raise EncodingError indicating empty file\n    # TODO 3: Read first 1024 bytes for encoding detection without loading entire file\n    # TODO 4: Attempt UTF-8 decoding - catch UnicodeDecodeError and check for null bytes (binary file)\n    # TODO 5: If UTF-8 fails, attempt Latin-1 decoding - Latin-1 should always succeed for binary data\n    # TODO 6: If both fail (shouldn't happen), raise EncodingError with detection failure details\n    # TODO 7: For successful detection, validate by trying to decode a larger sample\n    # Hint: Use try/except blocks for each encoding attempt and preserve original exception details\n    pass\n\ndef compute_lcs_with_limits(sequence1: Sequence, sequence2: Sequence, monitor: ResourceMonitor) -> CommonSubsequence:\n    \"\"\"\n    Compute LCS with resource monitoring and graceful degradation on limits.\n    Switches algorithms based on input size and available resources.\n    \"\"\"\n    # TODO 1: Start resource monitoring and get initial memory baseline\n    # TODO 2: Handle empty sequence edge cases - return appropriate CommonSubsequence immediately  \n    # TODO 3: Estimate memory requirements for full matrix algorithm\n    # TODO 4: If memory estimate exceeds limits, choose memory-efficient algorithm\n    # TODO 5: Periodically check resource limits during matrix construction\n    # TODO 6: If limits exceeded during computation, clean up and raise ResourceError with context\n    # TODO 7: Validate result consistency - LCS length should not exceed shorter sequence\n    # TODO 8: Return CommonSubsequence with computation statistics attached\n    # Hint: Use monitor.check_limits() after each major step, clean up matrix on failure\n    pass\n\ndef generate_diff_with_validation(file1_lines: List[str], file2_lines: List[str], \n                                 lcs: CommonSubsequence, context_lines: int) -> List[Hunk]:\n    \"\"\"\n    Generate diff hunks with comprehensive validation and error recovery.\n    Validates line numbering consistency and hunk boundary correctness.\n    \"\"\"\n    # TODO 1: Validate LCS result consistency against input files\n    # TODO 2: Convert LCS to edit operations, tracking line numbers carefully\n    # TODO 3: Validate that edit operations account for all lines in both files\n    # TODO 4: Group operations into hunks with requested context\n    # TODO 5: Validate each hunk's line count claims against actual content\n    # TODO 6: Check for overlapping context between adjacent hunks\n    # TODO 7: Merge or adjust hunks to resolve context overlaps\n    # TODO 8: Final validation pass - ensure line numbers are monotonic and complete\n    # Hint: Keep running totals of processed lines to catch numbering errors early\n    pass\n```\n\n**Milestone Checkpoints for Error Handling**\n\nAfter implementing error handling for each milestone, verify these specific behaviors:\n\n**Milestone 1 Checkpoint - File Reading Errors:**\n- Command: `python diff_tool.py nonexistent.txt other.txt`\n- Expected: Clear error message about missing file, exit code 1\n- Command: `python diff_tool.py /dev/null /dev/null` (Unix) or empty files\n- Expected: \"Both files are empty\" message, exit code 0\n- Command: `python diff_tool.py binary_file.exe text_file.txt`\n- Expected: Error about binary file detection with null byte position\n\n**Milestone 2 Checkpoint - Algorithm Limits:**\n- Create test files with 10,000+ lines each\n- Command: `python diff_tool.py huge1.txt huge2.txt`\n- Expected: Either successful completion with memory monitoring or graceful failure with resource limit message\n- Verify memory usage doesn't exceed system limits\n- Check that empty file comparisons complete instantly without matrix construction\n\n**Milestone 3 Checkpoint - Diff Validation:**\n- Create files with edge cases: no common lines, all identical lines, single character differences\n- Verify hunk line counts match content\n- Check that all input lines appear exactly once in diff output\n- Validate line numbers are consistent and monotonic\n\n**Milestone 4 Checkpoint - CLI Error Handling:**\n- Test all error scenarios produce appropriate exit codes (0 for success, 1 for differences, 2 for errors)\n- Verify color codes don't appear when output is piped: `python diff_tool.py file1.txt file2.txt | cat`\n- Check that Ctrl+C interruption cleans up resources properly\n\n**Debugging Tips for Error Handling**\n\n| Symptom | Likely Cause | Diagnosis Steps | Fix Strategy |\n|---------|--------------|----------------|--------------|\n| Tool crashes silently | Unhandled exception or resource exhaustion | Check system logs, monitor memory usage during run | Add try/catch blocks around main operations, implement resource monitoring |\n| \"Binary file\" error on text files | Encoding detection failing, or file contains null bytes | Examine file with hex editor, check for encoding issues | Improve encoding detection logic, handle mixed encodings gracefully |  \n| Line numbers in diff output are wrong | Off-by-one errors in hunk generation | Compare line numbers in hunks against original files manually | Validate line counting logic, use 1-indexed line numbers consistently |\n| Memory usage grows without bound | LCS matrix not being garbage collected | Profile memory usage during algorithm execution | Implement matrix cleanup, use memory-efficient algorithms for large inputs |\n| Tool hangs on large files | Infinite loop in algorithm or excessive memory swapping | Use profiler to identify bottleneck, monitor system resources | Add progress monitoring, implement timeouts, detect swap thrashing |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones — comprehensive testing ensures correctness throughout line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)\n\nTesting a diff tool requires a systematic approach that validates both algorithmic correctness and practical usability. The core challenge lies in verifying that complex dynamic programming algorithms produce correct results while handling the myriad edge cases that arise from real-world file formats and user scenarios.\n\n### Mental Model: Quality Assurance Chain\n\nThink of testing a diff tool like quality assurance in a publishing house that compares manuscript versions. The QA process has multiple checkpoints: first, verify that each editor (component) correctly identifies their assigned changes; then, confirm that all editorial notes (diff operations) accurately reflect the differences; finally, ensure the published comparison (formatted output) is readable and follows industry standards. Each checkpoint catches different types of errors, and the chain is only as strong as its weakest link.\n\nThe testing strategy mirrors this approach by validating each component individually, then verifying their integration produces correct end-to-end behavior. Just as a publishing house maintains reference examples of well-executed comparisons, our test suite relies on golden files and known-correct diff outputs to validate algorithmic behavior.\n\n### Unit Testing Approach\n\nUnit testing for a diff tool requires careful construction of test cases that isolate component behavior while exercising the full range of inputs each component might encounter. The strategy focuses on testing individual components with known input-output pairs, systematic edge case coverage, and algorithmic validation using reference implementations.\n\n#### Component Isolation Strategy\n\nEach component in the diff pipeline requires different testing approaches based on its algorithmic complexity and interaction patterns. The `FileReader` component primarily handles I/O and text processing, making it suitable for file-based testing with various encodings and formats. The `LCSEngine` involves complex dynamic programming algorithms that benefit from mathematical verification against known solutions. The `DiffGenerator` transforms algorithmic results into structured output, requiring format validation and context handling verification. The `OutputFormatter` handles presentation logic that needs both visual verification and compatibility testing.\n\n> **Decision: Component-First Testing Approach**\n> - **Context**: Testing can proceed component-by-component or through integrated scenarios. Component-first testing isolates failures but may miss integration issues.\n> - **Options Considered**: Component isolation, integration-first testing, hybrid approach\n> - **Decision**: Start with component isolation, then build integration tests\n> - **Rationale**: Dynamic programming algorithms are complex enough to warrant isolated verification before adding integration complexity. Individual component bugs are easier to diagnose and fix than integration failures.\n> - **Consequences**: Enables parallel test development, simplifies debugging, but requires additional integration test layer\n\n| Testing Approach | Pros | Cons | Chosen? |\n|-----------------|------|------|---------|\n| Component Isolation | Clear failure attribution, parallel development, algorithmic focus | May miss integration issues, duplicate test data | ✓ Primary |\n| Integration-First | Tests real scenarios, catches interface mismatches early | Complex failure diagnosis, coupled test development | Secondary |\n| Hybrid Approach | Balances isolation and integration, comprehensive coverage | Longer test development time, more complex test suite | Long-term goal |\n\n#### FileReader Component Testing\n\nThe `FileReader` component requires extensive testing of file I/O edge cases, encoding detection, and line normalization behavior. Test cases must cover different file encodings, line ending formats, and boundary conditions that real-world files present.\n\n**Encoding Detection Test Matrix:**\n\n| File Content | Expected Encoding | Test Purpose |\n|--------------|------------------|--------------|\n| Pure ASCII text | UTF-8 | Basic encoding detection |\n| UTF-8 with BOM | UTF-8 | BOM handling verification |\n| UTF-8 without BOM | UTF-8 | Standard UTF-8 detection |\n| Latin-1 characters (é, ñ, ü) | Latin-1 | Fallback encoding detection |\n| Binary data (null bytes) | Error | Binary file rejection |\n| Empty file | UTF-8 (default) | Edge case handling |\n| Mixed valid UTF-8 and invalid sequences | Error | Encoding corruption detection |\n\n**Line Ending Normalization Test Cases:**\n\nThe `normalize_line_endings` function must handle all combinations of line ending types while preserving the original format information for diff headers. Test cases verify that different line ending formats are correctly detected and normalized to a consistent internal representation.\n\n| Input Content | Expected Normalized | Expected Original Format | Test Purpose |\n|---------------|-------------------|------------------------|--------------|\n| `\"line1\\nline2\\n\"` | `[\"line1\", \"line2\"]` | `LF` | Unix format handling |\n| `\"line1\\r\\nline2\\r\\n\"` | `[\"line1\", \"line2\"]` | `CRLF` | Windows format handling |\n| `\"line1\\rline2\\r\"` | `[\"line1\", \"line2\"]` | `CR` | Classic Mac format handling |\n| `\"line1\\r\\nline2\\n\"` | `[\"line1\", \"line2\"]` | `\"mixed\"` | Mixed format detection |\n| `\"line1\\nline2\"` | `[\"line1\", \"line2\"]` | `\"no_final_newline\"` | Missing final newline |\n| `\"\"` | `[]` | `\"empty\"` | Empty file handling |\n| `\"\\n\\n\\n\"` | `[\"\", \"\", \"\"]` | `LF` | Multiple empty lines |\n\n**File Content Creation Test Scenarios:**\n\nThe `create_file_content` factory function requires validation of its input normalization and validation logic. Tests must verify that invalid combinations are rejected and valid inputs produce correctly structured `FileContent` objects.\n\n```python\n# Test case structure for FileContent creation\ntest_cases = [\n    {\n        'filepath': '/path/to/file.txt',\n        'raw_content': 'line1\\nline2\\nline3',\n        'encoding': 'UTF-8',\n        'line_ending': 'LF',\n        'expected_lines': ['line1', 'line2', 'line3'],\n        'expected_line_count': 3\n    },\n    {\n        'filepath': '/path/to/empty.txt',\n        'raw_content': '',\n        'encoding': 'UTF-8',\n        'line_ending': 'empty',\n        'expected_lines': [],\n        'expected_line_count': 0\n    }\n]\n```\n\n#### LCS Engine Component Testing\n\nThe `LCSEngine` requires rigorous algorithmic testing since dynamic programming implementations are prone to off-by-one errors, incorrect recurrence relations, and backtracking mistakes. Testing approaches include mathematical verification against known solutions, property-based testing, and performance validation.\n\n**Known Solution Verification:**\n\nLCS algorithms can be verified against manually computed solutions for small inputs, then scaled to larger inputs with predictable patterns. The test suite includes carefully constructed examples where the correct LCS is obvious and can be manually verified.\n\n| Sequence 1 | Sequence 2 | Expected LCS | Expected Length | Test Purpose |\n|------------|------------|--------------|-----------------|--------------|\n| `[\"A\", \"B\", \"C\"]` | `[\"A\", \"B\", \"C\"]` | `[\"A\", \"B\", \"C\"]` | 3 | Identical sequences |\n| `[\"A\", \"B\", \"C\"]` | `[\"X\", \"Y\", \"Z\"]` | `[]` | 0 | No common elements |\n| `[\"A\", \"B\", \"C\", \"D\"]` | `[\"B\", \"D\", \"F\"]` | `[\"B\", \"D\"]` | 2 | Partial overlap |\n| `[]` | `[\"A\", \"B\"]` | `[]` | 0 | Empty first sequence |\n| `[\"A\", \"B\"]` | `[]` | `[]` | 0 | Empty second sequence |\n| `[]` | `[]` | `[]` | 0 | Both sequences empty |\n| `[\"A\", \"A\", \"A\"]` | `[\"A\", \"A\"]` | `[\"A\", \"A\"]` | 2 | Repeated elements |\n\n**Matrix Construction Verification:**\n\nThe `build_lcs_matrix` function requires validation of its dynamic programming table construction. Tests verify that the matrix dimensions are correct and that each cell contains the expected LCS length for its corresponding subsequences.\n\n```python\n# Example matrix verification for sequences [\"A\", \"B\"] and [\"A\", \"C\"]\nexpected_matrix = [\n    [0, 0, 0],  # Row 0: empty vs [\"A\", \"C\"]\n    [0, 1, 1],  # Row 1: [\"A\"] vs [\"A\", \"C\"]\n    [0, 1, 1]   # Row 2: [\"A\", \"B\"] vs [\"A\", \"C\"]\n]\n# Matrix[i][j] represents LCS length of first i elements vs first j elements\n```\n\n**Backtracking Algorithm Verification:**\n\nThe `backtrack` function must correctly reconstruct the actual LCS from the completed matrix. Tests verify that backtracking produces a valid LCS (present in both sequences in order) and that multiple valid LCS paths are handled consistently.\n\n| Matrix State | Expected Backtrack Path | Expected LCS | Test Purpose |\n|--------------|-------------------------|--------------|--------------|\n| Single optimal path | Deterministic trace | Unique LCS | Standard case |\n| Multiple optimal paths | Consistent tie-breaking | One valid LCS | Tie-breaking rules |\n| All zeros matrix | No backtrack moves | Empty LCS | No common elements |\n| Diagonal matrix | Straight diagonal trace | Full common sequence | Identical inputs |\n\n**Performance and Memory Testing:**\n\nThe `LCSEngine` must handle large inputs without memory exhaustion while maintaining reasonable performance. Tests verify that the memory optimization strategies work correctly and that resource limits are respected.\n\n| Sequence Length | Expected Algorithm | Expected Memory | Expected Time | Test Purpose |\n|-----------------|-------------------|-----------------|---------------|--------------|\n| 100 x 100 | `matrix` | ~80KB | <1ms | Small input baseline |\n| 1000 x 1000 | `matrix` | ~8MB | <100ms | Medium input handling |\n| 10000 x 10000 | `two_row` | ~80KB | <10s | Memory optimization |\n| 50000 x 50000 | `hirschberg` | ~800KB | <5min | Large input handling |\n\n#### DiffGenerator Component Testing\n\nThe `DiffGenerator` transforms LCS results into structured diff operations and hunks. Testing focuses on correct edit operation generation, proper hunk formation with context lines, and unified diff format compliance.\n\n**Edit Operation Generation Testing:**\n\nThe `lcs_to_edit_operations` function must correctly identify which lines are unchanged (in LCS), added (in sequence2 but not LCS), or deleted (in sequence1 but not LCS). Tests verify that the generated operations correctly represent the transformation from sequence1 to sequence2.\n\n| File1 Lines | File2 Lines | LCS | Expected Operations | Test Purpose |\n|-------------|-------------|-----|-------------------|--------------|\n| `[\"A\", \"B\", \"C\"]` | `[\"A\", \"B\", \"C\"]` | `[\"A\", \"B\", \"C\"]` | All `UNCHANGED` | Identical files |\n| `[\"A\", \"B\"]` | `[\"A\", \"X\", \"B\"]` | `[\"A\", \"B\"]` | `UNCHANGED`, `ADDED`, `UNCHANGED` | Single insertion |\n| `[\"A\", \"X\", \"B\"]` | `[\"A\", \"B\"]` | `[\"A\", \"B\"]` | `UNCHANGED`, `DELETED`, `UNCHANGED` | Single deletion |\n| `[\"A\", \"B\"]` | `[\"X\", \"Y\"]` | `[]` | `DELETED`, `DELETED`, `ADDED`, `ADDED` | Complete replacement |\n\n**Hunk Formation Testing:**\n\nThe `diff_lines_to_hunks` function groups nearby changes into hunks with appropriate context lines. Tests verify that hunks are formed correctly, context lines are included properly, and adjacent hunks are merged when appropriate.\n\n```python\n# Test case: Context line grouping\ndiff_lines = [\n    DiffLine(\"line1\", UNCHANGED, 1, 1),\n    DiffLine(\"line2\", UNCHANGED, 2, 2),\n    DiffLine(\"old_line\", DELETED, 3, None),\n    DiffLine(\"new_line\", ADDED, None, 3),\n    DiffLine(\"line4\", UNCHANGED, 4, 4),\n    DiffLine(\"line5\", UNCHANGED, 5, 5)\n]\n\n# With context_lines=2, expect single hunk:\nexpected_hunk = Hunk(\n    old_start=1, old_count=5,\n    new_start=1, new_count=5,\n    lines=diff_lines,\n    context_before=2,\n    context_after=2\n)\n```\n\n**Hunk Merging Logic Testing:**\n\nThe `merge_adjacent_hunks` function combines hunks that are close enough together to warrant merging. Tests verify the merging distance calculation and ensure that merged hunks maintain correct line counts and ranges.\n\n| Hunk1 Range | Hunk2 Range | Context Lines | Max Gap | Should Merge? | Test Purpose |\n|-------------|-------------|---------------|---------|---------------|--------------|\n| Lines 1-5 | Lines 8-12 | 2 | 3 | Yes | Close hunks merge |\n| Lines 1-5 | Lines 15-20 | 2 | 3 | No | Distant hunks separate |\n| Lines 1-5 | Lines 6-10 | 1 | 0 | Yes | Adjacent hunks merge |\n| Lines 1-5 | Lines 7-10 | 0 | 1 | No | Context gap prevents merge |\n\n#### OutputFormatter Component Testing\n\nThe `OutputFormatter` handles presentation logic including unified diff format generation, ANSI color application, and CLI integration. Testing verifies format compliance, color handling, and cross-platform compatibility.\n\n**Unified Diff Format Compliance:**\n\nThe `format_unified_diff` function must generate output that complies with the standard unified diff format. Tests verify header generation, hunk marker format, line prefix correctness, and overall format structure.\n\n```python\n# Expected unified diff format structure\nexpected_format = [\n    \"--- file1.txt\\toriginal_timestamp\",\n    \"+++ file2.txt\\tmodified_timestamp\", \n    \"@@ -1,3 +1,3 @@\",\n    \" unchanged_line\",\n    \"-deleted_line\", \n    \"+added_line\",\n    \" another_unchanged_line\"\n]\n```\n\n**ANSI Color Testing:**\n\nThe `ColorFormatter` must correctly apply ANSI color codes when appropriate and strip them when color is disabled. Tests verify color application, TTY detection, and cross-platform compatibility.\n\n| Input Line | Color Enabled | Expected Output | Test Purpose |\n|------------|---------------|-----------------|--------------|\n| `DiffLine(\"text\", DELETED, 1, None)` | True | `\"\\033[31m-text\\033[0m\"` | Red deletion color |\n| `DiffLine(\"text\", ADDED, None, 1)` | True | `\"\\033[32m+text\\033[0m\"` | Green addition color |\n| `DiffLine(\"text\", UNCHANGED, 1, 1)` | True | `\" text\"` | No color for unchanged |\n| `DiffLine(\"text\", DELETED, 1, None)` | False | `\"-text\"` | No color when disabled |\n\n**CLI Argument Processing Testing:**\n\nThe argument parsing logic must correctly handle all supported command-line options and provide appropriate error messages for invalid usage. Tests verify option parsing, file path validation, and help text generation.\n\n```python\n# CLI argument test cases\ncli_test_cases = [\n    {\n        'args': ['file1.txt', 'file2.txt'],\n        'expected': DiffArguments(file1='file1.txt', file2='file2.txt', \n                                 color=True, context_lines=3),\n        'description': 'Basic two-file comparison'\n    },\n    {\n        'args': ['--no-color', 'file1.txt', 'file2.txt'],\n        'expected': DiffArguments(file1='file1.txt', file2='file2.txt',\n                                 color=False, context_lines=3),\n        'description': 'Color disabled'\n    },\n    {\n        'args': ['--context', '5', 'file1.txt', 'file2.txt'],\n        'expected': DiffArguments(file1='file1.txt', file2='file2.txt',\n                                 color=True, context_lines=5),\n        'description': 'Custom context lines'\n    }\n]\n```\n\n#### Property-Based Testing Strategy\n\nProperty-based testing generates random inputs and verifies that certain properties always hold, regardless of the specific input values. This approach is particularly valuable for diff algorithms because it can discover edge cases that manual test case construction might miss.\n\n**LCS Properties to Verify:**\n\n1. **Symmetry Property**: The LCS length of (A, B) equals the LCS length of (B, A)\n2. **Subsequence Property**: The returned LCS must be a valid subsequence of both input sequences\n3. **Optimality Property**: No longer common subsequence should exist than the one returned\n4. **Prefix Property**: LCS(A[0:i], B[0:j]) should be consistent with the full LCS computation\n\n**Diff Generation Properties:**\n\n1. **Roundtrip Property**: Applying the generated diff operations should transform sequence1 into sequence2\n2. **Line Conservation**: The total number of unchanged + deleted lines should equal the original file length\n3. **Hunk Completeness**: All diff operations should appear in exactly one hunk\n4. **Context Consistency**: Context lines in hunks should match the original file content\n\n#### Error Condition Testing\n\nEach component must handle error conditions gracefully and provide meaningful error messages. Error testing verifies that components fail fast with appropriate error types and context information.\n\n**FileReader Error Scenarios:**\n\n| Error Condition | Expected Exception | Expected Message Pattern | Recovery Strategy |\n|-----------------|-------------------|--------------------------|-------------------|\n| File not found | `FileSystemError` | \"File not found: {filepath}\" | Prompt user for correct path |\n| Permission denied | `FileSystemError` | \"Permission denied: {filepath}\" | Check file permissions |\n| Binary file detection | `EncodingError` | \"Binary file detected: {filepath}\" | Skip or warn user |\n| Mixed line endings | Warning | \"Mixed line endings detected\" | Continue with normalization |\n| Encoding detection failure | `EncodingError` | \"Could not determine encoding\" | Prompt user for encoding |\n\n**LCSEngine Error Scenarios:**\n\n| Error Condition | Expected Exception | Expected Message Pattern | Recovery Strategy |\n|-----------------|-------------------|--------------------------|-------------------|\n| Memory limit exceeded | `ResourceError` | \"LCS matrix too large: {size}MB > {limit}MB\" | Suggest memory optimization |\n| Time limit exceeded | `ResourceError` | \"LCS computation timeout after {seconds}s\" | Suggest algorithm optimization |\n| Invalid sequence input | `AlgorithmError` | \"Invalid sequence type: expected List[str]\" | Validate input format |\n| Empty matrix allocation | `ResourceError` | \"Cannot allocate matrix of size {rows}x{cols}\" | Check available memory |\n\n### Common Pitfalls in Testing\n\nTesting diff algorithms presents several common pitfalls that can lead to false confidence in correctness or missed edge cases. Understanding these pitfalls helps construct more robust test suites.\n\n⚠️ **Pitfall: Testing Only Happy Path Scenarios**\n\nMany developers focus testing on scenarios where files have clear, obvious differences and ignore the edge cases where algorithms are most likely to fail. Testing only well-formed text files with consistent line endings misses the real-world complexity of mixed encodings, binary data, and malformed input.\n\nThe fix involves systematically constructing adversarial test cases: files with no common lines, files where one is empty, files with only whitespace differences, and files with encoding issues. Create a test matrix that covers all combinations of edge conditions rather than just the scenarios that work smoothly.\n\n⚠️ **Pitfall: Assuming LCS Uniqueness**\n\nLCS algorithms can produce multiple valid results when there are multiple longest common subsequences of equal length. Tests that expect a specific LCS may fail when the algorithm chooses a different but equally valid path through the edit graph.\n\nThe solution is to test LCS properties rather than exact content. Verify that the returned LCS has the correct length, appears in both sequences in the correct order, and that no longer common subsequence exists. This allows the algorithm flexibility in tie-breaking while ensuring correctness.\n\n⚠️ **Pitfall: Off-by-One Line Number Testing**\n\nUnified diff format uses one-indexed line numbers, but most programming languages use zero-indexed arrays. Tests that don't account for this indexing difference may pass with incorrect line numbering that breaks compatibility with standard diff tools.\n\nCreate test cases that specifically verify line numbering in hunk headers matches the expected unified diff format. Compare generated output with the output of system diff tools to ensure compatibility. Pay special attention to edge cases like single-line files and changes at the beginning or end of files.\n\n⚠️ **Pitfall: Incomplete Context Line Testing**\n\nContext line generation involves complex boundary conditions when changes occur near file boundaries or when hunks would overlap. Tests that don't exercise these boundary conditions miss scenarios where context line calculation fails.\n\nConstruct test cases where changes occur on the first line, last line, and cases where requested context extends beyond file boundaries. Verify that hunk merging works correctly when context lines overlap and that merged hunks maintain correct line counts.\n\n⚠️ **Pitfall: Platform-Specific Color Testing**\n\nANSI color code handling varies significantly between operating systems and terminal types. Tests that work on one platform may fail on others due to different color support, TTY detection, or output redirection behavior.\n\nCreate platform-specific test configurations that verify color output under different conditions: interactive terminal, redirected output, Windows command prompt, and Unix terminals. Mock TTY detection to ensure consistent behavior across environments.\n\n### Milestone Checkpoints\n\nEach milestone in the diff tool implementation requires specific validation checkpoints that verify both individual component functionality and integration with previous components. These checkpoints provide concrete verification steps and expected outcomes.\n\n#### Milestone 1 Checkpoint: Line Tokenization\n\nAfter implementing the `FileReader` component, the following validation steps ensure correct file reading and line processing behavior:\n\n**Validation Commands:**\n```bash\n# Basic functionality test\npython -m pytest tests/test_file_reader.py -v\n\n# Encoding detection test\npython test_encoding_detection.py\n\n# Line normalization verification\npython test_line_endings.py\n```\n\n**Expected Behavior Verification:**\n\n1. **File Reading Test**: Create test files in different encodings (UTF-8, Latin-1) with various content types. The `read_file_lines` function should correctly detect encoding and return a list of strings representing file lines.\n\n2. **Line Ending Normalization**: Create files with different line endings (LF, CRLF, CR, mixed) and verify that `normalize_line_endings` correctly detects the original format while producing consistent internal representation.\n\n3. **Empty Line Preservation**: Files with empty lines should preserve those empty lines in the output. The line count should match the actual number of lines including empty ones.\n\n4. **Error Handling Verification**: Binary files should be rejected with appropriate error messages. Files with permission issues should produce clear error descriptions.\n\n**Success Indicators:**\n- All encoding detection tests pass with correct UTF-8/Latin-1 identification\n- Line count reported matches manual line count for various file types\n- Empty lines are preserved in output without being filtered\n- Binary file detection prevents processing of non-text files\n- Error messages provide actionable information for file access issues\n\n**Troubleshooting Common Issues:**\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|--------------|------------------|-----|\n| Binary files accepted | Missing binary detection | Check for null bytes in content | Add binary detection logic |\n| Line count mismatch | Trailing newline handling | Compare with `wc -l` output | Handle final newline consistently |\n| Encoding errors | Detection order wrong | Test with Latin-1 content | Try UTF-8 first, fallback to Latin-1 |\n| Empty lines missing | Split logic incorrect | Check split algorithm | Use split that preserves empty strings |\n\n#### Milestone 2 Checkpoint: LCS Algorithm\n\nThe LCS implementation requires verification of correct dynamic programming matrix construction and backtracking logic:\n\n**Validation Commands:**\n```bash\n# LCS algorithm correctness\npython -m pytest tests/test_lcs_engine.py -v\n\n# Performance and memory testing\npython test_lcs_performance.py\n\n# Matrix construction verification\npython test_matrix_building.py\n```\n\n**Expected Behavior Verification:**\n\n1. **Algorithm Correctness**: Test with known LCS examples where the result can be manually verified. The `compute_lcs` function should return the correct longest common subsequence and length.\n\n2. **Matrix Construction**: The `build_lcs_matrix` function should produce a properly sized matrix where each cell contains the correct LCS length for the corresponding subsequences.\n\n3. **Backtracking Verification**: The `backtrack` function should reconstruct a valid LCS that appears in both input sequences in the correct order.\n\n4. **Memory Optimization**: Large inputs should trigger memory optimization strategies without affecting correctness.\n\n**Success Indicators:**\n- All known LCS test cases produce correct results\n- Matrix dimensions match input sequence lengths plus one\n- Backtracked LCS is a valid subsequence of both inputs\n- Memory usage stays within configured limits for large inputs\n- Performance scales reasonably with input size\n\n**Troubleshooting Common Issues:**\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|--------------|------------------|-----|\n| Wrong LCS length | Matrix construction error | Print matrix values manually | Check recurrence relation |\n| Backtrack fails | Index boundaries wrong | Trace backtrack path | Fix matrix indexing |\n| Memory explosion | No optimization triggered | Check input size thresholds | Lower optimization trigger point |\n| Performance issues | Inefficient matrix access | Profile algorithm execution | Optimize inner loop |\n\n#### Milestone 3 Checkpoint: Diff Generation\n\nThe diff generation component transforms LCS results into structured hunks with unified diff format:\n\n**Validation Commands:**\n```bash\n# Diff generation correctness\npython -m pytest tests/test_diff_generator.py -v\n\n# Hunk formation testing\npython test_hunk_generation.py\n\n# Format compliance verification\npython test_unified_diff_format.py\n```\n\n**Expected Behavior Verification:**\n\n1. **Edit Operations**: The `lcs_to_edit_operations` function should correctly identify added, deleted, and unchanged lines based on LCS results.\n\n2. **Hunk Formation**: The `diff_lines_to_hunks` function should group nearby changes with appropriate context lines and generate correct hunk boundaries.\n\n3. **Line Numbering**: All line numbers in hunks should be one-indexed and accurately reflect positions in the original files.\n\n4. **Context Handling**: Context lines should be included around changes, and overlapping contexts should trigger hunk merging.\n\n**Success Indicators:**\n- Edit operations correctly represent file transformation\n- Hunk line counts match actual line content\n- Line numbering follows unified diff conventions (one-indexed)\n- Context lines accurately match original file content\n- Adjacent hunks merge appropriately based on context overlap\n\n**Troubleshooting Common Issues:**\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|--------------|------------------|-----|\n| Wrong line numbers | Zero-based indexing used | Check hunk headers against file | Convert to one-based numbering |\n| Missing context lines | Context calculation error | Verify context boundaries | Fix context line extraction |\n| Hunks not merging | Merge distance wrong | Check overlap calculation | Adjust merge threshold |\n| Line count mismatch | Hunk calculation error | Sum hunk lines vs file lines | Fix hunk line counting |\n\n#### Milestone 4 Checkpoint: CLI and Color Output\n\nThe final milestone integrates all components into a complete CLI tool with colored output:\n\n**Validation Commands:**\n```bash\n# Complete integration test\npython diff_tool.py file1.txt file2.txt\n\n# Color output verification\npython diff_tool.py --color file1.txt file2.txt\n\n# Context line configuration\npython diff_tool.py --context 5 file1.txt file2.txt\n\n# No-color mode testing\npython diff_tool.py --no-color file1.txt file2.txt > output.diff\n```\n\n**Expected Behavior Verification:**\n\n1. **CLI Integration**: Command-line arguments should be parsed correctly with appropriate defaults and error messages for invalid usage.\n\n2. **Color Output**: Terminal output should include ANSI color codes for additions (green) and deletions (red) when appropriate, but strip colors when output is redirected.\n\n3. **Format Compatibility**: Generated diff output should be compatible with standard diff tools and patch utilities.\n\n4. **Exit Codes**: Program should return 0 for identical files, 1 for different files, and 2 for errors.\n\n**Success Indicators:**\n- CLI accepts all documented arguments correctly\n- Color output appears properly in terminal\n- No-color mode produces clean output suitable for redirection\n- Generated diffs can be applied using standard patch tools\n- Exit codes match diff tool conventions\n- Error messages provide helpful guidance for incorrect usage\n\n**Integration Verification Steps:**\n\n1. **Compare with System Diff**: Run both your tool and system diff on the same files and verify that the essential differences are captured correctly (line numbers and change indicators may vary slightly due to different algorithms).\n\n2. **Patch Application Test**: Generate a diff with your tool and verify it can be applied using standard patch utilities to reproduce the target file.\n\n3. **Performance Validation**: Verify that the complete pipeline handles reasonably sized files (1000+ lines) within acceptable time limits.\n\n4. **Cross-Platform Testing**: Test CLI behavior on different operating systems to ensure consistent argument parsing and color output.\n\n**Final Integration Troubleshooting:**\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix |\n|---------|--------------|------------------|-----|\n| Colors in redirected output | TTY detection failed | Test with `diff_tool.py > file` | Fix TTY detection logic |\n| Patch application fails | Format compliance issue | Compare with system diff output | Align format with standards |\n| Wrong exit codes | Exit code logic missing | Test with identical/different files | Implement proper exit codes |\n| Performance degradation | Component integration overhead | Profile pipeline execution | Optimize data passing between components |\n\n### Implementation Guidance\n\nThe testing implementation focuses on creating a comprehensive test suite that validates each component individually and verifies their integration. The approach emphasizes systematic test case construction, property-based testing, and milestone-driven validation.\n\n#### Technology Recommendations\n\n| Testing Component | Simple Option | Advanced Option |\n|------------------|---------------|-----------------|\n| Test Framework | `unittest` (built-in) | `pytest` with fixtures |\n| Property Testing | Manual test case construction | `hypothesis` for property-based testing |\n| Performance Testing | Basic timing with `time.time()` | `pytest-benchmark` with statistical analysis |\n| Test Data Management | Hardcoded test strings | External test files with various encodings |\n| Coverage Analysis | Manual verification | `coverage.py` with branch coverage |\n| CLI Testing | Direct function calls | `click.testing.CliRunner` for CLI simulation |\n\n#### Recommended File Structure\n\n```\nproject-root/\n├── src/\n│   ├── diff_tool/\n│   │   ├── __init__.py\n│   │   ├── file_reader.py      ← FileReader component\n│   │   ├── lcs_engine.py       ← LCSEngine component\n│   │   ├── diff_generator.py   ← DiffGenerator component\n│   │   ├── output_formatter.py ← OutputFormatter component\n│   │   └── main.py            ← CLI entry point\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py            ← pytest fixtures and shared test utilities\n│   ├── test_file_reader.py    ← FileReader unit tests\n│   ├── test_lcs_engine.py     ← LCSEngine unit tests\n│   ├── test_diff_generator.py ← DiffGenerator unit tests\n│   ├── test_output_formatter.py ← OutputFormatter unit tests\n│   ├── test_integration.py    ← End-to-end integration tests\n│   ├── test_properties.py     ← Property-based testing\n│   ├── test_data/            ← Test files with various encodings\n│   │   ├── utf8_sample.txt\n│   │   ├── latin1_sample.txt\n│   │   ├── binary_sample.bin\n│   │   ├── empty_file.txt\n│   │   └── mixed_endings.txt\n│   └── performance/\n│       ├── test_lcs_performance.py\n│       └── test_memory_usage.py\n├── pytest.ini                ← pytest configuration\n└── requirements-test.txt      ← testing dependencies\n```\n\n#### Test Fixture Infrastructure\n\nCreate reusable test fixtures that provide consistent test data and component instances across the test suite:\n\n```python\n# tests/conftest.py - Shared test fixtures and utilities\nimport pytest\nfrom pathlib import Path\nfrom src.diff_tool.file_reader import FileReader\nfrom src.diff_tool.lcs_engine import LCSEngine\nfrom src.diff_tool.diff_generator import DiffGenerator\nfrom src.diff_tool.output_formatter import OutputFormatter\n\n@pytest.fixture\ndef file_reader():\n    \"\"\"Provide a configured FileReader instance for testing.\"\"\"\n    return FileReader()\n\n@pytest.fixture\ndef lcs_engine():\n    \"\"\"Provide a configured LCSEngine instance for testing.\"\"\"\n    return LCSEngine()\n\n@pytest.fixture\ndef diff_generator():\n    \"\"\"Provide a configured DiffGenerator instance for testing.\"\"\"\n    return DiffGenerator()\n\n@pytest.fixture\ndef output_formatter():\n    \"\"\"Provide a configured OutputFormatter instance for testing.\"\"\"\n    return OutputFormatter()\n\n@pytest.fixture\ndef test_data_dir():\n    \"\"\"Provide path to test data directory.\"\"\"\n    return Path(__file__).parent / \"test_data\"\n\n@pytest.fixture\ndef sample_files(test_data_dir, tmp_path):\n    \"\"\"Create sample test files with known content and encoding.\"\"\"\n    # TODO: Create UTF-8 file with known content\n    # TODO: Create Latin-1 file with accented characters\n    # TODO: Create file with mixed line endings\n    # TODO: Create empty file\n    # TODO: Return dict mapping file types to file paths\n    pass\n\n@pytest.fixture\ndef known_lcs_cases():\n    \"\"\"Provide test cases with known LCS solutions.\"\"\"\n    return [\n        {\n            'seq1': [\"A\", \"B\", \"C\", \"D\"],\n            'seq2': [\"A\", \"X\", \"B\", \"Y\", \"C\"],\n            'expected_lcs': [\"A\", \"B\", \"C\"],\n            'expected_length': 3\n        },\n        # TODO: Add more known LCS test cases\n        # TODO: Include edge cases: empty sequences, no common elements\n        # TODO: Include cases with repeated elements\n    ]\n```\n\n#### Component Test Skeletons\n\nProvide test class structures for each component with TODO comments mapping to specific test requirements:\n\n```python\n# tests/test_file_reader.py - FileReader component tests\nimport pytest\nfrom src.diff_tool.file_reader import FileReader, FileContent\nfrom src.diff_tool.errors import FileSystemError, EncodingError\n\nclass TestFileReader:\n    \"\"\"Test FileReader component functionality.\"\"\"\n    \n    def test_detect_file_encoding_utf8(self, test_data_dir):\n        \"\"\"Test UTF-8 encoding detection for files with UTF-8 content.\"\"\"\n        # TODO: Create test file with UTF-8 content\n        # TODO: Call detect_file_encoding on test file\n        # TODO: Assert encoding is detected as 'UTF-8'\n        pass\n    \n    def test_detect_file_encoding_latin1(self, test_data_dir):\n        \"\"\"Test Latin-1 encoding detection for files with Latin-1 content.\"\"\"\n        # TODO: Create test file with Latin-1 content (accented characters)\n        # TODO: Call detect_file_encoding on test file\n        # TODO: Assert encoding is detected as 'Latin-1'\n        pass\n    \n    def test_read_file_lines_basic(self, sample_files, file_reader):\n        \"\"\"Test basic file reading with line splitting.\"\"\"\n        # TODO: Use sample UTF-8 file from fixture\n        # TODO: Call read_file_lines to get FileContent object\n        # TODO: Assert lines list matches expected content\n        # TODO: Assert line_count matches len(lines)\n        # TODO: Assert encoding is correctly detected\n        pass\n    \n    def test_normalize_line_endings_unix(self, file_reader):\n        \"\"\"Test normalization of Unix LF line endings.\"\"\"\n        content = \"line1\\nline2\\nline3\\n\"\n        # TODO: Call normalize_line_endings on content\n        # TODO: Assert normalized lines are [\"line1\", \"line2\", \"line3\"]\n        # TODO: Assert original_endings is \"LF\"\n        pass\n    \n    def test_normalize_line_endings_windows(self, file_reader):\n        \"\"\"Test normalization of Windows CRLF line endings.\"\"\"\n        # TODO: Test content with \\r\\n line endings\n        # TODO: Verify normalization produces correct line list\n        # TODO: Verify original format detection\n        pass\n    \n    def test_binary_file_detection(self, test_data_dir, file_reader):\n        \"\"\"Test that binary files are detected and rejected.\"\"\"\n        # TODO: Create binary file with null bytes\n        # TODO: Verify EncodingError is raised when reading\n        # TODO: Verify error message indicates binary file\n        pass\n    \n    def test_file_not_found_error(self, file_reader):\n        \"\"\"Test appropriate error for nonexistent files.\"\"\"\n        # TODO: Call read_file_lines on nonexistent file path\n        # TODO: Assert FileSystemError is raised\n        # TODO: Verify error message contains file path\n        pass\n\n# tests/test_lcs_engine.py - LCSEngine component tests  \nclass TestLCSEngine:\n    \"\"\"Test LCSEngine dynamic programming implementation.\"\"\"\n    \n    def test_compute_lcs_identical_sequences(self, lcs_engine):\n        \"\"\"Test LCS computation for identical sequences.\"\"\"\n        seq1 = [\"A\", \"B\", \"C\"]\n        seq2 = [\"A\", \"B\", \"C\"]\n        # TODO: Call compute_lcs on identical sequences\n        # TODO: Assert returned LCS equals input sequence\n        # TODO: Assert LCS length equals sequence length\n        pass\n    \n    def test_compute_lcs_no_common_elements(self, lcs_engine):\n        \"\"\"Test LCS computation when sequences share no elements.\"\"\"\n        # TODO: Create sequences with no common elements\n        # TODO: Verify LCS is empty list\n        # TODO: Verify LCS length is 0\n        pass\n    \n    def test_build_lcs_matrix_dimensions(self, lcs_engine):\n        \"\"\"Test that LCS matrix has correct dimensions.\"\"\"\n        seq1 = [\"A\", \"B\"]\n        seq2 = [\"X\", \"Y\", \"Z\"]\n        # TODO: Call build_lcs_matrix on test sequences\n        # TODO: Assert matrix has (len(seq1) + 1) rows\n        # TODO: Assert matrix has (len(seq2) + 1) columns\n        # TODO: Verify matrix[0][j] == 0 for all j (empty sequence base case)\n        # TODO: Verify matrix[i][0] == 0 for all i (empty sequence base case)\n        pass\n    \n    def test_backtrack_simple_case(self, lcs_engine, known_lcs_cases):\n        \"\"\"Test backtracking for known LCS cases.\"\"\"\n        for test_case in known_lcs_cases:\n            # TODO: Build LCS matrix for test case sequences\n            # TODO: Call backtrack on completed matrix\n            # TODO: Assert backtracked LCS matches expected result\n            # TODO: Verify LCS is valid subsequence of both inputs\n        pass\n    \n    def test_memory_optimization_trigger(self, lcs_engine):\n        \"\"\"Test that memory optimization triggers for large inputs.\"\"\"\n        # TODO: Create large test sequences that exceed memory threshold\n        # TODO: Mock memory monitoring to verify optimization triggered  \n        # TODO: Verify algorithm switches to memory-efficient version\n        # TODO: Ensure result correctness is maintained\n        pass\n\n# tests/test_diff_generator.py - DiffGenerator component tests\nclass TestDiffGenerator:\n    \"\"\"Test DiffGenerator hunk formation and edit operations.\"\"\"\n    \n    def test_lcs_to_edit_operations_basic(self, diff_generator):\n        \"\"\"Test conversion of LCS to basic edit operations.\"\"\"\n        file1_lines = [\"A\", \"B\", \"C\"]\n        file2_lines = [\"A\", \"X\", \"C\"]  \n        lcs = [\"A\", \"C\"]\n        # TODO: Call lcs_to_edit_operations with test data\n        # TODO: Assert operations are [UNCHANGED, DELETED, ADDED, UNCHANGED]\n        # TODO: Verify line numbers are correctly assigned\n        # TODO: Check that content matches source lines\n        pass\n    \n    def test_diff_lines_to_hunks_single_change(self, diff_generator):\n        \"\"\"Test hunk formation for single isolated change.\"\"\"\n        # TODO: Create DiffLine list with single change surrounded by unchanged lines\n        # TODO: Call diff_lines_to_hunks with context_lines=2\n        # TODO: Assert single hunk is created\n        # TODO: Verify hunk contains appropriate context lines\n        # TODO: Check hunk line counts and ranges\n        pass\n    \n    def test_merge_adjacent_hunks(self, diff_generator):\n        \"\"\"Test merging of hunks that are close together.\"\"\"\n        # TODO: Create two hunks with small gap between them\n        # TODO: Call merge_adjacent_hunks with appropriate max_gap\n        # TODO: Assert hunks are merged into single hunk\n        # TODO: Verify merged hunk has correct line counts\n        # TODO: Check that all lines from both hunks are preserved\n        pass\n    \n    def test_hunk_line_numbering(self, diff_generator):\n        \"\"\"Test that hunk line numbers follow one-indexed conventions.\"\"\"\n        # TODO: Create test diff operations with known line positions\n        # TODO: Generate hunks from operations\n        # TODO: Verify hunk headers use one-based line numbering\n        # TODO: Check old_start, old_count, new_start, new_count values\n        pass\n\n# tests/test_output_formatter.py - OutputFormatter component tests\nclass TestOutputFormatter:\n    \"\"\"Test OutputFormatter unified diff generation and color output.\"\"\"\n    \n    def test_format_unified_diff_headers(self, output_formatter):\n        \"\"\"Test generation of unified diff file headers.\"\"\"\n        file1 = FileContent(\"file1.txt\", [\"line1\"], 1, \"UTF-8\", \"LF\")\n        file2 = FileContent(\"file2.txt\", [\"line2\"], 1, \"UTF-8\", \"LF\")\n        hunks = []\n        # TODO: Call format_unified_diff to generate output\n        # TODO: Assert output starts with \"--- file1.txt\" header\n        # TODO: Assert second line is \"+++ file2.txt\" header\n        # TODO: Verify header format matches unified diff standard\n        pass\n    \n    def test_ansi_color_formatting(self, output_formatter):\n        \"\"\"Test ANSI color code application.\"\"\"\n        # TODO: Create DiffLine with DELETED type\n        # TODO: Format line with colors enabled\n        # TODO: Assert output contains red ANSI codes\n        # TODO: Test ADDED lines get green colors\n        # TODO: Verify UNCHANGED lines have no color\n        pass\n    \n    def test_no_color_mode(self, output_formatter):\n        \"\"\"Test plain text output when colors are disabled.\"\"\"\n        # TODO: Configure formatter with colors disabled\n        # TODO: Format diff lines of various types\n        # TODO: Assert no ANSI codes appear in output\n        # TODO: Verify line prefixes are still correct\n        pass\n\n# tests/test_integration.py - End-to-end integration tests  \nclass TestIntegration:\n    \"\"\"Test complete diff tool pipeline integration.\"\"\"\n    \n    def test_complete_diff_pipeline(self, sample_files):\n        \"\"\"Test full pipeline from file reading to diff output.\"\"\"\n        # TODO: Use sample files with known differences\n        # TODO: Run complete diff pipeline: read -> LCS -> generate -> format\n        # TODO: Verify output contains expected diff structure\n        # TODO: Check that generated diff could be applied with patch\n        pass\n    \n    def test_identical_files_handling(self, sample_files):\n        \"\"\"Test behavior when comparing identical files.\"\"\"\n        # TODO: Compare file with itself\n        # TODO: Verify no hunks are generated  \n        # TODO: Check appropriate exit code (0 for identical)\n        pass\n    \n    def test_performance_large_files(self, tmp_path):\n        \"\"\"Test performance with reasonably large files.\"\"\"\n        # TODO: Generate large test files (1000+ lines)\n        # TODO: Run diff pipeline with timing\n        # TODO: Verify completion within reasonable time limit\n        # TODO: Check memory usage stays within bounds\n        pass\n```\n\n#### Property-Based Test Implementation\n\nProperty-based testing automatically generates test inputs and verifies that important properties hold across all generated cases:\n\n```python\n# tests/test_properties.py - Property-based testing\nfrom hypothesis import given, strategies as st\nimport pytest\nfrom src.diff_tool.lcs_engine import LCSEngine\nfrom src.diff_tool.diff_generator import DiffGenerator\n\nclass TestLCSProperties:\n    \"\"\"Property-based tests for LCS algorithm correctness.\"\"\"\n    \n    @given(st.lists(st.text(min_size=1, max_size=10), max_size=20))\n    def test_lcs_subsequence_property(self, sequence):\n        \"\"\"Test that LCS result is valid subsequence of both inputs.\"\"\"\n        lcs_engine = LCSEngine()\n        # TODO: Generate second sequence as permutation/subset of first\n        # TODO: Compute LCS of both sequences\n        # TODO: Verify LCS appears in both sequences in correct order\n        # TODO: Assert LCS length <= min(len(seq1), len(seq2))\n        pass\n    \n    @given(st.lists(st.text(), max_size=15), st.lists(st.text(), max_size=15))\n    def test_lcs_symmetry_property(self, seq1, seq2):\n        \"\"\"Test that LCS(A,B) has same length as LCS(B,A).\"\"\"\n        lcs_engine = LCSEngine()\n        # TODO: Compute LCS length for (seq1, seq2)\n        # TODO: Compute LCS length for (seq2, seq1) \n        # TODO: Assert both lengths are equal\n        pass\n\nclass TestDiffProperties:\n    \"\"\"Property-based tests for diff generation correctness.\"\"\"\n    \n    @given(st.lists(st.text(), max_size=20), st.lists(st.text(), max_size=20))\n    def test_diff_roundtrip_property(self, file1_lines, file2_lines):\n        \"\"\"Test that applying diff operations transforms file1 to file2.\"\"\"\n        # TODO: Compute LCS of input files\n        # TODO: Generate edit operations from LCS\n        # TODO: Apply operations to file1_lines\n        # TODO: Assert result equals file2_lines\n        pass\n```\n\n#### Milestone Validation Scripts\n\nCreate standalone validation scripts that can be run after completing each milestone:\n\n```python\n# scripts/validate_milestone_1.py - File reading validation\n#!/usr/bin/env python3\n\"\"\"Validate Milestone 1: Line Tokenization implementation.\"\"\"\n\ndef validate_file_reading():\n    \"\"\"Validate basic file reading functionality.\"\"\"\n    print(\"=== Milestone 1 Validation: Line Tokenization ===\")\n    \n    # TODO: Test encoding detection with sample files\n    # TODO: Verify line normalization with different endings\n    # TODO: Check empty line preservation\n    # TODO: Test binary file rejection\n    # TODO: Report validation results with pass/fail status\n    \n    print(\"Validation complete. Check results above.\")\n\nif __name__ == \"__main__\":\n    validate_file_reading()\n\n# scripts/validate_milestone_2.py - LCS algorithm validation  \n#!/usr/bin/env python3\n\"\"\"Validate Milestone 2: LCS Algorithm implementation.\"\"\"\n\ndef validate_lcs_computation():\n    \"\"\"Validate LCS dynamic programming correctness.\"\"\"\n    print(\"=== Milestone 2 Validation: LCS Algorithm ===\")\n    \n    # TODO: Test with known LCS examples\n    # TODO: Verify matrix construction correctness\n    # TODO: Check backtracking produces valid LCS\n    # TODO: Test memory optimization for large inputs\n    # TODO: Report algorithm performance metrics\n    \n    print(\"Validation complete. Check results above.\")\n\nif __name__ == \"__main__\":\n    validate_lcs_computation()\n```\n\n#### Debugging and Performance Analysis Tools\n\nCreate utilities to help diagnose issues and analyze performance during development:\n\n```python\n# tools/debug_lcs.py - LCS algorithm debugging utilities\ndef visualize_lcs_matrix(seq1, seq2, matrix):\n    \"\"\"Print LCS matrix in readable format for debugging.\"\"\"\n    # TODO: Print sequence labels across top and side\n    # TODO: Display matrix values in aligned grid\n    # TODO: Highlight backtrack path if provided\n    # TODO: Show final LCS result below matrix\n    pass\n\ndef trace_backtrack_path(matrix, seq1, seq2):\n    \"\"\"Show step-by-step backtracking process.\"\"\"\n    # TODO: Start from bottom-right matrix cell\n    # TODO: Print each backtrack decision and reasoning\n    # TODO: Show how LCS is built in reverse\n    # TODO: Display final LCS reconstruction\n    pass\n\n# tools/performance_profiler.py - Performance analysis utilities\ndef profile_lcs_performance(sequence_lengths):\n    \"\"\"Profile LCS performance across different input sizes.\"\"\"\n    # TODO: Generate test sequences of specified lengths\n    # TODO: Time LCS computation for each size\n    # TODO: Measure memory usage during computation  \n    # TODO: Plot performance curves\n    # TODO: Identify performance bottlenecks\n    pass\n\ndef memory_usage_analyzer():\n    \"\"\"Analyze memory usage patterns during LCS computation.\"\"\"\n    # TODO: Monitor memory allocation during matrix building\n    # TODO: Track peak memory usage\n    # TODO: Verify memory optimization triggers correctly\n    # TODO: Report memory efficiency metrics\n    pass\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones — debugging skills are essential throughout line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4), with algorithm-specific techniques for each stage\n\n**Mental Model: Medical Diagnosis for Algorithms** — Debugging a diff tool is like diagnosing a patient with multiple interconnected systems. Each component (File Reader, LCS Engine, Diff Generator, Output Formatter) represents an organ system, and symptoms in one area often indicate problems elsewhere. Just as doctors use systematic diagnostic procedures, we need structured approaches to identify the root cause of algorithmic failures. The key is understanding which symptoms point to which underlying conditions, and having the right diagnostic tools to peer inside each \"organ\" of our diff algorithm.\n\nDebugging diff algorithms presents unique challenges because failures can cascade through the pipeline in subtle ways. A file encoding issue in the File Reader can manifest as incorrect LCS computation, which then produces malformed diff hunks, ultimately resulting in garbled terminal output. The dynamic programming nature of LCS computation means that small indexing errors can propagate exponentially, while the contextual grouping in diff generation creates complex interdependencies between seemingly unrelated lines.\n\nThe debugging process requires both systematic symptom analysis and deep algorithmic understanding. Unlike simple business logic bugs, diff algorithm failures often involve mathematical properties like optimal substructure, correctness of recurrence relations, and invariant preservation across component boundaries. This section provides learners with diagnostic frameworks specifically designed for these algorithmic challenges.\n\n### Symptom-Cause-Fix Reference\n\nThe following comprehensive reference table maps common symptoms encountered during diff tool implementation to their likely root causes and specific remediation strategies. Each entry includes detection techniques and step-by-step resolution procedures.\n\n| Symptom | Likely Cause | Detection Technique | Specific Fix |\n|---------|--------------|-------------------|--------------|\n| **Matrix index out of bounds during LCS computation** | Off-by-one error in matrix dimensions or loop bounds | Add boundary checks: `if i < 0 or i >= len(matrix)` before every access | Matrix should be `(len(seq1)+1) x (len(seq2)+1)`. Loop indices should use `range(1, len(seq1)+1)` and `range(1, len(seq2)+1)` for filling |\n| **LCS returns empty result for files with obvious common lines** | Backtracking algorithm moving in wrong direction through matrix | Print backtrack path: log each `(i,j)` position and movement decision | Fix backtracking conditions: move diagonally when `seq1[i-1] == seq2[j-1]`, not when matrix values are equal |\n| **Memory error or system freeze during LCS on large files** | Algorithm using O(mn) space without optimization | Monitor memory usage: `psutil.Process().memory_info().rss` during computation | Implement two-row optimization: only keep current and previous matrix rows, or switch to Hirschberg's algorithm |\n| **Diff output shows wrong line numbers in hunk headers** | Confusion between 0-indexed internal arrays and 1-indexed diff format | Verify: print internal line numbers vs diff output line numbers side by side | Add 1 to all line numbers when formatting: `old_line_num + 1` and `new_line_num + 1` in hunk headers |\n| **Missing lines or duplicated content in diff hunks** | Incorrect edit operation assignment from LCS result | Trace edit script generation: log every ADD/DELETE/UNCHANGED decision with line content | Fix `lcs_to_edit_operations`: ensure each line from both files appears exactly once in edit operations |\n| **Hunk context lines show incorrect content** | Context extraction using wrong line indices or ranges | Print context ranges: log `start_idx` and `end_idx` for each context region | Context should use original file line indices, not edit operation indices. Verify bounds checking against `len(file_lines)` |\n| **File reading fails with encoding errors** | Binary file processed as text, or wrong encoding assumption | Check file type: `file --mime-type filename` and inspect first 100 bytes as hex | Implement binary detection: if file contains null bytes or high percentage of non-printable characters, reject as binary |\n| **Line endings inconsistent in output** | Mixed line ending normalization or preservation failure | Hexdump file endings: `od -c filename | tail` to see actual line terminators | Normalize consistently: detect original endings with `detect_line_endings()`, convert all to LF internally, preserve original format in output |\n| **Empty files cause crashes** | Missing edge case handling for zero-length sequences | Test with: `touch empty.txt && diff_tool empty.txt nonempty.txt` | Add checks: if `len(sequence) == 0`, return appropriate empty results instead of processing through normal algorithm |\n| **Identical files show differences** | Whitespace normalization inconsistency or trailing newline handling | Compare raw bytes: `cmp file1 file2` vs your tool's result | Ensure identical normalization: both files must undergo same whitespace trimming and line ending conversion |\n| **Color codes appear in redirected output** | TTY detection failure or missing --no-color support | Test: `diff_tool file1 file2 > output.txt && cat output.txt` | Fix TTY detection: use `sys.stdout.isatty()` and respect `--no-color` flag to disable ANSI codes |\n| **Hunks merge incorrectly or stay separate unexpectedly** | Hunk merging logic using wrong distance calculation | Print hunk gaps: log line numbers between consecutive hunks and merge decisions | Gap calculation should be `hunk2.old_start - (hunk1.old_start + hunk1.old_count + hunk1.context_after)`. Merge if gap ≤ 2 * context_lines |\n| **Program hangs during file processing** | Infinite loop in backtracking or file reading without progress | Add progress logging: print percentage completion every 1000 iterations | Check loop termination: backtracking should always decrease `i` or `j`, file reading should check for EOF after each read operation |\n| **Diff output missing @@ hunk headers** | Hunk header generation skipped or formatted incorrectly | Verify header format: should match regex `@@\\s-\\d+,\\d+\\s\\+\\d+,\\d+\\s@@` | Header format: `@@ -{old_start},{old_count} +{new_start},{new_count} @@` with 1-indexed line numbers |\n| **Exit code always 0 regardless of differences** | Exit code logic not implemented or wrong conditions | Test: `diff_tool identical.txt identical.txt; echo $?` should be 0, different files should be 1 | Set exit code based on diff result: `sys.exit(0)` if no differences found, `sys.exit(1)` if differences exist |\n| **Context lines duplicated at hunk boundaries** | Overlapping context regions not handled during hunk merging | Check context overlap: log context ranges when merging adjacent hunks | When merging hunks, deduplicate overlapping context: shared lines should appear once, not in both hunks |\n\n⚠️ **Pitfall: Debugging with Print Statements**\nMany learners add `print()` statements throughout their algorithm but this creates several problems. Print debugging can mask timing issues, produce overwhelming output that obscures the actual problem, and interfere with proper output formatting (especially with color codes). Instead, use structured logging with levels (`logging.debug()`, `logging.info()`) and enable debug output only when needed via command-line flags.\n\n⚠️ **Pitfall: Testing Only with Small Files**\nAlgorithms that work perfectly on 10-line files can fail catastrophically on 1000-line files due to memory exhaustion, indexing errors that only manifest at scale, or performance degradation that reveals algorithmic flaws. Always test with files of varying sizes: empty files, single-line files, files with thousands of lines, and files with very long individual lines.\n\n### Debugging Techniques\n\nThe following systematic approaches provide structured methods for diagnosing and resolving issues specific to diff algorithm implementation. Each technique targets different aspects of the algorithm pipeline and provides concrete steps for investigation.\n\n#### Matrix Inspection and Visualization\n\nThe LCS dynamic programming matrix contains the complete computational history and can reveal algorithmic errors that are invisible from final output alone. Understanding how to read and interpret the matrix is crucial for debugging the core algorithm.\n\n**Matrix Validation Technique:**\n\nCreate a matrix visualization function that displays the LCS matrix with sequence elements as headers. For sequences `[\"a\", \"b\", \"c\"]` and `[\"a\", \"c\"]`, the correct matrix should show:\n\n```\n    \"\"  a   c\n\"\"   0  0   0\na    0  1   1  \nb    0  1   1\nc    0  1   2\n```\n\nThe matrix reveals several key properties that must hold for correct LCS computation. Each cell `(i,j)` represents the LCS length for the first `i` elements of sequence 1 and first `j` elements of sequence 2. Values should never decrease when moving right or down through the matrix. The bottom-right cell contains the final LCS length. Diagonal moves (when characters match) should increment the value from the diagonal predecessor.\n\n**Backtracking Path Verification:**\n\nImplement a path tracer that logs each backtracking decision with its rationale. The backtracking algorithm should follow these decision rules consistently:\n\n1. If characters match (`seq1[i-1] == seq2[j-1]`), move diagonally and include the character in LCS\n2. If `matrix[i-1][j] > matrix[i][j-1]`, move up (deletion from sequence 1)  \n3. Otherwise, move left (insertion into sequence 1)\n\nLog each decision: `\"At (3,2): seq1[2]='c' != seq2[1]='c' - MISMATCH. matrix[2][2]=1, matrix[3][1]=1. Moving left.\"` This reveals logic errors in the backtracking conditions.\n\n**Common Matrix Debugging Patterns:**\n\nValues that are too high indicate incorrect recurrence relation implementation - check that matches only increment by 1 and non-matches take the maximum of adjacent cells. Zeros appearing in unexpected locations suggest initialization problems or boundary condition errors. A matrix filled entirely with 1s typically indicates the loop is only comparing the first characters repeatedly rather than iterating through sequences correctly.\n\n#### Algorithm Execution Tracing\n\nStep-by-step execution tracing reveals the decision-making process within each algorithm component and helps identify where expectations diverge from reality.\n\n**LCS Computation Tracing:**\n\nImplement detailed logging for each matrix cell computation. For each `(i,j)` position, log the comparison being made, the predecessor values consulted, and the resulting cell value. This creates an audit trail of the dynamic programming process:\n\n```\nComputing cell (2,3): comparing seq1[1]='b' with seq2[2]='c'\n  Characters don't match\n  Left neighbor matrix[2][2] = 1  \n  Top neighbor matrix[1][3] = 1\n  Taking max(1,1) = 1\n  Setting matrix[2][3] = 1\n```\n\nThis granular tracing immediately reveals whether the algorithm is accessing correct sequence positions, using proper indexing, and applying the recurrence relation correctly.\n\n**Edit Operation Generation Tracing:**\n\nWhen converting LCS results to edit operations, trace each decision point that determines whether a line should be marked as UNCHANGED, ADDED, or DELETED. Log the current positions in both sequences, the characters being compared, and the reasoning for the operation type assignment:\n\n```\nLCS position 5: seq1[7]='def' matches seq2[12]='def' → UNCHANGED\nBetween matches: seq1[8]='ghi' not in LCS → DELETED  \nNext LCS match at seq2[13]='jkl', gap seq2[13]='extra' → ADDED\n```\n\nThis reveals gaps in LCS coverage and ensures every line from both input sequences is properly classified in the edit script.\n\n**Hunk Formation Tracing:**\n\nThe process of grouping edit operations into hunks with context involves complex boundary calculations and merging decisions. Trace each step of hunk formation:\n\n```\nFound change block: lines 10-15 (3 deletions, 2 additions)\nAdding context: before=[7,8,9] after=[16,17,18]  \nHunk created: old_start=8 old_count=9 new_start=8 new_count=8\nChecking merge with next hunk at line 25: gap=7 > 2*context(3) → separate hunks\n```\n\nThis debugging approach reveals incorrect line counting, context boundary errors, and merging logic failures.\n\n#### Output Format Validation\n\nDiff output must conform to standardized formats that other tools can parse correctly. Validation techniques ensure compliance with format specifications.\n\n**Unified Diff Format Compliance:**\n\nImplement a format validator that checks each element of the unified diff output against the specification. The validator should verify:\n\n- File headers use exactly `---` and `+++` prefixes with proper spacing\n- Hunk headers match the pattern `@@ -{old_start},{old_count} +{new_start},{new_count} @@`\n- Line prefixes are exactly one character: space for unchanged, `-` for deleted, `+` for added\n- Line numbers in headers are 1-indexed and match the actual line counts in the hunk body\n- No trailing whitespace on empty lines (represented as single prefix character)\n\n**ANSI Color Code Validation:**\n\nWhen color output is enabled, verify that ANSI codes are properly paired and don't interfere with format parsing. Create a validator that strips ANSI codes and confirms the underlying text still matches unified diff format:\n\n```python\ndef validate_color_output(colored_line):\n    stripped = re.sub(r'\\033\\[[0-9;]*m', '', colored_line)  \n    return validate_diff_line_format(stripped)\n```\n\nColor codes should only wrap the content portion of diff lines, not the prefix characters or line numbers that tools use for parsing.\n\n**Line Number Consistency Checking:**\n\nImplement a checker that verifies line number consistency throughout the diff output. Track running totals of old and new line numbers as you process each hunk, ensuring that:\n\n- Hunk header line counts match the actual number of lines in the hunk body\n- Line number sequences are continuous with no gaps or duplicates  \n- UNCHANGED lines increment both old and new line counters\n- DELETED lines increment only old line counter\n- ADDED lines increment only new line counter\n\nThis catches off-by-one errors and incorrect line counting that can make diff output unusable by other tools.\n\n#### Memory and Performance Debugging\n\nLarge file processing reveals memory leaks, inefficient algorithms, and resource management issues that don't appear with small test cases.\n\n**Memory Usage Monitoring:**\n\nImplement memory tracking that monitors heap usage throughout algorithm execution. Track peak memory usage during matrix construction, backtracking, and diff generation phases:\n\n```python\nimport psutil\nimport gc\n\ndef track_memory(phase_name):\n    gc.collect()  # Force garbage collection  \n    process = psutil.Process()\n    memory_mb = process.memory_info().rss / 1024 / 1024\n    print(f\"{phase_name}: {memory_mb:.1f} MB\")\n```\n\nMonitor for memory growth that doesn't match algorithmic expectations. The LCS matrix should require approximately `len(seq1) * len(seq2) * 8 bytes` for integer storage. Significantly higher usage indicates data structure inefficiency or memory leaks.\n\n**Algorithm Complexity Verification:**\n\nMeasure actual runtime against theoretical complexity expectations. For sequences of length `m` and `n`, LCS computation should exhibit O(mn) time complexity. Test with progressively larger inputs and verify that runtime scales predictably:\n\n- 100x100 sequences → baseline time T\n- 200x200 sequences → approximately 4T  \n- 1000x1000 sequences → approximately 100T\n\nDeviation from expected scaling indicates algorithmic inefficiency or implementation errors that cause redundant computation.\n\n**Resource Limit Testing:**\n\nTest algorithm behavior at system resource boundaries. Create test cases that approach memory limits, processing time limits, and file system constraints. This reveals whether the algorithm fails gracefully or crashes unpredictably:\n\n```python\n# Test with files approaching memory limits\nlarge_file_size = psutil.virtual_memory().available // 2\ncreate_test_file(large_file_size)\n\n# Test with deep recursion (for recursive implementations)\nsys.setrecursionlimit(100)  # Lower than default\ntest_with_long_sequences()\n```\n\n#### Property-Based Testing Integration\n\nProperty-based testing generates random inputs and verifies that algorithmic properties hold across diverse scenarios.\n\n**LCS Property Verification:**\n\nImplement property tests that verify fundamental LCS properties:\n\n- **Subsequence Property**: Every element in the returned LCS must appear in both original sequences in the same relative order\n- **Optimality Property**: No longer common subsequence should exist (verify by checking all possible extensions)\n- **Symmetry Property**: `lcs(A, B)` should have the same length as `lcs(B, A)` (though elements may differ if multiple optimal solutions exist)\n\n**Edit Script Property Verification:**\n\nVerify that edit scripts correctly transform one sequence into another:\n\n- **Transformation Property**: Applying all edit operations to sequence 1 should yield sequence 2\n- **Minimality Property**: The total number of ADD and DELETE operations should equal the edit distance\n- **Coverage Property**: Every line from both input sequences should appear exactly once across all edit operations\n\n**Round-Trip Testing:**\n\nImplement round-trip tests that verify the complete pipeline preserves information correctly:\n\n1. Start with two known file contents\n2. Process through complete diff pipeline  \n3. Apply the generated diff operations to reconstruct the second file\n4. Verify the reconstructed content matches the original second file exactly\n\nThis end-to-end testing catches subtle bugs that unit tests might miss, especially issues involving line ending preservation, whitespace handling, and context line selection.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|-----------------|\n| Logging Framework | Python `logging` with console handler | Structured logging with JSON output and log levels |\n| Memory Profiling | `psutil` for basic memory monitoring | `memory_profiler` with line-by-line analysis |\n| Test Generation | Manual test cases with known outputs | `hypothesis` for property-based test generation |\n| Performance Measurement | `time.time()` for basic timing | `cProfile` with statistical analysis |\n| Matrix Visualization | Print statements with formatted output | Rich terminal UI with color-coded matrices |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  debug/\n    matrix_visualizer.py     ← LCS matrix inspection tools\n    trace_logger.py          ← Algorithm execution tracing\n    property_tester.py       ← Property-based test generators\n    memory_profiler.py       ← Resource usage monitoring\n    format_validator.py      ← Output format compliance checking\n  tests/\n    debug_test_cases/       ← Problematic cases for debugging\n      edge_cases.py         ← Empty files, identical files, etc.\n      large_files.py        ← Memory and performance stress tests\n      malformed_input.py    ← Binary files, encoding issues\n  src/\n    diff_tool/\n      debug_hooks.py        ← Integration points for debugging tools\n```\n\n#### Debugging Infrastructure Starter Code\n\n**Complete Matrix Visualizer:**\n\n```python\n\"\"\"\nMatrix visualization and validation tools for LCS debugging.\n\"\"\"\nimport sys\nfrom typing import List, Optional, Tuple\n\nclass MatrixVisualizer:\n    \"\"\"Provides visualization and validation for LCS dynamic programming matrices.\"\"\"\n    \n    def __init__(self, seq1: List[str], seq2: List[str], matrix: List[List[int]]):\n        self.seq1 = seq1\n        self.seq2 = seq2  \n        self.matrix = matrix\n        \n    def display_matrix(self) -> str:\n        \"\"\"Generate a formatted matrix display with sequence headers.\"\"\"\n        # Calculate column widths for proper alignment\n        col_widths = [max(3, len(str(val))) for val in ['']+self.seq2]\n        row_headers = ['']+self.seq1\n        \n        # Build header row\n        header = \"\".join(f\"{val:>{width}}\" for val, width in zip([''] + self.seq2, col_widths))\n        lines = [header]\n        \n        # Build data rows  \n        for i, row_header in enumerate(row_headers):\n            row_data = [row_header] + [str(self.matrix[i][j]) for j in range(len(self.matrix[i]))]\n            line = \"\".join(f\"{val:>{width}}\" for val, width in zip(row_data, col_widths))\n            lines.append(line)\n            \n        return \"\\n\".join(lines)\n        \n    def validate_matrix_properties(self) -> List[str]:\n        \"\"\"Validate that matrix satisfies LCS properties.\"\"\"\n        errors = []\n        \n        # Check dimensions\n        expected_rows = len(self.seq1) + 1\n        expected_cols = len(self.seq2) + 1\n        if len(self.matrix) != expected_rows:\n            errors.append(f\"Wrong row count: got {len(self.matrix)}, expected {expected_rows}\")\n        if any(len(row) != expected_cols for row in self.matrix):\n            errors.append(f\"Inconsistent column count: expected {expected_cols}\")\n            \n        # Check boundary conditions (first row and column should be zeros)\n        if any(self.matrix[0][j] != 0 for j in range(len(self.matrix[0]))):\n            errors.append(\"First row should be all zeros\")\n        if any(self.matrix[i][0] != 0 for i in range(len(self.matrix))):\n            errors.append(\"First column should be all zeros\")\n            \n        # Check monotonicity (values never decrease moving right or down)\n        for i in range(1, len(self.matrix)):\n            for j in range(1, len(self.matrix[i])):\n                current = self.matrix[i][j]\n                left = self.matrix[i][j-1]  \n                top = self.matrix[i-1][j]\n                \n                if current < left:\n                    errors.append(f\"Value decreased moving right at ({i},{j}): {left} -> {current}\")\n                if current < top:\n                    errors.append(f\"Value decreased moving down at ({i},{j}): {top} -> {current}\")\n                    \n        return errors\n\nclass BacktrackTracer:\n    \"\"\"Traces backtracking path through LCS matrix for debugging.\"\"\"\n    \n    def __init__(self, matrix: List[List[int]], seq1: List[str], seq2: List[str]):\n        self.matrix = matrix\n        self.seq1 = seq1\n        self.seq2 = seq2\n        \n    def trace_backtrack(self) -> Tuple[List[str], List[Tuple[int, int, str]]]:\n        \"\"\"Perform backtracking with detailed logging of each decision.\"\"\"\n        lcs = []\n        path = []\n        \n        i, j = len(self.seq1), len(self.seq2)\n        \n        while i > 0 and j > 0:\n            current = self.matrix[i][j]\n            \n            if self.seq1[i-1] == self.seq2[j-1]:\n                # Characters match - move diagonally\n                lcs.append(self.seq1[i-1])\n                path.append((i, j, f\"MATCH: '{self.seq1[i-1]}' - diagonal to ({i-1},{j-1})\"))\n                i -= 1\n                j -= 1\n            elif self.matrix[i-1][j] > self.matrix[i][j-1]:\n                # Deletion from seq1 - move up\n                path.append((i, j, f\"DELETE seq1[{i-1}]='{self.seq1[i-1]}' - up to ({i-1},{j})\"))\n                i -= 1\n            else:\n                # Insertion into seq1 - move left  \n                path.append((i, j, f\"INSERT seq2[{j-1}]='{self.seq2[j-1]}' - left to ({i},{j-1})\"))\n                j -= 1\n                \n        # Handle remaining elements\n        while i > 0:\n            path.append((i, j, f\"DELETE remaining seq1[{i-1}]='{self.seq1[i-1]}'\"))\n            i -= 1\n        while j > 0:\n            path.append((i, j, f\"INSERT remaining seq2[{j-1}]='{self.seq2[j-1]}'\"))\n            j -= 1\n            \n        lcs.reverse()  # Backtracking builds LCS in reverse order\n        return lcs, path\n```\n\n**Complete Performance Monitor:**\n\n```python\n\"\"\"\nPerformance and resource monitoring for diff algorithm debugging.\n\"\"\"\nimport time\nimport psutil\nimport gc\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass PerformanceStats:\n    \"\"\"Statistics collected during algorithm execution.\"\"\"\n    start_time: float\n    end_time: Optional[float]\n    peak_memory_mb: float\n    operations_count: int\n    matrix_size: Tuple[int, int]\n    algorithm_phase: str\n    \n    @property\n    def elapsed_time(self) -> float:\n        if self.end_time is None:\n            return time.time() - self.start_time\n        return self.end_time - self.start_time\n\nclass PerformanceMonitor:\n    \"\"\"Monitors resource usage during algorithm execution.\"\"\"\n    \n    def __init__(self):\n        self.stats: Dict[str, PerformanceStats] = {}\n        self.current_phase: Optional[str] = None\n        \n    def start_phase(self, phase_name: str, matrix_size: Tuple[int, int] = (0, 0)):\n        \"\"\"Begin monitoring a specific algorithm phase.\"\"\"\n        if self.current_phase:\n            self.end_phase()\n            \n        self.current_phase = phase_name\n        gc.collect()  # Clean slate for memory measurement\n        \n        self.stats[phase_name] = PerformanceStats(\n            start_time=time.time(),\n            end_time=None,\n            peak_memory_mb=self._get_memory_usage_mb(),\n            operations_count=0,\n            matrix_size=matrix_size,\n            algorithm_phase=phase_name\n        )\n        \n    def end_phase(self):\n        \"\"\"Complete monitoring of current phase.\"\"\"\n        if not self.current_phase:\n            return\n            \n        stats = self.stats[self.current_phase]\n        stats.end_time = time.time()\n        stats.peak_memory_mb = max(stats.peak_memory_mb, self._get_memory_usage_mb())\n        self.current_phase = None\n        \n    def record_operation(self, count: int = 1):\n        \"\"\"Record completion of algorithm operations (e.g., matrix cell computations).\"\"\"\n        if self.current_phase:\n            self.stats[self.current_phase].operations_count += count\n            # Update peak memory periodically\n            if self.stats[self.current_phase].operations_count % 1000 == 0:\n                current_memory = self._get_memory_usage_mb()\n                self.stats[self.current_phase].peak_memory_mb = max(\n                    self.stats[self.current_phase].peak_memory_mb, \n                    current_memory\n                )\n                \n    def get_report(self) -> Dict[str, Any]:\n        \"\"\"Generate performance report for all monitored phases.\"\"\"\n        report = {}\n        \n        for phase_name, stats in self.stats.items():\n            complexity_score = \"N/A\"\n            if stats.matrix_size[0] > 0 and stats.matrix_size[1] > 0:\n                expected_ops = stats.matrix_size[0] * stats.matrix_size[1]\n                if expected_ops > 0:\n                    complexity_score = f\"{stats.operations_count / expected_ops:.2f}x expected\"\n                    \n            report[phase_name] = {\n                \"elapsed_time\": stats.elapsed_time,\n                \"peak_memory_mb\": stats.peak_memory_mb,\n                \"operations\": stats.operations_count,\n                \"matrix_size\": stats.matrix_size,\n                \"complexity_score\": complexity_score\n            }\n            \n        return report\n        \n    def _get_memory_usage_mb(self) -> float:\n        \"\"\"Get current process memory usage in MB.\"\"\"\n        process = psutil.Process()\n        return process.memory_info().rss / 1024 / 1024\n```\n\n#### Core Debugging Integration Points\n\n**Debug-Enhanced LCS Engine:**\n\n```python\nclass DebugLCSEngine(LCSEngine):\n    \"\"\"LCS engine with debugging capabilities enabled.\"\"\"\n    \n    def __init__(self, debug_enabled: bool = False):\n        super().__init__()\n        self.debug_enabled = debug_enabled\n        self.visualizer: Optional[MatrixVisualizer] = None\n        self.tracer: Optional[BacktrackTracer] = None\n        self.monitor = PerformanceMonitor()\n        \n    def compute_lcs(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:\n        \"\"\"Compute LCS with optional debugging instrumentation.\"\"\"\n        # TODO 1: Start performance monitoring for matrix construction phase\n        # TODO 2: Build LCS matrix with debug logging if enabled\n        # TODO 3: Create matrix visualizer if debug mode active\n        # TODO 4: Validate matrix properties and report any violations\n        # TODO 5: Start performance monitoring for backtracking phase  \n        # TODO 6: Perform backtracking with path tracing if enabled\n        # TODO 7: Generate performance report and debug output\n        # TODO 8: Return CommonSubsequence with debug metadata attached\n        pass\n        \n    def _debug_matrix_construction(self, seq1: Sequence, seq2: Sequence) -> List[List[int]]:\n        \"\"\"Build matrix with detailed logging for debugging.\"\"\"\n        # TODO 1: Log matrix dimensions and expected memory usage\n        # TODO 2: Initialize matrix with boundary condition logging\n        # TODO 3: Fill matrix with cell-by-cell operation logging\n        # TODO 4: Validate intermediate results every N operations\n        # TODO 5: Check for memory usage spikes during construction\n        pass\n        \n    def _validate_and_report(self):\n        \"\"\"Generate comprehensive debugging report.\"\"\"\n        # TODO 1: Run matrix property validation\n        # TODO 2: Generate matrix visualization if requested\n        # TODO 3: Create backtracking trace log\n        # TODO 4: Compile performance statistics  \n        # TODO 5: Write debug report to configured output stream\n        pass\n```\n\n#### Language-Specific Debugging Hints\n\n**Python Debugging Tools:**\n- Use `pdb.set_trace()` for interactive debugging at algorithm decision points\n- Install `memory_profiler`: `pip install memory_profiler` for line-by-line memory analysis  \n- Use `sys.getsizeof()` to measure data structure memory usage\n- Enable warnings: `python -W all diff_tool.py` to catch potential issues\n- Use `tracemalloc` module for detailed memory allocation tracking\n\n**Matrix Indexing Safety:**\n- Always use `range(1, len(seq)+1)` for matrix filling loops to avoid off-by-one errors\n- Add assertions: `assert 0 <= i < len(matrix)` before every matrix access\n- Use `matrix[i][j] if i < len(matrix) and j < len(matrix[i]) else 0` for safe access\n\n**File Handling Edge Cases:**\n- Test with `os.devnull` as input to verify empty file handling\n- Use `tempfile.NamedTemporaryFile()` for creating test files with specific encodings\n- Test with files lacking trailing newlines: `echo -n \"content\" > test.txt`\n\n#### Milestone Checkpoint Integration\n\n**After Milestone 1 (Line Tokenization):**\nExpected behavior: `python debug/test_tokenization.py` should validate file reading with various encodings and line endings. Manual verification: create files with different encodings and verify line counts match `wc -l` output.\n\n**After Milestone 2 (LCS Algorithm):**  \nExpected behavior: `python debug/matrix_validator.py` should confirm matrix properties hold for test cases. Debug output should show matrix visualization for small examples. Performance monitor should report O(mn) complexity scaling.\n\n**After Milestone 3 (Diff Generation):**\nExpected behavior: `python debug/format_validator.py` should verify unified diff format compliance. Round-trip tests should successfully reconstruct target files from diff operations.\n\n**After Milestone 4 (CLI and Color Output):**\nExpected behavior: All debugging tools should work through CLI interface. Color output should validate correctly in both TTY and pipe modes. Exit codes should match diff result status.\n\n\n## Future Extensions\n\n> **Milestone(s):** All milestones — future extensions build upon the complete foundation from line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)\n\nThe current diff tool design provides a solid foundation that can accommodate numerous enhancements while maintaining architectural integrity. Like building a house with a strong foundation that can support additional floors, our component-based architecture with clear separation between `FileReader`, `LCSEngine`, `DiffGenerator`, and `OutputFormatter` allows for incremental improvements without requiring fundamental restructuring.\n\nThe extension strategy follows a principle of **progressive enhancement** — each improvement builds upon existing capabilities while preserving backward compatibility. This approach ensures that basic diff functionality remains stable while advanced features can be added, disabled, or modified independently. The modular design means that algorithm improvements can be implemented as alternative strategies within the `LCSEngine`, while output enhancements can be added as new formatters alongside the existing `OutputFormatter`.\n\n### Algorithm Improvements\n\nThe current LCS-based approach represents just one point in the rich landscape of diff algorithms. Like choosing between different route-finding algorithms for navigation — some optimize for shortest distance, others for fastest time, others for avoiding traffic — different diff algorithms optimize for different characteristics. Our architecture anticipates this diversity by encapsulating algorithm choice within the `LCSEngine` component.\n\n#### Myers' Algorithm Implementation\n\n**Mental Model: The Shortest Edit Path**  \nThink of text comparison as finding the shortest path through a maze where each cell represents a comparison between characters or lines. Myers' algorithm is like having a GPS that explores multiple paths simultaneously, always pursuing the most promising routes first. Instead of filling out the entire maze (like our current LCS matrix approach), Myers' algorithm uses an **edit graph** where diagonal moves represent matches and horizontal/vertical moves represent insertions/deletions.\n\nThe algorithm maintains a concept of **edit distance** — the minimum number of operations needed to transform one sequence into another. Myers' algorithm achieves O(n+d²) expected performance where d is the actual edit distance, making it significantly faster than O(mn) LCS when files are similar.\n\n> **Decision: Myers' Algorithm Integration Strategy**  \n> - **Context**: Current O(mn) LCS algorithm becomes prohibitively slow for large files, especially when most content is similar  \n> - **Options Considered**: Replace LCS entirely, implement Myers' as alternative strategy, hybrid approach  \n> - **Decision**: Implement Myers' as selectable strategy within existing `LCSEngine` architecture  \n> - **Rationale**: Preserves backward compatibility while providing performance benefits; allows algorithm comparison and fallback behavior  \n> - **Consequences**: Enables handling larger files efficiently while maintaining simple LCS for educational purposes and edge cases\n\n| Algorithm Aspect | LCS Dynamic Programming | Myers' Algorithm | Implementation Impact |\n|---|---|---|---|\n| Time Complexity | O(mn) always | O(n+d²) expected | Myers' much faster for similar files |\n| Space Complexity | O(mn) or O(min(m,n)) optimized | O(n+d) | Myers' uses less memory |\n| Implementation Complexity | Straightforward DP table | Complex edit graph traversal | Myers' requires more sophisticated code |\n| Educational Value | Excellent for learning DP | Advanced algorithm concepts | Keep both for different learning objectives |\n| Worst-Case Behavior | Predictable O(mn) | Can degrade to O(mn) for very different files | Need fallback strategy |\n\nThe `LCSEngine` would be enhanced with a strategy selection mechanism. The `choose_strategy(seq1_len, seq2_len)` method would analyze input characteristics and select the optimal algorithm. For files under 1000 lines or when educational mode is enabled, the system would use traditional LCS. For larger files, Myers' algorithm would be preferred.\n\n```python\n# Enhanced LCSEngine with algorithm selection\ndef choose_strategy(self, seq1_len: int, seq2_len: int) -> MemoryStrategy:\n    estimated_lcs_memory = (seq1_len * seq2_len * 8) / (1024 * 1024)  # MB\n    \n    if self.educational_mode or seq1_len < 1000 or seq2_len < 1000:\n        return MemoryStrategy(algorithm=\"lcs_matrix\", max_memory_mb=estimated_lcs_memory, \n                            estimated_time_factor=1.0)\n    elif estimated_lcs_memory > self.memory_optimizer.max_memory_mb:\n        return MemoryStrategy(algorithm=\"myers\", max_memory_mb=estimated_lcs_memory * 0.1,\n                            estimated_time_factor=0.3)\n    else:\n        return MemoryStrategy(algorithm=\"lcs_matrix\", max_memory_mb=estimated_lcs_memory,\n                            estimated_time_factor=1.0)\n```\n\nThe Myers' implementation would require a new `EditGraph` data structure and `MyersEngine` class that implements the same interface as the current LCS approach but uses fundamentally different internal algorithms.\n\n#### Word-Level and Character-Level Diffing\n\n**Mental Model: Zoom Levels in Image Editing**  \nCurrent line-level diffing is like viewing an image at 100% zoom — you see the overall structure but miss fine details. Word-level diffing is like zooming to 200% to see individual pixels, while character-level diffing is like examining the image at 400% magnification. Each zoom level reveals different types of changes that matter for different use cases.\n\nWord-level diffing becomes essential when comparing prose documents, configuration files, or code where line boundaries don't align with logical changes. A developer who renames a variable or fixes a typo shouldn't see the entire line marked as deleted and re-added — they should see the specific word that changed highlighted within the line context.\n\n> **Decision: Hierarchical Diffing Architecture**  \n> - **Context**: Line-level diffing misses granular changes within lines, making output less readable for small modifications  \n> - **Options Considered**: Replace line diffing with word diffing, implement separate word-diff tool, hierarchical approach  \n> - **Decision**: Implement hierarchical diffing where line-level diff identifies changed lines, then word-level diff analyzes differences within those lines  \n> - **Rationale**: Provides both structural overview and detailed changes; leverages existing line-level infrastructure  \n> - **Consequences**: More complex output format but significantly improved usability for code review and document editing\n\nThe architecture would extend the `DiffGenerator` component with a `HierarchicalDiffGenerator` that performs multi-level analysis:\n\n| Diff Level | Input Unit | Algorithm | Use Case | Output Enhancement |\n|---|---|---|---|---|\n| Line | File lines | Current LCS/Myers' | Structural changes | Current unified diff format |\n| Word | Line tokens split by whitespace/punctuation | LCS on word sequences | Variable renames, text editing | Highlighted words within unchanged lines |\n| Character | Individual characters | Character-level LCS | Typo fixes, small edits | Precise change highlighting |\n| Semantic | AST nodes (future) | Tree diff algorithms | Code refactoring | Semantic change descriptions |\n\nThe word-level implementation would introduce a `TokenizerEngine` that splits lines into meaningful units:\n\n```python\nclass TokenizerEngine:\n    def tokenize_line(self, line: str, mode: str) -> List[Token]:\n        \"\"\"Split line into tokens based on mode (word, character, semantic)\"\"\"\n        # TODO 1: Apply appropriate tokenization strategy\n        # TODO 2: Preserve whitespace information for reconstruction\n        # TODO 3: Handle punctuation and special characters appropriately\n        # TODO 4: Return Token objects with position and type metadata\n```\n\nEach `Token` would maintain enough information to reconstruct the original line while enabling granular diff analysis. The `DiffGenerator` would first perform line-level diffing, then apply word-level analysis to lines marked as changed, producing nested `DiffLine` objects that contain both line-level and word-level change information.\n\n#### Semantic Diffing for Code\n\n**Mental Model: Understanding vs. Memorizing**  \nTraditional diff algorithms are like students who memorize text without understanding — they notice every character change but miss the logical meaning. Semantic diffing is like a teacher who understands the subject matter and can recognize when two different explanations convey the same concept. For code, this means understanding that `if (x == true)` and `if (x)` are semantically equivalent even though they're textually different.\n\nSemantic diffing requires parsing code into Abstract Syntax Trees (AST) and comparing structural relationships rather than textual representation. This approach can identify meaningful changes like algorithm modifications while ignoring cosmetic changes like formatting, variable renames that don't affect logic, or comment additions.\n\nThe implementation would extend our architecture with a `SemanticDiffEngine` that operates on AST representations:\n\n| Code Change Type | Traditional Diff View | Semantic Diff View | Business Value |\n|---|---|---|---|\n| Variable Rename | Every line changed | \"Renamed variable: oldName → newName\" | Ignore cosmetic changes |\n| Function Move | Large deletion + addition | \"Moved function: Class1 → Class2\" | Focus on structural changes |\n| Comment Addition | Line additions throughout | No change reported | Hide documentation updates |\n| Whitespace/Formatting | Extensive line changes | No change reported | Ignore style-only changes |\n| Algorithm Change | Mixed line changes | \"Modified sorting algorithm\" | Highlight logic changes |\n\nThe semantic engine would require language-specific parsers but could integrate with existing tools like Python's `ast` module, JavaScript's Babel parser, or tree-sitter for multi-language support.\n\n### Output Format Enhancements\n\nThe current unified diff format serves as a solid foundation, but different use cases demand different presentation approaches. Like a newspaper that might present the same information as a headline, detailed article, or infographic depending on the audience, our diff tool should support multiple output formats optimized for different consumption patterns.\n\n#### Side-by-Side Display\n\n**Mental Model: Parallel Reading**  \nThink of side-by-side diff display like reading parallel translations of a book — you can see both versions simultaneously and easily correlate changes across the two texts. This is particularly valuable for code review where understanding the context around changes is crucial, or for document editing where you need to see both the original intent and the revised version.\n\nSide-by-side display requires fundamentally different layout calculations compared to unified diff format. Instead of interleaving changes in a single column, the formatter must align corresponding sections and handle cases where insertions and deletions don't match up cleanly.\n\n> **Decision: Responsive Side-by-Side Layout**  \n> - **Context**: Unified diff format becomes difficult to read for large changes; reviewers need to see both versions simultaneously  \n> - **Options Considered**: Fixed two-column layout, responsive width adaptation, horizontal scrolling  \n> - **Decision**: Implement responsive layout that adapts to terminal width with graceful degradation  \n> - **Rationale**: Maximizes readability across different terminal sizes while providing side-by-side benefits  \n> - **Consequences**: More complex rendering logic but significantly improved user experience for code review\n\nThe implementation would extend `OutputFormatter` with a `SideBySideFormatter` class:\n\n| Layout Challenge | Solution Approach | Implementation Notes |\n|---|---|---|\n| Terminal Width Detection | Query terminal size, fall back to 80 columns | Use `shutil.get_terminal_size()` with fallback |\n| Column Width Calculation | Dynamic split based on content + minimum readability | Reserve space for line numbers and separators |\n| Line Alignment | Match corresponding lines, insert blanks for unmatched | Complex alignment algorithm for deletions vs insertions |\n| Long Line Handling | Wrap lines within column boundaries | Preserve indentation and syntax highlighting |\n| Color Synchronization | Coordinate color schemes across both columns | Ensure consistent highlighting between sides |\n\n```python\nclass SideBySideFormatter(OutputFormatter):\n    def format_hunk_side_by_side(self, hunk: Hunk, column_width: int) -> List[str]:\n        \"\"\"Format hunk in side-by-side layout with proper alignment\"\"\"\n        # TODO 1: Calculate optimal column widths based on terminal size\n        # TODO 2: Align old and new lines, inserting blanks for unmatched content\n        # TODO 3: Handle long lines by wrapping within column boundaries\n        # TODO 4: Apply consistent color schemes to both columns\n        # TODO 5: Add separator column with change indicators\n```\n\nThe side-by-side formatter would also need to handle edge cases like very long lines, mixed content types, and terminal resizing during output generation.\n\n#### HTML Output with Interactive Features\n\n**Mental Model: Document Publishing**  \nThink of HTML diff output like converting a manuscript draft into a published article with interactive annotations. While command-line output serves developers working in terminals, HTML output serves broader audiences including project managers, documentation reviewers, and stakeholders who need to understand changes in a more accessible format.\n\nHTML output enables rich interactivity that's impossible in terminal displays: collapsible sections, syntax highlighting, inline comments, change summaries, and navigation aids. This transforms the diff from a developer tool into a communication medium.\n\nThe architecture would add an `HTMLFormatter` that generates self-contained HTML documents:\n\n| HTML Feature | Technical Implementation | User Benefit |\n|---|---|---|\n| Syntax Highlighting | Integration with Pygments or highlight.js | Improved code readability |\n| Collapsible Hunks | JavaScript accordions with CSS transitions | Focus on relevant changes |\n| Change Statistics | Summary panels with charts | Quick overview of modification scope |\n| Navigation Sidebar | Generated table of contents with anchor links | Easy movement through large diffs |\n| Inline Annotations | Hover tooltips and expandable comments | Additional context without clutter |\n| Export Options | Print-friendly CSS and PDF generation | Documentation and archival |\n\n```python\nclass HTMLFormatter(OutputFormatter):\n    def generate_interactive_diff(self, file1: FileContent, file2: FileContent, \n                                 hunks: List[Hunk]) -> str:\n        \"\"\"Generate complete HTML document with interactive diff features\"\"\"\n        # TODO 1: Generate HTML structure with navigation and content areas\n        # TODO 2: Apply syntax highlighting based on file extension detection\n        # TODO 3: Create collapsible hunk sections with JavaScript controls\n        # TODO 4: Add change statistics summary with visual indicators\n        # TODO 5: Include CSS for responsive design and print compatibility\n        # TODO 6: Embed JavaScript for interactive features without external dependencies\n```\n\nThe HTML formatter would generate self-contained documents that work offline and can be shared easily. Integration with existing syntax highlighting libraries would provide language-aware formatting that surpasses terminal capabilities.\n\n#### Integration with Version Control Systems\n\n**Mental Model: Native Git Citizen**  \nThink of VCS integration like making our diff tool a native speaker of Git's language rather than a foreign translator. Instead of just comparing two arbitrary files, the tool would understand repository context, branch relationships, commit history, and merge conflicts. This transforms it from a generic comparison tool into a specialized Git companion.\n\nVersion control integration opens up powerful workflows: comparing working directory against specific commits, analyzing changes across branch merges, generating release notes from commit ranges, and providing enhanced conflict resolution during merges.\n\n> **Decision: Git Protocol Integration**  \n> - **Context**: Developers primarily work within Git repositories where file comparison needs repository context  \n> - **Options Considered**: Shell wrapper scripts, native Git integration, separate VCS adapter layer  \n> - **Decision**: Implement VCS adapter pattern with Git as primary target, using libgit2 bindings  \n> - **Rationale**: Provides deep Git integration while maintaining extensibility for other VCS systems  \n> - **Consequences**: More complex dependency management but enables sophisticated repository-aware features\n\nThe implementation would add a `VCSAdapter` interface with Git-specific implementation:\n\n| VCS Feature | Implementation Approach | Diff Enhancement |\n|---|---|---|\n| Commit Range Comparison | Use libgit2 to traverse commit history | Compare any two points in project history |\n| Branch Diff Analysis | Identify merge bases and divergence points | Show changes unique to each branch |\n| Working Directory Integration | Monitor file status and staged changes | Compare working files against index or HEAD |\n| Merge Conflict Resolution | Parse conflict markers and provide 3-way diff | Enhanced conflict visualization |\n| Blame Integration | Correlate changes with commit authors and dates | Attribution information in diff output |\n| Submodule Awareness | Handle submodule boundary detection | Proper handling of nested repositories |\n\n```python\nclass GitAdapter(VCSAdapter):\n    def get_file_at_commit(self, filepath: str, commit_hash: str) -> FileContent:\n        \"\"\"Retrieve file content at specific commit for comparison\"\"\"\n        # TODO 1: Use libgit2 to access repository object database\n        # TODO 2: Resolve commit hash to tree object\n        # TODO 3: Navigate tree to find file blob\n        # TODO 4: Extract blob content with proper encoding detection\n        # TODO 5: Create FileContent with commit metadata\n    \n    def compare_commit_range(self, start_commit: str, end_commit: str, \n                           filepath: str) -> List[Hunk]:\n        \"\"\"Generate diff for file changes across commit range\"\"\"\n        # TODO 1: Validate commit range and file existence\n        # TODO 2: Retrieve file content at both commits\n        # TODO 3: Apply standard diff pipeline to historical content\n        # TODO 4: Annotate output with commit metadata\n```\n\nThe VCS integration would also enable advanced features like **change velocity analysis** (tracking how frequently different parts of files change over time) and **collaboration patterns** (identifying areas where multiple developers frequently make conflicting changes).\n\n#### Advanced Output Customization\n\n**Mental Model: Custom Report Generation**  \nThink of output customization like a newspaper editor who can present the same story as a front-page headline, detailed investigative piece, or statistical infographic depending on the audience and purpose. Different stakeholders need different levels of detail and different presentation formats from the same underlying diff analysis.\n\nAdvanced customization goes beyond simple formatting to include **content filtering**, **aggregation strategies**, and **presentation modes** tailored to specific workflows.\n\nThe architecture would support customizable output pipelines through a **template system** and **filter chain**:\n\n| Customization Type | Configuration Approach | Example Use Case |\n|---|---|---|\n| Content Filtering | YAML configuration files | Hide whitespace changes for code review |\n| Aggregation Rules | Python expressions for grouping | Summarize changes by file type or author |\n| Template Systems | Jinja2 templates for output format | Custom corporate report formats |\n| Notification Integration | Webhook and email template support | Automated change notifications |\n| Metrics Collection | Plugin system for change analysis | Code quality and complexity metrics |\n\n```python\nclass CustomizableOutputPipeline:\n    def apply_filter_chain(self, hunks: List[Hunk], \n                          filters: List[DiffFilter]) -> List[Hunk]:\n        \"\"\"Apply sequence of filters to diff output\"\"\"\n        # TODO 1: Load filter configuration from YAML or Python modules\n        # TODO 2: Apply each filter in sequence, allowing early termination\n        # TODO 3: Support filter parameterization and conditional application\n        # TODO 4: Maintain audit trail of applied filters\n    \n    def generate_from_template(self, template_name: str, \n                             diff_data: DiffData) -> str:\n        \"\"\"Generate output using specified template\"\"\"\n        # TODO 1: Load template from filesystem or embedded templates\n        # TODO 2: Prepare template context with diff statistics and metadata\n        # TODO 3: Apply template engine with safety restrictions\n        # TODO 4: Post-process output for format-specific requirements\n```\n\n### Implementation Strategy and Migration Path\n\nThe extension implementation follows a **progressive enhancement strategy** that maintains backward compatibility while enabling advanced features. Like adding floors to a building without disrupting the ground floor, each enhancement builds upon existing architecture without breaking current functionality.\n\n#### Phase 1: Algorithm Enhancement (3-4 weeks)\n1. Implement `StrategySelector` within existing `LCSEngine`\n2. Add Myers' algorithm as alternative computation strategy\n3. Create performance benchmarking suite to validate improvements\n4. Implement algorithm fallback mechanisms for edge cases\n\n#### Phase 2: Multi-Level Diffing (4-5 weeks)\n1. Develop `TokenizerEngine` for word and character level analysis\n2. Extend `DiffGenerator` with hierarchical diffing capabilities\n3. Enhance `DiffLine` data model to support nested change information\n4. Create unified API that maintains existing interface compatibility\n\n#### Phase 3: Output Format Extensions (3-4 weeks)\n1. Implement `SideBySideFormatter` with terminal width adaptation\n2. Develop `HTMLFormatter` with syntax highlighting integration\n3. Create template system for custom output formats\n4. Add format auto-detection based on output destination\n\n#### Phase 4: VCS Integration (5-6 weeks)\n1. Design `VCSAdapter` interface with Git implementation\n2. Integrate libgit2 bindings for repository access\n3. Implement commit range comparison and working directory integration\n4. Add merge conflict resolution enhancements\n\n⚠️ **Pitfall: Feature Creep Management**  \nThe abundance of possible enhancements can lead to **scope creep** where the simple diff tool becomes an overly complex Swiss Army knife. Each enhancement should be evaluated against core use cases and implemented as optional, configurable features that don't complicate the basic diff workflow. Maintain separate command-line flags and configuration options so users can opt into complexity rather than having it imposed.\n\n⚠️ **Pitfall: Performance Regression**  \nAdding multiple algorithms and output formats can introduce performance overhead even when advanced features aren't used. Implement **lazy loading** and **strategy selection** so that basic diff operations maintain their current performance characteristics. The `choose_strategy` method should default to simple approaches for small inputs and only engage complex algorithms when they provide clear benefits.\n\n⚠️ **Pitfall: Configuration Complexity**  \nAdvanced customization can create a configuration nightmare where users need extensive setup before the tool becomes useful. Design configuration with **smart defaults** and **progressive disclosure** — the tool should work well without any configuration, provide simple options for common customizations, and only expose complex configuration for power users who explicitly seek advanced capabilities.\n\n### Implementation Guidance\n\nThe future extensions leverage modern Python ecosystem capabilities while maintaining the educational value of the core implementation. The extensions are designed as **optional enhancements** that students can explore after mastering the fundamental concepts.\n\n#### Technology Recommendations\n\n| Extension Area | Simple Option | Advanced Option |\n|---|---|---|\n| HTML Generation | String templating with f-strings | Jinja2 template engine with Pygments syntax highlighting |\n| VCS Integration | subprocess calls to git command | pygit2 (libgit2 bindings) for native Git access |\n| Algorithm Selection | Simple if/else strategy selection | Strategy pattern with performance profiling |\n| Configuration | Command-line arguments only | YAML configuration files with schema validation |\n| Testing Extensions | Manual verification of output | Automated visual diff testing with image comparison |\n\n#### Recommended File Structure Enhancement\n\nThe extensions maintain the existing modular structure while adding specialized components:\n\n```\ndiff-tool/\n├── core/                    # Existing core components\n│   ├── file_reader.py\n│   ├── lcs_engine.py\n│   ├── diff_generator.py\n│   └── output_formatter.py\n├── algorithms/              # Algorithm implementations\n│   ├── __init__.py\n│   ├── lcs_traditional.py   # Current implementation\n│   ├── myers_algorithm.py   # Myers' diff algorithm\n│   └── strategy_selector.py # Algorithm selection logic\n├── formatters/              # Output format extensions\n│   ├── __init__.py\n│   ├── unified_formatter.py # Current implementation\n│   ├── side_by_side.py     # Side-by-side display\n│   ├── html_formatter.py   # HTML output with highlighting\n│   └── template_engine.py  # Custom template support\n├── vcs/                     # Version control integration\n│   ├── __init__.py\n│   ├── vcs_adapter.py      # Abstract VCS interface\n│   ├── git_adapter.py      # Git-specific implementation\n│   └── conflict_resolver.py # Enhanced merge conflict handling\n├── tokenizers/              # Multi-level diffing support\n│   ├── __init__.py\n│   ├── line_tokenizer.py   # Current line-based approach\n│   ├── word_tokenizer.py   # Word-level analysis\n│   └── semantic_tokenizer.py # AST-based semantic diffing\n├── config/                  # Configuration management\n│   ├── __init__.py\n│   ├── settings.py         # Configuration schema and defaults\n│   └── templates/          # Built-in output templates\n├── tests/\n│   ├── extensions/         # Tests for extension components\n│   ├── integration/        # End-to-end extension testing\n│   └── performance/        # Algorithm performance benchmarks\n└── examples/\n    ├── custom_templates/   # Example template configurations\n    └── vcs_integration/    # Git workflow examples\n```\n\n#### Algorithm Strategy Infrastructure\n\nThe strategy selection system provides a clean way to add new algorithms without breaking existing functionality:\n\n```python\n# algorithms/strategy_selector.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Tuple\nfrom ..core.data_model import Sequence, CommonSubsequence, MemoryStrategy\n\nclass DiffAlgorithm(ABC):\n    \"\"\"Abstract interface for different diff algorithms\"\"\"\n    \n    @abstractmethod\n    def compute_lcs(self, sequence1: Sequence, sequence2: Sequence) -> CommonSubsequence:\n        \"\"\"Compute longest common subsequence using this algorithm\"\"\"\n        pass\n    \n    @abstractmethod\n    def estimate_performance(self, seq1_len: int, seq2_len: int) -> Tuple[float, float]:\n        \"\"\"Return (time_factor, memory_mb) estimates for input size\"\"\"\n        pass\n\nclass StrategySelector:\n    \"\"\"Selects optimal diff algorithm based on input characteristics\"\"\"\n    \n    def __init__(self):\n        self.algorithms = {\n            'lcs_matrix': TraditionalLCSAlgorithm(),\n            'myers': MyersAlgorithm(),\n            'hirschberg': HirschbergAlgorithm()\n        }\n        self.performance_history = {}  # Track actual performance for tuning\n    \n    def choose_algorithm(self, seq1_len: int, seq2_len: int, \n                        memory_limit_mb: float = 1024.0) -> str:\n        \"\"\"Select best algorithm for given constraints\"\"\"\n        # TODO 1: Calculate performance estimates for each available algorithm\n        # TODO 2: Filter algorithms that exceed memory constraints\n        # TODO 3: Consider historical performance data for similar input sizes\n        # TODO 4: Apply user preferences and educational mode settings\n        # TODO 5: Return algorithm name with fallback to 'lcs_matrix'\n        \n        estimates = {}\n        for name, algorithm in self.algorithms.items():\n            time_factor, memory_mb = algorithm.estimate_performance(seq1_len, seq2_len)\n            if memory_mb <= memory_limit_mb:\n                estimates[name] = (time_factor, memory_mb)\n        \n        # Default to fastest algorithm that fits in memory\n        if not estimates:\n            return 'lcs_matrix'  # Fallback\n        \n        return min(estimates.keys(), key=lambda k: estimates[k][0])\n```\n\n#### HTML Output Infrastructure\n\nThe HTML formatter demonstrates how to create rich, interactive output while maintaining clean separation from core diff logic:\n\n```python\n# formatters/html_formatter.py\nfrom typing import List, Dict, Any\nimport html\nfrom ..core.data_model import FileContent, Hunk, DiffLine, LineType\n\nclass HTMLFormatter:\n    \"\"\"Generates interactive HTML diff displays\"\"\"\n    \n    def __init__(self, syntax_highlighting: bool = True, \n                 interactive_features: bool = True):\n        self.syntax_highlighting = syntax_highlighting\n        self.interactive_features = interactive_features\n        self.css_template = self._load_css_template()\n        self.js_template = self._load_js_template()\n    \n    def generate_diff_document(self, file1: FileContent, file2: FileContent, \n                             hunks: List[Hunk]) -> str:\n        \"\"\"Generate complete HTML document with embedded CSS and JavaScript\"\"\"\n        # TODO 1: Generate HTML document structure with metadata\n        # TODO 2: Embed CSS styles for diff formatting and responsive design\n        # TODO 3: Create navigation sidebar with hunk links\n        # TODO 4: Generate main diff content with syntax highlighting\n        # TODO 5: Add interactive JavaScript for collapsible sections\n        # TODO 6: Include print-friendly CSS media queries\n        \n        document_parts = [\n            self._generate_html_header(file1.filepath, file2.filepath),\n            self._generate_navigation_sidebar(hunks),\n            self._generate_diff_content(file1, file2, hunks),\n            self._generate_html_footer()\n        ]\n        \n        return '\\n'.join(document_parts)\n    \n    def _generate_diff_content(self, file1: FileContent, file2: FileContent, \n                             hunks: List[Hunk]) -> str:\n        \"\"\"Generate main diff content area with syntax highlighting\"\"\"\n        # TODO 1: Apply syntax highlighting based on file extension\n        # TODO 2: Create hunk sections with collapsible controls\n        # TODO 3: Format line numbers and change indicators\n        # TODO 4: Add hover tooltips for additional context\n        # TODO 5: Generate change statistics summary\n        pass\n    \n    def _apply_syntax_highlighting(self, content: str, language: str) -> str:\n        \"\"\"Apply syntax highlighting using Pygments or similar\"\"\"\n        # TODO 1: Detect language from file extension or content analysis\n        # TODO 2: Use Pygments to generate highlighted HTML\n        # TODO 3: Preserve diff markers and line structure\n        # TODO 4: Handle edge cases like mixed languages or plain text\n        pass\n```\n\n#### VCS Integration Foundation\n\nThe Git integration shows how to extend the diff tool with repository awareness:\n\n```python\n# vcs/git_adapter.py\nimport os\nimport subprocess\nfrom typing import Optional, List, Tuple\nfrom ..core.data_model import FileContent, DiffLine, Hunk\nfrom .vcs_adapter import VCSAdapter\n\nclass GitAdapter(VCSAdapter):\n    \"\"\"Git-specific version control integration\"\"\"\n    \n    def __init__(self, repository_path: str):\n        self.repo_path = repository_path\n        self.git_cmd = ['git', '-C', repository_path]\n    \n    def get_file_at_commit(self, filepath: str, commit_hash: str) -> Optional[FileContent]:\n        \"\"\"Retrieve file content at specific commit\"\"\"\n        # TODO 1: Validate that commit_hash exists in repository\n        # TODO 2: Use 'git show commit:filepath' to get file content\n        # TODO 3: Handle files that don't exist at specified commit\n        # TODO 4: Detect encoding and normalize line endings\n        # TODO 5: Create FileContent with commit metadata\n        \n        try:\n            result = subprocess.run(\n                self.git_cmd + ['show', f'{commit_hash}:{filepath}'],\n                capture_output=True, text=True, check=True\n            )\n            return self._create_file_content_from_git(filepath, result.stdout, commit_hash)\n        except subprocess.CalledProcessError:\n            return None\n    \n    def compare_working_directory(self, filepath: str, \n                                 against_commit: str = 'HEAD') -> List[Hunk]:\n        \"\"\"Compare working directory file against specified commit\"\"\"\n        # TODO 1: Get current working directory file content\n        # TODO 2: Get file content at specified commit\n        # TODO 3: Apply standard diff pipeline to compare versions\n        # TODO 4: Add Git-specific metadata to hunk headers\n        pass\n    \n    def get_merge_conflicts(self, filepath: str) -> List[Tuple[int, int, str]]:\n        \"\"\"Parse merge conflict markers and return conflict regions\"\"\"\n        # TODO 1: Read file and detect conflict markers (<<<<<<< ======= >>>>>>>)\n        # TODO 2: Parse conflict regions into (start_line, end_line, conflict_type)\n        # TODO 3: Extract 'ours', 'theirs', and 'base' content sections\n        # TODO 4: Return structured conflict information for enhanced resolution UI\n        pass\n```\n\n#### Milestone Checkpoints for Extensions\n\nEach extension area provides clear validation steps:\n\n**Algorithm Enhancement Checkpoint:**\n- Run: `python -m diff_tool --algorithm=myers large_file1.txt large_file2.txt`\n- Expected: Significantly faster execution on large files with similar content\n- Validation: Performance improvement of 50%+ for files >10MB with <10% changes\n- Debug check: Algorithm selection logging shows Myers' chosen for large inputs\n\n**HTML Output Checkpoint:**\n- Run: `python -m diff_tool --format=html file1.py file2.py > diff.html`\n- Expected: Self-contained HTML file with syntax highlighting and interactive features\n- Validation: Open diff.html in browser, verify collapsible hunks and color coding\n- Debug check: HTML validates and includes embedded CSS/JavaScript\n\n**VCS Integration Checkpoint:**\n- Run: `python -m diff_tool --git-compare HEAD~1 HEAD src/main.py`\n- Expected: Diff between current file and previous commit version\n- Validation: Output includes commit metadata and matches `git diff HEAD~1 HEAD src/main.py`\n- Debug check: Git repository detection and commit resolution working correctly\n\n#### Common Extension Pitfalls\n\n⚠️ **Pitfall: Algorithm Selection Overhead**  \nAdding multiple algorithms can introduce selection overhead that exceeds the benefits for small files. The strategy selector should cache performance characteristics and default to simple algorithms for inputs under 1000 lines. Measure actual selection time and ensure it's under 10ms for typical use cases.\n\n⚠️ **Pitfall: HTML Output Security**  \nWhen generating HTML output, especially with user-provided content, ensure proper HTML escaping to prevent XSS vulnerabilities. Use `html.escape()` for all user content and avoid generating JavaScript from user input. The HTML should be safe to open in any browser without security warnings.\n\n⚠️ **Pitfall: Git Dependency Management**  \nVCS integration can fail silently if Git isn't available or repository detection fails. Implement graceful degradation where VCS features are simply unavailable rather than causing tool failure. Provide clear error messages when Git operations fail and suggest fallback approaches.\n\n⚠️ **Pitfall: Configuration File Complexity**  \nAdvanced configuration options can overwhelm users and make the tool difficult to adopt. Design configuration with progressive disclosure: simple command-line flags for common options, optional configuration files for advanced users, and comprehensive defaults that work well without any configuration.\n\nThe extension architecture ensures that the diff tool can grow from a simple educational project into a sophisticated development tool while maintaining its core educational value and simplicity for basic use cases.\n\n\n## Glossary\n\n> **Milestone(s):** All milestones — comprehensive terminology reference supporting line tokenization (Milestone 1), LCS computation (Milestone 2), diff generation (Milestone 3), and CLI output (Milestone 4)\n\nThe diff tool implementation involves specialized terminology from multiple domains including dynamic programming, text processing, file system operations, and command-line interface design. This glossary provides precise definitions for all technical terms, algorithms, and domain-specific vocabulary used throughout the design document, organized to support both immediate reference during implementation and deeper understanding of the underlying concepts.\n\n### Core Algorithm Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **LCS** | Longest Common Subsequence algorithm using dynamic programming to find the longest sequence of elements that appear in the same order in both input sequences, though not necessarily consecutively | Core algorithm in Milestone 2 for finding matching lines between files before generating diff output |\n| **dynamic programming** | Algorithmic technique for solving optimization problems by building solutions from optimal subproblems, storing intermediate results to avoid recomputation | Foundation of LCS implementation in Milestone 2, where we build a matrix of optimal subsequence lengths |\n| **edit graph** | Graph representation where moves represent edit operations - horizontal moves are deletions, vertical moves are insertions, diagonal moves are matches | Conceptual model underlying Myers' algorithm and visualizing the relationship between sequences |\n| **edit distance** | Minimum number of operations needed to transform one sequence into another, typically counting insertions, deletions, and substitutions | Quantifies the difference between files and guides optimization decisions in diff generation |\n| **recurrence relation** | Mathematical relationship defining how optimal solutions to subproblems combine to form solutions to larger problems | Defines how LCS matrix cells are computed based on neighboring cells and sequence element matches |\n| **optimal substructure** | Property where optimal solutions to a problem contain optimal solutions to subproblems | Key property that makes dynamic programming applicable to LCS - optimal subsequences contain optimal shorter subsequences |\n| **backtracking** | Process of reconstructing the optimal solution by tracing backwards through the dynamic programming matrix | Used in Milestone 2 to recover the actual LCS from the completed matrix of lengths |\n| **tie-breaking rules** | Consistent handling of multiple valid LCS paths when backtracking through matrix cells with equal values | Ensures deterministic output when multiple equally valid longest common subsequences exist |\n\n### Text Processing and File Handling Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **encoding detection** | Process of determining the character encoding of a file by attempting to decode with common encodings like UTF-8 and Latin-1 | Essential in Milestone 1 for reading files correctly before line comparison can begin |\n| **line normalization** | Standardizing line endings, whitespace handling, and text structure while preserving meaningful content differences | Critical preprocessing step in Milestone 1 that affects all subsequent comparison accuracy |\n| **binary file detection** | Identifying non-text files that contain binary data and cannot be meaningfully diffed as text | Prevents encoding errors and provides appropriate error messages when comparing unsupported file types |\n| **trailing newline** | Final newline character at the end of a file, whose presence or absence can affect diff output | Common source of unexpected diff results that must be handled consistently across different editors and platforms |\n| **mixed line endings** | File containing multiple line ending types (LF, CRLF, CR) which may indicate file corruption or cross-platform editing | Detected during line normalization in Milestone 1 and can indicate data integrity issues requiring user attention |\n| **UTF-8** | Unicode encoding that can represent any character while maintaining ASCII compatibility | Primary encoding attempt in file reading, supporting international characters and modern text files |\n| **LATIN-1** | Single-byte character encoding covering Western European languages | Fallback encoding when UTF-8 decoding fails, ensuring maximum compatibility with legacy text files |\n| **LF** | Unix line ending character (0x0A) representing a single line feed | Standard line ending for Unix/Linux systems, requiring normalization for cross-platform compatibility |\n| **CRLF** | Windows line ending sequence (0x0D 0x0A) combining carriage return and line feed | Standard line ending for Windows systems, must be normalized to prevent false differences |\n| **CR** | Classic Mac line ending character (0x0D) representing a single carriage return | Legacy line ending from pre-OS X Mac systems, rarely encountered but must be handled for completeness |\n\n### Diff Format and Output Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **unified diff** | Standard diff output format using -/+ prefixes to mark deletions and additions, with context lines for readability | Target output format generated in Milestone 3, compatible with standard Unix diff tools and version control systems |\n| **context lines** | Unchanged lines displayed around changes to provide readability and help locate modifications within the file | Configurable feature in Milestone 4 that affects hunk formation and overall diff readability |\n| **hunk** | Group of consecutive changes with surrounding context lines, representing a logical block of modifications | Fundamental unit of diff output generated in Milestone 3, containing related changes grouped for human readability |\n| **edit script** | Sequence of ADD, DELETE, and UNCHANGED operations that transform one file into another | Intermediate representation in Milestone 3 that bridges between LCS results and formatted hunk output |\n| **one-indexed** | Line numbering convention starting at 1 rather than 0, used for human readability in diff output | Standard convention for diff format line numbers, requiring careful conversion from zero-indexed internal arrays |\n| **hunk header** | @@ line range markers showing the position and size of changes in both files using format @@old_start,old_count +new_start,new_count@@ | Essential component of unified diff format that allows diff consumers to locate and apply changes |\n| **file headers** | --- and +++ lines at the beginning of diff output that identify the compared files | Standard unified diff format requirement that provides context about which files are being compared |\n| **edit operations** | Classification of lines as ADD (inserted), DELETE (removed), or UNCHANGED (identical) | Core abstraction in Milestone 3 that represents the transformation between file versions |\n\n### Command-Line Interface and Display Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **ANSI color codes** | Terminal control sequences that format text with colors, bold, and other visual effects | Used in Milestone 4 to provide visual distinction between additions (green) and deletions (red) |\n| **TTY detection** | Determining whether output is directed to a terminal or being piped to a file or another program | Critical for deciding when to apply ANSI color codes - colors should only appear in interactive terminal sessions |\n| **exit codes** | Numeric values returned to the shell indicating program success (0) or failure (non-zero), with specific meanings | Standard convention where 0 indicates identical files and 1 indicates differences, used by scripts and automation |\n| **color mode** | Configuration setting controlling when ANSI color formatting is applied to output | Allows users to force color on/off regardless of TTY detection, important for testing and special terminal scenarios |\n| **side-by-side display** | Parallel presentation of both file versions showing changes in adjacent columns | Alternative output format that makes it easier to see before/after states of modified content |\n\n### Data Structure and Architecture Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **pipeline pattern** | Sequential processing architecture where data flows through distinct stages with well-defined interfaces | Architectural approach used for FileReader → LCSEngine → DiffGenerator → OutputFormatter flow |\n| **message-passing interface** | Communication pattern where components interact through standardized method calls rather than shared state | Ensures clean separation between components and makes testing individual components easier |\n| **fail-fast strategy** | Design principle of detecting and reporting errors immediately rather than allowing invalid state to propagate | Implemented throughout error handling to provide clear diagnostics and prevent cascading failures |\n| **contextual error propagation** | Preserving error context and adding relevant information as errors bubble up through component layers | Ensures that error messages include enough context for users to understand and fix problems |\n| **progressive enhancement** | Design approach that starts with basic functionality and adds advanced features without breaking core behavior | Guides the milestone progression from basic line comparison to advanced output formatting |\n\n### Performance and Memory Management Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **memory optimization** | Techniques to reduce space complexity for large inputs, such as using only two matrix rows instead of full matrix storage | Essential for handling large files in LCS computation without exhausting system memory |\n| **Hirschberg's algorithm** | Space-efficient LCS algorithm using divide-and-conquer approach that achieves O(m+n) space complexity | Advanced optimization considered for very large file comparison when standard O(mn) approach fails |\n| **memory exhaustion** | Condition where the algorithm attempts to allocate more memory than available, causing program failure | Primary risk when comparing large files using standard LCS matrix approach |\n| **resource limit enforcement** | Preventing operations from exceeding system constraints through monitoring and early termination | Safety mechanism to prevent system instability when processing unexpectedly large inputs |\n| **graceful degradation** | System behavior that maintains partial functionality when encountering resource constraints or errors | Design principle ensuring the tool provides useful output even when optimal algorithms cannot complete |\n\n### Implementation and Testing Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **edge cases** | Boundary conditions and unusual input scenarios that test the limits of algorithm correctness | Include empty files, identical files, files with no common lines, and files exceeding memory limits |\n| **off-by-one indexing** | Common programming error involving incorrect array bounds or counting, especially critical in matrix operations | Frequent source of bugs in LCS matrix construction and line number calculations for diff output |\n| **hunk validation** | Ensuring diff hunk consistency by verifying that line counts match actual content and ranges are correct | Quality assurance step that catches bugs in diff generation before output formatting |\n| **milestone checkpoints** | Validation steps after completing each implementation stage to verify correct behavior before proceeding | Structured testing approach ensuring each component works correctly before building dependent components |\n| **property-based testing** | Automated test generation that verifies algorithmic properties across many random inputs | Advanced testing strategy for validating LCS properties like optimality and consistency across different inputs |\n| **matrix inspection** | Debugging technique involving visualization and validation of LCS dynamic programming matrices | Essential debugging tool for understanding why LCS algorithms produce unexpected results |\n| **round-trip testing** | End-to-end verification that the complete pipeline preserves information and produces consistent results | Comprehensive testing approach ensuring the diff tool works correctly in real-world usage scenarios |\n\n### Algorithm Complexity and Optimization Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **O(mn) time complexity** | Algorithmic performance characteristic where execution time grows proportionally to the product of input sizes | Standard LCS algorithm performance - comparing files with m and n lines requires m×n operations |\n| **O(mn) space complexity** | Memory usage that grows proportionally to the product of input sizes due to storing the full LCS matrix | Memory limitation that necessitates optimization techniques for large file comparison |\n| **matrix** | Standard LCS algorithm using full O(mn) space to store complete dynamic programming table | Default implementation providing full algorithm transparency and debugging capability |\n| **two_row** | Space optimization that uses only two matrix rows, reducing space complexity to O(min(m,n)) | First-level optimization that significantly reduces memory usage while maintaining algorithm simplicity |\n| **hirschberg** | Advanced space optimization using divide-and-conquer to achieve O(m+n) space complexity | Most advanced optimization for handling very large files when even two-row optimization insufficient |\n\n### Error Classification and Handling Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **ERROR_CODE** | Standardized error classification system enabling programmatic error handling and user guidance | Structured approach to error handling that provides specific error codes for different failure categories |\n| **FileSystemError** | Error category for file access problems including missing files, permission issues, and I/O failures | Handles failures in Milestone 1 file reading operations with appropriate error messages and suggestions |\n| **EncodingError** | Error category for character encoding detection and conversion failures | Addresses text decoding problems in Milestone 1 when files contain invalid character sequences |\n| **AlgorithmError** | Error category for computational problems including matrix overflow and infinite loops | Covers failures in Milestone 2 LCS computation when algorithm encounters unexpected conditions |\n| **ResourceError** | Error category for memory exhaustion, timeout, and system resource limitations | Prevents system instability when processing very large files exceeds available resources |\n| **OutputError** | Error category for formatting and display problems including ANSI code issues and file write failures | Handles problems in Milestone 4 output generation and CLI interface operations |\n\n### Development and Extension Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **scope creep** | Uncontrolled expansion of project requirements that adds complexity without corresponding learning benefit | Avoided through clear non-goals definition and focus on core diff algorithm learning objectives |\n| **lazy loading** | Design pattern that delays component initialization until actually needed, improving startup time and memory usage | Optimization strategy for loading heavyweight components like syntax highlighters only when required |\n| **smart defaults** | Configuration that works well for most users without requiring manual setup or deep understanding | User experience principle ensuring the tool is immediately useful while supporting advanced customization |\n| **progressive disclosure** | Interface design that reveals advanced features gradually rather than overwhelming users with options | Guides CLI design to present essential options prominently while making advanced features discoverable |\n| **algorithm fallback** | Graceful degradation strategy where simpler algorithms are used when preferred approaches fail | Ensures reliability by providing backup computation strategies when resource-intensive algorithms cannot complete |\n\n### Advanced Features and Algorithms Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **Myers algorithm** | Efficient diff algorithm with O(n+d²) expected performance where d is the edit distance between sequences | Advanced algorithm suitable for future extension when basic LCS approach proves insufficient for large files |\n| **hierarchical diffing** | Multi-level analysis that compares files at different granularities from lines to words to characters | Extension capability that can provide more precise diff information by analyzing changes at multiple levels |\n| **semantic diffing** | Comparing code meaning rather than text representation by operating on abstract syntax trees | Advanced feature for code-aware diffing that understands programming language structure rather than treating code as plain text |\n| **VCS integration** | Version control system awareness allowing the diff tool to work with Git, SVN, and other repositories | Extension path that enables the tool to compare file versions across commits and branches |\n| **strategy selection** | Algorithm that chooses optimal diff approach based on input characteristics like file size and available memory | Intelligent system that automatically selects the best algorithm variant for given constraints |\n\n### Data Structure and Type System Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **Sequence** | Type alias for List[str] representing an ordered collection of lines for comparison | Fundamental type used throughout LCS computation and diff generation for consistent sequence handling |\n| **CommonSubsequence** | Data structure containing the actual LCS elements along with their positions in both original sequences | Result type from LCS computation that provides both the subsequence and positional information for diff generation |\n| **EditDistance** | Quantitative measure of file differences including counts of insertions, deletions, unchanged lines, and total operations | Provides statistical summary of changes that can guide performance optimization and user feedback |\n| **DiffLine** | Representation of a single line in the diff output with content, type classification, and line numbers from both files | Core data structure in Milestone 3 that bridges between algorithm output and formatted display |\n| **LineType** | Enumeration distinguishing between UNCHANGED, ADDED, and DELETED lines in the diff output | Type safety mechanism ensuring consistent handling of different line classifications throughout the pipeline |\n| **Hunk** | Structured representation of a group of changes with context, including line ranges and formatting information | Primary output unit in Milestone 3 that packages related changes with sufficient context for human readability |\n| **FileContent** | Complete representation of a file including filepath, lines, metadata, and encoding information | Comprehensive file abstraction from Milestone 1 that carries all necessary information through the diff pipeline |\n\n### Performance Monitoring and Resource Management Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **MemoryStrategy** | Configuration object specifying algorithm choice, memory limits, and performance trade-offs for LCS computation | Enables intelligent selection between different algorithm variants based on available resources and input size |\n| **ComputationStats** | Performance metrics including execution time, memory usage, matrix dimensions, and algorithm selection | Provides detailed performance information for optimization and debugging of LCS computation |\n| **PerformanceMonitor** | Component that tracks resource usage and execution statistics across different algorithm phases | Enables performance analysis and resource limit enforcement during expensive dynamic programming operations |\n| **ResourceMonitor** | System that enforces memory and time limits to prevent resource exhaustion during large file processing | Safety mechanism that prevents system instability when processing unexpectedly large inputs |\n| **MAX_SAFE_LINES** | Constant defining maximum line count to prevent integer overflow and memory exhaustion | Practical limit that guides when to apply memory optimizations or reject inputs as too large |\n\n### Command-Line Interface and User Experience Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **DiffArguments** | Container for parsed command-line arguments including file paths, context settings, and formatting options | Central configuration object in Milestone 4 that controls all aspects of diff tool behavior |\n| **ColorMode** | Enumeration controlling when ANSI color codes are applied to output (always, never, auto based on TTY) | User preference system in Milestone 4 that balances visual enhancement with compatibility requirements |\n| **ColorFormatter** | Utility class providing ANSI color code helpers for terminal text formatting | Encapsulates color handling logic in Milestone 4, supporting both colored and plain text output modes |\n\n### Architecture and Design Pattern Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **PipelineContext** | Execution context tracking current processing stage and progress for monitoring and error reporting | Provides visibility into diff tool execution progress and helps with debugging when operations fail |\n| **PipelineError** | Exception type that preserves context information about where and why pipeline processing failed | Structured error handling that maintains enough information for meaningful error messages and debugging |\n| **DiffPipeline** | Main coordinator component that orchestrates the flow from file reading through LCS computation to formatted output | Central control component that manages the interaction between FileReader, LCSEngine, DiffGenerator, and OutputFormatter |\n\n### Debugging and Development Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **MatrixVisualizer** | Debugging utility that generates formatted display of LCS matrices with sequence headers for inspection | Essential debugging tool for understanding LCS algorithm behavior and diagnosing incorrect results |\n| **BacktrackTracer** | Debugging component that logs detailed information about backtracking decisions and path selection | Helps diagnose issues with LCS reconstruction by providing step-by-step trace of algorithm decisions |\n| **DebugLCSEngine** | Enhanced LCS engine with additional debugging capabilities including matrix inspection and validation | Development tool that extends basic LCS engine with comprehensive debugging features for learning and troubleshooting |\n| **algorithm execution tracing** | Step-by-step logging of algorithm decision-making process including matrix construction and backtracking | Debugging technique that provides detailed visibility into how the LCS algorithm processes input sequences |\n| **output format validation** | Verification that generated diff output conforms to standard unified diff format requirements | Quality assurance process ensuring compatibility with existing tools and systems that consume diff output |\n\n### Memory Management and Optimization Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **memory exhaustion** | Condition where algorithm memory requirements exceed available system resources | Primary failure mode for large file comparison that necessitates algorithm selection and resource monitoring |\n| **space-time trade-off** | Algorithm design decision balancing memory usage against computational complexity | Fundamental consideration in choosing between different LCS implementation strategies |\n| **memory-efficient backtracking** | Techniques for reconstructing LCS without storing the complete matrix | Advanced optimization that enables LCS computation for very large files |\n| **incremental processing** | Strategy of processing input in chunks rather than loading entire files into memory | Potential optimization for handling files larger than available system memory |\n\n### Future Extension and Advanced Feature Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **Token** | Granular unit of text (character, word, line) that serves as the basic comparison element | Abstraction that enables hierarchical diffing by supporting different levels of text granularity |\n| **TokenizerEngine** | Component responsible for splitting text into meaningful comparison units based on selected granularity | Enables word-level and character-level diffing as extensions beyond basic line-based comparison |\n| **HierarchicalDiffGenerator** | Extended diff generator that analyzes changes at multiple levels of granularity | Advanced feature that can provide more detailed change analysis by examining lines, words, and characters |\n| **SemanticDiffEngine** | Diff engine that operates on abstract syntax trees rather than raw text | Code-aware diffing capability that understands programming language structure |\n| **SideBySideFormatter** | Output formatter that presents changes in parallel columns rather than unified format | Alternative display format that makes before/after comparison more intuitive for human readers |\n| **HTMLFormatter** | Output formatter that generates interactive web-based diff displays | Rich output format supporting folding, syntax highlighting, and interactive navigation |\n| **VCSAdapter** | Abstract interface enabling integration with version control systems | Extension point for comparing file versions across commits and branches |\n| **StrategySelector** | Component that analyzes input characteristics and selects optimal algorithm variant | Intelligent system that automatically chooses the best approach based on file size, available memory, and performance requirements |\n\n### Quality Assurance and Validation Terms\n\n| Term | Definition | Context in Project |\n|------|------------|-------------------|\n| **hunk consistency validation** | Verification that hunk line counts accurately reflect the contained changes | Quality assurance check that prevents malformed diff output |\n| **LCS property verification** | Testing that computed longest common subsequences satisfy mathematical correctness properties | Ensures algorithm implementation correctness through property-based validation |\n| **format compliance checking** | Validation that generated output conforms to standard unified diff format specifications | Compatibility assurance ensuring output works with existing tools and systems |\n| **cross-platform compatibility** | Ensuring consistent behavior across different operating systems and terminal environments | Critical requirement for a generally useful diff tool |\n\nThis comprehensive glossary serves as both a reference during implementation and a learning resource for understanding the deeper concepts behind text comparison algorithms. Each term is defined with sufficient detail to understand its role in the overall system while maintaining connections to the specific milestones where these concepts become practically important.\n\nThe terminology spans from fundamental computer science concepts like dynamic programming and algorithmic complexity to practical implementation concerns like file encoding and terminal color handling. Understanding these terms and their relationships is essential for successfully implementing a robust diff tool that handles real-world text comparison scenarios effectively.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| CLI Parsing | `argparse` module with basic argument handling | `click` library with rich help formatting and command groups |\n| File I/O | `open()` with try/except encoding detection | `pathlib` with `chardet` library for robust encoding detection |\n| ANSI Colors | String constants with manual concatenation | `colorama` library for cross-platform color support |\n| Performance Monitoring | Simple time/memory measurement | `memory_profiler` and `cProfile` for detailed analysis |\n| Testing Framework | Built-in `unittest` module | `pytest` with fixtures and parameterized testing |\n\n**B. Recommended Project Structure:**\n\n```\ndiff-tool/\n├── src/\n│   ├── __init__.py\n│   ├── main.py                 # CLI entry point and argument parsing\n│   ├── data_model.py           # Core types and data structures\n│   ├── file_reader.py          # FileReader component\n│   ├── lcs_engine.py           # LCS computation and optimization\n│   ├── diff_generator.py       # Edit operations and hunk formation\n│   ├── output_formatter.py     # Unified diff formatting and colors\n│   ├── error_handling.py       # Error types and handling utilities\n│   └── utils/\n│       ├── __init__.py\n│       ├── colors.py           # ANSI color utilities\n│       ├── performance.py      # Performance monitoring\n│       └── validation.py       # Data validation helpers\n├── tests/\n│   ├── __init__.py\n│   ├── test_file_reader.py\n│   ├── test_lcs_engine.py\n│   ├── test_diff_generator.py\n│   ├── test_output_formatter.py\n│   └── fixtures/               # Test files with various encodings\n│       ├── utf8_sample.txt\n│       ├── latin1_sample.txt\n│       └── binary_sample.bin\n├── docs/\n│   ├── design_document.md\n│   └── api_reference.md\n├── requirements.txt\n├── setup.py\n└── README.md\n```\n\n**C. Infrastructure Starter Code:**\n\n**File: `src/utils/colors.py`** (Complete ANSI color utilities)\n```python\nimport os\nimport sys\nfrom enum import Enum\n\nclass ColorMode(Enum):\n    \"\"\"Controls when ANSI color codes are applied to output.\"\"\"\n    AUTO = \"auto\"      # Color when output is to TTY\n    ALWAYS = \"always\"  # Force color regardless of output\n    NEVER = \"never\"    # Never use color\n\n# ANSI color constants\nRED = \"\\033[31m\"\nGREEN = \"\\033[32m\"\nBOLD = \"\\033[1m\"\nDIM = \"\\033[2m\"\nRESET = \"\\033[0m\"\n\nclass ColorFormatter:\n    \"\"\"ANSI color helper with TTY detection and mode control.\"\"\"\n    \n    def __init__(self, color_mode: ColorMode = ColorMode.AUTO):\n        self.color_mode = color_mode\n        self._color_enabled = self._determine_color_enabled()\n    \n    def _determine_color_enabled(self) -> bool:\n        \"\"\"Determine if color should be enabled based on mode and TTY detection.\"\"\"\n        if self.color_mode == ColorMode.NEVER:\n            return False\n        elif self.color_mode == ColorMode.ALWAYS:\n            return True\n        else:  # AUTO mode\n            return sys.stdout.isatty() and os.getenv('NO_COLOR') is None\n    \n    def red(self, text: str) -> str:\n        \"\"\"Format text with red ANSI codes if color enabled.\"\"\"\n        if self._color_enabled:\n            return f\"{RED}{text}{RESET}\"\n        return text\n    \n    def green(self, text: str) -> str:\n        \"\"\"Format text with green ANSI codes if color enabled.\"\"\"\n        if self._color_enabled:\n            return f\"{GREEN}{text}{RESET}\"\n        return text\n    \n    def bold(self, text: str) -> str:\n        \"\"\"Format text with bold ANSI codes if color enabled.\"\"\"\n        if self._color_enabled:\n            return f\"{BOLD}{text}{RESET}\"\n        return text\n    \n    def is_color_enabled(self) -> bool:\n        \"\"\"Check if color output is currently enabled.\"\"\"\n        return self._color_enabled\n```\n\n**File: `src/utils/performance.py`** (Complete performance monitoring)\n```python\nimport time\nimport psutil\nfrom dataclasses import dataclass\nfrom typing import Dict, Optional, Tuple, Any\n\n@dataclass\nclass PerformanceStats:\n    \"\"\"Performance statistics for a specific algorithm phase.\"\"\"\n    start_time: float\n    end_time: Optional[float] = None\n    peak_memory_mb: float = 0.0\n    operations_count: int = 0\n    matrix_size: Tuple[int, int] = (0, 0)\n    algorithm_phase: str = \"\"\n\nclass PerformanceMonitor:\n    \"\"\"Monitors and reports performance statistics for diff operations.\"\"\"\n    \n    def __init__(self):\n        self.stats: Dict[str, PerformanceStats] = {}\n        self.current_phase: Optional[str] = None\n        self._process = psutil.Process()\n    \n    def start_phase(self, phase_name: str, matrix_size: Tuple[int, int] = (0, 0)) -> None:\n        \"\"\"Begin monitoring a specific algorithm phase.\"\"\"\n        self.current_phase = phase_name\n        self.stats[phase_name] = PerformanceStats(\n            start_time=time.time(),\n            matrix_size=matrix_size,\n            algorithm_phase=phase_name\n        )\n    \n    def end_phase(self) -> None:\n        \"\"\"Complete monitoring of current phase.\"\"\"\n        if self.current_phase and self.current_phase in self.stats:\n            stats = self.stats[self.current_phase]\n            stats.end_time = time.time()\n            stats.peak_memory_mb = self._get_memory_usage_mb()\n            self.current_phase = None\n    \n    def record_operation(self, count: int = 1) -> None:\n        \"\"\"Record completion of algorithm operations.\"\"\"\n        if self.current_phase and self.current_phase in self.stats:\n            self.stats[self.current_phase].operations_count += count\n    \n    def _get_memory_usage_mb(self) -> float:\n        \"\"\"Get current process memory usage in MB.\"\"\"\n        return self._process.memory_info().rss / (1024 * 1024)\n    \n    def get_report(self) -> Dict[str, Any]:\n        \"\"\"Generate comprehensive performance report.\"\"\"\n        report = {}\n        for phase_name, stats in self.stats.items():\n            duration = (stats.end_time - stats.start_time) if stats.end_time else 0\n            report[phase_name] = {\n                'duration_seconds': duration,\n                'peak_memory_mb': stats.peak_memory_mb,\n                'operations_count': stats.operations_count,\n                'matrix_size': stats.matrix_size,\n                'ops_per_second': stats.operations_count / duration if duration > 0 else 0\n            }\n        return report\n```\n\n**File: `src/utils/validation.py`** (Complete validation utilities)\n```python\nfrom typing import List, Optional\nimport re\n\ndef validate_hunk_consistency(hunk) -> bool:\n    \"\"\"Verify that hunk line counts match actual content.\"\"\"\n    # Count actual additions and deletions in hunk lines\n    actual_deletions = sum(1 for line in hunk.lines if line.line_type.value == \"DELETED\")\n    actual_additions = sum(1 for line in hunk.lines if line.line_type.value == \"ADDED\")\n    actual_unchanged = sum(1 for line in hunk.lines if line.line_type.value == \"UNCHANGED\")\n    \n    # Calculate expected counts from hunk header\n    expected_old_count = hunk.old_count\n    expected_new_count = hunk.new_count\n    \n    # Validate that header counts match actual line content\n    calculated_old = actual_deletions + actual_unchanged\n    calculated_new = actual_additions + actual_unchanged\n    \n    return (calculated_old == expected_old_count and \n            calculated_new == expected_new_count)\n\ndef normalize_line_endings(content: str) -> Tuple[str, str]:\n    \"\"\"Normalize line endings and detect original format.\"\"\"\n    # Detect original line ending format\n    if '\\r\\n' in content:\n        original_ending = 'CRLF'\n    elif '\\r' in content:\n        original_ending = 'CR'\n    elif '\\n' in content:\n        original_ending = 'LF'\n    else:\n        original_ending = 'NONE'\n    \n    # Normalize to LF\n    normalized = content.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    return normalized, original_ending\n\ndef split_preserving_empty_lines(content: str) -> List[str]:\n    \"\"\"Split content into lines while preserving empty lines in sequence.\"\"\"\n    if not content:\n        return []\n    \n    # Split on normalized line endings\n    lines = content.split('\\n')\n    \n    # Handle trailing newline - if content ends with newline,\n    # split will create an empty string at the end that we should remove\n    if content.endswith('\\n') and lines and lines[-1] == '':\n        lines.pop()\n    \n    return lines\n\ndef detect_binary_content(content: bytes, sample_size: int = 8192) -> bool:\n    \"\"\"Detect if file content appears to be binary rather than text.\"\"\"\n    # Check first sample_size bytes for null bytes or high percentage of non-printable chars\n    sample = content[:sample_size]\n    \n    # Presence of null bytes strongly indicates binary content\n    if b'\\x00' in sample:\n        return True\n    \n    # Count printable ASCII and common extended characters\n    printable_count = sum(1 for byte in sample \n                         if (32 <= byte <= 126) or byte in (9, 10, 13))\n    \n    # If less than 95% printable characters, likely binary\n    if len(sample) > 0:\n        printable_ratio = printable_count / len(sample)\n        return printable_ratio < 0.95\n    \n    return False\n```\n\n**D. Core Logic Skeleton Code:**\n\n**File: `src/data_model.py`** (Core types with method skeletons)\n```python\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Tuple\n\nclass LineType(Enum):\n    \"\"\"Classification of lines in diff output.\"\"\"\n    UNCHANGED = \"UNCHANGED\"\n    ADDED = \"ADDED\" \n    DELETED = \"DELETED\"\n\n@dataclass\nclass DiffLine:\n    \"\"\"Represents a single line in diff output with metadata.\"\"\"\n    content: str\n    line_type: LineType\n    old_line_num: Optional[int]\n    new_line_num: Optional[int]\n    \n    def format_unified_diff_line(self) -> str:\n        \"\"\"Format line with appropriate unified diff prefix.\"\"\"\n        # TODO 1: Get prefix character for line type (space, +, -)\n        # TODO 2: Combine prefix with line content\n        # TODO 3: Handle lines that don't end with newline\n        pass\n    \n    def is_change(self) -> bool:\n        \"\"\"Returns True for ADD or DELETE lines.\"\"\"\n        # TODO 1: Check if line_type is ADDED or DELETED\n        # TODO 2: Return False for UNCHANGED lines\n        pass\n\n@dataclass  \nclass Hunk:\n    \"\"\"Group of consecutive changes with surrounding context.\"\"\"\n    old_start: int\n    old_count: int\n    new_start: int\n    new_count: int\n    lines: List[DiffLine]\n    context_before: int\n    context_after: int\n    \n    def format_hunk_header(self) -> str:\n        \"\"\"Generate @@ header line for unified diff format.\"\"\"\n        # TODO 1: Format old file range as start,count\n        # TODO 2: Format new file range as +start,count  \n        # TODO 3: Combine into @@ -old_range +new_range @@\n        # TODO 4: Handle special case where count is 1 (omit ,1)\n        pass\n```\n\n**E. Language-Specific Implementation Hints:**\n\n- **File Encoding**: Use `open(filepath, 'r', encoding='utf-8')` first, catch `UnicodeDecodeError` and retry with `encoding='latin-1'`\n- **Memory Monitoring**: Use `psutil.Process().memory_info().rss` to get current memory usage in bytes\n- **Cross-Platform Paths**: Use `pathlib.Path` instead of string concatenation for file path handling\n- **ANSI Color Detection**: Check `sys.stdout.isatty()` and absence of `NO_COLOR` environment variable\n- **Matrix Operations**: Use list comprehensions for matrix initialization: `[[0 for _ in range(n)] for _ in range(m)]`\n- **Error Context**: Use `try/except` blocks that catch specific exceptions and re-raise with additional context\n- **String Comparison**: Use `==` for exact line matching - Python handles Unicode comparison correctly\n- **Performance Timing**: Use `time.perf_counter()` for high-resolution timing measurements\n\n**F. Milestone Checkpoint Verification:**\n\n| Milestone | Command to Run | Expected Output | Manual Verification |\n|-----------|---------------|-----------------|-------------------|\n| 1: Line Tokenization | `python -m pytest tests/test_file_reader.py -v` | All file reading tests pass | Create test files with different encodings, run `detect_file_encoding()` |\n| 2: LCS Algorithm | `python -m pytest tests/test_lcs_engine.py -v` | LCS computation tests pass with correct subsequences | Compare simple text files manually, verify LCS makes sense |\n| 3: Diff Generation | `python -m pytest tests/test_diff_generator.py -v` | Hunk generation tests pass with proper context | Generate diff for known files, check hunk boundaries and line numbers |\n| 4: CLI Integration | `python src/main.py file1.txt file2.txt` | Colored diff output in unified format | Test with `--no-color` flag, verify exit codes with `echo $?` |\n\n**G. Common Implementation Patterns:**\n\n```python\n# Error handling with context preservation\ntry:\n    lines = read_file_lines(filepath)\nexcept UnicodeDecodeError as e:\n    raise EncodingError(\n        f\"Cannot decode file {filepath}\",\n        context={\"filepath\": filepath, \"encoding_attempts\": [\"utf-8\", \"latin-1\"]},\n        suggestion=\"File may be binary or use unsupported encoding\"\n    )\n\n# Resource monitoring pattern\nmonitor = ResourceMonitor(memory_limit_mb=512, time_limit_seconds=30)\nmonitor.start_monitoring()\ntry:\n    result = expensive_operation()\n    if error := monitor.check_limits():\n        raise error\n    return result\nfinally:\n    stats = monitor.get_stats()\n    \n# Safe matrix construction with memory estimation\ndef estimate_matrix_memory(rows: int, cols: int) -> float:\n    \"\"\"Estimate LCS matrix memory requirements in MB.\"\"\"\n    # Each cell stores an integer (typically 8 bytes on 64-bit systems)\n    bytes_needed = rows * cols * 8\n    return bytes_needed / (1024 * 1024)\n```\n"}